{"title": "A Framework for Mining Collectively-Behaving Bots in MMORPGs", "authors": ["Hyunsoo Kim", "Jun Hee Kim", "Jaeman Son", "Jihoon Song", "Eunjo Lee"], "abstract": "In MMORPGs (Massively Multiplayer Online Role-Playing Games), abnormal players (bots) using unauthorized automated programs to carry out pre-defined behaviors systematically and repeatedly are commonly observed. Bots usually engage in these activities to gain in-game money, which they eventually trade for real money outside the game. Such abusive activities negatively impact the in-game experiences of legitimate users since bots monopolize specific hunting areas and obtain valuable items. Thus, detecting abnormal players is a significant task for game companies. Motivated by the fact that bots tend to behave collectively with similar in-game trajectories due to the auto-programs, we developed BotTRep, a framework that comprises trajectory representation learning followed by clustering using a completely unlabeled in-game trajectory dataset. Our model aims to learn representations for in-game trajectory sequences so that players with contextually similar trajectories have closer embeddings. Then, by applying DBSCAN to these representations and visualizing the corresponding moving patterns, our framework ultimately assists game masters in identifying and banning bots.", "sections": [{"title": "1 Introduction", "content": "In MMORPGs (Massively Multiplayer Online Role-Playing Games), player ac- tivities naturally generate diverse patterns, similar to those in the real world. They can undertake various tasks individually or with others. Furthermore, there are groups within the game that carry out activities with malicious intent, as in the real world. The collective behaviors of bots, which exhibit abnormal gaming efficiency due to auto-programs, negatively impact the in-game experiences of regular players. Bots not only monopolize many aspects of the game but also participate in real money trading, which disrupts the in-game economy [8,12]. In this study, we introduce a framework for mining collectively-behaving bots, one of the most prevalent forms of abuse in MMORPGs inspired by moving- together patterns in the real world [2,3,7,13,21,23,24,31]. However, the collectively- behaving groups we aim to identify differ from real-world patterns due to the"}, {"title": "2 Background", "content": null}, {"title": "2.1 Trajectory data mining for real world tasks", "content": "Related works There are various research fields and applications in trajectory data mining [3,4,6,13,21,23,24,25,27,28,29,32,33]. Even though our research aligns closely with studies such as [13,21,24], we had to design a new mechanism because our research objectives differ from those of trajectory mining in two key aspects."}, {"title": "3 Proposed Approach", "content": null}, {"title": "3.1 Preliminary", "content": "Defining areas In this section, we introduce three geographical terms to distinguish areas in the game world: continent, zone, and cell. A continent is the largest area category, classified by whether players can move on foot or need to use a portal or teleport. For example, islands and instance dungeons are treated as separate continents. We define zones by dividing continents into multiple areas, each sized at 256 by 256 coordinates, as shown in Fig. 2. Similarly, zones contain several cells, each sized at 8 by 8 coordinates. In Lineage W, players can move about 256 coordinates per minute. The main continent measures 2048 by 2048 coordinates, and there are over 100 continents, including islands and instance dungeons, each sized between 256 by 256 and 512 by 512. When logging location coordinates in the game, the unique continent ID where the player was located at each timestamp and the detailed coordinates within that continent are recorded. Our model is trained by zone and cell tokens, which provide spatial information. Zones offer abstract representations for larger areas, while cells provide specific details for smaller areas. Training the model with only zone tokens reduces the out-of-vocabulary issue but hampers its ability to distinguish between different trajectories. Conversely, training with only cell tokens allows discrimination between trajectories but leads to the out-of-vocabulary problem and unstable convergence in model training. We determined the appropriate criteria empirically during model design. We recommend setting the width and height of a zone to be half the size of an instance dungeon to prevent tokens from being overly abstracted. The width and height of a cell should be approximately the range of a ranged character, such as a mage or archer. This ensures that the movement of ranged characters, as well as groups of both ranged and melee characters, can be detected more precisely. The definition of collectively-behaving bots As outlined earlier, our goal is to detect collectively behaving bots as accurately and extensively as possible. The"}, {"title": "3.2 Data preparation", "content": "Traning dataset The game logs we used in this work consist of coordinates and timestamp logs sampled at one-minute intervals. This means that if a user played the game for an entire day, we would sample 1,440 logs-one for each minute of the day. As mentioned earlier, the game logs we aim to train on are significantly lengthy. Consequently, instead of feeding the entire log sequence into the model for training, we have preprocessed the structure of the input data to ensure the model can effectively learn the relationships between contextually close cells appearing in each sequence. To achieve this, we extract a data point in the training dataset based on the following rules:\n1. Collect data for all locations where players have visited on a daily basis.\n2. Utilize the collected coordinates logs to generate tokens for zones and cells.\n3. Construct a sequence using the generated zone and cell tokens, ensuring that neighboring cells within the sequence are not identical, to include various local information within a sequence.\n4. Split the sequence into multiple data points, each with a length of 32.\n5. Reorganize the preprocessed data with a length of 32 into triplet formats in two modes: 1) odd-even split mode, which uses odd and even indexes, and 2) half split mode, which uses the first half and second half indexes. In each mode, the anchor (A), positive (P), and negative samples (N) will have a length of 16 each.\n6. Finally, masking is applied to the preprocessed anchor sequences from the pre- vious step. The masking occurs with a probability of r (where r \u2208 {0.2,0.3}) for the sequence tokens."}, {"title": "3.3 Task-specific representation model", "content": "BotTRep utilizes a contrastive structure based on the Transformer architecture [11,22]. It is trained jointly using the triplet margin loss [17] and cross-entropy loss for two tasks: contrastive learning and masked cell prediction, as shown in Fig. 3. The following subsections provide a detailed explanation of the design strategy and the two tasks.\nTransformer-based contrastive learning task In this part, we begin by explaining the process of contrastive learning with a data point of zone and"}, {"title": "3.4 Extract representation vectors", "content": "Now, we can extract representations from user trajectories using our trained model. We utilize the model that extracts user representations in Fig. 3. The entire procedure is almost the same as the model train step, but the observed timestamp values are added to each token instead of randomly generated val- ues. We utilize timestamp encoding designed on a minute basis, as mentioned previously. Afterward, we extract the daily trajectory of each player from the games, and each data point is denoted as $T^{p_i}$, as mentioned before. The embed- ding matrix associated with $T^{p_i}$ is also initialized as $E^{p_i} = (e_1, .., e_t)$ where $e_t = e_z(z(l_t))+e_c(c(l_t))+te(t)$ where t is timestamp index from 1 to 1440, stands for the timestamp of tth location that the player has visited. Then, the embedding matrix $E_i$ is input to the trained model, and the model extracts representations. To summarize, the simplified structure of our suggestion is $T^{tr_i} = model(E^{p_i})$ where model(\u00b7) is the proposed model, and the representations of the trajectories are notated in this way: $D^{rep}$ = {$T^{tr_1}, T^{tr_2},..,T^{tr_N}$}."}, {"title": "3.5 Clustering collectively-behaving groups", "content": "Once we obtain representation vectors for the trajectories, we cluster them so that players that have similar in-game trajectories and, hence, similar representations get grouped together. In particular, we use the DBSCAN [5]. An interesting property of DBSCAN is that not all data points get assigned to a cluster. That is, the algorithm classifies points that do not belong to any group as noise. Such points generally correspond to benign players because they have peculiar trajectories resulting from diverse preferences in play styles and are typically not included in specific clusters. Hence, we decided to define all the clustered groups (i.e. DBSCAN did not classify as noise) as collectively-behaving groups. However, in order to utilize DBSCAN appropriately, optimization of parameters, min_samples and eps (\u025b), should be preceded. Here, we select min_samples as 4 because we target suspicious groups with more than 4 players relying on our industrial requirement. Afterward, we control \u025b by referring to the distances of representation vectors of 4 closest neighbors from each data point, inspired by [18]. Notably, we chose not to use a fixed \u025b value for DBSCAN. Instead, we adopted the methodology from [18] that selects \u025b values based on the density of representation vectors. This is because the vectors we cluster are derived from the deep learning model. Even when using the same data for training, the inherent randomness in the learning process can result in representation vectors in hidden space having different scales of distance and density among specific data points. In other words, using a fixed a value led to issues in maintaining consistent quality when detecting collectively-behaving bots based on the model's output vectors. Fig. 4 explains how we choose the \u025b value in the clustering process, and the clusters that result from it. Firstly, the leftmost image shows the criterion for selecting \u025b as proposed in [18] (a), and the criterion we used in this work (b). [18] suggests drawing a plot of distance and then using the distance at the elbow point of the curve as the \u025b value. However, applying the value from (a) to our data led to the phenomenon of clustering together trajectories that are relatively dissimilar, as shown in the second plot in Fig. 4. Consequently, we searched for a new criterion (b) suitable for our data and are utilizing this value as the \u025b for DBSCAN. Precisely, we extract the distances between each data point and their 4 nearest data points. Afterward, we select a distance value of 0.05-0.20 quantile (q) from the extracted distances by K-NN. For example, \u03b5 = quantile0.05(dist) where quantileq(\u00b7) is a quantile function that returns q quantile from input data, and dist = 4 - NNdist(Drep) where 4 NNdist() is a k - NN algorithm where k = 4 and returns distances between the 4 closest neighbors from each data point."}, {"title": "4 Experiments", "content": null}, {"title": "4.1 Dataset : Lineage W", "content": "We train and evaluate our proposed model with two different datasets: 1) a preprocessed dataset for model training, and 2) a real-world gaming trajectory dataset for the downstream task. The first dataset includes 778,656 samples of preprocessed trajectories collected for 8 days on July 1st-8th, 2023. When training, we performed parallel computing on 8 NVIDIA A40 GPUs. We have configured the model to be trained for at least 70 epochs and terminated based on early stopping criteria with patience of 8 epochs. The training time was approximately 6-12 minutes per epoch, depending on the parameters. The second dataset contains 26,136 player trajectories collected for 7 days on July 9th-15th, 2023. Tables 1 and 2 present the experimental results for the second dataset."}, {"title": "4.2 Evaluation methods", "content": "Contextual similarity In this work, we evaluate the similarity in representation between two pairs: collectively-behaving pairs and random pairs, which we call positive and negative pairs, respectively. In this step, we prepared the experimental environment by collecting daily trajectory sequences from all players in a game world and extracting their representations. Subsequently, we generated positive and negative groups based on their representations using DBSCAN. Then, we excluded noise-labeled data determined by the DBSCAN algorithm. We then selected positive and negative pairs based on the cluster labels in this way:\n$pos = {(T^{p_i}, T^{p_j}) | i = 1, .., N, j\\in \\S(T^{p_i})}$\n$neg = {(T^{p_i}, T^{p_j}) | i = 1,.., N, j \\notin \\S(T^{p_i})}$\nwhere \u00a7(\u00b7) is a function that returns the closest index from neighboring players within the cluster containing each input player.\nAfter composing experimental data pairs in the above way, we measure the contextual similarity between their trajectories using a metric named time-aware Jaccard similarity. In this study, we design time-aware Jaccard similarity to check whether the pair of trajectories have similarities over time. We calculate Jaccard similarity [9,10] by a 30-minute subset of each trajectory using 1440 range of minute indexes (t). This metric returns the overall similarity by averaging every 30-minute subsets between two trajectories with 15-minute shifts. The similarity scores from this metric can be interpreted as a measure of how contextually close two different users were in terms of their locations at approximately the same moments. Trajectory pairs with similar travel routes exhibit high similarity values. Contextual similarity is calculated at the cell level and is defined as follows:\n$\\frac{1}{T}\\Sigma J_t (T^{p_i}, T^{p_j})$ where t \u2208 {1, 16, 31, .., 1411} = T\nand $J_t(T^{p_i}, T^{p_j}) = \\frac{|\\{tr_i, .., tr_i+29\\} \\cap \\{tr_j, .., tr_j+29\\}|}{|\\{tr_i, .., tr_i+29\\} \\cup \\{tr_j, .., tr_j+29\\}|}$"}, {"title": "Access information homogeneity", "content": "The another metric is designed to verify whether there is indeed the same abuser behind the clusters mined as collectively- behaving groups. In addition to user trajectory data, our dataset records access information data for each user, such as the IP and device-sharing network mentioned in [20]. This metric aims to determine whether their access information actually belongs to the same person. In other words, if the access information of players mined as collectively-behaving groups is identical, it signifies that they are indeed real collectively-behaving bots controlled by the same user. The specific calculation method is as follows: $\\E c \\in C Ecia ec acc_info(cid)$, where C represents all clusters excluding a noise cluster, that is, the entire collectively-behaving groups we have mined. Cid denotes each collectively-behaving group. acc_info(.) is a function that takes a collectively-behaving group as input and returns the number of different access information points possessed by players in that cluster. For instance, if there are 4 players within a certain cluster and their access information is interconnected, 1 is returned. However, if, upon checking the access information of the 4 players, it is found that 3 of their access information points are interconnected, but one is different, then they form 2 groups, and thus 2 is returned. That is, bots controlled by the same owner have identical access information, resulting in low access information homogeneity values. In contrast, legitimate users who operate one avatar at a time have different access information, resulting in high access information homogeneity values."}, {"title": "4.3 Ablation study", "content": "This section summarizes the ablation study results for the proposed method. We experimented by altering the model's key parameters. Additionally, we highlight the benefits of incorporating both zone and cell tokens and the Masked Cell Prediction (MCP) technique, assessing their impact on model performance. To validate this, we varied parameters and documented the outcomes in experiment type (a). We compared models trained on cell inputs alone versus those trained on both zone and cell inputs, and examined the effects of incorporating MCP, with results under experiment type (b). In experiment type (c), we adjusted the clustering parameter q to observe its impact on our model and DBSCAN's performance. As q increases, contextual similarity and homogeneity of access information decrease due to less homogeneous clusters. A larger q adopts a more lenient criterion for detecting suspicious players, while a smaller q is preferred for higher precision. Experimental results Our proposed setting for BotTRep is shown at the top of Table 1 (\u2020). This model showed the best performance from the perspective of contextual similarity when we conducted additional experiments adjusting d_model, d_hid, \u1e9e, and MCP ratio based on this model; the model generally exhibited higher performances in experiment type (a). In experiment type (b), we conducted experiments by removing zone embedding and MCP one at a time from \u2020, and a slight decrease in performance was observed in both cases regarding"}, {"title": "4.4 Baseline models", "content": "In this study, we deliberated on selecting the most appropriate baseline model due to the lack of precedent representation models applied to tasks similar to ours. To compare and validate the performance of our model, we prepared three types of baseline models, as described below. These models employ the encoder-decoder structure most commonly used for sequence data representation, with internal layers implemented in three variants using Bi-GRU, Bi-LSTM and Transformer blocks. We compared our model to autoencoder-based models because they are commonly used for extracting sequence representations. Previous trajectory representation models proposed for GPS data using proximity features in the real world [13,21,24] have also used autoencoders. For the dataset, we trained and inferred directly using the data for downstream tasks (Dtraj) without additional preprocessing steps, such as checking if adjacent cells are identical. This decision was made because such preprocessing significantly slowed the model's convergence, leading to poor performance within the time constraints of our requirements. When preparing these models, we set d_model to 256 to enable a comparison with our model under similar specifications. When extracting representations, we applied mean pooling after the input data passed through the encoder block because it achieved the best performance compared to CLS and max pooling."}, {"title": "4.5 Trajectory visualization", "content": "This work is designed to surveil collectively-behaving groups, supposed to be bots, throughout the continents using their trajectory data and visualize how much their trajectories are similar to each other. The heatmap, designed to show similar colors when players exist contextually close to each other, is used to visualize whether the suspicious players appear together. The heatmap's x-axis represents timestamps, and the y-axis represents player indices. The color, in RGB format, indicates the player's location at a specific timestamp. That is, we construct a 3-dimensional vector that somehow represents spatial information, and then visualize it as RGB coloring. Specifically, we generate colormaps as (continent_lv, x, y), where continent_lv reflects average player levels in each continent. This addition represents semantic relationships between continents. Regarding game geography, hunting grounds suitable for each level are located in an adjacency to guide players in growing their avatars with less confusion. Note that if the player was not logged in the game at a particular timestamp, we color the corresponding spot as white. Finally, we present a visualization of player location over time in Fig. 5. The right-most plot corresponds to the points such that DBSCAN labeled as noise: i.e. those that we consider benign users. We can see that these users tend to have their own distinct trajectories, indicating that they are indeed not"}, {"title": "5 Conclusion", "content": "We proposed a novel framework that uses a trajectory representation model trained jointly on contrastive learning and masked cell prediction tasks, so that similar contextual in-game movements obtain closer representations. Then, we used DBSCAN to identify collectively-behaving groups and introduced a visualization method that explains their in-game trajectories. Our framework meets the industrial needs for clear explainability and can assist game masters by providing clustered users who are suspicious to be collectively-behaving bots."}]}