[{"title": "Scalable Knowledge Refactoring using Constrained Optimisation", "authors": ["Minghao Liu", "David M. Cerna", "Filipe Gouveia", "Andrew Cropper"], "abstract": "Knowledge refactoring compresses a logic program by introducing new rules. Current approaches struggle to scale to large programs. To overcome this limitation, we introduce a constrained optimisation refactoring approach. Our first key idea is to encode the problem with decision variables based on literals rather than rules. Our second key idea is to focus on linear invented rules. Our empirical results on multiple domains show that our approach can refactor programs quicker and with more compression than the previous state-of-the-art approach, sometimes by 60%.", "sections": [{"title": "Introduction", "content": "Knowledge refactoring is a key component of human intelligence (Rumelhart and Norman 1976). Knowledge refactoring is also important in AI, such as for policy reuse in planning (Bonet, Drexler, and Geffner 2024) and to improve performance in program synthesis (Ellis et al. 2018; Duman\u010di\u0107, Guns, and Cropper 2021). The goal is to compress a knowledge base, such as a logic program, by introducing new rules.\nTo illustrate knowledge refactoring, consider the logic program:\n$\\begin{aligned}\ng(A) & \\leftarrow p(A), q(A,B), r(B), s(A,B) \\\\\ng(A) & \\leftarrow p(A), q(A,B), r(B), t(A,B) \\\\\nP_1 = { } \\\\\ng(A) & \\leftarrow p(B), q(B,C), r(C), w(A,B) \\\\\ng(A) & \\leftarrow p(A), q(B,A), r(A), z(A,B)\n\\end{aligned}$\nThis program has 4 rules, each with 5 literals. Thus, the size of this program is 20 (literals).\nWe could add a new $\\text{aux}\\_1$ rule to refactor $P_1$ as:\n$\\begin{aligned}\n\\text{aux}\\_1(A,B) & \\leftarrow p(A), q(A,B), r(B) \\\\\ng(A) & \\leftarrow \\text{aux}\\_1(A,B), s(A,B) \\\\\nP_2 = { } \\\\\ng(A) & \\leftarrow \\text{aux}\\_1(A,B), t(A,B) \\\\\ng(A) & \\leftarrow \\text{aux}\\_1(B,C), w(A,B) \\\\\ng(A) & \\leftarrow p(A), q(B,A), r(A), z(A,B)\n\\end{aligned}$\nThe size of $P_2$ is smaller than $P_1$ (18 vs 20 literals) yet syntactically equivalent to $P_1$ after unfolding\u00b9 (Tamaki and Sato 1984).\nA limitation of current refactoring approaches is scalability (Ellis et al. 2018; Cao et al. 2023; Bowers et al. 2023). For instance, KNORF (Duman\u010di\u0107, Guns, and Cropper 2021) frames the refactoring problem as a constrained optimisation problem (COP) (Rossi, Van Beek, and Walsh 2006). KNORF builds a set of invented rules by enumerating all subsets of the rules in an input program. KNORF then uses a COP solver to find a subset of the invented rules that maximally compresses the input program. However, because it enumerates all subsets, KNORF struggles to scale to programs with large rules and to programs with many rules.\nTo overcome this scalability limitation, we introduce a novel refactoring approach. Our first key contribution is a new COP formulation. Instead of enumerating all subsets of rules, we use decision variables to determine whether a literal is used in an invented rule. Our new formulation has two key advantages. First, the number of decision variables required is exponentially reduced. Second, an invented rule can use any combination of literals in the input program, rather than a strict subset of an input rule.\nTo illustrate the benefit of our first contribution, consider the input program $P_1$. The invented rule $\\text{aux}\\_1$ cannot refactor the last rule as any instance of $\\text{aux}\\_1$ cannot cover the literals $p(A)$, $q(B,A)$, $r(A)$ simultaneously. However, we could invent the rule $\\text{aux}\\_2$ to refactor the program as:\n$\\begin{aligned}\n\\text{aux}\\_2(A,B,C) & \\leftarrow p(A), q(B,C), r(C) \\\\\ng(A) & \\leftarrow \\text{aux}\\_2(A,A,B), s(A,B) \\\\\ng(A) & \\leftarrow \\text{aux}\\_2(A,A,B), t(A,B) \\\\\nP_3 = { } \\\\\ng(A) & \\leftarrow \\text{aux}\\_2(B,B,C), w(A,B) \\\\\ng(A) & \\leftarrow \\text{aux}\\_2(A,B,A), z(A,B)\n\\end{aligned}$\nThe body of $\\text{aux}\\_2$ is not a subset of any rule in $P_1$, so KNORF could not invent $\\text{aux}\\_2$. By contrast, because we allow an invented rule to use any literal, we can invent $\\text{aux}\\_2$. The program $P_3$ is smaller than $P_2$ (16 vs 18 literals) yet is syntactically equivalent to $P_1$ after unfolding. As this example shows, our first contribution allows our approach to find better (smaller) refactorings.\nOur second key contribution is to use linear invented rules where (i) the body literals may not occur in the input program, and (ii) the size may be larger than any rule in the input program."}, {"title": "Novelty and Contributions", "content": "The three main novelties of this paper are (i) the theoretical proof of the complexity of the optimal knowledge refactoring problem, (ii) a concise and efficient encoding of the problem as a COP, and (iii) demonstrating the effectiveness of our approach on large-scale and real-world benchmarks.\nOverall, our contributions are:\n\u2022 We introduce the optimal knowledge refactoring problem, where the goal is to compress a logic program by inventing rules. We prove that the problem is NP-hard.\n\u2022 We introduce MAXREFACTOR, which solves the optimal knowledge refactoring problem by formulating it as a COP.\n\u2022 We evaluate our approach on multiple benchmarks. Our results show that, compared to the state-of-the-art approach, MAXREFACTOR can improve the compression rate by 60%. Our results also show that MAXREFACTOR scales well to large and real-world programs."}, {"title": "Related Work", "content": "Knowledge refactoring. Knowledge refactoring is important in many areas of AI (Bonet, Drexler, and Geffner 2024), notably in program synthesis (Ellis et al. 2018; Bowers et al. 2023; Cao et al. 2023; Hocquette, Dumancic, and Cropper 2024). For instance, Duman\u010di\u0107, Guns, and Cropper (2021) show that learning from refactored knowledge can substantially improve predictive accuracies of an inductive logic programming system and reduce learning times because the knowledge is structured in a more reusable way and redundant knowledge is removed.\nModel reformulation. There is much research on reformulating constraint satisfaction problem (CSP) models automatically (O'Sullivan 2010; Charlier et al. 2017; Vo 2020).\nThe main categories include implied constraints generation (Charnley, Colton, and Miguel 2006; Bessiere, Coletta, and Petit 2007), symmetry and dominance breaking (Liberti 2012; Mears and de la Banda 2015), pre-computation (Cadoli and Mancini 2006), and cross-modeling language translation (Drake et al. 2002). We differ because we work with logic programs and invent rules.\nRedundancy and compression. Knowledge refactoring is distinct from knowledge redundancy, which is useful in many areas of AI, such as in Boolean Satisfiability (Heule et al. 2015). For instance, Plotkin (1971) introduced a method to remove logically redundant literals and clauses from a logical theory. Similarly, theory compression (De Raedt et al. 2008) approaches select a subset of clauses such that performance is minimally affected with respect to a cost function. We differ from redundancy elimination and theory compression because we restructure knowledge by inventing rules.\nPredicate invention. We refactor a logic program by introducing predicate symbols that do not appear in the input program, which is known as predicate invention (Kramer 2020). Predicate invention is a major research topic in program synthesis and inductive logic programming (Kok and Domingos 2007; Muggleton, Lin, and Tamaddoni-Nezhad 2015; Hocquette and Muggleton 2020; Jain et al. 2021; Silver et al. 2023; Cerna and Cropper 2024). We contribute to this topic by developing an efficient and scalable method to invent predicate symbols to compress a logic program.\nProgram refactoring. In program synthesis, many researchers (Ellis et al. 2018; Bowers et al. 2023; Cao et al. 2023) refactor functional programs by searching for local changes (new $\\lambda$-expressions) that optimise a cost function. We differ from these approaches because we (i) consider logic programs, (ii) use a declarative solving paradigm (COP), and (iii) guarantee optimal refactoring. ALPS (Duman\u010di\u0107 et al. 2019) compresses facts in a logic program, whereas we compress rules.\nKNORF. The most similar work is KNORF (Duman\u010di\u0107, Guns, and Cropper 2021). Given a logic program P as input, KNORF works as follows. For each ruler \u2208 P, KNORF enumerates every subset s of r. For each subset s and for each combination h of the variables in s, KNORF creates a new rule $\\text{aux}\\_{sh}$. KNORF then creates a COP problem where there is a decision variable for each $\\text{aux}\\_{sh}$. It also creates decision variables to state whether a ruler \u2208 P is refactored using $\\text{aux}\\_{sh}$. KNORF then uses a COP solver to find a subset of the invented rules that leads to a refactoring with maximal compression. KNORF has many scalability issues. Foremost, it enumerates all subsets of all rules and thus struggles to scale to programs with large rules and many rules. Specifically, for a program with n rules and a maximum rule size k, KNORF uses $O(n2^k)$ decision variables. By contrast, our MAXREFACTOR approach does not enumerate all subsets of rules. Instead, as we describe in Section 4, we define a new rule $\\text{aux}\\_i$ by creating decision variables to represent whether any literal in P is in $\\text{aux}\\_i$. Besides, we create decision variables to state whether a rule and a literal in P is refactored using $\\text{aux}\\_i$. Since the number of invented rules is a predefined constant, MAXREFACTOR only needs"}, {"title": "Problem Setting", "content": "We focus on refactoring knowledge in the form of a logic program, specifically a definite logic program with the least Herbrand model semantics (Lloyd 2012). For simplicity, we use the term logic program to refer to a definite logic program. We assume familiarity with logic programming but restate some key terms. A logic program is a set of rules of the form:\n$\\qquad h \\leftarrow a_1, a_2,..., a_m$\nwhere h is the head literal and $a_1,..., a_m$ are the body literals. A literal is a predicate symbol with one or more variables. For example, parent(A,B) is a literal with the predicate symbol parent and two variables A and B. The predicate symbol of a literal a is denoted as pred(a) and the set of its variables is denoted as var(a). The head literal of a rule is true if and only if all the body literals are true. The head literal of a ruler is denoted as head(r) and the set of body literals is denoted as body(r). The size of a ruler is defined as $\\text{size}(r) = |\\text{body}(r)| + 1$, which is the total number of literals. The size of a logic program P is defined as $\\text{size}(P) = \\sum_{r\\in P} \\text{size}(r)$.\n3.1 Knowledge Refactoring\nOur goal is to reduce the size of a logic program whilst preserving its semantics. However, checking the semantic equivalence between two logic programs is undecidable (Shmueli 1987). Therefore, we focus on finding syntactically equivalent refactorings. Syntactic equivalence implies semantic equivalence but the reverse is not necessarily true. We check syntactic equivalence by unfolding (Tamaki and Sato 1984) refactored programs. Unfolding is a transformation in logic programming. We adapt the unfolding definition of Nienhuys-Cheng and Wolf (1997) to (i) resolve multiple literals, whereas the original definition only resolves one literal each time, and (ii) prohibit variables that only appear in the body of a rule:\nDefinition 1 (Rule unfolding). Given a logic program $P = {c_1, c_2,...,c_N}$ and a rule r, where r does not have variables that only appear in its body, then unfolding P upon r means constructing the logic program $Q = {d_1,d_2,...,d_v}$, where each $d_i$ is the resolvent of $c_i$ and r if head(r) is unifiable with any literal in body($c_i$), otherwise $d_i = c_i$.\n$\\begin{aligned}\ng(A) & \\leftarrow p(A), \\text{aux}(A,B) \\\\\ng(A) & \\leftarrow p(B), p(C), \\text{aux}(A,B), \\text{aux}(A,C) \\\\\ng(A) & \\leftarrow p(B), q(A,B), r(B)\n\\end{aligned}$\nand the ruler: $\\text{aux}(A,B) \\leftarrow p(B), q(A,B)$. The result of unfolding P upon r is:\n$\\begin{aligned}\ng(A) & \\leftarrow p(A), p(B), q(A,B) \\\\\nQ= { } \\\\\ng(A) & \\leftarrow p(B), p(C), q(A,B), q(A,C) \\\\\ng(A) & \\leftarrow p(B), q(A,B), r(B)\n\\end{aligned}$"}, {"title": "MAXREFACTOR", "content": "Given an input logic program P", "S": "n$\\begin{aligned"}, "n\\text{aux}\\_1(A,B,C) & \\leftarrow p(A,B), q(B,C) \\\\\n\\text{aux}\\_2(A,B,D) & \\leftarrow p(A,B), r(B,D) \\\\\n\\text{aux}\\_3(B,C,D) & \\leftarrow q(B,C), r(B,D) \\\\\n\\text{aux}\\_4(A,B,C,D) & \\leftarrow p(A,B), q(B,C), r(B,D)\n\\end{aligned}$\nDefining S this way has the advantage that it restricts which literals can appear in an invented rule. However, this approach also has disadvantages. As we show in Section 1, this approach cannot invent a rule that is not a subset of any input rule (e.g. $\\text{aux}\\_2$ in $P_3$), nor can the size of the invented rule be larger than any input rule (e.g., $\\text{aux}\\_3$ in $Q_2$).\nTo overcome these limitations, we use a new approach to define the space of invented rules. We denote the set of body predicate symbols in the logic program P as $\\text{Pr}(P)$ and a finite set of variables as X. We define the set of all possible body literals $\\mathcal{L} = {p(v) | p \\in \\text{Pr}(P), v \\in X^{\\text{arity}(p)}}$. We define S as the space of all combinations of literals from $\\mathcal{L}$, i.e., the power set of $\\mathcal{L}$. The size of S is exponential in the size of $\\mathcal{L}$ and S is clearly a superset of the space considered by KNORF. Therefore, our key insight is not to consider all combinations of $\\mathcal{L}$ and to instead only consider the most general ones. We call such rules linear invented rules:\nDefinition 6 (Linear invented rule). A linear invented rule is a rule with linear variable occurrence in its body.\n$\\text{aux}\\_1(A,B,C) \\leftarrow p(A,B), q(B,C)$ is not linear because its body literals share the variable B. By contrast, the rule $\\text{aux}\\_2(A,B,C,D) \\leftarrow p(A,B), q(C,D)$ is linear.\nFor any invented rule r, we can always build a linear invented rule lin(r) as follows: (i) rewrite the body literals such that the predicate symbols remain unchanged and the variables occur linearly, then (ii) build a new head literal such that $\\text{var}(\\text{head}(\\text{lin}(r))) = \\bigcup_{a \\in \\text{body}(\\text{lin}(r))} \\text{var}(a)$.\nTo motivate the use of linear invented rules in refactoring, we show the theorem:\nTheorem 2. If the optimal knowledge refactoring problem has a solution using the set of invented rules $C \\subseteq S$ then it has a solution using $C' \\subseteq S^{\\text{lin}}$, where $S^{\\text{lin}} = {\\text{lin}(s) | s \\in S}$.\nProof. Suppose there is an invented ruler \u2208 C, we can always build a linear invented rule $r' = \\text{lin}(r)$, then $C' = C\\backslash\\{r\\} \\cup \\{r'\\}$. First, observe that $|C'| \\le |C|$ because either an invented rule has a unique linear invented rule generalising it, or multiple invented rules of C are generalised by the same linear invented rule. Second, for any body literal in the input program that is covered by r, it can also be covered by r' via variable mapping. Thus, we can always get a refactored program of the same or smaller size using C'.\nTheorem 2 implies that we can restrict S to linear invented rules without compromising the optimal solution. As we show below, defining S as linear invented rules allows us to simplify the COP formulation.\n4.2 COP Encoding\nAccording to Theorem 1, the optimal knowledge refactoring problem is NP-hard, making it computationally challenging. Constraint programming (CP) is a successful framework for modeling and solving hard combinatorial problems (Hebrard 2018). Therefore, MAXREFACTOR formulates this search problem as a constrained optimisation problem (COP) (Rossi, Van Beek, and Walsh 2006). Given (i) a set of decision variables, (ii) a set of constraints, and (iii) an objective function, a COP solver finds an assignment to the decision variables that satisfies all the specified constraints and minimises the objective function.\nWe describe our COP encoding below\u00b2.\nDecision Variables MAXREFACTOR builds decision variables to determine (a) which literals are in which invented rules, and (b) how to refactor input rules using the invented rules\u00b3.\nFor task (a), for each possible invented rule $r_k$ for $k \\in [1, K"], "program": "n$\\begin{aligned"}, {"nc_2": "g(A) & \\leftarrow p(B)^{a_1}, q(A,B)^{a_2}, q(A,C)^{a_3}, s(C)^{a_4}\n\\end{aligned}$"}]