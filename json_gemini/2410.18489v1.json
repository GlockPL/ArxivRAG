{"title": "LLM as a Code Generator in Agile Model-Driven Development", "authors": ["Ahmed R. Sadik", "Sebastian Brulin", "Markus Olhofer", "Antonello Ceravola", "Frank Joublin"], "abstract": "Leveraging Large Language Models (LLM) like GPT-4 in the auto-generation of code represents a significant advancement, yet it is not without its challenges. The ambiguity inherent in natural language descriptions of software poses substantial obstacles to generating deployable, structured artifacts. This research champions Model-Driven Development (MDD) as a viable strategy to overcome these challenges, proposing an Agile Model-Driven Development (AMDD) approach that employs GPT-4 as a code generator. This approach enhances the flexibility and scalability of the code auto-generation process and offers agility that allows seamless adaptation to changes in models or deployment environments. We illustrate this by modeling a multi-agent Unmanned Vehicle Fleet (UVF) system using the Unified Modeling Language (UML), significantly reducing model ambiguity by integrating the Object Constraint Language (OCL) for code structure meta-modeling, and the FIPA ontology language for communication semantics meta-modeling. Applying GPT-4's auto-generation capabilities yields Java and Python code that is compatible with the JADE and PADE frameworks, respectively. Our thorough evaluation of the auto-generated code verifies its alignment with expected behaviors and identifies enhancements in agent interactions. Structurally, we assessed the complexity of code derived from a model constrained solely by OCL meta-models, against that influenced by both OCL and FIPA-ontology meta-models. The results indicate that the ontology-constrained meta-model produces inherently more complex code, yet its cyclomatic complexity remains within manageable levels, suggesting that additional meta-model constraints can be incorporated without exceeding the high-risk threshold for complexity.", "sections": [{"title": "1 Introduction", "content": "In the era of artificial intelligence, with Large Language Models (LLMs) trained on diverse codebases, new opportunities for innovation in Model-Driven Devel-"}, {"title": "2 Problem Statement", "content": "Natural language's inherent ambiguity presents challenges not only for machine interpretation but also for human understanding. In leveraging GPT-4 in de-"}, {"title": "3 Proposed Approach", "content": "Addressing the challenges described in the problem statement, our AMDD approach uses GPT-4 as a code generator, that seamlessly interprets of the model into interconnected software artifacts that are ready for deployment. We lever-aged PlantUML to translate UML diagrams into a formal text representation, to bridge the gap between GPT-4 text-based prompt and the visual UML's di-agrams, therefore facilitating direct input into GPT-4. As illustrated in Fig. 2., the modeler starts by crafting the model's layers: structural, behavioral, and constraints.\nThe structural layer outlines the static aspects of the model, showcasing software components and their complex relationships. Class diagrams elucidate object relationships and hierarchies, package diagrams group objects to highlight dependencies, and component diagrams offer a high-level view of system func-tionality and inter-component links. Deployment diagrams illustrate the hard-ware setup and component distribution for the system's physical architecture, whereas object diagrams provide runtime snapshots of objects, and profile dia-grams adapt UML models for specific platforms.\nThe behavioral layer depicts the system's operations and interactions through various diagrams. Sequence diagrams map out event sequences, offering a time-line of interactions, while activity diagrams provide a detailed process flow. In-teraction diagrams and timing diagrams further explore component interplay and the significance of timing, respectively. Use case diagrams demonstrate in-teractions between external entities and the system, and state diagrams trace the lifecycle and state transitions of entities.\nDespite the comprehensive view offered by structural and behavioral dia-grams, they fall short in articulating the governing rules and semantics. Our research introduces a constraints layer to refine the model's architecture by in-corporating explicit meta-values and rules beyond UML's scope. We employ the OCL to define detailed code construction rules for both layers, specifying class invariants, method pre- and post-conditions, and parameter value restric-tions. Additionally, communication constraints are articulated using ontology languages, enhancing knowledge sharing among software artifacts."}, {"title": "4 Case study model", "content": "The use-case selected for discussion centers around an UVF, consisting of a va-riety of UVs tasked with distinct missions, all orchestrated by a Mission Control Center (MCC) with human oversight. This case study has been designed as in-herently distributed, making it suitable for representation and analysis through a Multi-Agent System (MAS) [3]. The case study complexity is notably high since each participating entity is modeled as an agent, which necessitates on-going communication and information sharing among agents to fulfill a unified objective, namely the successful completion of the fleet's mission. To ensure clar-ity and prevent the details of the MAS from becoming overwhelming, subsequent"}, {"title": "4.1 Structure model", "content": "Within the architecture of the model, the class diagram holds a crucial role by mapping out each participant in the case study as a distinct agent class, a relationship depicted in Fig. 3. This diagram introduces the operator agent, embodying the human operator's functions such as dispatching mission briefings and collecting performance metrics. It also details the MCC agent, defined by characteristics like its unique MCC-ID, which oversees mission coordination and fleet supervision. Additionally, the UVF-Manager agent is tasked with the over-sight of fleet operations, encompassing the allocation of tasks and monitoring of execution outcomes. The Unmanned Vehicle (UV) agent is conceptualized as a foundational class for UVs, branching into specific subclasses for varied vehicle categories, including UAVs, UGVs, and USVs . Through this class diagram, the intricate interactions among agents are clarified, highlighting their attributes, functionalities, and the web of relationships among them, such as composition, aggregation, and inheritance, while also defining the connections' cardinality."}, {"title": "4.2 Behaviour model", "content": "For conciseness and focus, the article will explore only two significant behavioral views critical for comprehending the case study model: the activity and state diagrams. These diagrams are essential for understanding the dynamic aspects"}, {"title": "5 Case study metamodel", "content": "In the proposed AMDD framework, the meta-model layer serves a pivotal role by encapsulating constraints that cover all facets of technical requirements not directly representable in the model layer. These constraints act as the guiding principles or rules that ensure the model adheres to specified technical standards and requirements. Upcoming sections will delve into the various types of meta-model constraints employed in the case study's modeling process, providing a comprehensive overview of how these constraints influence and shape the model's development and ensuring it aligns with the desired technical specifications and objectives"}, {"title": "5.1 Construction metamodel", "content": "OCL complements the UML by defining rules for classes within a model. It plays a crucial role in adding construction constraints to UML diagrams, thereby enhancing model refinement and clarity. By addressing model ambiguities, OCL"}, {"title": "5.2 Communication metamodel", "content": "While the OCL aims to define constraints for classes within UML models, it has limitations in facilitating inter-class communication essential for the func-tionality of MAS [20,19]. To bridge this gap, technologies such as Java Agent DEvelopment (JADE) and Python Agent DEvelopment (PADE) turn to the FIPA-ontology communication language [18]. This language significantly en-hances MAS by providing a rich set of interaction protocols tailored for complex agent communications, overcoming the shortcomings of OCL in this domain. Our case study specifically points out these limitations of OCL and demonstrates how FIPA-ontology language serves as a crucial tool in developing sophisticated MAS communications."}, {"title": "6 Code evaluation", "content": "In the final stage of our AMDD approach, we employ GPT-4 for the conversion of the model and the metamodel into executable code. Our findings indicate an average occurrence of four bugs per agent class generated by GPT-4, predomi-nantly due to the omission of necessary library imports. Nevertheless, with the correction of these bugs, the generated code becomes suitable for deployment. It is important to note that our primary interest in this study lies not in the accuracy of the auto-generated code but in its comprehensiveness. Our evalua-tion focuses on the examination and analysis of the structure and behavior of the auto-generated code, rather than on identifying and quantifying the bugs it may contain.\nTo this end, we conducted two distinct experiments. The first experiment sought to dissect the structure and complexity of the auto-generated code, pro-viding insights into its architectural design and the intricacies of its internal mechanisms. The second experiment was designed to investigate the behavior of the auto-generated code, aiming to understand how well it performs its intended functions within a given context. These experiments collectively offer a holistic view of the auto-generated code's efficacy, highlighting areas of strength and opportunities for further refinement."}, {"title": "6.1 Structure evaluation", "content": "In our first experiment, we concentrated on analyzing the structure and com-plexity of the auto-generated code using the cyclomatic complexity metric. This metric is essential for measuring code complexity, as it enumerates the number of linearly independent paths through the program's source code. The calculation relies on the code's control-flow graph, akin to the example depicted in Fig. 8. The cyclomatic complexity (M) is derived from the formula:\n$M=E-N + 2P$\nwhere E represents the number of edges in the flow graph, N is the number of nodes, and P indicates the number of disconnected parts of the graph. For instance, given the graph shown in Fig. 8, the calculated M is 3. This M value is critical for evaluating various software aspects, such as testing difficulty, main-tainability, understandability, refactorability, performance, reliability, and docu-mentation quality. Based on the M value, risk levels are categorized as follows: an M between 1 and 10 signifies low risk; an M between 11 and 20 indicates moderate risk; an M from 21 to 50 suggests high risk, potentially requiring code review or decomposition into smaller modules; and an M exceeding 50 denotes severe risk, necessitating substantial refactoring.\nIn our AMDD approach, we placed particular emphasis on the impact of integrating formal constraints on the generation of deployable code. The aim of this experiment was to gauge the influence of the matemodel constraints on the complexity of the auto-generated code. Consequently, we generated two distinct deployments that varied in the degree of constraints embedded within their models. The first deployment was based on a model that implemented only OCL constraints, while the second deployment also integrated FIPA-ontology constraints into the model."}, {"title": "6.2 Behaviour evaluation", "content": "In the second experiment of our study, we generated two distinct deployments: one in Java for the JADE platform, and another in Python for the PADE frame-work. The objective was to assess and compare the behaviors of code executed on JADE with that running on PADE, aiming to verify the system dynamics' con-sistency across different programming languages. This examination specifically focused on the agents' interaction behaviors within both the JADE and PADE frameworks. Observations indicated that the agents' behaviors, as captured by the JADE Sniffer tool, align with the sequence diagrams generated from PADE agent interactions, as depicted in Fig. 9."}, {"title": "7 DISCUSSION, CONCLUSION, AND FUTURE WORK", "content": "Our investigation into the integration of LLMs within MDD practices has un-veiled significant potential for overcoming the challenges posed by natural lan-guage ambiguities in auto-generating deployable code. By employing formal mod-eling languages, such as UML, and enriching them with precise metamodels' constraints, we have significantly bridged this gap. Our proposed AMDD ap-proach, which introduces semantic depth through metamodelling, has proven to enhance the accuracy of code generation by LLMs, particularly GPT-4, which demonstrates advanced reasoning capabilities.\nIn our case study focusing on a MAS of an UVF, we utilized class diagrams to represent agents and employed activity and state diagrams to capture their interactions and behaviors. Detailed metamodels were defined by using the OCL for structural aspects and FIPA-ontology for agent communication. This foun-dational model facilitated the auto-generation of code in both Java and Python, showcasing the effectiveness of our approach.\nOur evaluation through two distinct experiments. The first experiment ex-amined the auto-generated code behavior in Java and Python. Both codes run in Java and Python showed identical behavior with the model activity diagram, however new behavior in both implementations was added by GPT-4 as shown in, to reveal the capability of LLM to interpret and then compliment the\nWhile the second experiment assessed the structural complexity of the gener-ated code revealed that the addition of FIPA-ontology metamodel does not unduly increase code complexity. This suggests that our approach allows for the inclusion of further constraints without necessitating immediate code refactor-ing, indicating robustness and scalability.\nThe insights gained from integrating LLMs into MDD underscore a trans-formative path towards achieving the sought-after agility in current MDD prac-tices. Future research will focus on assessing the correctness of auto-generated code, incorporating new privacy and cybersecurity metamodels, and comparing our methodology against existing MDD frameworks. Through continuous en-hancement and evaluation, we aim to pave the way for more agile, efficient, and robust software development methodologies. As the domain of software devel-opment continues to evolve, the seamless interplay between structured model-ing, advanced LLM reasoning, and assessments of structural complexity will be paramount. Our research represents a step forward in this direction, suggesting a future where the generation of deployable code from high-level models becomes more streamlined, precise, and reliable."}]}