{"title": "A Neurosymbolic Fast and Slow Architecture for Graph Coloring", "authors": ["Vedant Khandelwal", "Vishal Pallagani", "Biplav Srivastava", "Francesca Rossi"], "abstract": "Constraint Satisfaction Problems (CSPs) present significant challenges to artificial intelligence due to their intricate constraints and the necessity for precise solutions. Existing symbolic solvers are often slow, and prior research has shown that Large Language Models (LLMs) alone struggle with CSPs because of their complexity. To bridge this gap, we build upon the existing SOFAI architecture (or SOFAI-v1), which adapts Daniel Kahneman's \"Thinking, Fast and Slow\" cognitive model to AI. Our enhanced architecture, SOFAI-v2, integrates refined metacognitive governance mechanisms to improve adaptability across complex domains, specifically tailored here for solving CSPs like graph coloring. SOFAI-v2 combines a fast System 1 (S1) based on LLMS with a deliberative System 2 (S2) governed by a metacognition module. S1's initial solutions, often limited by non-adherence to constraints, are enhanced through metacognitive governance, which provides targeted feedback and examples to adapt S1 to CSP requirements. If S1 fails to solve the problem, metacognition strategically invokes S2, ensuring accurate and reliable solutions. With empirical results, we show that SOFAI-v2 for graph coloring problems achieves an 16.98% increased success rate and is 32.42% faster than symbolic solvers.", "sections": [{"title": "Introduction", "content": "Constraint Satisfaction Problems are a core challenge in artificial intelligence (AI) due to their demand for correctness adhering to strict constraints in static (Kumar 1992) or uncertain, dynamic environments (Verfaillie and Jussien 2005). These problems are prominent in applications such as scheduling, boolean satisfiability, resource allocation, temporal reasoning, and planning (Welsh and Powell 1967; Chaitin 1982). Traditional approaches to solve CSPs typically rely on constraint propagation or search (Haralick and Elliott 1980). The symbolic approaches are known for their accuracy but often struggle with scalability as the complexity of CSPs increases, hindered by high computational overhead and slow processing times (Dechter 2003; Rossi, Van Beek, and Walsh 2006).\nRecent advancements in LLMs have shown promise in rapidly processing complex information (Ruoss et al. 2024),"}, {"title": "Background", "content": "Constraint Satisfaction Problem\nCSP is defined as a tuple (X, D, C'), where:\n\u2022 X = {x1,x2,..., Xn} is a finite set of variables.\n\u2022 D = {D1, D2, . . ., Dn } is a set of domains, with each Di representing the possible values for variable xi.\n\u2022 C = {C1, C2,..., Cm} is a set of constraints, with each constraint cj defining a subset of allowed assignments for a set of variables involved in the constraint.\nA solution to a CSP is an assignment of values to all variables in X such that every constraint in C is satisfied. CSPs are used extensively in scheduling, resource allocation, and combinatorial optimization, where satisfying multiple constraints simultaneously is crucial.\nGraph Coloring Problem\nThe graph coloring problem is a specific type of CSP, where the goal is to assign a color to each node of a graph such that no two adjacent nodes share the same color. Formally, it can be defined as a tuple (G, C, k), where:\n\u2022 G = (V, E) is an undirected graph, with V = {U1, U2,..., Un} representing the set of vertices (or nodes) and E = {(Vi, Vj)|Vi, Vj \u2208 V} representing the set of edges.\n\u2022 C = {C1, C2, . . ., Ck } is a set of k colors.\n\u2022 The objective is to find a function f : V \u2192 C such that for any edge (vi, vj) \u2208 E, f(vi) \u2260 f(vj).\nWe use the DIMACS representation (Johnson and Trick 1996) to describe the graph coloring problem, and its corresponding visualization is shown in Figure 1.\nDegree of Saturation Algorithm with Backtracking\nThe Degree of Saturation, or DSATUR algorithm is a heuristic for approaching optimal coloring by assigning colors to vertices based on their saturation degree-the number of distinct colors already assigned to adjacent vertices (Br\u00e9laz 1979). While the algorithm by itself is not guaranteed to find an optimal solution, the addition of backtracking allows it to systematically explore alternative color assignments, ensuring optimal coloring is achieved.\nGiven the graph coloring problem (G, C, k), where G = (V, E) is an undirected graph, C = {C1,C2,..., Ck} is a set of colors, and f: V \u2192 C is the coloring function, the algorithm proceeds as follows:\n1. Initialization: Set f (v) = \u00d8 for all v \u2208 V, marking all vertices as uncolored.\n2. Saturation Degree Calculation: For each uncolored vertex v \u2208 V, calculate its saturation degree, dsat (v), defined as the number of distinct colors assigned to its adjacent vertices: {f(u) | (v, u) \u2208 E, f(u) \u2260 0}."}, {"title": "Related Works", "content": "This section reviews the evolution of solvers for graph coloring, the application of LLMs in sequential decision-making tasks, and the emergence of neurosymbolic approaches for enhancing decision-making processes."}, {"title": "The SOFA\u0399 Architecture", "content": "The SOFAI architecture, also referred to as SOFAI-v1 here (Booch et al. 2021), leverages a rule-based metacognitive control mechanism that dynamically chooses between S1 and S2 solvers based on a confidence threshold associated with S1's outputs. S1 solvers are experience-based (and usually data-driven) solvers, while S2 solvers are deliberative (and usually symbolic and rule-based) solvers. SOFAI-v1 has been instantiated to planning (Fabiano et al. 2023) and constrained-grid navigation (Ganapini et al. 2022), showing improvement on the performance compared to either symbolic or data-driven solvers for the same class of problems.\nIn SOFAI-v1, the metacognitive component only chooses between S1 and S2 solvers, but does not exploit the possible collaboration between these two kinds of solvers, nor does it provide feedback to the solvers if they cannot solve the given problem instance. In this paper we consider a generalized version of this architecture, called SOFAI-v2, shown in Figure 2, where the metacognitive component (called MC) can provide feedback and examples to a failing S1 solver (that for this paper is an LLM), calling the S1 solver more than once, until either a correct solution is returned or a maximum number of iterations is reached, which triggers the activation of an S2 solver.\nFormally, let fs1(x, M) denote the solution produced by S1 for a problem instance x with access to an episodic memory M. Here, M consists of previously encountered problem-solution pairs generated by SOFAI-v2, i.e., pairs (xj, fsOFAI-v2(xj)), where fsOFAI-v2(xj) represents the final solution that could have been generated by either S1 or S2. When a new problem instance x is presented to S1, a similarity function \u03c3(x, M) is used to retrieve a subset Mx CM of similar past instances, defined as:\nMx = {(xj, SOFAI-v2(xj)) | \u03c3(x,xj) \u2265 a},\nwhere xj \u2208 M and a is a predefined similarity threshold. This subset M provides S1 with additional contextual information from past solutions, enabling it to leverage the SOFAI-v2's previous outputs for experience-based adaptation.\nLet C(fs1(x, M\u2081)) denote the confidence score assigned by MC to the solution fs1(x, M\u2081), produced by S1 using both the current problem instance x and the retrieved memory subset Mr. If C(fs1(x, Mx)) > 0s1, where 0s1 is a predefined confidence threshold, the solution is accepted as final. Otherwise, MC provides feedback F(fs1(x, Mx)) or generates a simplified example E(x), where E(x) is a reduced version of x, and calls the S1 solver again with the additional information included in the feedback and the examples.\nMC also monitors the trend in S1's confidence scores over k iterations to evaluate the improvement. Let C\u2081 = C(fs1 (xi, Mxi)) represent the confidence score after the i-th iteration on similar or modified instances. An improvement trend is identified if:\n\u2200i \u2208 {1, ..., k \u2212 1}, Ci+1 > Ci.\nIf this trend condition is not satisfied after k iterations, MC gives the problem instance to S2, invoking fs2(x) as a fallback to solve it. This ensures robustness, particularly in cases where S1's adaptation is insufficient to meet confidence requirements, even with feedback, examples, and episodic memory support."}, {"title": "Experimental Setup and Results", "content": "This section details the methodology and results of experiments designed to evaluate the performance of various solver configurations on graph coloring problems. The experiments focus on efficiency and success rate, incorporating a systematic approach to data generation, problem classification, and solver configuration.\nData Generation and Problem Classification\nGraph coloring problems were generated using the Erd\u0151s-R\u00e9nyi model, allowing for controlled variations in graph complexity through two main parameters:\nGraph Size (n): Graphs varied n \u2208 [5,50] vertices, addressing a broad range of problem sizes.\nEdge Formation Probability (p): Set with p\u2208 [0.1,0.9], this parameter adjusted the density of edges, thereby influencing the difficulty of the coloring problem.\nSolvability Mix (m): The chromatic number for each graph, crucial for defining solvability, was calculated using the DSATUR algorithm. Based on this, problems were categorized into different solvability mixes, represented by the tuple m = (a, b), where a is the percentage of solvable problems and b is the percentage of unsolvable problems:\n\u2022 m = (100,0): All problems are solvable within the given constraints.\n\u2022 m = (50,50): A balanced mix with equal solvable and unsolvable scenarios.\n\u2022 m = (0,100): All problems are unsolvable, with the allowed number of colors less than the chromatic number.\nGraphs were saved in DIMACS format to ensure standardization and enhance reproducibility.\nSOFAI-v2 Implementation for Graph Coloring\nThe SOFAI-v2 architecture integrates advanced components designed to solve graph coloring problems dynamically. Figures 8 and 4 show example prompts provided to LLM (S1) for solving graph coloring. Below, we detail the implementation of these components using formal definitions and the functions they perform within the architecture:\n\u2022 Episodic Memory Implementation: The episodic memory, denoted as M, stores historical instances of solved graph coloring problems and their solutions. This aids the S1 solver by providing access to a set of similar past problems, enhancing the adaptability and effectiveness of the solver:\nMemory Structure: Each entry in M consists of graph attributes such as nodes, edges, edge_density, chromatic_number, and the corresponding solution.\nSimilarity Assessment: A similarity function \u03c3(\u03b1, \u039c) evaluates the resemblance of the current graph attributes x to those stored in M, prioritizing instances where attribute deviations are minimal. The similarity function is defined as:\n\u03c3(x, M) = {(xj, fv2(xj)) : xj \u2208 M, d(x,xj) < a}\nwhere,\nd(x,x_j) = |attributes(x) - attributes(x_j)|, a threshold.\n\u2022 Improvement Trend Evaluation: If consecutive iterations indicate no improvement in solving capabilities, or if S1 fails to solve a problem within a set limit of five iterations, the S2 solver is invoked to ensure problem resolution.\n\u2022 Example Generation: The Graph Coloring Example Generator, E(x), simplifies the graph problem space by creating subgraphs. This module uses a greedy algorithm to propose potential solutions for these subgraphs, aiding the broader problem-solving strategy by focusing on simpler problem segments.\n\u2022 Feedback Generation and Validator: The Graph Coloring Validator assesses the validity of the proposed solutions and identifies errors such as coloring conflicts or uncolored vertices. Feedback denoted as F(fs1(x, Mx))"}, {"title": "Performance Metrics", "content": "All solver configurations, as detailed in Table 1, were evaluated using two primary metrics: success rate and average time taken. The success rate shown in Equation 1 measures the proportion of correct solutions out of the total number of problems, while the average time shown in Equation 2 taken calculates the mean time per problem solved within the time cap. The metrics are defined as follows:\nSuccess Rate(%) = (Number of Correct Solutions / Total Number of Problems) \u00d7 100\nAverage Time Taken = (\u2211i=1 ti) / n\nwhere in Equation 2, ti represents the time taken to solve the i-th problem, and n is the total number of problems solved within the time cap. Results were aggregated over three randomized trials to ensure reliability and consistency in the findings."}, {"title": "Results", "content": "This section presents an analysis of solver performance by systematically controlling key parameters. Unless mentioned, the edge formation probability is fixed to p = 0.5, allowing a focused evaluation across varying graph sizes n and solvability mixes m to capture a broad range of problem configurations. Tables 2 and 3 provide the success rate and average time taken for each solver configuration under these controlled conditions. The Supplementary Material includes results for additional p values to supplement this focused analysis, providing a comprehensive view of solver robustness across varying edge densities. From these results, we aim to address four key research questions (RQs) that provide deeper insights into SOFAI-v2 performance and robustness.\nRQ 1\nWhat improvement in success rate does SOFAI-v2 demonstrate compared to other solvers?\nAccording to the results shown in Table 2, SOFAI-v2, SOFAI-v1, and S2 exhibit comparable performance in fully solvable problem configuration (m = (100,0)). In contrast, in the unsolvable scenario (m = (0,100)) at a graph size of 50, SOFAI-v2 achieves a success rate of 53.85%, which is significantly higher than the 3.85% achieved by both SOFAI-v1 and S1. Similarly, in the mixed scenario (m = (50,50)), SOFAI-v2 continues to perform well with a 27.72% success rate, far surpassing SOFAI-v1 and S1, each at 2.11%.\nThe higher success rates of SOFAI-v2 in challenging problem configurations likely arise from its metacognitive governance that effectively identifies and resolves constraints, particularly in unsolvable configurations. This capability allows SOFAI-v2 to adapt more dynamically to complex problem sets, enhancing its performance in environments with a mix of solvable and unsolvable problems.\nAnswer to RQ 1: The SOFAI-v2 model shows enhanced performance in tackling unsolvable and mixed problem configurations, surpassing other solvers as detailed in Table 2. For example, within the unsolvable scenarios set (with m = (0, 100) at n = 50), SOFAI-v2 achieves a success rate of 53.85%. This is approximately a 1298% improvement over the success rates of SOFAI-v1 and Solver S1, which are around 3.85%. The calculation for the improvement is derived as follows:\n(53.85 - 3.85)/3.85 * 100% \u2248 1298%\nThis significant performance boost is attributed to SOFAI-v2's metacognitive governance system, which optimizes decision-making processes in complex problem configurations.\nRQ 2\nHow does SOFAI-v2 compare in terms of average time taken for solving problems relative to other solvers?\nAccording to the results in Table 3, SOFAI-v2 demonstrates distinct time efficiency advantages across various problem configurations and graph sizes. In fully solvable problems (m = (100,0)), the average solving time for SOFAI-v2 remains consistent and competitive with other solvers. However, in more complex problem configurations, such as all unsolvable problems (m = (0,100)) at n = 50, SOFAI-v2 significantly reduces the average solving time to 88.93 seconds, a 55% decrease compared to S2, requiring up to 200 seconds. Similarly, in the mixed scenario (m = (50,50)) at the same graph size, SOFAI-v2 further improves efficiency, reducing the solving time to 194.47 seconds, demonstrating a nearly 3% improvement over SOFAI_v1 (200 seconds) and S2 (200 seconds).\nThe enhanced time efficiency of SOFAI-v2 in these challenging configurations likely results from its metacognitive governance, which optimizes computational strategies to handle complex and mixed problem configurations more efficiently. This capability enables SOFAI-v2 to solve problems faster and manage its computational resources more effectively, particularly in problem configurations where solvability varies widely.\nAnswer to RQ 2: In terms of time efficiency, SOFAI-v2 significantly outperforms other solvers, notably in problem configurations involving unsolvable and mixed problems. Specifically, at a graph size of 50 within the unsolvable configuration (m = (0,100)), the average time taken by SOFAI-v2 to attempt solving these problems is 88.93 seconds, which is approximately 55% less than the 200 seconds typically required by Solver S2. The percentage reduction is calculated as follows:\n(200-88.93)/200 * 100% ~ 55%\nThis enhanced performance is attributed to the metacognitive governance within SOFAI-v2, which accelerates the problem-solving process and increases accuracy in complex problem configurations.\nRQ 3\nDoes the iterative calling mechanism in SOFAI-v2 enhance the performance of its S1 solver through metacognitive governance?\nThe iterative feedback mechanism within SOFAI-v2's S1 solver shows a clear progression in performance across different graph sizes and problem configurations, as detailed in Figure 5. Each iteration, from MC-S1-I1 through MC-S1-15, demonstrates a quantitative improvement in success rates, indicative of the solver's enhanced problem-solving capabilities due to metacognitive governance.\nIn the fully solvable problems (m = (100,0)), the success rates of the initial iteration MC-S1-11 start at approximately 20% and quickly improve to nearly 80% by MC-S1-15 for n = 5. This rapid improvement highlights the effectiveness of iterative feedback in optimizing the solver's approach to solvable problems.\nFor the entirely unsolvable problems (m = (0, 100)), success rates at n = 10 begin at about 60% during MC-S1-11 and rise to over 85% by MC-S1-15. This increase of approximately 40% in success rate across iterations underscores the solver's growing capability to efficiently recognize and handle unsolvable problem configuration without unnecessarily invoking higher-cost computational resources.\nIn the balanced mix problem configuration (m = (50, 50)), iterative feedback leads to substantial improvement across graph sizes. Initially, success rates at MC-S1-I1 are around 40% for n = 10 and increase to about 60% by MC-S1-15. This demonstrates a consistent improvement of around 50% in discerning between solvable and unsolvable problems as iterations progress, illustrating the benefits of metacognitive governance in mixed problem configurations.\nAnswer to RQ 3: The iterative calling mechanism of SOFAI-v2 substantially enhances the performance of its S1 solver in various problem configurations. For instance, in the configuration where m = (100,0), success rates escalate from 20% in the MC-S1-11 to nearly 80% by the MC-S1-15, marking an approximate 300% increase. This improvement is calculated as follows:\n(80-20)/20 * 100% = 300%\nSimilarly, in the configuration m = (0,100), the success rates rise by 40%, from 60% in MC-S1-I1 to 85% in MC- S1-15:\n(85 - 60)/60 * 100% ~ 40%\nIn the balanced scenario (m = (50,50)), there is a 50% increase in success rates, from 40% in MC-S1-11 to 60% in MC-S1-15, demonstrating the solver's adaptability:\n(60-40)/40 x 100% = 50%\nThe metacognitive governance within SOFAI-v2 facilitates these significant improvements across different configurations, enhancing the solver's efficiency and adaptability.\nRQ4\nHow does edge probability (p) influence the solvability and time efficiency of graph coloring problems across different solvers?\nThe impact of edge probability (p) on solvability and time efficiency across solvers was systematically evaluated through success rates and solving times as p ranges from 0.1 to 0.9. As p increases, all solvers generally exhibit a decreasing trend in success rates until reaching a plateau, as detailed in Figure 6. This trend indicates the increasing complexity of the graph coloring problems with more connections between nodes. Regarding time efficiency, there is a noticeable increase in average solving time, peaking before stabilizing, as shown in Figure 7.\nSOFAI-v2 consistently outperforms S1, S2, and SOFAI-v1 in maintaining higher success rates across all edge probabilities, demonstrating enhanced resilience against increasing problem complexity. Additionally, SOFAI-v2 consistently requires less time to solve problems across all configurations, highlighting its superior time efficiency.\nIn the All Solvable (m = (100, 0)) configuration, SOFAI-v2 exhibits comparable success rates as the probability p increases, similar to other solvers. In the All Unsolvable (m = (0,100)) scenario, SOFAI-v2 achieves peak success rates at an edge probability of p = 0.1, which are 20-40% higher than other solvers (SOFAI-v2 = 94%, SOFAI-v1 = 74%, Solver S1 = 68%, Solver S2 = 51%). This advantage is maintained with an approximate 10-20% lead as p increases, as illustrated in Figure 6. Additionally, in this configuration, SOFAI-v2 solves problems 60-80% faster than its counterparts at mid-range probabilities (p = 0.1 to 0.5). For instance, at p = 0.1, the solving times are as follows: SOFAI-v2 = 20 seconds, SOFAI-v1 = 55 seconds, and Solver S2 = 112 seconds, as depicted in Figure 7. In the Balanced Mix (m = (50, 50)) scenario, the success rate for SOFAI-v2 peaks at approximately 72% at p = 0.1, which is about 15-25% higher than the rates observed for SOFAI-v1, Solver S1, and Solver S2. The time efficiency in this scenario also notably surpasses other solvers, with reductions in solving times of 40-50%. Specifically, at p = 0.1, the times are: SOFAI-v2 = 70 seconds, SOFAI-v1 = 100 seconds, and Solver S2 = 108 seconds.\nAnswer to RQ 4: Edge probability (p) substantially influences solvability and time efficiency, with SOFAI-v2 showing superior adaptability and operational efficiency. In problem configurations with increasing complexity, SOFAI-v2 sustains higher success rates and achieves significant time efficiency compared to other solvers, affirming its effective metacognitive governance."}, {"title": "Discussion", "content": "This study presented SOFAI-v2, a neurosymbolic architecture that integrates a fast, experience-based S1 powered by an LLM with a slow, deliberative S2 utilizing the DSATUR graph coloring algorithm governed by real-time metacognitive governance. Our experiments evaluated the performance of SOFAI-v2 on graph coloring problems with sizes ranging from 5 to 50, generated using the Erd\u0151s-R\u00e9nyi model with an edge probability of p = 0.5. We assessed the solvers across three problem configurations: all solvable (m = (100,0)), all unsolvable (m = (0,100)), and a balanced mix (m = (50,50)). The discussion addresses the research questions posed.\nIntegrating metacognitive governance and episodic memory in SOFAI-v2 demonstrates a notable enhancement in solving graph coloring problems, significantly improving success rates and reducing computational times across various graph sizes and problem complexities. Success rates in complex scenarios like the all-unsolvable configuration reveal SOFAI-v2's superior adaptability, achieving up to a 53.85% success rate for larger graphs, a substantial improvement over SOFAI-v1 and traditional symbolic solvers. Additionally, iterative metacognitive feedback in SOFAI-v2's System 1 has proven effective in refining problem-solving strategies, increasing efficiency, and enhancing the solver's ability to differentiate between solvable and unsolvable problems. These capabilities underscore the value of combining neural and symbolic approaches to overcome limitations in traditional CSP solvers, demonstrating SOFAI-v2's potential in dynamic and demanding CSP environments."}, {"title": "Implications and Comparisons with Prior Work", "content": "This study broadens the scope of neurosymbolic systems by applying them to graph coloring problems. It demonstrates that integrating LLMs with traditional symbolic solvers, guided by metacognitive governance, significantly enhances solutions' accuracy and efficiency. Unlike previous applications that primarily leveraged LLMs for sequential decision-making tasks (Valmeekam et al. 2022; Stechly, Valmeekam, and Kambhampati 2024), SOFAI-v2 directly addresses their constraint adherence limitations through iterative feedback and strategic use of symbolic reasoning. This approach aligns with cognitive decision-making theories and shows a better success rate and time efficiency, illustrating the practical benefits of hybrid architectures in complex constraint satisfaction problems."}, {"title": "Conclusion", "content": "We introduced SOFAI-v2, a neurosymbolic architecture that integrates a fast, episodic memory-based LLM (S1) with a slow, deliberative symbolic solver (S2), enhanced by real-time metacognitive governance. Our empirical evaluations across various graph coloring problems confirm that SOFAI-v2 outperforms traditional symbolic solvers and its predecessor, SOFAI-v1, in both success rates and time efficiency, especially within complex problem configurations.\nSOFAI-v2 employs iterative metacognitive feedback and episodic memory-based iterations to enable S1 to refine its response. This effectively overcomes the limitations of LLMs in constraint adherance of CSPs. By leveraging episodic memory and adaptive feedback, SOFAI-v2 significantly enhances the accuracy and efficiency of solving CSPs, demonstrating the potential of cognitive-inspired AI architectures in managing complex challenges. Future work will scale SOFAI-v2 to tackle larger and more varied problem sets, explore different graph models, and apply the architecture to other types of CSPs and sequential decision-making tasks. Enhancing the metacognitive components with advanced learning algorithms and incorporating alternative neural models are anticipated to boost its adaptability and efficiency further, contributing to developing robust, scalable solutions for intricate AI applications."}, {"title": "Graph Coloring Problem Prompt", "content": "New Problem to Solve:\nYou are given an undirected graph with 2 colors available. Your task is to assign a color to each vertex such that no two adjacent vertices share the same color.\nGraph Representation:\nNumber of vertices and edges: p edge 5 5.\nEdges between vertices are listed as follows:\neAB\neAC\ne BC\neCD\neDE\nObjective:\nAssign a unique color to each vertex, ensuring that no two vertices connected by an edge have the same color. Use no more than 2 distinct colors. Provide the color assignments for each vertex in the format:\n(Vertex Color)\nExample Format:\n(A 1)\n(B 2)\n(C 1)\nPlease provide the color assignment for the new problem to solve, or respond with \"NOT SOLV-ABLE\" if it cannot be solved."}, {"title": "Graph Coloring Problem Prompt with Episodic Memory Example", "content": "New Problem to Solve:\nYou are given an undirected graph with 2 colors available. Your task is to assign a color to each vertex such that no two adjacent vertices share the same color.\nGraph Representation:\nNumber of vertices and edges: p edge 5 5.\nEdges between vertices are listed as follows:\ne AB\neAC\ne BC\neCD\neDE\nObjective:\nAssign a unique color to each vertex, ensuring that no two vertices connected by an edge have the same color. Use no more than 2 distinct colors. Provide the color assignments for each vertex in the format:\n(Vertex Color)\nEpisodic Memory Example:\nGraph: p edge 3 3\nEdges:\neAB\ne BC\ne CA Solution:\n(A 1)\n(B 2)\n(C 3)\nThis example is provided to demonstrate a previously successful coloring strategy for a similar subgraph, which may be helpful in solving the current problem.\nPlease provide the color assignment for the new problem to solve directly below, or respond with \"NOT SOLVABLE\" if it cannot be solved."}, {"title": "Graph Coloring Feedback - Exceeding Limit", "content": "An attempt was made to solve the graph coloring using three colors, exceeding the maximum allowed.\nOver-Colored Submission:\n(A 1)\n(B 2)\n(C 3)\n(D 1)\n(\u0395 2)\nFeedback Provided:\nError: Only 2 colors are allowed. 3 colors were used."}, {"title": "Graph Coloring Feedback \u2013 Incorrect Coloring", "content": "Given an undirected graph with 2 colors available, the vertices were incorrectly colored as follows:\nGraph Representation:\nNumber of vertices and edges: p edge 5 5.\nEdges between vertices are listed as follows:\neAB\neAC\ne BC\neCD\neDE\nIncorrect Coloring Submitted:\n(A 1)\n(B 1)\n(C 2)\n(D 2)\n(\u0395 1)\nFeedback Provided:\nError: Vertices A and B are adjacent but have the same color.\nError: Vertices B and C are adjacent but have the same color."}, {"title": "Graph Coloring Generated Example", "content": "To generate an example, a subgraph is extracted from the problem graph to demonstrate a valid coloring with fewer vertices.\nSubgraph Representation:\nSubgraph vertices and edges: p edge 3 3.\nEdges between subgraph vertices are listed as follows:\neAB\neAC\ne BC\nCorrect Coloring of Subgraph:\n(A 1)\n(B 2)"}, {"title": "Results - Success Rate", "content": "This section explores the success rates of different solvers in solving graph coloring problems across different problem configurations (m). Figure 13, Figure 14 and Figure 15 demonstrate how each solver-System 1, System 2, SOFAI-v1 and SOFAI-v2 performs across varying edge probabilities (p). These graphs show the robustness of SOFAI-v2 in terms of success rate compared to other solvers."}, {"title": "Results - Average Time Take", "content": "This section explores the time taken by different solvers to solve graph coloring problems across different problem configurations (m). Figure 16, Figure 17, and Figure 18 demonstrate how each solver-System 1, System 2, SOFAI-v1, and SOFAI-v2-performs across varying edge probabilities (p). These graphs show the time efficiency of SOFAI-v2 compared to System 2 and SOFAI-v1."}]}