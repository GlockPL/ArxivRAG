{"title": "ARS: Automatic Routing Solver with Large Language Models", "authors": ["Kai Li", "Fei Liu", "Zhenkun Wang", "Xialiang Tong", "Xiongwei Han", "Mingxuan Yuan"], "abstract": "Real-world Vehicle Routing Problems (VRPs) are characterized by a variety of practical constraints, making manual solver design both knowledge-intensive and time-consuming. Although there is increasing interest in automating the design of routing algorithms, existing research has explored only a limited array of VRP variants and fails to adequately address the complex and prevalent constraints encountered in real-world situations. To fill this gap, this paper introduces RoutBench 1, a benchmark of 1,000 VRP variants derived from 24 attributes, for evaluating the effectiveness of automatic routing solvers in addressing complex constraints. Along with RoutBench, we present the Automatic Routing Solver (ARS), which employs Large Language Model (LLM) agents to enhance a backbone algorithm framework by automatically generating constraint-aware heuristic code, based on problem descriptions and several representative constraints selected from a database. Our experiments show that ARS outperforms state-of-the-art LLM-based methods and commonly used solvers, automatically solving 91.67% of common VRPs and achieving at least a 30% improvement across all benchmarks.", "sections": [{"title": "1. Introduction", "content": "The Vehicle Routing Problem (VRP) is a fundamental Combinatorial Optimization Problem (COP) that plays a critical role in logistics, transportation, manufacturing, retail distribution, and delivery planning (Toth & Vigo, 2014; Liu et al., 2023). In these scenarios, the objective of VRPs is to efficiently allocate and plan vehicle routes to meet various requirements while minimizing overall routing costs. These requirements often include constraints such as vehicle capacities, time windows, and duration limits, resulting in numerous variants of VRPs in practical applications (Braekers et al., 2016). Existing heuristics are usually problem-specific. When the problem changes slightly (e.g., a minor modification to the requirements), a lot of effort is required for experts to redesign the heuristic to make it effective in solving the new problems (Vidal et al., 2013; Rabbouch et al., 2021; Errami et al., 2023).\nLarge Language Models (LLMs) have shown powerful reasoning and code-generation capabilities (Chen et al., 2021; Austin et al., 2021; Li et al., 2023). By integrating these functionalities, users can express their specific requirements in natural language, enabling the models to automatically design algorithms to address VRPs (Liu et al., 2024b). Most existing works primarily leverage the LLM to solve a small number of standard VRPs (Jiang et al., 2024; Huang et al., 2024) and cannot be applied to complex VRPs. Moreover, current methods rely on general solvers to optimize routes (Xiao et al., 2023; Zhang et al., 2024). However, solvers often struggle with standard modeling and exhibit low solving efficiency, making it difficult to handle complex constraints that arise in practical applications.\nTo tackle these challenges, this paper proposes a framework that uses a heuristic algorithm, developed with the assistance of LLMs, to solve the VRP variants with complex constraints. Our contributions are summarized as follows:\n\u2022 We propose ARS, a framework designed to automatically create constraint-aware heuristics based on the problem description, which enhances a backbone heuristic algorithm for route optimization, offering an adaptive framework to address the diverse routing problems expressed in natural language.\n\u2022 We introduce RoutBench, a benchmark with 1,000 VRP variants derived from 24 VRP constraints. Each variant in RoutBench is equipped with a detailed problem description, instance data, and validation code, enabling the evaluation of various routing solvers' effectiveness in handling diverse VRP constraints.\n\u2022 We comprehensively validate our approach on commonly-used problems and RoutBench. The results show that ARS can automatically handle 91.67% of commonly-used problems, achieving at least a 30%"}, {"title": "2. Problem Formulation", "content": "Vehicle Routing Problems (VRPs) involve optimizing the routes and schedules of a fleet of vehicles delivering goods or services to various locations, aiming to minimize costs while satisfying constraints like delivery windows and vehicle capacities. The VRP variants can be mathematically described as optimization problems on a graph \\(G = (V,E)\\) where nodes \\(V = \\{0,1,..., n\\}\\) represent depot 0 and locations \\(\\{1,..., n\\}\\), and edges represent the possible routes between these nodes \\(E = \\{e_{ij}, i, j \\in V\\}\\), each of them is assigned with a cost \\(c_{ij}\\). The mathematical representation is given by:\n\\begin{equation}\nmin \\sum_{i\\in V} \\sum_{j\\in V} c_{ij}x_{ij}\n\\end{equation}\nsubject to \\(X \\in C\\),\nwhere \\(x = \\{x_{ij} | i,j \\in V, i \\neq j\\}\\) represents the set of decision variables, \\(x_{ij}\\) is a binary variable that indicates whether the route from i to j is used. The feasible solution space C is defined by constraints. In this paper, we consider VRPs with a variety of real-world constraints such as vehicle capacity, travel distance, and time windows, thereby extending the basic VRP, as seen in the Capacitated VRP (CVRP) (Toth & Vigo, 2014) and the VRP with Time Windows (VRPTW) (Solomon, 1987). Moreover, new constraints often emerge in real-world scenarios. For example, VRP variants related to vehicle capacity include Heterogeneous VRP (HVRP), which considers vehicles with different capacities (Lai et al., 2016), Multi-Product VRP (MPVRP), which addresses the need to transport multiple types of products (Yuceer, 1997), and dynamic demands (Powell, 1986).\nVRP variants that incorporate these real-world constraints are more prevalent and practically significant in real-world applications\nHowever, current methods focus on a limited range of problems and do not sufficiently address the complex and diverse constraints present in real-world scenarios. To bridge this gap and further the development of automated solutions for practical VRP variants, this paper introduces a benchmark for VRPs featuring various complex yet practical constraints. Additionally, we propose a general automatic routing solver enhanced by a large language model to effectively manage these constraints."}, {"title": "3. Automatic Routing Solver", "content": "Given the problem description in natural language format and the instance data for any VRP variants with one or more constraints, our proposed automatic routing solver (ARS) can automatically generate the constraint-aware heuristic to augment the backbone heuristic solver. ARS consists of three key components: 1) Pre-defined Database, 2) Constraint-aware heuristic generation, and 3) Augmented heuristic solver."}, {"title": "3.1. Database", "content": "We build a database, denoted as \\(D\\), with several representative fundamental constraints to provide additional guidance for LLM-driven constraint-aware heuristic generation. Specifically, database D includes a basic VRP information \\((I_o, C_o)\\) (without additional constraints) and six representative constraints \\((I_k, C_k)\\), \\(k = 1, ..., 6\\), each corresponds to a distinct representative constraint: Vehicle Capacity, Distance Limit, Time Windows, Pickup and Delivery, Same Vehicle, and Priority.\nEach constraint example \\((I_k, C_k)\\) consists of two parts:\n\u2022 \\(I_k\\): The problem description. The natural language description of the constraint.\n\u2022 \\(C_k\\): The constraint feasibility checking program. It checks whether a solution belongs to the feasible solution space described by \\(I_k\\). The program is given a solution and returns 'True' if the corresponding constraint is satisfied."}, {"title": "3.2. Constraint-Aware Heuristic", "content": "We first select relative constraints from the database. Then we sequenticaly generate the constraint checking and scoring programs for the target VRP variants given the selected constraints and the problem description. Finally, the constraint-aware heuristic is generated based on the designed constraint checking and scoring programs."}, {"title": "3.2.1. CONSTRAINT SELECTION", "content": "Given an input problem description I, we instruct LLM agents to automatically select a subset of relevant constraints S from the database D to provide reference information for subsequent constraint program generation. There can be two cases. In the first case, LLM agents select one or more relative constraint examples. In the second case, if no constraints are recognized as related to the input I, the base case \\((I_o, C_o)\\), with no additional contrasts, is selected.\nThis step is similar to Retrieval-Augmented Generation (RAG) methods that retrieve information from external sources (Zhang et al., 2023; Zhou et al., 2022), while our candidate reference information is a pre-defined database with representative constraints."}, {"title": "3.2.2. CONSTRAINT CHECKING PROGRAM GENERATION", "content": "This approach works by taking a set of relevant constraints, denoted as S. For each constraint \\(C_k\\) within S, we incorporate specific modifications, \\(\\Delta C_k(I)\\), based on the problem description I. This process results in the creation of new, customized constraints \\(C_{new}\\), which are better suited to address the specific requirements of the problem. This method offers two main benefits:\n\u2022 User-Centric Design: It aligns with how users typically work by enhancing existing constraints. This allows users to refine their specific requirements without the need to develop a complete problem definition from the beginning.\n\u2022 Efficient Processing by LLMs: It helps LLM agents focus on these new, tailored constraints. This reduces unnecessary complexity and enhances the relevance and accuracy of the solutions provided by the models."}, {"title": "3.2.3. CONSTRAINT SCORING PROGRAM GENERATION", "content": "In practice, heuristic algorithms operate within a variable space that is typically much larger than the feasible solution space. This discrepancy presents significant challenges in identifying feasible solutions. To address this, heuristic methods may permit the presence of infeasible solutions during the search process, as this allows for the evaluation of potential improvements in solution quality (Deb, 2000; M\u00e1ximo & Nascimento, 2021).\nTherefore, to effectively integrate \\(C_{new}\\) into the solution process, we utilize LLM agents to generate a violation score function guided by the constraint checking program. This score function quantifies the degree of constraint violation, thereby establishing a method for handling constraints and identifying high-quality solutions. It aids in systematically assessing and managing constraint violations, facilitating the search for feasible and high-quality solutions within the expansive variable space."}, {"title": "3.2.4. CONSTRAINT-AWARE HEURISTIC", "content": "We present the Constraint-Aware Heuristic (CAH) based on the constraint checking (Checker) and scoring programs (Scorer). As seen in Algorithm 1, the constraint handling method evaluates whether a new solution \\(S_{new}\\) improves upon an old solution \\(s_{old}\\). It first verifies whether \\(S_{new}\\) is feasible (line 1). If \\(S_{new}\\) is feasible and \\(s_{old}\\) is infeasible (line 2), or both are feasible but \\(s_{new}\\) results in a smaller travel distance (line 4), \\(S_{new}\\) is accepted. If both are infeasible, the algorithm compares the violation scores of both solutions (line 8) and selects the one with the lower score. This approach allows infeasible solutions to evolve gradually toward feasibility while minimizing the overall travel distance."}, {"title": "3.3. Augmented Heuristic Solver", "content": "The solver has a general single-point-based search backbone heuristic framework. The automatically generated constraint handling codes are used for this backbone heuristic framework."}, {"title": "3.3.1. BACKBONE HEURISTIC FRAMEWORK", "content": "The backbone heuristic solver mainly consists of 1) destroy&repair and 2) local search.\nIn the destroy phase, we employ multiple operators, including random removal and string removal (Christiaens & Vanden Berghe, 2020), to selectively remove customers or partial routes from the current solution. The choice of destroy operators is determined using a roulette wheel selection mechanism, which assigns higher probabilities to operators that performed well in previous iterations. The repair phase reinserts removed customers into the solution using a greedy repair operator, aiming to construct a feasible solution with shorter routes. Specific details of these operators are provided in the Appendix B.\nFollowing the destroy and repair phases, the solution undergoes a local search process to further refine its quality. We utilize a set of local search operators, including 2-OPT, SWAP, and SHIFT, and the best solution found among these operators is selected. To avoid premature convergence, the Record-to-Record Travel (RRT) criterion is applied (Dueck, 1993; Santini et al., 2018), allowing the acceptance of slightly worse solutions within a predefined threshold, thus maintaining a balance between intensification and diversification.\nThe entire process is iteratively repeated until a termination condition is met, such as a time limit."}, {"title": "3.3.2. CONSTRAINT-AWARE HEURISTIC", "content": "Throughout the search, the constraint-aware heuristic plays a critical role in evaluating and guiding solutions. It is used in the recreate step and all local search operators. By effectively navigating infeasible regions and gradually improving solution feasibility, it ensures that the solver not only satisfies user requirements but also effectively minimizes the total route length."}, {"title": "4. RoutBench", "content": "Recent advancements in LLMs have opened up new possibilities for automatically generating routing solvers to address different VRP variants (Xiao et al., 2023). These methods have shown promising automation capabilities and have been applied to a few VRP variants (Chen et al., 2023). However, their evaluations are often constrained to some simple problems, leaving a significant gap in assessing their generalization ability. There is yet to be a VRP benchmark that can evaluate the generalization ability of these LLM-based methods, especially under complex yet common constraints in real-world scenarios.\nThus, we propose RoutBench, a benchmark dataset that includes 1,000 VRP variants derived from 24 constraints, each has three different sizes: 25, 50, and 100. As shown in Table 1, 4 variants are selected for each of the six constraint types: Vehicle Capacity (C), Distance Limits (L), Time Windows (TW), Pickup and Delivery (PD), Same Vehicle (S) and Priority (P). These constraint types are representative due to their practical significance and theoretical challenges, which already have attracted researchers' attention. These 1,000 problem instances can be divided into simple and hard based on the number of constraints.\n\u2022 RoutBench-S: 500 simple VRP variants with 3 or fewer constraints\n\u2022 RoutBench-H: 500 hard VRP variants with 4 or more constraints\nEach problem instance is comprised of three components: 1) the problem description, which is a natural language explanation of the problem; 2) the instance data, including the geometric positions of nodes and the constraint parameters; and 3) the validation code, used to confirm whether a solution adheres to user requirements and satisfies all constraints.\nBy offering a comprehensive and standard dataset for VRP variants with diverse and practical constraints, RoutBench provides a valuable test benchmark for advancing research on vehicle routing algorithms, fostering the development of practical routing solvers."}, {"title": "4.1. Dataset Construction", "content": "The RoutBench is constructed by combinations of six basic constraint types: vehicle capacity, distance limits, time windows, pickup and delivery, same vehicle constraints, and node priority. We design four representative variants derived from each basic constraint type that incorporate variations such as heterogeneous vehicle fleets, multidimensional resource limits, dynamic changes, and others. To produce one problem instance, we first pick one basic constraint combination and then pick one real constrain variant for each chosen basic constraint type. Notice that Vehicle Capacity (C) and Pickup and Delivery (PD) are mutually exclusive, since PD is essentially a derivative of C. The total number of problem combinations is :\n\\begin{equation}\nN_{combinations} = \\sum_{k=1}^{6} \\binom{6}{k} 4^k\n\\end{equation}\nwhere \\(\\binom{6}{k}\\) represents the number of ways to select k constraints from the six types, and \\(4^k\\) accounts for the four variations per constraint. After excluding combinations where vehicle capacity and pickup and delivery coexist, the total number of feasible combinations is reduced to 5624. From these, 1000 unique problem instances are uniformly sampled based on the order of all combinations, ensuring even coverage across the solution space. To balance complexity, 500 problems are sampled with three or fewer constraints, while the remaining 500 include more than three constraints.\nEach problem instance includes detailed parameters such as customer locations, demands, time windows, and other relevant attributes, with data generated using the Solomon C103 dataset as a base. Problem sizes include 25, 50, and 100 nodes. To ensure every problem has at least one feasible solution, the VRP solver in this study directly incorporates a demand verification code into its Selection Strategy. This strategy guides the search process during problem generation, ensuring that each problem is constructed with a valid and feasible solution.\nThe detailed descriptions of the 24 problem instances are provided in Appendix D. These examples illustrate the diversity of problem settings and serve as a representative subset of the dataset's broader scope. By systematically combining constraints, leveraging validation mechanisms, and ensuring feasibility, RoutBench offers a diverse and reliable dataset for benchmarking VRP solvers."}, {"title": "4.2. Analysis", "content": "This section analyzes the distribution of problem types and complexities in the RoutBench dataset, focusing on the 48-problem subset and RoutBench, and their relationship to the full set of 5624 feasible problems.\nThe distribution of problems by the number of constraints is shown in Figure 2. Among the 48 problems, one is a simple VRP without any constraints, while the remaining 47 include one to five constraints. In RoutBench, the distribution reflects the proportions of the full set of 5624 problems. Specifically, problems with three constraints are the most common in the dataset, as three-constraint problems dominate the total number of problems with three or fewer constraints. For more complex problems, those with four and five constraints appear in similar proportions, ensuring a balanced representation of high-complexity scenarios.\nFigure 3 shows the distribution of problem types across RoutBench. Most problem types, such as VRPTW, HVRPL, and CluVRP, are well-represented. However, problems involving vehicle capacity constraints (e.g., CVRP, HCVRP) and pickup and delivery operations (e.g., VRPMPD, HVRPMPD) are less frequent. This is because these two categories are mutually exclusive, and the two types do not coexist in the dataset.\nOverall, the RoutBench dataset achieves a diverse and balanced representation of problem types and complexities. The 48-problem subset provides a concise overview of simpler cases, while RoutBench captures a wide range of scenarios."}, {"title": "5. Experiments", "content": "The experiments are conducted on common benchmark problems and RoutBench, which include 48 and 1,000 VRP variants, respectively. These variants cover a wide range of real-world problem types, such as heterogeneous, dynamic, multi-commodity, and others.\nTo evaluate the performance of these LLM-based methods in handling different VRP variants, we assess their ability to generate correct programs within our solver. To analyze the impact of different solvers on the generated programs, we compare our solver with other solvers (e.g., Gurobi and OR-Tools) to investigate their influence. Additionally, we included experiments with other open-source and proprietary LLMs (e.g., DeepSeek v3 and LLaMA 3.1 70B) to explore their impact on program development."}, {"title": "5.1. Comparison with LLM-Based Methods", "content": "The first experiment aims to evaluate the ability of ARS to produce successful programs. We compare our proposed ARS with seven LLM-based methods, including Standard Prompting, Chain of Thought (CoT) (Wei et al., 2022), Reflexion (Shinn et al., 2024), Progressive-Hint Prompting (PHP) (Zheng et al., 2023), Chain-of-Experts (CoE) (Xiao et al., 2023), Self-debug (Chen et al., 2023), and Self-verification (Huang et al., 2024). To focus on program development, all methods are implemented using our backbone algorithm framework to handle various VRP variants.\nThis experiment is conducted on the common problems and RoutBench. We use two metrics to evaluate the results. The Success Rate (SR) measures the proportion of the program where generated solutions pass the validation process. The Runtime Error Rate (RER) quantifies the percentage of programs that fail due to issues such as runtime errors, incorrect API usage, or syntax mistakes.\nAs shown in Table 2, ARS significantly outperforms other LLM-based methods in generating correct programs for both common problems and RoutBench. It is evident that these compared methods exhibit unsatisfactory performance across all problems, particularly on the RoutBench-H problems, where their SR is merely around 10%. None of the compared algorithms achieved an SR of 50% or higher. In contrast, ARS achieved an SR of 91.67% on the common problems, successfully addressing 44 out of 48 VRPs. Moreover, on RoutBench, ARS outperformed all seven other LLM-based methods by at least 30% in terms of SR. These results highlight ARS's competitiveness in addressing complex VRP variants."}, {"title": "5.2. Comparison with Different Solvers", "content": "In the previous experiment, to focus on generating correct programs, all methods use the same solving framework to handle VRP variants. To explore the impact of different solving tools on program development, this experiment uses Standard Prompting with three solving tools (OR-tools, Gurobi, and our backbone) for common problems.\nAs shown in Table 3, both SR and RER achieve significantly better results when using our framework compared to OR-tools and Gurobi. Under standard prompting, our framework achieves an SR of 41.67%, whereas OR-tools and Gurobi reach only about 10% SR. This is because, in our framework, the LLM only needs to complete the constraint codes in Python, whereas the use of solvers is restricted by their specific implementations and requires highly standardized modeling. For the same VRP variants, our solving framework simplifies program development considerably"}, {"title": "5.3. Evaluation with Different LLMS", "content": "We further investigate the impact of using different LLMs for generating correct programs to solve VRP variants under standard prompting and ARS. The LLMs evaluated include GPT-3.5-Turbo, GPT-40, DeepSeek-V3, and LLaMA-3.1-70B.\nAs shown in Figure 4, the success rate of solving VRP variants varies across different LLMs. All methods benefit from more advanced LLMs, leading to improved accuracy. The results indicate that DeepSeek-V3 is the most effective LLM for handling VRP variants among these LLMs. When using DeepSeek-V3, ARS achieves an SR of 77.20% on simple problems in RoutBench. The improvement is even more pronounced for RoutBench-H problems, where ARS attains an SR of 61.60%."}, {"title": "5.4. Ablation Study", "content": "An ablation study is conducted to evaluate the program development component of ARS. To analyze the impact of our database and constraint selection step on ARS, experiments are performed by removing each of these components separately.\nAs shown in Table 5, removing the constraint selection step leads to a decrease in the SR of ARS. This is because, without constraint selection, ARS acquires all six representative constraints, which are not necessarily all relevant to the current VRP. Consequently, this irrelevant information may mislead the LLM.\nCompared to constraint selection, removing the database has a more significant impact on the performance of ARS in generating correct programs. As previously discussed, ARS can be refined based on relevant constraints, thereby focusing on the distinctive aspects of a VRP variant. However, without reference to relevant constraints, the LLM must independently generate all the constraints, imposing a higher requirement on the LLM.\nThe results of this ablation study demonstrate that ARS achieves optimal program development performance only when both components are utilized."}, {"title": "6. Conclusion", "content": "In this paper, we have proposed ARS, a framework that leverages LLMs to automatically design constraint-aware heuristics to enhance a heuristic routing optimization framework for tackling VRP variants with complex and practical constraints. Moreover, we have developed and presented RoutBench, a comprehensive benchmark consisting of 1,000 VRP variants derived from 24 VRP constraints. Each variant includes a problem description, instance data, and validation code, enabling standard evaluation of routing solvers.\nThe experimental evaluations of ARS have been particularly promising, demonstrating a superior performance over existing LLM-based methods and commonly used solvers. Specifically, ARS achieved a remarkable success rate of 91.7% in automatically solving common VRP instances and registered at least a 30% improvement across all tested benchmarks. In the future, we would like to extend the ARS framework to address other combinatorial optimization challenges, including scheduling and bin packing."}, {"title": "Impact Statement", "content": "This paper presents work whose goal is to advance the field of Machine Learning. There are many potential societal consequences of our work, none of which we feel must be specifically highlighted here."}, {"title": "A. Related works", "content": "A.1. Heuristics for VRPS\nThe Vehicle Routing Problem (VRP) is a classical combinatorial optimization problem that seeks optimal routes for vehicles to serve customers under constraints like capacity and time windows (Dantzig & Ramser, 1959). Variants such as the Capacitated VRP (CVRP) (Lysgaard et al., 2004), VRP with Time Windows (VRPTW) (Solomon, 1987), and Multi-Depot VRP (MDVRP) (Yuceer, 1997) have been extensively studied.\nTo address VRP's computational challenges, heuristic methods are widely used. Local Search (LS) iteratively improves solutions using operators like 2-opt or 3-opt (Lin, 1965), while Iterated Local Search (ILS) introduces perturbations to escape local optima (Louren\u00e7o et al., 2003). Simulated Annealing (SA) explores worse solutions probabilistically to avoid stagnation (Kirkpatrick et al., 1983), and Tabu Search (TS) prevents revisiting solutions using a tabu list (Glover, 1989). Variable Neighborhood Search (VNS) systematically adjusts neighborhood structures for better exploration (Mladenovi\u0107 & Hansen, 1997).\nAdaptive Large Neighborhood Search (ALNS) selects neighborhood operators adaptively based on performance (Ropke & Pisinger, 2006). Recent ALNS variants integrate machine learning to predict effective operators (Mara et al., 2022) and reinforcement learning to optimize selection policies (Wang et al., 2024). Hybrid ALNS approaches, such as combining ALNS with branch-and-price, have further improved performance on constrained VRPs (Vidal, 2022).\nIn summary, these heuristic advancements have significantly promoted VRP research by enabling efficient solutions to increasingly complex and large-scale problem instances."}, {"title": "A.2. LLMs for VRPS", "content": "Recent advancements in large language models (LLMs) have opened new possibilities for solving vehicle routing problems (VRPs) by leveraging their ability to process and embed complex tasks through natural language understanding (Huang et al., 2024). These models have been applied to classical optimization problems such as the traveling salesman problem (TSP) and CVRP. In particular, LLMs, combined with evolutionary computation (EC), have demonstrated potential in automating the discovery of heuristics for VRPs (Liu et al., 2024a). For instance, guided local search and other algorithmic frameworks can be evolved with the assistance of LLMs, albeit requiring significant domain-specific expertise and computational resources for iterative model invocation (Wang et al., 2024).\nAnother line of research emphasizes the transformation of textual problem descriptions into mathematical formulations and executable code that can be processed by external solvers (Tang et al., 2024). This approach benefits from LLMs' ability to interpret user queries and generate structured outputs, enabling the automation of optimization tasks. Furthermore, multi-agent systems have been introduced to coordinate LLM-based agents for tasks such as problem formulation, programming, and evaluation (Xiao et al., 2023). While promising, these methods are inherently limited by the scope of the knowledge encoded within the pre-trained models, which restricts their applicability to novel or highly complex problems (Zhang et al., 2024).\nTo address these challenges, emerging studies focus on directly generating executable programs for VRPs by integrating LLMs with external knowledge sources. This approach bypasses the intermediate step of mathematical model formulation and instead leverages both the intrinsic reasoning capabilities of LLMs and external references to enhance problem-solving efficacy (Huang et al., 2024). Such integration aims to reduce reliance on domain-specific expertise while expanding the range of solvable problems, marking a shift towards more generalized and adaptive optimization frameworks (Romera-Paredes et al., 2024)."}, {"title": "B. Operator", "content": "Local search operators are critical components of heuristic methods, designed to explore the neighborhood of a solution and improve its quality. The commonly used operators are as follows:\n2-opt Operator. The 2-opt operator is a classical approach originally developed for the Traveling Salesman Problem (TSP). It works by removing two non-adjacent edges in the solution and reconnecting them in a different way, thereby altering the order of nodes. If the new configuration reduces the total cost, it is accepted as an improved solution.\nSwap Operator. The Swap operator exchanges the positions of two elements in the solution, generating a new configuration.\nThis simple yet effective operator promotes diversity in the solution space and helps avoid local optima.\nShift Operator. The Shift operator moves an element from its current position to another position within the same solution or a different one. This adjustment redistributes the structure of the solution, enabling further exploration of the search space and improving solution quality.\nDestroy Operator. The Destroy operator partially disrupts the current solution by selectively removing some elements, breaking its local optimality and enabling exploration of new regions in the search space. Two common implementations are Random Removal and String Removal:\n\u2022 Random Removal: This method removes elements uniformly at random, without relying on specific heuristics, making it a simple yet effective way to diversify the search process.\n\u2022 String Removal: This method targets sequences of consecutive or related elements (strings), such as partial routes or groups of customers (Christiaens & Vanden Berghe, 2020). It begins by randomly selecting a \"center\" customer and removing a string of nearby customers from the route. The string size is randomly determined, constrained by the average route size and a predefined maximum. If constraints on the number of disrupted routes or previously disrupted routes are met, further removal is skipped.\nRepair Operator. The Repair operator complements the Destroy operator by reinserting removed elements to reconstruct a complete solution, guided by optimization objectives. A commonly used implementation is the Greedy Repair:\n\u2022 Greedy Repair: This method reinserts removed elements one by one, selecting at each step the position that minimizes the objective function. By prioritizing optimal insertions, it balances solution quality with search efficiency.\nThese operators, through targeted adjustments, provide the foundation for heuristic and metaheuristic algorithms, enabling efficient exploration and exploitation of the solution space."}, {"title": "C. Prompts of ARS", "content": "Automatic Routing Solver (ARS) is designed to perform three key steps leveraging the capabilities of LLMS: Constraint Selection, Constraint Checking Program Generation, and Constraint Scoring Program Generation. In this section, we describe the prompt engineering involved in each step. These prompts are constructed based on user inputs and several representative constraints stored in the database to generate the Constraint Checking Program and the Constraint Scoring Program. Variable information, such as user inputs and constraint descriptions, is highlighted in blue for clarity.\nStep 1: Constraint Selection. In the first step, the ARS identifies constraints relevant to the user's input from the database. This step processes the user input and matches it against the constraints stored in the database. If relevant constraints are found, they are selected for further processing. Otherwise, LLM outputs \"No Relevant Constraint\u201d. This step ensures that only the constraints pertinent to the user's query are considered in subsequent steps."}, {"title": "D. VRP Variants", "content": "The common VRP variants may involve several representative constraints, such as vehicle capacity, distance limits, time windows, pickup and delivery, same vehicle, and priority. As shown in Table 6, these six representative constraints can be combined to generate 48 common problems, with the exception of cases where vehicle capacity and pickup and delivery appear together."}, {"title": "E. Experimental Details", "content": "Experiments are performed on a computer with an Intel Xeon Gold 6248R Processor (3.00 GHz), 128 GB system memory, and Windows 10.\nIn RoutBench, the ARS heatmaps illustrate the frequency of simultaneous errors encountered when solving composite Vehicle Routing Problems (VRPs). The horizontal and vertical axes correspond to 24 specific VRPs, with each cell representing the total number of errors occurring when solving a composite problem that includes both the row and column problems. The diagonal values indicate the total number of errors for individual problems, reflecting their inherent difficulty.\nIn the RoutBench-S, the number of errors in priority problems is significantly higher than in other types of problems. This may be due to the inability of LLMs to adequately understand and handle priority issues. When transitioning to the RoutBench-H, the four time-window-related problems exhibit a significantly higher number of errors compared to other problem types. This suggests that time-window problems are inherently more complex. In contrast, regardless of whether the problems are RoutBench-S or RoutBench-H, our algorithm performs exceptionally well in terms of modeling success rates for capacity constraints and return point constraints."}, {"title": "F. Examples of Program Codes", "content": "To better analyze different methods for solving VRPs, we provide code examples for three approaches: our solver, Gurobi, and OR-Tools. As a case study, these methods are applied to the Capacitated Vehicle Routing Problem with Time Windows (CVRPTW) to illustrate their respective requirements and complexities.\nFrom the provided code examples, it is clear that our solver requires the least amount of code to be generated by an LLM. This is attributed to the simplicity and flexibility of our method, which avoids the need for verbose or overly rigid programming constructs. In contrast, the code examples for Gurobi and OR-Tools are more extensive, primarily due to their reliance on strict syntax rules and detailed configurations."}, {"title": "G. Database", "content": "The database contains six representative constraints, which exemplify problems related to these constraints. If no example problem is associated with the given input I, the base case (Io, Co), which includes no additional constraints, will be selected. The following sections introduce these six representative constraints and the base case."}, {"title": "G.1. No Additional Constraints", "content": "Constraint Description: No additional constraints.\nVerification Code:"}, {"title": "G.2. Vehicle Capacity"}]}