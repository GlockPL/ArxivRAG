{"title": "Pruning Boolean d-DNNF Circuits Through Tseitin-Awareness", "authors": ["Vincent Derkinderen"], "abstract": "Boolean circuits in d-DNNF form enable tractable probabilistic inference. However, as a key insight of this work, we show that commonly used d-DNNF compilation approaches introduce irrelevant subcircuits. We call these subcircuits Tseitin artifacts, as they are introduced due to the Tseitin transformation step\u2014a well-established procedure to transform any circuit into the CNF format required by several d-DNNF knowledge compilers. We discuss how to detect and remove both Tseitin variables and Tseitin artifacts, leading to more succinct circuits. We empirically observe an average size reduction of 77.5% when removing both Tseitin variables and artifacts. The additional pruning of Tseitin artifacts reduces the size by 22.2% on average. This significantly improves downstream tasks that benefit from a more succinct circuit, e.g., probabilistic inference tasks.", "sections": [{"title": "I. INTRODUCTION", "content": "Boolean circuits represent Boolean functions in a manner that allows certain operations to become feasible. In this work we focus on d-DNNF circuits (see Fig. 1 for an example), because they allow us to compute the weighted model count in polytime, despite it being a computationally hard task in general [1]. As such, they play an important role in enabling tractable probabilistic inference [2]\u2013[7]. Furthermore, a key advantage of the circuit-approach to computing the weighted model count, is that when the weights change, the same compiled circuit can be reused and only the circuit evaluation must be repeated. This effectively amortizes the compilation cost across evaluations, and is especially relevant in the context of parameter learning where the parameters evolve over many evaluations. However, in such a context, the circuit size also becomes important. In neuro-symbolic AI, for instance, where such circuits are being combined with neural networks, many evaluations take place during training and an efficient circuit evaluation is key to maintaining a fast enough neural network learning pipeline [8], [9]. To conclude, besides efficiently obtaining a d-DNNF circuit, it is also important that these circuits are succinct.\nTo obtain a succinct d-DNNF circuit from any Boolean circuit, the field of knowledge compilation has developed several d-DNNF compilers. The CDCL-based class of compilers, which includes D4 [10] and sharpSAT-TD [11], requires the input circuit to be in conjunctive normal form (CNF). The most prominent algorithm to efficiently obtain this form"}, {"title": "II. BACKGROUND", "content": ""}, {"title": "A. Propositional Logic", "content": "We use the standard terminology of propositional logic. A literal is a Boolean variable v or its negation \u00ac\u03c5. \u0391"}, {"title": "B. Weighted Model Counting", "content": "Definition 1 (weighted model count): Given a propositional formula \u03c6 over variables V, and weight function w that maps each literal to a real value, the weighted model count is defined as\n$WMC(\\psi,V,w) = \\sum_{model of \\psi} \\prod_{lit \\in model}w(lit)$.\n(1)\nWe will use WMC(\u03c8,w) when V is clear from context, and MC(\u03c6) to refer to unweighted model counting, which is equivalent to using weight 1 for all literals. Since probabilistic inference can be cast as a weighted model counting (WMC) task [2], [13], efficiently computing the WMC is of great interest. This is possible using a compilation-based approach."}, {"title": "C. Circuit Properties", "content": "The structure of a propositional formula \u03c6 is a tree. When allowing reuse of substructures, i.e., when we have a more general single-rooted DAG structure, we instead use the term Boolean circuit. There are several structural properties [2] that such a circuit may have, and that are of interest to our work.\nDefinition 2 (determinism (d)): A Boolean circuit \u03c6 is deterministic iff for each \u03c8\u2081 V \u03c8\u2082 within \u03c6, \u03c8\u2081 and \u03c8\u2082 do not share any models. That is, \u03c8\u2081 \u2227 \u03c8\u2082 = \u22a5.\nDefinition 3 (Decomposability (D)): A Boolean circuit \u03c6 is decomposable iff for each \u03c8\u2081 \u039b \u03c8\u2082 within \u03c8, \u03c8\u2081 and \u03c8\u2082 do not share any variables.\nDefinition 4 (Negation Normal Form (NNF)): A Boolean circuit is in negation normal form iff it consists only of V, \u039b, and literals (negation is only allowed over variables).\nDefinition 5 (smoothness (s)): A Boolean circuit \u03c6 is smooth iff for each \u03c8\u2081 V \u03c8\u2082 within \u03c6, \u03c8\u2081 and \u03c8\u2082 contain the same variables.\nWhen \u03c6 satisfies the sd-DNNF properties, its WMC can be computed in time linear in the size of the representation by a single bottom-up evaluation. The smoothness property is less important from a computational complexity perspective as it is obtainable in polytime while preserving the d-DNNF properties [14], [15]. Furthermore, if w(v) + w(\u00abv) = 1 holds for all variables V (for example within a probabilistic inference context when the variables represent a Bernoulli distribution), then the smoothness property is unnecessary and a d-DNNF circuit suffices to efficiently compute the WMC."}, {"title": "D. CDCL Algorithm", "content": "Several algorithms have been developed to compile a Boolean circuit into a d-DNNF. Many state-of-the-art compilers are based on the CDCL algorithm that was initially developed for SAT solving, but can be adapted for compilation. Examples include D4 [10] and sharpsat-TD [11], [16]. For a more detailed explanation of these algorithms we refer to [10], [11], [17].\nImportant to understanding our contributions is that these algorithms operate on a CNF formula \u03c6, and that they iteratively condition on literals until the remaining formula is satisfied.\nExample 2: Consider the following \u03c6, a CNF of two clauses.\n\u03c6 := (a \u2228 \u00acb) ^ (a \u2228 \u00acc)\n(2)\nIf a CDCL-based algorithm were to condition on \u00acb, clauses that contain \u00acb are removed, and b is removed from every clause. The remaining formula is \u03c8|\u00ac\u044c = (a V \u00abc). When then conditioning on a, the remaining formula is |\u00acb,a = T, and the algorithm backtracks to cover the other models in a similar fashion.\nAlso relevant is component decompositioning [18], a very effective optimisation used within weighted model counting and d-DNNF compilation to reduce the search space. This optimisation exploits the fact that if a CNF can be partitioned into sets of clauses that do not share any variables (called components), then these can be treated separately. Furthermore, these components can be cached such that when they are encountered again later in the search space, the cached result can be reused. For d-DNNF compilation, this enables reuse of subcircuits and results in a DAG rather than a tree. The effectiveness of this optimisation has lead the community to propose a variety of component representations [19]\u2013[21].\nExample 3: Consider the following CNF of three clauses.\n\u03c8 := (a \u2228 \u00acb) ^ (a \u2228 \u00acc) \u2227 (\u00acd Ve)\nThe first two clauses together form a component C1, while the third clause forms component C2 as it does not share any variables with the previous clauses. From a weighted model count perspective we have (3) which indicates that the model count of each component can be computed separately.\nWMC(\u03c8,V,w) = WMC(C1, w) \u00d7 WMC(C2, w), (3)"}, {"title": "E. Tseitin Transformation", "content": "The Tseitin (or Tseytin) transformation is a procedure by which any Boolean circuit \u03c6 can be converted into CNF [12]. The main idea powering this transformation is that, when we introduce a new auxiliary Boolean variable x to refer to a subcircuit \u03c8', we can conveniently replace each occurrence of \u03c8' by x. For larger nested circuits this significantly simplifies the CNF transformation because each (l \u21d4 Vili) and (l\u21d4 \u039bili) can easily be transformed into a CNF where the number of clauses is exactly equal to the number of literals li and l. The number of clauses in the resulting CNF is therefore linear in the number of subcircuits \u03c8' and in the number of literals occurring in \u03c8.\nExample 4 (Tseitin transformation): Consider the circuit \u03c8 given below.\n\u03c8 := (ab) V (cd)\n(4)\nThe Tseitin transformation introduces new variables x1 and x2 to refer to (ab) and (cd) respectively. Using this new equivalence, the original circuit \u03c8 could be summarized as\nT(\u03c8) := (x1 \u2228 x2) \u2227 (x1 \u21d4 a^ b) ^ (x2 \u2194 c^d). (5)\nAs CNF, this results in circuit CNF(T(\u03c8)), displayed below as a conjunction of seven clauses.\n(x\u2081 \u2228 \u00aca\u2228 \u00acb)^ (\u00abx1 Va) ^ (\u00acx1 \u2228 b)^\n(x2 \u2228 \u00acd V \u00abc) ^ (\u00abx2\u2228 d) ^ (\u00acX2 V c) ^ (X1 \u2228 X2) (6)\nIn this example we distinguished T(4) from CNF(T(\u03c8)). In the remainder of this paper we use T(4) to refer to the circuit resulting from the Tseitin transformation on \u03c8. Its exact representation, as a CNF (6) or not (5), will generally not be important. In case it is important, the representation we refer to will be clear from context.\nNote that \u03c8 and T(4) are not equivalent as T(\u03c8) contains variables that are not present in 4, and that were introduced by the Tseitin transformation. We call these Tseitin variables. Importantly, there is a one-to-one mapping between the models of \u03c8 and the models of T(\u03c8) [22]. By construction, each model of \u03c8 implies a truth value for the Tseitin variables in T(\u03c8) through the equivalences introduced by the transformation (5). In the other direction, ignoring the Tseitin variables from a model of T(4) yields exactly one model of \u03c8. As a consequence, we have the following relation (7) where X is the set of Tseitin variables introduced during the Tseitin transformation.\n\u039e\u03a7.\u03a4(\u03c8) = \u03c8 (7)\nWhen computing the weighted model count of using T(4), the weight of a Tseitin variable X is typically set to one (w(x)=1=w(\u00abx)). This preserves the weight of each model and consequently also the weighted model count of \u03c6."}, {"title": "III. WHAT ARE TSEITIN ARTIFACTS?", "content": "We first informally introduce the concept that we refer to as a Tseitin artifact. A more formal definition is then provided afterwards. We study these artifacts in the context of d-DNNF compilation. Therefore, suppose we wish to obtain a d-DNNF representation of circuit \u03c8 (4) in Example 4. We will use a CDCL-based d-DNNF compiler that requires a CNF as input, so we first use the Tseitin transformation to obtain T(4) (6). Fig. 1 shows a possible output of the compiler, ad-DNNF circuit representing \u03a4(\u03c8). Since we are interested in the number of computations during evaluation, we define the circuit size as the number of binary nodes (e.g., a node with three inputs represents two binary nodes, and so on). The size of the d-DNNF in Fig. 1 is 16."}, {"title": "A. Existential Quantification of Tseitin Variables", "content": "The circuit in Fig. 1 is a d-DNNF and can hence be used to efficiently compute the weighted model count of T(4) and 4. The current representation, however, does contain many unnecessary elements. In particular, the Tseitin variables X were introduced by the Tseitin transformation to easily obtain a CNF, but are irrelevant to downstream counting tasks. These variables can be removed through existential quantification, i.e., by computing \u2203X.T(\u03c8).\nThanks to the decomposability property, existential quantifi-cation of X \u2208 X is very simple here: replace each occurrence of x and \u00acx in the formula by T. We refer to this procedure as EXISTS(\u03c8, \u03a7). This procedure is guaranteed to preserve the DNNF properties [22]. Additionally, recent work has proven that since we existentially quantify Tseitin variables, this procedure is guaranteed to also preserve determinism [11].\nFig. 2 shows the circuit of Fig. 1 after performing existential quantification of the Tseitin variables. Combining the results above with (7), it follows that Fig. 2 again represents circuit \u03c8 instead of T(\u03c8), but now as a d-DNNF due to the earlier compilation step."}, {"title": "B. Tseitin Artifacts", "content": "The subcircuit f whose root is marked in red in Fig. 2, is given in (8). While this subcircuit initially represented (x2 \u2194 c\u2227 d), which is not a tautology, after performing the existential quantification of x2, it did become a tautology.\n\u2203x2.f = (((\u00acd^c) \u2228 \u00acc) ^T) V (T^c^d) =T (8)\nThis means that f can be entirely replaced by T. Indeed, consider the initial circuit \u03c8 of Example 4 and note that a,b = T. We call f a Tseitin artifact, a tautological subcircuit introduced to the compiled circuit due to the Tseitin transformation.\nDefinition 6 (Tseitin artifact): A (sub)circuit f(X, Y) over Tseitin variables X and non-Tseitin variables Y is Tseitin artifact if and only if it is a tautology when existiantially quantifying over X. That is, when \u2203X. f(X,Y) = T.\nThis definition can be generalised beyond Tseitin variables X, to variables that are completely defined by other variables (cf. the definition of definability by [11], [23]). Our focus on Tseitin variables is a practical choice. First, they are known to be defined by other variables so we do not need a procedure to determine the set of defined variables. Second, they are irrelevant from a user perspective. That is, these variables are not present in the original circuit (pre-Tseitin transformation) so we can safely assume they are irrelevant to any downstream model counting task and can thus be removed.\nOur insight can be applied more generally: if a (sub)circuit is equivalent to T, you can replace it with T to reduce the circuit size. However, a top-down d-DNNF compiler would never produce such subcircuits under normal conditions because a non-empty CNF is never equivalent to T (unless we allow CNFs of only trivial clauses such as x V \u00abx). Subcircuits that are equivalent to T only emerge within a d-DNNF once we perform existential quantification, which is advised when using the Tseitin transformation as we show in the experiments. We therefore position our insight around Tseitin variables, and refer to the subcircuits as Tseitin artifacts.\nExistential quantification of Tseitin variables using the EXISTS procedure of section III-A does not eliminate all Tseitin artifacts. For example, while propagating T in Fig. 2, we would not have realised that subcircuit f (node marked in red) is equivalent to T, missing the possible reduction to a circuit of size 6 instead of 11. In the next section we study how to detect these artifacts and how they emerge."}, {"title": "IV. DETECTING TSEITIN ARTIFACTS", "content": ""}, {"title": "A. How To Detect Them?", "content": "Tseitin artifacts can be detected in an sd-DNNF represen-tation in time linear in the size of the sd-DNNF.\nProposition 1: When f(X, Y) is a (sub)circuit of a d-DNNF representation for T(\u03c8), over Tseitin variables X and non-Tseitin variables Y, then f is a Tseitin artifact if and only if the unweighted model count is MC(f) = 2|Y|.\nProof: We know MC(f) = MC(\u2203X. f(X, Y)), because by construction a Tseitin variable X is completely defined by non-Tseitin variables Y.\nMC(f) = 2|Y| \u2194 MC(\u2203X.f(X, Y)) = 2|Y|\nX. f(X, Y) = T \u2194 f(X,Y) is a Tseitin artifact\nIt is well known that the model count for each sd-DNNF (sub)circuit can be computed in time linear in the size of the representation, and that a similar approach can be used for non-smooth d-DNNF representations by performing the appropriate smoothing operations in polytime either before or during evaluation [1], [15]. Furthermore, since we only require unweighted model counts, smoothing is unnecessary and we only need to know the number of variables that would have to be smoothed over. The number of these so called free variables is easy to extract during the compilation process. Combining this fact with Proposition 1, we can detect Tseitin artifacts by computing the unweighted model count of each subcircuit f(X, Y) using a single bottom-up evaluation. If the model count is equivalent to 2|Y|, f is a Tseitin artifact and it can be removed when we existentially quantify over X."}, {"title": "B. When Do They Emerge?", "content": "Next we provide more intuition on when these artifacts may emerge within CDCL-based d-DNNF compilers. This helps to identify the types of circuits for which our proposed technique (removing Tseitin artifacts) has a high impact. Consider again \u03c8 and T(4) from Example 4.\n\u03c8 := (a^ b) V (cd)\nT(\u03c8) := (x1 V X2) \u2227 (x1 \u21d4 a > b) \u2227 (x2 \u2194 c^d)\nWhen a d-DNNF compiler conditions on x1 (9), the clause (x1Vx2) becomes satisfied and, since x2 is not used elsewhere, the Tseitin equivalence (x2 \u2194 c^d) will emerge as a Tseitin artifact (after component decompositioning which splits off the (ab) part).\nT(\u03c8)|x\u2081 = (ab) \u2227 (x2 \u21d4 \u0441^d) (9)\nMore generally, if 1 and 2 are circuits more complex than a single literal, appearing together as 41 V 42, such that 142 \u2260 1, then a Tseitin artifact may emerge depending on the variable ordering of the CDCL compiler. We empirically"}, {"title": "V. RELATED WORK", "content": "Prior work [22] has studied the usage of existential quan-tification, the EXISTS procedure, to obtain succinct DNNF circuits. Continuing on this result, [11] proved that existential quantification of X also preserves determinism if X is defined in terms of the other variables, and is thus applicable when targetting d-DNNF circuits. Our work continues on these findings, realising that this procedure may result in subcircuits that can be removed to reduce the circuit size even further.\nThe concept of definability, which strongly relates to the Tseitin variables, has previously been used in preprocessing, altering the CNF to improve model counting [23], [26]. Similarly, the variable elimination approach of [11] could eliminate Tseitin variables prior to compilation. While this is beneficial in some cases, it may also degrade performance in the context of Tseitin variables as these were introduced exactly to ensure a small CNF size (with likely faster compilation) [11]. For this reason they consider heuristics to determine which variables to eliminate. Furthermore, prior elimination of the Tseitin variables prevents the compiler from conditioning on them. This may lead to larger circuit sizes and a potential increase in compilation time.\n[27] proposed a novel projected model counter restricted to Horn clauses, which are clauses whose form is equivalent to (li) \u21d2 h, with li and h positive literals or T. The relation to our work is their propagation technique. This technique is based on the insight that during the counting process, if h is an auxiliary variable that is not constrained by any other remaining Horn clause, then its associated clause can be satisfied without impacting the count. In other words, they can remove such clauses (only because h is an auxiliary variable).\nThis relates to the Tseitin artifacts, although these emerge from an equivalence structure rather than an implication and are not restricted to projected model counting."}, {"title": "VI. EXPERIMENTS", "content": "Given the influence of the variable ordering and the structure of disjunctions within 4, a natural research question is: how prevalent are Tseitin artifacts? We primarily focus on the former, avoiding instances that we know will not contain Tseitin artifacts (i.e., Bayesian networks with mutual exclusive disjunctions). We study the effect of removing Tseitin artifacts on the circuit size, and compare the effect of performing sim-ple existential quantification (denoted as d-DNNF+p) versus removing the Tseitin artifacts entirely as well (denoted as d-DNNF+t)."}, {"title": "A. Datasets", "content": "a) Reverse-engineered CNFs (MCC): Benchmarks used for weighted model counting and d-DNNF compilation are typically CNF formulas already, so these are not useful from"}, {"title": "VII. CONCLUSION", "content": "The Tseitin transformation introduces auxiliary variables to obtain a small CNF circuit. These variables can easily be removed after d-DNNF compilation. But as we have shown, subcircuits that are trivially satisfied may then emerge. Fortunately, we can easily detect and remove such artifacts using a single bottom-up evaluation of the d-DNNF circuit. We have empirically shown the positive impact of pruning these artifacts on the final circuit size. In future work, we will investigate the detection and removal of these artifacts during compilation, with the additional aim of reducing compilation time. This requires a new detection mechanism as the current one relies on each subcircuit to already be compiled."}, {"title": "APPENDIX A MUTUALLY EXCLUSIVE DISJUNCTION", "content": "A Bayesian network whose conditional probability tables are encoded in a way that each V is mutually exclusive, results in few Tseitin artifacts. We illustrate one such probability table, P(CA, B):\nC (a^b^\u03b8\u03b1,)\nV (a^b^0-6)\n(a^b^0a,b)\n(\u00aba>\u00abb^0a,\u00acb).\n(12)\nWe now briefly discuss one of the few found Tseitin artifacts. The subformula that formed this artifact was (using equiva-lences instead of CNF for clarity, and x and y to distinguish the Tseitin and non-Tseitin variables respectively):\n(X306 X296)\u2227 (X296\u2194\n295)\u2227\n(X321X311) \u2227 (X311\u2194 Y310)\u2227\n(X322 X321X306).\n(13)\nThe Tseitin artifact of this formula is illustrated in Fig. 9. To understand how this artifact emerged, we explain the meaning behind (13) and how the conditioning process led to its existence. The role of x306 within andes is akin to cin (12). (x306x296) was a larger equivalence with a four-case disjunction, similar to how (12) has four cases. After conditioning on several literals during the compilation process, the equivalence was reduced to (X306 \u2194 X296). The case itself, like a^b^0, is represented by X296, whose definition was reduced to X296 Y295 (where Y295 is akin to 0,6). The third and fourth conjunct within (13)"}]}