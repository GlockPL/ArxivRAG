{"title": "MCP-Solver: Integrating Language Models with Constraint Programming Systems", "authors": ["Stefan Szeider"], "abstract": "While Large Language Models (LLMs) perform exceptionally well at natural language tasks, they often struggle with precise formal reasoning and the rigorous specification of problems. We present MCP-Solver, a prototype implementation of the Model Context Protocol that demonstrates the potential for systematic integration between LLMs and constraint programming systems. Our implementation provides interfaces for the creation, editing, and validation of a constraint model. Through an item-based editing approach with integrated validation, the system ensures model consistency at every modification step and enables structured iterative refinement. The system handles concurrent solving sessions and maintains a persistent knowledge base of modeling insights. Initial experiments suggest that this integration can effectively combine LLMs' natural language understanding with constraint-solving capabilities. Our open-source implementation is proof of concept for integrating formal reasoning systems with LLMs through standardized protocols. While further research is needed to establish comprehensive formal guarantees, this work takes a first step toward principled integration of natural language processing with constraint-based reasoning.", "sections": [{"title": "Introduction", "content": "Large Language Models (LLMs) have demonstrated remarkable capabilities across diverse natural language tasks yet exhibit fundamental limitations in logical reasoning and formal problem specification. Recent studies have established that LLMs struggle with complex reasoning chains, backtracking from failed solution attempts, and maintaining precise quantifier relationships [8]. These limitations are particularly evident in mathematical and logical problem-solving contexts, where LLMs often fail to provide reliable formal specifications despite their fluency in natural language descriptions [16].\nResearchers have tackled LLMs' limitations by pairing them with specialized formal systems. Some integrate theorem provers into the reasoning pipeline, while others connect LLMs to calculators or verification tools. Integrating theorem provers [20] represents one promising direction, while other approaches leverage external calculators and verification frameworks. A breakthrough came with Wei et al.'s [18] demonstration that chain-of-thought prompting can unlock complex reasoning capabilities in large language models. Further advancing the field, Drori et al. [5] showcased the power of combining LLMs with scientific computing libraries, while Betz et al. [2] contributed valuable insights through their work on procedural reasoning networks for understanding physical systems. However, these solutions often need custom integration work for each reasoning system, limiting their broader applicability."}, {"title": "Related Work", "content": "Recent research has linked large language models (LLMs) with constraint solving through different approaches. Curtis et al. [4] created PROC3S, which uses a two-stage architecture for robotics planning-an LLM generates parameterized skill sequences that go through continuous constraint satisfaction. For program synthesis, Jha et al. [6] built a counterexample-guided framework that combines an LLM synthesizer with an SMT solver verifier to strengthen correctness guarantees. SATLM by Ye et al. [21] translates natural language into logical formulas suitable for SAT solving. Pan et al. [14] developed LOGIC-LM as a complete pipeline from LLM through symbolic solver to interpreter. Wu et al. [19] created Lemur, which provides a task-agnostic LLM framework for program synthesis.\nKambhampati et al. [7] established theoretical foundations for LLM-Modulo frameworks that pair LLMs with external verifiers. For constraint solving specifically, R\u00e9gin et al. [15] built GenCP, which integrates LLMs into the domain generation of constraint solvers for text tasks. Voboril et al. [17] focused on real-time constraint solving by creating StreamLLM"}, {"title": "System Overview", "content": "We present the first application of MCP to bridge the gap between LLMs and Constraint Programming (CP) systems, specifically focusing on integration with MiniZinc, a widely adopted constraint modeling language. Our implementation provides a precise interface for transforming natural language specifications into formal constraint models, validating these models, and verifying solutions. This bridges the fundamental reasoning limitations of LLMs with the formal guarantees provided by constraint solvers.\nOur open-source implementation demonstrates the practical viability of this approach, offering tools for model submission, parameter management, solution retrieval, and iterative refinement. The system maintains a solver state, handles concurrent solving sessions, and provides detailed feedback for model validation and solution verification. This implementation is a prototype for integrating formal reasoning systems with LLMs through the MCP standard.\nThe contributions of this paper include (i) a formal specification of the MCP-based integration between LLMs and constraint solvers, (ii) a complete implementation demonstrating the practical viability of this approach, and (iii) an analysis of the complementary capabilities enabled by this integration. We argue that this work represents a significant step toward more reliable and verifiable LLM-based problem-solving systems."}, {"title": "Code and Technical Description", "content": "The MCP Solver is available as an open-source project at:\nhttps://github.com/szeider/mcp-solver\nThe implementation requires Python 3.9 or higher and MiniZinc with the Chuffed solver. The system supports macOS, Windows, and Linux platforms, though Linux users currently need an alternative to the Claude Desktop app. The server can be installed via standard Python package management tools, and configuration is handled through JSON files in platform-specific locations. Documentation includes installation instructions, configuration guides, and example usage. The project follows MCP's protocol specifications for tool interfaces and messaging, ensuring compatibility with any MCP-compliant client."}, {"title": "Design Principles", "content": "The MCP Solver addresses three key challenges in integrating LLMs with constraint solvers: maintaining solver integrity, managing model state, and providing effective tool interfaces. Our asynchronous model management keeps modification and solving operations strictly separate. A validation step precedes each change to the model, maintaining its consistency. We handle solver timeouts and resource cleanup through a robust session management system.\nKnowledge accumulation occurs through a file-backed memo system that maintains solver insights between sessions, creating a growing knowledge base of successful modeling patterns and providing structured error recovery suggestions.\nThe MCP Solver connects three key components (Figure 1): the Claude Desktop app as the MCP client, the MCP Solver as the server, and MiniZinc [13] as the constraint-solving backend. The client enables LLMs like Claude to interact with constraint models through natural language, while the server manages these interactions and translates them into MiniZinc operations using its Python API. MiniZinc then compiles these models into FlatZinc specifications that can be processed by a constraint solver."}, {"title": "MCP tools", "content": "The MCP Solver implements these core operations as \"tools\" adhering to the MCP specification [10]:\n\u2022 get_model: View the current model with numbered items\n\u2022 add_item: Add new item at a specific index\n\u2022 delete_item: Delete item at index\n\u2022 replace_item: Replace item at index\n\u2022 clear_model: Reset model\n\u2022 solve_model: Execute with Chuffed solver\n\u2022 get_solution: Get solution variable value with array indices\n\u2022 get_solve_time: Get execution timing\n\u2022 get_memo: Access knowledge base\n\u2022 edit_memo: Update knowledge base\nThe server implements MCP's request-response protocol with validation and error handling. Model modification has transitioned from line-based to item-based editing for improved robustness. The memo system maintains solution insights between sessions, enabling knowledge accumulation from past modeling experiences."}, {"title": "Model Management", "content": "The system implements an item-based model management approach through four complementary tools: get model, add_item, delete_item, and replace_item. get model enables inspection of the current model state with numbered items, while the editing tools provide atomic operations for model modification.\nThe item-based editing approach ensures model validity by integrating validation into every modification operation. Each proposed change triggers Python MiniZinc's complete validation chain: syntax parsing, type checking, and instantiation verification. Changes are only applied if validation succeeds, maintaining the invariant that the current model is always in a valid state (see Figure 2). This approach eliminates the possibility of accumulated inconsistencies that could arise in line-based editing."}, {"title": "Persistent Knowledge Base", "content": "The memo system maintains a growing knowledge base of solving and modeling insights that persist between sessions in a text file that can be periodically reviewed and curated. The LLM automatically records successful modeling strategies and solutions to complex problems. Users also contribute to this knowledge collection by prompting the LLM to document specific insights. The get memo and edit memo tools provide access to this growing knowledge base through a line-based editing interface."}, {"title": "Preliminary Experimental Evaluation", "content": "We evaluated the MCP Solver on various natural problems stated in natural language to assess its flexibility, robustness, and interaction patterns. While these experiments are not rigorous benchmarks, they provide valuable insights into the system's practical capabilities. We tested the system on several dozen problems covering different constraint programming paradigms. These included pure satisfaction problems (e.g., casting constraints), optimization problems (e.g., Traveling Salesperson Problem), and parameter exploration (e.g., N-Queens with varying board sizes). The appendix provides detailed transcripts of representative examples that demonstrate different aspects of the system:\n\u2022 The casting example shows how the LLM effectively translates complex logical conditions into boolean constraints.\n\u2022 The TSP example demonstrates both optimization modeling and model adaptation when new constraints arise (blocked road)\n\u2022 The N-Queens example illustrates parameter exploration while maintaining model structure\nCurrent implementation restricts solving times to a few seconds, which suffices for moderately sized problems but may require modifications for larger instances. While the memo system successfully captures modeling insights when prompted, autonomous knowledge base updates by the LLM were rare, suggesting room for improvement in the system prompt to encourage more proactive knowledge accumulation."}, {"title": "Conclusion", "content": "The MCP Solver demonstrates that protocol-based integration of LLMs with constraint solvers offers significant advantages over fixed pipeline approaches. The flexible architecture enables dynamic problem refinement, where solutions can trigger new constraints and model adjustments based on user feedback. This adaptability is particularly valuable during the exploratory phase of constraint modeling, where problem specifications often evolve through iteration.\nOur preliminary experiments demonstrate that the MCP Solver effectively combines natural language understanding with constraint modeling capabilities. The system shows particular strength in iterative model refinement and error recovery through natural dialogue, though some aspects, like autonomous knowledge accumulation could benefit from further development.\nWhile the system effectively bridges LLM capabilities with constraint solving, some reliability challenges remain. LLMs occasionally misinterpret solver outputs or make translation errors. Although the current verification mechanisms generally catch and correct these issues, more rigorous system prompts and validation procedures could improve reliability. The balance between flexibility and reliability represents an ongoing challenge in LLM-solver integration.\nOur work points to several promising research directions: Adding SAT solvers and minimal unsatisfiable subset analysis would broaden the system's scope. The reliability of results could benefit from more sophisticated verification methods without sacrificing the system's flexibility. The observed self-reflection capabilities of LLMs also suggest new possibilities for interactive modeling.\nAn inspiring direction lies in leveraging the broader MCP ecosystem. With hundreds of existing MCP services available, rich opportunities exist for creating more comprehensive problem-solving environments. Instance data could be seamlessly imported from databases or online spreadsheets through database MCP servers, while visualization servers could provide interactive result analysis. This interoperability with the broader MCP ecosystem enables the creation of sophisticated end-to-end workflows that combine constraint solving with data access, preprocessing, and result visualization.\nThe MCP Solver represents a significant step toward integrating natural language understanding with constraint programming, demonstrating that protocol-based architectures can effectively combine the strengths of both domains while maintaining the system flexibility. The broader MCP ecosystem opens up possibilities for building more sophisticated constraint-solving applications."}, {"title": "Appendix: Case Studies", "content": "Here are a few transcripts of chat conversations. We used Claude Desktop app (version 0.7.7) and Claude Sonnet 3.5, and MCP Server (version 2.0.0)."}, {"title": "Casting", "content": "This is based on an example by George Johnson (NYT, July 13, 1999).\nUser\nSuppose that a theatrical director feels obligated to cast either his ingenue, Actress Alvarez, or his nephew, Actor Cohen, in a production. But Miss Alvarez won't be in a play with Mr. Cohen (her former lover), and she demands that the cast include her new flame, Actor Davenport. The producer, with her own favors to repay, insists that Actor Branislavsky have a part. But Mr. Branislavsky won't be in any play with Miss Alvarez or Mr. Davenport. Can the director cast the play?"}, {"title": "Traveling Salesperson", "content": "This example shows how the same model can be re-used with different parameter settings, and how solving times are compared."}, {"title": "N-Queens", "content": "This example shows how the same model can be solved with different parameter values, and the solving times can be obtained."}, {"title": "Timetabling", "content": "This example showcases a timetabling problem. As a follow up question, the user asks for a more balanced schedule."}]}