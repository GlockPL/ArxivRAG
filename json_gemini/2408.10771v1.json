{"title": "SSL-TTS: Leveraging Self-Supervised Embeddings and KNN Retrieval for Zero-Shot Multi-speaker TTS", "authors": ["Karl El Hajal", "Ajinkya Kulkarni", "Enno Hermann", "Mathew Magimai.-Doss"], "abstract": "While recent zero-shot multispeaker text-to-speech (TTS) models achieve impressive results, they typically rely on extensive transcribed speech datasets from numerous speakers and intricate training pipelines. Meanwhile, self-supervised learning (SSL) speech features have emerged as effective intermediate representations for TTS. It was also observed that SSL features from different speakers that are linearly close share phonetic information while maintaining individual speaker identity, which enables straight-forward and robust voice cloning. In this study, we introduce SSL-TTS, a lightweight and efficient zero-shot TTS framework trained on transcribed speech from a single speaker. SSL-TTS leverages SSL features and retrieval methods for simple and robust zero-shot multi-speaker synthesis. Objective and subjective evaluations show that our approach achieves performance comparable to state-of-the-art models that require significantly larger training datasets. The low training data requirements mean that SSL-TTS is well suited for the development of multi-speaker TTS systems for low-resource domains and languages. We also introduce an interpolation parameter which enables fine control over the output speech by blending voices. Demo samples are available at https://idiap.github.io/ssl-tts/.", "sections": [{"title": "I. INTRODUCTION", "content": "NEURAL text-to-speech (TTS) synthesis has advanced significantly in recent years, achieving a level of naturalness comparable to human speech and allowing for an increasingly expressive range of outputs [1], [2], [3], [4]. Neural TTS systems can be categorized into two-stage and single-stage pipelines. Two-stage models convert phonemic features into acoustic features and then use a vocoder to generate waveforms. These models can suffer from error propagation and limitations due to their dependence on low-level features like mel-spectrograms [5], [6], [7]. Single-stage models aim to address these issues by streamlining this process into an end-to-end framework [2], [8], [9], but they may face oversmoothing, mispronunciations, and reduced flexibility due to the lack of explicit linguistic information and entangled latent representations [9], [10]. Recent research combines the strengths of both approaches by using self-supervised learning (SSL) speech representations as intermediate elements in two-stage models [10], [11], [12], [13]. These representations help improve word error rates, pronunciation of out-of-vocabulary words [11], and robustness to noise [14], leading to high-quality, natural speech often surpassing end-to-end models.\nIn practice, end-user applications may need multiple voices. Collecting high quality speech data and building a TTS model for each target speaker/voice is a challenging problem. So, there has been a growing interest in zero-shot multi-speaker TTS systems which can synthesize speech in an unseen speaker's voice based on short reference samples. State-of-the-art models such as XTTS [15] and HierSpeech++ [16] demonstrate impressive quality and similarity to unseen speakers. However, these models require end-to-end training on thousands of hours of transcribed audio data from a large number of speakers to generalize effectively.\nSimultaneously, kNN-VC [17] has emerged as a promising any-to-any voice conversion method, leveraging SSL features for zero-shot conversion. It uses a kNN algorithm to match frames from the source speaker with the target speaker's representations, adjusting the speaker identity while preserving speech content. This approach is similar to retrieval-augmented generation (RAG) techniques used in deep generative models such as language models [18] and image generators [19]. These methods can enhance accuracy, reliability, and enable style transfer by steering model outputs to mirror characteristics of a retrieval database [19], [20].\nBuilding on these insights, we propose SSL-TTS, a lightweight framework for multi-speaker zero-shot TTS that leverages SSL features encapsulating both speaker and linguistic information. In the first stage of the framework, text is converted to SSL embeddings, which are then matched with corresponding features from a target speaker by exploiting their linear relationship. Similar to kNN-VC, this modifies the target voice in a non-parametric manner and obviates the need for multi-speaker transcribed data for training. A waveform is finally generated from the converted features using a pre-trained vocoder. The only component that requires training is the Text-to-SSL model, which can be trained on transcribed data from a single speaker only. Furthermore, we introduce a linear interpolation parameter allowing for fine-grained control over the influence of the target style on the output. We validate the approach by implementing the Text-to-SSL block using two different lightweight models, namely GlowTTS [5] and GradTTS [21]. We train them on transcribed speech from a single speaker, and compare them with state-of-the-art zero-shot multi-speaker models using objective metrics and subjective listening tests. The code and trained models will be made public upon publication, demo samples are available at https://idiap.github.io/ssl-tts/.\nThis paper is organized as follows. The next section intro-"}, {"title": "II. PROPOSED APPROACH", "content": "The SSL-TTS framework, illustrated in Fig. 1, begins with a Text-to-SSL model that generates source speaker features from text input. A kNN retrieval algorithm then matches these generated features to units in a target speaker's unit database, which contains features pre-extracted from the target speaker's recordings using a pre-trained, general-purpose SSL encoder. The selected target speaker features are linearly interpolated with the source speaker features to obtain the converted features. Finally, these converted features are decoded back into a waveform using a pre-trained vocoder.\nSSL encoder: For this framework, we need an intermediate audio representation that meets the following criteria: (1) the features should encompass both linguistic and speaker-specific information; (2) features that are linearly close should exhibit similar phonetic properties while preserving speaker identity; and (3) it should be possible to decode the features back to waveform without loss of information. Recent observations indicate that self-supervised models encode speech into general representations that meet these criteria [22]. Therefore, such SSL representations are suitable for this framework.\nText-to-SSL: We train a Text-to-SSL model that generates corresponding SSL features from a given text input. Notably, this is the only component of our framework that requires audio data paired with text transcriptions for training. It is sufficient to train this model on the speech of a single speaker.\nKNN: To synthesize speech in a target speaker's voice, units (or frames) from the target speaker unit database are selected to replace corresponding frames from the source speaker features. The selection is performed by comparing source and target frames in terms of a linear distance metric. This process results in selected target speaker features which maintain the phonetic information while replacing the voice characteristics with those of the target speaker.\nThe source and target speaker features are then linearly interpolated with each other to obtain the converted features [18]. We use a variable parameter A which can be modified to change the degree of influence the target features have on the output. This allows for creating a blend of the source and target styles.\n$Y_{\\text{converted}} = \\lambda Y_{\\text{selected}} + (1 - \\lambda) Y_{\\text{source}}$\nVocoder: We employ a vocoder capable of decoding the SSL features back into a waveform. To ensure robust generalization, the vocoder should be pre-trained on a large and diverse dataset to maintain high-quality waveform reconstruction across different speakers and contexts."}, {"title": "III. EXPERIMENTAL SETUP", "content": "SSL encoder: We employ a pre-trained WavLM-Large encoder from [23] to derive representations from speech utterances. WavLM-Large fits the requirements we presented, and is specifically selected due to its effective audio reconstruction capabilities, obtained through training on masked speech denoising and prediction tasks [24]. Specifically, we utilize features extracted from the 6th layer of the model, which encapsulate both phonetic and speaker characteristics [17], [24]. Each utterance yields T \u00d7 1024 features, where T is the sequence length. Each frame represents a 25ms window with a 20ms hop between frames. These features are pre-extracted and cached prior to training or inference, eliminating the need to load the WavLM model during training or synthesis, assuming the target speaker is known.\nText-to-SSL: We evaluate two Text-to-SSL implementations: GlowTTS [5] and GradTTS [21]. GlowTTS employs a non-autoregressive architecture with a transformer-based text encoder, a duration predictor, and a flow-based decoder [25]. GradTTS follows a similar architecture but uses a diffusion-based decoder [26]. These models, which were originally designed to predict mel-spectrograms, are trained to encode text inputs into WavLM features corresponding to a single speaker's speech. We maintain the models' default configurations and only adjust their output dimension to 1024 channels to align with WavLM-Large features. For the GradTTS diffusion decoder, we use 100 iterations for synthesis. Both models are trained on the LJSpeech dataset [27], which comprises"}, {"title": "C. Evaluation", "content": "We use the default checkpoints and configurations provided by the authors for each baseline model\u00b9. Since these models employ various speaker encoders to convert a reference utterance into a style embedding, we ensure a fair comparison by averaging the embeddings across all reference utterances for each target speaker. For zero-shot multi-speaker synthesis comparisons, we use the LibriSpeech test-clean dataset for target speaker reference utterances. It includes speech of varied quality from 20 male and 20 female speakers, with 8 minutes of speech per speaker. For each model, we synthesize 100 English sentences per speaker, selecting the sentences randomly from the FLoRes+ dataset [32], in accordance with the XTTS protocol. Tests are performed with x = 1.\nObjective analysis: we evaluate each model's performance in terms of naturalness using UTMOS [33], intelligibility using the word error rate (WER) and phoneme error rate (PER) computed with the Whisper-Large v3 model [34], and speaker similarity using speaker encoder cosine similarity (SECS) with the ECAPA2 model [35].\nSubjective evaluation: we conduct a listening test to assess naturalness and similarity mean opinion scores (N-MOS and S-MOS). We randomly select utterances from 10 male and 10 female target speakers in the LibriSpeech test-clean dataset, choosing 3 synthesized sentences per speaker, totaling 60 utterances per model. Each utterance is rated by 10 raters on naturalness and similarity to a ground-truth recording, with scores ranging from 1 to 5 in 0.5 increments. We use Amazon Mechanical Turk, with raters required to be native English speakers based in the United States, having a HIT acceptance rate above 98% and more than 500 approved HITs. Attention checks are implemented to filter out unreliable ratings.\nModel efficiency: we compare the models based on the number of parameters, peak GPU memory usage during test sample synthesis, and real-time factor (RTF). These tests are performed using an NVIDIA RTX3090 GPU.\nControllability: to showcase this aspect of the framework, we perform an experiment using the interpolation parameter,"}, {"title": "IV. RESULTS AND ANALYSIS", "content": "Results are presented in Table I. Objective metrics reveal that the SSL-TTS models demonstrate the best speaker similarity, XTTS excels in intelligibility, and HierSpeech++ achieves the highest naturalness. Subjective evaluations show that listeners rated HierSpeech++ highest for naturalness and similarity, while the SSL-TTS models and XTTS performed similarly. These models' results fall within each other's confidence intervals, suggesting comparable performance. Regarding model efficiency, SSL-TTS models have the fewest parameters and lowest memory requirements among the top performers. Notably, GlowTTS-SSL requires 3\u00d7 less memory than HierSpeech++ with comparable speed. GradTTS-SSL's memory usage and RTF are higher due to the 100 iterations used in the diffusion decoder. Further, the SSL-TTS models are trained on 100\u00d7 less transcribed data than HierSpeech++ and 1000\u00d7 less data than XTTS.\nThe speaker similarity matrix (Figure 2) illustrates the results of the controllability experiment. We can observe that the similarity of the outputs to the target speaker gradually increases as \u00e0 rises. This demonstrates the framework's ability to blend source and target styles in a fine-grained manner and suggests the potential to combine multiple target styles.\nWe conduct ablation studies to evaluate the models' outputs with varying amounts of reference utterances. Figure 3a compares outputs using kNN retrieval from different amounts of LJSpeech data. We find that approximately 30 seconds of reference utterances are needed to achieve suitable intelligibility, while naturalness improves up to 5 minutes, surpassing the model outputs without kNN retrieval. Figure 3b compares the SSL-TTS models to the baselines for different amounts of reference utterances from a target speaker. Similarly, about 30 seconds are required for suitable intelligibility, while similarity plateaus at around 1 minute. In contrast, the baselines benefit less from increasing the amount of reference utterances beyond 10 to 30 seconds."}, {"title": "V. DISCUSSION AND CONCLUSIONS", "content": "State-of-the-art zero-shot multi-speaker TTS models rely on large datasets of transcribed speech from thousands of speakers for training. In this paper, we demonstrated that by combining SSL features and kNN retrieval methods, we can develop a lightweight TTS system that achieves a comparable level of naturalness and similarity to other approaches while requiring transcribed data from only a single speaker. However, there is a trade-off, with the other approaches performing better with just a few seconds of reference audio, while our method needs at least 30 seconds of reference audio, which is still a manageable requirement. We further showed that fine-grained control over the influence of the target style on the output can be achieved using an interpolation parameter. This indicates that this technique, which is originally inspired from other domains such as language modeling [18] and machine translation [36], also applies to TTS.\nThe simplicity of the training process is one of the main advantages of our approach, where only the Text-to-SSL model requires training, and it can be trained on transcribed data from a single speaker. This simplicity, in conjunction with the KNN approach's cross-lingual capability [37], is particularly appealing for extending the model to new languages and domains with fewer resources. This aspect is open for future work. We also showed that the framework can be implemented using different Text-to-SSL model architectures, allowing for model swapping to leverage different benefits. Our implementations notably demonstrated efficiency in terms of parameters, memory usage, and runtime speed in the case of GlowTTS-SSL, even without optimizing the retrieval process.\nTypically, different speakers exhibit different pronunciation durations. In our framework, the duration aspect is determined by the Text-to-SSL model, and the target voice is modified through frame-by-frame selection, meaning that the duration of each utterance remains unchanged for different speakers. Interestingly, despite this limitation, the SSL-TTS models were rated comparably to other approaches in terms of similarity. Our future work will explore techniques, such as Urythmic [38], to address this limitation."}]}