{"title": "Semantic Interoperability on Blockchain by Generating Smart Contracts Based on Knowledge Graphs", "authors": ["William Van Woensel", "Oshani Seneviratne"], "abstract": "Background: Health 3.0 marks the next step in the evolution of healthcare, where data management moves from being institution-centric and centralized to patient-centric and distributed. Health 3.0 thus enables decision making to be based on longitudinal data from multiple institutions, from across the patient's healthcare journey. In such a distributed setting, blockchain can act as a neutral intermediary to implement trustworthy decision making. Blockchain, as a separate, secure and transparent platform, does not require any party to entrust another with their privacy-sensitive data, nor to execute the decision-making process. Instead, secure transactions share patient data with a smart contract, which implements the decision-making process on blockchain in a transparent and tamper-proof way. Therefore, contributing parties only require trust in the original smart contract and the underlying blockchain technologies (consensus mechanism, ledger).\nObjective: In a distributed setting, transmitted data will be structured using standards (such as HL7 FHIR) for semantic interoperability. In turn, the smart contract will require interoperability with the domain standard; implement a complex communication setup to work in a distributed environment (e.g., using oracles); and be developed using special-purpose blockchain languages (e.g., Solidity). We propose the encoding of smart contract logic using a high-level semantic Knowledge Graph (KG), using concepts and relations from a domain standard, and describing data requirements from distributed parties. We subsequently deploy this semantic KG on blockchain for trustworthy decision making.\nMethods: We use a hybrid on-/off-chain solution to deploy the semantic KG on blockchain: off-chain, a code generation pipeline compiles the KG into a concrete smart contract, which is then deployed on-chain. Our pipeline targets an intermediary \"bridge\" representation, which captures declarative logic using imperative constructs, and is then \"transpiled\" into a specific blockchain language. Our choice for off-chain code generation avoids on-chain rule engines, with unpredictable and likely higher computational cost. It is thus in line with the economic rules of blockchain, where heavier computations result in higher execution costs.\nResults: We applied our code generation approach to generate smart contracts for 3 health insurance cases from Medicare. We discuss the suitability of our approach\u2014the need for a neutral intermediary\u2014for a number of healthcare use cases. We evaluated the generated", "sections": [{"title": "Introduction", "content": "Health 3.0 [1] marks a paradigm shift in healthcare data and service management, away from an institution-centric model with one-size-fits-all digital services and centralized closed-off data silos. Instead, Health 3.0 is characterized by a patient-centric model, where healthcare services are personalized and customized to individual patient profiles and needs. Moreover, Health 3.0 aims to make a patient's longitudinal data, i.e., recording their healthcare journey across multiple institutions, accessible to the patient and their care providers for improved decision making. Health 3.0 thus implies a distributed environment, i.e., in which data will be integrated from multiple institutions. To implement health decision making in such a distributed environment, a suitable platform will be needed.\nWe argue that the unique characteristics of blockchain technology are conducive to this role. Blockchain can deploy decision making in a distributed setting as a neutral intermediary, i.e., without any party having to entrust another party with (a) their privacy-sensitive health data, or (b) executing the particular decision making process. At its core, blockchain is a secure and transparent third-party platform for conducting \"transactions\"; a transaction involves the exchange of data or currency, is validated by a consensus mechanism, and is recorded into an immutable ledger that is accessible to all parties. Smart contracts are blockchain programs for implementing decision making that involves multiple parties and transactions. When using a smart contract to implement health decision making, parties thus do not share health data directly with each other, but rather via secure transactions\u00b9 with the smart contract on a separate platform. Moreover, after its publication on blockchain, a smart contract cannot be modified, its execution cannot be influenced or tampered with, and each execution is similarly recorded in the ledger. Hence, blockchain, and smart contracts, by extension, are \"trustless\": a contributing party does not need to place trust in another party, or any single provider, to run transactions and smart contracts; they only need to trust the original smart contract and proven blockchain technologies (e.g., consensus mechanism, ledger). Until now, smart contracts have mostly been applied to coordinate legal and financial interactions, however they have also been used for healthcare cases that require a neutral intermediary. Examples include ensuring that trial recruitment adheres to regulations [4]\u2013[7], deciding on unbiased funding for prevention programs [8], and selecting health insurance and coverage [9]\u2013[11]."}, {"title": "Methods", "content": "We developed a graph-based approach for generating smart contracts from semantic Knowledge Graphs (KG), which include high-level declarative logic (N3 rules) that encodes policies and regulations, using domain concepts and relations from an OWL2 ontology. Figure 1 shows the code generation pipeline of our hybrid on/off-chain approach. From a set of textual constraints, regulations, or policies (e.g., health insurance), domain experts computerize declarative N3 rules. An OWL2 domain ontology encodes the semantics of concepts and relations found in well-known domain standards such as HL7 FHIR.\nGiven the OWL2 ontology, the Parser parses the N3 rules and extracts a set of annotated rule graphs. Next, the Converter converts these rule graphs into a set of intermediary \"bridge\" abstractions that represent the declarative logic using imperative programming concepts. Whereas N3 rules declare applicable data constraints, the imperative code procedurally implements and checks these constraints against input data. From these bridge abstractions, Code Generators will generate smart contracts for different blockchain languages (e.g., Solidity, JavaScript). Once the Smart Contract is deployed on a blockchain, it will be executed by a client using transactions with input data (e.g., insurance claim). During its execution, the contract will request additional data from distributed Information Systems (IS) (e.g., Electronic Medical Records) via an off-chain oracle [14]. Finally, the contract will issue output events that reflect the outcome (e.g., claim approved)."}, {"title": "Representing Decision Logic using N3", "content": "We will rely on a health insurance use case as a running example. This use case involves deciding on reimbursement of healthcare costs, based on the patient's coverage and policies from the Medicare's booklet on benefits [20] (Section 1, p. 98). We show a text snippet of the case below; we will represent the numbered parts as N3 rules and use them to illustrate our code generation approach. We refer to our online repository for the full case [21].\n\"(1) Medicare covers transplant drug therapy if Medicare helped pay for your organ transplant. You must have Part A at the time of the covered transplant, and (2) you must have Part B at the time you get immunosuppressive drugs. Keep in mind, (3) Medicare drug coverage (Part D) covers immunosuppressive drugs if Part B doesn't cover them. [..]\"\nThis text is interpreted as follows. (1) An organ transplant is eligible for drug therapy coverage in case Medicare Part A helped pay for the transplant. (2)-(3) Transplant drug therapy (immunosuppressive drugs) is covered in case you, at the time of therapy, have (2) Medicare Part B, or (3) if not Part B, you have Medicare Part D."}, {"title": "Decision Logic As Existential N3 Rules", "content": "Notation3 (N3) [16] is a Semantic Web rule language that is built on top of the Resource Description Framework (RDF). N3 has been used in health informatics to represent clinical decision logic (e.g., extracted from guidelines) [22]\u2013[24], explain the ensuing health recommendations [25], and generate model-driven Uls [26]. N3 supports a wide range of built-in operators, meta-data on groups of statements, and (scoped) negation as failure. There are execution engines for multiple platforms (eye [27], eye-js [28], cwm [29], jen3 [30]) and a VSCode plugin [31] for writing and executing N3 code.\nIn RDF [32], information is described as triples with subject, predicate, and object resources. URI and literal terms (e.g., numbers and strings) can be used to identify resources; blank nodes are used when an identifier is not available or necessary. URIs can be written in full (e.g., ) or using qualified names written as . E.g., on line 1 in Code 1, the URI uses fhir as namespace and CoverageEligibilityRequest as local name; on line 3, the default (empty) namespace and immunoTherapyItem as local name is used. A triple is terminated by a period (\".\"). Shorthands include the predicate \"a\" for type (e.g., line 1); a single subject with multiple predicate-object pairs separated by \";\" (e.g., lines 1 and 2); and a single subject-predicate pair with multiple objects separated by \",\" Blank nodes are written using \"[\" \"]\"5.\nN3 extends RDF with graph terms for grouping triples, surrounded by \"{\" \"}\"; lists as first-class citizens, surrounded by \"(\" \")\"; and universal variables, written as ?. An N3 rule is written as a triple: the subject is a graph term as the rule's body or antecedent, the predicate is log:implies (shorthand \"=>\"), and the object is a graph term as the rule's head or consequent. Simply put, given a rule { body } \u2192 { head }, statements in the head will be inferred in case statements in the body evaluate to true."}, {"title": "Converting Rules into Imperative Bridge Abstractions", "content": "The semantic KG-including the extracted rule graphs and domain ontology-is converted into a set of intermediary \"bridge\" abstractions, which represent the declarative logic using"}, {"title": "Constructing ADT from Rule Graphs and Domain Ontologies", "content": "Figure 3 shows the set of ADT bridge abstractions as typically found in imperative applications 11.\nA instance represents a concrete ADT (e.g., Patient) that corresponds to an ontology class referred by the rule. It consists of ModelProperty fields (e.g., status, gender) with a given cardinality, corresponding to the ontology class's properties referred in the rule. To support statically typed languages (e.g., Solidity), a ModelProperty keeps a ModelType representing either an XSD datatype12 or an object type as another ModelADT. ModelADTs can thus be nested, i.e., the value of a ModelProperty can be another ModelADT. Each ModelElement keeps its term URI from the rule or ontology as a unique name and a human-readable label (rdfs:label property in the ontology), if any.\nTo instantiate these ADTs, our approach recursively traverses the extracted rule graph(s) (e.g., Figure 2) starting from their function parameter (e.g., req), instantiating ADTs for classes and properties referred by the rule. This is in contrast to other work such as RDFReactor [35], which instantiates ADTs (Java classes) for an entire OWL ontology. This aims to reduce the size of smart contracts. For instance, on the Ethereum blockchain, smart contracts have max. size of 24Kb13, whereas mature ontologies can be huge; DMTO [36], used in our prior work to generate diabetes-related smart contracts [8], includes over 10,000"}, {"title": "Constructing Application Logic from Rule Graphs", "content": "Figure 4 shows a basic set of bridge abstractions for application logic as typically found in imperative applications15.\nThe generated application logic consists of a set of Statements. An IfThen statement keeps an \"if\" Condition and a \"then\" Block. A Block acts as a container of other Statements. A Condition can be a Comparison, which compares two Operands (e.g., literals; see below) using a comparator (cmp); or a CondSet, which groups multiple Conditions as either a conjunction (AND) or disjunction (OR) 16. An Assignment assigns an operand to another operand (e.g., variable). Since a Block is itself a Statement, other Blocks (or any type of statement) can be arbitrarily nested within Blocks; similarly, as CondSet is a Condition, conditions can be arbitrarily nested.\nFigure 5 shows the statement operand abstractions:"}, {"title": "Supporting Advanced Application Logic", "content": "Figure 5 shows the statements that cover more \"advanced\" application logic:\nAn Operation (e.g., math or string operation) is applied to a set of Operands using an operator (e.g., sum). An Iteration will start from a PropertyPath: in each iteration, a value identified by the path (start) is assigned to the loop's Variable, and a StandardLoop will execute its body (IfThen). A QualifiedCondition will check the given Condition and will return true if the condition holds for all (universal qualifier) or some (existential qualifier) loop variable values. A RemoteRequest represents a data retrieval request for a remote IS at location with key-value Parameters for selecting data. Finally, an EmitEvent represents the emission of an Operand as an event with a given name. We point out that Operation is itself an Operand, meaning it can be nested in comparisons or other operations; and a Qualified Condition is a Condition, meaning it can be used wherever conditions are used.\nIn the subsections below, we discuss extensions to the generateLogic function to support the instantiation of these abstractions as well as multi-valued properties."}, {"title": "Remote Data Requests", "content": "In our distributed Health 3.0 setting, relevant data will need to be retrieved from remote IS to implement the decision logic, such as prior claims and coverages of the given patient.\nIn general, for smart contracts on blockchain to communicate with remote services, an off-chain \"oracle\" is needed [14]. Communication between the smart contract, oracle, and remote service takes place as follows:"}, {"title": "Multi-Valued Properties Using Indexing and Iteration", "content": "Until now, we have made the simplifying assumption that properties have either none or a single value. However, properties can have any cardinality (Figure 3); we call properties with multiple possible values \"multi-valued\". E.g., in the FHIR standard, a CoverageEligibilityRequest can include many items (fhir:item); a MedicationRequest can cover multiple medications (fhir:medication); and a patient can have many prior insurance claims (inverse fhir:subjectOf property).\nAs with our choice for a hybrid on-/off-chain pipeline, our implementation is informed by the economic rules of blockchain-based systems, i.e., where computational work expends cryptocurrency. Where possible, values of multi-valued properties are indexed to avoid iterations (time complexity O(n)) over the values. We discuss two general methods for processing multi-valued properties. Appendix C elaborates on their implementation. We discuss the challenges of implementing these methods in Solidity in the next section."}, {"title": "Indexing Multi-Valued Property Values on Unique Keys", "content": "In case the decision logic refers to values of multi-valued properties using a unique key, we can index and access these values using those keys. Below is an example snippet from our prior work [8], where DDO: has_physical_examination is a multi-valued property:"}, {"title": "Iterating over Multi-Valued Property Values", "content": "In case a unique key is not available for values of multi-valued properties, we will have to iterate over its values. From our running example, fhir:item is an multi-valued property:"}, {"title": "Unification and Mathematical Operations", "content": "During code generation (Algorithm 2), path sequences from rule graphs are converted into property paths for comparison or assignment with concrete values or new ADTs. In some cases, however, property paths will have to be compared or assigned to each other.\nIn Code 2 (line 9), the req.immunoTherapyItem property path identifies values for the ?med variable, and req.patient.subjectOf.procedure identifies values for ?proc. To represent this in imperative code, the following assignment should be generated:\nreq.immunoTherapyItem.eligibleTransplant = req.patient.subjectOf.procedure\nSimilarly, in Code 3 (line 14), the ?med variable is identified by the req.immunoTherapyItem property path, and should lead to the following constructor invocation:\nCoverageEligibilityResponse(request: req.immunoTherapyItem [..])\nWe refer to resolving variables ?proc and ?med to their corresponding property paths as unification. We implement the unification step by keeping a mapping between variables, found in the rule body, to their property path. When the same variable is found in the rule"}, {"title": "Generating Imperative Smart Contract Code", "content": "The Code Generation component will convert the instantiated bridge abstractions into blockchain smart contracts. Currently, we support Solidity and JavaScript as target imperative languages. For brevity, we do not detail this step in this paper, but we describe noteworthy aspects below."}, {"title": "Emit smart contract events", "content": "To communicate with any off-chain party, albeit the client that invoked the contract, or an oracle retrieving remote data, the smart contract emits events.\nFor communicating results back to the client, N3 rules are annotated with cg:event , which will involve the emission of an event called . An example is given in Code 3 (line 15). In case the application logic involved the creation of a new ADT, as is the case here, the event will emit this new ADT as payload:"}, {"title": "Remote data requests using oracles", "content": "Smart contracts follow a communication setup for remote data retrieval that relies on oracles, shown in Figure 7. The smart contract will emit an event when remote data is required; the oracle retrieves the data, and issues a transaction back to the contract with the data. In particular, this transaction calls a contract function, passing the retrieved data as an"}, {"title": "Results", "content": "We used our code generation pipeline to generate smart contracts for 3 health insurance scenarios, including our running example. These smart contracts automate the process of deciding on reimbursement of healthcare costs, based on the Medicare's booklet on benefits [20]. We evaluated the generated smart contract code in 2 ways:\n1) code analysis: visualizing their control and message flow, and using simulated cases to validate their correctness.\n2) performance analysis: measuring their execution cost in terms of \"gas\", i.e., computational effort required to execute transactions or smart contracts on a blockchain platform.\nWe refer to our online repository [21] for descriptions of these cases, their N3 implementation, generated smart contracts, and all evaluation results. We further deployed each contract on an Ethereum testnet called Sepolia so they can be manually tested. Experimental reproducibility criteria are available in our repository's README."}, {"title": "Experiment Setup", "content": "We evaluated the generated smart contracts in (1) a local simulation environment, using Ganache [37] and Foundry [38] (analogous to a private consortium setting) and a (2) public test network, similar to the evaluation by [9]. We used web3.js [39] for writing client and oracle scripts that interact with our smart contracts. We describe these two scripts below:\nOracle. The oracle script is an off-chain component that listens to events that represent remote data requests from the smart contract. When received, the oracle retrieves the requested data, and returns the data to the smart contract by invoking its callback functions. In a real-world application, the oracle would fetch actual data from external sources (e.g., using HL7 FHIR RESTful APIs) instead of using hardcoded values as simulated here. However, we argue that this is a good approximation of how smart contracts can interact with external systems to obtain remote, off-chain data.\nClient. The client script simulates an off-chain component interacting with the smart contract. It sends a request to the contract, and listens for an event that represents the contract's response, i.e., the outcome of the contract's decision logic. It thus acts as an interface between the user\u2014or an external system\u2014and the smart contract."}, {"title": "Smart Contract Code Analysis", "content": "The generated smart contracts will be part of a distributed Health 3.0 data environment, involving other contracts and off-chain components such as external data sources (oracles) and clients. Smart contracts use events to communicate with these off-chain components, resulting in an asynchronous workflow. For our running example, Figure 8 (a) shows a sequence diagram of the messages exchanged between Client, Smart Contract and Oracle. Figure 8 (b) shows actual internal and external function calls22 recorded by Surya [40], a tool for visualizing smart contract control flow and highlighting vulnerabilities.\nThe main control flow proceeds as follows. The Client starts by invoking the process function of the Smart Contract, passing a CoverageEligibilityRequest. The process function then executes a number of if-else checks, including an internal check1 function to check a condition on a multi-valued property. The process function proceeds by emitting a RequestData event to retrieve prior Claims. The Oracle listens for this event, retrieves the relevant claims, and calls the callback1 function with the retrieved claims. This function then continues with processing these claims, eventually emitting a second RequestData event for prior Coverage. As before, the Oracle similarly responds by retrieving relevant coverages and passing them to a callback2 function. The function processes these coverages, calls a second internal check2 function, and finally emits a CoverageEligibilityResponse which is captured by the Client. In Appendix E, we describe all the structs, enums, events and functions from the smart contracts, including the ones mentioned here."}, {"title": "Validating Code Correctness", "content": "We created 10 test cases for each smart contract: for each case, we created CoverageEligibilityRequests (Client), Claims and Coverages (Oracle), together with their nested structs such as Procedure, Claim, MedicationRequest, and Patient (Appendix E). For each case, using the client and oracle scripts, we executed the smart contracts in our local simulation environment, and manually verified the correctness of the outcomes. All outcomes and their input data can be found in our online repository [21]. The generated contracts can also be tried out on the Sepolia testnet."}, {"title": "Gas Analysis", "content": "Table 1 shows the execution costs of deploying and running the 3 smart contracts on a local simulation environment (Foundry [38]) in terms of units of \"gas.\" Foundy's \u201cgas- report\" outlines the gas used by each function call and transaction. Deployment cost is the amount of gas used to deploy the contract onto the Ethereum blockchain.\nOn Ethereum blockchains, each computation costs \"gas,\" which is paid in Gwei. 1 Gwei is one-billionth of ETH (the Ethereum cryptocurrency). The gas costs for atomic operations (e.g., base transaction fees, creating a smart contract, calling functions) are detailed in Appendix G of the Ethereum Yellow Paper [41]. E.g., the base cost of deploying a contract amounts to 53,000 gas, whereas storing the contract costs 20,000 gas per 256 bits of code.\nBetween January 2024 and the time of writing (Feb 22, 2024), the average gas price was circa 31 Gwei24. Deploying the first contract thus expends 38 268 570 Gwei; with 1 Gwei equalling one-billionth of ETH, this equals 0.03826857 ETH. Also at the time of writing (Feb 22, 2024), 1 ETH equaled 2 929.39 USD, implying a deployment cost of circa 112 USD. Calling the process, callback1 and callback2 functions incurs 0.001990386 ETH (5.83 USD), 0.000631253 ETH (1.85 USD) and 0.000629672 ETH (1.84 USD), respectively. Although not trivial, we argue that these costs are acceptable; deploying a reasonably-sized smart contract of 8Kb would already cost circa USD 157. Harris [42] measured the gas cost of deploying Al models on blockchain; when plugging in our Gwei cost per unit of gas and USD for ETH rate, deploying the cheapest model (Sparse Perceptron) amounts to USD 2812."}, {"title": "Discussion", "content": "Healthcare Use Cases Benefiting from Blockchain\nAccording to a recent literature study [44], research on the use of blockchain in healthcare has been growing since 2016. Automating health-related decision making using blockchain lowers administrative costs and avoids mistakes and delays caused by human error. At the same time, however, the choice of blockchain technology introduces latencies unrelated to computational work: these can be caused by the unavailability of nodes, chosen consensus mechanism (e.g., proof-of-work or -stake), and other blockchain properties, such as the use of interactive zero-knowledge proofs in preserving privacy. Moreover, any computational work incurs an execution cost on public blockchains in terms of cryptocurrency, as shown in our Results section.\nA use case should thus have a distinct need for the unique \"trustless\" features offered by blockchain that allow it to act as a neutral intermediary (e.g., transparency, tamper- proofness). The National Institute of Standards and Technology (NIST) published a flowchart that determines the suitability of blockchain for a given use case [45] (p. 42). Criteria include (1) trust issues over who controls the dataset and runs the application logic, (2) a shared and consistent dataset between multiple entities; and (3) an immutable and tamper-proof transaction ledger that allows trustworthy audits. Blockchain technology supports these criteria as follows:\n(1) trust or control issues: parties rely on a separate blockchain platform, as a neutral intermediary, to control the dataset and run the application logic. This platform is further considered \"trustless\": no trust is needed in a single provider to run the platform, but rather the proven consensus and ledger technologies for executing, validating and recording transactions and smart contracts. We point out that smart contracts, once deployed, cannot be influenced or tampered with (just like transactions).\n(2) shared and consistent dataset: all involved parties have access to a historically consistent datastore25 in terms of an immutable ledger; all parties are able to contribute data.\n(3) audit capabilities: trustworthy audits are afforded by this immutable ledger: it records (a) all transactions that execute the smart contract, including any provided (possibly encrypted) input data, and (b) events emitted by the smart contract that reflect the outcomes."}, {"title": "Clinical Trial Eligibility", "content": "When conducting clinical trials, there is a need to ensure adherence to regulatory requirements on research ethics and data privacy [7]; and avoid poor reproducibility of results when caused either by \"honest mistakes\" or fraud during the study [46]. These needs can be met in part by automating trial eligibility checking in a trustworthy and transparent way. Benchoufi et al. [4], Dai et al. [5], Zhuang et al. [6], and Benchoufi et al. [7] have studied the use of blockchain technology for trial eligibility. Regarding the suitability criteria:\n(1) trust or control issues: no trust is required in study investigators to keep records, adhere to regulatory requirements, and avoid mistakes in eligibility (honest or otherwise). Instead, an appropriate smart contract can be deployed within the trustless blockchain setting. Clinical Trial Management Systems (CTMS) can also be utilized for this purpose, but they offer weaker safeguards as they are under single-party control [5].\n(2) shared and consistent dataset: all involved parties, including the sponsors, patients, and investigators, will contribute ethical requirements, demographics, and health data.\n(3) audit capabilities: regulators and trial sponsors as a matter of policy [46], or researchers in case of non-reproducibility, can conduct systematic audits of the blockchain ledger to assess regulatory adherence and rule out mistakes or fraud [4], [5]."}, {"title": "Health Screening Policies", "content": "In this public health use case, parties receive funding from the government to fund prevention and treatment programs based on screening outcomes. In prior work [8], we presented a diabetes risk screening use case where (1) regional healthcare organizations forward patient data to a region-wide platform, where an automated process determines diabetes risk, and (2) funding is subsequently distributed for diabetes prevention and treatment programs where they are needed most. Such programs include incentives for patients to keep their BMI below 26, walking 150 minutes or more per week, or equivalent exercises depending on their medical condition [47].\n(1) Trust or control issues: healthcare providers will benefit from inflating diabetes risk factors among their population, may suspect such actions from other providers, or may perceive an underestimation of risk factors from the government. Instead, by deploying an appropriate smart contract on a blockchain-based system, no trust is required in any single party.\n(2) Shared and consistent dataset: regional healthcare providers will contribute population data for the diabetes risk screening, which will be shared between all involved parties.\n(3) Audit capabilities: in case of disagreement on screening outcomes, an audit of the ledger will reflect the given input population data (transactions) and the resulting screening outcomes (events), allowing the validation of screening outcomes."}, {"title": "Multimorbidity Clinical Decision Support", "content": "For patients with multiple co-occurring illnesses (i.e., multimorbidity), appropriate treatments will often be decided by multiple different specialists. However, concomitant treatments for"}, {"title": "Health Insurance", "content": "In health insurance processes, such as claim handling, insurance companies decide which healthcare costs are reimbursed based on the patient's coverage and applicable policies. Automating these processes lowers the insurance's administrative costs and avoids human error. Karmakar et al. [9], Zhou et al. [10], and Chondrogiannis et al. [11] have explored the use of blockchain for medical insurance.\n(1) Trust or control issues: patients, care providers, and insurers have competing interests and often a mutual distrust [9]: insurers will benefit from choosing the lowest-cost option; patients and care providers will benefit from maximizing reimbursement and health benefits. Deploying an appropriate smart contract on blockchain means no trust is required in a single party; instead, any choice on eligibility will be made and recorded in a trustless setting.\n(2) Shared and consistent dataset: patients and care providers contribute information on the patient's health and treatment options; insurers contribute data on coverages and policies.\n(3) Audit capabilities: in case of disagreement about claim decisions, audits of the ledger will reflect the provided health and coverage data (transactions), as well as resulting claim decisions (event), allowing the validation of the latter."}, {"title": "Public vs. Private Consortium Blockchains", "content": "Regarding health insurance use cases, there exist two options for deployment: public or private consortium blockchains. As mentioned, in a public blockchain, anyone can join and perform transactions; cryptocurrency and decentralized finance transactions take place here. A private consortium chain is managed by multiple organizations and requires permission to join, and is typically used by banks and government organizations [43]."}, {"title": "Using Logics-based Languages to Develop Smart Contracts", "content": "Idelberger et al. [13] reported in 2016 that logic-based languages have hardly been explored to implement smart contracts. To the best of our knowledge, this has not changed since then, aside from work by Choudhury et al. [19] and our prior work which this paper extends [8]. Idelberger et al. [13] showed that declarative, rule-based languages are more naturally suitable to represent legal clauses, i.e., they are easier to write and comprehend by domain experts such as jurists. Representing a license agreement in imperative procedural languages is far more involved, as it requires determining the ordering of imperative commands, the impact of triggers on the internal state, and propagating the state changes accordingly. A declarative rule-based program instead relies on an underlying rule engine for execution, without consideration of internal state or ordering. That said, the authors also outline an important technical challenge: reasoning algorithms have to be cheap, as per the economic rules of the blockchain-computational work and transactions expend the blockchain's cryptocurrency. With this in mind, the authors differentiate between on-chain and off-chain solutions for rule-based reasoning. We outline these two options below:"}, {"title": "Off-chain Solution", "content": "A strictly off-chain solution involves deploying the rule engine as an oracle. The smart contract hereby emits \"reasoning requests\"; these are received by the oracle, which executes the rules and sends back inferences. This setup requires setting up a secure and scalable oracle, and an extra transaction to send back the inferences. Shukla et al. [27] developed the Read-Execute-Transact-Erase-Loop (RETEL) module, which similarly utilizes an oracle to outsource general application logic to off-chain Python scripts. Python scripts have a much larger set of libraries, and their computational work does not expend cryptocurrency. Nevertheless, this again requires a scalable and secure Python backend and an additional transaction. We only rely on oracles to retrieve data from remote IS (Figure 7); this is unavoidable in a distributed setting, where relevant data is stored by different parties."}, {"title": "On-chain Solution", "content": "A strictly on-chain option involves embedding an execution engine directly within the smart contract. Symboleo [51], PROForma [52], and GLEAN [22] implementations are based on Finite State Machine (FSM) execution semantics; Rasti et al. [53] manually implemented the Symboleo FSM in terms of base classes within smart contracts. These works are useful to implement decision logic limited to a particular domain, such as legal contracts. We target an approach for deploying general-purpose decision making, encoded by a semantic KG, on blockchain. To that end, a rule engine (reasoner) would have to be embedded, which tends to rely heavily on unbounded loop constructs, i.e., loops without obvious iteration limits. These are heavily discouraged on blockchain, as unbounded loops yield a-priori unknown execution costs-in other words, \"on Ethereum, unlimited work is not an option\"26."}, {"title": "Hybrid On-/Off-chain Solution", "content": "Alternatively, Idelberger et al. [13] mention the compilation of rule-based knowledge into a lower-level representation, to \"increase the speed of inferential computation\" within smart contracts. This is referred to as a hybrid on- and off-chain option, as compilation will occur off-chain and execution takes place on-chain. Our work belongs in this category; we compile a semantic KG, outfitted with N3 rules and an ontology, into the blockchain imperative programming language. Our evaluation shows the execution cost of our smart contract, and how it compares favorably. Nevertheless, our approach currently puts multiple restrictions on supported N3 rules; it remains an open question whether our approach would yield acceptable gas costs for more complex N3 rule sets. We revisit this in future work.\nChoudhury et al. [19] similarly chose a compilation-based approach that generates smart contracts from rules written in SWRL. Their approach relies on apriori, manually written smart contract \"templates\": these implement the criteria involved, together with ADTs based on ontology classes, properties, and general constraints. Business logic rules written in SWRL [54] are parsed into an AST, which is then used to populate the placeholders within the pre-written template conditions (e.g., when checking for age, filling in the specific age constraint). The authors expect that smart contract templates will be applicable to all cases within a particular domain, such as clinical trial eligibility. Instead, we foresee our approach to be applicable to any domain with a domain standard encoded by an ontology.\nAs mentioned, our code generation-based approach essentially transforms a declarative interpretation (semantic KG) into an operational interpretation (imperative smart contracts)."}, {"title": "Code Generation for the Medical Domain", "content": "Past works have investigated imperative code generation for decision logic within the medical domain. Gietzelt"}]}