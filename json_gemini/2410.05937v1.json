{"title": "ATHANOR: LOCAL SEARCH OVER ABSTRACT CONSTRAINT SPECIFICATIONS", "authors": ["Saad Attieh", "Nguyen Dang", "Christopher Jefferson", "Ian Miguel", "Peter Nightingale"], "abstract": "Local search is a common method for solving combinatorial optimisation problems. We focus on general-purpose local search solvers that accept as input a constraint model - a declarative description of a problem consisting of a set of decision variables under a set of constraints. Existing approaches typically take as input models written in solver-independent constraint modelling languages like MiniZinc. The ATHANOR solver we describe herein differs in that it begins from a specification of a problem in the abstract constraint specification language ESSENCE, which allows problems to be described without commitment to low-level modelling decisions through its support for a rich set of abstract types. The advantage of proceeding from ESSENCE is that the structure apparent in a concise, abstract specification of a problem can be exploited to generate high quality neighbourhoods automatically, avoiding the difficult task of identifying that structure in an equivalent constraint model. Based on the twin benefits of neighbourhoods derived from high level types and the scalability derived by searching directly over those types, our empirical results demonstrate strong performance in practice relative to existing solution methods.", "sections": [{"title": "Introduction", "content": "Local search [1] is a common method for solving combinatorial optimisation problems. Typically, it operates by generating an initial assignment to the decision variables in a problem and then iteratively modifies this assignment to improve an objective through a sequence of moves, selected from a neighbourhood of assignments reachable from the current assignment. This approach trades completeness for the ability to make rapid improvements to the objective, and often finds good solutions more quickly than systematic search procedures [2].\nWe focus herein on general-purpose local search solvers that accept as input a constraint model: a declarative problem description consisting of a set of decision variables under a set of constraints. This is a general, flexible approach in contrast to local search procedures specialised to individual problems (e.g., [2, 3, 4]).\nExisting approaches typically accept models written in solver-independent constraint modelling languages like MiniZinc [5]. The recently-proposed Structured Neighbourhood Search (SNS) [6], and the ATHANOR solver we describe in this paper (which was first proposed in [7]), differ in that they begin from a problem specification in the abstract constraint specification language ESSENCE [8, 9, 10]. ESSENCE allows problems to be described without commitment to"}, {"title": "An Overview of ESSENCE and ATHANOR", "content": "This section provides an overview of the architecture and operation of the ATHANOR solver, before full details are given in subsequent sections. We also briefly describe the types and structure of the ESSENCE language on which ATHANOR operates."}, {"title": "Background: ESSENCE", "content": "We begin with a brief overview of the ESSENCE abstract constraint specification language, from which the neigh-bourhood templates and neighbourhood structures employed by ATHANOR are derived (this derivation is discussed in Section 4). ESSENCE was originally conceived as a means of capturing a formal description of a combinatorial problem without committing to a concrete model suitable for input to a particular solving formalism, such as constraint programming or SAT. Hence, the types supported by ESSENCE (summarised in Table 1) are designed to allow a specification to be given in terms of the combinatorial structure of the problem. We distinguish between atomic types and compound types (as shown in Table 1). There is also a distinction in ESSENCE between abstract types (set, multiset, sequence, relation, function, and partition) and concrete types (the atomic types, matrix, tuple, and record) [13].\nAn ESSENCE specification (e.g. Figure 1) comprises formal parameters (given), which may themselves be constrained (where); the combinatorial objects to be found (find); constraints the objects must satisfy (such that); identifiers"}, {"title": "Overview of ATHANOR", "content": "Given an ESSENCE specification, ATHANOR begins by constructing two abstract syntax trees (ASTs). The first tree encodes the constraints in a problem, the second encodes the objective, if present. Each node in the tree represents an ESSENCE expression, with each leaf being a reference to a variable in the problem (or a constant) and their ancestors representing the operators. Subsequently, ATHANOR generates a value at random for each of the decision variables according to some restrictions (described in Section 5). The operators (ancestor nodes) are then evaluated all the way up to the roots of the two trees, yielding a Boolean and an integer value for the constraint and objective trees respectively.\nFurthermore, every Boolean expression is associated with an integer termed the constraint violation. When the expression evaluates to true, the constraint violation is 0, otherwise it takes a positive value. The constraint violation is a heuristic for the magnitude of the change necessary to the operand values of an expression such that the expression evaluates to true. In addition, each variable in the problem is associated with a variable violation, a heuristic measure of the likelihood of a variable being the cause of violated constraints in the problem. In the case of a structured type, such as a set of set of int, variable violations are associated with the top level structure (here the outermost set), each of its elements, and their elements and so on. This allows the solver to infer whether a whole or part of a structure is the cause of constraint violations, as described in Section 6.\nFigures 2 to 4 illustrate the initialisation of the constraint tree for the SONET specification (Figure 1). The forAll quantifier is represented with an and function, applied to a list generated by a comprehension. Similarly, the exists quantifier becomes an or function containing a comprehension. Figure 2 presents the abstract syntax tree prior to the unrolling of the two comprehensions. Each comprehension has three children: the expression template (labelled expr template), the generator, and the unrolled list (initially empty). Comprehensions may also produce sets, but in this example both comprehensions produce lists. The generator supplies a sequence of values to substitute one by one into the expression template to create the elements of the unrolled list. For this simple example, we consider two demand pairs, {1,3} and {3,4}. Figure 3 shows the constraint tree after the top comprehension has been unrolled with respect to these two pairs, forming a list with two elements. Finally, a random value for the network variable is generated, {{1,3,8}, {2,3}}, and used to unroll the inner comprehension, as presented in Figure 4. At this point, the AST can be evaluated, and it evaluates to false. The expression template (expr template) child of a comprehension is always retained in the AST so that the unrolled child can be updated in the event that the generator is changed."}, {"title": "Related Work", "content": "There are a number of existing approaches related to our work, which we summarise in this section.\nLOCALIZER [14] introduced a modelling language for the manual specification of a local search procedure. One of its key innovations was the concept of an invariant (also known as one-way constraints in the iOpt toolkit [15]), an expression that describes how to compute the values of one set of variables from another. This allows the separation"}, {"title": "Neighbourhoods", "content": "A neighbourhood structure [12] is a procedure that takes an assignment to a decision variable and applies a transfor-mation to it, such as randomly reassigning an integer, adding a value to a set, or moving elements between parts of a partition. ATHANOR has a set of neighbourhood templates, which are the building blocks from which neighbourhood structures are created. A neighbourhood is the set of assignments reachable from the current assignment to a decision variable by applying a neighbourhood structure. At each iteration of the search, a neighbourhood structure is selected, and the structure is used to generate a move from within a neighbourhood of the current assignment. Details on the sampling process is described in Section 4.1.\nNeighbourhoods must respect the types of variables, for example given the value {1, 3, 5} for a variable of type set ( size 3) of int (1..6), we can change 1 to 2, 4 or 6, but not to 3 or 5, nor can we add or remove values from the set, as the set is fixed size. More complex types allow for more interesting neighbourhoods. For example, given a value {{1, 2}, {2,3,4}} for a variable of type set of set of int(1..5), we could change one of the values inside one of the inner sets, create or remove an entire set, or move values between sets \u2013 as long as we never create an invalid value for our type.\nIn the next sub-section, we describe the set of neighbourhood templates and how they are combined into neighbour-hood structures."}, {"title": "Neighbourhood Templates", "content": "ATHANOR's neighbourhood templates are inspired by neighbourhood generation in Structured Neighbourhood Search [6]. Since each neighbourhood is directly linked to a variable type and domain, ATHANOR's neighbourhoods are not allowed to violate type invariants, such as the uniqueness of elements in a set. As ATHANOR'S neighbourhoods cannot violate type invariants, we reduce the time spent finding assignments to highly structured variables (e.g. set of partition (regular, numParts 3)) and can instead focus on satisfying problem constraints or improving the objective.\nWhere neighbourhood structures can very cheaply check if they would violate a type invariant, for example adding a value to a set which is already maximum size, they do so. However, given the large number of type invariants in ESSENCE we do not require all neighbourhood structures maintain all type invariants. Instead, neighbourhood structures generate a neighbourhood move, which is reverted if any type invariant is violated. If a neighbourhood structure fails to generate a valid neighbourhood move after a fixed number of attempts (currently set to 50), the neighbourhood structure is abandoned and another neighbourhood structure is chosen.\nNeighbourhood templates are divided into four categories. We will discuss these categories in turn, using the neigh-bourhood structures generated for the SONET problem as examples."}, {"title": "Atomic Neighbourhood Templates", "content": "The first type of neighbourhood templates are atomic neighbourhood templates, presented in Table 2. These apply only to a single value of one of the primitive types. For example, intAssignRandom reassigns a variable of type int to another value in its domain. None of these apply to the SONET problem, as the SONET problem contains no variables of type bool, enum, or int. However, these will be used as building blocks for neighbourhood structures used in the SONET problem later. Integers have a direct neighbourhood template that restricts the magnitude of the change to be no greater than the violation attributed to that variable (intAssignRandomFromViolation). No other type currently has a neighbourhood template that makes use of the violation. We do not provide a general assignRandom for any higher-level types, instead considering neighbourhoods that make smaller, structured changes."}, {"title": "Direct Neighbourhood Templates", "content": "The second type of neighbourhood templates are direct templates, presented in Table 3. These are only dependent on the outermost part of a type. For example, the setAdd neighbourhood template can only be applied to a set, but can be instantiated for sets of any type. The Add templates use the existing infrastructure for creating random values, discussed in Section 5. The relation type in ESSENCE is equivalent to a set of tuple, so variables of type relation use the set neighbourhoods.\nThe attributes of variable domains are considered during the creation of neighbourhood structures. For example, neighbourhood templates that alter a set's cardinality are not used to create neighbourhood structures on a set variable whose domain has a fixed size attribute. Similarly, if a sequence variable has a domain with the injective attribute (meaning all values in the sequence are distinct), the neighbourhood structures created for that variable are limited to those that retain injectivity.\nIn SONET, the set Add and Remove neighbourhood templates are used to add and remove elements from network. These added and removed values are of type set (minSize 2, maxSize capacity)."}, {"title": "Higher-order Neighbourhood Templates", "content": "The third type of neighbourhood template is higher-order, as listed in Table 4. These take another neighbourhood template and apply it to one or more elements of a container, such as a set or sequence. LiftSingle applies a neighbourhood template on a type T to a single element of a collection of Ts. For example, in SONET, we can lift SetAdd to create SetLiftSingle_SetAdd, which adds an element to a set contained in network. We can lift multiple times, so we can lift intAssignRandom twice, thus creating a neighbourhood structure that can modify any integer contained in a set that is in network.\nNeighbourhoods can be lifted for sets, multisets, sequences, and the defined set and the range of a function. Neigh-bourhoods are not currently lifted for partitions, because none of our currently implemented neighbourhood templates would lift to useful, valid neighbourhood structures on partitions. Neighbourhood structures generated by lifting a set illustrate how difficult it is to ensure neighbourhood structures satisfy all type invariants. For example, changing one value in a set to be equal to another value in the same set, where the set has fixed size, would violate the type invariant of the set. Rather than require every neighbourhood handle this problem, ATHANOR runs the neighbour-hood structure, then as a final step checks if the set's type invariants are violated \u2013 if so the move is rejected and an alternative move is generated."}, {"title": "Synchronised Neighbourhood Templates", "content": "The fourth and final kind of neighbourhood templates operate on multiple members of a container at once. These are known as Synchronised neighbourhood templates and are presented in Table 5. For example, the setMove neighbour-hood template moves an element from one set to another. Because these neighbourhood templates require two values to operate, they only work when lifted. liftMultiple takes a synchronised neighbourhood and lifts it to any of the container types in ATHANOR.\nIn SONET, we generate two synchronised lifted neighbourhoods,\nSetLiftMultiple_SetMove, which takes two sets in network and moves an item from one set to another, and\nSetLiftMultiple_SetCrossover, which takes two sets in network and exchanges two elements from the two sets."}, {"title": "Neighbourhood Structure Creation", "content": "Neighbourhood structures are created once at the beginning of search, and neighbourhood structures are created inde-pendently for each variable in the ESSENCE specification. Parameters do not affect neighbourhood structure genera-tion.\nFor each variable, we start at the top of the type and attempt to instantiate each type of neighbourhood template appropriate for the outer-most type. For each lifted neighbourhood template that applies to the outer-most type, we remove the outer-most type, recursively create all neighbourhood structures for the inner type, and combine these with the lifted neighbourhood template."}, {"title": "Generating Random Values", "content": "ATHANOR requires a method to generate a value that belongs to a given domain, both for generating initial variable assignments at the start of search and for generating new elements of a container type (for example, in the setAdd neighbourhood template).\nValues are not generated uniformly at random, instead smaller values (i.e. values of smaller cardinality) are preferred for two reasons. Firstly, ESSENCE domains can contain values so large that they would not typically fit in memory. Types can be arbitrarily nested, and several types describe variable-sized containers (such as set and sequence). In Section 1 we gave an example where a small instance of SONET led to a domain containing values with cardinality $2^{64-66}$.\nSecondly, the unrolling and evaluation of constraints can be computationally expensive when a value has high cardi-nality. ATHANOR consistently aims to make small incremental changes that are computationally cheap to evaluate, and may be quickly undone if the new state is not accepted by the search strategy. Generating high cardinality random values is inconsistent with this general aim. When a large value is a necessary part of the solution, it may be reached by adding elements to a container over several iterations of search.\nThe method for generating random values in ATHANOR includes a mechanism for limiting the number of steps in the generation process, and therefore limiting the size of the generated values as well as the resources needed to generate a value. The resource limit is an essential part of the method. Without the resource limit, when generating a value of a variable-sized compound type, each possible cardinality would be generated with equal probability. The resource limit applies to every part of a nested domain and is described in detail below."}, {"title": "Generating Random Values Under Resource Limits", "content": "In this section, we describe the algorithm GENERATERANDOM. We use the multiset (mset) domain as an example because it demonstrates the general method by which random values are produced for variable-sized container types. Other types, such as set, are very similar but require that other constraints (type invariants) are satisfied when gen-"}, {"title": "Resource Limits", "content": "The GENERATERANDOM procedure is used to generate random values for the initial state and for some neighbourhood structures. In both cases, small values are preferable (as outlined above) and so GENERATERANDOM should be given a small value of $r_{in}$ initially. However, it may run out of resource and fail to generate a value, requiring it to be called again with a larger value of $r_{in}$. We define two constants: $r_{mul} = 1.1$ and $r_{min} = 500$. For the first call, we set $r_{in} \\leftarrow r_{mul} \\times CALCMINRESOURCE(d) + r_{min}$. If the first call fails, then we set $r_{in} \\leftarrow r_{mul} \\times r_{in}$ and call GENERATERANDOM again, repeating until a value is returned.\nIn summary, the effect of the resource limit is to introduce a strong bias towards values with low cardinality (for every part of a nested domain) while still allowing some freedom to generate values that are not of the minimal cardinality."}, {"title": "Violation Counts", "content": "In constraint-based local search solvers, each constraint is often associated with a constraint violation value (or vio-lation degree) [16, 33], which heuristically measures the number of necessary changes in the current assignment to satisfy the constraint, where the violation is 0 when the constraint is satisfied. There can be more than one way of calculating a violation for a constraint, and the violation value does not have a single definition across all constraints. For example, the constraint violation v for the constraint x = y can be defined as v = |x \u2212 y|. One method of measur-ing violation for the allDiff constraint counts the number of repeated values used by its variables. The violation of an arbitrary constraint is calculated inductively based on its structure. For example, the violation of a disjunction $C_1 \\lor C_2$ is the minimum of the violations of $c_1$ and $C_2$. We refer to Michel and Van Hentenryck [33] for a full list of violation calculation rules for different types of constraints, on which ATHANOR's constraint violation rules are based.\nAnother key concept in constraint-based local search solvers is variable violation, which indicates how much each variable contributes to the violation of a constraint. Unlike constraint violations, which are only assigned to booleans, variables of all types can have a variable violation attached to them. In previous works [16, 33], the violation of a variable x within a constraint c is defined as the largest possible decrease in the constraint violation of c over all possible values in the domain of x. However, such calculations can be computationally expensive, especially in ATHANOR where arbitrarily nested variable types are allowed. Furthermore, in a high-level description of a problem, there are cases where only a single high-level decision variable exists in a constraint model. Attaching a violation to only such variable is too coarse. A useful additional feature would be to attach violations to parts of variables, such as the members of a set or sequence. Therefore, we propose a modified version of variable violation calculation, which heuristically decides which variables, and parts of variables, are most likely the cause of current constraint violation.\nThe variable violation calculation in ATHANOR is done in a top-down manner. The violation of each constraint is assigned to the top operator of the constraint, and then the violation is recursively forwarded to the operands of"}, {"title": "Incremental Evaluation", "content": "During search, whenever a variable is reassigned we must calculate new values and new violation counts for the con-straints. Rather than reevaluating the entire AST, which can be computationally expensive, ATHANOR only reevaluates the nodes on the paths from the changed variable (leaf node) to the root. The reevaluation is done incrementally and is optimised for efficiency via three mechanisms: caching, triggering, and incremental hashing. ATHANOR also uses invariants in some cases, as described below."}, {"title": "Caching", "content": "Every node in the AST can be queried for a value. In the case of a leaf node, this is the value assigned to the variable represented by the leaf. For a non-leaf node, this is the value produced by evaluating the operator encoded by the node. In most cases, operators cache their values after evaluation and simply return the cached values when queried. In addition, the operators also cache the values of their operands when needed. For example, a sum operator will cache the current sum of all its child nodes and the value of each element in the sum. Some operators do not cache their values, but instead forward the request for a value to a descendant node. For example, the sequence index operator, which accepts a sequence s and an integer index i, and evaluates to the member m of s whose position matches i. Unless i is out of bounds (see below for a discussion of undefinedness) instead of storing its own value, when queried the sequence index operator simply forwards the query to m.\nThe cached values are used for incremental evaluation whenever possible. This is particularly useful when there are nodes in the AST that have a very large number of children. Consider, for example, summing a list of length 1000. As an example, when changing the value of c from $c_1$ to $c_2$ in the expression s = sum({a,b,c,d,e}), the new value of the sum can be calculated as $s' = s - c_1 + c_2$. This allows the sum operator to be reevaluated without querying the values of a, b, d, and e."}, {"title": "Triggering", "content": "During incremental evaluation, operators must check if they have to update their current values. Each operator makes use of two pieces of information to update its value during the incremental evaluation: its current cached values and the changes made by its child nodes. Changes in child nodes are communicated to their parents through triggers -functions that describe in detail the changes in the child nodes' values. All data types share a common set of three basic trigger functions:\n\u2022 valueChanged() notifies that the value of the node has changed.\n\u2022 hasBecomeUndefined() notifies that the value of the node has become undefined (for example, dividing by 0, or indexing a sequence by an out-of-bounds value, such as \u22121).\n\u2022 hasBecomeDefined() notifies that the value of a node has changed from undefined to defined.\nWhile these three triggers are sufficient to implement incremental evaluation, many abstract types extend the basic set of trigger functions in order to give a more detailed description of the change in the value of a node. This allows a more efficient implementation of incremental evaluation in many cases. Consider, as an example, the set type. Notifying a set operator that the value of one of its operands (of type set) has changed gives very limited information to the operator. Only one member of the set may have changed, or the entire set might have been replaced with a different one. The basic valueChanged() trigger function will always need a full reevaluation of the operator. To improve performance, ATHANOR defines additional trigger functions for the set type, including:\n\u2022 valueAdded (index): a new element is added to the set at index.\n\u2022 valueRemoved (index): an element is removed from the set at index.\n\u2022 memberValueChanged(index): an element in the set is changed at index.\nIn addition, some compound types share two additional trigger functions: memberHasBecomeDefined(index) and memberHasBecomeUndefined(index), which indicate that some element has become defined or undefined, respec-tively. These are useful for operators such as f(y), which evaluates to the image of y w.r.t the function f, and which only becomes undefined if the image of y becomes undefined.\nNote that while types such as sets are unordered in ESSENCE, we treat abstract types as ordered internally, so any particular value remains at the same index where possible."}, {"title": "Value Representation and Incremental Hashing", "content": "It is important for scalability that values are represented compactly, particularly for types where the size is variable. ATHANOR uses representations that scale approximately linearly with the actual size of the value, not its upper-bound size. For example, values of type set of int are represented with an extensible array of references to the elements, combined with a hash set (i.e. a hash table containing only keys) of the elements, both of which scale approximately linearly with the number of elements. Each type has a hash function that is incrementally updated to reflect changes made to a value of that type. The incremental hash functions are important for efficiency because hash values are extensively used to compare values for equality or disequality. B describes the value representations and incremental hash functions for each type. In very rare cases a hash collision can affect the behaviour of ATHANOR, and we also discuss this issue in B."}, {"title": "Invariants and Partial One-Way Propagation", "content": "Invariants, also known as one-way constraints, are a common feature of constraint-based local search solvers (as discussed in Section 3). An invariant defines one set of variables in terms of another set. For example, given x = y+2, we can allow the search process to change y, and calculate the value of x from y when required.\nATHANOR implements invariants for integer variables. When an integer variable a is contained in an equality con-straint a = e (with any expression e), all other occurrences of a are replaced with e throughout the specification and the variable a is deleted. To ensure that e takes a value within the domain of a, the constraint a = e is replaced with e \u2208 D(a), where D(a) is the domain of a, unless this constraint is trivially true in which case it is replaced with TRUE.\nInteger elements of compound types are a more difficult case. Consider an equality involving a member of a compound type, for example M[2] = y + 2, for a sequence M and integer y. In this case we cannot remove M[2] because the sequence M as a whole may appear in other constraints and will have neighbourhood structures. However, we would still like to use this constraint to update M [2] when y changes.\nTo handle such cases, we introduce a weaker technique which we call partial one-way propagation. Given a constraint b = e where b is an integer element of a compound type, partial one-way propagation can assign b the value of e whenever e changes, without deleting b or deleting the constraint b = e. We implement partial one-way propagation for constraints b = e when: b is an integer element of a compound type; the value of e must always be in the domain of b; and the domain of the decision variable x containing b places no restrictions on the value of b other than the domain of b itself.\nThe final requirement is to ensure that updating b will not violate the type of x. For example, if x is an injective sequence, updating b could break injectivity. Similarly, sets and partitions disallow duplicate values so their elements also cannot be updated by partial one-way propagation. Restrictions on an integer element can arise from any layer of the type of x; for example, while the integers in a sequence (maxSize 5) of int can be updated by partial one-way propagation, the integers in a set of sequence (maxSize 5) of int cannot, because the set cannot contain duplicate sequences."}, {"title": "Search Procedures", "content": "In ATHANOR, as is usual for local search-based metaheuristics, the generated neighbourhood structures are treated as black boxes \u2013 procedures which may improve or worsen the violation count or the objective. A single iteration of search consists of the selection of one variable and its reassignment via a neighbourhood structure. Built around these iterations is the traditional metaheuristic design; the metaheuristic decides after each iteration of search whether the new solution should be accepted or the change should be reversed. The metaheuristics used in ATHANOR follows the well-known Iterated Local Search (ILS) algorithm [35] where a hill climbing phase (for improving the current solution) and an exploration phase (for escaping local optima) are interleaved. During the hill climbing phase, neighbourhood structures are selected dynamically to ensure the most effective ones are chosen depending on the current stage of the search.\nIn this section, we first explain the overall search procedure of ATHANOR (Section 8.1). The exploration phase is then described in Section 8.2, followed by details of the hill climbing phase (Section 8.3 and Section 8.4). Finally, the dynamic neighbourhood structure selection mechanism is explained in Section 8.5."}, {"title": "Search Architecture", "content": "The overall search procedure of ATHANOR is presented in Algorithm 2. The search starts by randomly assigning values to all variables (line 1), initialising the two best solutions so far (line 2) and the random walk's length for the exploration phase (line 3). The two best solutions saved during the search include: (i) $s_{best}$, the current global best during the entire search; and (ii) $s^*$, the local best solution obtained before the random walk's length reaches its limit.\nFor constrained problems, it is possible that the current solution does not satisfy all constraints. Therefore, in the main loop, ATHANOR first tries to repair any violations via a hill climbing search (line 6, procedure HILLCLIMBER-TOZEROVIOLATION) before starting to alternate between two phases: (i) a hill climbing phase (line 7, procedure HILLCLIMBER), which focuses on improving the objective function value; and (ii) an exploration phase (line 14, procedure RANDOMWALK), which makes a number of random changes to the current solution s obtained from the hill-climbing if s is not better than the local best $s^*$. The comparator STRICTLYBETTER(s, s*) (line 8) is defined as follows:"}, {"title": "Exploration", "content": "The exploration phase is detailed in Algorithm 3. This phase aims to escape local optima by making a number of unguided random moves. Each move is performed by randomly selecting a neighbourhood structure and applying it to the current assignment. However, we found that simply allowing ATHANOR to make unrestricted changes to the assignment was unproductive because some neighbourhood structures make much more dramatic changes than others. For example, given a nested structure such as a set of set of int, one neighbourhood structure deletes a single integer from an inner set, while another neighbourhood structure deletes a set of integers. An important area of future work is to investigate different strategies to control the magnitude of the changes made by each neighbourhood structure. In this paper, we adopt a simple strategy where we set a limit on the increase in the violation allowed during the current exploration phase (set by nr). A tight restriction on violation increase tends to cause ATHANOR to make small changes to the assignment, if the specification includes some constraints. The same parameter ny also determines the number of random moves made during the exploration phase. Therefore, increasing nr allows individual moves to make larger changes to the assignment, and also increases the number of random moves. While Algorithm 3 could hypothetically enter an infinite loop if applying random neighbour structures failed to find any assignments that satisfy the violation requirements, we have never observed this. If it did, the algorithm could be modified to terminate after a specified number of failed attempts to apply a random neighbourhood structure."}, {"title": "Hill Climbing for Repairing Violations", "content": "The HILLCLIMBERTOZEROVIOLATION procedure (called on line 6, Algorithm 2) is described in Algorithm 4. This procedure solely focuses on repairing any violations in the current assignment. At each iteration, a neighbourhood structure is dynamically selected (details on how neighbourhood structures are selected are described in Section 8.5) and applied to the current solution s (line 4). The new solution is assigned to s if it has a smaller number of violations (line 6). To avoid getting stuck in local optima, we restart the whole search with a random assignment if there is no improvement in terms of violations across 5000 consecutive iterations (lines 9 \u2013 10)."}, {"title": "Hill Climbing for Improving Objective Function Value", "content": "The HILLCLIMBER procedure (called on line 7, Algorithm 2) assumes that the input solution is feasible and focuses on improving the objective value. This procedure is comprised of two different versions of hill climbing. The first one, namely HILLCLIMBERSTANDARD, is a simple and standard hill climbing algorithm where only strictly better solutions are accepted, while the second one, namely HILLCLIMBERWITHVIOLATIONS, is more sophisticated and temporarily allows assignments with constraint violations. The latter one was introduced to address the issue where heavily constrained variables exist and the search must temporarily violate constraints to improve the objective.\nEach version of hill climbing is given a fixed budget of 5000 solution evaluations during each iteration of the overall search procedure of ATHANOR. We first describe the sophisticated hill climbing version (Section 8.4.1), followed by the dynamic selection mechanism to choose between HILLCLIMBERSTANDARD and HILLCLIMBERWITHVIOLATIONS (Section 8.4.2)."}, {"title": "Hill Climbing with Temporary Violations", "content": "The HILLCLIMBERWITHVIOLATIONS procedure is shown in Algorithm 5. Starting from a current solution s and an initial limit nvio for temporary violations (lines 3-4), the main loop includes two stages. First, ATHANOR searches for an assignment with a better objective value while allowing violations up to the limit of nvio (lines 8 \u2013 13). The second stage attempts to repair the introduced violations while maintaining the improved objective value (lines 16 \u2013 21). Following the second stage, if the search found a feasible solution with improved objective value then we reset Nvio and the target objective, essentially re-starting the procedure from the improved assignment s' (lines 23 - 25). Also, when the violation limit reaches a certain value (line 23), the search is reset but with an assignment s' that could be worse than the original assignment s. Otherwise, we increase the violation limit nvio and continue to the next iteration (line 27)."}, {"title": "Dynamic Selection of Hill Climbing Procedure", "content": "Each time HILLCLIMBER is called from Algorithm 2, a choice is made between HILLCLIMBERSTANDARD and HILL-CLIMBERWITHVIOLATIONS. It is not known a priori which one is most suitable at a given stage of the search, so the choice is made dynamically.\nThe choice is treated as a Multi-Armed Bandit (MAB) problem [37]. The MAB problem considers a bandit with multiple independent arms, each of which when pulled returns a random reward. The reward distribution of each arm is unknown, and the aim is to choose which arms to pull such that the total reward is maximised. The most important point when solving a MAB problem is to have a balance between exploitation (pulling the best-so-far arm) and exploration (trying a new or less frequently selected arm to gather more information). One of the most"}, {"title": "Dynamic Neighbourhood Structure Selection", "content": "In this section, we describe in detail how neighbourhood structures are selected during each hill climbing variant (i.e., the APPLYNEIGHBOURHOODSTRUCTURE procedure in Algorithm 4 and Algorithm 5).\nA typical ESSENCE specification with high-level nested types usually leads to the instantiation of several neighbour-hood structures. Some neighbourhood structures may be better at improving the objective, while others may be better at reducing violations when looking for a feasible solution. Of course there may be some that are not favourable for either. The aim of dynamic neighbourhood structure selection is to quickly classify these neighbourhood structures and bias the search towards the neighbourhoods appropriate to the current search stage."}, {"title": "Experimental Evaluation", "content": "In this section we evaluate the performance of ATHANOR in comparison with a collection of other solvers. We compare with constraint-based local"}]}