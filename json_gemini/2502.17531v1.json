{"title": "Laplace-Beltrami Operator for Gaussian Splatting", "authors": ["Hongyu Zhou", "Zorah L\u00e4hner"], "abstract": "With the rising popularity of 3D Gaussian splatting and the expanse of applications from rendering to 3D reconstruction, there comes also a need for geometry processing applications directly on this new representation. While considering the centers of Gaussians as a point cloud or meshing them is an option that allows to apply existing algorithms, this might ignore information present in the data or be unnecessarily expensive. Additionally, Gaussian splatting tends to contain a large number of outliers which do not affect the rendering quality but need to be handled correctly in order not to produce noisy results in geometry processing applications. In this work, we propose a formulation to compute the Laplace-Beltrami operator, a widely used tool in geometry processing, directly on Gaussian splatting using the Mahalanobis distance. While conceptually similar to a point cloud Laplacian, our experiments show superior accuracy on the point clouds encoded in the Gaussian splatting centers and, additionally, the operator can be used to evaluate the quality of the output during optimization. Our code will be released on github soon.", "sections": [{"title": "1. Introduction", "content": "3D Gaussian Splatting (3DGS) [19] has recently revolutionized 3D scene representations. By representing complex scenes as a set of 3D Gaussians, it achieves photorealistic results for novel view synthesis while allowing much more efficient training and real-time rendering compared to NeRF based approaches [2]. Even though it was originally proposed for rendering applications, it is now also popular as a general 3D representation [14, 16]. However, due to its initial focus on rendering, most 3DGS methods do not lead to an accurate surface representation. To overcome this, a series of work has been produced with a focus on surface reconstruction instead [10, 16]. One possibility is to pull the 3D Gaussians to the suspected surface and then reconstruct a mesh via Poisson reconstruction [15, 18]. Another approach was suggested in [16] by restricting the Gaussians to be 2D which leads to more accurate surface mappings (as the surface of a 3D object is a 2D manifold).\nAs the geometric reconstruction accuracy advances, the need for common geometry processing tools directly on this representation rises. For example, manual editing through deformation energies [17] and semantic segmentation [8]"}, {"title": "2. Related Work", "content": "In this section, we show connections to the most relevant related work. A broader introduction into Gaussian splatting can be found in the survey of [9]."}, {"title": "2.1. Gaussian Splatting", "content": "3D Gaussian splatting was introduced in [19] as an efficient framework for novel-view synthesis. It optimizes over a set of Gaussian distributions in 3D space with color and opacity values which can be rendered from new view points. While this works exceptionally well and has been applied to many applications [28, 34], the pipeline is focused on clean-looking rendering results but not clean geometry. To overcome this, several methods introduced additional constrains that focus on the geometric accuracy in the optimization. For example, the method of [16] restricts the variance to a 2D plane (the dimension of the surface). Another approach, SuGaR [15], extracts a mesh and realigns the Gaussian splats with the surface of this mesh to obtain a cleaner geometry. Gaussian opacity fields [35] combine Gaussians with a signed distance function to further regularize the results. While this leads to better geometry, the extraction of a mesh in the process is expensive and the extracted mesh might still be noisy. Without the extraction, outlier splats can prevail, and while they tend to not deteriorate the rendering, they can heavily interfere with geometry processing applications."}, {"title": "2.2. Laplacian-Beltrami Operator", "content": "The Laplace-Beltrami operator (LBO) is the generalization of the second derivative on general manifolds and a popular tool in many geometry processing applications. Its discretization, especially on triangular meshes, has been studied extensively and it has been shown that not all properties of the continuous Laplacian can be fulfilled in the discrete case at the same time [32]. While it is possible to use the graph Laplacian [31] on a mesh by discarding the face information, this fails to take into account all information about the local geometry. More advanced mesh LBOs, like the cotan discretization [20, 25] or intrinsic Delaunay discretization [5], provide a more accurate approximation of the continuous behaviour. These can also be extended to more complex domains, like n-dimensional data [12], general polygonal meshes [1, 7], or non-manifold meshes [29]. However, all of these depend on explicitly given connectivity information which can guarantee certain properties but does not work for less structured shape representations, like point clouds or Gaussian splatting.\nAs the discrete Laplacian operator relies on the definition of the neighborhood that is not explicitly given in the point cloud, it is essential to estimate the neighborhood function in a good way so that it approximate the intrinsic connectivity. A straight-forward solution would be to triangulate the point cloud, however, this is expensive and often leads to errors on sparse or noisy point clouds. Instead, a common solution is to locally approximate the surface via its tangent plane and projection of surrounding points onto it, often by a nearest neighbor search [4]. This works well on smooth or flat regions, but struggles around very sharp features. The resulting inaccuracies can be diminished by building an operator that is robust to incorrectly found and non-manifold surface connections [29], or by employing improvements in the surface estimation for these cases, for example through anisotropic Voronoi diagrams [26], or physic"}, {"title": "3. Background", "content": "In this section we introduce the background on Gaussian splatting and the Laplace-Beltrami operator necessary to understand the rest of the paper."}, {"title": "3.1. Gaussian Splatting", "content": "3D Gaussian splatting [19] represents a scene as a collection of 3D Gaussian distributions {(\u03bci, \u03a3i, \u03b1i, ci)}i with mean \u03bci \u2208 R3, variance \u03a3i \u2208 R3\u00d73, alpha value \u03b1i, and color function ci in spherical harmonic representation. This collection can be easily projected to 2D and rendered by accumulating density along a ray. The parameters of each Gaussian splat are optimized to render to a set of training images from different view points. Since this optimization is focused on rendering, the 3D Gaussian splats are not necessarily localized on the surface of the objects in the scene. There have been efforts to align the 3D Gaussian splats to the surface by regularizing on the SDF [15], the depth and the normal [35], or training 2D Gaussian splatting [16], that focus on the geometry of the reconstructed mesh."}, {"title": "3.2. (Discrete) Laplace-Beltrami Operator", "content": "The Laplace-Beltrami operator (LBO) L = div \u00b7 \u2207 generalizes the second derivative to general closed compact manifolds. The operator and its eigenfunctions and eigenvalues, which are non-trivial solutions to L\u03c6i = \u03bbi\u03c6i, are popular tools in geometry processing (see Sec. 2.2). When discretizing the underlying manifold, the LBO also has to be discretized which leads to approximation artifacts [32].\nThe cotan-discretization [25] for triangular meshes is defined as follows:\n\nWij =\\begin{cases}\n(cot\u03b1ij + cot\u03b2ij), & if (i, j) \u2208 E \\\\\n-\\sum_{k \\in N(i)} W_{ik} & if j = i \\\\\n0, & otherwise\n\\end{cases}\n\nwhere \u03b1ij, \u03b2ij are the opposing angles to the edge between vertices vi, vj (see Fig. 2). In combination with the diagonal mass matrix M describing the local weight at each vertex Mii the area of the voronoi cell around vertex i, the LBO is L = M\u22121W. While the default cotan-Laplacian does not fulfill the maximum principle, it will when applied to"}, {"title": "4. Method", "content": "We propose a discretization of the Laplace-Beltrami operator (LBO) that takes into account all geometric information that is given in Gaussian splatting and can serve as a quality measure for the surface information at the same time. As detailed in Sec. 3.2, the LBO encodes the local surface information so the main challenge is to construct the local neighborhood accurately, even though a collection of Gaussians has no explicit notion of connectivity. We explain how to do this in Sec. 4.1. The second challenge is that most Gaussian splatting is optimized to render well and not as an accurate geometry representation. Methods like 2D Gaussians [16] or SuGaR [15] aim to find a representation more localized on the surface but still contain many low-variance outliers. In Sec. 4.2 we explain how the properties of the LBO can be used to determine if a geometrically converged representation was found and how to use this during training."}, {"title": "4.1. Local Neighborhood Construction", "content": "Gaussian splatting can be considered as a point cloud (the centers) with additional geometric information in form of a directional variance attached to each point. A straight-forward implementation of the LBO could just apply the point cloud Laplacian [29] to the center point cloud, however, this ignores valuable information that the variance gives. Instead of using the Euclidean neighborhood to estimate the local connectivity of the surface, we propose to use the Mahalanobis distance which can take into account the full Gaussian distribution present.\nThe Mahalanobis distance is a measure of the distance between a point and a distribution G with mean \u03bc \u2208 Rd and covariance \u03a3 \u2208 Rd\u00d7d. We only consider d = 3 in this paper. It is defined as\n\ndm(p, G) = \\sqrt{(p - \u03bc)T\u03a3^{-1}(p - \u03bc)}\n\nfor a point p \u2208 Rd. See Fig. 3 for a visualization. Intuitively, Gaussian splats have a higher variance along the tangent directions of the surface, and a low variance in normal direction. Thus, a neighborhood based on the Mahalanobis distance clusters together points that lie along side on the surface and give outliers a very high distance.\nHowever, we can only compute the distance between a point and a distribution, but all elements of a Gaussian splatting are distributions. Computing the distance between two distributions, which is what we actually want, is possible, for example with the earth mover's distance but computationally very expensive. In practice, we approximate by taking a symmetric approach and building neighborhoods between splats where edge points are both their respective Mahalanobis neighbors.\nThe point cloud Laplacian requires a neighborhood N of k nearest neighbors to be defined for each vertex v which is then used to approximate the local surface. Instead of computing the Euclidean nearest neighbors, we compute the following for each Gaussian center: (pi, pj) is an edge if pi lies in the neighborhood of pj, and pj lies in the neighborhood of pi using the k-nearest Mahalanobis neighbors. There can be multiple connected components in the constructed graph due to the existence of noisy Gaussian splats inside the objects. To filter out the Gaussian"}, {"title": "4.2. Gaussian filtering", "content": "The optimization of a set of Gaussian splats often leads to outliers that do not contribute to the geometry or rendering. The original Gaussian splatting [19] already proposed to regularly remove splats with near zero opacity due to their low information. When rendering a closed surface, splats on the inside will not be visible and thus can also take high variance forms without adding to the solution (but also not degrading it) but adding noise to the geometric information. We propose to use the same symmetric Mahalanobis neighborhood construction to filter out these noisy Gaussians by pruning splats that are not in the largest connected component. See Fig. 4 for a visualization of the effect of filtering."}, {"title": "4.3. Adaptive Training", "content": "In previous work, the Chamfer distance [16, 35] is mainly used to evaluate the quality of geometry for Gaussian splatting. However, it is originally designed to evaluate the similarity between point clouds and thus does not take surface"}, {"title": "5. Experiments", "content": "In this section we show the effectiveness of our method. We mainly compare against the robust point cloud Laplacian [29] as a baseline and use the mesh Laplacian as the ground-truth on data generated from a given mesh instead of renderings only (see Sec. 5.1). We show superior performance on the computation of heat diffusion and the derivied geodesic distance (Sec. 5.2), shape matching (Sec. 5.3), and the adaptation of training the Gaussian splatting using the LBO for filtering (Sec. 5.4). All experiments were done a NVIDIA RTX 4090 with 64 GB RAM."}, {"title": "5.1. Evaluations and Comparisons", "content": "We build the dataset from TOSCA [6] that provides 8 classes of non-rigid shapes with correspondence with at least 3 different poses in each class. We use blender to generate the image dataset for training, validation and testing. For each class we select 5 poses if any and generate 100 images of each shape for training, 50 images for validation and 30 images for testing. For simplicity, we downscale the object by 20 before capturing the images to fit into a default camera frame. In comparison to other common 3DGS datasets such as Mip-NeRF360 [2], TOSCA contains meshes well-suited for geometry processing applications and a clean ground-truth mesh which we can use to quantitatively evaluate our method. We will publish this dataset with reconstructed 3DGS from TOSCA and correspondences between both with this paper to allow better evaluation of geometry processing applications on 3DGS.\nThe LBO matrices of different 3D representations cannot be compared directly because the discretization can vary significantly. We will use the eigenvalues and selected functions on the surface for comparing the performance of different approaches. The discretization differences also exist for these functions but the function values can be more easily projected onto a different discretization. In order to compare, we assume the smoothness of the functions between the existing samples and then project each vertex of the ground truth mesh onto the other representations (point cloud, 3D Gaussians, mesh from GOF) by distance. For each representation, we denote this correspondence by I..\nFor the eigenvalues, the paper of [3] shows the convergence of the Laplacian operator in the spectrum regime. The eigenfunctions of the point cloud Laplacian converges to the eigenfunctions of the Laplacian-Beltrami operator in the underlying manifold in L2 norm with improved sampling. Thus, we propose to compare the eigenvalues and the eigenfunctions of the normalized Laplacian matrix, that is to solve Lx = \u03bbMx and compute the first K = 100 eigenvalues (the lower the more stable) for all experiments. Since the eigenvalue is inversely proportional to the scale of the surface area, we calculate the normalized difference \u2211i|\u03bbX \u2212 \u03bbi| for i = 1, . . . , 100 for comparing eigenvalues. For the eigenfunctions, we apply the 12 metric and the normalized 12 metric\n\nL_2(f_1, f_i) = \\frac{L(f_1, f_i)}{||f_1||_w \\cdot ||f_i||_w}\n\nwhere ||f||w = fTMf and M is the mass matrix of the ground truth mesh and f' the eigenfunction of a different representation projected onto the ground-truth mesh.\nWe apply the same projection before any comparisons also for the heat diffusion, geodesic distance and matching errors. We are able to compute the losses L2(f(I), fgt) and L\u221e(f(I), fgt) of the respective functions.\nWe compare our method to the following baselines since there are no targeted competitiors for LBO on Gaussian splatting:\n\u2022 Point Cloud: the point cloud Laplacian on the point cloud computed from centers of the 3D Gaussian splats,\n\u2022 Mesh (GOF): reconstructing the mesh from a 3DGS using the SOTA approach of Gaussian opacity fields [35],\n\u2022 Ours (Euclid): our GS Laplacian using the k-nearest neighbors in Euclidean distance to compute the normal direction (as in [29]), applied on the 3DGS filtered,\n\u2022 Ours (M+normal): our GS Laplacian using the lowest magnitude variance direction as normal direction and using the k-nearest neighbors in Mahalanobis distance, applied on the 3DGS filtered,\n\u2022 Ours(AT+M+normal): our GS Laplacian using the lowest magnitude variance direction as normal direction and using the k-nearest neighbors in Mahalanobis distance, applied on the 3DGS after adaptive training.\nThe ground-truth Laplace-Beltrami operator is computed from the ground-truth meshes (if given), and we use the"}, {"title": "5.2. Function Comparison", "content": "Since the LBO matrix itself is not directly comparable (see Sec. 5.1), we compare descriptive functions on the surface of each representation. We choose (i) the eigenfunctions of the LBO, (ii) heat diffusion applied from a collection of source points, and (iii) the geodesic distance computed using Geodesics in Heat [13].\nWe take the first 10 eigenfunctions computed from each Laplace operator and compare their values to the eigenfunctions from the LBO on the ground-truth mesh in TOSCA. Tab. 1 shows the average over these 10 eigenfunctions for each class and operator. Our method and Mesh (GOF) perform on-par while both are much better than the point cloud Laplacian. However, Mesh (GOF) requires an extra step to extract a (very high resolution) mesh from the Gaussian splatting which is expensive to compute while our methods operates directly on the given data.\nAs an intrinsic property, the mean curvature can be derived from the Laplace-Beltrami operator via the equation \u2206p = \u22122Hn, where p denotes the coordinates, H the mean curvature and n the normal. This property can be used to evaluate the quality of the Laplacian Beltrami operator. We report qualitative and quantitative results in"}, {"title": "Geodesic Distance", "content": "The geodesic distance represents the shortest path between two points on a surface, or more gen"}, {"title": "5.3. Shape Matching", "content": "A fundamental problem in geometry processing is finding correspondences between pairs of non-rigid 3D shapes. The approach of functional maps [22] provides an efficient framework to compute these in functional space where the Laplace-Beltrami basis is used for dimensionality reduction. We will use this application to show the effectiveness of our Laplace-Beltrami operator on 3DGS by comparing accuracy in representing correspondences. Given the ground-truth correspondence in form of a permutation P, it can be projected into functional map representation by taking\n\nC = \u03a6sP\u03a6tMt\n\nwhere \u03a6 is the matrix of the first (ordered by frequency) k stacked eigenvectors of the source and target shape, respectively, and Mt the mass matrix on the target shape. A correspondence Corr(s,t) can be extracted by taking nearest neighbors in the aligned spectral space between the points in \u03a6t and Cs. Since we do not want to evaluate a specific matching algorithm, this projection of the ground-truth, which still leads to errors due to the dimension reduction, gives us a measure of the quality of the eigenbasis used, and in turn of our Laplace Beltrami operator.\nFor computational reasons, we use k = 100 eigenfunctions and uniformly sample 1000 vertices to compute the geodesic error. We do the experiments on the TOSCA dataset. Since the vertices on the meshes are different from those derived from the 3D Gaussians, we are only able to compute the approximate geodesic error\n\nq_{s}^{gt} = Corr_{gt}(p_s)\n\\\\\nq = P_{pc\\rightarrow m}Corr(s,t)(P_{m\\rightarrow pc}(p_s))\n\\\\\nE_{corr}(p_s) = \\frac{dist(q_{s}^{gt}, q)}{S_t}\n\nwhere ps is a vertex on the mesh of the source object, P_{t}^{pc\\rightarrow m} denotes the projection from the point cloud derived from 3D Gaussians to the mesh of the target object and P_{m\\rightarrow pc} denotes the projection from the mesh of the source object to the point cloud of the source object. Corr(s,t) is the point-wise correspondence from the source object to the target object computed using the eigenfunction of \u039bs and \u039bt [22] as described above. While extracting the mesh via GOF performs slightly better, our method outperforms the point cloud Laplacian as visible in Fig. 9 and Fig. 10."}, {"title": "5.4. Adaptive Training of 3DGS", "content": "We use our adaptive training technique (Sec. 4.3) and point cloud filtering (Sec. 4.2) to improve the geometry of the results when training 3DGS. Specifically, we filter every N = 2000 iterations and remove all except the k = 1 biggest components at the same time. Note that finding all the connected components can be achieved by breadth-first search in complexity O(N), hence the extra cost of computation is insignificant during training.\nRemarkably, this training scheme leads to a very clean geometry with nearly no outlier splats in the geometry (see"}, {"title": "6. Geometry Smoothing", "content": "As an additional experiment from the area of geometry processing, we show how the optimized geometry can be manipulated easily with the LBO operator. We compute the LBO on the 3DGS and use the first 500 eigenfunctions to form a low frequency function space, denoted by\n\u03a6 \u2208 Rn\u00d7500. Then, we project the xyz-coordinate functions onto \u03a6 to perform a low pass filtering (smoothing):\n\n\u03c5 = \u03c6\u03c6 T\u039c\u03c5, \u03c5 \u2208 {x,y,z},\n\nwhere M is the mass matrix. We show the results using k = 500 on the chair shape in Fig. 1 where even view dependent lighting effects are preserved under this smoothing operation."}, {"title": "7. Conclusion", "content": "We defined a new Laplace Beltrami operator that can be directly computed on 3D Gaussian splatting by using the Mahalanobis distance on the Gaussian splats using the variance to determine the neighborhood and filter out outlier splats. Our experiments show that this performs much better than just computing the point cloud Laplacian on the point cloud of Gaussian centers, and also does not require an extra expensive step like extracting a mesh from the 3D Gaussians. Additionally, while an extracted mesh can lead to accurate computations, the mesh might also contain topological noise (e.g. in the form of disconnected components) which distorts the results significantly. Our Laplacian allows common geometry processing applications, like shape matching, to be directly performed on 3DGS, and the GS Laplacian can be used during training to determine convergence and improve the quality of the geometry."}]}