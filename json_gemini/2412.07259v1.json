{"title": "Goal-Driven Reasoning in DatalogMTL with Magic Sets", "authors": ["Shaoyu Wang", "Kaiyue Zhao", "Dongliang Wei", "Przemys\u0142aw Andrzej Wa\u0142\u0119ga", "Dingmin Wang", "Hongming Cai", "Pan Hu"], "abstract": "DatalogMTL is a powerful rule-based language for temporal reasoning. Due to its high expressive power and flexible modeling capabilities, it is suitable for a wide range of applications, including tasks from industrial and financial sectors. However, due its high computational complexity, practical reasoning in DatalogMTL is highly challenging. To address this difficulty, we introduce a new reasoning method for DatalogMTL which exploits the magic sets technique-a rewriting approach developed for (non-temporal) Datalog to simulate top-down evaluation with bottom-up reasoning. We implement this approach and evaluate it on several publicly available benchmarks, showing that the proposed approach significantly and consistently outperforms performance of the state-of-the-art reasoning techniques.", "sections": [{"title": "Introduction", "content": "DatalogMTL (Brandt et al. 2018) extends the well-known declarative logic programming language Datalog (Ceri, Gottlob, and Tanca 1989) with operators from metric temporal logic (MTL) (Koymans 1990), allowing for complex temporal reasoning. It has a number of applications, including ontology-based query answering (Brandt et al. 2018; G\u00fczel Kalayci et al. 2018), stream reasoning (Wa\u0142\u0119ga et al. 2023; Wa\u0142\u0119ga, Kaminski, and Cuenca Grau 2019), and reasoning for the financial sector (Colombo et al. 2023; Nissl and Sallinger 2022; Mori et al. 2022), among others.\nTo illustrate capabilities of DatalogMTL, consider a scenario in which we want to reason about social media interactions. The following DatalogMTL rule describes participation of users in the circulation of a viral social media post:\n$\\Box_{[0,2]}P(x) \\leftarrow I(x,y) \\land P(y)$,\n(1)\nnamely, it states that if at a time point t a person x interacted with person y over the post (expressed as I(x, y)), and y participated in the post's circulation (expressed as P(y)), then in the time interval [t, t + 2], person x will be continuously participating in the post's circulation ($\\Box_{[0,2]}P(x)$).\nOne of the main reasoning tasks considered in DatalogMTL is fact entailment, which involves checking whether"}, {"title": "Preliminaries", "content": "We briefly summarise the core concepts of DatalogMTL and provide a recapitulation of magic set rewriting. Throughout this paper we assume that time is continuous, in particular, that the timeline is composed of rational numbers.\nSyntax of DatalogMTL. A time interval is a set of continuous time points o of the form (t1,t2), where t1, t2 \u20ac Qu{-8,8}, whereas ( is [ or ( and likewise ) is ] or ). An interval is punctual if it is of the form [t, t], for some t \u2208 Q; we will often represent it as t. Although time points are rational numbers we will sometimes use dates instead, for example, 10/9/2023 (formally it can be treated as the number of days that passed since 01/01/0000). A term is either a variable or a constant. A relational atom is an expression R(t), where R is a predicate and t is a tuple of terms of matching arity. Metric atoms extend relational atoms by exploiting operators from metric temporal logic (MTL), namely, \u2295,\u65e5,\u03c1, \u03c1, Up, and So, with varying intervals o.\nIn particular metric atoms, M, are generated by the following grammar:\nM ::=1 | T | R(t) | \u7530\uff61M | \u65e5\uff61M |M|M|\nMUM MSM,\nwhere o is an interval containing only non-negative ratio-"}, {"title": "Magic Sets for DatalogMTL", "content": "In this section, we extend magic set rewriting to DatalogMTL. We start by providing an example of how, given a query q and a DatalogMTL program-dataset pair (II, D), we construct (\u03a0', D'). To simplify the example we will use a ground query q (i.e. a fact), but it is worth emphasising that our approach supports also non-ground queries.\nExample. Consider a query q = P(Arthur)@10/9, some dataset D, and a program consisting of the rules\n$\\Box_{[0,2]}P(x) \\leftarrow I(x,y) \\land P(y)$,\n$\\Diamond_{[0,1]}P(x) \\leftarrow I(x, y) \\land \\neg \\Box_{[0,1]}P(y)$.\n(r1)\n(r2)\nWe start by constructing an adorned program Ia as below:\n$\\Box_{[0,2]}P^{b}(x) \\leftarrow I^{bf}(x,y) \\land P^{b}(y)$,\n$\\Diamond_{[0,1]}P^{b}(x) \\leftarrow I^{bf}(x, y) \\land \\neg \\Box_{[0,1]} P^{b} (y)$.\n(ra\u2081)\n(ra\u2082)\nProgram Ia will help us generate magic predicates for each idb predicate. In the next step, similar to the case of Datalog, two types of rules are added to II' for each rule in \u03a0\u03b1.\nRules of the first type are guarded versions of the original rules in II, which are responsible for derivation of idb facts guarded by a magic atom. Consider Rule (ra\u2081):"}, {"title": "Correctness of our Algorithm", "content": "Given a program II, a dataset D, and a query q = R(t)@p, the magic pair (\u03a0', D') produced by Algorithm 1 provides the same set of answers to q as (II, D). Theorem 1 implies this statement.\nTheorem 1. For each DatalogMTL program II, each dataset D, and each query R(t)@p, the following holds for each time point t \u2208 p and each substitution \u03c3 mapping variables in t to constants:\nC,D, t = R(o(t))\niff C\u2161',D', t = R(o(t)),\nwhere (\u03a0', D') = Magic(I, D, R(t)@\u03c1).\nProof Sketch. For the if part, we leverage the fact that the first kind of rules in II' are all derived by adding magic atoms to the body of a rule from II, which means that each derivation of a non-magic fact with (\u03a0', D') corresponds exactly to a derivation from (II, D).\nFor the only if part, we call facts in magic relations magic queries and show that materialisation recursively divides a magic query and produces other magic queries whose corresponding facts of interest combined together can derive the original query's facts of interest. This division of magic queries continues until magic queries are indivisible and its fact of interests can be derived by purely edb facts.\nNotice that if the query q is a fact, it is clear that Magic(II, D, q) entails q if and only if (II, D) does so.\nNext we adapt our algorithm to the optimised solely materialisation-based algorithm. Given II a program, D a dataset, and R1 (t1)@01 a fact, this algorithm checks for entailment of R1 (t1)@01 and searches for a saturated interpretation after each materialisation round. It always finds a saturated interpretation in finite time, which necessarily requires the entailed facts with intervals between the maximum and minimum time points in (II, D) to remain the same between materialisation rounds. This means the extreme interval endpoints of facts in D directly affect the algorithm's running time. Therefore, given a query q = R(t)@p, if following our rewriting algorithm we add fact m_R\u00ba(bt(t, a))@p to D, the time cost for the optimised algorithm can be influenced by e, which can be arbitrarily large and does not depend on the original program and dataset. This is undesirable as it may render the evaluation of the transformed program and dataset slower than their original counterpart."}, {"title": "Empirical Evaluation", "content": "We implemented our algorithm\u00b9 and evaluated it on LUBMt (Wang et al. 2022), a temporal version of LUBM (Guo, Pan, and Heflin 2005), on iTemporal (Bellomarini, Nissl, and Sallinger 2022), and on the meteorological (Maurer et al. 2002) benchmarks using MeTeoR (Wa\u0142\u0119ga et al. 2023) to see how the magic programs fare against the original programs in terms of query answering. The three test programs have 85, 11, and 4 rules, respectively. Moreover, all our test queries are facts since, to the best of our knowledge, no DatalogMTL system allows currently for answering queries with variables. Given a program II and a dataset D, the engine first loads the pair and preprocesses the dataset before"}, {"title": "Conclusion and Future Work", "content": "We have extended the magic set rewriting technique to DatalogMTL, considerably improving the performance of a single query answering. Our goal-driven approach provides an important alternative to the state-of-the-art materialisation-based method, and it can be useful in applications where the underlying data changes frequently or the materialisation of the entire program and dataset requires too much time and space. In future, we shall consider developing a hybrid approach that combines top-down with bottom-up reasoning. Supporting additional features such as negation and aggregation is also an avenue worth research."}, {"title": "Appendix", "content": "Before presenting the proofs we make a few relevant definitions in addition to the ones in our paper.\nIn the following text we adopt interval arithmetic. For a set T \u2286 QU{\u2212\u221e, \u221e}, let inf (T) represent the infimum of T and sup(T) the supremum of T. We define a function Link: [R]2 \u2192 [R], for two intervals 01 and 02, let B =\nQ1 Q2,\nLink(01,02) =[inf(B), sup(B)]\n- (B^ {inf(B), sup(B)})\nwhere [in f (B), sup(B)] is a closed interval.\nA DatalogMTL fact with a punctual interval is a punctual fact.\nFor a tuple of terms t and an adornment y of the same length, let bt(t, \u03b3) and bu(t, \u03b3) be the subsequences of bound terms and bound variables in t, respectively, according to \u03b3.\nFor a non-nested ruler that is without nested operators, we define the reasoning order of the predicates in body(r).\n\u2022 We first number the metric atoms of r from left to right, starting with 1.\n\u2022 We next generate a listing of all the predicates p that appeared in r as follows, note that duplicate predicates are preserved.\nFor any pair of predicates p\u2081 and p2, if p\u2081 and p2 are from different metric atoms, say M\u2081 and Mj, and i < j, then in the listing p\u2081 appears on the left of p2. Predicate P1 appears on the right of p2 when i > j.\nIf p1 and p2 are from the same metric atom Mi, then Mi contains MTL operator S or U. Assume that the metric atom is in the form p\u2081Op2, where O is either S or U, then p2 appears on the left of p1. The reverse is true for p\u2081 and p2 if the metric atom is in the form P2OP1.\n\u2022 Let the listing generated by the previous steps be L, we number the predicates in L from left to right staring with 1, the number becoming the predicate's index in the reasoning order.\nLet I0, I1,..., and I, I1, ..., be the transfinite sequences of interpretations defined for ID and ID' by the immediate consequence operators T\u2081\u2081 and T\u2081\u2081', respectively. If for a fact g, there is an integer i such that I satisfies g and Ji-1 does not satisfy g, we call this integer the birth round of g regarding (II, D), and denote this integer by birth(g, II, D). Facts satisfied by Jo have birth round 0 regarding (II, D).\nWe are now ready to deal with Theorem 1.\nProof. Note that when R is not an idb predicate in II, I' will be empty and both canonical models satisfy the same set of facts with predicate R, since this set is empty when R is not edb for II, and when R is edb, D and D' contains the same set of edb facts. Also, for determining whether an interpretation I satisfies some relational atoms at each time point te p' for a time interval o', considering punctual facts alone is enough. Therefore, we only need to consider queries with idb predicates in II and punctual intervals. Next, we prove the equivalence:\n\u2022 {}: We prove the if part of Theorem 1 by an induction on birth(g, I', D'), where fact g's predicate is an idb predicate in II and its interval tg is punctual. We show that if birth(g, I', D') = i, then I satisfies g. We capitalise on the fact that each rule r' in I' that derives facts with predicates from the original program II is produced by adding a magic atom to a rule r in II.\nBasis: When birth(g, \u03a0', D') = 0, this case is trivial since such g does not exist.\nInduction Step: When birth(g, I', D') = i and i > 0, there must be a rule r' \u2208 \u03a0', a dataset F' satisfied by J-1, a time point t and a substitution o such that IF', t = o(body(r')) and for any interpretation I such that I, t = (head(r')), I must satisfy g. In other words, g was first derived by r'. Let F be the set of all the facts in F' whose predicates are idb predicates in II, then by the induction hypothesis, Ji-1 satisfies F. Let r be the rule from which r' is produced by lines 8\u2013 11 in Algorithm 1, it is clear that IF, t = o(body(r)) and head(r) = head(r'). Since I\u017c-1 satisfies F, we have \u00cf\u00bf-1,t = \u03c3(body(r)), which in turn means that Ii, t = (head(r')), whereby Ii satisfies g.\n\u2022 {}: Let y be the adornment of R according to t. It is obvious that \u2200o, bt(\u03c3(t), \u03b3) = bt(t, \u03b3), since bt(t, \u03b3) is a tuple of constants. Therefore, we only need to prove the following claim:\nClaim 3. For any fact g = S(tg)@tg, where tg is a time point and S is an idb predicate in II, if there is a fact gm = m_S% (bt(tg,0))@tg which has a birth round regarding (I', D') for some adornment Yo, and g has a birth round regarding (II,D), then g also has a birth round regarding (\u03a0', D').\nBecause for any punctual fact q' = R(t')@tq, satisfied by CII,D such that tq \u2208 p and there is a substitution o for which \u03c3(t) = t', we have already made sure that I satisfy its corresponding qm mentioned in Claim 3 by line 3 in Algorithm 1, whereby if Claim 3 stands, q' is satisfied by CI',D'. We prove Claim 3 by an induction on birth(g, II, D).\nBasis: when birth(g, II, D) = 1, there must be a rule r\u2208 II, a dataset F satisfied by ID, a time point t and a substitution o such that IF, t = o(body(r)) and for any interpretation I such that I,t = o(head(r)), I must satisfy g. Since D \u2282 D', ID' also satisfies F. Let r' be the rule produced by adding an atom containing m_Sro to body(r) in line 10, Algorithm 1, then IFU{gm}, t = body(r') and head(r') = head(r), whereby since I = I'\u00bd satisfies F\u222a {gm}, we have I'\u2081, t = head(r), and thus I\u2081 satisfies g.\nInduction Step: when birth(g, II,D) = n and n > 1, there must be a ruler \u2208 II, a dataset F' satisfied by In-1, a time point t' and a substitution o such that IF', t = (body(r)) and for any interpretation I such that I, t = (head(r)), I must satisfy g. Let r be a follows\n\u7530S(to) \u2190 M1, M2, ..., \u039c\u03b9.\nWe allow o to contain non-negative rationals while inf(p) * sup(\u03c1) \u2265 0, whereby we don't need to consider in the rule head. Let the predicates in body(r) be R1, R2, ..., Rk according to their reasoning order, with the tuples associated with them being t1, t2, ..., tk in body(r). Since I F, t = \u03c3(body(r)), F' must contain a subset F = {fj | fj = Rj(t';)@lf;,j\u2208 {1, 2, ..., k}}, and for F, \u03c3 and the time point t' who must be in tg - 0, these conditions are met:\n* Each fact f; either has an edb predicate or has birth(fj, II, D) < birth(g, II, D).\n* If Rj belongs to a metric atom \u2295emp Rj (tj), then t' + Qmn = Qfj.t' Qmh = Qf; should hold instead if the operator is .\n* If Rj belongs to a metric atom empRj(tj), then Of, is punctual and of; \u2208 t' + @mr\u00b7 Qf; \u2208 t' Omn should hold instead if the operator is .\n* If Rj and Rj-1 belongs to a metric atom Rj (tj)Semp Rj-1(tj-1), then Ofj-1 is punctual and @fj-1 Et' - @mn and of; = Link(@fj-1, {t'}). Of5-16 t' + @mp should hold instead if the operator is U.\n* \u03c3(to) = tg, \u03c3(b\u03c5(to, Yo)) = bt(tg, Yo) and o(tj) = t';, \u2200j \u2208 {1, 2, ..., k}\nSince gm has a birth round regarding (\u03a0', D') by the induction hypothesis, we only need to prove all facts in F are either in edb or has a birth round regarding (\u03a0', D'). The cases where Rj is an edb predicate are trivial, whereby we only need to consider when it's an idb predicate. We prove this inductively on index j of the facts in F.\n* Basis: if R\u2081 is an idb predicate, for the first metric atom M1, the rule r1 generated for R1(t1) by lines 12-18 in Algorithm 1 contains only @m_S% (bv (to, 0)) in the body and has relational atom m_R\u00b9 (s1) in the head for another adornment 1, where s\u2081 = bu(t1, 1). Since I{gm},t' = m_S% (bu (to, yo)), we have I'birth(gm,I',D'), t' = \u03c3(body(r1)) and Ibirth(gm, II', D')+1, t' = \u03c3(head(r1)). Because I'birth(gm,I',D')+1,t' = (head(r1)), interpretation Ibirth(gm,I',D')+1 must satisfy a fact 91 m_R11 (tg1)@@g\u2081 such that \u03c3(s1) = tg\u2081 and according to Algorithm 3 which determines head(r1),\n091 = t' + @m1, if M\u2081 is \u2295em\u2081 R1(t1), em\u2081 R1(t1) or R2(t2) Uem, R1(t1). In this case, since Of1 t' + @m1, we have Of1\u2286 091\n091 = t' - @m1, if M\u2081 is \u66f0em\u2081 R1(t1), em\u2081 R1(t1) or R2(t2) Sem\u2081 R1(t1). Similarly, we can deduce Of1091\nBecause tg1 = \u03c3(81) = \u03c3(\u03bf\u03c5(1,1)) = bt(1, 1) and of1091, I'birth(gm,I',D')+1 satisfies m_R1\u00b9 (bt(t1,Y1))@lf\u2081, and we have that for each fact f\u2081 = R1(t1)@t with t\u2081 \u20ac Of\u2081, there is a fact fm\u2081 = m_R11 (bt(t\u2081, \u00a51))@t1, for which birth(f'm, I', D') \u2264 birth(gm, \u03a0', D') + 1. Since"}]}