{"title": "Leveraging Member-Group Relations via Multi-View Graph Filtering for Effective Group Recommendation", "authors": ["Chae-Hyun Kim", "Yoon-Ryung Choi", "Jin-Duk Park", "Won-Yong Shin"], "abstract": "Group recommendation aims at providing optimized recommendations tailored to diverse groups, enabling groups to enjoy appropriate items. On the other hand, most existing group recommendation methods are built upon deep neural network (DNN) architectures designed to capture the intricate relationships between member-level and group-level interactions. While these DNN-based approaches have proven their effectiveness, they require complex and expensive training procedures to incorporate group-level interactions in addition to member-level interactions. To overcome such limitations, we introduce Group-GF, a new approach for extremely fast recommendations of items to each group via multi-view graph filtering (GF) that offers a holistic view of complex member-group dynamics, without the need for costly model training. Specifically, in Group-GF, we first construct three item similarity graphs manifesting different viewpoints for GF. Then, we discover a distinct polynomial graph filter for each similarity graph and judiciously aggregate the three graph filters. Extensive experiments demonstrate the effectiveness of Group-GF in terms of significantly reducing runtime and achieving state-of-the-art recommendation accuracy.", "sections": [{"title": "1 Introduction", "content": "Group recommender systems aim to provide precise recommendations tailored to a collection of members rather than individuals [2, 5, 9, 13, 16]. In group recommendations, capturing the intricate relationships between member-level and group-level interactions is essential for accurate group recommendations [2, 16]. For example, the preferences of a travel group on a trip platform may differ from individual members' preferences, as shown in Figure 1. In this context, it is of paramount importance to effectively integrate such dissimilar preferences for accurate group recommendations [1, 8]. In other words, treating both member-level and group-level interactions separately can result in a failure to account for the nuanced dynamics that occur within group contexts [9, 18, 19].\nTo jointly deal with both member-level and group-level interactions, existing approaches often resort to hypergraph-based [9, 16, 18, 19] and self-supervised learning (SSL)-based [13, 16, 21] methods. However, the aforementioned methods often involve complex hypergraph modeling or expensive model training costs for SSL, which can hinder their responsiveness to rapidly changing member preferences.\nTo address these practical challenges, we propose Group-GF, the first attempt at group recommendations built upon graph filtering (GF). Our Group-GF method is composed of 1) the construction of three item similarity graphs exhibiting different viewpoints and 2) the optimal design of distinct polynomial graph filters that are hardware-friendly without costly matrix decomposition. More"}, {"title": "2 Preliminary", "content": "We provide fundamental principles of GF. Suppose a weighted graph G = (V, E) represented by an adjacency matrix A \u2208 R^{|V|\u00d7|V|}. A d-dimensional vector x \u2208 R^{|V|} is a graph signal, where x_i represents the signal strength of node i in x. The graph Laplacian L of G is L = D \u2013 A, where D = diag(A1). The smoothness measure S(x) is expressed as [14, 15]:"}, {"title": "2.1 Graph Filtering", "content": "S(x) = \\sum_{i,j} A_{i,j} (x_i - x_j)^2 = x^T L x.\nSmaller values of S(x) indicate that the signal x is smoother on the graph. By the eigen-decomposition L = U\u039bU^T, we can formally define the graph Fourier transform (GFT) of a graph signal x as x = U^T x, where U \u2208 R^{|V|\u00d7|V|} is the matrix whose i-th column is the eigenvector u_i of L. Here, the signal x is considered smooth if the dot product of the eigenvectors corresponding to smaller eigenvalues of L is high. Given a graph Laplacian matrix L, a graph filter H(L) \u2208 R^{|V|\u00d7|V|} is given by\nH(L) = Udiag(h(\\lambda_1),\u00b7\u00b7\u00b7, h(\\lambda_{|v|}))U^T,\nwhere h: C\u2192 R is the frequency response function that maps eigenvalues {\\lambda_1,\u00b7\u00b7\u00b7, \\lambda_{|v|}\\} of L to {h(\\lambda_1),\u00b7\u00b7\u00b7, h(\\lambda_{|v|})\\}. The convolution of a graph signal x with a graph filter H(L) is then represented as H(L)x = Udiag(h(\u03bb\u2081),\u00b7\u00b7\u00b7, h(d|v|))UTx."}, {"title": "2.2 Problem Definition", "content": "Consider the sets of members, items, and groups, denoted by U = {u_1, u_2, ..., u_{|U|}\\}, I = {i_1, i_2, \u00b7 \u00b7 \u00b7, i_{|I|}\\}, and G = {g_1, g_2, ..., g_{|G|}\\}, respectively. Each member and group interacts with various items, reflecting their own preferences. Among U, I, and G, there are two types of interactions: 1) interactions between members and items and 2) interactions between groups and items. We denote the member-item interaction matrix by R_u \u2208 R^{|U|\u00d7|I|} and the group-item interaction matrix by R_g \u2208 R^{|G|\u00d7|I|}, where r_{ui} = 1 (resp. r_{gi} = 1) if member u (resp. group g) is associated with item i, and r_{ui} = 0 (resp. r_{gi} = 0) otherwise. The t-th group G_t = {u_1, u_2, \u2026\u2026\u2026, u_s, \u2026\u2026\u2026, u_{|G_t|}\\} \u2208 G consists of a set of members in the"}, {"title": "3 Methodology", "content": "In this section, we elaborate on Group-GF, a method that judiciously performs multi-view GF to model complex interactions between members and groups. The schematic overview of Group-GF is shown in Figure 2."}, {"title": "3.1 Augmented Graph Construction", "content": "Standard GF-based recommendation methods [4, 6, 10, 11, 14, 17] for the individual recommendation task begin with constructing a graph structure, where each item is represented as a node and the similarities between items are modeled as edges. The construction process is formulated as follows:\nP = \\tilde{R}^T \\tilde{R}; \\tilde{R} = D^{-1/2} R D^{-1/2},\nwhere the operator || denotes the concatenation of matrices, and R\u2208 R^{|U|X|I|} is the member-item interaction matrix; R is the normalized interaction matrix; Du = diag(R1) and D\u2081 = diag(1^TR); and P is the adjacency matrix of the item-item similarity graph. However, constructing separate graphs for member-item and group-item interactions overlooks the member-group relations. Thus, we present a nontrivial strategy that constructs augmented item similarity graphs using a member-group relation matrix M\u2208 R^{|G|\u00d7|U|}, where M_{ij} = 1 indicates that member j belongs to group i, and M_{ij} = 0 otherwise. We first augment R_u and R_g by concatenating the member-group relation matrix M:\n\\tilde{R_u} = R_u||M^T; \\tilde{R_g} = R_g||M,\nwhere the operator || denotes the concatenation of matrices, and \\tilde{R_u} \u2208 R^{|U|\u00d7(|I|+|G|)} and \\tilde{R_g} \u2208 R^{|G|\u00d7(|1|+|U|)} are the augmented member-level and group-level interaction matrices, respectively. It is worth noting that this augmentation allows us to jointly leverage the information of member-group relations as well as member-level interactions and group-level interactions for GF. Next, we construct two augmented similarity graphs as follows:\nP_u = \\tilde{R_u}^T \\tilde{R_u}; \\tilde{R_u} = D_u^{-0.5} R_u D_I^{0.5},\nP_g = \\tilde{R_g}^T \\tilde{R_g}; \\tilde{R_g} = D_G^{0.5} R_g D_I^{-0.5},\nwhere P_u \u2208 R^{(|I|+|G|)\u00d7(|I|+|G|)} and P_g \u2208 R^{(|I|+|U|)\u00d7(|I|+|U|)} represent the member-level and group-level item similarity graphs,"}, {"title": "3.2 Unified Graph Construction", "content": "We further construct a unified item similarity graph P_{uni} to comprehensively grasp the relationships among items. This unified graph enables us to perceive the extensive preference of items by simultaneously taking into account both member-item and group-item interaction matrices. We begin with concatenating R_g and R_u along the item dimension:\nR_{uni} = [R_u^T R_g^T]^T \u2208 R^{(|G|+|U|)\u00d7I},\nwhich effectively combines all possible interactions at the item level. Next, we normalize R_{uni} to obtain \\tilde{R_{uni}}, then compute the graph as:\nP_{uni} = \\tilde{R_{uni}}^T \\tilde{R_{uni}}; \\tilde{R_{uni}} = D_{uni}^{0.5} R_{uni} D_{I_{uni}}^{-0.5},\nwhere D_{uni} = diag(R_{uni}1) and D_{I_{uni}} = diag(1^T R_{uni}). Finally, we also adjust the unified item similarity graph using the Hadamard power as follows:\nP_{uni} = P_{uni}^s.\nThis process results in the unified item similarity graph P_{uni}, capturing comprehensive relationships from an item-centric view derived from both group-level and member-level interactions."}, {"title": "3.3 Filter Design", "content": "We address the design principle of our multi-view GF in Group-GF based on the constructed item similarity graphs. To this end, we investigate the eigenvalue (i.e., the graph frequency) distributions of the three item similarity graphs P_g, P_u, and P_{uni}. As illustrated in Figure 3, the eigenvalue distributions of P_g, P_u, and P_{uni} tend to"}, {"title": null, "content": "f_1 (P_u) = \\sum_{k=1}^{K_u} a_kP_u^k; f_2 (P_g) = \\sum_{k=1}^{K_g} b_kP_g^k; f_3 (P_{uni}) = \\sum_{k=1}^{K_{uni}} c_kP_{uni}^k,\nwhere f_1 (P_u), f_2(P_g), and f_3 (P_{uni}) are the polynomial graph filters for P_u, P_g, and P_{uni}, respectively; K_u, K_g, and K_{uni} are the maximum order of polynomial filters for P_u, P_g, and P_{uni}, respectively; and a_k, b_k, and c_k are polynomial coefficients. As an example, we can use a polynomial graph filter f_2(P_g) = 2P_g \u2013 P_g^2 to find the graph filter whose frequency response function is h(\u03bb) = 1 \u2013 \u03bb\u00b2 [11, 12].\nDue to the fact that the member-level and group-level interactions behave differently depending on group recommendation scenarios [2, 5, 9], Group-GF optimally aggregates the three graph filters f_1 (P_u), f_2(P_g), and f_3 (P_{uni}) according to\ns_g = r_g((1 \u2212 \u03b1 \u2212 \u03b2) f_1(P_u) + \u03b1f_2(P_g) + \u03b2f_3(P_{uni})),\nwhere r_g is the g-th row of R_g, representing the graph signal for group g; s_g is the predicted score for group g; and \u03b1 and \u03b2 are the parameters that balance among the three types of polynomial graph filters. The final prediction optimally combines the preferences propagated through member-level, group-level, and unified interactions via hyperparameter tuning on the validation set.\nNext, let us turn to providing a theoretical foundation for Group-GF, which bridges between multi-view GF and optimization via smoothness regularization. We consider smoothness regularization in the context of group recommendation, because the preferences of individual members and the preferences of the belonging group as a whole are interconnected within the graph structure. The smoothness regularization assures that similar nodes (i.e., items) in each graph have similar preference scores, leading to more accurate recommendations.\ns_{g} = arg min ||s_{g} - r_{g}||^2 + \u03bbs_{g}^T ((1 \u2212 \u03b1 \u2212 \u03b2)L_u + \u03b1L_g + \u03b2L_{uni}) s_{g}\nwhere \u03bb > 0 is a regularization parameter and 0 < \u03b1, \u03b2 < 1 are balancing parameters."}, {"title": "4 Experimental Evaluation", "content": "Datasets. We adopt three widely used benchmark datasets on group recommendations [2, 9, 16, 20], including CAMRa2011, Mafengwo, and Douban. Table 1 summarizes the statistics of the three datasets. We note that the size of group recommendation datasets are inherently smaller in scale than that of canonical (user) recommendation datasets, reflecting their focus on collective interactions rather than individual-level data.\nCompetitors. We compare Group-GF with eight state-of-the-art group recommendation methods, including DNN-based (NCF [7]), attentive aggregation-based (AGREE [2]), hypergraph-based (HyperGroup [5], HCR [9], and ConsRec [16]), and SSL-based (GroupIM [13], S2-HHGR [21], and CubeRec [3]) methods.\nEvaluation protocols. Following the evaluation protocol outlined in [9, 16], we adopt performance metrics such as the hit ratio (HR@k) and the normalized discounted cumulative gain (NDCG@k), where k is set to 10 by default, due to the space limitation.\nImplementation details. In our experiments, rather than exhaustively searching for polynomial coefficients, we use the polynomial graph filters presented in [11] (i.e., pre-defined polynomial coefficients in Eq. (10)) for efficient filter search, because it was empirically confirmed that exhaustive search leads to only negligible gains in recommendation accuracy. Group-GF is basically training-free; however, similarly as in training-based recommendation methods, it adjusts hyperparameters on the validation set. All experiments are carried out with the same device: Intel (R) 12-Core (TM) i7-9700K CPUs @ 3.60 GHz and GPU of NVIDIA GeForce RTX A6000.\nAdditional experiments. Further experimental results, including 1) scalability, 2) analysis on different group sizes, 3) comparison with canonical recommendation methods, and 4) sensitivity analysis, as well as the reproducibility code, can be found at https://github.com/ chaehyun1/Group-GF."}, {"title": "4.2 Runtime Analysis", "content": "Table 2 presents the runtime of Group-GF compared to the four DNN-based competitors that perform well (AGREE, GroupIM, CubeRec, and ConsRec) on the three benchmark datasets. Here, the"}, {"title": "4.3 Recommendation Accuracy", "content": "The performance of Group-GF and all competitors is summarized in Table 3. Our key observations are made as follows:\n(i) In spite of not requiring any training, Group-GF consistently outperforms state-of-the-art group recommendation methods across all datasets and metrics. Specifically, on the Douban dataset, it achieves up to 16.4% higher HR@10 than that of the best competitor. This is due to Group-GF's ability to effectively integrate member and group information while capturing complex member-level, group-level, and unified interactions.\n(ii) In contrast to early-developed methods such as AGREE, techniques based on hypergraph structures and SSL show comparatively competing performance. This implies the importance of modeling the complex interactions between each group and its belonging members in capturing group preferences."}, {"title": "4.4 Ablation Study", "content": "To assess the contribution of each component in Group-GF, we perform an extensive ablation study alongside four variants, each"}, {"title": "5 Conclusions and Future Work", "content": "We addressed an unexplored yet important challenge of designing GF methods for group recommendations. To this end, we proposed Group-GF, an innovative group recommendation method via training-free multi-view GF, which is capable of jointly leveraging all available interactions. In Group-GF, we showed 1) how to construct two augmented item similarity graphs and one unified item similarity graph, which manifest different viewpoints for GF, and 2) how to efficiently and optimally discover each of distinct polynomial graph filters and aggregate them. Through systematic evaluations and analyses, we demonstrated (a) the remarkable computational efficiency of Group-GF, (b) the superior recommendation accuracy over state-of-the-art methods in various circumstances, and (c) the theoretical finding that supports the model's performance and interpretability. As the three similarity graphs P_u, P_g, and P_{uni} need to be loaded into memory, which is memory-demanding, potential avenues of our future research include the design of a memory-efficient and scalable GF method for large-scale group recommendation scenarios."}]}