{"title": "A Faster Branching Algorithm for the Maximum k-Defective Clique Problem", "authors": ["Chunyu Luo", "Yi Zhou", "Zhengren Wang", "Mingyu Xiao"], "abstract": "A k-defective clique of an undirected graph G is a subset of its vertices that induces a nearly complete graph with a maximum of k missing edges. The maximum k-defective clique problem, which asks for the largest k-defective clique from the given graph, is important in many applications, such as social and biological network analysis. In the paper, we propose a new branching algorithm that takes advantage of the structural properties of the k-defective clique and uses the efficient maximum clique algorithm as a subroutine. As a result, the algorithm has a better asymptotic running time than the existing ones. We also investigate upper-bounding techniques and propose a new upper bound utilizing the conflict relationship between vertex pairs. Because conflict relationship is common in many graph problems, we believe that this technique can be potentially generalized. Finally, experiments show that our algorithm outperforms state-of-the-art solvers on a wide range of open benchmarks.", "sections": [{"title": "1 Introduction", "content": "Finding cohesive subgraphs is a fundamental task in many real-world network applications, such as community detection in social networks [2, 1, 13], protein complex mining in biological networks [30, 16], and statistical analysis in financial networks [6, 5]. A recent study in [21] also reveals a potential application of finding cohesive graphs in the design of Graph Neural Network [21]. The clique, which requires an edge for every pair of vertices, is a basic model for representing cohesive subgraphs. Additionally, the study of algorithms for the maximum clique problem, that is, finding the maximum clique from a given graph, has made significant progress both theoretically and practically in recent years. For example, the best-known time complexity for the exact computation of the maximum clique is $O^* (1.20^n)$ [28]; Practical algorithms such as MC-BRB [7] and MoMC [20] can solve massive sparse or hard dense graphs in seconds. However, the clique model itself is not a preferred choice for real-world applications. Due to the existence of noises and faults in many scenarios, the constraint that requires all possible relations to exist in the community may be too restrictive [11]. Therefore, various clique relaxations have been formulated in the literature, such as k-plex [25, 26], k-clique [3] and k-defective clique [30, 14, 8, 18]. This paper focuses on the k-defective clique model, a subset of vertices that allows the induced subgraph missing at most k edges"}, {"title": "2 Preliminary", "content": "In an undirected graph G = (V, E) where V is the vertex set and E is the edge set, $N_G(u)$ denotes the set of vertices adjacent to $u \u2208 V$ in G (when the context is clear, we use N(u) instead), G[S] denotes the subgraph induced by $S \u2286 V$, CN(S) denotes the set of vertices in G that are adjacent to every vertex in S, that is, $\\bigcap_{u \\in S} N(u)$. The complement graph of G is denoted as $\\overline{G}$. Any two distinct vertices in G are adjacent if and only if they are not adjacent in $\\overline{G}$. Given a positive integer n, we use [n] to denote the index set {1, 2, ..., n}. A clique in G = (V, E) is a set S \u2286 V where all vertices in S are pairwise adjacent in G. An independent set is a set S \u2286 V where no two vertices in S are adjacent in G. Given a non-negative integer k, a set S \u2286 V is a k-defective clique if the subgraph G[S] contains at least ${|S| \\choose 2} \u2212 k$ edges. Equivalently, S is a k-defective clique in graph G if the complement graph $\\overline{G}[S]$ has at most k edges. If S is a k-defective clique in G, then any subset of S is also a k-defective clique in G [15]. For any subset S \u2286 V, we define $r(S) = k \u2212 |E(G[S])|$ as the gap between k and the number of edges in G[S]. If r(S) \u2265 0, then S is a k-defective clique."}, {"title": "3 An Exact Decompose-and-Branch Algorithm", "content": "This section introduces a branching algorithm with a better exponential-time bound than existing ones. We first introduce the notion of the k-defective set.\nDefinition 2 (k-Defective Set). A D \u2286 V is a called a k-defective set of G if \u2200v \u2208 D, |N(v) \u2229 D| < |D| \u2212 1, and there are at least ${|D| \\choose 2} - k$ edges in G[D].\nIn general, a k-defective set D is also a k-defective clique, except that every vertex in D is nonadjacent to at least one other vertex in D. It is easy to see that the size of any k-defective set is no more than 2k.\nFor any k-defective clique Q, we denote D(Q) as the maximal k-defective set in Q, that is, we cannot find another vertex $v \u2208 Q$ such that D(Q) \u222a {v} is still a k-defective set. Our algorithm is based on the observation that Q can be partitioned into the maximal k-defective set D(Q) \u2286 Q and a clique C(Q) \u2286 Q. We also observe that C(Q) \u2286 CN(D(Q)), that is, \u2200u \u2208 D(Q), C(Q) \u2286 N(u). If D(Q) is empty, then Q is a clique in G. Examples of this observation are given in Fig. 1."}, {"title": "3.1 The Branching Algorithm", "content": "By the above observation, our approach is outlined below. We enumerate all k-defective sets D from V. For any non-empty k-defective set D, we compute the maximum clique $C^*$ within the subgraph induced by CN(D). The maximum k-defective clique is the largest one among all candidates D\u222aC*.\nFor clarity in the description of the algorithm, we define the general k-defective clique problem.\nDefinition 3 (General k-Defective Clique Problem). Given an instance I = (G = (V, E), P, R) where G is the graph, P and R are two disjoint subsets of V, find the maximum k-defective clique Q* such that P \u2286 D(Q*) \u2286 P \u222a R and $Q^* \u2286 V$."}, {"title": "3.2 The Whole Decompose-and-Branch Algorithm", "content": "We further investigate the graph decomposition rule in the algorithm. The rule reduces the original input instance I = (G, \u00d8, V) to instances $I_1, ..., I_n$ such that the solution of I is the maximum size in these $w_k(I_i)$.\nBecause the rule is defined with an order of set V, let us first denote the order as $v_1, v_2, ..., v_n$. We also denote $N(v_i) \u2229 {v_{i+1},..., v_n}$ as $N^+(v_i)$, and $(\\bigcup_{v \\in N^+(v)} N(v)) \u2229 {v_{i+1}, ..., v_n} \\setminus N^+(v_i)$ as $N^{2+}(v_i)$. ($N^{2+}(v_i)$ is a subset of vertices that rank after $v_i$, and each $u \\in N^{2+}(v_i)$ is adjacent to at least one vertex in $N^+(v_i)$). We say that $N^{2+}(v_i)$ is two-hop adjacent to $v_i$ with respect to the given order.\nLemma 3. Give an instance I = (G, \u00d8, V) and an order of V which is denoted by $v_1, ..., v_n$. Then $w_k(I) = max_{i=[n]}(w_k(I_i), w_k(I_i'))$ where $I_i = (G[{v_i} \u222a N^+(v_i) \u222a N^{2+}(v_i)], {v_i}, N^+(v_i) \u222a N^{2+}(v_i))$ and $I_i' = (G[{v_i} \u222a N^+(v_i)], \u00d8, N^+(v_i))$.\nTo understand this lemma, one can think that in a non-trivial k-defective clique, the length of shortest path of any two vertices is bounded by 2. So we can find the largest k-defective clique from all diameter-two bounded subgraphs."}, {"title": "4 Exploring Tighter Upper Bound", "content": "We investigate the upper bounding rule to prune the branching algorithm. Given an instance I = (G = (V, E), P, R), the bounding rule introduces an upper bound on $w_k(I)$. Suppose that there is currently a best known lower bound, say lb. (Initially, lb = |Q| where Q is found using a linear-time heuristic.) In the branching algorithm, if the upper bound of I is not greater than lb, we can claim that there is no hope of finding a k-defective clique larger than lb in I, and thus we can stop the search. This is the principle of bounding in branch-and-bound algorithms."}, {"title": "4.1 Revisiting the Existing Upper Bounds", "content": "We first review the packing bound and coloring bound rules that are independently proposed in [14] and [10].\nBefore that, in an instance I = (G, P, R), we define the weight of $u \u2208 V$ as $w(u) = |P| \u2212 |N(u) \u2229 P|$. The w(u) can be seen as the number of vertices that are not adjacent to u in P. Clearly, we can move some vertices of V \\ P to P. If the sum of weight does not exceed r(P), P is still a k-defective clique. This is the essence of packing bound.\nBounding Rule 1 (Packing Bound [14]). Assume that the vertices in V \\ P are sorted in non-decreasing order of weight w(v), say $v_1, ...., v_{|V \\setminus P|}$. Then, $|P| + i$ is an upper bound of $w_k(I)$ where i is the largest number that $\\sum_{j=1}^{i} w(v_j) \\le k$.\nThe coloring bound depends on a graph coloring partition of V \\ P. That is to say, V \\ P should be partitioned into x non-disjoint independent sets before computing the coloring bound.\nBounding Rule 2 (Coloring Bound [10]). Assume V \\ P is partitioned into x non-disjoint independent sets $\u03a0_1, ..., \u03a0_\u03c7$. Then $|P| + \\sum_{i=1}^{x} min(\\lceil{\\frac{1+\\sqrt{8k+1}}{2}}\\rceil, |\u03a0_i|)$ is an upper bound of $w_k(I)$.\nThis bound holds because at most $\\lceil{\\frac{1+\\sqrt{8k+1}}{2}}\\rceil$ vertices in an independent set can be contained in the same k-defective clique.\nRecently, a Sorting bound was proposed in [8], and another partition-based bound called Club was given in [18]. These bounding rules are more complicated than the packing and coloring bounds. In the following, we will investigate the conflict relationship of the vertices and design a new bounding framework that hybrids the packing, coloring bounds and the conflict relationship."}, {"title": "4.2 A New Upper Bound Based on Packing, Coloring and Conflict Vertices", "content": "Let us first introduce conflict vertices.\nDefinition 4 (Conflict Vertices). Give an instance I = (G, P, R) and a lower bound lb, two different vertices {u, v} ($u, v \u2208 V$) are conflict vertices if u and v cannot be in the same k-defective clique of size larger than lb.\nThere are several rules to identify the conflict vertices for a given instance. So far, we use the following rules.\n1. If u \u2208 R, v \u2208 V \\ (P \u222a R) and {u, v} \u2209 E, then {u, v} are conflict vertices."}, {"title": "5 Experiments", "content": "In this section, we evaluate our algorithms and bounds empirically. Our algorithm is written in C++11 and compiled by g++ version 9.3.0 with the -Ofast flag. All experiments are conducted on a machine with an Intel(R) Xeon(R) Gold 6130 CPU @ 2.1GHz and a Ubuntu 22.04 operating system. Hyper-threading and turbo are disabled for steady clock frequency.\nWe implement our DnBk branching algorithm that uses PackColorConf to upper bound the solution (and thus prune branches).\nWe empirically compare DnBk with the state-of-the-art algorithms kDC [8], KDClub [18]. Three real-world datasets are used as benchmark graphs, the same as in [8, 14]. Because the kDC-2 codes [9] are not publicly available, we only partially compare this algorithm using the data in the paper. This is reported in Section 6.2 in the supplementary file.\nWe record the computation time for running an algorithm on a graph instance for a specific k from {1, 5, 10, 15, 20}, with a cutoff time 10800 seconds (3 hours) for each test. This configuration is the same as that in [8]. The recorded time excludes the I/O time of loading the graph instance from the disk to the main memory. Because the problem we solve is to find the maximum k-defective clique of size larger than or equal to k+2, we omit instances whose maximum k-defective clique size is smaller than k + 2 for each k."}, {"title": "5.1 Overall Performance", "content": "In Fig. 5, we show the number of solved instances within different time frames. The codes for KDBB [14] are not available because the authors cannot provide them. So, it is not included in the figure. In fact, both kDC and KDClub outperform KDBB in their reports. Our DnBk also solves all instances that were solved in [14] but consumes much less time.\nFrom Fig. 5, DnBk solves more instances or at least as many instances as kDC and KDClub in 3 hours for all sets. For small k values such as 1 or 5, these algorithms can solve almost all instances of DIMACS10&SNAP and Socfb to optimal in 3 hours, but DnBk still solves more in a shorter time frame. For k = 10, 15 and 20, DnBk clearly outperforms kDC and KDClub. Specifically, we find that DnBk closes 3,2,5,8 and 6 NDR instances that were not solved by other algorithms for k = 1, 5, 10, 15 and 20, respectively."}, {"title": "5.2 The Effect of the Upper Bound", "content": "We empirically evaluate the upper bounds by comparing DnBk (which uses packing-and-coloring bound with conflict pairs) with the following algorithms.\n- DnBkp, the DnBk that uses the packing bound, see Bounding Rule 1.\n- DnBkc, the DnBk that uses the coloring bound, see Bounding Rule 2.\n- DnBks, the DnBk that uses the Sorting Bound in [8].\n- DnBkclub, the DnBk that uses the Club bound in [18].\nDue to the space limit, we show the computation time and the nodes of each algorithm for 12 benchmark graphs in Tab. 1. Here, the number of nodes refers to the number of branches in the search tree produced by the algorithm. We can see that for all instances, DnBk has fewer nodes than DnBks, which in turn has fewer nodes than DnBkp and DnBkc. This matches the dominance relations that we conclude in Fig. 4. For instances like rt-retweet-cralw and tech-as-skitter with k=1, all algorithms can solve them within 10 seconds, the other variant could be faster than DnBk. This shows that the time overhead of computing the bound only affects easy instances. The number of nodes is fewer than that of DnBkclub in most cases, implying that our new bound is empirically better than Club. Also, DnBk is faster than this algorithm."}, {"title": "6 Conclusion", "content": "In the paper, we discussed both theoretical and practical aspects of solving the maximum k-defective clique problem. We studied a branching algorithm that has a better exponential time complexity than the existing ones when k is constant. We also investigated a new bound that hybrids existing two bounds with the idea of conflict vertices. The tightness of the bounds are analyzed based on the dominance relationships. We note that the conflict relationship of vertices, which was first formalized in this paper, exists in many graph search problems, such as the maximum clique problem, and thus can be potentially extended in the future."}, {"title": "Appendix", "content": "1 Structure of the Appendix\n- In Section 2, we describe the heuristic algorithm used in BnBk.\n- In Section 3, we prove the correctness of Lemma 2 and Lemma 3. Specifically, we prove that the decomposition algorithm does not miss the optimal solution.\n- In Section 4, we add the missing proofs for the upper bounding rules and algorithms in the paper. Specifically, in Section 3.1, we show the correctness of all conflict rules in the paper. In Section 3.2, we show the correctness of the pakcing, coloring with conflict bounding rules. In Section 3.3, we show that DPBound solve the OPT problem without conflict constraint.\n- In Section 5, we prove the dominance relation among the proposed bounds and existing bounds.\n- In Section 6, we provide complete experimental results, including the comparison of different variants on the whole benchmark and detailed comparison among DnBk, kDC-2 and -RR3."}, {"title": "2 Heuristic Algorithm for Finding Initial Solution in DnBk", "content": "The Algorithm 1 shows the heuristic algorithm for building the initial solution. Note that the time complexity of the heuristic algorithm is O(|V|+|E|)."}, {"title": "3 Proof to Lemma 2 and Lemma 3", "content": "Lemma 1. Given an instance I = (G, P, R) where P\u2260 0, the branching algorithm finds the maximum k-defective clique of I in time O(|R|2km) where m = |CN(P)| and yc is the base of the exponential factor in the time complexity for maximum clique algorithm.\nProof. It is known that the branching algorithm produces a depth-first tree. Also, the running time of the algorithm is equal to the time to generate all the tree nodes. Regarding our branching algorithm, the tree nodes are partitioned into intermidate nodes and leaf nodes."}, {"title": "4 Missing Proof for the Bound and Algorithms", "content": "4.1 Correctness of the Five Rules for Identifying Conflict Vertices\nWe show that the following rules are correct for identifying conflict pairs.\n1. If u \u2208 R, v \u2208 V \\ (P \u222a R) and {u, v} \u2209 E, then {u, v} are conflict vertices.\n2. If u, v \u2208 V \\ (P \u222a R) and {u, v} \u2209 E, then {u, v} are conflict vertices.\n3. If u, v \u2208 V \\ P and r(P\u222a {u, v}) < 0, then {u, v} are conflict vertices.\n4. If u, v \u2208 V \\ P, {u, v} \u2208 E and |NG(u) \u2229 NG(v) \u2229 V \\ P| \u2264 lb - (|P|+r(P) \u2013 w(u) \u2013 w(v) + 2), then {u, v} are conflict vertices.\n5. If u, v \u2208 V \\ P, {u, v} \u2209 E and | NG(u) \u2229 NG(v) \u2229 V \\ P| \u2264 lb - (|P|+r(P) \u2013 w(u) \u2013 w(v) + 1), then {u, v} are conflict vertices.\nProof. The first two conditions hold because, in a k-defective clique, any vertex in the clique set should be adjacent to all other vertices. The third condition is satisfied because P \u222a {u, v} is not a k-defective clique. Due to the Hereditary Property, any k-defective clique subsumes P cannot contain u and v at the same time.\nNow, we show the correctness of the fourth and fifth rules. We denote V\\(P\u222a{u, v}) as T and T can be partition into T \u2229 NG(u) \u2229 NG(v) and T \\ (NG(u) \u2229 NG(v)). For P\u222a {u, v}, we can choose at most r(PU {u, v}) vertices from T \\ (NG(u) \u2229 NG(v)) since every vertex in T \\ (NG(u) \u2229 NG (v)) is not adjacent to at least one vertex in {u, v}. Therefore, the upper bound of PU {u, v} is PU {u, v}|+ |NG(u) \u2229 NG(v) \u2229 T| + r(PU {u, v}) = |P| + 2 + |NG(u) \u2229 NG(v) \u2229 T| + r(PU {u, v}). Therefore, if {u, v} \u2209 E, then r(PU{u, v}) = r(P) \u2013 w(u) \u2013 w(v) \u2013 1; If {u, v} \u2208 E, then r(PU {u, v}) = r(P) \u2013 w(u) \u2013 w(v). This further indicates that"}, {"title": "4.2 Proof of Bound Rule 3", "content": "Bounding Rule 1 (The Packing, Coloring with Conflict Bounding Rules). Given an instance I = (G, P, R) and a lower bound lb, assume that V \\ P is partitioned into x independent sets \u03a01, ..., \u03a0\u03c7. For any u, v \u2208 V \\ P, conflict(u, v) = 1 if {u, v} are conflict vertices and conflict(u, v) = 0 otherwise. The optimal objective value of the optimization problem described in the following is an upper bound of $w_k(I)$.\nProof. We prove the optimal k-defective clique of instance I satisfies all constraints and can provide a feasible solution of optimization problem OPT. Assume that $Q^*$ is an optimal k-defective clique and $|Q^*| > |P|$. Then P \u2286 D(Q*) \u2286 P \u222a R and $Q^* \u2286 V \\ P$. Let $S_i = Q^* \u2229 \u03a0_i$ for any $i \u2208 [x]$. Due to the definition of k-defective clique, we have\nwhere the first factor in the left-hand-side is the number of edges in each $G[S_i]$, the second factor is the number of missing edges between each $S_i$ and P and the third factor is the number of edges in G[P]. Reorganizing the inequality, we have\nThis indicates that S satisfies the constraint (2). By the definition of conflict vertices, every pair of vertices in Q* is not conflict, so for \u2200u, v \u2208 Si, \u2200i \u2208 [x] we have conflict(u, v) = 0 then the constraint (3) is satisfied. Therefore, $|P| + \\sum_{i=1}^{x} |S_i| = |Q^*|$ is a feasible solution to the OPT So the optimal objective value of the Optimiation Problem OPT is an upper bound of Q*."}, {"title": "4.3 Proof for Correctness of DPBound Algorithm", "content": "We show that the DPBound algorithm solves the optimization problem OPT without the constraint (3), i.e., the conflict constraints.\nProof. We show that in the first two steps, the algorithm actually computes the optimal value for maxvi\u2208[x],Si\u2286n\u2081 |P|+ \\sum_{i=1}^{x}|S_i| under the constraint (1) in the optimization problem. The key point of the proof is that given an i < [x] and an r < r(P), the t(i, r) that we computed in step 1, is the objective value of the following subproblem."}, {"title": "5 Proofs to the Dominance Relations Between Different Bounds", "content": "We first reformulate the sorting [1] and club [4] bounding rules so that they match the context of our description.\nBounding Rule 2 (Sorting bound [1]). Given an instance I = (G, P, R), assume that V \\ P is partitioned into x independent sets \u03a01, \u03a02, ..., \u03a0\u03c7. Then, the following algorithm computes the upper bound for $w_k(I)$.\n1. For each i \u2208 [x], sort the vertices in each \u03a0i in non-decreasing order regarding w(.). Assume the ordering as $v_{i_1}, v_{i_2}, ..., v_{i_{|\u03a0_i|}}$\nThen, for j\u2208 [|\u03a0i|], assign vertex $v_{i_j}$ the weight $w_s(v) = w(v) + j \u2212 1$.\n2. Sort all the vertices in R by non-decreasing order of its weight ws(.). Find the maximum is such that $\\sum_{j=1}^{i_s} Ws (v_j) \\le r(P)$\n3. return |P|+ is as the upper bound"}, {"title": "6 More Statistical Results of Experiments", "content": "6.1 Complete Experiments for Bounds\nDetailed experimental results are given in file data.pdf. Note that for certain k, if the maximum k-defective clique is smaller than k + 2, then the opt is assigned to k + 1. Here we will give the whole performance of the five variants. We first show the results of the five variants in Fig. 1 on all graphs with k = 1,5,15, 20. From Fig. 1, we can see that for all k values DnBk, DnBks and DnBkclub are faster than DnBkp and DnBkc. Moreover, the dominance is become more obvious when k is increasing. When k is relatively small, i.e., k = 1,5, the efficiency of DnBk, DnBks and DnBkclub are almost the same. But when k is large, i.e., k = 15, 20, DnBk outperforms DnBks and DnBkclub and when k = 20 DnBks obviously outperforms DnBkClub. For DnBkp and DnBkc, they cannot dominant each other but DnBkp is slightly better than DnBkc.\n6.2 Comparing to kDC-2 and -RR3\nSince the DnBk performs very similar to -RR3 and kDC-2 in [2], we show the experiment results of these three solvers on the 39 Socfb large social network graphs. The three solvers are listed below.\n- DnBk, the most efficient solver in our paper.\n- kDC-2, the most efficient solver in [2]\n- -RR3, the variant of kDC-2 without Reduction Rule 3 in [2]."}]}