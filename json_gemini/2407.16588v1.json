{"title": "A Faster Branching Algorithm for the Maximum k-Defective Clique Problem", "authors": ["Chunyu Luo", "Yi Zhou", "Zhengren Wang", "Mingyu Xiao"], "abstract": "A k-defective clique of an undirected graph G is a subset of its vertices that induces a nearly complete graph with a maximum of k missing edges. The maximum k-defective clique problem, which asks for the largest k-defective clique from the given graph, is important in many applications, such as social and biological network analysis. In the paper, we propose a new branching algorithm that takes advantage of the structural properties of the k-defective clique and uses the efficient maximum clique algorithm as a subroutine. As a result, the algorithm has a better asymptotic running time than the existing ones. We also investigate upper-bounding techniques and propose a new upper bound utilizing the conflict relationship between vertex pairs. Because conflict relationship is common in many graph problems, we believe that this technique can be potentially generalized. Finally, experiments show that our algorithm outperforms state-of-the-art solvers on a wide range of open benchmarks.", "sections": [{"title": "1 Introduction", "content": "Finding cohesive subgraphs is a fundamental task in many real-world network applications, such as community detection in social networks [2, 1, 13], protein complex mining in biological networks [30, 16], and statistical analysis in financial networks [6, 5]. A recent study in [21] also reveals a potential application of finding cohesive graphs in the design of Graph Neural Network [21]. The clique, which requires an edge for every pair of vertices, is a basic model for representing cohesive subgraphs. Additionally, the study of algorithms for the maximum clique problem, that is, finding the maximum clique from a given graph, has made significant progress both theoretically and practically in recent years. For example, the best-known time complexity for the exact computation of the maximum clique is $O^* (1.20^n)$ [28]; Practical algorithms such as MC-BRB [7] and MoMC [20] can solve massive sparse or hard dense graphs in seconds. However, the clique model itself is not a preferred choice for real-world applications. Due to the existence of noises and faults in many scenarios, the constraint that requires all possible relations to exist in the community may be too restrictive [11]. Therefore, various clique relaxations have been formulated in the literature, such as k-plex [25, 26], k-clique [3] and k-defective clique [30, 14, 8, 18]. This paper focuses on the k-defective clique model, a subset of vertices that allows the induced subgraph missing at most k edges"}, {"title": "2 Preliminary", "content": "In an undirected graph $G = (V, E)$ where V is the vertex set and E is the edge set, $N_G(u)$ denotes the set of vertices adjacent to $u \u2208 V$ in G (when the context is clear, we use N(u) instead), G[S] denotes the subgraph induced by $S \u2286 V$, $CN(S)$ denotes the set of vertices in G that are adjacent to every vertex in S, that is, $N_{u \\in S} N(u)$. The complement graph of G is denoted as $\\overline{G}$. Any two distinct vertices in G are adjacent if and only if they are not adjacent in $\\overline{G}$. Given a positive integer n, we use [n] to denote the index set {1, 2, ..., n}. A clique in $G = (V, E)$ is a set S \u2286 V where all vertices in S are pairwise adjacent in G. An independent set is a set S \u2286 V where no two vertices in S are adjacent in G. Given a non-negative integer k, a set S \u2286 V is a k-defective clique if the subgraph G[S] contains at least $\\binom{|S|}{2} - k$ edges. Equivalently, S is a k-defective clique in graph G if the complement graph $\\overline{G}[S]$ has at most k edges. If S is a k-defective clique in G, then any subset of S is also a k-defective clique in G [15]. For any subset S \u2286 V, we define $r(S) = k \u2212 |E(G[S])|$ as the gap between k and the number of edges in G[S]. If r(S) \u2265 0, then S is a k-defective clique."}, {"title": "3 An Exact Decompose-and-Branch Algorithm", "content": "This section introduces a branching algorithm with a better exponential-time bound than existing ones. We first introduce the notion of the k-defective set."}, {"title": "3.1 The Branching Algorithm", "content": "By the above observation, our approach is outlined below. We enumerate all k-defective sets D from V. For any non-empty k-defective set D, we compute the maximum clique $C^*$ within the subgraph induced by CN(D). The maximum k-defective clique is the largest one among all candidates $D \\cup C^*$. For clarity in the description of the algorithm, we define the general k-defective clique problem."}, {"title": "3.2 The Whole Decompose-and-Branch Algorithm", "content": "We further investigate the graph decomposition rule in the algorithm. The rule reduces the original input instance $I = (G, \u00d8, V)$ to instances $I_1, ..., I_n$ such that the solution of I is the maximum size in these $w_k(I_i)$. Because the rule is defined with an order of set V, let us first denote the order as $v_1, v_2, ..., v_n$. We also denote $N(v_i) \\cap {v_{i+1},..., v_n}$ as $N^+(v_i)$, and $(\\bigcup_{v \\in N^+(v)} N(v)) \\cap {v_{i+1}, ..., v_n} \\setminus N^+(v_i)$ as $N^{2+}(v_i)$. ($N^{2+}(v_i)$ is a subset of vertices that rank after $v_i$, and each $u \\in N^{2+}(v_i)$ is adjacent to at least one vertex in $N^+(v_i)$). We say that $N^{2+}(v_i)$ is two-hop adjacent to $v_i$ with respect to the given order."}, {"title": "4 Exploring Tighter Upper Bound", "content": "We investigate the upper bounding rule to prune the branching algorithm. Given an instance $I = (G = (V, E), P, R)$, the bounding rule introduces an upper bound on $w_k(I)$. Suppose that there is currently a best known lower bound, say lb. (Initially, $lb = |Q|$ where Q is found using a linear-time heuristic.) In the branching algorithm, if the upper bound of I is not greater than lb, we can claim that there is no hope of finding a k-defective clique larger than lb in I, and thus we can stop the search. This is the principle of bounding in branch-and-bound algorithms."}, {"title": "4.1 Revisiting the Existing Upper Bounds", "content": "We first review the packing bound and coloring bound rules that are independently proposed in [14] and [10]. Before that, in an instance $I = (G, P, R)$, we define the weight of $u \u2208 V$ as $w(u) = |P| \u2212 |N(u) \u2229 P|$. The w(u) can be seen as the number of vertices that are not adjacent to u in P. Clearly, we can move some vertices of $V \\setminus P$ to P. If the sum of weight does not exceed r(P), P is still a k-defective clique. This is the essence of packing bound."}, {"title": "4.2 A New Upper Bound Based on Packing, Coloring and Conflict Vertices", "content": "Let us first introduce conflict vertices."}, {"title": "4.2.1 Dynamic Programming without Conflict Constraint", "content": "We propose the following dynamic programming-like algorithm to solve the OPT without considering the conflict constraint."}, {"title": "4.2.2 The Algorithm for Packing, Coloring and Conflict Bounds", "content": "Now, we propose an algorithm to solve OPT such that the packing-and-coloring constraint is satisfied and the conflict constraint is partially satisfied."}, {"title": "4.3 Comparison of Existing Bounding Rules", "content": "We compare the recent bounding rules for the maximum k-defective clique through the domination relations. For a maximize problem, we say that Bounding Rule A dominates Bounding Rule B if, for the same instance, the bound found by A is not larger than that found by B. In Fig. 4, we show the dominance relations among the packing bound [14], coloring bound [10], sorting bound [8], club bound [18] and the bound obtained by PackColorConf. Note that PackColorConf only obtains the upper bound of the OPT problem (Section 4.2.2). We can see that PackColorConf is as good as Sorting bound, which in turn is as good as Coloring and Packing bounds. Due to the heuristic nature of the Club, we only know that it dominates Packing so far."}, {"title": "5 Experiments", "content": "In this section, we evaluate our algorithms and bounds empirically. Our algorithm is written in C++11 and compiled by g++ version 9.3.0 with the -Ofast flag. All experiments are conducted on a machine with an Intel(R) Xeon(R) Gold 6130 CPU @ 2.1GHz and a Ubuntu 22.04 operating system. Hyper-threading and turbo are disabled for steady clock frequency. We implement our DnBk branching algorithm that uses PackColorConf to upper bound the solution (and thus prune branches). 3 We empirically compare DnBk with the state-of-the-art algorithms kDC [8], KDClub [18]. Three real-world datasets are used as benchmark graphs, the same as in [8, 14]. Because the kDC-2 codes [9] are not publicly available, we only partially compare this algorithm using the data in the paper. This is reported in Section 6.2 in the supplementary file."}, {"title": "5.1 Overall Performance", "content": "In Fig. 5, we show the number of solved instances within different time frames. The codes for KDBB [14] are not available because the authors cannot provide them. So, it is not included in the figure. In fact, both kDC and KDClub outperform KDBB in their reports. Our DnBk also solves all instances that were solved in [14] but consumes much less time. From Fig. 5, DnBk solves more instances or at least as many instances as kDC and KDClub in 3 hours for all sets. For small k values such as 1 or 5, these algorithms can solve almost all instances of DIMACS10&SNAP and Socfb to optimal in 3 hours, but DnBk still solves more in a shorter time frame. For k = 10, 15 and 20, DnBk clearly outperforms kDC and KDClub. Specifically, we find that DnBk closes 3,2,5,8 and 6 NDR instances that were not solved by other algorithms for k = 1, 5, 10, 15 and 20, respectively."}, {"title": "5.2 The Effect of the Upper Bound", "content": "Due to the space limit, we show the computation time and the nodes of each algorithm for 12 benchmark graphs in Tab. 1. Here, the number of nodes refers to the number of branches in the search tree produced by the algorithm. We can see that for all instances, DnBk has fewer nodes than DnBks, which in turn has fewer nodes than DnBkp and DnBkc. This matches the dominance relations that we conclude in Fig. 4. For instances like rt-retweet-cralw and tech-as-skitter with k=1, all algorithms can solve them within 10 seconds, the other variant could be faster than DnBk. This shows that the time overhead of computing the bound only affects easy instances. The number of nodes is fewer than that of DnBkclub in most cases, implying that our new bound is empirically better than Club. Also, DnBk is faster than this algorithm."}, {"title": "6 Conclusion", "content": "In the paper, we discussed both theoretical and practical aspects of solving the maximum k-defective clique problem. We studied a branching algorithm that has a better exponential time complexity than the existing ones when k is constant. We also investigated a new bound that hybrids existing two bounds with the idea of conflict vertices. The tightness of the bounds are analyzed based on the dominance relationships. We note that the conflict relationship of vertices, which was first formalized in this paper, exists in many graph search problems, such as the maximum clique problem, and thus can be potentially extended in the future."}, {"title": "Appendix", "content": "1 Structure of the Appendix\n\u2022 In Section 2, we describe the heuristic algorithm used in BnBk.\n\u2022 In Section 3, we prove the correctness of Lemma 2 and Lemma 3. Specifically, we prove that the decomposition algorithm does not miss the optimal solution.\n\u2022 In Section 4, we add the missing proofs for the upper bounding rules and algorithms in the paper. Specifically, in Section 3.1, we show the correctness of all conflict rules in the paper. In Section 3.2, we show the correctness of the pakcing, coloring with conflict bounding rules. In Section 3.3, we show that DPBound solve the OPT problem without conflict constraint.\n\u2022 In Section 5, we prove the dominance relation among the proposed bounds and existing bounds.\n\u2022 In Section 6, we provide complete experimental results, including the comparison of different variants on the whole benchmark and detailed comparison among DnBk, kDC-2 and -RR3."}, {"title": "2 Heuristic Algorithm for Finding Initial Solution in DnBk", "content": "The Algorithm 1 shows the heuristic algorithm for building the initial solution. Note that the time complexity of the heuristic algorithm is O(|V|+|E|)."}, {"title": "3 Proof to Lemma 2 and Lemma 3", "content": "Lemma 1. Given an instance I = (G, P, R) where P\u2260 0, the branching algorithm finds the maximum k-defective clique of I in time O(|R|2km) where m = |CN(P)| and yc is the base of the exponential factor in the time complexity for maximum clique algorithm."}, {"title": "4 Missing Proof for the Bound and Algorithms", "content": "4.1 Correctness of the Five Rules for Identifying Conflict Vertices\nWe show that the following rules are correct for identifying conflict pairs."}, {"title": "4.2 Proof of Bound Rule 3", "content": "Bounding Rule 1 (The Packing, Coloring with Conflict Bounding Rules). Given an instance I = (G, P, R) and a lower bound lb, assume that V \\ P is partitioned into x independent sets \u03a01, ..., \u03a0\u03c7. For any u, v \u2208 V \\ P, conflict(u, v) = 1 if {u, v} are conflict vertices and conflict(u, v) = 0 otherwise. The optimal objective value of the optimization problem described in the following is an upper bound of wk (I)."}, {"title": "5 Proofs to the Dominance Relations Between Different Bounds", "content": "We first reformulate the sorting [1] and club [4] bounding rules so that they match the context of our description."}, {"title": "6 More Statistical Results of Experiments", "content": "6.1 Complete Experiments for Bounds\nDetailed experimental results are given in file data.pdf. Note that for certain k, if the maximum k-defective clique is smaller than k + 2, then the opt is assigned to k + 1. Here we will give the whole per-formance of the five variants. We first show the results of the five variants in Fig. 1 on all graphs with k = 1,5,15, 20. From Fig. 1, we can see that for all k values DnBk, DnBks and DnBkclub are faster than DnBkp and DnBkc. Moreover, the dominance is become more obvious when k is increasing. When k is relatively small, i.e., k = 1,5, the efficiency of DnBk, DnBks and DnBkclub are almost the same. But when k is large, i.e., k = 15, 20, DnBk outperforms DnBks and DnBkclub and when k = 20 DnBks obviously outper-forms DnBkClub. For DnBkp and DnBkc, they cannot dominant each other but DnBkp is slightly better than DnBkc."}, {"title": "6.2 Comparing to kDC-2 and -RR3", "content": "Since the DnBk performs very similar to -RR3 and kDC-2 in [2], we show the experiment results of these three solvers on the 39 Socfb large social network graphs. The three solvers are listed below.\n\u2022 DnBk, the most efficient solver in our paper.\n\u2022 kDC-2, the most efficient solver in [2]\n\u2022 -RR3, the variant of kDC-2 without Reduction Rule 3 in [2].\nActually, the research [9] is concurrent with ours, and the source code is still unavailable. Hence, we can only compare DnBk with kDC-two and -RR3 by analyzing the Table3 in [9], i.e. running time on 39 socfb-graphs with k=10 and 15, the only detailed results re-ported.\nFirst, we use kDC as the benchmark algorithm for machine per-formance since both studies used the same kDC source code. We observed that the machine in [9] is likely to be 2.21x faster than ours. Thus, we scaled the running times in [9] by 2.21 times and compare them with DnBk."}]}