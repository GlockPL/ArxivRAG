{"title": "An Empirical Study of Code Obfuscation Practices in the Google Play Store", "authors": ["Akila Niroshan", "Suranga Seneviratne", "Aruna Seneviratne"], "abstract": "The Android ecosystem is vulnerable to issues such as app repackaging, counterfeiting, and piracy, threatening both developers and users. To mitigate these risks, developers often employ code obfuscation techniques. However, while effective in protecting legitimate applications, obfuscation also hinders security investigations as it is often exploited for malicious purposes. As such, it is important to understand code obfuscation practices in Android apps. In this paper, we analyze over 500,000 Android APKs from Google Play, spanning an eight-year period, to investigate the evolution and prevalence of code obfuscation techniques. First, we propose a set of classifiers to detect obfuscated code, tools, and techniques and then conduct a longitudinal analysis to identify trends. Our results show a 13% increase in obfuscation from 2016 to 2023, with ProGuard and Allatori as the most commonly used tools. We also show that obfuscation is more prevalent in top-ranked apps and gaming genres such as Casino apps. To our knowledge, this is the first large-scale study of obfuscation adoption in the Google Play Store, providing insights for developers and security analysts.", "sections": [{"title": "I. INTRODUCTION", "content": "ANDROID plays a vital role in the smartphone market, holding more than 70% market share [2]. Within that, the Google Play Store serves as the primary app repository, offering over 1.7 million apps as of August 2024 [3]. The Google Play Store is highly accessible, allowing developers to publish and monetize their apps with fewer barriers to entry. Due to the relative ease of publishing apps, various malpractices are common in the Google Play Store [4]. For example, some malicious authors may repackage or counterfeit legitimate apps for nefarious purposes [5], [6]. Similarly, some malicious parties may steal intellectual property (IP) by reverse engineering apps [7]. These malpractices pose a significant threat to legitimate app developers and end users. As a countermeasure, app developers use code obfuscation to protect their apps and intellectual property (IP) [8]. Equally, malware authors can also use obfuscation to evade anti-malware tools and to conceal functionality [9], [10].\nAlthough obfuscation provides security benefits, it also hinders reverse engineering, which is essential for static analysis by app investigators [11]-[13]. This poses challenges for malware analysts and app store administrators in enforcing security policies, as obfuscation can bypass anti-malware mechanisms and app store regulations [9], [10]. Additionally, obfuscation introduces performance degradations and limitations in Android research [13]-[15]. While some studies propose obfuscation-resilient research methods [16]\u2013[18], others either overlook obfuscation or consider only basic techniques and tools [19]\u2013[21], possibly due to limited awareness of its prevalence. Given these challenges, it is important to examine the prevalence and trends of obfuscation in the Google Play Store. While some prior work has introduced methods for obfuscation detection [22]-[26], no studies have fully examined the use of code obfuscation by app developers, the tools and techniques they employ, or the evolution of obfuscation adoption over time.\nTo this end, in this paper, we investigate code obfuscation adoption and practices in the Google Play Store from different aspects to benefit various stakeholders of the app market ecosystem. For developers, our work highlights the importance of obfuscation tools and industry standards to protect apps and IP. For researchers, we provide insights into industry trends. For malware analysts and app store administrators, our work underscores the necessity of robust security measures and regulations. Our research involves developing a set of classifiers to detect obfuscated code using various tools and techniques and analyzing trends over time by conducting a longitudinal study using data from two snapshots of the Google Play Store, taken five years apart. More specifically, we make the following contributions.\n\u2022\nWe propose a bank of classifiers to detect whether an app is obfuscated and, if so, identify the obfuscation tools and techniques used. On our test set, we achieved 97% accuracy in detecting obfuscation, 99% accuracy in identifying the tool used for obfuscation, and 88% accuracy in identifying the obfuscation technique.\n\u2022 Using these classifiers, we conduct a longitudinal study spanning eight years, from 2016 to 2023, to understand how code obfuscation practices have evolved in the Google Play Store. To the best of our knowledge, this is the first large-scale study of its kind to analyse over half a million Android applications.\n\u2022\nWe show that overall code obfuscation in the Google Play Store increased by nearly 13% from 2016 to 2023. We also find that ProGuard [27] and Allatori [28] are the two most commonly used tools by developers. Gaming apps tend to use obfuscation more than non-gaming apps, with Casino games showing the highest prevalence, at 80% of apps obfuscated, and over 85% using multiple techniques.\n\u2022 We report a 28% increase in obfuscation among top developers from 2018 to 2023 and an 11.7% increase among developers with only one app. Over 90% of the top 1,000 apps are obfuscated, with higher-ranked apps using multiple obfuscation techniques more frequently than lower-ranked ones. We further report that ProGuard is the most commonly used tool among lower-ranked apps.\nThe rest of the paper is organized as follows. In Section II, we present background information such as common obfuscation tools and techniques. Section III details our obfuscation detection framework, and Section IV describes our large-scale dataset. We present our findings on obfuscation trends in the Google Play Store in Section V. Section VI reviews related work, while Section VII discusses the implications and the limitations of our work and concludes the paper."}, {"title": "II. BACKGROUND", "content": "A. Common Obfuscation Techniques\nObfuscation systematically converts the source code of the program into a form that is beyond human readability. This transformation maintains the application's functionality unchanged while altering the program's code. Several previous works studied and categorized obfuscation techniques [22], [26], [29]-[31]. In the following, we describe some of the well-known obfuscation techniques used in Android apps.\n1) Identifier Renaming (IR): In Identifier Renaming, identifiers in the code (e.g., class names, method names, and field names) are substituted with random characters or strings. This aims to make the code less readable by obfuscating readable information without changing the program logic.\n2) Control Flow Modification (CF): The primary concept behind Control Flow Modification is to change the sequence of program execution, making it more difficult to understand and analyze. This technique is commonly used to protect software from reverse engineering and tampering. In [31] and [29], various methods for achieving CF are discussed, and we outlined the popular techniques below.\n\u2022 Control flow flattening incorporates a construct that may include an infinite or finite loop with a termination condition. Within this construct, individual basic blocks are encapsulated as cases of a switch statement. While the original basic block is executed during runtime, the process of decompiling the switch case statement and restoring the initial code is challenging, due to the convoluted 'if' and 'goto' statements.\n\u2022 Call indirection involves creating a new method to invoke the original method. Within the course of code execution, each method call is shadowed by this intermediary method, which, in turn, invokes the original method. It introduces complexity in the process of code restoration and impairs readability [29], [32].\n\u2022 Reflection is a technique in Java to alter the runtime behaviour of a program dynamically. It primarily leverages the Java.lang.reflect.* API, an integral component of the native Java library, to access and manipulate methods during program execution.\n\u2022 Other obfuscation methods involve techniques that sometimes overlap with the earlier methods, and as such, delineating boundaries between these techniques is challenging. For example, [33] introduces adding `nop' instructions and unconditional jumps. This is known as junk code insertion. Moreover, developers can employ opaque predicates, such as conditional statements or branches, to create a simulated branch [31], which constitutes a bogus control flow. This practice generates two branches yielding the same outcome, with one branch containing the original code and the other comprising unreachable junk instructions.\n3) String Encryption (SE): Storing sensitive information or identifiable prompts in plain text strings within the source code may render the application vulnerable to third-party examination and reverse engineering. To avoid that, String Encryption transforms human-readable strings within the code into human-unreadable character sequences.\nB. Commonly used Obfuscation Tools\nDevelopers usually resort to tools to obfuscate code. Previous works [22], [24], [25], [34] have reported multiple code obfuscation tools of various kinds, as we describe below.\n\u2022 ProGuard [27] is an inbuilt and free obfuscator for Android Studio by GuardSquare. It can be easily activated by adding ProGuard rules in the build.gradle file. ProGuard can perform only Identifier Renaming and Code Optimization as specified in the user guide.\n\u2022 Allatori [28] is a commercial obfuscator by Smardec Inc. It is offered as both paid and free educational versions with equal functionality. Integrating Allatori into an Android project is similar to ProGuard. However, it requires adding the Allatori jar file and configuration file in the build.gradle. It supports all three main obfuscation techniques discussed in Section II-A.\n\u2022 DashO [35] is another commercial obfuscator by Pre-Emptive Inc. It is a paid tool, with the possibility of requesting a 7-day evaluation licence. Developers can use DashO UI to open source code files and enable necessary configurations. DashO UI will then add the required settings to the build.gradle file. It supports all three main obfuscation techniques described earlier.\n\u2022 Obfuscapk [36] was initially developed as an open-source obfuscation tool for researchers to obfuscate Android applications. It implements all three techniques discussed in Section II. As a validation dataset, we used the AndroOBFS dataset [37], which was obfuscated using ObfuscAPK. Further details on this dataset and its role in validating our method's performance will be discussed in Section III-C.\n\u2022 DexGuard [38] is an advanced paid version of ProGuard, also provided by GuardSquare. DexGuard implements all three techniques discussed earlier and also supports Runtime Application Self-Protection (RASP) for app hardening. We were unable to obtain a free or evaluation"}, {"title": "III. OBFUSCATION DETECTION FRAMEWORK", "content": "We developed a machine learning-based framework to detect whether an app is being obfuscated or not, followed by what tool it has used for obfuscation and, finally, what type of obfuscation(s) are present. Our framework consists of a bank of classifiers that use the same Android APK-level features.\nA. Classifier Banks\nOur framework consists of three classifier types as illustrated in Figure la for i) Obfuscation Detection, ii) Obfuscation Tool Detection, and iii) Obfuscation Technique Detection.\nUsing our training and validation sets (cf. Section III-C), we tested several models, such as MLP, SVM, Random Forest, and Decision Trees. We selected the best model for each task and further tuned the hyper-parameters using grid search.\nOur models and features are comparable to existing work in obfuscation detection [25], [26], [30], [34] and provide similar performance. Here, our methodological contribution is the comprehensive framework, which facilitates subsequent large-scale longitudinal analysis of obfuscation adoption.\n\u2022 Obfuscation Detector: Our Obfuscation Detector is a binary MLP classifier that makes a prediction of whether a given Android APK is obfuscated or not.\n\u2022 Obfuscation Tool Detector: We use a bank of three binary Random Forest classifiers for obfuscation tool detection making decisions: 1. ProGuard vs. Other, 2. Allatori vs. Other, 3. DashO vs. Other. Each classifier assigns a probability to each tool: Proguard, DashO, and Allatori. Based on the highest probability, we decide which tool the APK uses. We chose to use a bank of classifiers rather than a single multi-class classifier to handle the other category more effectively, given the absence of training data for unknown obfuscation tools. This approach simplifies decision-making, as they do not need to distinguish between multiple classes. Also, it allows easy scalability by adding new classifiers as data from other tools becomes available.\n\u2022 Obfuscation Technique Detector: Similarly, we train a bank of three binary Random Forest classifiers for Obfuscation Technique Detection. We focused on the most commonly used obfuscation techniques that were discussed in Section II-A and in previous works [22], [26], [29]-[31]; i) Identifier Renaming (IR), ii) Control Flow Modification (CF), and iii) String Encryption (SE). Given an APK, these classifiers predict whether it is obfuscated with each of these techniques. If the probability given by a classifier is higher than 0.5, we categorize the APK as obfuscated using the relevant technique.\nB. Feature Engineering\nWe use 37 features of three types to represent an Android APK. They are primarily related to obfuscation techniques we focus on, as summarised in Table II. These features were selected based on prior works [30], [34]. We use Androguard [39] to extract Identifier names, Strings and Instructions from APKS' DEX files. We calculate the percentages of class names, method names, field names, and other strings based on their lengths, the presence of special characters, and the presence of numeric characters. Specifically, we count the occurrences of names with lengths of 1, 2, 3, 4, and greater than 4, as well as those containing special characters, numeric characters, or both. For example, Feature 1, described in Equation (1), represents the percentage of class names with a length of 1 relative to the total number of class names in a given APK. Equation (2) calculates the percentage of class names containing special characters relative to the total number of class names. We performed similar calculations for other attributes, as detailed in Table 2. For instructions, we selected five specific instructions: nop, goto, invoke, if, and move. We then calculated the percentage of these selected instructions out of the total number of available instructions, as shown in Equation (3).\nFeat. 1 = $\\frac{\\text{No. of class names with length 1}}{\\text{Total number of class names}} \\times 100$ \nFeat. 6 = $\\frac{\\text{No. of class names consist of special chars}}{\\text{Total number of class names}} \\times 100$"}, {"title": "C. Building the Ground-truth Dataset", "content": "To build our training dataset, we downloaded app source codes from the F-droid repository [40]. We imported each source code to Android Studio and disabled any obfuscation in the build.gradle to produce non-obfuscated samples.\nTo create obfuscated samples, we used the same projects imported from F-droid and employed ProGuard [27], Allatori [28], and DashO [35] as obfuscation tools. While Proguard is free, for Allatori, we used the educational version, which has the same features as the commercial version. For DashO, we used the 7-day evaluation licence provided to us by PreEmptive Inc., which again has the full features of the commercial version. To train the Obfuscation Technique detector, we created sets of APKs by applying each technique individually, thereby ensuring separate datasets for each technique.\nFurthermore, we also use the AndroOBFS dataset [37], comprising malware APKs obfuscated with ObfuscAPK [36]. Our aim is to select a subset of APKs from AndroOBFS to validate our classifiers and verify that they perform well with unseen obfuscation tools. Finally, we obtained a set of random APKs from the Google Play Store and manually labelled them for obfuscation, serving as an additional validation dataset. Since we don't know which tool was used to obfuscate these apps, we label them only as obfuscated or not.\nUsing manually created obfuscated and non-obfuscated APKS (MC-APKs), AndroOBFS APKs, and 50 Google Play Store APKS (GP), we generated several datasets to train and validate each classifier. The summary of these data subsets is discussed below.\n1) Datasets for Obfuscation Detector: We curated four datasets using MC-APKs, AndroOBFS data, and 50 GP APKS:\n\u2022 D1: Training and testing dataset (349 MC-APKS; 80% for training and parameter tuning, and 20% for testing).\n\u2022 D2: Unseen evaluation dataset (135 MC-APKs).\n\u2022 D3: Random subset of AndroOBFS (270 APKs).\n\u2022 D4: Manually labelled 50 Google Play APKS.\nUsing F-Droid [40] Android projects, we manually created 87 non-obfuscated APKs and 397 obfuscated APKs (MC-APKs). Due to the limited number of ground truth APKs, we divided these manually created APKs into two sets, D1 and D2, as detailed in Table III. We utilized D1 as our training and testing dataset, reserving D2 as an unseen validation dataset to assess the generalizability of our models. To further enhance the validation of generalizability, we incorporated the AndroOBFS dataset [37]. We randomly selected D3 from the AndroOBFS dataset as our second validation set. As shown in Table III, all APKs in the AndroOBFS dataset are obfuscated; no non-obfuscated APKs were included. To strengthen the validation of our obfuscation detector, we also randomly selected 50 APKs from the Google Play Store and manually labelled them. We examined the identifier names of each APK to identify any anomalies or deviations in natural language. APKs were labelled as obfuscated if anomalies were observed in the identifier names; otherwise, they were labelled as non-obfuscated. Out of the 50 APKS, 33 were classified as obfuscated and 17 as non-obfuscated after manual labelling.\n2) Datasets for Obfuscation Tool Detector: We use MC-APKs and AndroOBFS apps to create two datasets:"}, {"title": "D. Performance of the Classifiers", "content": "\u2022\nWe excluded all non-obfuscated APKs from the manually created APK dataset (from MC-APKs) because they could not be categorized under any obfuscation tools. Additionally, we removed APKs that were obfuscated using a combination of two tools, as it was challenging to classify such APKs under a single tool. Consequently, we had 362 obfuscated APKS available for tool detection. Similar to the previous scenario, we divided this dataset into D5 and D6, using D5 for training and testing the tool detection model, and keeping D6 as the unseen validation set. To ensure that our model can accurately classify the \"Other\" category, we randomly selected 30 APKS from the AndroOBFS dataset and combined them with D6, as detailed in Table IV. We used D6 as our unseen validation dataset.\n\u2022\nWe used 376 MC-APKs and AndroOBFS apps to create three datasets:\n\u2022 D7: Training and testing dataset (324 MC-APKs; 80% for training and parameter tuning, and 20% for testing).\n\u2022 D8: Unseen evaluation dataset (52 MC-APKS)\n\u2022 D9: Random subset of AndroOBFS (90 each for IR, CF, and SE).\nIn line with the tool detection process, we removed non-obfuscated APKs and irregularly combined APKs from the original dataset (from MC-APKs) to create a set of 376 manually obfuscated APKs for technique detection. As with the previous cases, we split this dataset into two subsets: D7 for training and testing, and D8 for unseen evaluation. The number of APKs in each dataset is detailed in Table V. Additionally, since the AndroOBFS dataset provides APKS labelled with obfuscation techniques, we randomly selected an extra set of APKs (D9) from it to further validate the generalizability of our method.\n\u2022\nD5: Training and testing dataset (312 MC-APKs; 80% for training and parameter tuning, and 20% for testing).\nD6: Unseen evaluation dataset (50 MC-APKs + 30 AndroOBFS)\n1) Obfuscation Detector: We show the performance of the obfuscation detector on different datasets in Table VI. Our results are comparable to those of OBFUSCAN [26], which reported similar findings. However, OBFUSCAN targets only ProGuard-obfuscated APKs, whereas our tool can handle APKs obfuscated by various obfuscators. To assess how well our obfuscation detector works with unseen data (i.e., not from a split of the training and test set), we evaluated it on D2, D3 and D4 as well. While the performance dropped somewhat, detector accuracy was still in the range of 87%-92%, suggesting its suitability for the large-scale analysis.\n2) Obfuscation Tool Detector Bank: Each classifier in our bank determines if an APK is obfuscated using a specific tool (ProGuard, Allatori, DashO) or another tool (Other). Here, it is crucial to assess that each classifier is not only classifying its own target tool usage correctly but also any other tool usage must be classified as other. For instance, if an APK is obfuscated with DashO, ProGuard vs. Other and Allatori vs. Other should classify it as Other, while DashO vs. Other should detect it as DashO. For APKs from AndroOBFS, all three classifiers should classify them as Other. Therefore, we use macro versions of Precision, Recall, and F1 to evaluate performance. We summarize the results in Table VII.\nOn the test set (D5), our classifier bank achieves an average of 99% which is comparable to previous work [25]. However, we highlight that [25] operates in a closed-set setting and, as such, does not have the means to categorize unknown obfuscators accurately. To further validate how well the classifiers perform in detecting unknown tools, we evaluated them on D6. We achieved an average accuracy of 88% showing that the obfuscation tool detector indeed works well with unknown tools and classifies them as others with high accuracy.\n3) Obfuscation Technique Detector Bank: Similarly, we show the performance of the obfuscation technique detector bank in Table VIII. On the test set (D7), we achieved an average accuracy of 88% which is comparable to prior works [23],"}, {"title": "IV. LARGE SCALE ANALYSIS", "content": "A. Dataset\nOur large-scale analysis data is based on two large snapshots of the Google Play Store collected around 2018 and 2023. The 2018 dataset that was collected as a part of our previous work [41], [42] contains metadata of over 1.2 million apps that were collected between January and March 2018 and 1,023,521 APK files. The 2023 dataset contains metadata of over one million apps and was collected between January and November and 395,396 APK files.\nBoth datasets were collected in the same way using a Python-based crawler. First, the crawler discovered available apps on the Google Play Store. Then, it collected app metadata (e.g., app ID, app genre, developer name, number of downloads, rating details) and APK executables for free apps. There are several reasons behind the difference between the number of apps for which we crawled metadata and the number of apps for which we downloaded the APKs. First, the APK crawler is significantly slower than the metadata crawler. Second, we do not download the APKs of paid apps. Third, some apps do not support the Android device we simulated to download APKs.\nOne of the fields in app metadata is the \"last update date\". We use this field to categorise apps by year as summarised in Table IX. As can be seen, the centre years of our two crawls, i.e., 2017 and 2022, have the highest number of apps. We have a notably smaller number of apps for 2019 and 2020 because they were only collected in 2022, and only a limited number of apps have the last update date in 2019 and 2020. These apps can bias our analysis as these represent apps that have been most likely abandoned by app developers. As a result, we do not consider 2019 and 2020 in our extended analysis. For each year, we analyse a random sample of apps as listed in Table IX. The reason for not analysing all apps in all the years is the time, as APK decompilation takes time.\nB. Process of APK Analysis\nFor each APK we analyse, we use Androguard [39] and our pre-processing scripts to create the feature vector described in Section III-B. Next, we make a prediction using our Obfuscation Detector. If the app is predicted as not obfuscated, we record this and stop further analysis for that app. If the APK is obfuscated, we use the same feature vector with the Obfuscation Tool Detector Bank and Obfuscation Technique Detector Bank to identify the tool and technique(s) used. In the Tool Detector step, if all three classifiers give a probability of less than 0.5, we categorize the APK as using an Other tool. Otherwise, we use the highest probability to determine the tool. In the Technique Detector, the classifier identifies the obfuscation technique (IR, CF, SE) if its probability exceeds 0.5. This overall process is illustrated in Figure 1b."}, {"title": "V. RESULTS", "content": "In this section, we present various analysis results that demonstrate the adoption of code obfuscation in Google Play.\nA. Overall Obfuscation Trends\n1) Presence of obfuscation: Out of the 548,967 Google Play Store APKs analyzed, we identified 308,782 obfuscated apps, representing approximately 56.25% of the total. In Figure 2, we show the year-wise percentage of obfuscated apps for 2016-2023. There is an overall obfuscation increase of 13% between 2016 and 2023, and as can be seen, the percentage of obfuscated apps has been increasing in the last few years, barring 2019 and 2020. As explained in Section IV-A, 2019 and 2020 contain apps that are more likely to be abandoned by developers, and as such, they may not use advanced development practices.\nFrom 2016 to 2018, the obfuscation levels were relatively stable at around 50-55%, while from 2021 to 2023, there was a marked rise, reaching approximately 66% in 2023. This indicates a growing focus on app protection measures among developers, likely driven by heightened security and IP concerns and the availability of advanced obfuscation tools.\n2) Obfuscation tools: Among the obfuscated APKs, our tool detector identified that 40.92% of the apps use Proguard, 36.64% use Allatori, 1.01% use DashO, and 21.43% use other (i.e., unknown) tools. We show the yearly trends in Figure 3. Note that we omit results in 2019 and 2020 (cf. Section IV-A). ProGuard and Allatori are the most consistently used obfuscation tools, with ProGuard showing a slight overall increase in popularity and Allatori demonstrating variability. This inclination could be attributed to ProGuard being the default obfuscator integrated into Android Studio, a widely used development environment for Android applications. Notably, ProGuard usage increased by 13% from 2018 to 2021, likely due to the introduction of R8 in April 2019 [43], which further simplified ProGuard integration with Android apps.\nDashO consistently remains low in usage, likely due to its high cost. The use of other obfuscation tools decreased until 2018 but has shown a resurgence from 2021 to 2023. This suggests that developers might be using other or custom tools, or our detector might be predicting some apps obfuscated with Proguard or Allatori as 'other.' To investigate, we manually checked a sample of apps from the 'other' category and confirmed they are indeed obfuscated. However, we could not determine which obfuscation tools the developers used. We discuss this potential limitation further in Section VII-B.\n3) Obfuscation techniques: We show the year-wise breakdown of obfuscation technique usage in Figure 4. Among the various obfuscation techniques, Identifier Renaming emerged as the most prevalent, with 99.62% of obfuscated apps using it alone or in combination with other methods (Categories of Only IR, IR and CF, IR and SE, or All three). Furthermore, 81.04% of obfuscated apps used Control Flow Modification, and 62.76% used String Encryption. The pervasive use of Identifier Renaming (IR) can be attributed to the fact that all obfuscation tools support it (cf. Table I). Similarly, lower adoption of Control Flow Modification and String Encryption can be attributed to Proguard not supporting it.\nOnly IR= 11.00 13.84 14.45 20.82 18.92 14.21\nOnly CF= 0.00 0.08 0.13 0.06 0.06 0.00\nOnly SE= 0.01 0.00 0.01 0.00 0.00 0.01\nIR & CF=21.13 24.10 24.47 24.50 19.16 16.56\nIR & SE 4.59 2.85 2.17 2.02 5.51 5.73\nCF & SE 0.02 0.61 0.88 0.02 0.02 0.03\nAll Three 63.25 58.47 57.83 52.64 56.38 63.46\nNext, we investigate the adoption of obfuscation on Google Play Store from various perspectives. Same as earlier, due to the smaller dataset size and possible bias (cf. Section IV-A), we exclude the APKs from 2019 and 2020 from this analyses.\nB. App Genre\nFirst, we investigate whether the obfuscation practices vary according to the App genre. Initially, we analysed all the APKS together before separating them into two snapshots.\nFigure 5 shows the genre-wise obfuscated app percentage. We note that 19 genres have more than 60% of the apps obfuscated, and almost all the genres have more than 40% obfuscation percentage. Casino genre has the highest obfuscation percentage rate at 80%, and overall, game genres tend to be more obfuscated than the other genres. The higher obfuscation usage in casino apps is logical due to their nature. These apps often simulate or involve gambling activities and handle monetary transactions and sensitive data related to in-game purchases, making them attractive targets for reverse"}, {"title": "C. App Developers", "content": "\u2022\nAdditionally", "insights": 1, "41": [42], "44": "."}]}