{"title": "Accessing LLMs for Front-end Software Architecture Knowledge", "authors": ["Luiz Pedro Franciscatto Guerra", "Neil Ernst"], "abstract": "Large Language Models (LLMs) have demonstrated significant promise in automating software development tasks, yet their capabilities with respect to software design tasks remains largely unclear. This study investigates the capabilities of an LLM in understanding, reproducing, and generating structures within the complex VIPER architecture, a design pattern for iOS applications. We leverage Bloom's taxonomy to develop a comprehensive evaluation framework to assess the LLM's performance across different cognitive domains such as remembering, understanding, applying, analyzing, evaluating, and creating. Experimental results, using ChatGPT 4 Turbo 2024-04-09, reveal that the LLM excelled in higher-order tasks like evaluating and creating, but faced challenges with lower-order tasks requiring precise retrieval of architectural details. These findings highlight both the potential of LLMs to reduce development costs and the barriers to their effective application in real-world software design scenarios. This study proposes a benchmark format for assessing LLM capabilities in software architecture, aiming to contribute toward more robust and accessible AI-driven development tools.", "sections": [{"title": "I. INTRODUCTION", "content": "Specialized architectures like MVC (Model-View-Controller) offer rapid development advantages but can face scaling issues [1]. Advanced architectures such as VIPER (View-Interactor-Presenter-Entity-Router) provide a consistent structure for building software but demand significant learning and implementation time [1], [2], posing challenges for new developers in communities favoring simpler approaches.\nLarge Language Models (LLMs) could provide assistance with these problems. They are becoming excellent tools for developers (e.g. Microsoft's Copilot and Sourcegraph's Cody), excelling at generating repetitive code and documentation, but struggle with complex tasks [3]. Despite their growing utility, limited research explores how LLMs support front-end architectures like VIPER, as most studies focus on general project-level architecture or unrelated domains [4], [5]. This raises the question as to whether LLMs can comprehend project trees, identify underlying patterns, and assist in implementing new features while maintaining architectural consistency.\nWe examine the following research questions:\n\u2022 RQ1: To what extent do LLMs demonstrate understanding of fundamental front-end architectural patterns, using VIPER as a specific example?\n\u2022 RQ2: Can LLMs accurately outline the structure of a VIPER module for that feature, specifying the roles and interactions of each component (View, Interactor, Presenter, Entity, Router), given a partial representation of the project of an iOS app (file tree)?\n\u2022 RQ3: How does the quality of the solutions to architectural design challenges proposed by LLMs (in terms of adherence to VIPER principles, logical consistency, and scalability) compare to those provided by human iOS developers with varying expertise?\n\u2022 RQ4: How accurately can LLMs infer missing components, predict potential dependencies, or identify architectural inconsistencies?\nTo answer these questions: (a) We created an example iOS project. The project is written in the Swift programming language using the UIKit UI framework and implementing the VIPER architecture. (b) We created a set of questions using a knowledge taxonomy to ensure a broad coverage of questions. (c) We presented these questions to ChatGPT using its API. (d) We analyze and grade the AI's responses. Since a knowledge taxonomy was used, comparative analysis can then be used between the different cognitive levels. This paper benefits from the primary author's extensive experience with VIPER, gained from industry practice.\nWe selected the VIPER architecture [2], [6], for being complex and incorporating a number of established patterns, being possible to generalize different responsibilities to other patterns (e.g. observer pattern instead of Presenter tactic)."}, {"title": "II. RELATED LITERATURE", "content": "Recent advances in LLMs have shown promise in automating various software engineering tasks, but their application to front-end software architecture remains largely unexplored.\nOzkaya et al. [7] highlight the limited attention given to how design and architecture tasks can be effectively accomplished using generative AI-based software development tools. They emphasize the necessity of human expertise to assess not only the correctness of tool recommendations but also their fitness for purpose in code generation. In the context of software engineering team automation, Lin [8] explores a scenario where each role in the software creation process is assumed by an LLM agent. However, the evaluation primarily focuses on the final generated code rather than the actual performance of the architect in the project.\nAlthough the literature touches on various aspects of architecture and LLMs, direct applications to software architecture are still sparse. Jahic and Hossain [9], [10] discuss system architecture, providing insights into how LLMs might be integrated into broader architectural frameworks. Li [11] explores the application of LLMs in chip architecture, suggesting potential parallels for software architecture. Wei [12] investigates the use of LLMs to generate software requirements, which indirectly influences architecture, particularly when following clean architecture principles. Several studies focus on the use of LLMs in generating UML diagrams [4], [13]\u2013[15], Rasheed [16] mentions the architecture of generated code, though it is often referenced indirectly in prompts rather than being a primary focus. Mzid [17] examines the detection of design patterns using LLMs."}, {"title": "A. VIPER Architecture", "content": "We selected the VIPER architecture [2], [6], for being complex and with comparatively little online documentation that an LLM could have been trained on. VIPER is a backronym to its five responsibilities. It is composed of five layers: the View displays data and captures user input, Interactor handles business logic, Presenter acts as a mediator, handling presentation logic, Entity represents the data modelling, and Router manages the navigation between screens.\nIt incorporates a number of established patterns (e.g. delegate), which could be generalized and adapted to other patterns (e.g., the observer pattern being utilized in the Presenter tactic). Additionally, it is a complex architecture with a large learning curve, contains multiple responsibilities and is aimed at large projects, as it has multiple advantages over other more common architectures, having good performance, testability, and modifiability metrics [1]."}, {"title": "III. ASSESSING ARCHITECTURAL KNOWLEDGE", "content": "Multiple knowledge models have been developed to understand how developers comprehend software. These models share common elements, including \"telltale code snippets and conjectures about the programming goals, and activities that bring the developer closer to the complete mental model\" [18]. The programmer's knowledge base typically consists of \"domain expertise; coding knowledge, beacons, and plans; syntactic and semantic knowledge; domain goals; rules of programming discourse; and schemas\" [18], [19]. However, these software comprehension models are usually based on how developers understand complex code or build knowledge around source code for a project, and given the novelty of LLMs, they are not built or tested against it."}, {"title": "A. Defining Architectural Knowledge", "content": "Architectural knowledge encompasses a broader scope than just code comprehension. According to Clements et al. and Ozkaya [7], [20], architectural knowledge can be considered the union of five factors: Architecture design (overall structure of the software system); Design decisions (choices made during the architecture design process); Assumptions (attributes assumed to be true during the architecture design); Context (environment where the system will be used, e.g. hardware, operating system, network infrastructure); and other factors (such as cost of development and maintenance).\nFor simplicity, we are choosing to follow Ozkaya's characterization [7] for defining architectural knowledge and the process of capturing design decisions. Capturing design decisions and its assumptions requires knowing the context and the trade-offs. Architectural knowledge and the ability to make meaningful trade-offs are expert skills and imply the experience of seeing similar examples over different situations. If we want to use generative AI tools to assist in system development beyond method or class-level implementation tasks and toy examples, we must embrace incorporating architectural knowledge into the process, implying using architectural patterns, tactics, and design constructs to direct code generation."}, {"title": "B. Assessing Architectural Knowledge", "content": "A key aspect of learning software design is conveying architectural knowledge [21]. This involves understanding not only algorithms and data structures, but also higher-level concerns (e.g. system structure and component interactions). Architectural design necessitates analyzing software requirements to capture functional and behavioral aspects, defining not only what a system is, but also what it does. Architectural design requires analyzing requirements to define both the structure and behavior of a system. Studying styles like layered architectures and Model-View-Controller provides a foundation for organizing complex systems, though learning design processes remains challenging [21]. Hu highlights that students often lack process knowledge-understanding the phases, paradigms, and methodologies essential for creating design artifacts.\nBloom's taxonomy provides a structured framework for assessing architecture knowledge by aligning learning objectives to benchmark approaches. It classifies cognitive learning into six hierarchical levels, from basic to complex [22]: Remembering: recalling facts (e.g., listing software architectures). Understanding: demonstrating comprehension (e.g., explaining differences between architectures). Application: using information in new contexts (e.g., developing an app using MVC). Analysis: breaking down components (e.g., analyzing interactions in hybrid app architectures). Evaluating: making judgments based on criteria (e.g., assessing performance implications of a design pattern). Creating: combining elements to design novel solutions (e.g., crafting a new architecture for a specific problem).\nTraditional approaches to teaching software architecture focus on textbooks and standardized solutions, as these methods were developed before the advent of LLMs. These tools impact information retrieval and collaboration, aiding or hindering developers depending on their usage [23]. While AI tools show efficiency gains, a new approach is needed to leverage LLMs\u2019 capabilities in acquiring and applying architectural knowledge, as they have the potential to be transformative tools."}, {"title": "IV. METHOD", "content": "To investigate the capabilities of the LLM in understanding and working within the VIPER architecture, we designed an investigation setup that covers various aspects of the architecture and its implementation in Swift. We create architectural knowledge questions about the framework, and assess the LLM performance using Bloom's taxonomy [22]."}, {"title": "A. Project Structure and Language", "content": "The selected project\u00b9 is a small Swift project, using UIKit framework, and follows the VIPER architecture. The code was built by the author, incorporating contributions from novice developers. The project includes realistic architectural errors reflective of the team's learning process at the time. It contains multiple VIPER modules, and each one of them holds its components: View, Interactor, Presenter, and Router. Entities are an exception, since they are commonly shared between multiple features, being usually found in a shared folder.\nProtocols, although not included in the VIPER nomenclature, are a common design pattern used together with VIPER on Swift, commonly referred to as the Delegate Design Pattern-therefore the LLM will also be tested on this separation of concerns."}, {"title": "B. Question Design", "content": "This architecture assesses the LLM's ability to respond and generate insights across varying cognitive levels. A diverse question set, based on Bloom's taxonomy, helped to ensure a more comprehensive evaluation:\n\u2022 Remembering: Identify file functionalities within VIPER modules.\n\u2022 Understanding: Explain file purposes in context (e.g., the role of Business Logic in the MovieHomeScreen module).\n\u2022 Applying: Describe data flows between VIPER elements and propose implementation strategies.\n\u2022 Analyzing: Detect patterns, deviations, and bottlenecks in adherence to VIPER standards.\n\u2022 Evaluating: Critique VIPER's effectiveness, highlighting strengths, limitations, and areas for improvement.\n\u2022 Creating: Suggest new features or refactor existing ones, considering localization, analytics, and development strategies.\nQuestions are open-ended, allowing multiple approaches to be correct. Some intentionally lack definitive answers (e.g., data flows for non-existing features) to evaluate handling of ambiguity and hallucinations."}, {"title": "C. Model and Queries", "content": "The objective is to probe if the current state-of-the-art (SOTA) AI model is consistent. At the time of running this study, the model was OpenAI's ChatGPT 4 Turbo 2024-04-09.\nLLM evaluations were conducted using the OpenAI API, with all prompts being structured as:\nGiven the context that this is an iOS\nproject using VIPER architecture,\nanswer the following question.\n<Query from Bloom's taxonomy>\nThe project tree is the following:\n<Project Tree>\nNote that no actual code is given to the model's context. Responses from the LLM were then collected and stored in a CSV file for further analysis.\nTo ensure the evaluation accurately targeted the intended research questions, a preliminary run was taken with ChatGPT 3.5-Turbo. The goal was to eliminate any potential interference from unclear wording or grammatical issues. In the case of misunderstandings, the question was iterated over until it was sufficiently clear. The replies from the final model were registered and then graded."}, {"title": "V. PRELIMINARY RESULTS", "content": "For the grading, each answer could be equal to 1 point (correct), 0.5 points (partially correct), and 0 points (incorrect). We considered an answer correct when the model answered the question satisfactorily; Partially correct when it made some mistakes in the answer, but it is not completely incorrect; And incorrect when it was not able to give the correct answer.\nEach level of the taxonomy has between 4 and 7 questions, totaling 43 questions, and the final results can be seen in Table I. The grade for each level represents the mean score of all questions within that level, converted to a percentage.\nPerhaps surprisingly, the model performed better at the later levels in Bloom's Taxonomy, scoring 100% in Analyzing, 94% in Evaluating, and 100% in Creating. In the first levels, the model did not have bad scores, but it is comparatively lower, with 83% in Remembering, 94% in Understanding, and 88% in Applying. This might demonstrate that the model is capable of creating actions and generating code, but fails with specific information retrieval without using code.\nHowever, it is important to note that the combined 'grade' needs to be viewed with some skepticism due to the varying number of questions per knowledge level. A simple average across the 'Grade (%)' row would give equal weight to each level, despite the difference in number of questions."}, {"title": "VI. DISCUSSION", "content": "The LLM demonstrated a promising grasp of front-end architectural principles (RQ1), showing potential in high-level tasks like proposing features and critiquing architecture, though its software design understanding remains limited, suggesting architects will maintain a critical role. Regarding outlining VIPER modules (RQ2), it shows capability in contributing to feature development and generating boilerplate code, suggesting structural understanding, yet struggled with describing component data flow. The comparative quality of the LLMs architectural design solutions against human developers (RQ3) remains a subject for future investigation. Finally, concerning its ability to infer missing components and dependencies (RQ4), its success in \"Analyzing\" suggests a capacity for identifying architectural inconsistencies; While constrained by lack of direct code access, necessitating higher-level suggestions, the LLM often correctly assumed relationships and proposed flexible solutions adaptable to existing project structure.\nIntegrating architectural knowledge into LLM training and using more complex datasets could enhance their ability to address real-world challenges. Employing Bloom's taxonomy highlights the model's proficiency in creative and evaluative tasks but reveals gaps in detailed information retrieval and precise architectural application.\nImproved LLM performance could lower development costs, support novice developers, and encourage robust design adoption, positioning LLMs as valuable tools rather than replacements in the software development process."}, {"title": "A. Limitations", "content": "While this study offers insights into LLM capabilities in understanding and applying software architecture concepts, particularly VIPER, several limitations must be acknowledged.\nThe evaluated project, developed by novices, contained architecture inconsistencies, providing a small-scale test case. Larger, older projects with technical debt might yield different insights. Using custom projects with designed errors could broaden the findings.\nThe study focused solely on VIPER in Swift, a niche architecture, which might limit generalization to other patterns like MVVM. Additionally, evaluations relied on a single model, ChatGPT 4 Turbo 2024-04-09, which may not reflect the behavior of other LLMs. Future advancements or alternative models might alter the results.\nThe model excelled in higher-order tasks (e.g., creating and evaluating) but struggled with lower-order-tasks (e.g., remembering and applying), likely due to project inconsistencies or limited contextual data (e.g., only project trees, not full source code). The \"black-box\" nature of LLMs also complicates understanding their decision-making, underscoring the need for interpretability tools and systematic error analysis."}, {"title": "B. Future Work", "content": "We plan to expand our analysis to a larger project. This shift necessitates revising the question set to align with the new repository.\nTo manage the increased complexity, we are incorporating inter-rater reliability into the question development process. Questions will be independently created by a group of graduate students and subsequently evaluated anonymously by a separate panel of graduate peers. Based on their feedback, questions will be refined, removed, or added until consensus is achieved.\nWe also intend to include an open-source LLM as a baseline and involve developers experienced with the architecture to evaluate the responses. The finalized question set will be tested on the latest state-of-the-art model."}, {"title": "VII. CONCLUSION", "content": "This study offers positive preliminary insights into LLM capabilities for architectural tasks, with potential for higher-order cognitive tasks, particularly in analyzing, evaluating and creating within the VIPER architectural pattern. We achieve it by employing a methodology grounded in Bloom's Taxonomy and analyzing open-ended responses to architectural challenges.\nIt also establishes a structured approach for evaluating potential and limitations on LLMs cognitive abilities for Software Design and Software Engineering. This framework provides a foundation for future research to more systematically explore the potential and limitations of LLMs in Software Engineering.\nDespite these promising results, the study also reveals barriers to widespread application, including limited context information and occasional struggles with information retrieval. As LLM technology evolves, improvements in training datasets, larger contexts, and interpretability could address these issues, enabling broader and more robust adoption."}]}