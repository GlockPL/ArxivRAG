{"title": "UM2N: Towards Universal Mesh Movement Networks", "authors": ["Mingrui Zhang", "Chunyang Wang", "Stephan Kramer", "Joseph G. Wallwork", "Siyi Li", "Jiancheng Liu", "Xiang Chen", "Matthew D. Piggott"], "abstract": "Solving complex Partial Differential Equations (PDEs) accurately and efficiently is an essential and challenging problem in all scientific and engineering disciplines. Mesh movement methods provide the capability to improve the accuracy of the numerical solution without increasing the overall mesh degree of freedom count. Conventional sophisticated mesh movement methods are extremely expensive and struggle to handle scenarios with complex boundary geometries. However, existing learning-based methods require re-training from scratch given a different PDE type or boundary geometry, which limits their applicability, and also often suffer from robustness issues in the form of inverted elements. In this paper, we introduce the Universal Mesh Movement Network (UM2N), which once trained can be applied in a non-intrusive, zero-shot manner to move meshes with different size distributions and structures, for solvers applicable to different PDE types and boundary geometries. UM2N consists of a Graph Transformer (GT) encoder for extracting features and a Graph Attention Network (GAT) based decoder for moving the mesh. We evaluate our method on advection and Navier-Stokes based examples, as well as a real-world tsunami simulation case. Our method outperforms existing learning-based mesh movement methods in terms of the benchmarks described above. In comparison to the conventional sophisticated Monge-Amp\u00e8re PDE-solver based method, our approach not only significantly accelerates mesh movement, but also proves effective in scenarios where the conventional method fails. Our project page is at https://erizmr.github.io/UM2N/.", "sections": [{"title": "1 Introduction", "content": "Various natural phenomena are modeled by Partial Differential Equations (PDE). The accurate and efficient approximation of the solutions to these complex and often nonlinear equations represents a fundamental challenge across all scientific and engineering disciplines. To solve real-world PDEs, many numerical methods require a computational mesh or grid to discretize the spatial domain. The quality of this mesh significantly impacts the balance between a numerical solution's accuracy and the computational cost required to obtain it. To maintain high-resolution everywhere in the domain is computationally expensive. Many systems modeled by PDEs however are multi-resolution in nature. For example, a small part of the system may be highly dynamic, while other regions are quasi-stationary; alternatively, some locations may be more important while others less important to the question being considered by the calculation [1-4]. While a uniform, high-resolution mesh can be utilized to capture the dynamics or what is most important accurately, this is often wasteful of finite, precious computational resources and comes with sustainability implications [5].\nAn active body of research is focused on developing deep learning based methods to accelerate the PDE-solving process by learning surrogate neural solvers [6\u20138]. A learned solver can output PDE solutions directly given the physical parameters, and boundary conditions of a PDE. However, these methods encounter challenges such as not being able to guarantee physical plausibility of the PDE solution, weak generalization ability, and low data efficiency.\nAn alternative approach to improve the efficiency of a PDE solver is to utilize mesh adaptation, which is a technique for distributing mesh according to the requirements of numerical accuracy. Two main categories of mesh adaptation techniques can be identified: h-adaptation and r-adaptation. h-adaptation refines or coarsens the mesh resolution dynamically through topological operations such as adding/deleting nodes and swapping element edges/faces. In contrast, r-adaptation (or mesh movement) relocates or moves mesh nodes, keeping the mesh topology and thus the number of elements and vertices in the mesh unchanged [9]. These traditional mesh adaptation techniques can help reduce PDE-solving costs, but the mesh adaptation process itself may come at the cost of significant computational overhead.\nDeep learning based methods have been proposed to accelerate mesh adaptation. [10\u201315]. Most previous methods focus on h-adaptive refinement [11\u201313, 16]. Some existing works focus on learning error indicators or Riemannian metrics (which account for element shape and anisotropy, as well as size) [13-15] to guide the mesh adaptation process. The learned indicator or metric is then fed into a traditional remesher for mesh generation, or a mesh optimizer, which overall limits the performance of these works to being no better than traditional methods, especially in terms of efficiency. Reinforcement learning based methods show potential to improve the mesh adaptation task, but are difficult to train with low data efficiency [11, 16, 17]. Only a small number of works focus on r-adaptation. [18] and [19] investigated supervised and unsupervised learning based mesh movement methods. However, the proposed methods require re-training from scratch given a different PDE or geometry, which limits their applicability. In addition, the unsupervised learning method requires significant GPU memory and suffers from long training times, which makes re-training even more prohibitive for large scale problems.\nTargeting the generalization ability and efficiency of mesh movement, here we introduce the Universal Mesh Movement Network (UM2N), a two stage, deep-learning based model that learns to move the computational mesh guided by an optimal-transport approach driven by solutions of equations of Monge-Amp\u00e8re (MA) type. Given an underlying PDE to solve numerically, the process of MA based mesh movement includes choosing a suitable monitor function (i.e., a measure for the desired mesh density) and solving an auxiliary PDE whose solution prescribes the movement of the mesh. The Monge-Amp\u00e8re equation is an example of such an auxiliary PDE, which results in mesh movement with attractive theoretical properties [9], but whose solution comes at a significant computational cost. Therefore, we decouple the underlying PDE solve and the mesh movement process. The learning of the mesh movement process is essentially learning to solve the auxiliary Monge-Amp\u00e8re equation.\nThe proposed UM2N consists of a Graph Transformer based encoder and a Graph Attention Network (GAT) [20] based decoder.\nElement volume loss is selected within the training loss, instead of the coordinates loss used in previous works [18, 19]. This offers the advantage that element volume loss not only provides supervision signals but also penalizes negative volumes (i.e., inverted elements), thereby reducing mesh tangling and enhancing robustness. We construct a PDE-independent dataset by generating random generic fields for model training. The trained model can be applied in a zero-shot manner to move meshes with different sizes and structure, for solvers applicable to different PDE types and boundary geometries. We comprehensively demonstrate the effectiveness of our methods on different cases including advection, Navier-Stokes examples, as well as a real-world tsunami simulations on meshes with different sizes and structures. Our UM2N outperforms existing learning-based mesh movement methods in terms of the benchmarks described above. In comparison to the sophisticated Monge-Amp\u00e8re PDE-solver based method, our approach not only significantly accelerates mesh movement, but also proves effective in scenarios where the conventional method fails. The trained model can be directly integrated into any mesh based numerical solvers for error reduction and acceleration in a non-intrusive way, which can benefit various engineering applications suffering trade-offs between accuracy and computational cost.\nOur main contributions are listed as follows:"}, {"title": "2 Related Works", "content": "Neural PDE solver. Neural PDE surrogate models can significantly accelerate the PDE solving process. There are three main groups of existing works. Physics-informed Neural Networks (PINNS) [6, 21, 22] are the first group, modeling the PDEs through implicit representations by neural networks. PINNS require knowledge of the governing equations and train neural networks with equation residuals from the PDEs with given boundary conditions and initial conditions. Neural operators are another group of methods for learning to solve PDEs which seek to learn a mapping from a function describing the problem to the corresponding solution function [7, 8, 23\u201325]. The third group is mesh-based PDE solvers with deep learning, including the utilization of CNNs and GNNs for processing structured and unstructured meshes [15, 26-31]. Our method can be considered to be related to the neural operator approach, although it learns a mapping from monitor function values to the potential field describing the mesh movement instead of the PDE solution directly. In addition, the networks in the proposed model share similar ideas to mesh-based PDE solvers for processing unstructured meshes.\nLearning for mesh generation and adaptation. Deep learning methods have been advanced for applications in mesh generation and adaptation. Two tasks need to be differentiated here, the first involves modeling the ideal mesh resolution or density, e.g. through learning a metric or error indicator. The second involves the step that actually adapts the mesh in response, where we can distinguish between h-adaptivity, in which the connectivity structure of the mesh is changed to refine or coarsen the mesh, and r-adaptivity which maintains the connectivity and only moves the vertices.\nAn example of the first task is MeshingNet [10] which employs a neural network to establish the requisite local mesh density, subsequently utilized by a standard Delaunay triangulation-based mesh generator. Similarly, the determination of optimal local mesh density for the purpose of mesh refinement is described in [12]. In [13], the authors propose a learning-based model to determine optimal anisotropy to guide h-adaptation. [15] introduces a neural-network-based approach for predicting the sizing field for use with an external remesher. Instead of learning a metric, some works learn to manipulate the mesh directly. [11, 16, 17] formulate the h-adaptation process as a reinforcement learning paradigm, learning a policy that guides to adjust the mesh elements.\nr-adaptation (or mesh movement) is generally formulated in a fundamentally different manner to h-adaptation. Leading r-adaptation methods are based on a mapping between a fixed reference computational domain and the physical domain encompassing the adapted mesh, which is established through the solution of a nonlinear auxiliary PDE. [18] first proposed the use of a GNN based mesh movement network. [19] investigated the unsupervised learning of mesh movement for improving performance of neural PDEs solvers. [32] introduced a learning based mesh movement method specially tailored for computation fluid dynamics simulation of airfoil design.\nOur work focuses specifically on r-adaptation, i.e., mesh movement methods. The approaches proposed in previous work require re-training the model when applied to different problems, or can only generalize within a limited range of PDE parameters. We propose a mesh movement network that aims to be universal across applications to different PDEs without retraining."}, {"title": "3 Preliminaries and Problem Statement", "content": "Monge-Amp\u00e8re mesh movement. A mesh movement problem can be defined as the search for the transformation between a fixed computational domain $\\Omega_c$, and a physical domain $\\Omega_p$. Coordinates in these spaces are denoted $\\xi$ and $x$, respectively. The mesh $H_c$ defined in the computational domain is the original, often uniform mesh. The mesh $H_p$ defined in the physical domain is the adapted (or moved) mesh. The goal of mesh movement is to find a mapping $x = f(\\xi)$ between the continuous coordinate fields of $\\Omega_c$ and $\\Omega_p$, although in practice we deduce a mapping of the discrete vertex sets of $H_c$ and $H_p$. While the coordinate transformation can also be used to accommodate time-dependent moving boundaries [33] or the optimisation of the shape of the domain, here we focus on its application to achieve variable resolution such that the solution $u_x$ of a PDE solved on the adapted mesh has higher accuracy than the solution $u_\\xi$ solved on the original mesh.\nA monitor function $m$ over the spatial domain is used to specify the desired mesh density, which can be based on various characteristics of the solution field $u$ of the PDE. It prescribes where the mesh should be refined or coarsened, i.e. large monitor values indicate where high mesh resolution is required. Therefore, the goal of the mesh movement process can be rephrased as finding a mapping so that $m$ is equidistributed over the adapted (i.e., physical) mesh [34]:\n$$m(x) \\text{det}(J) = \\Theta,$$\nwhere $J$ is the Jacobian of the map $x = f(\\xi)$ with respect to the computational coordinates $\\xi$, $\\text{det}(J)$ denotes the determinant of the Jacobian which corresponds to the relative change in volume under the transformation, and $\\Theta$ is a normalization constant. By using concepts from optimal transport theory [35], the problem can be constrained to have a unique solution, with the deformation of the map expressed in terms of the gradient of a scalar potential $\\phi$ such that:\n$$x(\\xi) = \\xi + \\sqrt{\\epsilon}\\nabla\\phi(\\xi).$$ Substituting the additional constraint described by equation (2) into equation (1) gives a nonlinear PDE of Monge-Amp\u00e8re type:\n$$m(x) \\text{det}(I + H(\\sqrt{\\epsilon}\\phi(\\xi))) = \\Theta,$$\nwhere $I$ is the identity matrix and $H(\\phi)$ is the Hessian of $\\phi$, with derivatives taken with respect to $\\xi$, i.e, $H(\\phi)_{ij} = \\frac{\\partial^2 \\phi}{\\partial \\xi_i \\partial \\xi_j}$. It should be noted that guarantees for existence and uniqueness, and convergence of solution methods for the Monge-Amp\u00e8re equation generally rely on the domain being diffeomorphic with a convex domain (e.g. [36]). In practice, the method is known to break down in some cases where the domain is not simply-connected or has non-smooth boundaries.\nThe MA equation (3) is an auxiliary PDE which is purely associated with the the mesh movement process, and is independent of the underlying PDE or physical problem we wish to solve, i.e., the MA equation keeps the same form for different PDEs. This decoupling benefits learning-based methods in terms of generalization properties, i.e., a well-learned MA neural solver has the potential to be applied to different problems with a small cost of fine-tuning or even without re-training."}, {"title": "4 UM2N: Universal Mesh Movement Network", "content": "4.1 Framework overview.\nThe proposed UM2N framework is shown in Fig. 1. Given an input mesh, vertex features and edge features are collected separately. The coordinates and monitor function values are gathered from the vertices and input into a graph transformer to extract embeddings. The embedding vector z obtained from the graph transformer encoder is then concatenated with the extracted edge features e to serve as the input for the Graph Attention Network (GAT) decoder. The decoder processes this combined input along with a mesh query to ultimately produce an adapted mesh.\nGraph Transformer encoder. Transformers [37] are a popular architecture which have been successfully applied for neural PDE solvers [24, 25, 38]. They have strong expressivity and can naturally handle irregular data structures such as unstructured meshes. Their attention mechanism can capture both the local and global information for a vertex of interest in a mesh. Here we use a graph transformer encoder as a feature extractor. The input features include the coordinates of the original mesh $\\xi$ and monitor values $m_\\xi$. The coordinates serve as the positional encoding. Features are concatenated and encoded into Q (query), K (key) and V (value) as inputs using MLPs for a self-attention module. The encoder output embedding z are fed into a downstream GAT based deformer for mesh movement.\nGraph Attention Network (GAT) based decoder. We choose GATs to construct our decoder. Its attention mechanism can help constrain the mesh vertex movement to within one hop of its neighbors which assists in alleviation of mesh tangling issues. The decoder consists of N GAT blocks. The first GAT block takes a mesh query $\\xi$, and the embedding z from the transformer encoder as well as the edge features e as inputs. For each following kth block, the inputs consist of the coordinates of the initial mesh $\\xi$, the coordinates of the intermediate moved mesh $\\xi^{(k-1)}$ and extracted features from the previous layer $f^{(k-1)}$.\n4.2 PDE-independent dataset and training.\nIn the existing work of neural mesh movement [18, 19], proposed models are trained on solutions of PDEs, with the training data generated by solving one specific type of PDE, limiting generalizability of the trained model. Aiming here to train universal mesh movement networks, we construct a PDE-independent training dataset $D = \\{d = (\\xi, m_\\xi; V_r, T_r)\\}$, where $\\xi, m_\\xi$ denotes the original mesh and monitor values as the model's input, and $V_r, T_r$ as the pre-calculated (reference) mesh's vertex coordinates and elements as ground truth. To build the dataset, we randomly generate generic solution fields, which are composed as the summation of a random number of Gaussian distribution functions centred in random locations, and with random widths in different directions to introduce anisotropy, samples are shown in Figure A1; refer to Appx. B for a detailed description. The generated fields can be interpreted as representing solutions of any PDE. For mesh movement, a widely used method to translate the PDE solution $u(x)$ into a monitor function, is the Hessian based formula [35]:\n$$m(x) = 1 + \\alpha \\frac{\\|H(u)\\|}{\\text{max} \\|H(u)\\|},$$ where $\\| H(u) \\|$ indicates the Frobenius norm of the Hessian of $u$ and $\\alpha$ is a user chosen constant. This choice results in small cells where the curvature of the solution is high, with a ratio of $1 + \\alpha$ between the largest and smallest cell volumes. Our network is trained on the values of the monitor function only, which can be computed relatively cheaply from the PDE solution. The expected movement of the mesh vertices is computed by solving the Monge-Amp\u00e8re equation (3) for each of the monitor functions based on the randomly generated PDE solutions. After training, the model can then be applied using only the monitor values as input, independent of the PDE that is being solved. Other choices of formulae for the monitor function in terms of $u$ may be appropriate in different cases, but again these can be applied without re-training the model, e.g., the flow-past-a-cylinder and tsunami test cases in the following section use a monitor function based on the gradient of the solution.\n4.3 Loss functions.\nGiven the dataset $D$ defined above, the final objective is to find model parameters $\\theta$, by minimizing the total loss $L_{total}$. Thus, we can formalize the process as\n$$arg \\text{min} L_{total}(\\theta) := \\lambda_{vol} L_{vol}(\\theta) + \\lambda_{cd}L_{cd}(\\theta).$$ where $L_{vol}, L_{cd}$ represents the element volume loss and Chamfer distance loss respectively, which are defined later. $\\lambda_{cd}, \\lambda_{vol} > 0$ represent hyper-parameters balancing these two effects.\nWe denote the modified (adapted) mesh with model parameters $\\theta$ as $M(\\xi, m_\\xi; \\theta) = \\{V_a, T_a\\}$, where $V_a = \\{x_i | i = 1, 2, ..., n_1\\}$ represents the coordinates of vertices and $T_a = \\{t_i | i = 1, 2, ..., n_2\\}$ represents the elements with $x_i, t_i$ as the i-th vertex and element. For ease of presentation, we omit the $\\theta$ here. Similarly, we define $y_i, q_i$ as $V_r, T_r$'s i-th vertex and element.\nElement volume loss. In contrast to the coordinate loss used in previous work [18, 19], here we use the element volume loss for training. Element volume loss is computed as the averaged volume difference between each element in the adapted mesh ($T_a$) and the reference mesh ($T_r$) computed from the MA method. It is defined as"}, {"title": "5 Experiments", "content": "5.1 Experiment setups.\nUnlike existing approaches to mesh movement, such as [18, 19], which re-train their model on a case-by-case basis, our study aims to explore the universal applicability of the proposed UM2N. Therefore, all examples shown in this section are tested in a zero-shot generalization manner, i.e., without re-training. In addition to PDE type, our training meshes are of small size typically comprising 500 vertices, while our test meshes have far more vertices: Advection (2, 052 vertices), Cylinder (4, 993 vertices), Tsunami (8, 117 vertices), which also tests the model's scalability. There are examples with more complicated settings, please refer to Appx. D.\nTraining. The training dataset consists of 600 randomly generated generic solution fields and original meshes with 463 and 513 vertices. The model is trained using the Adam optimizer. The training and experiments are performed on an Nvidia RTX 3090 GPU.\nMetrics. The main metric for evaluating mesh movement quality is underlying PDE solution error reduction (ER) ratio. Here PDE error is approximated by the difference between the solutions obtained on a coarse mesh and accurate solutions which are obtained on a very high resolution mesh. The PDE error reduction ratio is the difference between the PDE error from an original mesh and that from an adapted mesh. Another important metric for mesh movement is mesh tangling. Once mesh tangling happens, the mesh is invalid for a numerical solver, which breaks the simulation.\n5.2 Benchmarking mesh movement.\nIn the following section, we benchmark the mesh movement using both non-learned Monge-Amp\u00e8re (MA) mesh movement implemented in Movement [39] and learning-based baseline M2N [18] over three different scenarios to compare with UM2N. Table1 shows the quantitative results in three different scenarios, Swirl, Cylinder, and Helmholz. An additional qualitative result of Tohoku Tsunami simulation, is provided to show our model can handle highly complex boundaries in real-world scenarios. Moreover, to give a fair comparison, we re-trained the model in M2N on our training dataset before evaluation.\nHelmholtz. The Helmholtz case is a time-independent problem solving a 2D Helmholtz equation as shown in (A2). The source terms of the equation are generated use formula as shown in (A1). Our model achieves better error reduction than M2N and comparable to MA method with significant less time cost.\nSwirl. The swirl case considers a time-dependent pure advection equation. In this scenario, the initial tracer field takes a narrow ring shape and is advected within a swirling velocity field, see Eq. (A3) and (A4) in Appx. C. The velocity swirling direction is anti-clockwise in the first half of the simulation and clockwise for the second half. Given this setting, as the advection process is reversible, the final state should be consistent with the initial state. This constitutes a problem of significant multi-resolution complexity, as the extremely narrow ring requires a high resolution to accurately resolve the dynamics at the sharply defined interfaces of both inner and outer sides.\nThe results are shown in Fig. 2. As shown in Table 1, our UM2N shows a average 35.93% error reduction which clearly outperforms M2N's 14.15%. It is close to that of the full Monge-Amp\u00e8re (MA) mesh movement approach which achieves an error reduction of 37.43%, but with significantly lower computational time.\nFlow past cylinder. Simulation of flow past a cylinder in a channel is a classic and challenging multi-resolution case of computational fluid dynamics, solving the Navier-Stokes equations. The cylinder and the channel's top-bottom surfaces require a high resolution mesh to resolve the boundary layers [40]. Given appropriate Reynolds number, the well-known von K\u00e1rm\u00e1n vortex street phenomena can be observed within the wake flow which also benefits from higher resolution to resolve the time-varying evolution of vorticity structures. The drag $C_D$ and lift $C_L$ coefficients for the cylinder are other quantities of interest in this problem. Here we use a benchmark configuration from [41], please refer to Appx.C.3 for more details.\nThe simulation is run for 8,000 time steps of size 0.001 s, i.e., 8 s physical time for the whole simulation. The original mesh is a uniform mesh with triangular elements and 4, 993 vertices. The reference solutions are obtained on a high resolution mesh with 260, 610 vertices.\nWe investigate the dynamics in the area around the cylinder and in the wake flow respectively. For the former, we use the measure of $C_D$ as shown in Fig. 3. The results for $C_L$ is shown in Fig. A5 in Appx. D. For the wake flow, we use cross-section probes at x = [0.5, 1.0, 1.5, 2.0] to measure the intensity of vorticity spatially along the y-axis as shown in Fig. 4.\nQualitatively, it can be observed that the proposed method moves the mesh in a manner that captures the fluid dynamics for the whole domain in general (see upper part of Fig. 3). At the cylinder and top-bottom surface, the vertices are moved to increase the resolution in order to resolve the boundary layers as expected. Quantitatively, the drag $C_D$ and lift $C_L$ coefficients computed on our moved mesh show a 61.29% average error reduction compared to that of original mesh as shown in lower part of Fig. 3. The proposed UM2N approach not only improves the accuracy of these coefficients in magnitude but also prevents their periodic variation from phase shifting. For the wake flow, as shown in Fig. 4, we selected a single snapshot at t = 4.0s for qualitative investigation. Our UM2N also shows an accuracy improvement for vorticity intensity on data sampled from all four cross-section probes comparing to the that on original mesh.\nNote that we intended to compare our UM2N to M2N and the conventional full MA method. However, both MA and M2N fail i.e., the solver diverges, within 30 time steps due to mesh tangling and thus provide insufficient data points for comparison.\nT\u014dhoku tsunami simulation. Here we present the case of a simulation of the 2011 Tohoku Tsunami, to show that our methods can be applied to real world scenarios with boundaries describing highly complex geometries. The tsunami is simulated by solving the shallow water equations using the Thetis framework [42]. For details on the datasets and software used to set up the Tohoku case study, see Appx. B.2. Note that the mesh (8, 117 vertices) has an arbitrarily irregular boundary. It can be observed that the mesh moves in a manner that helps track the wave propagation with enhanced"}, {"title": "5.3 Ablation study.", "content": "Volume loss vs coordinate loss. We denote the UM2N variant trained with coordinate loss [18] as UM2N-coord. As shown in Table 2, UM2N-coord achieves comparable error reduction (31.21%) to the proposed UM2N (35.93%) on the Swirl case. However, it fails (i.e., encounters mesh tangling) on the Cylinder case which has a more complex boundary geometry. This indicates that the element volume loss is mesh-tangling aware, i.e., helps to prevent producing inverted elements.\nMonitors vs PDE solutions as inputs. We denote the UM2N variant using the PDE solution as input, instead of monitor function values, as UM2N-sol. The UM2N-sol is trained on solutions of the Helmholtz PDE. The UM2N-sol shows a much inferior performance (-0.35%) compared to UM2N (35.93%) on the Swirl case as well as on the Cylinder case. This indicates that learning mesh movement from monitors directly improves the generalisability of the model."}, {"title": "6 Conclusions", "content": "We introduce the Universal Mesh Movement Network (UM2N), which once trained on our generated PDE-independent dataset, can be applied in a non-intrusive, zero-shot manner to move meshes with different sizes and structure, for solvers applicable to different PDE types and boundary geometries. Our method demonstrates superior mesh movement results on Advection and Navier-Stokes PDE examples as well as a real-world tsunami simulation case. Our UM2N outperforms existing learning based method and achieves comparable PDE error reduction to the costly Monge-Amp\u00e9re (MA) PDE based approach. Our UM2N demonstrates effectiveness on cases with complex boundary geometries where existing learning and conventional MA based methods fail. Our method also shows significant acceleration compared to MA based mesh adaptation. See Appx. F for the discussions on limitations and broader impacts."}, {"title": "Appendix", "content": "A Software used in the paper.\nIn this paper, PDEs are solved using finite element methods with Firedrake [43]. Firedrake is written in Python, uses the Unified Form Language (UFL) [44] domain-specific language to represent finite element forms, and automatically generates C kernels for computational efficiency. Firedrake uses PETSC [45] for solving linear and nonlinear equations that result from discretisation, as well as for its underlying unstructured mesh representation.\nOriginal meshes (i.e., meshes before adaptation) are generated by either Firedrake or Gmsh [46]. Gmsh is a meshing software especially designed for finite element methods, providing access to several meshing algorithms. In the case of the Tohoku tsunami simulation, the mesh of the Japan Sea is generated using qmesh [47] \u2013 a meshing tool specifically designed for coastal ocean modelling applications, which manages GIS (Geoscientific Information System)-based datasets to construct a valid input geometry used by gmsh to generate the mesh.\nThe conventional mesh movement strategy used to generate training data is implemented in Movement [39], which is itself written in UFL and Firedrake. Movement implements several mesh movement approaches, including two based on solutions of Monge-Amp\u00e8re type equations. In this paper, we use the 'relaxation' approach, which solves the nonlinear MA equation in an iterative fashion by introducing a pseudo-timestep (see [35] for details).\nB Dataset description.\nB.1 Dataset generation pipeline.\nWe developed a pipeline for generating PDE-independent training data and further research. Through our pipeline, generic fields are generated and can be utilized as solutions of any PDE. The monitor values computed from the generic field are used to guide the MA-based method to perform mesh adaption on the original mesh.\nWe stack N randomly generated Gaussian distributions to form the generic field u. Concretely, they can be generated by the formula:\n$$u = \\sum_{k=1}^N \\text{exp} \\left(-\\frac{(x - \\mu_x)^2}{\\sigma_x^2} + \\frac{(y - \\mu_y)^2}{\\sigma_y^2}\\right)$$\nwhere $\\mu_x$ and $\\mu_y$ denote the means of the distribution along two orthogonal directions in a 2D domain, while $\\sigma_x$ and $\\sigma_y$ represent the respective standard deviations."}, {"title": "B.2 Evaluation data for the Tohoku tsunami simulation.", "content": "As mentioned in Sec. A, the mesh of the Japan Sea is generated using qmesh [47]. For this, we provide qmesh with coastline data from [48]. Bathymetry (sea bed topography) data is taken from the ETOPO1 dataset [49]. A highly idealised tsunami source condition is used, comprised of a sum of Okada functions [50]."}, {"title": "C Details of experimental settings", "content": "C.1 Helmholtz\nThe Helmholtz equation used in the paper is defined as:\n$$-\u2207\u00b2u + u = f, \\nabla u \u00b7 n = 0 \\text{ on } \\Gamma,$$\nwhere $f$ is the source term and $\\Gamma$ denotes the boundary.\nC.2 Swirl\nWe use a similar setting to the unsteady 2D linear advection case in [17].\nInitial Condition\n$$u_0 = \\text{exp} \\left(-\\frac{1}{2\\sigma^2} (\\sqrt{(x - x_0)^2 + (y \u2013 y_0)^2} \u2013 r_0)^2\\right)$$\nThe initial condition defines a ring centered at $(x_0, y_0)$ with an inner radius $r_0$. The thickness of the ring is $3\\sigma$. In this paper, $r_0 = 0.2, (x_0, y_0) = (0.30, 0.30)$, and $\\sigma = 0.05/3$.\nVelocity Field\n$$c(x, y,t) = \\left(\\frac{9}{10} \\alpha(t) \\text{sin}^2 (\\pi x) \\text{sin}(2\\pi y), -\\frac{9}{10} \\alpha(t) \\text{sin}^2 (\\pi y) \\text{sin}(2\\pi x)\\right)$$\nIn this paper, $0 < t < 1$, if $t < 0.5$ then $\\alpha(t) = 1$, if $0.5 <= t < 1, \\alpha(t) = \u22121$, i.e., the velocity direction is reversed at t = 0.5\nMonitor Function\n$$m(x) = 1 + \\text{max} \\left(\\alpha \\frac{\\|H(u)\\|}{\\text{max} \\|H(u)\\|}, \\beta \\frac{\\|G(u)\\|}{\\text{max} \\|G(u)\\|}\\right)$$\nThe $\\|H(u) \\|$ and $\\|G(u)\\|$ are hessian norm and gradient norm respectively. In practical, we set $\\alpha = 5$ and $\\beta = 10$.\nC.3 Flow past a cylinder\nSetting The Reynolds number is 100, a quadratic velocity profile is imposed at the left boundary as inflow condition. At the right boundary a zero pressure outflow condition is applied. The cylinder and top-bottom surface are imposed with non-slip boundaries."}, {"title": "D Additional experimental results.", "content": "Flow past multiple cylinders. The Fig. A2 shows a challenge scenario with 5 cylinders in the domain. The proposed UM2N can move mesh capturing the complex dynamics without mesh tangling."}, {"title": "E Mesh movement enhanced simulation.", "content": "The Mesh Movement Enhanced Simulation Algorithm, as outlined in Alg. 1, integrates our mesh adaption strategies into the simulation process to enhance the quality and accuracy of computational solutions. The proposed MMES procedure can be adapted into almost any time-dependent numerical simulation processes non-intrusively.\nFor a given time-dependent PDE P and an initial mesh $\\xi_{init}$, the algorithm evaluates the monitor function m based on the solution field of the PDE at each time step t. The monitor value m is then"}, {"title": "F Limitations and broader impacts.", "content": "Limitations. 1) The GAT to an extent constrains the mesh movement to lie in a restricted range, which may be less effective in scenarios requiring substantial large deformation within a single iteration of the mesh mover. 2) There is no theoretical guarantee that mesh tangling will be completely prevented. 3) Given a low-quality or extremely coarse original mesh, the efficacy of the proposed method may be constrained by the inherent limitation on the degree of freedom count, as it reallocates rather than increases the number of mesh vertices. A promising future direction could be exploring the integration of mesh movement with h-adaptation, potentially developing a hybrid hr-adaptation approach that combines the advantages of both techniques.\nBroader Impacts. This research contributes to the field of AI for physical simulation by introducing an advanced learning-based mesh movement method that enhances the accuracy and efficiency of numerical simulations. The primary application of this method lies in areas requiring high-fidelity simulations of physical phenomena, such as geophysics, renewable energy, climate modeling, and aerodynamics. This method can aid in better weather or hazards forecasting, more efficient energy harvesting, fast prototyping of aircraft design etc."}]}