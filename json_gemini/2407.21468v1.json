{"title": "An Invertible State Space for Process Trees", "authors": ["Gero Kolhof", "Sebastiaan J. van Zelst"], "abstract": "Process models are, like event data, first-class citizens in most process mining approaches. Several process modeling formalisms have been proposed and used, e.g., Petri nets, BPMN, and process trees. Despite their frequent use, little research addresses the formal properties of process trees and the corresponding potential to improve the efficiency of solving common computational problems. Therefore, in this paper, we propose an invertible state space definition for process trees and demonstrate that the corresponding state space graph is isomorphic to the state space graph of the tree's inverse. Our result supports the development of novel, time-efficient, decomposition strategies for applications of process trees. Our experiments confirm that our state space definition allows for the adoption of bidirectional state space search, which significantly improves the overall performance of state space searches.", "sections": [{"title": "I. INTRODUCTION", "content": "Several process modeling formalisms have been proposed in the business process management [1] and process mining [2] literature, ranging from business-oriented formalisms (e.g., BPMN [3]) to mathematically grounded models (e.g., Petri Nets [4]). Process trees [5] represent a strict subset of Petri nets (any process tree is trivially translated to a sound Workflow net [6]). Yet, despite their inability to model complex control-flow patterns, e.g., milestone patterns, the tree structure and corresponding formal guarantees render process trees a very useful modeling formalism from an algorithmic perspective, e.g., conformance-checking artifacts such as alignments, are guaranteed to be computable for process trees.\nVarious works utilize process trees, ranging from automated process discovery [7]\u2013[10] to conformance checking [10], [11], yet, only a limited amount of work exists that covers formal properties and guarantees for process trees, and the corre- sponding potential to improve the efficiency of solving com- mon computational problems for process trees. For example, in [12, Chapter 5], a set of language-preserving reduction rules are proposed for process trees. At the same time, in various applications, e.g., conformance checking and event data-based performance measurements, the explicit notion of a state space for process trees, as well as possible corresponding theoretical guarantees and optimizations, is of particular interest.\nTherefore, in this paper, we present a novel state space defi- nition for process trees. Our proposed definition is simple, i.e., only using three possible vertex states. Despite its simplicity, it comes with powerful theoretical guarantees. We show that the state space definition is invertible, i.e., implying that the corresponding state space graph of a process tree is isomorphic to the state space graph of its inverse, where the inverse tree only changes the directionality of some of its operators. This theoretical result allows us to adopt general-purpose optimiza-tion techniques and strategies for search problems on the state space of process trees. As such, our contribution supports the further development of novel, time-efficient, decomposition strategies for applications of process trees. Our conducted experiments confirm that the proposed state space definition allows for the trivial adoption of bidirectional search on top of a general breadth-first search on the state space graph, yielding significant overall performance improvements.\nThe remainder of this paper is structured as follows. In Section II, we present the notation used, followed by (inverse) process trees in Section III. In Section IV, we present our main contribution: an invertible state space definition for process trees. In Section V, we present the evaluation. Section VI discusses related work; Section VII concludes this work."}, {"title": "II. NOTATION", "content": "Let $X$ be an arbitrary set. We let $[X]_2 = \\{\\{x,y\\} | x, y \\in X, x \\neq y\\}$ be the set of all subsets of X of size two. A sequence $\\sigma$ of length n is a function $\\sigma: \\{1, ..., n\\} \\rightarrow X$, written as $(x_1,...,x_n)$ (where $\\sigma(i) = x_i$ for $1 \\leq i \\leq n$). The set of all possible finite sequences over set X is written as $X^*$. The empty sequence is written as $\\epsilon$. The concatenation of two sequences $\\sigma_1, \\sigma_2 \\in X^*$, is written as $\\sigma_1 \\cdot \\sigma_2$. Furthermore, we let $\\shuffle$ denote the sequence shuffle operator, i.e., $(a,b) \\shuffle (c, d) = \\{\\{a, b, c, d\\}, (a, c, b, d), (a, c, d, b), (c, a, b, d), (c, a, d, b), (c, d, a, b\\} \\}$. Given $\\sigma = (x_1 ..., x_n)$, we let $\\sigma^{-1} = (x_n,...,x_1)$ the reverse of $\\sigma$. Given a language $L \\subseteq X^*$, $L^{-1} = \\{\\sigma^{-1} | \\sigma \\in L\\}$ denotes the reverse language.\nGiven an undirected graph $G = (V, E)$ over a set of vertices V and edges $E \\subseteq [V]_2$, we refer to all vertices connected to vertex $v \\in V$ as the neighbors of v ($neigh(v) = \\{v' \\in V | \\exists \\{v, v'\\} \\in E\\}$). The degree of a vertex $v \\in V$ represents the number of edges connected to v ($deg(v) = |neigh(v)|$). An acyclic connected undirected graph is referred to as a tree; vertices with $deg(v) = 1$ are referred to as leaves, vertices with $deg(v) > 1$ are referred to as internal vertices of the tree. A rooted tree, additionally, assigns a specific vertex $r \\in V$ as its root vertex. Let $T = (V, E, r)$ be a rooted tree. Every $v \\in V \\setminus \\{r\\}$, has a unique parent, i.e., the first vertex encountered on the path from v to the root. We refer to this node as $par(v) \\in V$ for $v \\in V \\setminus \\{r\\}$,"}, {"title": "III. PROCESS TREES", "content": "A process tree allows for modeling the control-flow perspec- tive of a process. Consider Fig. 1, which depicts an example process tree. A process tree is a rooted tree in which the internal vertices represent control-flow operators and leaves represent activities (or unobservable skips). Tree $T_1$ in Fig. 1 contains five different types of control-flow operators, i.e., sequence ($\\rightarrow$), reverse sequence ($\\leftarrow$), exclusive choice ($\\times$), parallelism ($+$) and loop ($\\circlearrowleft$). The process tree describes that first, activity a is executed in the process (for compactness, we use single characters to represent business process activities). Secondly, activity b should be executed. After activity b, a parallel subprocess (vertex $v_{1.3}$) is described, in which activity f is executed in parallel with a loop-based sub-process (vertex $v_{2.1}$). The loop-based sub-process describes that we first execute activity d, followed by a choice between either activity c or $\\tau$ (representing an unobservable skip). As such, the $\\times$-operator describes a choice between executing activity c or skipping it. Subsequently, we either execute e or leave the loop. Executing e, reinitiates the loop operator. The final activity that is to be executed is activity g. We formally define the notion of a process tree as follows.\nDefinition 1 (Process Tree): Let V be an indexed set of vertices, let E be a set of edges (s.t. (V, E) is a tree), let $r \\in V$, let $\\mathcal{O} = \\{\\rightarrow, \\leftarrow, \\times, +, \\circlearrowleft \\}$ denote the universe of process tree operators, let $\\Sigma$ be the universe of activity labels, let $\\tau \\in \\Sigma$, and let $l: V \\rightarrow \\Sigma \\cup \\mathcal{O} \\cup \\{\\tau\\}$. The rooted labeled tree $T = (V, E, r, l)$ is a process tree if and only if:\n$\\deg(v) = 1 \\Leftrightarrow l(v) \\in \\Sigma \\cup \\{\\tau\\}$ (leaves are activities or skips),\n$\\deg(v) > 1 \\Leftrightarrow l(v) \\in \\mathcal{O}$; (internal vertices are operators), and\n$l(v) = \\circlearrowleft \\Rightarrow |chld(v)| = 2$; (loops have two children).\nLet $T = (V, E, r, l)$ be a process tree with $chld(r) = \\{v_1,..., v_n\\}$. We alternatively write T as $l(r)(T_1,...,T_n)$, where $T_i = T|_{v_i}$ for $1 \\leq i \\leq n$, e.g., if $l(r) = \\rightarrow$ we write $\\rightarrow (T_1,...,T_n)$. When reasoning on process tree behavior, each operator specifies its own behavioral rules. For the sequence operator $\\rightarrow(T_1, . . ., T_n)$, we first execute the behavior of $T_1$, followed by $T_2, ..., T_n$. For the reverse sequence operator $\\leftarrow (T_1, ...,T_n)$, we first execute $T_n$, followed by $T_{n-1}, ..., T_1$. Note that we adopt the reverse sequence operator (as opposed to reversing the children of the sequence operator), allowing the process tree inverse function (cf. Definition 3) to retain the input tree's structure. For an exclusive choice operator $\\times (T_1, . . ., T_n)$, we execute one and only one sub-tree $T_i$ with $1 \\leq i \\leq n$. For a parallel operator $+(T_1,...,T_n)$, we execute all sub-trees, in any order. Finally, for a loop operator $\\circlearrowleft(T_1, T_2)$, we always execute tree $T_1$. If we execute $T_2$, we re-initiate the loop operator. We always execute $T_1$ to terminate the loop operator. Correspondingly, we define the language of a process tree as follows.\nDefinition 2 (Process Tree Language): Let $\\Sigma$ denote the universe of activity labels (with $\\tau \\in \\Sigma$) and let $T = (V, E, r, l)$ be a process tree (cf. Definition 1). The language described by process tree T, i.e., $L(T) \\subseteq \\Sigma^*$, is defined as follows.\n$L(T) = \\{\\{\\epsilon\\}\\}$, if $V = \\{r\\} \\land l(r) = \\tau$,\n$L(T) = \\{\\{l(r)\\}\\}$, if $V = \\{r\\} \\land l(r) \\in \\Sigma$,\n$L(T) = \\{\\sigma_1 \\cdot \\sigma_2 \\cdot \\cdot \\cdot \\sigma_n | \\sigma_1 \\in L(T_1), \\sigma_2 \\in L(T_2), ..., \\sigma_n \\in L(T_n)\\}$, if $T = \\rightarrow(T_1, T_2, . . ., T_n)$,\n$L(T) = \\{\\sigma_n \\cdot \\sigma_{n-1} \\cdot \\cdot \\cdot \\sigma_1 | \\sigma_1 \\in L(T_1), \\sigma_2 \\in L(T_2), ..., \\sigma_n \\in L(T_n)\\}$, if $T = \\leftarrow(T_1, T_2, ..., T_n)$,\n$L(T) = \\bigcup_{i=1}^{n} L(T_i)$ if $T = \\times(T_1, T_2, . . ., T_n)$,\n$L(T) = \\{\\sigma_1 \\shuffle \\sigma_2 \\shuffle \\cdot \\cdot \\cdot \\sigma_n | \\sigma_1 \\in L(T_1), \\sigma_2 \\in L(T_2), ..., \\sigma_n \\in L(T_n)\\}$ if $T = +(T_1, T_2, ...,T_n)$,\n$L(T) = \\bigcup_{i=0}^{\\infty} \\{\\sigma_0 \\cdot (\\sigma_1' \\shuffle \\sigma_1) \\cdot (\\sigma_2' \\shuffle \\sigma_2) \\cdot \\cdot \\cdot (\\sigma_i' \\shuffle \\sigma_i) \\cdot \\sigma_i' | \\sigma_0, \\sigma_1,..., \\sigma_i \\in L(T_1), \\sigma_1',..., \\sigma_i' \\in L(T_2)\\}$ if $T = \\circlearrowleft(T_1, T_2)$,\nFinally, we present the notion of the process tree inverse. The inverse of a process tree is a process tree itself, which reverses the original tree's language. Inverting a process tree only requires a change of the directionality of the sequence operator, i.e., the operators $\\times$, $+$, and $\\circlearrowleft$ remain unchanged, e.g., the inverse tree $T_1^{-1}$ of process tree $T_1$ (Fig. 1) is $\\leftarrow(a, b, +(\\rightarrow(\\times(c, \\tau), d), e), f), g)$. We formally define the process tree inverse as follows."}, {"title": "IV. AN INVERTIBLE STATE SPACE", "content": "In this section, we present our main contribution, i.e., an invertible process tree state space. This section is structured as follows. In Section IV-A, we present the notion of a process tree state and corresponding legal transitions. In Section IV-B, we present the inverse of a process tree state and show that the state space graph of a process tree is isomorphic to the state space graph of the tree's inverse. In Section IV-C, we present state space reduction techniques that enhance the performance of general state space search. Finally, in Section IV-D, we present means to connect search results of the state spaces of trees $T$ and $T^{-1}$ into a final solution."}, {"title": "A. States and Transitions", "content": "In this section, we present the notions of vertex and process tree states, as well as transitions that allow for state manipula- tions. In a process tree state, each vertex of the tree is assigned a local state, i.e., one of:\nFuture (F); Currently not open, though, the vertex may either be opened or closed in the future,\nOpen (O); the vertex is open,\nClosed (C); the vertex is closed, either because it was open before or because it refrained from being opened.\nConsider Fig. 2, in which we visualize the aforementioned vertex states, and the possible transitions between them. A vertex that is in the F state can either go to state O or to state C. A vertex in state O can only change into C. A vertex in state C can change (back) into state F. Given the vertex states, we define the notion of a process tree state as follows.\nDefinition 4 (Process Tree State): Let $T = (V, E, r, l)$ be a process tree and let $S = \\{F, O, C\\}$ be the set of vertex states. A process tree state s of process tree T is a function $s: V \\rightarrow S$.\nGiven that V is indexed, i.e., $V = \\{v_1, ..., v_n\\}$, the state of a process tree can alternatively be represented as an n-tuple of vertex states, i.e., $s(T) = (s_1, s_2, ..., s_n)$ s.t., $s(v_1) = s_1, s(v_2) = s_2, ..., s(v_n) = s_n$. If all vertices are assigned the same state, i.e., all being either F, O or C, we simply write F, $\\tilde{O}$, and C, respectively. Clearly, a state s of a tree T can be projected on any of its rooted subtrees, i.e., for some $v \\in V$, $s(T|_{v})$ is readily defined.\nWe manipulate a process tree state s by executing a tran- sition. A transition describes a vertex state change, yielding a new state s'. A transition is a member of the Cartesian product $V \\times S \\times S$, where $(v, X, Y)$, alternatively written as $v[X \\rightarrow Y]$, represents changing some vertex v from state X to state Y. In a given state s, not every transition is legal, e.g., any transition changing a vertex state from C directly into O is not allowed. For all vertices, regardless of their label, $v[F \\rightarrow C]$ and $v[C \\rightarrow F]$ are allowed if their parent's state is either future or closed. For $v[F \\rightarrow O]$, the parent of v should be open and all of its descendants should be in the future state. Similarly, for $v[O \\rightarrow C]$, the parent of v should be open and all of its descendants should be closed. In case $l(par(v)) = +$, no additional rules hold. For other cases, the operator-specific rules are as follows. For a vertex v with $l(par(v)) = \\rightarrow$, transitions $v[F \\rightarrow O]$ and $v[O \\rightarrow C]$ are allowed if all the left-hand side siblings and their descendants are closed and all the right-hand side siblings and their descendants are future. The rules for the $l(par(v)) = \\leftarrow$ are inversely symmetrical. For a vertex v with $l(par(v)) = \\times$, transition $v[F \\rightarrow O]$ is allowed if all siblings of v (and all their descendants) are future, transition $v[O \\rightarrow C]$ is allowed if all siblings of v (and all their descendants) are closed, and transition $v[F \\rightarrow C]$ is additionally allowed if par(v) is open and at least one of v's siblings is open. For a vertex v with $l(par(v)) = \\circlearrowleft$, we differentiate between v being the do-child (i.e., the leftmost child) or the redo-child (i.e., the rightmost child). If v is the do-child, then $v[F \\rightarrow O]$ is allowed if its right-hand sibling (the redo child of the loop) and all its descendants are in the future state, $v[O \\rightarrow C]$ is allowed if the redo child and all its descendants are closed, and, $v[C \\rightarrow F]$ is allowed if the redo child is open. If v is the redo-child, then $v[F \\rightarrow O]$ is allowed if its left-hand sibling (the do-child of the loop) and all its descendants are in the closed state, $v[O \\rightarrow C]$ is allowed if the do-child and all its descendants are future, $v[F \\rightarrow C]$ is allowed if the do-child is open, and, $v[C \\rightarrow F]$ is allowed if the redo child is not open. We formalize the notion of legal transitions as follows.\nDefinition 5 (Legal Transition): Let $T = (V, E, r, l)$ be a process tree, let $S = \\{F, O, C\\}$ be the set of vertex states and let $s: V \\rightarrow S$ be a process tree state. Given $v \\in V$, then:\nIf $s(v) = C$, then transition $v[C \\rightarrow F]$ is legal if:\n$s(par(v)) \\in \\{F, C\\} \\lor (s(par(v)) = O \\land b)$  (1a)\nwhere:\n$b = \\begin{cases}\n\\forall v' \\in rsib(v) (s(v') = O) & \\text{if } l(par(v)) = \\circlearrowleft \\land rsib(v) \\neq \\emptyset \\\\\n\\exists v' \\in lsib(v) (s(v') \\neq O) & \\text{if } l(par(v)) = \\circlearrowleft \\land lsib(v) \\neq \\emptyset \\\\\nfalse & \\text{otherwise}\n\\end{cases}$\nIf $s(v) = C$, then transition $v[C \\rightarrow O]$ is illegal.\nIf $s(v) = F$, then transition $v[F \\rightarrow C]$ is legal if:\n$s(par(v)) \\in \\{F, C\\} \\lor (s(par(v)) = O \\land b)$ (2a)\nwhere:\n$b = \\begin{cases}\n\\exists v' \\in sib(v) (s(v') = O) & \\text{if } l(par(v)) = \\times \\\\\n\\forall v' \\in lsib(v) (s(v') = O) & \\text{if } l(par(v)) = \\circlearrowleft \\land lsib(v) \\neq \\emptyset \\\\\nfalse & \\text{otherwise}\n\\end{cases}$ (2b)"}, {"title": "B. State Inverse and State Space Isomorphism", "content": "Similarly to the process tree inverse, we define the inverse of the process tree state.\nDefinition 6 (Process Tree State Inverse): Let $T = (V, E, r, l)$ be a process tree, let $S = \\{F, O, C\\}$, and let $s: V \\rightarrow S$ be a corresponding state. We let $s^{-1}: V \\rightarrow S$, where:\n$s^{-1}(v) = \\begin{cases}\nF & \\text{if } s(v) = C \\\\\nO & \\text{if } s(v) = O \\\\\nC & \\text{if } s(v) = F\n\\end{cases}$\nGiven a transition $t = (v, s_1, s_2) \\in V \\times S \\times S$, let $t^{-1} = (v, s_2^{-1}, s_1^{-1})$ denote the inverse transi- tion. Given $\\sigma \\in (V \\times S \\times S)^*$ with $|\\sigma| = n$, we let $\\sigma^{\\dagger} = (\\sigma(n)^{-1}, \\sigma(n-1)^{-1}, ..., \\sigma(1)^{-1})$ be the reversed sequence where every transition is inverted.\nIn Fig. 3, we show the effect of applying the state inverse. In every subfigure, the inverse of the states of the original state space is shown in gray and connected by means of a red wobbly arc. When applying the state space transition rules in the inverse process tree, we obtain a mirrored state space (as exemplified in Fig. 3). We formally prove this, on a transition level, in Lemma 1. State space isomorphism and language equivalence follow from this (presented in Corollary 1 and Corollary 2).\nLemma 1 (Transition Inversibility): Let $T = (V, E, r, l)$ be a process tree and let $T^{-1} = (V, E, r, l')$ be its inverse. Let $S = \\{F, O, C\\}$, let $s_1, s_2 \\in R(T, F)$ be two reachable process tree states. Let $v \\in V$ and let $X, Y \\in S$.\n$(T, s_1) \\xrightarrow{v[X \\rightarrow Y]} (T, s_2) \\Leftrightarrow (T^{-1}, s_2^{-1}) \\xrightarrow{v[Y^{-1} \\rightarrow X^{-1}]} (T^{-1}, s_1^{-1})$.\nProof: Direction $\\Rightarrow$\nCase I: $s_1(v) = F$;\nCase I.a: $(T, s_1) \\xrightarrow{v[F \\rightarrow O]} (T, s_2) \\Rightarrow (T^{-1}, s_2^{-1}) \\xrightarrow{v[O \\rightarrow C]} (T^{-1}, s_1^{-1})$; There are seven cases that allow for $(T, s_1) \\xrightarrow{v[F \\rightarrow O]} (T, s_2)$. Every condition includes\n$(par(v) = 1 \\lor s_1(par(v)) = O) \\land \\forall v' \\in chld(v) (s_1(T|_{v'}) = F)$, hence, in all cases, for $T^{-1}$ we deduce\n$(par(v) = 1 \\lor s_2^{-1}(par(v)) = O) \\land \\forall v' \\in chld(v) (s_2^{-1}(T|_{v'}) = C)$.\nCase I.a.1: $l(par(v)) = \\rightarrow$;\nWe additionally have $\\forall v' \\in lsib(v) (s_1(T|_{v'}) = C) \\land \\forall v' \\in rsib(v) (s_1(T|_{v'}) = F)$. We deduce $\\forall v' \\in lsib(v) (s_2^{-1}(T|_{v'}) = F) \\land \\forall v' \\in rsib(v) (s_2^{-1}(T|_{v'}) = O)$. Since $l'(v) = \\leftarrow$, we deduce that $(T^{-1}, s_2^{-1}) \\xrightarrow{v[O \\rightarrow C]} (T^{-1}, s_1^{-1})$ holds.\nCase I.a.2: $l(par(v)) = \\leftarrow$; Symmetrical to to Case I.a.1."}, {"title": "V. EVALUATION", "content": "In this section, we evaluate the impact of adopting our proposed invertible state space definition on the performance of state space searches. Section V-A presents the experimental setup. Section V-B presents the corresponding results. In Section V-C, we discuss threats to the validity of our results."}, {"title": "A. Experimental Setup", "content": "In this section, we briefly describe the experimental setup used in our experiments. We discuss Data Generation as well as the Implementation of the different search strategies used. Table I presents a general overview of the parameters of our experiments.\nData Generation: We generated 150 000 distinct process trees with 5-15 activities using the process mining library Pm4Py [13]. The generation function accepts a probability vector for inserting operator types into the generated tree. We sampled the probability vectors from a uniform Dirichlet distribution, meaning that each probability vector is equally likely to ensure that the generated trees represent a diverse range of possible tree structures."}, {"title": "C. Threats to Validity", "content": "In our implementation, we use fast-forwarding of the $C \\rightarrow F$ and $F \\rightarrow C$ (described in Section IV-C), which reduces the search space by avoiding unnecessary transitions. We expect fast-forwarding to reduce the execution time. How- ever, the results regarding the search efficiency improvements through bidirectional search remain valid since we apply fast-forwarding to both the unidirectional and bidirectional variants. In our experiments, we only consider trees with 5-15 activities. For larger trees, it becomes infeasible to compute paths in a reasonable time using breadth-first search, and we would require more efficient ways of traversing the state space. However, the aim was to show that we can adopt bidirectional search, significantly improving search efficiency."}, {"title": "VI. RELATED WORK", "content": "Generally, process trees [5] are inspired by the notion of block-structured process modeling formalisms [14]. A limited amount of work exists that explicitly focuses on formal properties of process trees. In [12, Chapter 5], a set of language-preserving reduction rules is proposed for process trees. It is easy to show that any process tree corresponds to a sound free-choice Workflow net. As such, any result for free-choice Workflow nets applies to process trees as well. We refer to [15] for a general introduction to the broader class of free-choice Petri nets. In [16], the reverse problem is tackled, i.e., an algorithm is presented that detects if, for a given arbitrary Workflow net, a language-equivalent process tree exists. Process trees are the result of various process discovery algorithms, e.g., in [7] an evolutionary algorithm is proposed. Similarly, in [8] a recursive algorithm for process trees is presented. In [9], process trees are discovered/used to represent behavioral fragments of event data (referred to as local process models). Additionally, some authors explicitly consider process trees as a process modeling formalism in conformance checking [10], [11], i.e., checking to what degree event data and a process model correspond to each other."}, {"title": "VII. CONCLUSION", "content": "In this paper, we introduced a novel process tree state space definition. We demonstrated the state space's invertibility, implying that a process tree's state space is isomorphic to the state space of its inverse, which in turn implies that a process tree's language equals the inverse of its inverse tree's language. Our experiments indicate that bidirectional search leveraging this invertibility reduces memory consumption and execution time. Parallel computation of both search directions further reduces computation time for larger state spaces. Our proposed state space serves as a foundation for various algorithms on process trees, e.g., conformance checking algorithms, facili-tating the adoption of bidirectional search.\nFuture Work: We aim to integrate our state space defi- nition in common computational problems for process trees. In particular, we aim to investigate the impact of bidirectional search for alignment computation for process trees."}]}