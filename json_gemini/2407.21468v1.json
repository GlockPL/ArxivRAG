{"title": "An Invertible State Space for Process Trees", "authors": ["Gero Kolhof", "Sebastiaan J. van Zelst"], "abstract": "Process models are, like event data, first-class citi-\nzens in most process mining approaches. Several process model-\ning formalisms have been proposed and used, e.g., Petri nets,\nBPMN, and process trees. Despite their frequent use, little\nresearch addresses the formal properties of process trees and\nthe corresponding potential to improve the efficiency of solving\ncommon computational problems. Therefore, in this paper, we\npropose an invertible state space definition for process trees\nand demonstrate that the corresponding state space graph\nis isomorphic to the state space graph of the tree's inverse.\nOur result supports the development of novel, time-efficient,\ndecomposition strategies for applications of process trees. Our\nconducted experiments confirm that our state space definition\nallows for the adoption of bidirectional state space search, which\nsignificantly improves the overall performance of state space\nsearches.", "sections": [{"title": "I. INTRODUCTION", "content": "Several process modeling formalisms have been proposed in\nthe business process management [1] and process mining [2]\nliterature, ranging from business-oriented formalisms (e.g.,\nBPMN [3]) to mathematically grounded models (e.g., Petri\nNets [4]). Process trees [5] represent a strict subset of Petri nets\n(any process tree is trivially translated to a sound Workflow\nnet [6]). Yet, despite their inability to model complex control-\nflow patterns, e.g., milestone patterns, the tree structure and\ncorresponding formal guarantees render process trees a very\nuseful modeling formalism from an algorithmic perspective,\ne.g., conformance-checking artifacts such as alignments, are\nguaranteed to be computable for process trees.\nVarious works utilize process trees, ranging from automated\nprocess discovery [7]\u2013[10] to conformance checking [10], [11],\nyet, only a limited amount of work exists that covers formal\nproperties and guarantees for process trees, and the corre-\nsponding potential to improve the efficiency of solving com-\nmon computational problems for process trees. For example,\nin [12, Chapter 5], a set of language-preserving reduction rules\nare proposed for process trees. At the same time, in various\napplications, e.g., conformance checking and event data-based\nperformance measurements, the explicit notion of a state space\nfor process trees, as well as possible corresponding theoretical\nguarantees and optimizations, is of particular interest.\nTherefore, in this paper, we present a novel state space defi-\nnition for process trees. Our proposed definition is simple, i.e.,\nonly using three possible vertex states. Despite its simplicity,\nit comes with powerful theoretical guarantees. We show that\nthe state space definition is invertible, i.e., implying that the\ncorresponding state space graph of a process tree is isomorphic\nto the state space graph of its inverse, where the inverse tree\nonly changes the directionality of some of its operators. This\ntheoretical result allows us to adopt general-purpose optimiza-\ntion techniques and strategies for search problems on the state\nspace of process trees. As such, our contribution supports the\nfurther development of novel, time-efficient, decomposition\nstrategies for applications of process trees. Our conducted\nexperiments confirm that the proposed state space definition\nallows for the trivial adoption of bidirectional search on top of\na general breadth-first search on the state space graph, yielding\nsignificant overall performance improvements.\nThe remainder of this paper is structured as follows. In\nSection II, we present the notation used, followed by (inverse)\nprocess trees in Section III. In Section IV, we present our main\ncontribution: an invertible state space definition for process\ntrees. In Section V, we present the evaluation. Section VI\ndiscusses related work; Section VII concludes this work."}, {"title": "II. NOTATION", "content": "Let \\(X\\) be an arbitrary set. We let \\([X]^2=\\{\\{x,y\\}|x,y\\in X,x\\neq y\\}\\) be the set of all subsets\nof \\(X\\) of size two. A sequence \\(\\sigma\\) of length \\(n\\) is a\nfunction \\(\\sigma\\colon \\{1, \\ldots, n\\} \\to X\\), written as \\((x_1, \\ldots, x_n)\n(where \\(\\sigma(i) = x_i\\) for \\(1 \\lt i \\lt n\\)). The set of all possible\nfinite sequences over set \\(X\\) is written as \\(X^*\\). The\nempty sequence is written as \\(\\epsilon\\). The concatenation of\ntwo sequences \\(\\sigma_1, \\sigma_2 \\in X^*\\), is written as \\(\\sigma_1 . \\sigma_2\\). Furthermore,\nwe let denote the sequence shuffle operator, i.e.,\n\\((a, b) \\uplus (c, d) = \\{\n(a, b, c, d), (a, c, b, d), (a, c, d, b), (c, a, b, d),\n(c, a, d, b), (c, d, a, b) \\}\n\\). Given \\(\\sigma = (x_1..., x_n)\\), we let\n\\(\\sigma^{-1} = (x_n,..., x_1)\\) the reverse of \\(\\sigma\\). Given a language\n\\(L \\subseteq X^*\\), \\(L^{-1} = \\{\\sigma^{-1} | \\sigma \\in L\\}\\) denotes the reverse language.\nGiven an undirected graph \\(G = (V, E)\\) over a set of\nvertices \\(V\\) and edges \\(E \\subseteq [V]^2\\), we refer to all ver-\ntices connected to vertex \\(v \\in V\\) as the neighbors of \\(v\\)\n(\\(\\text{neigh}(v) = \\{v' \\in V | \\exists \\{v, v'\\} \\in E\\}\\)). The degree of a vertex\n\\(v \\in V\\) represents the number of edges connected to \\(v\\)\n(\\(\\text{deg}(v) = |\\text{neigh}(v)|\\)). An acyclic connected undirected graph\nis referred to as a tree; vertices with \\(\\text{deg}(v) = 1\\) are referred\nto as leaves, vertices with \\(\\text{deg}(v) > 1\\) are referred to as inter-\nnal vertices of the tree. A rooted tree, additionally, assigns\na specific vertex \\(r \\in V\\) as its root vertex. Let \\(T = (V, E, r)\\)\nbe a rooted tree. Every \\(v \\in V \\backslash \\{r\\}\\), has a unique parent,\ni.e., the first vertex encountered on the path from \\(v\\) to the\nroot. We refer to this node as \\(\\text{par}(v) \\in V\\) for \\(v \\in V \\backslash \\{r\\}\\),"}, {"title": "III. PROCESS TREES", "content": "A process tree allows for modeling the control-flow perspec-\ntive of a process. Consider Fig. 1, which depicts an example\nprocess tree. A process tree is a rooted tree in which the\ninternal vertices represent control-flow operators and leaves\nrepresent activities (or unobservable skips). Tree \\(T_1\\) in Fig. 1\ncontains five different types of control-flow operators, i.e.,\nsequence (\\(\\rightarrow\\)), reverse sequence (\\(\\leftarrow\\)), exclusive choice (\\(\\times\\)),\nparallelism (\\(+\\)) and loop (\\(\\circlearrowleft\\)). The process tree describes that\nfirst, activity a is executed in the process (for compactness, we\nuse single characters to represent business process activities).\nSecondly, activity b should be executed. After activity b,\na parallel subprocess (vertex \\(v_{1.3}\\)) is described, in which\nactivity f is executed in parallel with a loop-based sub-process\n(vertex \\(v_{2.1}\\)). The loop-based sub-process describes that we\nfirst execute activity d, followed by a choice between either\nactivity c or \\(\\tau\\) (representing an unobservable skip). As such,\nthe \\(\\times\\)-operator describes a choice between executing activity\nc or skipping it. Subsequently, we either execute e or leave\nthe loop. Executing e, reinitiates the loop operator. The final"}, {"title": "IV. AN INVERTIBLE STATE SPACE", "content": "In this section, we present our main contribution, i.e., an\ninvertible process tree state space. This section is structured\nas follows. In Section IV-A, we present the notion of a process\ntree state and corresponding legal transitions. In Section IV-B,\nwe present the inverse of a process tree state and show that the\nstate space graph of a process tree is isomorphic to the state\nspace graph of the tree's inverse. In Section IV-C, we present\nstate space reduction techniques that enhance the performance\nof general state space search. Finally, in Section IV-D, we\npresent means to connect search results of the state spaces of\ntrees \\(T\\) and \\(T^{-1}\\) into a final solution."}, {"title": "A. States and Transitions", "content": "In this section, we present the notions of vertex and process\ntree states, as well as transitions that allow for state manipula-\ntions. In a process tree state, each vertex of the tree is assigned\na local state, i.e., one of:\n*   Future (F); Currently not open, though, the vertex may\n    either be opened or closed in the future,\n*   Open (O); the vertex is open,\n*   Closed (C); the vertex is closed, either because it was open\n    before or because it refrained from being opened.\nConsider Fig. 2, in which we visualize the aforementioned\nvertex states, and the possible transitions between them.\nA vertex that is in the F state can either go to state O or to\nstate C. A vertex in state O can only change into C. A vertex\nin state C can change (back) into state F. Given the vertex\nstates, we define the notion of a process tree state as follows."}, {"title": "B. State Inverse and State Space Isomorphism", "content": "Similarly to the process tree inverse, we define the inverse\nof the process tree state."}, {"title": "C. State Space Reduction", "content": "Let \\(T = (V, E, r, l)\\) be a process tree and let \\(s \\colon V \\to S\\) be\na process tree state. Given some \\(v \\in V\\) with \\(s(v) = F\\) and\n\\(s(\\text{par}(v)) \\in \\{C, F\\}\\), Definition 5 allows for \\((\\text{T}, s) \\xrightarrow{\\hspace{0.1cm}v [F\\rightarrow C]\\hspace{0.1cm}} (\\text{T}, s')\\)\n\\(({\\hspace{0.1cm}v [C\\rightarrow F]\\hspace{0.1cm}} (\\text{T}, s') \\xrightarrow{\\hspace{0.1cm}v [C\\rightarrow F]\\hspace{0.1cm}} (\\text{T}, s)\\). Hence, we\nare able to keep alternating the state of \\(v\\) from state F to\nC and vice versa. The alternating property is a requirement\nfor the general invertibility of the process tree state space.\nConsider Fig. 4, in which we show a schematical example of\nthis requirement. In the figure, the state of vertex \\(v_2\\) is changed\nfrom F to C, i.e., \\(v_2[F \\rightarrow C]\\). In the inverse of the resulting\ntree state (the bottom right figure), the same transition yields\nthe inverse (bottom left) of the starting state (top right). Since\n\\(v_1\\) is in the future state, this is allowed.\nGenerally, state alternation is not meaningful, i.e., it does not\ncontribute to generating members of the language of the pro-\ncess tree. Therefore, we avoid state alternation by adopting two\nadditional mechanisms within the state space traversal. Firstly,\nwe apply an F\u2192C or C\u2192F transition, if it is meaningfully\ndictated, e.g., as specified in the boolean condition b as defined\nin Equation 2b, encapsulated in Equation 2a. For example,\nin case some vertex \\(v \\in V\\) is in the future state, then the\ncase \\(l(\\text{par}(v)) = \\times\\) and \\(\\exists v' \\in \\text{sib}(v) (s(v) = O)\\) is meaningfully\ndictating \\(v\\) to close. Secondly, we apply fast-forwarding. When"}, {"title": "D. State Matching", "content": "The invertible state space definition allows us to traverse\nthe state space bidirectionally. Hence, any search problem on\nthe state space can be broken into two sub-problems, i.e.,\nsearching \\((\\text{T}, \\text{F}) \\leadsto (\\text{T}, \\overline{\\text{C}})\\) and \\((\\text{T}^{-1}, \\text{F}) \\leadsto (\\text{T}^{-1},\\overline{\\text{C}})\\).\nAt some point during the search, the two partial search\nresults need to be combined into a single result. Assume\nwe search for a (shortest) path of the form \\((\\text{T}, \\text{F}) \\leadsto (\\text{T}, \\overline{\\text{C}})\\)\nand we have obtained two partial results \\((\\text{T}, \\text{F}) \\xrightarrow{\\sigma} (\\text{T}, s)\\) and\n\\((\\text{T}^{-1}, \\text{F}) \\xrightarrow{\\sigma'} (\\text{T}^{-1}, s')\\). Under the assumption that the two\npartial results do not overlap, we can combine the results in\none of two ways, i.e.,\n1)  Given \\((\\text{T}, s) \\xrightarrow{\\sigma''} (\\text{T}, s'^{-1})\\), we yield \\(\\sigma . \\sigma'' . \\sigma'^{\\dagger}\\)\n2)  Given \\((\\text{T}^{-1}, s') \\xrightarrow{\\sigma'''} (\\text{T}^{-1}, s^{-1})\\), we yield \\(\\sigma . \\sigma'''^{\\dagger} . \\sigma'^{\\dagger}\\)\nIn case the partial results do overlap, we revert one of the two\nresults to directly match its counterpart in the inverse direction."}, {"title": "V. EVALUATION", "content": "In this section, we evaluate the impact of adopting our\nproposed invertible state space definition on the performance\nof state space searches. Section V-A presents the experimental\nsetup. Section V-B presents the corresponding results. In\nSection V-C, we discuss threats to the validity of our results."}, {"title": "A. Experimental Setup", "content": "In this section, we briefly describe the experimental setup\nused in our experiments. We discuss Data Generation as well\nas the Implementation of the different search strategies used.\nTable I presents a general overview of the parameters of our\nexperiments."}, {"title": "B. Results", "content": "In this section, we present the results of the conducted ex-\nperiments. In particular, we compare the memory consumption\nand execution time of BD and BDP against the baseline UD.\nTo compare the algorithms, we consider the quotient of execu-\ntion time and memory consumption to quantify the reduction.\nWe expect bidirectional search to reduce memory consumption\nand execution time. We also expect that the improvement in\nsearch efficiency depends on the operator distribution. For\nhigh levels of parallelism, the branching factor of the state\nspace is high, increasing the efficiency of bidirectional search,\nwhile for trees with high sequence operator levels, we expect a\nlower reduction since the branching factor is lowest. Regarding\nBDP, we expect that for small state spaces, the overhead of\nmanaging two threads outweighs the benefit, while for larger\nstate spaces, BDP gets close to a speedup of factor two.\nThe results are shown in Figures 5 to 7. In Fig. 5, we\nshow the reduction in memory consumption and execution"}, {"title": "C. Threats to Validity", "content": "In our implementation, we use fast-forwarding of the\nC \\leftrightarrow F and F\u2192C (described in Section IV-C), which reduces\nthe search space by avoiding unnecessary transitions. We\nexpect fast-forwarding to reduce the execution time. How-\never, the results regarding the search efficiency improvements\nthrough bidirectional search remain valid since we apply\nfast-forwarding to both the unidirectional and bidirectional\nvariants. In our experiments, we only consider trees with 5-15\nactivities. For larger trees, it becomes infeasible to compute\npaths in a reasonable time using breadth-first search, and we\nwould require more efficient ways of traversing the state space.\nHowever, the aim was to show that we can adopt bidirectional\nsearch, significantly improving search efficiency."}, {"title": "VI. RELATED WORK", "content": "Generally, process trees [5] are inspired by the notion of\nblock-structured process modeling formalisms [14]. A limited\namount of work exists that explicitly focuses on formal\nproperties of process trees. In [12, Chapter 5], a set of\nlanguage-preserving reduction rules is proposed for process\ntrees. It is easy to show that any process tree corresponds\nto a sound free-choice Workflow net. As such, any result for\nfree-choice Workflow nets applies to process trees as well.\nWe refer to [15] for a general introduction to the broader\nclass of free-choice Petri nets. In [16], the reverse problem\nis tackled, i.e., an algorithm is presented that detects if, for a\ngiven arbitrary Workflow net, a language-equivalent process\ntree exists. Process trees are the result of various process\ndiscovery algorithms, e.g., in [7] an evolutionary algorithm\nis proposed. Similarly, in [8] a recursive algorithm for process\ntrees is presented. In [9], process trees are discovered/used to\nrepresent behavioral fragments of event data (referred to as\nlocal process models). Additionally, some authors explicitly\nconsider process trees as a process modeling formalism in\nconformance checking [10], [11], i.e., checking to what degree\nevent data and a process model correspond to each other."}, {"title": "VII. CONCLUSION", "content": "In this paper, we introduced a novel process tree state space\ndefinition. We demonstrated the state space's invertibility,\nimplying that a process tree's state space is isomorphic to the\nstate space of its inverse, which in turn implies that a process\ntree's language equals the inverse of its inverse tree's language.\nOur experiments indicate that bidirectional search leveraging\nthis invertibility reduces memory consumption and execution\ntime. Parallel computation of both search directions further\nreduces computation time for larger state spaces. Our proposed\nstate space serves as a foundation for various algorithms on\nprocess trees, e.g., conformance checking algorithms, facili-\ntating the adoption of bidirectional search.\nFuture Work: We aim to integrate our state space defi-\nnition in common computational problems for process trees.\nIn particular, we aim to investigate the impact of bidirectional\nsearch for alignment computation for process trees."}]}