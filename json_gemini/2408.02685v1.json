{"title": "Artificial Neural Networks for Photonic Applications: From Algorithms to Implementation", "authors": ["PEDRO FREIRE", "EGOR MANUYLOVICH", "JAROSLAW E. PRILEPSKY", "SERGEI K. TURITSYN"], "abstract": "This tutorial-review on applications of artificial neural networks in photonics targets a broad audience, ranging from optical research and engineering communities to computer science and applied mathematics. We focus here on the research areas at the interface between these disciplines, attempting to find the right balance between technical details specific to each domain and overall clarity. First, we briefly recall key properties and peculiarities of some core neural network types, which we believe are the most relevant to photonics, also linking the layer's theoretical design to some photonics hardware realizations. After that, we elucidate the question of how to fine-tune the selected model's design to perform the required task with optimized accuracy. Then, in the review part, we discuss recent developments and progress for several selected applications of neural networks in photonics, including multiple aspects relevant to optical communications, imaging, sensing, and the design of new materials and lasers. In the following section, we put a special emphasis on how to accurately evaluate the complexity of neural networks in the context of the transition from algorithms to hardware implementation. The introduced complexity characteristics are used to analyze the applications of neural networks in optical communications, as a specific, albeit highly important example, comparing those with some benchmark signal processing methods. We combine the description of the well-known model compression strategies used in machine learning, with some novel techniques introduced recently in optical applications of neural networks. It is important to stress that although our focus in this tutorial-review is on photonics, we believe that the methods and techniques presented here can be handy in a much wider range of scientific and engineering applications.", "sections": [{"title": "1. Introduction", "content": "Machine learning has a tremendous number of definitions, which often reflect the specific interests of the researchers who formulate them. Here, we use the definition of machine learning as a bevy of algorithms that \u201c... allows computer programs to automatically improve through experience and that automatically infer some general laws from specific data\", taken from the classical Tom Mitchell's monograph [1]. In this tutorial-review, we will discuss blending machine learning with various photonics technologies and applications. The mixture of these two complementary disciplines enables the development of new scientific and engineering techniques that benefit both from the speed and parallelism inherent to optical systems and the ability of machine learning to infer from data and automatically improve system performance. Nonlinear photonics often features complex light dynamics and deals with systems that cannot be easily comprehended or controlled. Therefore, another attractive feature of machine learning in photonics applications is its capability to deal with complex nonlinear systems, whilst staying flexible and re-adaptable. Additionally, photonic devices and systems operating at high speed can quickly generate a vast amount of data. This makes them well-suited to the application of various data-based machine learning algorithms that improve performance with increasing available data sets. Therefore,\nphotonics and machine learning look like a perfect fit for each other, and their combination can naturally bring forth new ideas, theories, and devices, as well as novel concepts for understanding the description of light-related phenomena.\nArtificial neural networks, which we will henceforth call simple neural network (NNs), are computational machine learning frameworks that attempt to mimic some brain operations. The attractive features of biological NNs, which we would like to keep when using their artificial analogs, are robustness and fault tolerance; flexibility and easiness of re-adaptation to the changing conditions; ability to deal with a variety of data, meaning that the network can make do with information that is fuzzy, probabilistic, noisy, and even inconsistent; collective computation, i.e., the network can process the data in parallel and in a distributed manner [2]. Whilst the NNs are frequently attributed to supervised learning thanks to numerous widely-known successful examples in, e.g., image recognition [3, 4], they are also applicable to unsupervised learning [5], semi-supervised learning [6,7], and reinforcement learning [8\u201311], to mention the most noticeable directions. Of course, in this tutorial-review, we cannot address each specific item from the list above. Instead, we will focus on some particular examples of using the NNs in photonics, trying to explain why the particular combination of a machine learning method with a photonics application has turned out to be successful.\nHere, it is pertinent to note that ultra-fast photonic applications can bring about conditions and requirements (in terms of accuracy, speed, and complexity), which differ from those in more \"traditional\" use cases of NNs. For example, in optical communications, the typical bit-error-rate (the probability of error occurrence in the dataset, speaking in \u201cmachine learning\" language) before forward error correction, is of the order $10^{-2}$, which is, for instance, much lower than we have in typical image recognition tasks [12]. Therefore, the solutions developed in deep learning applications for image recognition and language processing often require adaptation and/or substantial modifications when we deal with, e.g., an equalization task in optical communications. We specifically notice that the real-time operation of NNs in ultra-fast photonics inevitably sets a limit on the acceptable level of NN's complexity and processing latency (inference). Thus, in this review, we pay special attention to the NNs with reduced complexity, and this, in turn, emanates into the reduction of the energy consumption used for signal processing, the sought-for feature in almost every application nowadays.\nThere are numerous recently-emerged and still developing areas at the interface of machine learning and photonics: general neuromorphic photonics, unconventional optical computing, photonic neural networks, optical communications, imaging, and sensing, to mention a few important examples where the cross-fertilization of the fields has already proven to be fruitful. Typically, the NNs' application in photonics is related to the processing of large data sets, which is the case in optical communications, ultra-fast photonics, optical imaging and sensing, lasers, optical metrology, design of new photonic materials, and so on. However, we would like to stress that this tutorial-review is not aimed to be a comprehensive overview of all applications of NNs (or, in more general terms, of the machine learning methods) in photonics, as this goal would be too large and general to fit into any review paper or even in a monograph. More information, details, methods, and examples of merging the photonics and artificial intelligence solutions can be found in other recent review papers covering different aspects of the subject and presenting various view-points [13-29]. How is then this tutorial-review different from numerous other review papers in the field? In this paper, we aim to improve some photonic techniques and technologies by using NNs for signal or data processing, providing analysis of the complexity and hardware implementation. We do not provide a comprehensive survey of optical reservoir computing or photonic NNs, which form a huge, rapidly expanding, and utterly fascinating area; we refer the reader to recent works and reviews on the subject [29-45], including critical opinions [46]. In particular, a good exposition of the known and potential benefits of using neuromorphic devices in place of their \u201cvon Neumann\u201d counterparts, including estimates of"}, {"title": "Basics of artificial neural networks for photonics community", "content": "In an artificial NN, several neurons are connected together in a nonlinear manner. The network learns by adjusting the weights and biases, according to the feedback (typically provided by the so-called back-propagation technique) based on the evaluation of the accuracy of the NN's prediction, which is quantified by a cost (loss) function. The number of neurons in the input layer corresponds to the input characteristics, whereas the number of output neurons is linked to the batch of classes of interest for classification; or it can be just a single neuron when we do with a single-class regression. In the deep NN structures, the layers between the input and output layer are referred to as hidden layers; the number of neurons per layer is arbitrary, and the choice of NN's hyperparameters (the number of neurons in the hidden layers and the number of hidden layers) requires designer's expertise in adjusting the NN structure to the task in hand; the choice of hyperparameters also depends on the complexity of the system to be modeled, as these parameters ultimately define the representation capability of an NN. For convenience of presentation, in this section, we briefly revisit some basic types and features of artificial NNs that will be discussed throughout the paper.\nHowever, we note that in spite of the (deceptive) simplicity of the short description of NNS given above, there are a plethora of unresolved puzzles and problems in the theory of deep NN, which typically relate to the three fundamental deep NN challenges: expressibility, optimizability,"}, {"title": "Dense Layer", "content": "We start from the basic feedforward NN, the so-called multi-layer perceptron (MLP). The simplest variant of the perceptron idea was first developed in 1943 by McCulloch and Pitts [48], but this concept drew the essential attention of scientific society only after Frank Rosenblatt's implementing it as a machine built in 1958 [49]. While Rosenblatt used just a single layer of neurons for binary prediction, nowadays, the perceptron's original idea has been largely generalized, such that it evolved into a (deep) feed-forward densely-connected multilayer structure that we call the MLP.\nA dense layer, also known as a fully connected layer, is a layer in which each neuron (labeled as i) is connected with all the neurons (labeled as j) from the previous layer with a specific weight $W_{ij}$. The input vector is mapped to the output vector in a nonlinear manner by the dense layer, due to the presence of a non-linear activation function. Dense layers can be combined to form an MLP, which is a class of a feed-forward deep NN. Fig. 1 illustrates the working operation of a single neuron in such a dense layer.\nThe output vector y of a dense layer, given x as an input vector, is written as:\n$y = \\phi(Wx + b)$, (1)\nwhere y is the output vector, $\\phi$ is a nonlinear activation function, W is the weight matrix, and b is the bias vector.\nNow, let us turn to the hardware implementation aspect of this most prolific NN structure, where we first mention the electronic implementation. The traditional matrix multiplier-and-accumulator (MAC) is used for the implementation of such layers in the digital domain [50]. More recently, the electrical analog implementation of a dense layer was demonstrated using a CMOS with transistors and resistors [51,52], or using an operational transconductance amplifier [53]. As a drawback, the analog NNs' implementation typically renders a lower accuracy and is more sensitive to noise compared to their digital counterparts [54].\nNow, we mention that there are two different elements of the NN processing that are addressed in the photonic feed-forward NN implementation: the matrix-vector multiplications, and the activation function. First, we address the differences in the activation function. The first widely adopted approach for the activation of photonic NNs, which can be called a \"fully-analog\" implementation, entails utilizing silicon photonic meshes comprising the networks of Mach-Zehnder interferometers and programmable phase shifters (electro-optic activations). However, lately, a novel approach for the activations coined \"hybrid\" photonic programmable NNs has emerged, demonstrating remarkable features in terms of low latency and energy efficiency for"}, {"title": "Convolutional Neural Networks", "content": "In a convolutional NN (CNN), we apply the convolutions with different filters to extract the features and convert them into a lower-dimensional feature set, The CNNs can be used in 1D, 2D, or 3D network arrangements depending on the applications. Here we focus on 1D-CNNs, which are applicable to, e.g., processing sequential data [64]. The 1D-CNN processing with padding equal to 0, dilation equal to 1, and stride equal to 1, can be summarized as the following transformation:\n$y_i = \\Phi(\\sum_{n=1}^{n_i} \\sum_{j=1}^{n_k} x_{i+j-1,n} K_{j,n} + b^f_i)$, (4)\nwhere $y_i$ denotes the output, known as a feature map, of a convolutional layer built by the filter f in the i-th input element, $n_k$ is the kernel size, $n_i$ is the size of the input vector, $x_{in}$ represents the raw input data, $k^f_j$ denotes the j-th trainable convolution kernel of the filter f and $b^f$ is the bias of the filter f.\nIn the general case, the additional parameters, such as padding, dilation, and stride, also affect the output size of the CNN. The padding adds information (often zeros) to the empty points around the edges of an input signal so that its size stays the same after the convolution operation. The dilation and stride affect how the kernel operation will behave in the convolution. The dilation \"inflates\" the kernel by adding holes between the kernel elements, and the stride controls"}, {"title": "Vanilla Recurrent Neural Networks", "content": "Vanilla RNN is different from MLP and CNN in terms of its ability to handle memory, which is quite beneficial for time series analysis and prediction. Here, we note that the feedforward models (e.g., those described above) can be reckoned, according to J. L. Elman [67], as an \"... attempt to \"parallelize time\" by giving it a spatial representation... However, there are problems with this approach, and it is ultimately not a good solution. A better approach would be to represent time implicitly rather than explicitly.\u201d The recurrent structures described in the following subsections do that implicit representation, Fig. 5: RNNs take into account the current input and the output that the network has learned from the prior input. The propagation step for the vanilla RNN at the time step t, can be described as follows:\n$h_t = \\phi(W x_t + U h_{t-1} + b)$, (9)\nwhere $\\phi$ is again the nonlinear activation function, $x_t \\in R^{n_i}$ is the $n_i$-dimensional input vector at time t, $h_t \\in R^{n_h}$ is a hidden layer vector of the current state with size $n_h$, $W\\in R^{n_h \\times n_i}$ and $U \\in R^{n_h \\times n_h}$ represent the trainable weight matrices, and b is the bias vector. For more explanations on the vanilla RNN operation, see, e.g., Ref. [68]. Even though the RNNs were tailored for efficient memory handling, they still suffer from the inability to capture the long-term dependencies because of the infamous vanishing gradient issue [69].\nIn addition to the mathematical description of such a layer, when designing sequence modeling algorithms (i.e., the algorithms involving recurrent layers), it is crucial to consider whether the training architecture is stateless or stateful [70\u201372]. Fig. 6 schematically illustrates how both architecture types work. The primary difference between these two architectures is how the first state ($h_0$) of the model (corresponding to each batch) is initialized as the training advances from one batch to the following one. Considering that the input share of these sequential data is $input = [batchsize,timelength = M, input features]$, in both architectures, for each batch of data, we utilize M recurrent cells in forward propagation. However, in the stateless architecture, every batch initializes the first state as $h_0 = 0$. This causes the model to forget the prior batch's learning. This design is utilized when the i.i.d. assumption for the data distribution is true\u00b9. This means that when building the training batches, there is no interdependence between the batches, and each batch is independent. This is not to be confused with the parameters/weights, which have already propagated through the entire training process, which is the goal of training. Nevertheless, not all sequential data, such as time series, contain non-i.i.d. samples; hence, it is not reasonable to always presume that the divided batches are completely independent.\n'This is similar to other supervised learning methods where we assume that each batch of the dataset you pass, is i.i.d. with respect to each other."}, {"title": "Long Short-Term Memory Neural Networks", "content": "LSTM is an advanced type of RNN. While RNNs suffer from short-term memory issues, the LSTM network has the ability to learn long-term dependencies between time steps (t), insofar as it was specifically designed to address the gradient problems encountered in RNNs [92,93]. LSTM networks are made up of LSTM cells, which are units that contain a series of gates that\ncan control the flow of information into and out of the cell, as shown in Fig. 7. The gates can learn to keep relevant information and discard irrelevant information, allowing the LSTM cell to remember important information for long periods of time. More specifically, there are three types of gates in an LSTM cell: an input gate ($i_t$), a forget gate ($f_t$), and an output gate ($o_t$). More importantly, the cell state vector ($C_t$) was proposed as a long-term memory to aggregate relevant information throughout the time steps.\nThe LSTM equation, as shown in Eq. (13), describes the computations involved in a single time step of an LSTM model. The input at time step t, $x_t \\in R^{n_i}$, is processed by the LSTM model to produce an output at time step t, $h_t \\in (-1,1)^{n_h}$. The subscript t denotes the current time step, while t \u2013 1 denotes the previous time step.\n$i_t = \\sigma(W^i x_t + U^i h_{t-1} + b^i)$, \n$f_t = \\sigma(W^f x_t + U^f h_{t-1} + b^f)$, \n$o_t = \\sigma(W^o x_t + U^o h_{t-1} + b^o)$, \n$C_t = f_t \\odot C_{t-1} + i_t \\odot \\phi(W^c x_t + U^c h_{t-1} + b^c)$, \n$h_t = o_t \\odot \\phi(C_t)$, (13)\nwith $\\odot$ being the element-wise (Hadamard) multiplication, where $\\phi$ is usually the \"tanh\u201d activation functions, $\\sigma$ is usually the sigmoid activation function, the sizes of each variable are $x_t \\in R^{n_i}, f_t, i_t, o_t \\in (0,1)^{n_h}, C_t \\in R^{n_h}$ and $h_t \\in (-1,1)^{n_h}$.\nTo explain further, the LSTM equation above is divided into 5 stages. First, the input gate controls the flow of information into the memory cell. It takes the input $x_t$ and the previous hidden state $h_{t-1}$ as inputs, and produces an output $i_t \\in (0, 1)^{n_h}$ that represents the degree to which the input should be written to the memory cell. Second, the forget gate controls the flow of information out of the memory cell. It takes the input $x_t$ and the previous hidden state $h_{t-1}$ as inputs, and produces an output $f_t \\in (0,1)^{n_h}$ that represents the degree to which the previous cell state $C_{t-1}$ should be retained. Next, the output gate controls the flow of information out of the memory cell. It takes the input $x_t$ and the previous hidden state $h_{t-1}$ as inputs, and produces an output $o_t \\in (0,1)^{n_h}$ that represents the degree to which the current cell state $C_t$ should be outputted. Then, the memory cell $C_t$ is responsible for storing and updating information over time. It takes the input $x_t$, the previous hidden state $h_{t-1}$, and the previous cell state $C_{t-1}$ as inputs, and produces a new cell state $C_t \\in R^{n_h}$ that integrates the current input and the previous memory. Finally, the hidden state $h_t$ is the output of the LSTM model at time step t. It takes the current cell state $C_t$ and the output gate $o_t$ as inputs, and produces an output $h_t \\in (-1,1)^{n_h}$ that represents the current hidden state of the LSTM model."}, {"title": "Gated Recurrent Units", "content": "Introduced in 2014 [94], the GRU network, similar to the LSTM, was designed to overcome the short-term memory issues of RNNs. However, the GRU is less complex than the LSTM7, as it has only two types of gates: the reset ($r_t$) and update ($z_t$) gates, as shown in Fig. 8. The reset gate is used to handle short-term memory, whereas the update gate is responsible for long-term memory [96]. In addition, the candidate hidden state ($\\hat{h}$) is also introduced to measure how relevant the previous hidden state is to the candidate state. The GRU for a time step t can be formalized as:\n$z_t = \\sigma(W^z x_t + U^z h_{t-1} + b^z)$,\n$r_t = \\sigma(W^r x_t + U^r h_{t-1} + b^r)$,\n$\\hat{h}_t = \\phi(W^h x_t + r_t \\odot U^h h_{t-1} + b^h)$,\n$h_t = z_t \\odot h_{t-1} + (1 - z_t) \\odot \\hat{h}_t$, (14)\nwhere $\\phi$ is typically the \"tanh\u201d activation function and the rest of the designations are the same as in Eq. (13).\nIn addition to (14), defining the so-called fully gated unit, the simpler GRU architecture variants called minimal gated unit are also sometimes used [97]: in these types, the reset, and update gates are merged. Some other GRU variants are described and compared in Ref. [96]."}, {"title": "Echo State Networks", "content": "Echo state networks (ESNs) belong to the class of recurrent structures, more specifically, to the reservoir computing category [98]. The ESN was proposed to simplify the training process while staying efficient and simple to implement. The ESN comprises three layers: an input layer, a recurrent layer, known as a reservoir, and an output layer, which is the only layer that is trainable. The reservoir with random weights assignment is used to replace back-propagation in traditional NNs to reduce the computational complexity of training [99]. We notice that the"}, {"title": "Attention Layers", "content": "Attention is an NN mechanism that observes a whole collection of data and selectively focuses on a subset of the collection. In other words, attention mechanisms are a way to allow a model to focus on specific parts of its input when processing it, rather than using the entire input equally. The attention unit is schematically represented in Fig. 11. It was first applied to sequence-to-sequence learning in [105] and was used mostly to further exploit the importance of each subset among the input data. In other words, attention is one add-on component of a network's architecture, in charge of managing and quantifying the interdependence between the data of interest. General attention investigates the interdependence between input and output elements, whilst self-attention deals with finding correlations among input elements [106-108].\nLet us turn to the case of general attention to account for the interdependence between the final predicted symbol and both the input symbols and the output hidden states. By adding such an attention mechanism, we expect to find the contribution of the input symbols and their hidden representations to the final received symbol prediction. Therefore, we can identify the essential part of the input sequence for training that could lower the computational complexity.\nThe attention is generally a single- or multi-layer feed-forward NN with trainable weights and"}, {"title": "Transformers", "content": "The vanilla transformer is a deep learning architecture that was introduced in Ref. [109]. Its architecture is shown in Fig. 12. The transformer is a sequence-to-sequence model that operates on sequences of vectors, where the goal is to learn a mapping from one sequence to another. The key innovation of the transformer is the use of the previously mentioned self-attention mechanism, which allows the model to weigh the importance of different parts of the input sequence when generating the output sequence. In a nutshell, the transformer consists of an encoder and a decoder. The encoder takes the input sequence and produces a sequence of hidden representations, which are then used by the decoder to generate the output sequence. The self-attention mechanism is used in both the encoder and the decoder, allowing the model to attend to different parts of the input sequence when generating each element of the output sequence. The vanilla transformer can be expressed mathematically as follows:\nLet $X = {x_1,x_2, ..., x_n}$ be the input sequence, where $x_i$ is a vector of dimension $d_{model}$, so the shape of X is [$n \\times d_{model}$]. Similarly, let $Y = {y_1, y_2, ..., y_m}$ be the output sequence, where $y_j$ is a vector of dimension $m \\times d_{model}$.\nThe encoder consists of N identical layers, where each layer has three sub-layers: a multi-head self-attention mechanism, an Add&Norm layer, and a position-wise fully connected feed-forward network. The output of the ith layer of the encoder is denoted as $H_i = {h_{i,1}, h_{i,2}, ..., h_{i,n}}$, where $h_{i, j}$ is a vector of dimension $n \\times d_{model}$.\nThe multi-head self-attention mechanism can be expressed as:"}, {"title": "Residual Neural Networks", "content": "An artificial neural network becomes a Residual Neural Network (ResNet) [110] if the input of a specific layer is also passed (or skipped) to another deeper layer in the network; this connection is called a residual connection. The utilization of skip connections or shortcuts, visually illustrated in Fig. 13, is a distinctive feature of ResNets. These connections facilitate the bypassing of specific layers, thereby addressing challenges like vanishing gradients and promoting more efficient training within deep architectures.\nAnother famous architecture that uses residual connections is the HighwayNet [113], The HighwayNet preserves the shortcuts introduced in the ResNet, but augments them with a learnable parameter to determine to what extent each layer should be a skip connection or a nonlinear connection. It is noteworthy that HighwayNets possess the capacity to autonomously learn the skip weights through an additional weight matrix governing their gates. In contrast, ResNet models are conventionally characterized by double or triple-layer skips, incorporating non-linear activation functions such as ReLU and batch normalization, which enhance the expressiveness and convergence capabilities of the models.\nAdditionally, DenseNets [114] serve as a relevant descriptive reference for models incorporating multiple parallel skip connections, underscoring the adaptability and versatility of residual connections in contemporary neural network designs.\nLet us now define what is the feed-forward equations for such a type of NN layer. Given the weight matrix $W^{l-1,l}$ for the connection weights from layer l \u2013 1 to l, and the weight matrix $W^{l-2,l}$ for the connection weights from layer l \u2013 2 to l, then the forward propagation through"}, {"title": "Radial basis function neural network", "content": "A radial basis function (RBF) network is an artificial NN that uses the RBFs as activation functions. Its schematics and a comparison of RBF function and sigmoid function are given in Fig. 15. The network output is a linear combination of input RBFs and neuron parameters. The concept itself was introduced by Broomhead and Lowe in 1988 [117]. There are numerous applications for RBF networks, including function approximation, time series prediction, classification, and system control. Even though the RBF concept is considerably old and familiar, and, often, the other NN types are preferred nowadays, it still attracts the attention of data scientists [118].\nThe RBF networks typically have three layers: an input layer, a hidden layer with a non-linear RBF activation function and a linear output layer [119]. The input can be modeled as a vector of real numbers $x \\in R^n$. The output of the network is then a scalar function of the input vector, $\\varphi$: $R^n \\rightarrow R$, and is given by:\n$\\varphi(x) = \\sum_{i=1}^{N} a_i \\rho(||x \u2013 c_i||)$,\nwhere N is the number of neurons in the hidden layer, $c_i$ is the center vector for neuron i, and $a_i$ is the weight of neuron i in the linear output neuron. Functions that depend only on the distance from a center vector are radially symmetric about that vector, hence the name radial basis function. In the basic form, all inputs are connected to each hidden neuron. The norm is typically taken to be the Euclidean distance (although the Mahalanobis distance [120] appears to perform better with pattern recognition) and the radial basis function is commonly taken to be a Gaussian function:\n$\\rho (||x \u2212 c_i||) = exp [\u2212\\beta_i ||x \u2212 c_i||^2]$.\nThe Gaussian basis functions are local to the center vector in the sense that\n$\\lim_{||x|| \\rightarrow \\infty} \\rho (||x - c_i||) = 0$,\ni.e., changing the parameters of one neuron has only a small effect on input values that are far away from the center of that neuron.\nThe RBF networks are the universal approximators on a compact subset of $R^n$ under certain modest restrictions regarding the activation function shape. This implies that an RBF network with sufficient hidden neurons can approximate any continuous function on a closed, constrained set with arbitrary accuracy [121].\nIn addition to the unnormalized architecture mentioned, the RBF networks can be normalized. In this case, the mapping is\n$\\varphi(x) \\stackrel{\\text{def}}{=} \\frac{\\sum_{i=1}^{N} a_i \\rho(||x - c_i||)}{\\sum_{i=1}^{N} \\rho(||x \u2013 c_i||)} = \\sum_{i=1}^{N} a_i \\mu (||x \u2212 c_i ||),"}, {"title": "Autoencoders", "content": "Autoencoders are the NN architectures that are trained to reconstruct their inputs. A basic architecture of an autoencoder is shown in Fig. 16. In a more formal description, consider that the data X is encoded by $\\phi$ to a latent representation Z, which is passed through a \"bottleneck\". In this sense, this first part can be summarized by an encoder NN $g_{\\phi}(.)$. The bottleneck output is decoded terminating with an output layer with the same dimensionality as the encoder's input layer (X), a reconstruction of X. Here, the decoder part can be described as $f_{\\theta}(.)$. It is important to highlight that without the bottleneck, the encoder, and decoder would copy their input to the output, and by having a bottleneck, the encoder compresses the data to a latent representation that is more robust. The bottleneck appears in many autoencoder variations [122-124]. Regarding the training, both encoder and decoder NNs are simultaneously trained by minimizing a reconstruction loss function. The loss function will depend on the nature of X and the task at hand. If X has n features with continuous values, this problem can be understood as a regression problem and one of the possible loss functions is the MSE:\n$L_{MSE}(x, \\hat{x}) = \\frac{1}{n} \\sum_{i=1}^{n}[(x_i \u2013 f_{\\theta} (g_{\\phi} (x_i)))^2]$. (27)\nHowever, if the data X is discrete, two possible tasks can be performed: multi-class classification or multi-label classification. In the first case, X is categorical in nature and is described by a"}, {"title": "Generative Adversarial Network", "content": "The idea behind the generative adversarial networks (GAN) was based on the concept of zero-sum game theory [134].\nAs shown in Fig. 17, the framework of GAN consists of two neural network models: a generative model called a generator that captures the data distribution, and a discriminative model that distinguishes whether a sample came from the real dataset or from a generated (\u201cfake\u201d) one. In a nutshell, the generator aims to learn the distribution of real data, while the discriminator aims to correctly determine whether the input data is from the real data or from the generator. In order to win the game, the two participants need to continuously optimize themselves to\nimprove the generation ability and the discrimination ability, respectively. Therefore, during the training procedure, the two models compete with each other. The generator is designed to generate data as realistically as possible so that it is difficult to distinguish them from the truth, while the discriminator as a binary classifier aims to identify real and fake data as accurately as possible. The generator and discriminator are optimized alternately until the augmented data is indistinguishable from the actual data [135\u2013137]. In other words, drawing upon the principles of game theory, GANs utilize a minimax strategy, where the generator and discriminator networks strive to optimize their respective objectives, resulting in a dynamic equilibrium. This competitive nature of GAN training resembles a zero-sum game, in which the gains made by one network come at the expense of the other. However, it is important to note that GANs, in their formal definition, may not strictly adhere to the conditions of a zero-sum game. In a zero-sum game, the total utility or payoff remains constant, and any gain by one player directly corresponds to a loss for the other player. In contrast, the training process of GANs does not necessarily maintain a fixed overall utility.\nIn a more mathematical formulation, to learn the generator distribution $p_g$ over data x with distribution $p_x(x)$, a prior to input noise variables is defined as $P_z(z)$, where z is the noise variable. Then, the generator represents a mapping from noise space to data space as $G(z, \\theta_g)$, where G is a differentiable function represented by a NN with parameters $\\theta_g$. The other NN, $D(x, \\theta_d)$, is also defined with parameters $\\theta_d$, but the output of D(x) is a single scalar. D(x) denotes the probability that x comes from the data rather than from the generator G. The discriminator D is trained to maximize the probability of assigning a correct label to both real training data and fake examples generated by the generator G. Simultaneously, G is trained to minimize log(1 \u2013 D(G(z))). Therefore, the optimization of a GAN can be formulated as a minimax problem:\n$\\min_{G} \\max_{D} {E_{x} [log D(x)] + E_{z} [log(1 \u2013 D(G(z)))]}$, (30)\nwhere E[...] represents the expectation value.\nIn practice, the training for such structures is inherently unstable, such that an alternative training method is used. In a nutshell, this alternative training occurs in two stages: freeze the $\\theta_g$ parameters and optimize $d_a$ to maximize the discrimination accuracy of D; froze the $\\theta_d$ parameters and optimize $\\theta_g$ to minimize the discrimination accuracy of D. This process alternates and we could achieve the global optimal solution if and only if $p_x = p_g$.\nFinally, it is important to highlight some of the best practices when using this type of structure [138]:\n\u2022 Scale properly the real data x and the Generator output G (z, $\\theta_g$). A problem at this step can cause sample oscillation and model instability. So, it is recommended to avoid applying batchnorm to the generator output layer and the discriminator input layer."}, {"title": "How to Choose your NN Architecture: The Hyperparameter Search", "content": "One of the most important steps in the NNs is the design of the NN architecture. Indeed, the hyperparameters of the NN model (e.g., number of layers, number of neurons, type of activation function"}]}