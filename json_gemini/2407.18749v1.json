{"title": "Multi-Robot System Architecture Design in SysML and BPMN", "authors": ["Ahmed R. Sadik", "Christian Goerick"], "abstract": "Multi-Robot System (MRS) is a complex system that contains many different software and hardware components. This main problem addressed in this article is the MRS design complexity. The proposed solution provides a modular modeling and simulation technique that is based on formal system engineering method, therefore the MRS design complexity is decomposed and reduced. Modeling the MRS has been achieved via two formal Architecture Description Languages (ADLs), which are Systems Modeling Language (SysML) and Business Process Model and Notation (BPMN), to design the system blueprints. By using those abstract design ADLs, the implementation of the project becomes technology agnostic. This allows to transfer the design concept from on programming language to another. During the simulation phase, a multi-agent environment is used to simulate the MRS blueprints. The simulation has been implemented in Java Agent Development (JADE) middleware. Therefore, its results can be used to analysis and verify the proposed MRS model in form of performance evaluation matrix.", "sections": [{"title": "1. Introduction", "content": "This paper extends the work presented at the 2019 International Conference on Mechatronics, Robotics, and System Engineering (MORSE) [1]. Related work can be also seen in [2].\nMulti-Robot System (MRS) is a cyber-physical system that contains more than one robot, each of them owns a unique set of capabilities. The idea of an MRS is to solve a complex problem by collectively using the current capabilities of existing robots [3]. Therefore, the MRS must match the given problem with the existing robots' capabilities, to plan the solution steps. Many MRS applications can be seen in swarm robotics, cooperative automated transportation, unmanned aerial vehicles, and cooperative manufacturing [4]. The advantages of an MRS is increasing the performance by saving the time and the effort to solve the problem. Moreover, distributing the solution among different robots provides more computational processing power, this means faster and higher capacity to solve many problems simultaneously [5].\nImplementing an MRS without a proper system architecture design is a crucial mistake that is often done by the system developers. Because the system requirements and functionalities are lost in a non-human readable machine code. Therefore, in this article we purpose a model driven development approach that uses the system model as the main software artifacts [6]. The proposed design approach in this article is based on the V-Model, which is a de facto solution for complex systems such as MRS.\nThe V-Model shown in Figure 1 describes the required stages to build an MRS. In the first stage of the V-Model, the system is decomposed. In this stage, the system components and architecture are designed based on the system requirements. In the second stage, the implementation of the MRS is carried out. The implementation of an MRS often involves the coding the individual components. In the final stage, the MRS individual components are tested through unit tests, then integration tests are carried out over sub-systems and eventually the overall integrated system. This article focusses on the first stage of the V-Model to build an MRS. As the design stage is the most curtail stage of an MRS system building, because all the following stages are depending on this design."}, {"title": "2. Problem and use case", "content": "Section 2 of the article describes the problem and the use case of concern. Section 3 introduces the background that that is needed to model and simulate the use case. Section 4 discusses the system requirements that are used to build and evaluate the system performance Modeling the use case is explained in detail in section 5, while its simulation is shown in section 6. Therefore, the performance analysis is explained in section 7. Ultimately, the last section concludes the work and the future research.\nThe main article objective is to design an MRS architecture model that can be simulated and evaluated due to a predefined evaluation criterion. An MRS architecture is an overall system description that abstracts its functionalities, logic, and constrains [7]. Accordingly, it provides an analysis tool to grasp and improve system characteristics, and a conceptual model that can be used as the system blueprints [8]. In this work, SysML block definition diagram is used to describe the proposed MRS architecture and components as shown in Figure 2 and Figure 3. SysML diagrams will be explained in the next section as many of them are used in constructing the proposed MRS design.\nFigure 2 is the the proposed MRS block definition diagram. The block definition diagram defines the main components of the architecture, which are the Requests Manager (RqM), the planner (PLN), and the Robots Manager (RbM). Figure 3 shows the proposed MRS internal block diagram that describes the connections among the components as illustrated in Figure 2. When the RqM receives a request (Rq), it checks if there is a plan-blueprint (Pb) in the Knowledge Base (KB) to fulfill this Rq. A Pb is a sequence of tasks (T), i.e., Pb\u2081 = {T\u2081,...,Tn}, where n is the number of tasks and could be different from one blueprint to another. A task is a function of the capabilities (C) of the robot (R), i.e., T\u2081 = f (Cx, Cy, ...), where each robot owns different capabilities set. If the RqM finds a match between Pb to and a Rq, it forwards the Pb to the PLN. The PLN checks the robots' availability, and their capabilities to achieve the tasks in the Pb. If more than a robot owns the capabilities to fulfill the task, the PLN compares the number of tasks that have been achieved by these robots in the past. Based on this comparison, the PLN selects a robot to assign for the task. If the PLN complete the matching of all the tasks with the robots, it sends a verified plan (Pv) to the RbM. The RbM sends the tasks to the robots and waits their response.\nThe use case diagram in Figure 4 shows three variation types that are considered during the simulation. First is the Pbs variation, by adding, editing, or omitting a Pb. Second is variation in the number of the available robots. The maximum number of robots that can exist is constrained to three. The robots are constrained to register or deregister through the RbM. Third is the variation in the robots' capabilities, by updating or editing the capabilities of a robot. the robot is constrained to deregister to be able to update its capabilities, then register again through the RbM, which automatically updates the robot new capabilities in the KB."}, {"title": "3. Solution preliminaries", "content": "Section 2 of the article describes the problem and the use case\nof concern. Section 3 introduces the background that that is needed\nto model and simulate the use case. Section 4 discusses the system\nrequirements that are used to build and evaluate the system\nperformance Modeling the use case is explained in detail in section\n5, while its simulation is shown in section 6. Therefore, the\nperformance analysis is explained in section 7. Ultimately, the last\nsection concludes the work and the future research.\n3.1. Systems Modeling Language\nSysML is a general-purpose modeling language that is derived\nfrom Unified Modeling Language (UML) [9]. SysML and UML\nbelong are both developed by Object Management Group (OMG).\nUML is is a visual modeling language that is particularly used to\nconstruct, design, and document the software systems in fields\nsuch as web-development, telecommunication, banking, and\nenterprise services [10]. While SysML is extending and modifying\nUML diagrams to fit complex industrial systems that involve\nvariety of hardware, software, information, and processes (e.g.,\nAviation, Space, Automotive) [11].\nFigure 5 shows the relation between SysML and UML graphs\n[12]. Requirement and parametric diagram are two new diagrams\nthat distinguish SysML [13]. Section 4 of this article used the\nrequirement diagram to define the system performance criteria\nrequirements and their relations. Block definition diagram and\n3.2. Business Process Model and Notation\nSince UML activity diagram provides an abstract high-level\nprocess description, BPMN extends the UML activity diagram to\nfulfill the following two drawbacks. First, UML activity diagram\nlakes the syntax and the logical execution among the actions.\nSecond, the poverty in UML notations and semantics in\ncomparison with BPMN [14].\nFlow control gateways is the best example to demonstrate how\nBPMN is improving UML activity diagram. Flow control\ngateways are all equivalent to only one notation in UML, which is\nthe decision notation. Table 1 shows the notations, semantics, and\nsyntax of the basic gateways of BPMN. Three different notations\nare demonstrated in Table 1, which are exclusive-OR, inclusive-\nOR, and parallel-AND. The three mentioned gates operate either\nas spilt or merge context. In spilt context, exclusive-OR splits one\ninput to only one output based on the conditions on the output\nbranches. Inclusive-OR splits one input to more than one output\nsimultaneously based on the conditions on the output branches.\nParallel-AND splits one input to all the output simultaneously\nwhen the input branch is triggered. In merge context, exclusive-\nOR merges any of the input branches to only one output, when any\nof the input branches is triggered. Inclusive-OR merges more than\none input branches to only one output, when these inputs are\nsimultaneously triggered. Parallel-AND merges all the input\nbranches to only one output, when all the inputs are simultaneously\ntriggered [15].\n3.3. Java Agent Development\nJADE is a Multi-Agent System (MAS) middleware [16] that\nhas been used in this research to deploy the proposed solution as\nshown in Figure 6-a. Each entity in the proposed SysML internal\nblock diagram is implemented as a JADE agent. JADE Agent\nManagement System (AMS) address each agent with a unique\nIdentifier (AID) to facilitate the communication among the agents.\nWhile JADE directory Facilitator (DF) announces the services that\nevery agent afford. JADE applies the Foundation for Intelligent\nPhysical Agent (FIPA) specifications, to enable agent\ncommunication through FIPA-Agent Communication Language\n(FIPA-ACL) [17].\nEach JADE agent has a complex individual behaviour that can\nbe seen as a composite of two simple behaviours. First is one-shot\nbehaviour that is executed only once when it is triggered. Second\nis a cyclic behaviour that continuously executed when it is\ntriggered. An example of JADE agent communication and\ndecision making based on their behaviours can be seen in Figure\n6-b. JADE is a suitable tool to build an agent simulation based on\nthe MRS SysML/BPMN model. As the MRS logic and\narchitecture can be easily translated to JADE implementation\nconcepts [18]."}, {"title": "4. Performance requirements", "content": "To evaluate the MRS design, it is necessary to measure the\nsystem performance during the simulation. Qualitative criteria\nsuch as reusability, scalability, extensibility, and interoperability\nhave been proposed in [19]. However, these criteria are often\nrelatively vague without quantitative performance measurements.\nTherefore, this research defines the quantitative indicators that are\nshown in Figure 7. The research assumes that the MRS is a black\nbox that receives different Rq, that can either success or fail during\nthe execution. The following measurements can be used to express\nthe system performance:\n\u2022\nThroughput: the number of requests that are processed.\n\u2022\nLatency: the time needed from the request arrival till the\nrequest execution.\n\u2022\nSuccess rate: the number of request that success to be\nexecuted per the overall received requests number.\n\u2022\nFailure rate: the number of request that fail to be executed\nper the overall received requests number.\n\u2022\nEfficiency: the ration between the success rate and the\nfailure rate.\nThe robot performance is also considered in this research as\nanother measurement of the MRS performance [20]. The robot\nperformance is fundamentally derived from its state machine\ndiagram that is shown in Figure 8. The the robot state machine is\nbuilt upon measuring the following times:\n\u2022\nControlled time (Tc): the time that the robot needs to\nperform an assigned task.\n\u2022\nUncontrolled time (Tunc): the robot waiting time to be\nassigned to a task after registration.\n\u2022\nRegistered time (Tr): the sum of the controlled and the\nuncontrolled time of the robot.\n\u2022\nUnregistered time (Tunr): the accumulation of the robot\nunregistered time.\n\u2022\nOverall time (Tov): the sum of the registered and the\nunregistered time of the robot.\nAccordingly, the robot performance criteria are calculated as\nfollows:\n\u2022\nAvailability: the ration between the robot registered time\n(Tr) and the overall time (Tov).\n\u2022\nUtilization: the ratio between the robot controlled time (Tc)\nand the overall time (Tov).\n\u2022\nEffectiveness: the ration between the robot controlled time\n(Tc) and the uncontrolled time (Tunc)."}, {"title": "5. System model", "content": "5.1. Requests manager\nThe RqM receives requests from various requestors, then it\nlooks for an associated Pb within the KB. If the RqM finds the\nassociated Pb, it forwards it to the PLN. The RqM decision making\nmodel is shown in Figure 9 via the BPMN activity diagram.\nThe RqM uses First Come First Serve (FCFS) technique to\nschedule the received requests. The RqM checks in the associated\nPb for every received request. If there is no associated Pb with the\nrequest, the RqM directly sends a negative feedback to the\nrequestor. If the RqM finds an associated Pb to the request, it\nforwards this Pb to the PLN, and waits for the feedback. If this\nfeedback exceeds predefined limits, the RqM considers this\nrequest as a failure one. If not, it waits the execution feedback to\nforward it to the requestor.\n5.2. Planner\nThe PLN receives the Pb and makes sure that it is visible to\nbuild a Pv instance according to the current system status. The PLN\ndecision making model is shown in Figure 10 via the BPM\u039d\nactivity diagram.\nTo construct a Pv instance from a Pb, The PLN checks the\navailable registered robots, the robots' capabilities, and the robots'\ntasks history. In case that there is only one available robot, the PLN\ndirectly considers a plan failure, as it is known in advance that a\nplan requires at least two robots to get executed. If at least two\nrobots are available, the PLN compares the tasks in the Pb to the\navailable robots' capabilities. If the robots' capabilities do not\nmatch the required tasks in the Pb, the PLN considers a plan\nfailure. If there are two robots or more that can perform the same\ntask, the PLN checks their tasks history, and assign the task to the\nrobot that performed less tasks. This is to balance the task\nassignment among the available robots within the MRS. If all the\ntasks in the Pb could be assigned to robots, the PLN creates a Pv\ninstance and sends it is the RbM to be executed.\n5.3. Robots Manager\nThe RbM receives the Pv, then it assigns the tasks in this Pv to\nthe available robot. Additionally, the RbM is also responsible for\nregistering/unregister the robots from the MRS. this way it\nmonitors the robots' availability. The RbM decision making model\nis shown in Figure 11 via the BPMN activity diagram.\nWhen the RbM assigns a task to a robot, it waits the robot\nfeedback within a time limit. If the robot feedback did not arrive\nwithin the predefined limits, the RbM sends a negative feedback\nto the RqM. This feedback means that the whole plan is failed to\nbe executed. If the RbM received a positive feedback from the\nrobot within the predefined time limits, it assigns the next task due\nto the Pv. If all the tasks in the Pv are executed, the RqM sends a\npositive feedback to the RqM, otherwise it sends a negative\nfeedback."}, {"title": "6. Simulation", "content": "The activity diagrams that have been illustrated in the previous\nsection are used as the MRS blueprints. JADE has been used in\nthis research to deploy these blueprints, and hence enables the\nMRS simulation during the design phase. The Graphical User\nInterface (GUI) shown in Figure 12 has been created to achieve\ninteract with every entity in the proposed architecture. The RqM\nGUI in Figure 12-a can be used to add/edit/remove the Pb. The\nPLN GUI in Figure 12-b is used to monitor the Pv execution, the\nrobots' availability, the robots' status, the robots' capabilities, and\nthe robots' tasks history. The RbM GUI in Figure 12-b is used to\nshow the assigned tasks status."}, {"title": "7. Simulation results analysis", "content": "To illustrate the simulation scenario, an interaction example\namong the MRS entities is show in Figure 13. In this example, The\nRqM receives Rq2. Therefore, the RqM sends the Pb in a form of\nthe ACL-message shown in Figure 14-a to the PLN. Accordingly,\nthe PLN constructs a Pv by matching the available robots'\ncapabilities and tasks history with the received Pb. In this case, R1\nand R3 were registered into the MRS as shown in Figure 14-b. As\nT1 needs (C1, C3, C4) to be executed, T1 was assigned to R1, because\n(C1, C3, C4) are unique capabilities of R1. Similarly, T3 was\nassigned to R3, as T3 needs (C2, C5) which is unique capability of\nR3. However, in case of T2, both R1 and R3 own the capability C2\nwhich is needed to execute this task. Therefore, the PLN checks\nboth robots' task history to be able to assign T2. The PLN finds out\nthat R\u2081 task history is 9 while R3 task history is 11. Accordingly,\nthe PLN assigns T2 to R1, to balance the robots' tasks distribution.\nUltimately, the PLN sends the Pv in form of the ACL-message\nshown in Figure 14-b to the RbM. The RbM assigns the tasks to\nthe associated robots according to the Pv. The task assignment is\nsent as an ACL-message as shown in Figure 14-c. The RbM waits\nthe robots' feedback within a timeframe window. If all the RbM\nreceived success feedbacks for all the assigned tasks, it sends a\nplan success feedback to the RqM.\nAs it has been demonstrated in the previous section, the robots'\navailability, the robot's capabilities, and the the plan blueprints are\nthe variables that can be used to build different simulation\nscenarios. Accordingly, to measure the system performance, the\nrobots' availability was randomly altered during the run time.\nThus, analyzing the simulation results has been done by running\nJADE MAS for 30 minutes as shown in Figure 15, then measuring\nthe system performance indicators that are concluded in section 4.\nEach one minute, a new request is generated, one robot randomly\nunregister from JADE MAS, and one random robot register to\nJADE MAS. the robot's capabilities and the the plan blueprints do\nnot change during the simulation scenario.\nOne of the RqM responsibilities is to monitor the requests\nstatus. The number of processed requests by the RqM is shown in\nthe graph in Figure 15-a. Accordingly, the MRS throughput can be\ndirectly calculated from this chart. On the one hand, MRS\nthroughput expresses how fast the system, therefore it is a relative\nvalue. Thus, to understand the MRS throughput, Figure 15-c and\nFigure 15-d should be considered as well. For instance, the number\nof requests at minute 4 is two requests as can be seen in Figure 15-\na. But, if we look closely into Figure 15-c and Figure 15-d, we will\nfind out that one request is success and another fail. This means\nthat, it is not important if the system is so fast, but most of the\nrequests are failed to be executed. On the other hand, MRS latency\nexpresses how much delay in the system as it can be seen in Figure\n15-e. If the system delay value is equal to zero as can be seen in\nthe 26th minutes of Figure 15-e, this means that the number of\nunprocessed requests is equal to zero as well, as can be seen in the\n26th minutes of Figure 15-b.\nThe MRS efficiency graph shown in Figure 15-f is derived\nfrom dividing the data in Figure 15-c (successful requests) by the\ndata Figure 15-d (fail requests). The MRS efficiency value is\nabsolute. When the MRS efficiency is higher than one, this means\nthat the number of success requests is higher than the number of\nfail request. Figure 15-f shows that the simulated MRS efficiency\nis higher than or equal to one during the simulation runtime.\nTable 2 can be also concluded from\nFigure 16-a. In this table, R3 is the most utilized and available robot\nduring the simulation runtime, and hence R3 is the most effective\nin comparison to R1 and R2. Accordingly, the PLN compensates\nthis variation by maximizing R\u2081 and R2 task assignment, to balance\nthem with R3."}, {"title": "8. Summary and Discussion", "content": "This article has highlighted new dimensions of the MRS design\nproblem, which are the formalization, simulation, and evaluation\nof the solution architecture. The proposed modeling approach is\nbased on a formal generic ADLs, that can be used to transfer the\nsolution concept over different system case studies, regardless the\nimplementation technology. Furthermore, the illustrated\nsimulation method can be used to verify different architecture\ndesign patterns, based on the concluded system performance\nmeasurements.\nThe fundamental SysML diagrams have been implemented to\ndesign the proposed MRS system model. Moreover, BPMN\nlanguage has been used to implement the activity diagram as it\nextends UML/SysML notations, semantics, and syntax. The\ncollection of these standard models is used as the MRS blueprints.\nThose blueprints can be easily coded in any programming\nenvironment that supports distributed system implementation. For\ninstance, JADE has been used in this research to implement these\nblueprints, however Robot Operation System (ROS) or Web\nService (WS) are very suitable candidates to deploy the system.\nA group of MRS performance requirements have been defined\nduring this article, to quantify the system performance during the\nsimulation runtime. Those criteria can are technology agonistic as\nwell, which means that they can be used to compare between the\nsystem performance when it is implemented with different\ntechnologies. Furthermore, the system simulation is not only used\nduring the design phased, but it can be reused in a form of a real\ntime digital twin during the implementation phase. For instance, to\ncheck in advance different planning and scheduling algorithms\nbefore executing them on the real system.\nUsing a formal description language such as SysML or BPMN\nenables separating the model from the code, which is a common\ndomain specific programming method. Therefore, in the future\nwork, we will write a code generator that can be used to\nautomatically generate the implementation code. Therefore, the\nmodel that has been developed in this article will turn to be\nexecutable and will be used as the main software artifact of the\nproject. This can dramatically reduce the coding time and effort\nand improve the system readability and maintainability.\nAdditionally, in the future work, the same performance\nmeasurements that have been used in this article can be used in the\nimplementation phase, as a part of the system visualization."}]}