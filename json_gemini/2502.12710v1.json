{"title": "TREND: A WHITESPACE REPLACEMENT INFORMATION HIDING METHOD", "authors": ["Malte Hellmeier", "Hendrik Norkowski", "Ernst-Christoph Schrewe", "Haydar Qarawlus", "Falk Howar"], "abstract": "Large Language Models (LLMs) have gained significant popularity in recent years. Differentiating\nbetween a text written by a human and a text generated by an LLM has become almost impossible.\nInformation hiding techniques such as digital watermarking or steganography can help by embedding\ninformation inside text without being noticed. However, existing techniques, such as linguistic-based\nor format-based methods, change the semantics or do not work on pure, unformatted text. In this\npaper, we introduce a novel method for information hiding termed TREND, which is able to conceal\nany byte-encoded sequence within a cover text. The proposed method is implemented as a multi-\nplatform library using the Kotlin programming language, accompanied by a command-line tool and a\nweb interface provided as examples of usage. By substituting conventional whitespace characters\nwith visually similar Unicode whitespace characters, our proposed scheme preserves the semantics\nof the cover text without increasing the number of characters. Furthermore, we propose a specified\nstructure for secret messages that enables configurable compression, encryption, hashing, and error\ncorrection. Our experimental benchmark comparison on a dataset of one million Wikipedia articles\ncompares ten algorithms from literature and practice. It proves the robustness of our proposed method\nin various applications while remaining imperceptible to humans. We discuss the limitations of\nlimited embedding capacity and further robustness, which guide implications for future work.", "sections": [{"title": "1 Introduction", "content": "The interest in Large Language Models (LLMs) has evolved rapidly in recent years with emerging application\npossibilities for individuals and companies. The enduring interest in digitization leads to documents directly stored in a\nmachine-readable format that can be processed with LLMs instead of manually processed paper printouts stored in file\nfolders. However, it is becoming increasingly difficult to protect intellectual property, especially when data is shared:\n\"The proliferation of AI-generated content is one of the biggest issues facing the internet today. Recent breakthroughs\nin large language models have made it increasingly difficult to distinguish this influx of AI-generated content from\nhuman-generated content\" [11, p. 325]. Therefore, keeping control over data is vital, often discussed under the umbrella\nterm data sovereignty [19, 22, 52]. Information-hiding techniques such as digital watermarking or steganography can\nhelp to tackle those issues by hiding information in a cover document [5, 7, 32, 36, 38].\nDifferent researchers and practitioners have developed methods for hiding data in different files such as images, video,\naudio, or the most challenging text files [7, 10]. Those techniques can be classified as watermarking or fingerprinting\nmethods focusing on robustness, storing copyright information, and securing intellectual property and steganography\nmethods focusing on imperceptibility, encoding information, and inconspicuousness [7, 36, 38, 41]. To hide information"}, {"title": "2 Background", "content": "This section introduces relevant terminologies and the nomenclature needed for the understanding of this work."}, {"title": "2.1 Watermarking & Steganography", "content": "Distinguishing between different terminologies in the domain of cryptography and information hiding is crucial and has\nmultifacetedly been discussed in literature [1, 5, 36, 41, 42]. Starting with the broadest concept: \u201cInformation hiding is\nthe science of concealing a secret message or watermark inside a cover media (a host file/message) for providing various\nsecurity purposes such as content authentication, integrity verification, covert communication, and so on\" [5, p. 56].\nSince information hiding can further be divided into steganography and watermarking, it differs from cryptography\nbecause its root is not about transforming plain text into an encrypted cipher text [1]. A detailed survey and classification\nis published by Petitcolas et al. [36].\nThe ability of a secret message to be hidden inside a cover text \u201cin a way that one cannot detect it\u201d [7, p. 6367] forms the\nterm steganography. Those methods can be classified into character-level, bit-level, or a mixture of both categories [28],\nleading to the following definition: \"Steganography embeds a secret message inside an innocent looking cover medium,\nstealthily, without creating any attention. The cover medium used can be a text, image, audio, video, network packets,\netc.\" [28, p. 1].\nIn contrast, digital watermarking focuses on \"a visible or an invisible, preferably the latter, identification code that\npermanently is embedded in the data\" [21, p. 230]. Those data assets can range from images, audio, and video to the"}, {"title": "2.2 Notations & Unicode Whitespaces", "content": "In the following, we introduce the nomenclature used in this paper. It is based on related work [4] while all iterable\nelements like lists start at index one. Since the information hiding scheme is based on pure text, we define every Unicode\nsymbol as u that is included in the set $U := \\{u : u \\text{ is Unicode character}\\}$, containing 149813 characters based on\nUnicode standard version 15.1 [48]. Following the standard, different whitespaces s exist, where the set of all Unicode\nspace characters with a width > 0 are defined as $S := \\{s : s \\text{ is space character } \\land s \\in U\\}$, containing 17 elements.\nA character like the zero-width space (U+200B) \u201calthough called a \"space\" in its name, does not actually have any\nwidth or visible glyph in display [...] and is treated as a format control character, rather than as a space character\" [48,\np. 267] and therefore not an element of S. We define the classical and most used space character U+0020 as \u03b4 with\n\u03b4\u2208 S. We evaluated every s to define our own subset of whitespaces as alphabet $A+ := \\{a : a \\in S \\land \u0430 \\in U\\land a \\text{ meets}\\newline \\text{criteria}\\}$, whereas the criteria are non-noticeability for humans and robustness in different applications and file formats.\nFor the non-noticeability or visibility criteria, we compared the width of the whitespace characters based on Korpela\n[26] with the commonly used space d (\u2248 1 em). If abnormalities exist causing unusual space, we classify it as different"}, {"title": "3 Related Work", "content": "Over time, different information hiding methods and implementations for watermarking and steganography have been\npublished. Due to the increasing number of diverse method classes, cover types, and areas of application, different\nliterature reviews and surveys exist to organize the cluttered research and application landscape. A more detailed\ndiscussion on selected methods is provided in section 3.1.\nBender et al. [9] present one of the first comprehensive overviews of data hiding methods for image, audio, and text\nfiles. Later on, Petitcolas et al. [36] made a survey on information hiding techniques, focusing on steganography,\nwatermarking, and fingerprinting techniques, including information about possible attacks and a basic theory for overall\nprinciples. A more specialized overview with solutions focusing on text steganography is provided by Ahvanooey et al.\n[3], Krishnan et al. [28], and Majeed et al. [32]. Current challenges are discussed by Ahvanooey et al. [5] and Tyagi\net al. [50], while the latter provide concrete application possibilities.\nBesides the reviews, researchers started analyzing and comparing existing methods to identify their strengths and\nweaknesses. Ahvanooey et al. [2] compare watermarking and steganography methods by differentiating their embedding\ntechnique and analyzing them based on the evaluation criteria of imperceptibility, embedding capacity, robustness,\nsecurity, and computational cost [2]. One of the latest evaluations on text steganography is published by Kn\u00f6chel and\nKarius [25] where the authors compared the capacity, imperceptibility, robustness, and complexity with a specialized\nfocus on Malware."}, {"title": "3.1 Related Methods", "content": "In order to integrate our proposed TREND method into the research landscape, we present the most relevant text\nwatermarking and steganography methods in the following. In connection with the LLM problem domain initially set\nout, Kirchenbauer et al. [24] and Christ et al. [12] present a token-based watermarking scheme, while the latter focus\non undetectability, completeness, and soundness. Such ideas are integrated into SynthID, the watermarking engine\nfor Google's Gemini LLM [17]. Steinebach [47] generates a cover text based on sets of letters. Those methods are\nclassified in the domain of lingustic methods since they make use of the LLM text generation. Nevertheless, those\nlinguistic methods are problematic for cover texts where semantics are important. Thus, we focus on format-based\nmethods that use insertion or substitution-based embedding techniques [25]. Other types of format-based methods, as\nwell as linguistic or random and statistical generation methods [25, 32] are not considered further since they either do\nnot work on pure text documents due to missing format options like color or fonts or because they change the semantic\nor structure of the cover text. We implemented all presented methods for our benchmark evaluation in Section 5. A\nsummarized overview is depicted in Table 4.\nSNOW. One of the first whitespace steganography methods for ASCII texts is the Steganographic Nature Of\nWhitespace (SNOW) by Kwan [30]. While the first release goes back to the 20th century, the last update with a\nchange to the open source license Apache 2.0 was made in 2013 [30]. It includes a Java and Windows DOS version\nand a C-implementation last updated in 2016 [31]. The embedding process encodes the secret message into tab and\nspace characters and appends it at the end of the cover text, starting with a tab character under the consideration of\na pre-defined line length [30]. Upstream compression and encryption can be optionally enabled before the encoding\nprocess.\nUniSpaCh. A very well-known algorithm in the field of information hiding for text documents is UniSpaCh, proposed\nby Por et al. [38]. It is an extended version of WhiteSteg, which replaces one single space character between words and\nparagraphs with either one or two whitespaces to encode a 0 or 1 [37]. UniSpaCh uses two different types to embed the\nsecret message in the text. For spaces between words and sentences, regular whitespaces either remain as they are or\nare extended by adding an additional Thin, Six-Per-Em, or Hair space to encode two bits per embedding location [38].\nFor end-of-line and inter-paragraph spacings, the remaining space is filled with a combination of Hair, Six-Per-Em,\nPunctuation, and Thin spaces to encode two bits per character [38].\nAITSteg. Ahvanooey et al. [1] propose a text steganography technique for SMS or social media communication. The\nembedding method transforms the secret message into zero-width characters with the help of a G\u00f6del function and by\nusing the sending/receiving time and the length of the secret message to add it before the cover text [1].\nShiu et al. The data hiding method proposed by Shiu et al. [45] focus on communication over messengers of social\nmedia networks. Due to the small width of a messaging window, the method is based on a fixed line length and can hide\nthree bits per line of a cover text [45]. After encoding a secret message into a bit stream based on the ASCII mapping, it\nembeds the first bit by adding a whitespace at the end of a line, changing the length of the line to embed the second bit,\nand adding a whitespace between two words to embed the third bit [45].\nRizzo et al. A text watermarking technique based on specific replacement of Unicode characters with their confusables,\nalso known as homoglyphs, was initially proposed in Rizzo et al. [41] and extended to a fine-grain watermarking\napproach in Rizzo et al. [42]. Based on their latest approach, it generates a watermark by using a keyed hash function\nwith a secret message as a watermark and a secret password [42]. Aftward, the watermark is embedded in the cover text\nby replacing specific characters with their confusables or leaving them as they are to embed one bit each and replacing\nwhitespaces with a set of specific whitespaces to embed three bits per space [42].\nStegCloak. The open-source implementation StegCloak published by KuroLabs [29] as described in Mohanasundar\n[35] is a JavaScript steganography tool that is able to hide a secret message inside a cover text with optional password\nencryption and Hash-based Message Authentication Code (HMAC). In the embedding process, the secret message is\ncompressed, optionally encrypted, and encoded in a set of zero-width characters to be inserted in one location after a\nclassical whitespace of the cover text [35].\nLookalikes. Another implementation is the Unicode Lookalikes algorithm by Thompson [49] as part of the Python\npackage pyUnicodeSteganography. Similar to Rizzo et al. [42], the method replaces specific characters with their\nconfusables to encode a secret message inside the cover text [49]."}, {"title": "4 Proposed Method", "content": "In this section, we present TREND, our information hiding technique for pure text documents. Since existing methods\nare either not robust in different applications, increase the number of characters, or are recognizable by humans, they\nare unsuitable for the LLM use case described in the introduction. Therefore, this section presents the embedding and\nextracting method in Algorithm 1 and Algorithm 2 based on our nomenclature introduced in Section 2.2. It further\nincludes a concrete example of a Lorem ipsum dummy text and information about our implemented prototypes."}, {"title": "4.1 Embedding", "content": "The proposed embedding method can hide any byte-encoded sequence in a Unicode-encoded cover text CT. The\nexamples in this paper are based on a secret message SM in text form, where every character is transformed into its\nUTF-8 byte representation SMbytes.\nThe embedding function Emb(CT, SMbytes, 0) begins by analyzing the configuration parameter 0. It specifies the\ntype of the secret message, which we call a TRENDmark. It offers optional functionalities that can be enabled in\nany combination by the end user, depending on the use case. This comprises functions like encryption, compression,"}, {"title": "4.2 Extracting", "content": "The extraction method Ext(CTSM) = SMbytes is split into three parts for extraction, tag analysis, and decoding. The\nfirst part starts by iterating over all characters of the input cover text including the secret message CTS\u2122 until it finds\nthe first occurrence of & as the separator character. Through the filtering of A+, it allows to extract the full TRENDmark\nwith the tag, an optional prefix, and a hidden secret message SMH as specified in Figure 1.\nThe second part analyzes and evaluates the whole TRENDmark based on the tag by calling analyzeTag(). If options\nlike hashing are enabled, it checks and verifies the hash of SMH and returns an error if problems occur. It can also\ndecompress the message, check the size, or apply the CRC32 prefix.\nThe third part decodes the hidden secret message SMH into its bit representation SMbytes. The step size for the\ndecoding part depends on the length of the alphabet without separator character and is defined as\n$d:=\\frac{\\log_2 2^8}{\\log_2 A-}$\nwith d = 4 for our alphabet because each byte is represented by four whitespaces of A. The cascading modulo\noperation from Algorithm 1 can be transformed back into its byte representation b. All b form the secret message\nrepresentation SMbytes, which in turn can be converted by the UTF-8 representation into the decoded secret message\ntext SM. The overall extraction process is summarized in Algorithm 2."}, {"title": "4.3 Implementation", "content": "Besides the theoretical presentation, both watermark embedding and extraction methods were technically implemented\nas a generic library in the Kotlin programming language to test and validate our solution. Kotlin was chosen since it\nis interoperable with the widely used Java programming language while supporting multiplatform targets. Thus, our"}, {"title": "5 Evaluation and Experimental Results", "content": "To analyze and evaluate our proposed TREND technique, this section compares it with state-of-the-art methods for\ntext watermarking and steganography. We created a testbed and implemented all methods presented in Section 3.1 in\nthe Java programming language based on their descriptions, reference implementations, and examples. To ensure a\nuniform basis and comparability without unnecessary overhead, we focus on the embedding and extraction methods\nonly. Thus, optional functionalities like encryption or compression are excluded since they can be applied upstream to\nall algorithms and would jeopardize the abstraction of the comparison. Figure 4 shows our evaluation Graphical User\nInterface (GUI), consisting of embedding a secret message inside a cover text on the left side, a dropdown selector of\nthe method in the middle with some additional options, and an extraction part on the right side. For the comparison, we\napplied each algorithm in two execution runs on the same considerably large dataset of one million random English\nWikipedia articles as cover texts. The first run tries to hide a short four-character secret message inside the dataset,\nwhile the second run tries to hide a long 455-character secret message inside the dataset. The different lengths and\nforms of the Wikipedia cover texts, as well as two different lengths of secret messages, ensure an appreciable broad\ndiversification. More details about the data and evaluation process for transparency and reproducibility are provided in\nthe Appendix.\nDifferent empirical research methods exist in the domain of software engineering, like simulations, benchmarks, case\nstudies, or controlled experiments [18]. We use benchmarking in this evaluation since it is a \"[s]tandard tool for the\ncompetitive evaluation and comparison of competing systems or components according to specific characteristics\" [51,\np. 333]. Since different types of benchmarks exist, we focus on specification-based benchmarks since they concentrate\non a business problem and require development work before running the benchmark [51, 27]."}, {"title": "5.1 Capacity", "content": "The embedding capacity provides information about the relationship between the length of the cover text and the length\nof the secret message. Information hiding techniques often strive for high embedding capacities, usually forming an\nopposite relationship with the imperceptibility criteria, since imperceptibility decreases if the embedding capacity\nincreases [55]. We distinguish between two types of algorithms:\n(i) Bounded capacity algorithms: Have limits in the embedding capacity, depending on the length, structure, and\nused characters in the cover text and secret message, primarily due to specific replacements or insertions.\nAlgorithms: Shiu et al., TREND, Rizzo et al., Lookalikes, Shazzad-Ur-Rahman et al., UniSpaCh.\n(ii) Boundless capacity algorithms: Generally have no limit in embedding capacity, primarily due to the usage of\n(zero-width) characters. Embedding capacity restrictions only apply if the text length is specified, like SMS or X\nposts (formally called Tweets from Twitter).\nAlgorithms: AITSteg, CovertSYS, StegCloak, SNOW."}, {"title": "5.2 Imperceptibility", "content": "Imperceptibility or invisibility is the ability of a secret message to be concealed in a cover document without causing\nany abnormalities or getting noticed [1]. Therefore, this benchmark is more relevant for steganography use cases\nthan watermarking [38, 41]. It is essential to distinguish between the imperceptibility of humans when identifying\nsomething unusual and the imperceptibility of machines when a computer system can identify a difference, for example,\nby using statistical metrics. Due to the varying perceptions of humans, this benchmark \u201cis the most subjective of all the\nmetrics\" [25, p. 121]. In the following, we use four different metrics to measure the imperceptibility:\n(i) Comparing the Jaro-Winkler Similarity\n(ii) Comparing the number of characters\n(iii) Comparing the file size\n(iv) Checking caret navigation\n(i) Jaro-Winkler Similarity. One standard numerical measurement to compare the similarity between two character\nsequences is the Jaro-Winkler similarity, also known under the wrong name Jaro-Winkler distance [23]. It is often used\nin related work in the domain of information hiding for evaluation (see [3, 4, 6, 8, 33, 34]). The benchmark is based on\nthe Jaro string comparator \u03a6, where 1 indicates that two strings $s_1$ and $s_2$ are identical and 0 indicates that both strings"}, {"title": "5.3 Robustness", "content": "The last primary benchmark criterion relates to the persistence of a secret message inside the cover text. In contradiction\nto the criteria and attacks discussed in other studies, a noticeable amount has no effect and does not need to be considered\nin more detail. One example is reformatting attacks that change, for example, the font color [2, 5], which does not\naffect any algorithm in this evaluation since all are based on pure text and thus style-independent. Therefore, and\nin accordance with the aforementioned whitespace evaluation in Section 2.2, we have analyzed the robustness of a\ncover text with an embedded secret message in different applications and file formats. By using simple copy and paste\noperations, this \"is one of the most common attacks in that the malicious users copy the whole of text and paste into\ntheir own files\u201d [2, p. 7]. In connection with related work, we extend the set of business-related targets with social\nmedia applications like WhatsApp, Facebook Messenger, or X (formerly known as Twitter) [43].\nIn our testbed, we applied each algorithm on a Lorem ipsum dummy text to hide a secret message in the cover text.\nWe copied each result in the application to be analyzed and checked if the secret message could still be extracted\nafter copying back in our testbed GUI. The results are shown in Table 6. A \"/\" indicates that the secret message can\nfully be extracted, while \u201cX\u201d indicates a corrupt output. Edge cases are depicted as \"(\u2714)\", like CovertSYS in a .docx\ndocument, where additional characters are shown in the extracted result, whereby the original secret message can still be\nrecognized. Only our proposed TREND technique works partly for the .pdf format, depending on the PDF viewer used.\nFor example, some whitespaces are replaced with a standard U+0020 space when copying the content out of Adobe\nAcrobat Reader, while it stays persistent with PDF24 Reader. In such cases, a \"(\u2714)\" is shown in Table 6 because the\nrespective whitespace characters remain in the original PDF file, but the robustness depends on the PDF viewer used.\nThe results show that some applications remove specific characters like the Four-per-em Space (U+2005) that do not\nwork in file types like .docx, .pdf, or in emails (see Table 2), but are used by algorithms like Rizzo et al. Further, the\ntested messengers or social media networks often remove trailing whitespaces from messages, which is why SNOW or\nCovertSYS encounter problems. Only our proposed TREND technique stays robust in all tested applications and file\ntypes."}, {"title": "6 Discussion", "content": "This section discusses our proposed TREND scheme based on the experimental evaluation results to show limitations\nand points of contact for future work. To our knowledge, the TREND algorithm reported in this study is the first\ninformation hiding technique that can hide a secret message inside a cover text without increasing the number of\ncharacters or getting noticed by humans while staying robust when copied in different applications.\nWe evaluated and compared TREND in a testbed of ten algorithms from literature and practice based on a dataset\nof one million articles. In a direct comparison, our results partly differ from those of previous studies because the\nbenchmark evaluation highly depends on the structure, format, and length of the cover text and the secret message. For\nexample, we identified an embedding capacity of ~0.79 bits/character for the UniSpaCh algorithm from Por et al. [38]\nin Section 5.1. Rizzo et al. [42] made a similar analysis with a different cover text dataset based on the New York Times\nCorpus, resulting in an embedding capacity of 0.321 bits/character for UniSpaCh. The significant differences can be\ntraced back to the different cover text inputs and algorithm properties. UniSpaCh embeds the secret message between\nwords, sentences, and paragraphs, whereas a significant amount is hidden between paragraphs. Since Rizzo et al. [42]\nonly use one paragraph, our results differ but agree better as the algorithm's strength is taken into account.\nIn general it should be underlined that there is no one-fits-all information hiding scheme that can be considered as\nthe best solution. Researchers and practitioners need to select an appropriate algorithm for their use case under the\nconsideration of boundary conditions and application scenarios. Following Kn\u00f6chel and Karius [25], we provide an\noverview in Figure 9 based on the evaluation results to support the decision-making process. A boundless algorithm\nlike AITSteg, CovertSYS, StegCloak, or SNOW should be selected if a high embedding capacity is essential. Our\nTREND algorithm is a favourable choice if data is often transferred between different applications and their robustness\nis important.\nNevertheless, limitations exist which need to be discussed in connection with future work. First, TREND's comparably\nsmall embedding capacity is one major weakness as identified in the evaluation. The structure of a TRENDmark, as\nshown in Figure 1, is built to enable optional compression. Our current implementation uses the widespread zlib data\ncompression library\u2074. Future work is in progress to identify and compare various techniques to increase the capacity\nfurther.\nSecond, the proposed solution is based and tested on the Unicode standard and the UTF-8 scheme. Future research\nmust check the influence of other coding schemes like the UTF-16, ISO-standardized Latin-1, and the potential impacts\non the re-coding process to a minor scheme like ASCII.\nThird, the algorithm is robust against standard users who do not know and recognize a document with a hidden secret\nmessage. However, people familiar with the strategy can use smart attacks to apply targeted destruction of the secret\nmessage, e.g., random replacement of A+. This can be eliminated by using a different random subset of A+ for every"}, {"title": "7 Conclusion", "content": "We have designed and implemented TREND, an information hiding technique that is able to embed any byte encoded\nsequence inside a cover text. Since different solutions for digital text watermarking and steganography have been\npublished over the last decade, existing approaches change the semantics or style of the cover text, increase the number\nof characters, or are not robust when copied into other applications. By encoding and mapping a secret message into our\nembedding alphabet of five Unicode whitespaces, we are able to embed the information in the cover text by substituting\nall whitespaces. The specified structure of our TRENDmark with a prefix and tag has been designed to enable additional\nfunctionalities like compression, encryption, hashing, and error correction. The experimental evaluation shows strengths\nin imperceptibility and robustness with limitations in embedding capacity based on a direct comparison benchmark\nanalysis of ten algorithms. Our resulting method will help LLM operators to fulfill regulations like the AI Act [15] or\ncompanies by securing sensitive data before it is shared with external parties, especially with application robustness\nuse cases. Future work is in progress to develop the algorithm further to increase embedding capacity and enable the\nrestoration of broken secret messages on text alterations."}, {"title": "A Evaluation Data", "content": "For evaluating, comparing, and benchmarking our proposed TREND method against existing solutions, we applied two\nbatch runs on all algorithms. The first batch run uses the English example name \"John\" as a short secret message. The\nsecond batch run uses the 455-characters long Lorem ipsum dummy text as a long secret message:\n\"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna\naliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint\noccaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\nThe set of cover texts consists of one million random English Wikipedia articles since they are publicly available texts\nwhich have different lengths and structures and cover a wide range of domains. We used the cleaned article versions\nbased on the dump from the Wikimedia Foundation. For the reproducibility of our randomized selection, the articles'\nIDs are available from the corresponding author upon request, which can be mapped back to the original texts and\nURLs."}, {"title": "CRediT Author Statement", "content": "Malte Hellmeier: Conceptualization, Software, Investigation, Writing - Original Draft, Visualization Hendrik\nNorkowski: Software, Writing - Review & Editing Ernst-Christoph Schrewe: Software Haydar Qarawlus: Data\nCuration Falk Howar: Supervision"}, {"title": "Data Availability", "content": "An implemented version of TREND is published on GitHub [16]. The test dataset is publicly available at https:\n//huggingface.co/datasets/wikimedia/wikipedia based on the dump from the Wikimedia Foundation https:\n//dumps.wikimedia.org. Information regarding the selection of our specific subset and the results of the benchmark\nevaluation are available from the corresponding author upon request."}]}