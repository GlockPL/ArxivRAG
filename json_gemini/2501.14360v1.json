{"title": "In System Alignments we Trust!\nExplainable Alignments via Projections", "authors": ["Dominique Sommers", "Natalia Sidorova", "Boudewijn van Dongen"], "abstract": "Alignments are a well-known process mining technique for reconciling system logs\nand normative process models. Evidence of certain behaviors in a real system may\nonly be present in one representation \u2013 either a log or a model \u2013 but not in the other.\nSince for processes in which multiple entities, like objects and resources, are involved\nin the activities, their interactions affect the behavior and are therefore essential to take\ninto account in the alignments.\nAdditionally, both logged and modeled representations of reality may be imprecise\nand only partially represent some of these entities, but not all. In this paper, we intro-\nduce the concept of \"relaxations\u201d through projections for alignments to deal with par-\ntially correct models and logs. Relaxed alignments help to distinguish between trust-\nworthy and untrustworthy content of the two representations (the log and the model) to\nachieve a better understanding of the underlying process and expose quality issues.", "sections": [{"title": "1. Introduction", "content": "Conformance checking is a branch of process mining focusing on understanding\nand improving processes by comparing the behavior of the process recorded in an\nevent log with a normative process model representing the expected behavior. Both\nthe recorded and modeled behavior may contain imperfections and even contradicting\ninformation regarding the system's true nature, which is further complicated by the\npresence of multiple entities simultaneously involved in real-life processes and inter-\nacting with each other in complex ways [3, 10, 12, 21].\nIn process mining, the process is generally an unknown entity with complex be-\nhavior manifested by its activities, which occur at different times and are executed by\nvarious resources on different objects. This behavior includes decision points, con-\ncurrency, and long-term dependencies between activities and/or resources. Logging\nmechanisms reveal some aspects of this behavior, while normative process models rep-\nresent the expected system behavior, as illustrated in Figure 1. The log representation\nof the system tends to be more concrete than a normative process model. For example,\nthe former may indicate the concrete resources that performed a specific activity, while"}, {"title": "2. Preliminaries", "content": "In this section, we start with definitions and notation regarding multisets and par-\ntially ordered sets, after which we introduce basic concepts related to Petri nets. Note\nwe present most definitions in this section as reiterations from previous work [22] for\nthe sake of self-containedness of this paper.\nDefinition 1. (Multiset) A multiset $m$ over a set $X$ is $m : X \\rightarrow N$. $X^{\\oplus}$ denotes the\nset of all multisets over $X$. We define the support $supp(m)$ of a multiset $m$ as the set\n${x \\in X | m(x) > 0}$. We list elements of the multiset as $[m(x) \\cdot x | x \\in X]$, and write\n$|x|$ for $m(x)$, when it is clear from context which multiset it concerns.\nFor two multisets $m_1, m_2$ over $X$, we write $m_1 \\le m_2$ if $\\forall x \\in X m_1(x) \\le m_2(x)$,\nand $m_1 < m_2$ if $m_1 \\le m_2 \\land m_1 \\ne m_2$. We define $m_1+m_2 = [(m_1(x)+m_2(x)) \\cdot x |$\n$x \\in X]$, and $m_1 - m_2 = [max(0, m_1(x) \u2013 m_2(x)) \\cdot x | x \\in X]$ for $m_1 \\ge m_2$.\nDefinition 2. (Sequence) A sequence $\\sigma$ over a set $X$ of length $n \\in N$ is $X^n$. With\n$n > 0$, we write $\\sigma = (\\sigma_1,...,\\sigma_n)$, and denote $n$ by $|\\sigma|$. $\\langle \\rangle$ denotes the empty sequence\nwhere $n = 0$. The set of all finite sequences over $X$ is denoted by $X^*$. A projection\nof a sequence $\\sigma$ on a set $Y$ is defined inductively by $\\langle\\rangle|_Y = \\langle\\rangle$ and $((x)\\cdot\\sigma)|_Y =$\n$((x)\\cdot\\sigma|_Y  \\begin{cases}\n    [(x)\\cdot\\sigma|_Y, \\text{ if } x \\in Y \\\\\n    \\sigma|_Y, \\text{ otherwise}\n  \\end{cases}$\nwhere $x \\in X$ and $\\cdot$ is the sequence concatenation operator.\nDefinition 3. (Partial order, Covering relation, Partially ordered set) A partially or-\ndered set (poset) $X = (X, <_X)$ is a pair of a set $X$ and a partial order $<_X\\subseteq X \\times X$\n(irreflexive, antisymmetric, and transitive). We overload the notation and write $x \\in X$\nif $x \\in X$. For $x,y \\in X$, we write $x||_Xy$ if $x \\ne y \\land y \\nless x \\land x \\nless y$ and $x \\le y$ if $x < y \\lor x = y$.\n$^{\\bullet}x = {y \\in X | y < x}$ and $x^{\\bullet} = {y \\in X | x < y}$ denote respectively the preset\nand postset of an element $x \\in X$. For a subset $X' \\subset X$ and an element $x \\in X \\backslash X'$,\nwe write $X' < x$ if for any $y \\in X'$, $y < x$. Similarly for $x < X'$.\nGiven a relation $< that is reflexive, antisymmetric, but not necessarily transitively\nclosed, we define $<^+$ to be the smallest transitively closed relation containing $<$. Thus\n$<^+$ is a partial order with $<\\subseteq<^+$. The covering relation $<_{<}$ is the transitive\nreduction of partial order $<$ which is the smallest subset of $<$ with $<^+ =<$, i.e., $< =$\n${(x,y) \\in < | \\forall z \\in X : x < z < y}$.\nWe define $X^{<_}$ as the set of all sequences with elements from $X$ that respects the\npartial order, i.e., for any $\\sigma \\in X^{<_}$ we have $|\\sigma| = |X|$, ${x \\in \\sigma} = X$ and $<_X\\subseteq<_\\sigma$.\nDefinition 4. (Set operations, minimum and maximum on posets, poset cuts) We extend\nthe standard set operations of union, intersection, difference and subsets to posets: for\nany two posets $X$ and $Y$, $X \\circ Y = (X \\circ Y,(<_X^{\\circ} <_Y)^+)$, with $\\circ \\in {\\cup,\\cap,\\backslash}$ and\n$Y \\subseteq X$ iff $Y \\subseteq X$ and $<_Y=<_X \\cap(Y \\times Y)$."}, {"title": "3. Recorded and modeled behavior as representations of reality", "content": "Figure 1 shows the real process as an unknown entity, denoted as the system $S$.\nThis system generates a system log $L$. A process model $M$ allows for describing\nand reasoning about process behavior at some abstraction level. In this section, we\nformalize these entities in order to allow for comparisons to expose where the behaviors\nof $S$, $L$, and $M$ agree and disagree.\n3.1. Defining reality as system behavior\nThe core elements of a process' behavior are events. An event $eid = (a, t, O)_{id}$ is\nan atomic execution of an activity $a \\in \\Sigma$, from a set of activities $\\Sigma$, that occurred at\ntimestamp $t$. We later focus solely on the relative ordering between events, abstracting\naway from their actual timestamps. $O$ denotes the involved objects and actors of $e$,\nwhich is a non-empty multiset $ \\langle \\rangle \\subset O \\subset O$ of a multiset $O$ of object names.\nEach object $o \\in O$ belongs to exactly one object role $r$ from a set of roles $R$, given\nby $role(o) = r$. We partition multiset $O$ by roles from $R$ into multisets $O_r$ of object\nnames per object role, i.e., $supp(O) = \\coprod_{r \\in R} supp(O_r)$. We extend the notation of\n$O_r$ to $O_R = [O(o) \\cdot o | o \\in supp(O), role(o) \\in R]$. Furthermore, we partition\n$R = R_p \\cup R_e \\cup R_s$, into object roles that correspond to persistent objects, e.g., machines\nor queue capacities, expected objects, e.g., human resources that are present according\nto a specific schedule, and spontaneous objects, e.g., patients or products that appear\nrandomly.\nWe define three object roles for our delivery process example, namely packages\n$p$, deliverers $d$, and warehouse depots $w$, i.e., $R = {p, d, w}$, which are respectively"}, {"title": "3.2. System log: recorded behavior", "content": "The execution of a process can be observed as a set of activity executions that\nare captured as recorded events. We write $eid = (a,t,O)_{id}$ for a recorded event $eid$\nwith activity $a$, timestamp $t$, and involved objects $O$. We omit the identifier and write\n$e$ instead of $eid$ when it is clear that $eid$ refers to an identifiable event. A logging\nmechanism in the system $S$ provides the recording of the events, either automatically or\nmanually. In practice, there can be multiple logging mechanisms, usually characterized\nby object roles. For example, in the delivery process, the package orders and depot\nregistrations are logged through a centralized system, whereas the deliverer performs\nmanual logging for ringing and delivery activities. Lastly, the collection of packages is\nlogged in the warehouse's system.\nThe order of the recorded events is based on their timestamps. As multiple log-\nging mechanisms may have differently aligned clocks or record on different levels\nof granularity, the exact order between two events recorded in different mechanisms"}, {"title": "3.3. Modeled behavior", "content": "Process models are frequently employed to describe and analyze the execution of\na process. They can be manually created using domain knowledge or automatically\ndiscovered from the system's recorded behavior, i.e., the system log. With extended\nsemantics of workflows, resources, and data attributes can be integrated into the process\nmodel, adding constraints on the activities they are involved in.\nWe emphasize that for the techniques we propose in this paper, any formalism of\nprocess models can be used to represent the behavior of $S$, provided its language can\nbe defined by partial orders. This implies that $M$ is not required to be sound, but at\nleast easy sound, i.e., there is a process execution from the initial to the final state of\n$M$. Resource-constrained (RC) $v$-nets [21] and Typed Jackson nets (t-JNs) [24] are\nsoundness-preserving subclasses of typed Petri nets with identifiers (t-PNIDs) [25, 17,\n24], able to incorporate the behavior of multiple interacting object roles. Alignment\ntechniques that we developed initially specifically for RC $v$-nets [21, 23] naturally\nextend to t-JNs and easy sound t-PNIDs. While these examples of formalisms are\nrestricted to modeling only one-to-one interactions between objects, other formalisms"}, {"title": "4. Behavioral deviations", "content": "A system log $L$ generated by system $S$ shows the activities executed by $S$. How-\never, most real-life system logs tend to be incomplete, noisy, and imprecise, as logging\nmechanisms may be faulty and the integration of event data from different systems may\nbe imprecise [6]. Manual logging imposes additional data quality risks.\nA process model $M$ is modeled to represent the behavior $S$ of the system, either\nmanually or automatically. However, manual modeling imposes quality risks when\ndomain knowledge is incomplete and automatically discovering the model inherits the\nquality issues from $L$, making $M$ a possibly imprecise representation of $S$ as well.\nTo compare poset representations, and reveal these imprecisions in $L$ and $M$, we\nfirst define the possible matching of the events in the different representations to sepa-\nrate conformities and deviations. We concretize these deviations with regard to the real\nbehavior of $S$.\n4.1. Comparing behavioral representations\nThe system $S$, log $L$, and executions of process model $M$ all reason over the behav-\nior of the system, in true, recorded, and modeled sense, each having a different domain.\nWhere $S$ reasons about events, $L$ and $M$ reason about recorded events and transition\nfirings respectively, both referring to events in $S$. In order to expose conformities and\ndeviations, we define a behavioral congruence relation that respects a matching func-\ntion, which decides whether two elements could be referring to the same event, and the\npartial orders of the posets. In the case of an element not being congruent with any\nelement in the other representation, we speak of deviations, for which we introduce an\nadditional element $\\varepsilon$.\nDefinition 8. (Matching, Behavioral congruence) Let $X = (X, <_X)$ and $Y = (Y, <_Y$\n) be two partially ordered sets. We extend its elements with $\\varepsilon$, denoted by $X_{\\varepsilon} = X \\cup$\n${\\varepsilon_X}$ and $Y_{\\varepsilon} = Y \\cup {\\varepsilon_Y}$.\n$x \\sim y$ denotes that elements $x \\in X$ and $y \\in Y$ are potential matches according to\na matching function $match : X_{\\varepsilon} \\times Y_{\\varepsilon} \\rightarrow [0, 1]$, i.e., $x \\sim y \\Leftrightarrow match(x, y) \\ge \\theta$ for\nsome $match$ and $0 < \\theta < 1$. For any $x \\in X$ and $y \\in Y$, we say that $match(x, y) = 1$\nand $match(x,y) = 1$, and therefore $x \\sim \\varepsilon_Y$ and $\\varepsilon_X \\sim y$."}, {"title": "5. Describing reality by alignments", "content": "Conformance checking is a technique aimed at the comparison of the behavior of\nthe model $M$ of system $S$ and the observed behavior of system $S$ as recorded in log $L$.\nSeveral state-of-the-art techniques in conformance checking use alignments to relate a\nrecorded execution of a process to the most similar trace of the language of a process\nmodel [7, 2]. More advanced techniques additionally incorporate data or resource in-\nformation [5, 8, 13, 14]. An alignment exposes deviations of the log execution from this\ntrace explaining where the activities prescribed by the process model were not executed\nand where activities not allowed by the model were performed. The techniques referred\nto above operate on a trace-by-trace basis, not incorporating inter-case dependencies"}, {"title": "5.1. Aligning recorded and modeled behavior", "content": "Recall that the congruence relation from Def. 8 aligns two behaviors defining a\nmatching relation of their elements while respectively the partial orders. At the core\nof alignments of recorded behavior $L$ and a process model $M$ are moves, defining the\nmatching function on recorded events and transition firings. Alignment moves belong\nto one of the following three types, which we formally define in Def. 10:\n1.  log moves, indicating that a recorded event cannot be mimicked by the process\nmodel;\n2.  model moves, indicating that the model requires the execution of an activity that\nhas no matching recorded event at the corresponding position;\n3.  synchronous moves, indicating that observed and modeled behavior agree on the\nevent represented by the move.\nLog and model moves refer to unmatched elements from respectively recorded and\nmodeled behavior, which we denote as deviating moves, while synchronous moves are\nconforming moves referring to elements that are matched in both behaviors.\nDefinition 10. (Log, model and synchronous moves) Let $L$ be a system log and $M =$\n$(N, m_i, m_f)$ be a process model with t-PNID $N = (P, T, F, l, a, \\beta)$ and $T_{\\mu}$ the set of\nall possible transition firings in $M$ (c.f., Def. 7).\n$\\Upsilon_S = {(e, t_{\\mu}) | e = (a, O) \\in L, t_{\\mu} \\in T_{\\mu}, a = l(t), O = objects(t_{\\mu})}$ is the set\nof possible synchronous moves, following the potential matching function from Def. 8.\n$\\Upsilon_L = {(e, \\gg) | e \\in L}$ is the set of possible log moves, and $\\Upsilon_M = {(\\gg, t_{\\mu})_{id} | t_{\\mu} \\in$\n$T_{\\mu}}$ is the infinite set of possible model moves, with the additional identifier to make\neach move unique.\nAn alignment defines the congruence relation between $L$ and $M$, i.e., a poset over\nthe set of synchronous, log and model moves that incorporates both the recorded be-\nhavior and the allowed behavior of the model. The alignment's deviating moves expose\ndeviation of the recorded behavior from the modeled behavior while the synchronous\nmoves show where the recorded behavior follows the model.\nDefinition 11. (Alignment) Let $L = (L, <_L)$ be a system log and $M = (N, m_i, m_f)$\nbe a process model. An alignment $\\gamma$ is a poset $\\gamma = (\\gamma, <_{\\gamma})$, where $\\gamma \\subseteq (\\Upsilon_L \\cup\\Upsilon_M \\cup\\Upsilon_S)$,\nwith the following properties:"}, {"title": "5.2. $\\gamma_{L,M}$ as a representation of S: a matter of trust", "content": "An alignment $\\gamma$ is a representation of the system $S$ (c.f., Fig. 1) as it integrates two\nbehavioral representations $L$ and $M$ by selecting an execution poset $\\varphi \\in L(M)$ and\na congruence relation $(=_{L,\\varphi})$ between the two, distinguishing where they agree and\ndisagree. Conformities $(e, t_{\\mu}) \\in =$, and deviations $(e, \\varepsilon_M) \\in =$ and $(\\varepsilon_L, t_{\\mu}) \\in =$ are\ndenoted by synchronous moves ($\\gamma_S$), log moves ($\\gamma_L$), and model moves ($\\Upsilon_M$) re-\nspectively. Even without deviations, i.e., $\\gamma = \\gamma_{\\vert S}$, the alignment provides an enriched\nrepresentation of $S$ by combining activity executions with structural properties of the\nprocess. Although individual trace alignments fail to capture inter-object dependen-\ncies present in the system, the complete system log alignment, introduced in [21], can\nalready provide a more accurate representation of reality.\nAssuming that the log and the model are the only sources of our knowledge about\nsystem $S$, we can say that to the best of our knowledge, synchronous moves are part\nof the behavior of $S$, as this is where $L$ and $\\varphi$ agree, i.e., for each $(e, t_{\\mu}) \\in \\gamma$ there\nis exactly one event $s \\in S$ such that $(e, t_{\\mu}, s) \\in =_{L,\\varphi,S}$. However, for model and log\nmoves it is not trivial to decide whether they represent system behavior. An alignment"}, {"title": "6. Classifying deviations by relaxations", "content": "In this section, we propose a method to relax the alignment problem that allows\nfor partial matching of recorded events and transition firings. We discuss how this\nimproves the interpretability of deviating behavior by showing more accurately for\nwhich objects the recorded and modeled behavior agree. Exposing the deviations for\ndifferent perspectives can provide information for the trust levels for both the process\nmodel and the system log locally, as discussed in Sec. 5.2.\nIn Sec. 4.2, we showed, through examples, the limitations of regular alignments\nwith regard to the interpretability of deviations from known quality issues in both the\nrecorded and modeled behavior. Here we revisit these examples and show how our\nproposed relaxed alignment extracts more information from the model and the log from\nwhich we can reveal which behavior would best match that of the system.\n6.1. Partial matching of log and model\nA process combines multiple perspectives from the various object roles, e.g., case,\nand resource perspectives. The modeled behavior, defined by $M = (N, m_i, m_f)$ with\n$N = (P, T, F, l, a, \\beta)$ distinguishes between these object roles through its place type\nfunction $a$. $M$ defines the combination of the process models for each object role by\nsynchronization of objects in transition firings. On the other hand, $L$ combines traces,\ndenoting projections of the system log on the individual objects, that are synchronized\nin events involving multiple objects.\nRecall from the previous section that $M$ and $L$ are compared in their entirety\nthrough an alignment $\\gamma$, by defining a potential matching relation $\\sim$ and computing a\ncongruence relation from the alignment $\\gamma$. The alignment $\\gamma$ is defined (c.f., Def. 11)\nin such a way that any two elements $(a, O) \\in L$ and $t_{\\mu} \\in \\varphi \\in L(M)$, with $\\varphi = \\gamma_{[T}$,\ncan only match, and therefore be congruent, if they agree on all involved objects si-\nmultaneously. When for a single object $o \\in (supp(O) \\cup objects(t_{\\mu}))$ the recorded"}, {"title": "6.2. Relaxed alignment moves through projections", "content": "Recall that a projection of $L$ onto objects $O \\subset O$ shows the recorded behavior\ninvolving only these objects. Similarly, the projection of $M$ onto objects $O$ models\nthe behavior from the perspectives of only these objects, ignoring any restrictions for\ntransition firings imposed by the modeled behaviors from other objects, i.e., $O' \\not= O$.\nSimilarly, through alignments on these projections, we can compute how many of the\ninvolved objects can be synchronized. For example, if we look at system behavior $S_1$\nfrom Fig. 4a. This is not behavior in the complete model $M$, since $order$ and $ring$ are\nnot allowed to be present in the same run of $M$. However, if we look at $S_1$ from the\nperspective of just the deliverer $d_1$, it perfectly matches the modeled behavior from the\ncorresponding model projection $M_{\\vert d_1}$ of the deliverer.\n6.2.1. Relaxing the process model\nTo allow for partial synchronization of events and transition firings, we introduce\nthe concept of relaxing a process model. Relaxations add behavior through the im-\nputation of projections into the respective t-PNID model. The relaxed process model\n$\\hat{M} = (\\hat{N}, m_i, m_f)$ extends a process model $M = (N, m_i, m_f)$ by directly adding\nits projections on all objects while integrating a correlation creation/destruction net\ndenoted as $N_C$, giving $\\hat{N} = (\\cup_{o \\subset O} N_{\\vert o}) \\cup N_C$. A fragment of $\\hat{M}$ of the run-\nning example is shown in Fig. 12a, for its formal definition and construction, we\nrefer to [22]. $\\hat{M}$ differs from $M$ by the projected transitions for $ring$ and $deliver$. As\nboth transitions involve two objects, there are two projections for each. In $\\hat{M}$, there\nis a correlation in place $p_5$ between the package and the deliverer created after the\nfiring of $ring$ and is used in the firing of $deliver$. The added silent transitions alterna-"}, {"title": "6.3. Relaxed alignment as a more accurate representation of reality", "content": "When there is a discrepancy between recorded and modeled behaviors on a sin-\ngle perspective, regular deviating moves (log and model moves) are mandatory in the\nsetting without relaxed moves. Contrarily, incorporating relaxed moves allows us to\nprovide information on which perspectives the behaviors agree or disagree. Further, it\nallows us to categorize the deviations based on the number of complying perspectives,\nwhich determines the likelihood of belonging to the system behavior. We denote this\nthe relaxed alignment, which can incorporate both the regular moves as well as the\nmodel and synchronous moves from projections and the substitute synchronous moves\n(relaxed moves):\nDefinition 13. (Relaxed alignment) Let $L = (L, <_L)$ be a system log and $\\hat{M} =$\n$(\\hat{N}, m_i, m_f)$ be a relaxed process model of $M = (N, m_i, m_f)$. A relaxed alignment $\\hat{\\gamma}$\nis a poset $\\hat{\\gamma} = (\\hat{\\gamma}, <_{\\hat{\\gamma}})$, where $\\hat{\\gamma} \\subseteq (\\Upsilon_L \\cup \\Upsilon_M \\cup \\Upsilon_S \\cup \\hat{\\Upsilon}_S \\cup \\tilde{\\Upsilon}_L \\cup \\tilde{\\Upsilon}_M)$, having the\nfollowing properties:\n1.  $L'$ is a relaxed version of $L$, i.e., respecting Eqs. 6 and 7;\n2.  $m_i \\xrightarrow{\\sigma} m_f$, i.e., $\\forall \\sigma \\in (\\gamma_{[T})^<, m_i \\xrightarrow{\\sigma} m_f$, $\\sigma_{[T}$ is a run in the relaxed process\nmodel $\\hat{M}$\nwith alignment projections on the log events (c.f., Eq. 3) and on the transition\nfirings (c.f., Eq. 4).\nThe relaxed alignment allows for partial synchronization of the objects' individual\nbehaviors through the included projections. We aim to match as many perspectives\nas possible, assuming that compliance of representations indicates trust in the content,\nand therefore is more likely to be included in the system $S$. We accomplish the by\nimposing costs on the moves such that a move has lower cost when it synchronizes\nmore objects. We define our cost function as follows and show that with this definition,\nthe desired criteria are respected. For (relaxed) move $(e_{[O}, t_{\\mu[O}) \\in \\hat{\\gamma}$ and some small\n$0 < \\epsilon < 1$:\n$c((e_{[O}, t_{\\mu[O})) = \\begin{cases} \\epsilon^2 & \\text{if } t \\in T^C \\\\\n|O| + (|Var(t)| - |O|)\\epsilon & \\text{if } \\forall \\in {e_{[O}, t_{\\mu[O}} \\land l(t) \\ne \\tau \\\\\n(|Var(t)| - |O|)\\epsilon & \\text{otherwise}  \\end{cases}$\nwhere $T^C$ denotes the transitions in the correlation creation/destruction net $N_C$ intro-\nduced in Sec. 6.1. $c$ imposes different costs for three types of moves. From bottom"}, {"title": "6.4. Trusting representations locally", "content": "A relaxed alignment can uncover issues in both recorded and modeled behavior,\nand it does so locally. This means that one does not need to make a choice and fully\ntrust either the log or the model, but rather one can determine trust levels locally, based\non the specific issues found in the data. After identifying issues in certain parts of\nthe process with respect to certain perspectives, it is possible to generate statistics in\norder to establish trust levels for those specific contents in both the log and the model.\nInformation on which contents is of low trust and which content is of high trust is\nvaluable for log and model repair [11, 18, 19, 26], as the repair can get a clear focus on\nthe problematic content.\nFurthermore, the relaxed alignment $\\hat{\\gamma}$ gives the basis for the analysis of what behav-\nior is most likely to have happened in reality, through the classification of the (relaxed)\nmoves such as the last row of Tab. 2. This improved representation of $S$ is valuable for\ndecision point analysis and performance analysis, since ideally, only the behavior of $S$\nshould be analyzed."}, {"title": "7. Conclusion", "content": "Real-life processes involve multiple objects affecting each other's behaviors through\ninteractions in shared activities. While the exhibited behavior of the process is an un-\nknown, invisible entity, we described how it is represented by its recorded behavior\n(a system log) and modeled behavior (a normative process model), both coming with\npotential quality issues.\nAlignments can provide a more trustworthy and richer representation of the pro-\ncess, by reconciling the recorded and modeled behavior. We have shown that align-\nments of a system log and a model are capable of exposing deviations in inter-object\ndependencies, which already provides a more accurate description of reality as opposed\nto the individually aligned objects.\nWith possible quality issues in both the recorded and modeled behavior, interpreta-\ntions of deviations can be ambiguous. Through relaxations, specifically on interacting\nperspectives, we enable partial matching of log and model, to more precisely pinpoint\npotential sources of deviations. Depending on the number of perspectives the behav-\niors agree on, we classify the deviations. This allows to identify the trustworthy and\nuntrustworthy contents of the two representations, achieve a better understanding of\nthe underlying process, and expose quality issues.\nIn this work, we have presented the relaxations in a general sense, where constraints\nfrom each of the perspectives can be relaxed. In a real-life setting, it is interesting to\ntake into account how realistic these relaxations are based on domain knowledge, which\ncan be integrated into the cost function for relaxed moves. For future work, we plan to\ne"}]}