{"title": "On the Foundations of Conflict-Driven Solving for Hybrid MKNF Knowledge Bases", "authors": ["RILEY KINAHAN", "SPENCER KILLEN", "KEVIN WAN", "JIA-HUAI YOU"], "abstract": "Hybrid MKNF Knowledge Bases (HMKNF-KBs) constitute a formalism for tightly integrated\nreasoning over closed-world rules and open-world ontologies. This approach allows for accurate\nmodeling of real-world systems, which often rely on both categorical and normative reasoning.\nConflict-driven solving is the leading approach for computationally hard problems, such as\nsatisfiability (SAT) and answer set programming (ASP), in which MKNF is rooted. This paper\ninvestigates the theoretical underpinnings required for a conflict-driven solver of HMKNF-KBs.\nThe approach defines a set of completion and loop formulas, whose satisfaction characterizes\nMKNF models. This forms the basis for a set of nogoods, which in turn can be used as the\nbackbone for a conflict-driven solver.", "sections": [{"title": "1 Introduction", "content": "Real-world problems often require integrated reasoning of both rules-based and on-\ntological knowledge, spanning domains such as customs, healthcare, and penal sys-\ntems (Knorr 2021; Alberti et al. 2012). For example, in customs, ontological reasoning\naids in categorizing imported goods, while rule-based reasoning determines inspection\nprocedures (Knorr 2021). The prevalence of such applications has led to the development\nof frameworks for reconciling ontologies with rules, including Hybrid MKNF Knowledge\nBases (Motik and Rosati 2010).\nA Hybrid MKNF Knowledge Base (HMKNF-KB) consists of two components: a logic\nprogram of rules, such as in answer set programming (ASP), and an ontology repre-\nsentable in a decidable fragment of first-order logic, most often under a description logic.\nThe main feature of HMKNF-KBs, compared to other approaches that combine ASP with\ndescription logics, is the tight integration between their two components. Here, tightness\nrefers to the ability of an integration to allow for derivation within one component based\non conclusions from the other. For certain applications, a one-way flow of information is\nsufficient. However, greater tightness results in a richer interplay between two knowledge\nsources.\nSome integrations have partial tightness, such as dl-programs (Eiter et al. 2005). While\nthese allow for back-and-forth derivation between two components, it must be localized to"}, {"title": "2 Preliminaries", "content": "Minimal Knowledge and Negation as Failure (MKNF):\nMKNF is a nonmonotonic logic formulated by Lifschitz (1991). MKNF formulas ex-\ntend first-order formulas with two modal operators, K for minimal knowledge, and not\nfor negation as failure. We define a first-order interpretation I as usual and denote the\nuniverse of I by |I|. An MKNF structure is a triple (I, M, N), where M and N are sets of\nfirst-order interpretations within the universe |I|. The language of MKNF formulas con-\ntains a constant for each element of |I|, which we call a name. We define the satisfaction\nrelation between an MKNF structure (I, M, N) and an MKNF formula as follows:\n(I, M, N) = \u00a2 (\u0444 is a first-order atom) if \u00f8 is true in I,\n(I, M, N) |= \u00ac\u00a2 if (I, M, N) |\u2260\u0444,\n(I, M, N) |= $1 ^ \u04442 if (I, M, N) |= $1 and (I, M, N) |= \u03a62,\n(I, M, N) |= \u2203x\u00a2 if (I, M, N) |= \u03c6[a \\ x] for some a,\n(I, M, N) |= K\u00a2 if (J, M, N) |= \u00a2 for all J \u2208 \u041c,\n(I, M, N) |= not \u00a2 if (J, M, N) |\u2260 $ for some J \u2208 N.\nThe symbols T, I, V,\u2200, and \u2283 are interpreted as usual.\nAn MKNF interpretation M is a nonempty set of first-order interpretations. Through-\nout this work, we employ the standard name assumption to avoid unintended behaviors\n(Motik and Rosati 2010). This assumes all interpretations are Herbrand interpretations\nwith a countably infinite number of additional constants, and that the predicate \u2248 is\na congruence relation. Thus, we do not explicitly mention the universe associated with\ninterpretations.\nAn MKNF interpretation M satisfies an MKNF formula 6, written M |=MKNF \u00d8, if\n(I, M, M) |= $ for each I \u2208 \u041c.\nDefinition 1\nAn MKNF interpretation M is an MKNF model of an MKNF formula 6, if M |=MKNF \u03a6,\nand for all MKNF interpretations M' s.t. M' \u2283 M, we have \u2200I' \u2208 M, (I', M', M) |\u2260 \u00a2.\nHybrid MKNF Knowledge Bases (HMKNF-KBs):\nMotik and Rosati (2010) identify a subset of MKNF formulas as Hybrid MKNF. In\nthis new language, an HMKNF-KB K = (P,O) consists of a finite set of rules termed a\nrule base P, and an ontology O translatable to first-order logic as \u03c0(O). A ruler is of\nthe form\n$h_0,..., h_m\\leftarrow P_0,...,P_j,\\neg n_0,...,\\neg n_k$\nwhere $h_i$, $p_i$, and $n_i$ are function-free first-order atoms. We denote body+(r) =\n{$p_0,...,p_j$}, body\u00af(r) = {$n_0,...,n_k$}, Body(r) = \\body+(r) \u2227 \u00ac\u2228 body\u00af(r), and\nhead(r) = {$h_0,...,h_m$}. A rule r's semantics is governed by the following MKNF for-\nmula.\n$\u03c0(r) = \u2200\\vec{x} : (Kh_0 \u2228... \u2228 Kh_m) \\subseteq (Kp_0\u06f8\u06f0\u06f0\u06f0\u06f8 Kp_j \u2227 not n_0 \u06f8\u06f0\u06f0\u06f0\u06f8 not n_k)$\nwhere $\\vec{x}$ is the vector of free variables in r. Naturally, a rule base P translates to an\nMKNF formula as \u03c0(P) = Urep\u3160(r). We say that an MKNF interpretation M is an"}, {"title": "3 Dependency Graph", "content": "A guiding principle behind the dependency graph of a logic program is to provide a\nsyntactic overapproximation of the true semantic dependency between atoms within the"}, {"title": "4 Completion and Loop Formulas", "content": "In this section we characterize models of HMKNF-KBs through logical formulas. Our ap-\nproach follows that of Lee and Lifschitz (2003) who defined completion and loop formulas\nto capture the answer sets of disjunctive logic programs. While this work is self-contained,\nwe draw frequent comparison to their seminal work to ease understanding.\n4.1 Completion\nLee and Lifschitz (2003) show that an interpretation of a tight disjunctive logic program\nis an answer set if and only if it satisfies a set of formulas termed the completion. A\nprogram's completion is composed of a rule completion, clauses that ensure atoms whose\ntruth is implied must be included in an answer set, and a support completion, clauses\nthat ensure true atoms within an interpretation are supported by some rule.\nThe rule completion of (Lee and Lifschitz 2003) can be easily adopted as follows."}, {"title": "5 Nogoods", "content": "In what follows, we present sets of nogoods indirectly capturing the constraints induced\nby the completion and loop formulas of the previous section. Total assignments of these\nnogoods directly correspond with K-interpretations, and their solutions to those induced\nby MKNF models. True atoms within an assignment reflect those evaluated as true\nunder the corresponding K-interpretation, and similarly for false atoms. Through this\nrelationship the nogoods characterize MKNF models. As such, conflict-driven approaches\ncan be built on generating a subset of these nogoods.\nIn all definitions of this section, we assume a given HMKNF-KB K = (P, O).\n5.1 Completion Nogoods\nRule Nogoods:\nFor expressing that the body of a ruler is satisfied, Gebser et al. (2013) use sets of\nliterals of the form \u1e9e(r) = {Tp | p \u2208 body+(r)} \u222a {Fp | p \u2208 body\u00af(r)}. These are treated\nas composite variables with an intrinsic meaning. The literal T\u1e9e(r) represents Body(r)\nbeing satisfied whereas F\u1e9e(r) represents its unsatisfaction. This meaning is enforced\nwithin solutions by a set of conjunction nogoods to be introduced shortly.\nDirectly following (Gebser et al. 2013), we define a set of rule nogoods corresponding\nto the rule completion, which in our case ensures that the rule base is satisfied.\nDefinition 10\nThe rule nogood for any r \u2208 P, is defined as: \u03c6p(r) = {Fp1,..., Fpt, T\u1e9e(r) | head(r) =\n{P1,...,Pt}}. The rule nogoods of K are \u0424p = {\u00a2p(r) | r \u2208 P}.\nSaturation Nogoods:\nTo represent whether an atom p is supported by the ontology, we use the variable\nBo(p). Within an assignment, T\u1e9eo (p) represents that p is supported via O, and F\u1e9eo(p)\nrepresents that it is not. This is enforced within solutions by a set of entailment nogoods\nto be introduced shortly.\nTo express that a solution must be reflective of a saturated K-interpretation, we in-\ntroduce a novel set of saturation nogoods corresponding to the saturation completion.\nDefinition 11\nThe saturation nogood for any atom p\u2208 KA(0) \u222a {1}, is defined as: \u0444\u043e(p) =\n{Fp, \u03a4\u03b2\u03bf(p)}. The saturation nogoods of K are \u0424\u043e = {$0(p) | p\u2208 KA(0) \u222a {1}}.\nSupport Nogoods:\nTo reflect whether an atom p is supported by a rule r, we use literal sets of the form\n\u03b2p(r,p) = {T\u1e9e(r)} \u222a {Fq | q \u2208 head(r) \\ {p}}, as is done in (Gebser et al. 2013).\nThe truth of literals based on these sets are also enforced by conjunction nogoods.\nWe introduce a novel set of support nogoods corresponding to the support completion,\nto prevent cases where there is no support from a rule or the ontology for some true atom\nwithin an assignment."}, {"title": "6 Conflict-Driven Solving", "content": "A conflict-driven solver which determines K-interpretations induced by MKNF models\nof an HMKNF-KB, can be built based on the completion and loop nogoods of Section 5,\nfollowing the same general approach of (Gebser et al. 2012). The following is a sketch of\nsuch a solver. Our goal is to provide an overview which is open to further specification.\n6.1 Main Procedures\nDue to the similarity of their formulation to that of (Gebser et al. 2012) the details of\nthe main conflict-driven procedures will be explained only at a high level, with some\ncomments on specific differences.\nAlgorithm 1: CDNL is primarily responsible for keeping track of an assignment repre-\nsenting a partial candidate solution, through a tree-like search procedure. Additionally,\nit tracks a set of nogoods which are a subset of those introduced in Section 5, and a"}, {"title": "6.2 Determining Entailment Nogoods", "content": "Algorithm 3: EntNogoods is the novel procedure responsible for determining unit-\nresulting entailment nogoods. It relies on the function Entailment, which takes a set\nSC KA(O) as an argument. It returns the set {1} if OB0,s is inconsistent, and other-\nwise returns a set \u03a9 = {p \u2208 KA(0) | OB0,s |= p} \u222a {\u00acp | p \u2208 KA(O), OB0,s |= \u00acp}.\nWe let \u03a9+ refer to {p\u2208 \u03a9 | p\u2208 KA(0) \u222a{1}} and \u03a9\u00af refer to {\u00acp\u2208 \u03a9 | p\u2208\u039a\u0391(0)}.\nWe denote the set of atoms which some p \u2208 \u039a\u0391(O) has an edge to in G(O) as ext(p).\nThe procedure determines the minimum set of entailable information \u03a9 in line 2, by\ncalling Entailment with all atoms from KA(O) which are true in the current assignment.\nIt then checks if this set contains the contradiction atom I in line 3. If so it adds the\nappropriate nogood, and returns indicating success. Otherwise, it checks whether any"}, {"title": "7 Related and Future Work", "content": "The first challenge in applying the theories of this work to the implementation of a\nconflict-driven solver, involves procedures for the generation and management of unit-\nresulting entailment and loop nogoods. Generation of entailment nogoods can follow the\napproach of EntNogoods, but requires the integration of ontology reasoners. Generating\nloop nogoods requires additional theoretical work, but in principle can be based on de-\ntection of unfounded sets. There must also be an investigation into the ideal policies\nfor when to attempt generation of these nogoods, and when they should be forgotten.\nIt is essential to keep the set of tracked nogoods small in order to reduce time spent\npreforming unit-propagation. This is likely to be uniquely challenging for HMKNF-KBs.\nThe second is the practical challenge of integrating these theories with existing solvers.\nThe Clingo system includes a Theory-enhanced ASP solving API (Gebser et al. 2016),"}, {"title": "8 Conclusion", "content": "Our work establishes the critical foundation for the development of a native conflict-\ndriven solver of HMKNF-KBs. We have made significant theoretical contributions in-\ncluding the first formulation of a dependency graph, and first adaption of a completion\nand loop formulas for the formalism. These advancements have enabled us to derive a\nset of nogoods, essential for implementing a conflict-driven solver. We have outlined the\narchitecture of such a solver and critically examined both the potential and challenges\nin leveraging existing systems. Our findings have significant implications for enhancing\nthe efficiency and practicality of reasoning with HMKNF-KBs under the stable model se-\nmantics. The immediate next steps include the implementation of a conflict-driven solver\nbased on our theoretical framework and further refinement of the characterizations we\nhave proposed."}]}