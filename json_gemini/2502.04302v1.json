{"title": "Strong Equivalence in Answer Set Programming with Constraints", "authors": ["Pedro Cabalar", "Jorge Fandinno", "Torsten Schaub", "Philipp Wanko"], "abstract": "We investigates the concept of strong equivalence within the extended framework of Answer Set Programming with constraints. Two groups of rules are considered strongly equivalent if, informally speaking, they have the same meaning in any context. We demonstrate that, under certain assumptions, strong equivalence between rule sets in this extended setting can be precisely characterized by their equivalence in the logic of Here-and-There with constraints. Furthermore, we present a translation from the language of several clingo-based answer set solvers that handle constraints into the language of Here-and-There with constraints. This translation enables us to leverage the logic of Here-and-There to reason about strong equivalence within the context of these solvers. We also explore the computational complexity of determining strong equivalence in this context.", "sections": [{"title": "1 Introduction", "content": "Many real-world applications have a heterogeneous nature that can only be effectively handled by combining different types of constraints. This is commonly addressed by hybrid solving technology, most successfully in the area of Satisfiability modulo Theories (SMT; Nieuwenhuis et al. 2006) with neighboring areas such as Answer Set Programming (ASP; Lifschitz 2008) following suit. However, this increased expressiveness introduces a critical challenge: How can we determine whether modifications to a heterogeneous specification preserve its semantic meaning, in view of the intricate interplay of different constraint types? This is even more severe in ASP since its nonmonotonic nature does not preserve equivalence when substituting a part of a specification by an equivalent one. For this, one generally needs a stronger concept of equivalence that guarantees that, informally speaking, two expressions have the same meaning in any context. Formally, this is referred to as strong equivalence (Lifschitz et al. 2001). Such properties are important because they can help us simplify parts of a logic program in a modular way, without examining its other parts."}, {"title": "2 The Logic of Here-and-there with Constraints", "content": "The logic of Here-and-There with constraints (HTc) along with its equilibrium mod-els provides logical foundations for constraint satisfaction problems (CSPs) in the set-ting of ASP. Its approach follows the one of the traditional Boolean Logic of Here-and-There (Heyting 1930) and its nonmonotonic extension of Equilibrium Logic (Pearce 1997). In HTc, a CSP is expressed as a triple (X,D,C), also called signature, where X is a set of variables over some non-empty domain D and C is a set of constraint atoms. A constraint atom provides an abstract way to relate values of variables and constants according to the atom's semantics (just as in lazy SMT (Nieuwenhuis et al. 2006)). Most useful constraint atoms have a structured syntax, but in the general case, we may sim-ply consider them as strings. For instance, linear equations are expressions of the form \u201cx + y = 4\", where x and y are variables from X and 4 is a constant representing some element from D.\nVariables can be assigned some value from D or left undefined. For the latter, we use the special symbol u \u2209 D and the extended domain Du def D\u222a{u}. The set vars(c) \u2286 X collects all variables occurring in constraint atom c. We assume that every constraint atom c satisfies vars(c) \u2260 \u00d8 (otherwise, it is just a truth constant).\""}, {"title": null, "content": "A valuation v over X,D is a function v : X \u2192 Du. We let VX,D, or simply V when clear from the context, stand for the set of all valuations over X, D. Moreover, valuation v|x : X \u2192 Du is the projection of v on X \u2286 X. Accordingly, for any set of valuations V \u2286 V, we define their restriction to X as Vlx def {vx| v \u2208 V}. A valuation v can be viewed as a set of pairs of the form {x \u2192 v(x) | x \u2208 X,v(x) \u2208 D}, which drops any pairs x \u21a6u for x \u2208 X. This allows us to use standard set inclusion for comparison. In view of this, v \u2286 v' stands for\n{x \u2192 v(x) | x \u2208 X,v(x) \u2208 D} \u2286 {x \u21a6 v\u2032(x) | x \u2208 X, v'(x) \u2208 D}.\nThis is equivalent to: v(x) \u2208 D implies v\u2032(x) = v(x) for all x \u2208 X. We define the domain of a valuation v as the set of variables that have a defined value, namely,\ndom(v) def {x \u2208 X | v(x) \u2260 u}.\nWe also allow for applying a valuation v to fixed domain values, and so extend their type to v : XU Du \u2192 Du by fixing v(d) = d for any d \u2208 Du.\nThe semantics of constraint atoms is defined in HT\u025b via denotations, which are func-tions of form [] : C \u2192 2V, mapping each constraint atom to a set of valuations. Fol-lowing (Cabalar et al. 2020a), we assume in the sequel that they satisfy the following properties for all c \u2208 C, x \u2208 X, and \u03c5, \u03c5' \u2208 V:\n1. v \u2208 [c] and v \u2286 v' imply v' \u2208 [c],\n2. v\u2208 [c] implies v \u2208 [c[x/v(x)]],\n3. if v(x) = v\u2032(x) for all x \u2208 vars(c) then v \u2208 [c] iff v\u2032 \u2208 [c].\nwhere c[s/s'] is the syntactic replacement in c of subexpression s by s'. We also assume that c[x/d] \u2208 C for any constraint atom c[x] \u2208 C, variable x \u2208 X and d \u2208 Du. That is, replacing a variable by any element of the extended domain results in a syntactically valid constraint atom. Intuitively, Condition 1 makes constraint atoms behave monotonically with respect to definedness. Condition 2 stipulates that denotations respect the role of variables as placeholders for values, that is, replacing variables by their assigned values does not change how an expression is evaluated. Condition 3 asserts that the denotation of c is fixed by combinations of values for vars(c); other variables may freely vary.\nA formula \u03c6 over signature (X,D,C) is defined as\n\u03c6 ::= \u22a5 | c | \u03c6 \u2227 \u03c6 | \u03c6 \u2228 \u03c6 | \u03c6 \u2192 \u03c6 where c \u2208 \u0421.\nWe define Tas | \u2192 I and \u00ac6 as \u00a2 \u2192 \u22a5 for any formula y. We let vars(6) stand for the set of variables in X occurring in all constraint atoms in formula y. An HT-theory is a set of formulas.\nIn HTc, an interpretation over X,D is a pair (h, t) of valuations over X,D such that h\u2286 t. The interpretation is total if h = t. Given a denotation [\u00b7], an interpretation (h, t) satisfies a formula 4, written (h, t) = 6, if\n1. (h, t) = c if h\u2208 [c]\n2. (h,t) = \u03c6\u2227 \u03c8 if (h, t) = \u00a2 and (h,t) = \u03c8\n3. (h, t) = \u03c6\u2228 \u03c8 if (h, t) = y or (h,t) = \u03c8\n4. (h,t) = \u03c6 \u2192 & if (w, t) \u00a5 \u00a2 or (w,t) = \u03c8 for w \u2208 {h,t}"}, {"title": null, "content": "We say that an interpretation (h, t) is a model of a theory \u0413, written (h, t) = \u0393, when (h, t) = 6 for every \u03c6 \u2208 \u0393. We write \u0393 = \u0393' when every model of \u0393 is also a model of \u0393'. We write \u0413 = \u0393' if \u0393 and \u0393' have the same models. We omit braces whenever a theory is a singleton.\nProposition 1 (Cabalar et al. 2016, Proposition 3)\nFor any formula 4, we have\n1. (h, t) = 6 implies (t, t) = 6,\n2. (h,t) = \u00ab iff (t, t) = 6, and\n3. any tautology in HT is also a tautology in HTc.\nThe first item reflects the well known Persistence property in constructive logics. The second one tells us that negation is only evaluated in the there world. The third item allows us to derive the strong equivalence of two expressions in HT\u00bf from their equivalence in HT when treating constraint atoms monolithically, though more equivalences can usually be derived using HTc.\nHT makes few assumptions about the syntactic form or the semantics of constraint atoms. In the current paper, however, we introduce a specific kind of constraint atom that is useful later on for some of the formal results. Given a subset D' \u2286 D, we define the associated\u00b9 constraint atom x : D' with denotation:\n[x: D'] def {v\u2208 VX,D | v(x) \u2208 D'}\nand vars(x : D') = {x}, that is, x : D' asserts that x has some value in subdomain D'. Note that v(x) \u2208 D' implies that x is defined in v, since u \u2209 D \u2283 D'. We use the abbre-viation def (x) to stand for x : D, so that this atom holds iff x has some value, i.e., it is not undefined, or v(x) \u2260 u.\nThe nonmonotonic extension of HT is defined in terms of equilibrium models, being minimal models in HT\u025b in the following sense.\nDefinition 1 (Equilibrium/Stable model)\nA (total) interpretation (t, t) is an equilibrium model of a theory \u0413, if (t, t) = \u0393 and there is no h Ct such that (h, t) = \u0413.\nIf (t, t) is an equilibrium model of F, then we say that t is a stable model of \u0413.\nAs detailed by Cabalar et al. (2016), the original logic of Here-and-There can be ob-tained as a special case of HT with a signature (X, D, C), where X = A represents logical propositions, the domain D = {t} contains a unique value (standing for \"true\") and the set of constraint atoms C = A coincides with the set of propositions. In this way, each logical proposition a becomes both a constraint atom a \u2208 C and a homonymous variable a \u2208 X so that vars(a) = {a} (we use different fonts for the same name to stress the different role). The denotation of a regular atom is fixed to\n[a] \u00ba\u00ba [a : {t}] = {v \u2208 VX,D | v(a) = t}\nMoreover, we can establish a one-to-one correspondence between any propositional in-terpretation, represented as a set X of regular atoms, and the valuation v that assigns t"}, {"title": null, "content": "to all members of X, i.e., X = {a | v(a) = t}. Note that a false atom, viz. a \u2209 X, is actually undefined in the valuation, viz. v(a) = u, since having no value is the default situation. Once this correspondence is established, it is easy to see that the definition of equilibrium and stable models in Definition 1 collapses to their standard definition for propositional theories (and also, logic programs in ASP).\nTreating logical propositions as constraint atoms allows us not only to capture standard ASP but also to combine regular atoms with other constraint atoms in a homogeneous way, even when we deal with a larger domain D \u2283 {t} such as, for instance, D = ZU{t}. In this setting, we may observe that while [a] \u2286 [ def (a)] (i.e., if the atom has value t, it is obviously defined), the opposite [def (a)]\u2286 [a] does not necessarily hold. For instance, we may have now some valuation v(a) = 7, and so v \u2208 [ def (a) ], but v \u00a3 [a]. For this reason, we assume the inclusion of the following axiom\ndef (a) \u2192 a    (1)\nto enforce [[ def (a) ] = [a] for each regular atom a. This forces regular atoms to be either true or undefined. It does not constrain non-regular atoms from taking any value in the domain.\nFinally, one more possibility we may consider in HT is treating all constraint atoms as regular atoms, so that we do not inspect their meaning in terms of an external theory but only consider their truth as propositions.\nDefinition 2 (Regular stable model)\nLet I be an HT theory over signature (X, D, C). A set of atoms X \u2286 C is a regular stable model of F if the valuation t = {a \u2194 t | a \u2208 X} is a stable model of \u0413over signature (C, {t}, C) while fixing the denotation [a] df [a: {t}] for every a \u2208 C.\nIn other words, regular stable models are the result of considering an HT-theory \u0413as a propositional HT-theory where constraint atoms are treated as logical propositions. This definition is useful in defining the semantics of logic programs with constraints according to clingo (see Section 4.1)."}, {"title": "3 Strong Equivalence in HTc", "content": "One of the most important applications of HT is its use in ASP for equivalent transfor-mations among different programs or fragments of programs. In general, if we want to safely replace program P by Q, it does not suffice to check that their sets of stable models coincide, because the semantics of ASP programs cannot be figured out by looking at single rules in isolation. We can easily extrapolate this concept to HTc as follows:\nDefinition 3 (Strong equivalence)\nHTC-Theories \u0413and \u0393' are strongly equivalent when \u0393\u03c5\u2206 and \u0393'U have the same stable models for any arbitrary HTc-theory \u0394.\nTheory A is sometimes called a context, so that strong equivalence guarantees that I can be replaced by \u0393' in any context (and vice versa). An important property of HT proved"}, {"title": null, "content": "by Lifschitz et al. (2001) is that two regular programs P and Q are strongly equivalent if and only if they are equivalent in HT.\nAccordingly, we may wonder whether a similar result holds for HT. The following theorem is an immediate result: the equivalence \u0393 = \u0393' in HT implies that HT-theories \u0393and \u0393' are strongly equivalent.\nTheorem 1\nIf HTc-theories \u0393 and \u0393' are equivalent in HTc, that is, \u0393 = \u0393', then \u0393 and \u0393' are strongly equivalent.\nProof\nAssume \u0413 = \u0393' and take any arbitrary theory \u0394. Then, \u0393 and \u0393' have the same models and, as a result, \u0393\u222a\u2206 and \u0393' \u222a\u2206 have also the same models. Since equilibrium models are a selection among HT models, their equilibrium and stable models also coincide.\nFor illustration, let us use Theorem 1 to prove the strong equivalence of two simple HTc-theories. Consider the following two formulas, similar to the ones from the introduc-tory section:\n\u2193\u2190\u00aca\u2227s \u2265 120   (2)\nas > 100   (3)\nIn fact, we show in Section 4.4 that these two formulas are an essential part of the HT-based translation of the logic program mentioned in the introduction. Let us show that \u0393 = {(2), (3)} is strongly equivalent to \u0393' = {(3)}. By Theorem 1, it suffices to show that \u0393 = \u0393' and, since \u0393' \u2286 \u0393, it suffices to show that (3) \u2192 (2) is an HT-tautology. The following property is useful to prove this result.\nLet [c/] be the uniform replacement of a constraint atom e occurring in formula \u03c6 by a formula 4. We show below that HT\u0108 satisfies the rule of uniform substitution.\nProposition 2\nIf y[c] is an HT tautology then 6[c/4] is an HT-tautology.\nProof\nAs a proof sketch, simply observe that if the original formula [c] is a tautology, it is satisfied for any possible combination of satisfactions for cin h and in t. Each time we replace c by some formula 4 in a uniform way for some interpretation (h,t), this corresponds to one of these possible truth combinations for atom c, and so [c/] is also satisfied.\nLet is now resume our example. The HT-tautology\n(\u03b1 \u2192 \u03b2) \u2192 ((\u03b2 \u2192 \u04af) \u2192 \u00ac(\u00ac\u04af \u039b\u03b1))\nis also an HT-tautology by Proposition 1. By applying Proposition 2 to this HT-tautology with substitution a \u2192 s > 120, \u03b2 \u2194 s > 100, and y\u2194 a, we obtain the following HT-tautology:\n(s > 120 \u2192 s > 100) \u2192 ((3) \u2192 (2))"}, {"title": null, "content": "To show that (3) \u2192 (2) is an HT-tautology and, thus, \u0393 and \u0393' are strongly equivalent, it suffices to show that the antecedent of this implication is an HTc-tautology. This immediately follows once we assume the usual semantics of linear inequalities and, thus, that our denotation satisfies\n[s \u2265 120 ] \u2286 [s > 100].\nAs expected, the result may not hold if we assume that these two constraint atoms have a different meaning than the one they have for linear inequalities.\nThis illustrates how we can use Theorem 1 to prove the strong equivalence of two HTc-theories. To prove that HT-equivalence is also a necessary condition for strong equivalence, we depend on the form of the context theory \u2206. For instance, in the case in which I and \u0393' are regular ASP programs, it is well-known that if we restrict the form of A to sets of facts, we obtain a weaker concept called uniform equivalence, that may hold even if \u0393 and \u0393' do not have the same HT models. In the case of HTC, the variability in the possible context theory A is much higher since the syntax and semantics of constraint atoms are very general, and few assumptions can be made on them. Yet, if our theory accepts at least a constraint atom def(x) in C for each x \u2208 X, then we can use this construct (in the context theory \u2206) to prove the other direction of the strong equivalence characterization.\nTheorem 2\nIf HTc-theories \u0393 and \u0393' are strongly equivalent, then they are equivalent in HTc, that is, \u0393 = \u0393'.\nProof\nWe proceed by contraposition, that is, proving that \u0393\u2260 \u0393' implies that \u0393 and \u0393' are not strongly equivalent. To this aim, we build some theory A such that \u0393\u03c5 \u0394 and \u0393\u0384\u03c5 \u0394 have different stable models. Without loss of generality, suppose there exists some model (h,t) = \u0393 but (h,t) |\u2260 \u0393'. Note that, by persistence, \u3008t, t) = \u0393, but we do not know whether (t, t) = \u0393' or not, so we separate the proof in two cases.\nCase 1. Suppose first that (t, t) |\u2260 \u0393'. Let us build the theory\n\u2206 = {def(x) | x \u2208 X,t(x) \u2260 u}\nthat exclusively consists of constraint atoms. We can easily see that (t, t) = \u2206 because A collects precisely those def (x) for which t(x) \u2260 u and so, t \u2208 [ def (x)] trivially. As a result, (t, t) = \u0393\u03c5\u2206 and, to prove that (t, t) is in equilibrium, suppose we have a smaller v Ct satisfying \u0393\u03c5 \u0394. Then there is some variable x \u2208 X for which v(x) = u whereas t(x) \u2260 u. The former implies (v,t) \u2260 def(x) while the latter implies def (x) \u2208 \u2206, so we conclude (v, t) = \u2206 reaching a contradiction.\nCase 2. Suppose that (t, t) = \u0393'. Take the theory \u2206 = \u2206\u2081 U A2 with:\n\u0394\u2081 = {def (x) | x \u2208 X, h(x) \u2260 u}\nand A2 consisting of all rules def (x) \u2190 def (y) for all pair variables x, y in the set:\n{z \u2208 X | h(z) = u, t(z) \u2260 u}\nWe prove first that (t, t) is not an equilibrium model for \u0393\u03c5\u2206 because (h, t) is, indeed, a model of this theory. To show this, it suffices to see that (h, t) = \u2206. First, it follows"}, {"title": null, "content": "that (h,t) = \u0394\u2081 because \u0394\u2081 only contains facts of the form def (x) per each variable x satisfying h(x) \u2260 u. Second, \u3008h, t) = \u22062 also follows because for all the implications of the form of def(x) \u2190 def(y) in A2, both (h,t) \u2260 def(y)\u2014because h(y) = u\u2014and (t, t) = def(x)\u2014because t(x) \u2260 u. It remains to be proven that (t, t) is an equilibrium model of \u0393'\u222a\u2206. We can see that (t, t) = \u2206 follows by persistence because (h, t) = \u2206, and thus, (t, t) = \u0393'\u222a\u0394. Suppose, by the sake of contradiction, that there existed some v C t such that (v, t) = \u0393' \u222a \u0394. Since (v, t) = \u2206\u2081, any variable x defined in h must be defined in v as well, but as v C t, v(x) = t(x) = h(x) and so, we conclude h \u2286 v. However, we also know (h, t) |\u2260 \u0393' \u2286 \u0393' \u222a \u2206, and so v \u2260 h, that is, h C v C t. Consider any variable y defined in v but not in h, that is, h(y) = u and u \u2260 v(y) = t(y) by persistence. Now, y is undefined in h and defined in t, and suppose we take any other variable x in the same situation. Then, we have an implication def (x) \u2190 def (y) in A2 that must be satisfied by (v,t) whereas, on the other hand, (v,t) = def (y) because v(y) \u2260 u. As a result, (v,t) = def(x) for all variables x undefined in h but not in t. But as (v,t) = \u2206\u2081 the same happens for variables defined in h. As a result, (v, t) = def(x) iff (t,t) = def(x) and this implies v(x) = t(x) for all variables, namely, v = t reaching a contradiction. Therefore, (t, t) is an equilibrium model of \u0393' \u03c5 \u0394.\nThis proof is analogous to the original one for HT by Lifschitz et al. (2001), using here constraint atoms def (x) to play the role of regular atoms in the original proof."}, {"title": "4 Logic Programs with Abstract Theories as HT-Theories", "content": "This section details the development of a transformation from logic programs with con-straints into HTc-theories. We begin by reviewing the language of logic programs with constraints employed by the ASP solver clingo 5 (Gebser et al. 2016; see also Sec-tion 4.1). Subsequently, we introduce a novel, simplified semantic definition for this lan-guage, demonstrating its equivalence to the original definition under widely accepted assumptions that are inherent to most hybrid solvers (Section 4.2). This streamlined definition not only enhances the clarity of the technical development presented in the subsequent sections but also holds the potential to facilitate future advancements in hy-brid solver design. Building upon this foundation, we revisit the definition of answer sets for logic programs with constraints, as recently formalized by Cabalar et al. (2023). Fi-nally, we present the central contribution of this work: a transformation of logic programs with constraints into HT-theories, and formally prove the preservation of answer sets under this transformation (Section 4.4)."}, {"title": "4.1 Theory solving in clingo", "content": "The main distinctive feature of clingo 5 is the introduction of theory atoms in its syntax. We review its most recent semantic characterization based on the concept of abstract theories (Cabalar et al. 2023). We consider an alphabet consisting of two disjoint sets, namely, a set A of propositional (or regular) atoms and a set T of theory atoms, whose truth is governed by some external theory. We use letters a, s, and b and variants of them for atoms in A, T, and AUT, respectively. In clingo 5, theory atoms are expressions preceded by '&', but their internal syntax is not predetermined: it can be defined by the"}, {"title": null, "content": "user to build new extensions. As an example, the system clingcon extends the input language of clingo with linear equations, represented as theory atoms of the form\n&sum{k1 * X1; ... ; kn * Xn} <ko    (4)\nwhere each xi is an integer variable and each ki \u2208 Z an integer constant for 0 \u2264 i \u2264 n, whereas \u4eba is a comparison symbol such as <=, =, !=, <, >, >=. Several theory atoms may represent the same theory entity. For instance, &sum{x}>0 and &sum{x}>=1 actually represent the same condition (as linear equations).\nA literal is any atom b\u2208 AUT or its default negation \u00abb.\nA T-program over (A,T) is a set of rules of the form\nbo \u2190 b1,..., bn, \u00abbn+1,...,\u00abbm   (5)\nwhere bi \u2208 AUT for 1 \u2264 i \u2264 m and bo \u2208 AUTU{1} with I & AUT denoting the falsum constant. We sometimes identify (5) with the formula\nb\u2081>> bn > \u00abbn+1 >\uff65\uff65\uff65^ \u00abbm \u2192 bo.\nWe let notations h(r) def bo, B(r) + def {b1,...,bn} and B(r) def {bn+1,...,bm} stand for the head, the positive and the negative body atoms of a ruler as in (5). The set of body atoms of r is just B(r) def B(r)+ UB(r)\u00af. Finally, the sets of body and head atoms of a program P are defined as B(P) def Urep B(r) and H(P) df {h(r) | r \u2208 P} \\{1}, respectively.\nThe semantics of T-programs in clingo (Gebser et al. 2016), relies on a two-step process: (1) generate regular stable models (as in Definition 2) and (2) select the ones passing a theory certification. We present next this semantics following the formalization recently introduced by Cabalar et al. in (2023).\nAn abstract theory T is a triple (T, Sat,^) where T is the set of theory atoms consti-tuting the language of the abstract theory, Sat 27 is the set of T-satisfiable sets of theory atoms, and^^^ : T \u2192 T is a function mapping theory atoms to their complement such that = s for any s \u2208 T. We define S = {\u015d | s \u2208 S} for any set S CT.\nWe partition the set of theory atoms into two disjoint sets, namely, a set E of external theory atoms and a set F of founded theory atoms. Intuitively, the truth of each external atom in & requires no justification. Founded atoms on the other hand must be derived by the T-program. We assume that founded atoms do not occur in the body of rules. We refer to the work by Janhunen et al. (2017) for a justification for this assumption.\nGiven any set S of theory atoms, we define its (complemented) completion with respect to external atoms E, denoted by Comp\u025b(S), as:\nCompe (S) def S\u222a (E \\S)\nIn other words, we add the complement atom \u015d for every external atom s that does not occur explicitly in S.\nDefinition 4 (Solution; Cabalar et al. 2023)\nGiven a theory T = (T, Sat,^) and a set & \u2286 T of external theory atoms, a set S \u2286 T of theory atoms is a (T,E)-solution, if S \u2208 Sat and Comp\u025b(S) \u2208 Sat.\nThat is, S is a (T,E)-solution whenever both S and Comp\u025b(S) are T-satisfiable."}, {"title": null, "content": "Definition 5 (Theory stable model\u00b3; Cabalar et al. 2023)\nGiven a theory T = (T, Sat,^^) and a set E \u2286T of external theory atoms, a set X C AUT of atoms is a \u3008T,E)-stable model of a T-program P, if there is some (T, E)-solution S such that X is a regular stable model of the program\nP\u222a {s \u2190 | \u2264 \u2208 (S\u2229E)} \u222a {1 \u2190\u2190 \u2264 | s \u2208 ((T\u2229 H (P)) \\ S)} .    (6)\nAs an example of an abstract theory, consider the case of linear equations L which can be used to capture clingcon-programs. This theory is formally defined as L = (T, Sat,^), where\n\u2022 Tis the set of all expressions of form (4),\n\u2022 Sat is the set of all subsets S \u2286 T of expressions of form (4) for which there exists an assignment of integer values to their variables that satisfies all linear equations in S according to their usual meaning, and\n\u2022 the complement function &sum{\u00b7} \u4ebac is defined as &sum{\u00b7} \u0968 c with 2 defined according to the following table:\nUsing the theory atoms of theory L, we can write the running example from the intro-duction as the T-program:\n1 \u2190 \u00aba, &sum{s}>=120    (7)\na \u2190 &sum{s}> 100  (8)"}, {"title": "4.2 A new and simpler definition of theory stable model", "content": "In this section, we introduce a new, simplified version of the definition of (T,E)-stable model that, under certain conditions introduced below, is equivalent to Definition 5.\nDefinition 6 (Theory stable model simplified)\nGiven a theory T = (T, Sat,^) and a set & \u2286 T of external theory atoms, a set X C AUT of atoms is a (T,E)-stable model of a T-program P, if (X \u2229T) \u2208 Sat and X is a regular stable model of the theory\nPU {\u1793 \u2228 \u1793\u17b7\u2502\u1793\u2208E}.   (9)\nThis definition drops the existential quantifier used in Definition 5 for identifying a (T, E)-solution S.\nTo state the conditions under which Definitions 5 and 6 are equivalent, we need the following concepts (Cabalar et al. 2023). An abstract theory T = (T, Sat,^) is consistent if none of its satisfiable sets contains complementary theory atoms, that is, there is no"}, {"title": null, "content": "S\u2208 Sat such that s \u2208 S and \u015d \u2208 S for some atom s \u2208 T. A set S of theory atoms is closed if s \u2208 S implies \u015d \u2208 S. A set S of theory atoms is called E-complete, if for all s \u2208 E, either s\u2208 S or \u015d\u2208 S. A theory T = (T, Sat,^) is monotonic if S \u2286 S' and S' \u2208 Sat implies S \u2208 Sat. Programs over a consistent theory with a closed set of external theory atoms have the following interesting properties:\nProposition 3 (Cabalar et al. 2023, Proposition 2)\nFor a consistent abstract theory T = (T, Sat,^) and a closed set E \u2286 T of external theory atoms, all (T, E)-solutions S \u2286 T are E-complete.\nTheorem 3\nGiven a theory T = (T, Sat,?) and a set & \u2286 T of external theory atoms, if T is consistent and monotonic, and E is closed, then Definitions 5 and 6 are equivalent.\nThe preconditions of Theorem 3 cover many hybrid extensions of clingo such as clingcon, clingo[DL], and clingo [LP]. Therefore, in the rest of the paper, we assume these conditions and use Definition 6 as the definition of a (T, E)-stable model."}, {"title": "4.3 Structured and Compositional Theories", "content": "The approach presented in Sections 4.1 and 4.2 is intentionally generic in its formal definitions. No assumption is made on the syntax or inner structure of theory atoms. An abstract theory is only required to specify when a set of theory atoms is satisfiable and provide a complement function for each theory atom. Definition 6 is a bit more specific, and further assumes consistent and monotonic theories (with a closed set of external atoms), something we may expect in most cases while still being very generic. The advantage of this generality is that it allows us to accommodate external theories without requiring much knowledge about their behavior. However, this generality comes at a price: ignoring the structure of the external theory may prevent in depth formal elaborations, such as, for instance, the study of strong equivalence for logic programs with constraint atoms.\nAlso, in many practical applications of hybrid systems, we are interested in the assign-ment of values to variables rather than the theory atoms that are satisfied, something not reflected in Definitions 5 or 6. This is what happens, for instance, in most hybrid exten-sions of answer set solvers including the hybrid versions of clingo, namely, clingcon, clingo[DL], and clingo[LP]. Since the presence of variables in theory atoms can be ex-ploited to describe their semantics in more detail, we resort to refined types of theories that are enriched with a specific structure.\nDefinition 7 (Structured theory; Cabalar et al. 2023)\nGiven an abstract theory T = (T, Sat,), we define its structure as a tuple (Xz, Dz, varsz, []T), where\n1. Xx is a set of variables,\n2. Dr is a set of domain elements,\n3. vars\u0129 : T \u2192 2\u012b is a function returning the set of variables contained in a theory atom such that vars\u0129(s) = vars\ub3c4(s) for all theory atoms s \u2208 T,\n4. V = {\u03c5 | v : Xx \u2192 Dx} is the set of all assignments over Xs and D\u0129, and"}, {"title": null, "content": "5. [. ]x : T\u21922V is a function mapping theory atoms to sets of valuations such that\nv \u2208 [s]ziff w\u2208 [s]T\nfor all theory atoms s\u2208T and every pair of valuations v, w agreeing on the value of all variables vars\u0129(s) occurring in s.\nWhenever an abstract theory T is associated with such a structure, we call it structured (rather than abstract). Observe that structured theories are based on the same concepts as HTc, viz. a domain, a set of variables, valuation functions, and denotations for atoms. In fact, we assume that the previously introduced definitions and notation for these concepts still apply here. This similarity is intended, since HT was originally thought of as a generalization of logic programs with theory atoms. One important difference between an HT valuation and a structured theory valuation v \u2208 V\u2082 is that the latter cannot leave a variable undefined in HT terms, that is, for a structured theory, we assume that the"}]}