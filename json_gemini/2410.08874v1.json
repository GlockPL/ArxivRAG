{"title": "Experiments with Choice in Dependently-Typed Higher-Order Logic", "authors": ["Daniel Ranalter", "Chad E. Brown", "Cezary Kaliszyk"], "abstract": "Recently an extension to higher-order logic called DHOL\nwas introduced, enrich-ing the language with dependent types, and creating a powerful extensional type theory.\nIn this paper we propose two ways how choice can be added to DHOL. We extend the DHOL term structure by Hilbert's indefinite choice operator \u025b, define a translation of the choice terms to HOL choice that extends the existing translation from DHOL to HOL and show that the extension of the translation is complete and give an argument for soundness.\nWe finally evaluate the extended translation on a set of dependent HOL problems that require choice.", "sections": [{"title": "1 Introduction", "content": "Dependently-typed higher-order logic (DHOL), introduced by Rothgang et al. [9], is an ex-tension of classical higher-order logic as originally presented by Church [5], albeit with a few modifications. DHOL turns the simply-typed lambda calculus with a base type for Booleans and an equality predicate for every type into a dependently-typed and extensional type the-ory. This makes it possible to define, for example, fixed-length lists or the type of fixed-size finite sets, by replacing the simple function type A \u2192 B with its dependent version \u03a0\u03b1 : \u0391.\u0392.\nWhile the extensionality comes at the cost of undecidable type-checking, initial experiments by Niederhauser et al. [7] suggest that on the other side of this trade-off lies the ability to find proofs of otherwise unobtainable problems. To make DHOL usable by a wider array of theorem provers, Rothgang et al. [9] also define a translation from DHOL to regular HOL, utilizing partial equivalence relations to capture information that would otherwise be lost while erasing the dependency in the types.\nOne of the changes to Church's original formulation is the omission of the choice operator. Choice is an important component of several higher-order interactive theorem provers such as Isabelle/HOL [8], HOL Light [6] or PVS [10], whose dependently-typed specification language make it particularly noteworthy. Choice is therefore interesting to automated reasoning too, as illustrated by the successes of Satallax [1, 3]. This suggests that DHOL-capable theorem provers like Lash [4, 7] will eventually benefit greatly from the availability of choice.\nContributions: We provide the necessary groundwork for such future work by extending DHOL with an indefinite choice operator \u025b and the corresponding additions to the translation. We match the completeness results for the translation as given by Rothgang et al. [9] and give arguments for the soundness. We implement the erasure(s) in an extended version of Lash, introduce 34 DHOL problems with choice, and evaluate type-checking and proving on these problems. The remainder of the paper is structured as follows: Section 2 sets the stage for the extension, introducing HOL and DHOL as well as the erasure between them. Following that, in Section 3, we present two possible variants for the extension to the language and translation and subsequently prove them both to be complete. We introduce some DHOL problems and evaluate the respective translations in Section 4."}, {"title": "2 Preliminaries", "content": "First, we present a formulation of higher-order logic (HOL), closely following the formulation given in [9] and [7] to facilitate a simple extension to DHOL in the next subsection. Figure 1 gives the grammar of the HOL syntax.\nA theory T is a concatenation of the empty theory o and any number of (simple) base type declarations a: tp, typed variable and/or constant declarations x : A, and axioms. A context \u0393 similarly concatenates the empty context with typed variables, typed constant declarations, and axioms, but misses base type declarations.\nAside from base types, there is no distinction in how theories and contexts are handled. The difference is mainly semantic: Theories declare the constants, types, and axioms that hold while contexts assume that there are some variables of a certain type, or that some proposition is true. As such, during proof search for example in [7] the theory is static, while there might be changes to the context.\nTypes are either the built-in boolean base type o, base types a as defined in the theory or function types A \u2192 B. We will use upper-case letters A, B, ... to denote type variables. Lastly, terms are variables/constants x, A-abstractions Ax : A.t, applications tu or the built-in boolean constant denoting the false proposition extended with the boolean connectives t \u21d2 u, t =\\a u and \u2200x: A.t. We will use the lowercase letters t, u, v,... as term variables. We write \u00act for t \u21d2 \u22a5, t\u2260\\a u for \u00ac(t =\\a u), \u22a4 for \u00ac\u22a5 as well as t\u2227u and t Vu for \u00ac(t \u21d2 \u00acu) and \u00act \u21d2 u respectively. Lastly, \u2203x: A.t will stand for \u00ac\u2200x: A.\u00act.\nApplication associates to the left, i.e. (tu)v = tuv, and we drop the subscript in t =\\au if it is clear from the context or irrelevant. We write t[x1/u1,...,xn/un] for the simultaneous capture-avoiding substitution of variables x\u2081 with terms ti.\nThe system uses the following judgments: We write \u251cs T thy and I ctx for well-formed theories and contexts respectively. The s in the superscript makes clear we are talking about simple types. \u251c A tp and \u251ct: A establish that A is a well-formed type and the well-formed term t has type a. A special case of this judgment is \u0393\u251c s u. In this case, the well-formed term u is of type o and also provable from T and \u0393. Lastly, we write \u0393\u251cA = B to say that types A and B are judgmentally equal. This is a trivial statement in HOL but will become much harder once we introduce dependent types in the next section. Note that the T in the subscript of the turnstile is only ever absent when the statement talks about the well-formedness of the theory. As such we will drop it in the remainder, as it is fairly clear from the context whether or not it is technically required."}, {"title": "2.1 DHOL", "content": "We now make two minute changes to the previously defined syntax to allow for dependent types: First, we replace the function type A \u2192 B with its dependent version \u03a0x : \u0391.\u0392(x). Now the second type B may depend on a term of type A. In the case where x does not appear free in B, we will stick to the arrow notation. The second change introduces dependent base types."}, {"title": "2.1.1 Erasure", "content": "As DHOL is rather new, there is not much native ATP support for the logic yet. However, the increased expressivity in itself is already valuable. Rothgang et al. introduced a sound and complete translation from DHOL to HOL, thereby providing automation support by serving as an interface between the DHOL language and any higher-order capable theorem prover. We give an overview of the translation and refer to the original paper [9] for the details and proofs.\nThe basic idea of the translation is to reduce dependent types to their simple components and to encode the lost information in a partial equivalence relation (PER). In accordance to the established notation, the PER generated while erasing a type A is written as A*. The distinguishing feature of a PER is that it does not require reflexivity. Elements of a DHOL-typex: A are just those elements for which a PER A* is indeed reflexive, i.e. \u0393\u251cdt : A holds if and only if \u0393 - A* tt and T\u251cst : A.\nFormally, the translation from DHOL to HOL is defined inductively on the grammar:\no = o\n\u0393,U = \u0393,U\no = o\n\u03a0x: A.B = A \u2192 B\n\u03bb\u03b1: A.t = \u03bb\u03b1: \u0391.t\n\u22a5 = \u22a5\nt\u21d2u=t\u21d2u\n\u2200x: A.t = \u2200x : \u0100. A* x x \u21d2t\n\u0393, \u0394 = \u0393, \u0394\nat\u2081...tn = a\nX = x\ntu = tu\nt = u\nt =\\a u = A* t u\nx: A = x: A, A* xx"}, {"title": "3 Choice", "content": "In order to allow choice in the input problems as well as in the inference rules, we extend the HOL and DHOL term languages with (\u03b5x : A.t). In HOL, the semantics of choice are more straightforward, since all types need to be non-empty. This is not the case in DHOL, which is why we propose two variants of typing rules for choice terms: the stronger 81 rule that requires the existence of an element satisfying the predicate and the weaker 82 rule that only relies on the type being inhabited. The mentioned inhabitation properties are stated by the second premise in the according inference rules in Figures 3-5. Note that \u0393, \u2200x: A.\u00act\u251c\u22a5 is equivalent to \u0393\u2203x : A.t. These are in addition to the DHOL rules [9].\nRemarkably, the prelude library of PVS [10] defines two variants of choice function, called choose and epsilon, that closely match our \u025b\u2081 and \u025b\u2082 respectively. While we define two variants in order to investigate whether one of those options is preferable, the fact that both formulations find use is noteworthy.\nThe HOL rules are extended with choice in a straightforward way since simple types are assumed nonempty. Note the difference in formulation: DHOL\u025b1 has a stricter type formation rule requiring the ATP system to exhibit the existence of an element x such that t is true while DHOLE2 only requires that the dependent type A is non-empty. The corresponding erasures respect this definition in that the stronger erasure assumes the provability of \u2203x: A.t.\n\u0393,x: A\u251cd\u025b1 t :o \u0393,\u2200x:A.\u00act\u251cd\u025b1 \u22a5/\u0393\u251cd\u025b1 (\u03b5x : A.t) : A E\u2081type \u0393,x: A\u251cd\u025b1 t:o \u0393,\u2200x:A.\u00act\u251cd\u025b1 \u22a5/\u0393\u251cd\u025b1 t[x/(\u03b5x: A.t)]\n\u0393,x: A\u251cd\u025b2 t :o \u0393,\u2200x:A.\u22a5 \u251cd\u025b2 \u22a5/\u0393\u251cd\u025b2 (\u03b5x : A.t) : A E2type \u0393,x: A\u251cd\u025b2 t:o \u0393,\u2200x:A.\u00act\u251cd\u025b2 \u22a5/\u0393\u251cd\u025b2 t[x/(ex: A.t)]\n\u0393,x: As\u025bt :o/\u0393\u251cs\u03b5(\u03b5x : A.t) : A choice type \u0393,x: A\u251cset:0 \u0393, \u2200x: A.ts/\u0393\u251cs\u025bt[x/(ex: A.t)] choice"}, {"title": "3.1 Completeness", "content": "We will use to denote either weak or strong erasure, corresponding to the typing rule used. Using induction on the structure of the natural deduction rules, we extend the completeness proof given in [9] to get the following theorem:\nTheorem. For either variant DHOLE1 or DHOL\u025b2 we retain that if \u251cdt: A then \u0393\u251ct:A and \u0393\u251cs A* t t. Also, if \u0393\u251cd t then \u0393\u251cst."}, {"title": "3.1.1 Proof of completeness for \u025b1 and strong erasure", "content": "From the first assumption \u0393, x : A\u251cdt : o we get the induction hypothesis \u0393, x : \u0100, A* x x \u251cs t : 0. With the assume rule, we can establish \u0393, x : A, A* x x \u251cs A* x x. Due to well-typedness, we know this is of type o and as HOL types cannot depend on propositions in the context, we may drop the A* x x from the context in both hypotheses. Using A-type on the hypotheses and a simple application of the definition of the strong erasure yields the first goal \u25ba (\u025bx : A.t) : A.\nNote, that the first assumption of all type-ing rules is the same, so this reasoning holds for either case."}, {"title": "3.1.2 Proof of completeness for \u025b2 and weak erasure", "content": "We now show the same results for the weak typing variant. Since (\u025bx : A.t) is defined using choice to implement if-then-else, it is easy to prove that \u0393\u251c(\u025bx : A.t) = (ex : \u00c2.A* x x \u2227 t) if \u0393\u251c\u2203x : \u00c2.A* xx\u2227t. Likewise, if \u0393\u251cs\u00ac\u2203x : \u00c2.A* x x\u2227t, then \u0393\u251cs (ex : A.t) = (\u03b5x : \u00c2.A* x x).\nWe will use both facts implicitly below to rewrite (\u025bx : A.t) according to one of these equations.\nFor both the \u025b2-type rule and the 82 rule the inductive hypothesis of the first premise allows us to infer \u25ba (ex : A.t) : \u00c2 as in the corresponding proof for the strong erasure.\nWe first show completeness for the 82 rule. The inductive hypothesis for the second premise gives \u00ce, \u2200x: \u00c2.A* x x \u21d2 \u00act \u251cs \u22a5. From this we can derive \u00ce\u251c\u2203x : \u00c2.A* x x \u2227 t and \u00ce,\u2200x : \u00c2. (A* x x \u2227t) - \u22a5. We need to prove \u00ces f[x/(ex : A.t)]. It suffices to prove \u00ce\u251cs (A* xx\u2227t)[x/(ex : \u00c2.A* x x \u2227t)] which follows from the simple choice rule.\nWe now show completeness of the 82-type rule. In this case the induction hypothesis of the second premise yields \u00ce, \u2200x : \u00c2.A* x x \u21d2 \u22a5 \u251cs \u22a5. We need to prove \u2191 A* (ex : A.t) (\u03b5x : A.t).\nUnlike the previous argument, the inductive hypothesis is not sufficient to know the condition of the if-then-else is provable. From here we proceed with a case distinction along the condition.\nSince we are in a classical setting, proving \u00ce, \u2203x : \u00c2.A* x x \u2227 \u25ba A* (\u03b5x : A.t) (\u03b5x : A.t) and \u00ce,\u00ac\u2203x: \u00c2.A* x x \u2227 \u25ba A* (ex : A.t) (ex : A.t) suffice to prove \u251cs A* (\u03b5x : A.t) (\u03b5x : A.t).\nWe begin with the first case in which we assume \u2203x : \u00c2.A* x x \u2227t in the context. Let A be \u00ce,\u2203x : \u00c2.A* x x \u2227t. Since \u2206\u251c\u2203x : \u00c2.A* x x \u2227 t, it suffices to prove\n\u0394\u251c \u0391* (\u03b5x : \u00c2.A* x x \u2227 t) (ex : \u00c2.A* x x \u2227 t).\nBy the simple choice rule, it suffices to prove \u2206, \u2200x : \u00c2.\u00ac(A* x x \u2227t) \u251cs \u22a5. This is obvious since \u2203x : \u00c2.A* x x \u2227t is literally the same as \u00ac\u2200x : \u00c2.\u00ac(A* x x \u2227t).\nFinally, we consider the second case in which the negation of the condition. Let A be \u0155, \u00ac\u2203x : \u00c2.A* x x \u2227t. Since \u2206\u251c\u00ac\u2203x:\u0100.A* xx\u2227t, it suffices to prove\n\u0394\u251c \u0391* (\u03b5x : \u0391.\u0391* x x) (\u03b5x : \u00c2.\u0391* x x).\nBy the simple choice rule, it suffices to prove \u2206,\u2200x : \u00c2.\u00ac(A* xx) \u251cs \u22a5. This is precisely the inductive hypothesis of the second premise."}, {"title": "3.2 Soundness", "content": "Theorem 2 of [9] gives a corresponding soundness result for the translation from DHOL to HOL. In particular, they prove FFF holds whenever F F : 0 and F. The proof of this result (found in the appendix of [9]) is significantly more involved than the completeness result.\nOne complication is that the HOL proof of \u251c F may make use of terms t' that are not of"}, {"title": "4 Experimental Problems and Results", "content": "We propose several problems in DHOL that include choice and experiment with the performance of the erasure on these problems. For the experiments, a modified version of Lash [4, 7] was run on the listed problems, once with each kind of erasure, for 90s.\nThe first set of problems share definitions for the type of natural numbers nat with the corresponding constructors 0: nat ands: nat\u2192 nat, and the dependent-type of fixed-size finite sets In: nat. tp with the two constructors fz : In : nat.fin(sn) and fs : In : nat.fin n \u2192 fin(sn). We use numbers 1, 2, . . . to mean s 0, s (s0), .... Following is a short description of the different classes of problems:\n\u2022 choice_def1 has in addition a type for predicates p for elements of fin 2 and an axiom that establishes the existence of an element x: fin 2 which fulfills the predicate. The conjecture expresses the definition of the choice operator in this setting: p(ex : fin 2.px).\n\u2022 choice_def2 is a generalization of choice_def from fin 2 to fin n where n \u2208 N.\n\u2022 choice_def3 finally generalizes the previous example to an arbitrary dependent type.\n\u2022 choice_eq1/2 establish that the e-operator respects identity for the types fin 1, where there is only one element to choose from, and fin 2 respectively.\n\u2022 choice_nq in turn, demonstrates that choice correctly chooses the other element in the fin 2 type, or alternatively, that there are at least two elements in fin 2.\n\u2022 no_fp_finN_reg and no_fp_finN_min is a family of problems for N \u2208 {0,...,9}. Each has a conjecture that says that the function \u03bb\u03b1 : (fin N).(\u025by : (fin N).x \u2260 y) has no fixed point. The variants with reg have fin N behave like previously, while the_min versions have fewer axioms and result in types that are assumed to have at least N elements as opposed to exactly N elements. In case N\u2265 2, it is clear that the term \u03bb\u03b1 : (fin N).(\u025by : (fin N).x \u2260 y) is well typed (of type fin N \u2192 fin N) in both the strong and weak senses. Likewise it is provable that the function given by the term has no fixed points. When N = 1, the term Ax : (fin 1).(\u025by : (fin 1).x \u2260 y) is well-typed in the weak sense (since fin 1 is provably nonempty) but is not well-typed in the strong sense (since fin 1 does not provably have at least two elements). When N = 0, the situation depends on whether we have assumed fin 0 has precisely 0 elements (a provably empty type) or at least 0 elements (a possibly empty type). If fin 0 is provably empty, then the term Ax : (fin 0).(\u025by : (fin 0).x \u2260 y) is well-typed in both the strong and weak sense, simply because \u0393,x : fin 0 \u251cd \u22a5 allows us to prove the premises of the relevant rules. Likewise, if fin 0 is provably empty, it is provable that the function has no fixed point since quantification over an empty type is vacuous. If fin 0 is only possibly empty, then \u03bb\u03b1 : (fin 0).(\u03b5y : (fin 0).x \u2260 y) is not well-typed in the strong sense but is well-typed in"}, {"title": "4.1 Results", "content": "The results are presented in Table 1. Lash can easily type-check both versions of all choice_def problems. Proving the conjectures, however, only works well for the strictly typed version requiring less than 10 seconds in all cases but times out when using the weakly typed version. Similarly, choice_eq1 is type-checkable and provable with strong typing only. choice_eq2 still type-checks for both versions but is now provable by neither. Lash is not able to type-check or prove choice_nq for either of the choice typing variants. The dependent list experiments are the hardest: Lash can only prove the simplest of the three conjectures.\nLash does not type check the ill-typed problems among no_fp_fin* (included as a sanity test). Lash also does not report them as provable. With a 90s timeout Lash can type check and prove each of the problems for n \u2265 2 with one exception: it does not prove no_fp_fin9_min. The increased timeout becomes necessary as the problems rise in difficulty.\nWe generated erased versions of the no_fp_fin9_min problem, and ran them on several other higher-order ATP systems. Only Leo-III [11] and Zipperposition [2] were supporting native choice in the TPTP THF language and succeeded. Leo-III was able to prove the conjecture in 38s using the strong erasure but timed out using the weak version. Zipperposition took 0.02s for the strong erasure, and 0.96s for the weak one, suggesting that the challenges posed by the"}, {"title": "5 Conclusion", "content": "We have extended DHOL by dependent choice. Since types in DHOL can be empty, we proposed two ways to specify the rules: a strong typing rule that ensures that there exist witnesses and a weak choice typing rule that only checks that the underlying type is non-empty. These are accompanied by a proof rule and two erasure functions to enable automated reasoning. We also created a collection of 34 dependent HOL problems that use/require dependent choice (http://cl-informatik.uibk.ac.at/cek/choice.tgz). Our proofs and experiments show that stronger choice works well with DHOL, making it the primary candidate for further investigations. Future work includes implementation of native choice rules."}]}