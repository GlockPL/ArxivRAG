{"title": "A Theory of Formalisms for Representing Knowledge (Extended Version)", "authors": ["Heng Zhang", "Donghui Quan"], "abstract": "There has been a longstanding dispute over which formalism is the best for representing knowledge in AI. The well-known \"declarative vs. procedural controversy\" is concerned with the choice of utilizing declarations or procedures as the primary mode of knowledge representation. The ongoing debate between symbolic AI and connectionist AI also revolves around the question of whether knowledge should be represented implicitly (e.g., as parametric knowledge in deep learning and large language models) or explicitly (e.g., as logical theories in traditional knowledge representation and reasoning). To address these issues, we propose a general framework to capture various knowledge representation formalisms in which we are interested. Within the framework, we find a family of universal knowledge representation formalisms, and prove that all universal formalisms are recursively isomorphic. Moreover, we show that all pairwise inter-translatable formalisms that admit the padding property are also recursively isomorphic. These imply that, up to an offline compilation, all universal (or natural and equally expressive) representation formalisms are in fact the same, which thus provides a partial answer to the aforementioned dispute.", "sections": [{"title": "Introduction", "content": "Knowledge plays a crucial role in a large number of fields such as intelligent decision making, natural language understanding and automatic scientific discovery. How to effectively represent, acquire, utilize and evolve knowledge is undoubtedly one of the most critical parts of realizing artificial general intelligence (AGI). Knowledge representation is the starting point and foundation of all of these tasks. In traditional knowledge representation and reasoning (KR), representations of knowledge are often regarded as \"explicit, symbolic, declarative representations of information\" (Delgrande et al. 2024). However, in this work, we aim to explore more general forms of knowledge representation.\nOver the past seven decades, researchers have devoted substantial efforts to developing various knowledge representation formalisms. A far incomplete list includes: monotonic logical systems such as Prolog (van Emden and Kowalski 1976) and description logics (Baader et al. 2017); non-monotonic logics such as circumscription (McCarthy 1980) and default logic (Reiter 1980); graph-based representations such as Bayesian networks (Pearl 1985) and semantic network (Sowa 1991), and parametrized models such as recurrent neural networks (Rumelhart, Hinton, and Williams 1986) and transformers (Vaswani et al. 2017). It is noteworthy that machine learning and knowledge representation are inherently intertwined; all learning algorithms are actually based on some formalisms for representing knowledge.\nThe quest for the best formalism of knowledge representation has sparked a longstanding dispute. A prime example is the \"declarative vs. procedural\" controversy, which centers on choosing between declarative statements and procedures as the primary means of representing knowledge. Similarly, the ongoing debate between symbolic AI and connectionist AI revolves around the question of whether knowledge should be represented explicitly or implicitly. In general, knowledge representation formalisms in machine learning, such as convolutional neural networks in deep learning and transformers in large language models, are usually implicit, while all logical formalisms in traditional KR are explicit.\nIn this work, we will undertake a systematic exploration of disputed issues, particularly the search for the optimal knowledge representation formalism. A general framework is needed to systematically evaluate varied formalisms. While extensive philosophical deliberations on fundamentals of knowledge representation exist, including the physical symbol system hypothesis (Newell and Simon 1976) and the knowledge representation hypothesis (Smith 1982), they primarily remain within the realm of theoretical consensus-building. Departing from this path, our goal is to obtain rigorous conclusions from a broad and inclusive framework through meticulous mathematical demonstrations, thereby deepening the understanding of the nature of representation."}, {"title": "Conventions and Notations", "content": "Suppose A, B and C are sets. By $p : A \\rightarrow B$ we denote that p is a partial function (or mapping) from A to B. We call p a partial function on A if A = B. Let $dom(p)$ and $ran(p)$ denote the domain and range of p, respectively. In addition, we call p a function from A to B, written $p: A \\rightarrow B$, if p is total. Given $X \\subset A$, by $p|_{x}$ we denote the restriction of p to X. A partial function q is called an extension of p, or equivalently, q extends p, if p is a restriction of q. Given functions $p: A\\rightarrow B$ and $q: B \\rightarrow C$, by $p \\circ q$ we denote the composition of p and q. All other notions of functions such as injectiveness, surjectiveness and bijectiveness are standard.\nThe reader is assumed familiar with logic. A signature is a set that consists of predicate and function symbols, each associated with a nonnegative integer, called its arity. Constants are nullary function symbols. Let \u03c3 be a signature. By \u03c3-atoms and \u03c3-sentences (or sentences of \u03c3) we denote atoms and sentences, respectively, built from \u03c3 and standard logical connectives and quantifiers as usual. Let FO and SO denote the classes of first-order and second-order sentences, respectively. A structure of \u03c3 (or simply, \u03c3-structure) \u0391 is armed with a nonempty domain A, maps each predicate symbol $P \\in \\sigma$ to a relation $P^{A}$ on A, and maps each function symbol $f \\in \\sigma$ to a function $f^{A}$ on A, both are of the same arity. A UNA-structure of \u03c3 is a \u03c3-structure A that satisfies the unique name assumption, i.e., $c^{A} \\neq d^{A}$ for every pair of distinct constants c, d in \u03c3. Given $v \\subseteq \\sigma$, let $A_{v}$ denote the restriction of A to v. We call A a \u03c3-expansion of B if $B = A_{v}$ for some $v \\subseteq \\sigma$. Let $\\phi$ be a \u03c3-sentence. We write $A \\models \\phi$ if A is a model of $\\phi$. Given a class C of \u03c3-structures, we write $C \\models \\phi$ if $A \\models \\phi$ for all A \u2208 C. Given a set \u2211 of sentences and a sentence $\\psi$, we write $\\sum \\models \\psi$ and $\\sum \\vDash \\psi$ if $\\psi$ is a logical implication of \u2211 and $\\psi$, respectively.\nEvery Turing machine M is armed with a two-way infinite tape, a reading head, a finite set Q of states and a fixed symbol set {0, 1, B}. There is exactly one starting state and at least one halting state in Q. Every halting state is either an yes state or a no state, but cannot be both. Both the input and output are strings in {0, 1}*, stored in the tape, starting from the position of the reading head and ending with B. Let $L \\subseteq {0,1}^{*}$ . We say M accepts L if, for every $\\pi \\in {0,1}^{*}$, M accepts \u03c0 (i.e., M on input \u03c0 halts at an yes state) if $\\pi \\in L$, and never halts otherwise; and M decides L if, for every $\\pi \\in {0,1}^{*}$, M accepts $\\pi$ if $\\pi \\in L$, and rejects \u03c0 otherwise. We say L is recursively enumerable (respectively, recursive) if it is accepted (respectively, decided) by some Turing machine. Moreover, Turing machines can also be used to compute functions. We say a partial function p from {0, 1}* to {0, 1}* is computed by M if, given $\\pi \\in {0,1}^{*}$ as input, M halts with the output w iff p is defined on \u03c0 and p(\u03c0) = w. We say p is partial recursive if it is computed by some Turing machine, and p is recursive if it is partial recursive and $dom(p)$ is recursive."}, {"title": "Framework", "content": "The major goal of this work is to carry out a careful comparison between different formalisms for representing knowledge. To this end, we have to propose a general framework that captures all the formalisms in which we are interested.\nTo build the desired framework, one immediate thought might be to define a family of abstract logical formalisms, similar to abstract logical systems proposed for establishing Lindstr\u00f6m's theorem (Lindstr\u00f6m 1969). But we do not pursue this approach in this work. The main reasons are as follows. Firstly, the framework established in this way is not general enough. It is important to note that logic is not the only method for representing knowledge. Secondly, from a user's perspective, the internal logical semantics of a representation formalism are actually not important. Users are primarily concerned with the outputs generated from given inputs. This aligns with a behaviorist perspective.\nRegarding the primary computational task, we will focus on knowledge reasoning. While there are certainly other important tasks, such as knowledge acquisition (learning) and maintenance, knowledge reasoning typically runs on-line, with its efficiency directly determining the performance of the underlying system. In contrast, knowledge acquisition and maintenance can in general be performed offline.\nWe aim to go beyond the traditional reasoning problem to tackle a more general computational problem, known as query answering (QA). The problem of QA has been extensively studied in databases, see, e.g., (Fagin et al. 2005) and was later introduced into KR to implement data-intensive knowledge reasoning, see, e.g., (Calvanese et al. 2007). The problem of QA in KR is defined as follows:\nGiven a database D, a knowledge base K and a query $\\phi$, determine whether $\\phi$ is inferable from D and K.\nIntuitively, D stores the observed facts, $\\phi$ describes the question that the user want to ask, and K represents the knowledge needed to answer the questions. It should be noted that if D is empty, QA degenerates into the traditional reasoning problem; if $\\phi$ is restricted to a proposition symbol, QA simplifies to both the query evaluation problem in databases and the classification problem in machine learning.\nFollowing the behaviorist perspective, a notion of abstract knowledge base can then be defined as the class of database-query pairs (D, $\\phi$) such that $\\phi$ is inferable from D and the underlying knowledge base. To define this formally, we need to establish what constitutes valid databases and queries.\nDatabases and Queries. We assume A to be a countably infinite set, consisting of all the constants used in databases and queries. Following the tradition in databases, both the closed-world assumption (CWA) and the open-world assumption (OWA) can be made (Abiteboul, Hull, and Vianu 1995). Therefore, each predicate symbol is either an OWA-predicate symbol or a CWA-predicate symbol, but not both."}, {"title": null, "content": "A database signature is a signature $\\sigma \\supset \\Delta$ that involves no function symbols of arities greater than 0. A query signature is a signature $v \\supset \\Delta$, containing no CWA-predicate symbol. Given any database signature \u03c3, let $Fact(\\sigma)$ denote the set of all \u03c3-atoms that involve no variables and equality.\nDefinition 1. Let \u03c3 be a database signature. \u0391 \u03c3-database is a partial function $D : Fact(\\sigma) \\rightarrow {1,0, -1}$ such that\n1. (finiteness of observation) there are only a finite number of atoms $a \\in dom(D)$ such that D(a) \u2265 0;\n2. (completeness of CWA-predicates) D is defined on every atom that involves a CWA-predicate symbol in \u03c3.\nIntuitively, in the above definition, by D(a) = 1 (respectively, D(a) = 0) we mean that a was observed to be true (respectively, false), and by D(a) = \u22121 we mean that a has not been observed yet, but its truth is already determined by the current observation and a fixed set of rules under CWA.\nEvery observed fact of D is an atom $a \\in dom(D)$ such that D(a) \u2265 0. Let $D_{C}(D)$ denote the set of constants each of which appears in at least one observed fact of D. Moreover, D is said to be positive if there is no atom $a \\in dom(D)$ such that D(a) = 0, i.e., no negative fact is allowed in D.\nWe are interested in the following classes of databases:\n1. $\\mathcal{D}_{A}$: the class of arbitrary \u03c3-databases;\n2. $\\mathcal{D}_{OS}$: the class of positive \u03c3-databases.\nLet A be a structure of some signature $v \\supset \\sigma$. We say that A is a model of D, written A |= D, if we have both\n1. A |= a for all $a \\in dom(D)$ with D(a) = 1, and\n2. A $\\not\\models a$ for all $a \\in dom(D)$ with D(a) = 0.\nNext, we define what constitutes a query language:\nDefinition 2. Given a query signature \u03c3, a query language of \u03c3 is a recursive class $\\mathcal{Q}$ of FO-sentences of \u03c3 such that\n1. $\\mathcal{Q}$ is closed under conjunctions, that is, if $\\phi, \\psi \\in \\mathcal{Q}$, then $\\phi \\land \\psi \\in \\mathcal{Q}$;\n2. $\\mathcal{Q}$ is closed under constant renaming, that is, if $\\tau : \\Delta \\rightarrow \\mathcal{A}$ is injective and $\\phi \\in \\mathcal{Q}$, then $\\tau(\\phi) \\in \\mathcal{Q}$;\n3. $\\mathcal{Q}$ contains at least one non-tautological sentence.\nThe notation $(\\phi)^{\\tau}$ above denotes the sentence obtained from $\\phi$ by replacing every occurrence of each $c \\in \\Delta$ with \u03c4(c).\nExample 1. Both Boolean conjunctive queries (CQs) and unions of conjunctive queries (UCQs, i.e., existential positive FO-sentences) are query languages according the above definition, see, e.g., (Abiteboul, Hull, and Vianu 1995).\nWe believe that employing first-order fragments as query languages is a reasonable assumption for the following reasons. According to Lindstr\u00f6m's second theorem, first-order logic is the most expressive semi-decidable logic that admits the L\u00f6wenheim-Skolem property (Lindstr\u00f6m 1969). It is also worth to mention that most of the results presented in this paper can be generalized to other semi-decidable logics.\nKnowledge Bases. To simplify the presentation, in the rest of this paper, we fix $\\sigma_{D}$ as a database signature, $\\sigma_{Q}$ a query signature, $\\mathcal{D} \\in {\\mathcal{D}_{A}, \\mathcal{D}_{OS}}$, and $\\mathcal{Q}$ a query language of \u03c3. Now, let us present a definition for abstract knowledge bases, following the spirit of abstract OMQA-ontology in (Zhang, Zhang, and You 2016; Zhang and Jiang 2022)."}, {"title": null, "content": "Definition 3. A knowledge base (KB) over $(\\mathcal{D}, \\mathcal{Q})$ is a subclass K of $\\mathcal{D} \\times \\mathcal{Q}$ satisfying all the following properties:\n1. (Correctness of tautological queries) If $\\phi \\in \\mathcal{Q}$ is a tautology and $D \\in \\mathcal{D}$, then $(D, \\phi) \\in \\mathcal{K}$;\n2. (Closure under query implications) If $(D, \\phi) \\in \\mathcal{K}$ and $\\psi \\in \\mathcal{Q}$ and $\\phi \\models \\psi$, then $(D, \\psi) \\in \\mathcal{K}$;\n3. (Closure under query conjunctions) If $(D, \\phi) \\in \\mathcal{K}$ and $(D, \\psi) \\in \\mathcal{K}$, then $(D, \\phi \\land \\psi) \\in \\mathcal{K}$;\n4. (Closure under database extensions) If $(D, \\phi) \\in \\mathcal{K}$ and $D_{0} \\in \\mathcal{D}$ extends D, then $(D_{0}, \\phi) \\in \\mathcal{K}$;\n5. (Closure under constant renaming) If $(D, \\phi) \\in \\mathcal{K}$ and $\\tau : \\Delta \\rightarrow \\Delta$ is injective, then $(\\tau(D), \\tau(\\phi)) \\in \\mathcal{K}$.\nThe notation $(\\cdot)^{\\tau}$ above is the same as that in Definition 2, and it is naturally generalized to databases.\nIn the above, almost all properties are natural and easy to understand. We only give explanations for Properties 4 and 5. Intuitively, Property 4 states that reasoning about open-world information should be monotone, i.e., adding new observed OWA-facts will not change previous answers. Note that, by the definition of database, all CWA-predicates are information complete so that no CWA-fact can be added to a database (to build an extension), which means that Property 4 cannot be applied to any CWA-predicate.\nProperty 5 rests on the assumption that knowledge should encapsulate general properties applicable to all objects in the underlying domain, rather than including propositions about specific objects. Consequently, the names of objects should not influence the results of QA.\nIn Definition 3, only Boolean queries are used, but this is not limiting. By allowing constants in queries, we enable an efficient conversion from arbitrary QA to Boolean QA.\nIn machine learning, bounded-error algorithms are commonly used. Unfortunately, finding a meaningful method to evaluate error rates for representation-dependent tasks like reasoning is extremely difficult, if not impossible (Lynch 1974). This is why our framework does not account for this aspect.\nMoreover, an important question arises as to whether the above properties (1-5) indeed capture the class of knowledge bases represented in any formalism in which we are interested. First consider the necessity. In a straightforward way, one can verify it case by case. The following is an example.\nExample 2. Suppose $\\mathcal{D}_{OS}$ contains no CWA-predicate symbols. Let \u2211 be a set of sentences (in a monotone logic such as FO or SO) of a signature $\\sigma \\supseteq (\\sigma_{D} \\cup \\sigma_{Q}) \\setminus \\Delta$. Let\n$\\mathcal{K}_{\\sum} := {(D, \\phi) \\in \\mathcal{D} \\times \\mathcal{Q} : D \\cup \\sum \\models \\phi}$.\nIt is easy to verify that $\\mathcal{K}_{\\sum}$ is a KB over $(\\mathcal{D}, \\mathcal{Q})$.\nHowever, as aforementioned, there are a very large number of knowledge representation formalisms to be verified. To avoid this, we address the question from a semantical perspective. Let D be a database recording the current observation in a certain domain. Based on the observation D, the knowledge base will produce a certain belief. The latter can be denoted by a class of worlds (structures) in which the belief holds. We thus have the following definition:\nDefinition 4. Let $\\sigma \\supseteq \\sigma_{D}$ be a signature. A belief mapping of $(\\sigma_{D}, \\sigma)$ is a function M that maps every $\\sigma_{D}$-database to a class of \u03c3-structures such that"}, {"title": null, "content": "1. if A \u2208 M(D) then A |= D;\n2. if $\\tau : \\Delta \\rightarrow \\Delta$ is injective, and $\\phi$ an FO-sentence of \u03c3, then M(D) |= $\\phi$ iff $M(\\tau(D)) |= (\\phi)^{\\tau}$;\n3. if $D_{0}$ is an extension of D and $\\phi$ an FO-sentence of \u03c3 such that M(D) |= $\\phi$, then M($D_{0}$) |= $\\phi$\nfor all $\\sigma_{D}$-databases D and $D_{0}$.\nIn the above, the first condition states that the belief produced from the observation must be consistent with the observation; the second asserts that, up to a constant renaming, from the same observation, M produces the same belief; and the third denotes that adding new observed OWA-facts will not change answers obtained by query answering with M.\nNext, we show how circumscription (McCarthy 1980) defines a belief mapping. Some notations are needed.\nThe language of circumscription is the same as first-order logic, armed with the minimal model semantics. Let $v \\supset \\sigma_{D}$ be a signature. Let $v_{C}$ be the set of all CWA-predicate symbols in \u03c3, and $v_{0} := v \\setminus v_{C}$. Let A and B be v-structures. We write $A \\subseteq_{v} B$ if A and B share the same domain, and\n1. for all $P \\in v_{C}$, we have $P^{A} \\subseteq P^{B}$, and\n2. $A|_{v_{0}} = B|_{v_{0}}$, i.e., OWA-parts of A and B are the same.\nFurthermore, let \u2211 be a set of FO-sentences of v, and let D be a $\\sigma_{D}$-database. We use $Mod_{v}^{min}(D, \\sum, v_{c})$ to denote the class of all UNA-structures of v that are $v_{C}$-minimal models (i.e., minimal under the order $\\subseteq_{v}$) of both D and \u03a3.\nExample 3. Let M denote the mapping that maps each $\\sigma_{D}$-database D to $Mod_{v}^{min}(D, \\sum, v_{c})$. It is easy to see that M is a belief mapping as it satisfies Conditions 1-3 of Definition 4.\nWith a belief mapping M, the KB can then be defined:\n$\\mathcal{K}b(M, \\mathcal{D}, \\mathcal{Q}) := {(D, \\phi) \\in \\mathcal{D} \\times \\mathcal{Q} : M(D) \\models \\phi}$.\nThe following proposition tells us that, despite its excessive inclusiveness, every belief mapping defines a knowledge base satisfying all the properties of Definition 3.\nProposition 1. Let \u03c3 be a signature such that $\\sigma_{D} \\cup \\sigma_{Q} \\subseteq \\sigma$, and M be a belief mapping of $(\\sigma_{D}, \\sigma)$. Then $\\mathcal{K}b(M, \\mathcal{D}, \\mathcal{Q})$ is a KB over $(\\mathcal{D}, \\mathcal{Q})$.\nNow, let us show the sufficiency of Properties 1-5 of Definition 3 to capture the notion of knowledge bases. It suffices to find a logical representation for each KB in Definition 3. By logical representations, we use theories of McCarthy's circumscription under the unique name assumption.\nProposition 2. Let K be a KB over $(\\mathcal{D}, \\mathcal{Q})$, and \u03c3 be the set consisting of all CWA-predicate symbols in $\\sigma_{D}$. Then there are a set \u2211 of FO-sentences such that, for all $D \\in \\mathcal{D}$ and $\\phi \\in \\mathcal{Q}, Mod_{v}^{min}(D, \\sum, v_{c}) |= \\phi$ iff $(D, \\phi) \\in \\mathcal{K}$.\nSketched Proof. The main idea involves constructing a rule for each pair (D, $\\phi$) \u2208 K such that its body describes D and its head records $\\phi$. If the facts in D have been observed, the rule will be triggered to support QA on $\\phi$. Let \u2211 be the set of all such rules. We can prove that \u2211 is the desired set.\nFormalisms. Based on the definition of abstract knowledge bases, we are now able to present a general definition of formalisms for representing knowledge in AI systems."}, {"title": null, "content": "Definition 5. A quasi knowledge representation formalism (qKRF) over $(\\mathcal{D}, \\mathcal{Q})$ is defined as a mapping \u0393 such that\n1. $dom(\u0393)$ is recursive subset of ${0, 1}^{*}$, and each string in $dom(\u0393)$ is called a theory of \u0393;\n2. \u0393 maps each theory \u03c0 \u03bff \u0393 to a KB over $(\\mathcal{D}, \\mathcal{Q})$.\nMoreover, a qKRF \u0393 is a knowledge representation formalism (KRF) if it admits an additional property as follows:\n3. It is recursively enumerable to check, given $\\pi \\in dom(\u0393), D \\in \\mathcal{D}$ and $\\phi \\in \\mathcal{Q}$, whether $(D, \\phi) \\in \u0393(\\pi)$ or not.\nIn the above definition, the three properties establish key requirements for every knowledge representation formalism: Property 1 stipulates that the formalism must possess a language with an effective method for determining whether a given expression is legal; Property 2 defines the semantics of the formalism by associating each legal expression (or theory) in the language with an abstract knowledge base; and Property 3 ensures the implementability of the formalism by requiring that there exists a Turing machine capable of solving the query answering problem for this formalism.\nExample 4. Suppose $\\mathcal{D}_{OS}$ involves no CWA-predicate symbols. Let $L \\in {FO, SO}$ and $\\sigma \\supseteq (\\sigma_{D} \\cup \\sigma_{Q}) \\setminus \\Delta$ be a signature. Let \u0393L be a mapping that maps each finite set \u03a3 of \u03c3-sentences in L to a KB $\\mathcal{K}_{\\sum}$ defined as follows:\n$\\mathcal{K}_{\\sum} := {(D, \\phi) \\in \\mathcal{D} \\times \\mathcal{Q} : D \\cup \\sum \\models \\phi}$.\nIt is easy to verify that both FFO and Iso are qKRFs over $(\\mathcal{D}, \\mathcal{Q})$, and the former is a KRF, but the latter is not.\nUniversal KRFS\nIn the last section, we have proposed a very general definition for knowledge representation formalisms. Both in theory and in practice, we would like the underlying knowledge representation formalism to be as expressive as possible. In this section, we will study what universal (q)KRFs are, and prove some interesting properties that such (q)KRFs enjoy.\nThere are at least two natural ways to define the class of universal (q)KRFs. The first is from a perspective on expressive power. We first present a notion defined in this way.\nDefinition 6. A qKRF \u0413 over $(\\mathcal{D}, \\mathcal{Q})$ is said to be expressively complete if $ran(\u0393)$ consists of all the recursively enumerable KBs over $(\\mathcal{D}, \\mathcal{Q})$.\nAccording to the above definition, given an expressively complete qKRF \u0393, for each knowledge base K represented in \u0393, there exists a Turing machine to implement query answering on K. However, this does not guarantee that \u0393 itself qualifies as a KRF. To be a KRF, \u0393 must have a single Turing machine capable of implementing query answering for all knowledge bases it represents. This leads to a natural question: Is there an expressively complete KRF? We will answer this question in the remainder of this section.\nAnother natural approach to defining universal KRFs involves reducibility between KRFs, defined as follows:\nDefinition 7. Let \u0393 and $\u0393_{0}$ be KRFs over $(\\mathcal{D}, \\mathcal{Q})$. Then I is reducible to $\u0393_{0}$ if there is a recursive function $\\rho : dom(\u0393) \\rightarrow dom(\u0393_{0})$ such that $\u0393 = \u0393_{0} \\circ \\rho$. In addition, we call \u03c1 a reduction from \u0393 to $\u0393_{0}$."}, {"title": null, "content": "With this notion, universal KRFs can be defined as below:\nDefinition 8. Let \u0393 be a KRF over $(\\mathcal{D}, \\mathcal{Q})$. Then I is said to be universal if every KRF over $(\\mathcal{D}, \\mathcal{Q})$ is reducible to \u0393.\nIn other words, a universal KRF is a formalism such that query answering with any KB represented in a KRF can be implemented in the underlying formalism by an effective translation. Note that translating is a rather general approach to implement knowledge reasoning systems, and implementing knowledge reasoning systems by procedural (or other kinds of) programs is in fact a type of translations. These thus demonstrate why the above definition is natural for universal formalisms of knowledge representation.\nIn order for Definition 8 to make sense, we have to answer the following question: Is there indeed a universal KRF according to this definition? At first glance, the answer to this question appears to be obviously affirmative. For example, as we know, every recursively enumerable KB can be accepted by a Turing machine. So, a naive idea is by defining a mapping \u0393 as follows: If M is Turing machine recognizing some KB K, then let \u0393([M]) := K. Unfortunately, such a mapping is not possible to be a KRF because $dom(\u0393)$ is not recursive. Notice that the latter is an immediate corollary of Rice's theorem, see, e.g., (Rogers 1987).\nTo construct the desired KRF, our general idea is by carefully identifying a recursive subset L of $dom(\u0393)$ such that the restriction of I to L is a KRF. To implement it, we propose an effective transformation to convert every Turing machine M to a Turing machine $M^{*}$ that accepts a KB. The class of arbitrary Turing machines is clearly recursive. Since the transformation is effective, the class of Turing machines $M^{*}$, where M is an arbitrary Turing machine, is thus recursive, too. This then implements the general idea.\nNext, we show how to construct the transformation. Some notations are needed. Given a Turing machine M, let\n$\\mathcal{K}(M) := {(D, \\phi) \\in \\mathcal{D} \\times \\mathcal{Q} : M accepts [D, \\phi]}$.\nGiven a subclass K of $\\mathcal{D} \\times \\mathcal{Q}$, let $cl(\\mathcal{K})$ denote the minimum superclass of K which admits Properties 1-5 in Definition 3. We need to assure the desired transformation $(\\cdot)^{*}$ satisfying the property: $\\mathcal{K}(M^{*}) = cl(\\mathcal{K}(M))$.\nThe desired machine $M^{*}$ is constructed from M by implementing Procedure 1. Now, let us explain how $M^{*}$ works. Let $D \\in \\mathcal{D}$ and $\\phi \\in \\mathcal{Q}$. Roughly speaking, the computation of $M^{*}$ on the input [D, $\\phi$] can be divided into six parts:\n1. Simulate M on [D, $\\phi$]; accept if M accepts.\n2. Check whether $\\phi$ is a tautology; accept if true.\n3. Check whether there is a sentence $\\psi \\in \\mathcal{Q}$ such that $\\phi \\models \\psi$ and that $M^{*}$ accepts [D, \u03c8]; accept if true.\n4. Check whether there exist a pair of sentences $\\psi, \\chi \\in \\mathcal{Q}$ such that $\\phi = \\psi \\land \\chi$ and that $M^{*}$ accepts both [D, \u03c8] and [D, \u03c7]; accept if true.\n5. Check whether there is a database $D^{\\prime} \\in \\mathcal{D}$ such that D extends $D^{\\prime}$ and that $M^{*}$ accepts [$D^{\\prime}$, \u03c6]; accept if true.\n6. Check whether there is a constant renaming (in fact, only need to consider injective functions from C to A where C is the set of constants appearing in either $D_{C}(D)$ or $\\phi$) $\\tau$ such that $M^{*}$ accepts [\u03c4(D), \u03c4(\u03c6)]; accept if true."}, {"title": null, "content": "A direct implementation of the above procedure is generally impossible due to the following issues: Firstly, computations on Parts 1-6 may not terminate. Secondly, Part 3 needs to enumerate all sentences $\\phi$ in $\\mathcal{Q}$, and Part 6 involves generating all possible constant renamings for D, both enumerations are infinite. Thirdly, Parts 3-6 also involve recursive invocations of $M^{*}$, which makes the situation even worse.\nTo address these challenges, we introduce a task array T, where the i-th task is stored in T[i]. Although there could be an infinite number of nonterminating tasks in T, we can apply a standard technique to sequentially simulate multiple such tasks. This can be visualized using a coordinate system where the x-axis represents the number of steps and the y-axis denotes task indices. The simulation is actually a procedure to traverse the first quadrant of this coordinate system. An atomic task is a tuple t := (N, $p_{1},..., p_{k}$), where N is a Turing machine and $p_{1}, ..., p_{k}$ its parameters. Performing t involves simulating N on the input [$p_{1},..., p_{k}$], with t being successful if N accepts. Every task is either an atomic task or a finite sequence of atomic tasks t := ($t_{1},...,t_{n}$). Executing t means sequentially performing the atomic tasks $t_{1},..., t_{n}$. The task t is said to be successful or to succeed if all its constituent atomic tasks succeed.\nMoreover, let $M_{e}$ denote a Turing machine that accepts [$\\psi, \\phi$] iff $\\phi, \\psi$ are a pair of FO-sentences such that $\\phi \\models \\psi$. For a technical reason, let $M_{\u03b7}$ denote a Turing machine that accepts [\u03b7] iff \u03b7 is an injective partial functions on \u0394.\nAs there might be an infinite number of tasks, we require $M^{*}$ to perform current tasks and generate new tasks at the same time. For example, in Part 1, we perform the first step of the task (M, D, $\\phi$) and add new tasks such as ($M_{e}, \\tau, \\phi$) to T in the same for-loop, see Lines 20-41 of Procedure 1. Using the task array T, infinite enumerations can then be removed. For instance, to handle the infinite enumeration of queries in $\\mathcal{Q}$ in Part 3, we start by letting $\\psi$ be the first query (in the order of a natural encoding) in $\\mathcal{Q}$, and add the task\nt := (($M_{e}, \\psi, \\phi$), (M, D, \u03c8))\nto T. When t is eventually executed, we add the task\n(($M_{e}, \\chi, \\phi$), (M, D, \u03c7))\nto T, where \u03c7 is the next query after \u03c8 in $\\mathcal{Q}$. By repeating this process, we effectively enumerate all queries in $\\mathcal{Q}$. For details, see Lines 22-23, 27-28, and 42-47 in Procedure 1.\nMoreover, recursive invocations can be eliminated by utilizing the task array T, too. For instance, to compute $M^{*}$ on the input [D, $\\phi$] in Part 3, we simply add the task (M, D, \u03c8) to T. As per Lines 20-42 of Procedure 1, when (M, D, \u03c8) is initiated, all tasks of computing the closure will be added to T orderly to implement the computation of ($M^{*}$, D, \u03c8).\nA flag array F records the completion status of each task as either true or false. The relationships between tasks are tracked using arrays p (parent) and c (cooperation). Specifically, p[n] = i indicates that the task T[n] is generated from the task T[i], making T[i] the parent of T[n]. A value of c[i] = -1 signifies that the task T[i] operates independently. If T[i] succeeds, its parent task's flag, F[p[i]], is set to true. Otherwise, if c[i] = j \u2260 \u22121, the task T[i] must cooperate with the task T[j]. Only when both T[i] and T[j] succeed"}, {"title": null, "content": "does the parent task's flag, F[p[i"}]}