{"title": "Large Language Monkeys: Scaling Inference Compute with Repeated Sampling", "authors": ["Bradley Brown", "Jordan Juravsky", "Ryan Ehrlich", "Ronald Clark", "Quoc V. Le", "Christopher R\u00e9", "Azalia Mirhoseini"], "abstract": "Scaling the amount of compute used to train language models has dramatically improved their capabilities. However, when it comes to inference, we often limit the amount of compute to only one attempt per problem. Here, we explore inference compute as another axis for scaling by increasing the number of generated samples. Across multiple tasks and models, we observe that coverage the fraction of problems solved by any attempt - scales with the number of samples over four orders of magnitude. In domains like coding and formal proofs, where all answers can be automatically verified, these increases in coverage directly translate into improved performance. When we apply repeated sampling to SWE-bench Lite, the fraction of issues solved with DeepSeek-V2-Coder-Instruct increases from 15.9% with one sample to 56% with 250 samples, outperforming the single-attempt state-of-the-art of 43% which uses more capable frontier models. Moreover, using current API pricing, amplifying the cheaper DeepSeek model with five samples is more cost-effective and solves more issues than paying a premium for one sample from GPT-40 or Claude 3.5 Sonnet. Interestingly, the relationship between coverage and the number of samples is often log-linear and can be modelled with an exponentiated power law, suggesting the existence of inference-time scaling laws. Finally, we find that identifying correct samples out of many generations remains an important direction for future research in domains without automatic verifiers. When solving math word problems from GSM8K and MATH, coverage with Llama-3 models grows to over 95% with 10,000 samples. However, common methods to pick correct solutions from a sample collection, such as majority voting or reward models, plateau beyond several hundred samples and fail to fully scale with the sample budget.", "sections": [{"title": "Introduction", "content": "The ability of large language models (LLMs) to solve coding, mathematics, and other reasoning tasks has improved dramatically over the past several years [42, 11]. Scaling up model training has been a consistent driver of these gains. Investments in larger models, larger pre-training datasets, and more extensive post-training (e.g. through collecting human preference labels) has led to remarkably capable generalist systems [2, 3, 4, 47].\nIn contrast, a comparatively limited investment has been made in scaling the amount of computation used during inference. Larger models do require more inference compute than smaller ones, and prompting techniques like chain-of-thought [56] can increase answer quality at the cost of longer (and therefore more computationally expensive) outputs. However, when interacting with LLMs, users and developers often restrict models to making only one attempt when solving a problem. In this work, we investigate repeated sampling (depicted in Figure 1) as an alternative axis for scaling inference compute to improve LLM reasoning performance.\nThe effectiveness of repeated sampling is determined by two key properties:\n1. Coverage: As the number of samples increases, what fraction of problems can we solve using any sample that was generated?\n2. Precision: In settings where we must select a final answer from the collection of generated samples, can we identify correct samples?\nWith unlimited attempts, any model that assigns a non-zero probability to every sequence will achieve perfect coverage. However, repeated sampling is only practical if we can improve coverage with a feasible budget. Moreover, without the ability to decide between samples, the applications of repeated sampling are limited. Existing work provides encouraging evidence along both of these directions, showing examples of repeated sampling improving performance in math, coding, and puzzle-solving settings [55, 43, 22]. Notably, AlphaCode [37], a state-of-the-art system for competitive programming, finds that performance continues to improve with a million samples per problem.\nHere, we show that repeated sampling is an effective methodology for improving coverage across a range of tasks, models, and sample budgets. For example, when solving CodeContests [37] programming problems using Gemma-2B [48], we increase coverage by over 300x as we scale the number of samples, from 0.02% with one attempt to 7.1% with 10,000 attempts. Interestingly, the relationship between log(coverage) and the number of samples often follows an approximate power law. With Llama-3 [3] and Gemma models, we observe that coverage grows nearly log-linearly with the number of samples over several orders of magnitude.\nIn settings where all of a model's solutions can be automatically verified, such as with proof checkers or unit tests, these increases in coverage translate directly into improved task performance. When applying repeated sampling to competitive programming and writing Lean proofs, models like Llama-3-8B-Instruct can exceed the single-attempt performance of much stronger ones like GPT-40 [2]. This ability to amplify weaker models extends to the challenging SWE-bench Lite dataset of real-life GitHub issues [30], where the current single-attempt state-of-the-art (SOTA), achieved by a mixture of GPT-40 and Claude 3.5 Sonnet models, is 43% [1]. When given a single attempt, DeepSeek-Coder-V2-Instruct [19] achieves only 15.9% on the benchmark. By simply increasing the number of attempts to 250, we increase the fraction of solved problems to 56%, exceeding the single-attempt state-of-the-art by 13%.\nIn addition to improving model quality, repeated sampling provides a new mechanism for minimizing LLM inference costs. When holding the total number of inference FLOPs constant, we find that on some datasets (e.g. MATH) coverage is maximized with a smaller model and more attempts, while on others (e.g CodeContests) it is better to use a larger model. We also compare API prices between DeepSeek-V2-Coder-Instruct, GPT-40, and Claude Sonnet 3.5 in the context of solving SWE-bench Lite issues. When keeping the agent framework (Moatless Tools [62]) constant, sampling five times from the weaker and cheaper DeepSeek model solves more issues than single attempts from Claude or GPT, while also being over 3x cheaper.\nFinally, in math word problem settings, where answers cannot be automatically verified by existing tools, we identify a large gap between coverage and the performance of common methods for deciding on a final answer. When solving MATH [24] problems with Llama-3-8B-Instruct, coverage increases from 79.8% with 100 samples to 95.3% with 10,000 samples. However, methods such as majority voting and using reward models plateau with a lower sample budget, scaling only from 38.7% to 39.8% over the same range. These results highlight that building robust verifiers remains an open problem.\nIn summary, our primary observations are:\n1. We demonstrate that scaling inference compute through repeated sampling leads to large improvements in coverage across a variety tasks, models, and sample budgets. This makes it possible, and sometimes cost-effective, to amplify weaker models with many samples and outperform single attempts from more capable models. Notably, we are able to solve 56% of issues from SWE-bench Lite by sampling 250 times from DeepSeek-V2-Coder-Instruct, exceeding the single-attempt SOTA of 43%.\n2. We show that the relationship between coverage and the number of samples can often be modelled using an exponentiated power law, suggesting a form of scaling laws for inference-time compute.\n3. In domains without automatic verifiers, we show that common approaches to verification like majority voting and reward model scoring plateau beyond approximately 100 samples. This leads to a growing gap between the performance achieved with these methods and the coverage upper bound."}, {"title": "Scaling Repeated Sampling", "content": "We focus on pass-fail tasks where a candidate solution can be scored as right or wrong. The primary metric of interest for these tasks is the success rate: the fraction of problems that we are able to solve. With repeated sampling, we consider a setup where a model can generate many candidate solutions while attempting to solve a problem. The success rate is therefore influenced both by the ability to generate correct samples for many problems (i.e. coverage), as well as the ability to identify these correct samples (i.e. precision).\nThe difficulty of the precision problem depends on the availability of tools for sample verification. When proving formal statements in Lean, proof checkers can quickly identify whether a candidate solution is correct. Similarly, unit tests can be used to verify candidate solutions to coding tasks.\nIn these cases, precision is handled automatically, and improving coverage directly translates into higher success rates. In contrast, the tools available for verifying solutions to math word problems from GSM8K and MATH are limited, necessitating additional verification methods that decide on a single final answer from many (often conflicting) samples.\nWe consider the following five tasks:\n1. GSM8K: A dataset of grade-school level math word problems [18]. We evaluate on a random subset of 128 problems from the GSM8K test set.\n2. MATH: Another dataset of math word problems that are generally harder than those from GSM8K [13]. Similarly, we evaluate on 128 random problems from this dataset's test set.\n3. MiniF2F-MATH: A dataset of mathematics problems that have been formalized into proof checking languages [60]. We use Lean4 as our language, and evaluate on the 130 test set problems that are formalized from the MATH dataset.\n4. CodeContests: A dataset of competitive programming problems [37]. Each problem has a text description, along with a set of input-output test cases (hidden from the model) that can be used to verify the correctness of a candidate solution. We enforce that models write their solutions using Python3.\n5. SWE-bench Lite: A dataset of real world Github issues, where each problem consists of a description and a snapshot of a code repository [30]. To solve a problem, models must edit files in the codebase (in the Lite subset of SWE-bench that we use, only a single file needs to be changed). Candidate solutions can be automatically checked using the repository's suite of unit tests.\nAmong these tasks, MiniF2F-MATH, CodeContests, and SWE-bench Lite have automatic verifiers (in the form of the Lean4 proof checker, test cases, and unit test suites, respectively). We begin by investigating how repeated sampling improves model coverage. Coverage improvements correspond directly with increased success rates for tasks with automatic verifiers and in the general case provide an upper bound on the success rate. In coding settings, our definition of coverage is equivalent to the commonly-used pass@k metric [15], where k denotes the number of samples per problem. We use this metric directly when evaluating on CodeContests and SWE-bench Lite. For MiniF2F the metric is similar, with a \"pass\" defined according to the Lean4 proof checker. For GSM8K and MATH, coverage corresponds to using an oracle verifier that checks if any sample \"passes\" by outputting the correct final answer. To reduce the variance when calculating coverage, we adopt the unbiased estimation formula from Chen et al. [15]. In each experiment, we first generate N samples for each problem index i and calculate the number of correct samples Ci. We then calculate the pass@k scores at each k \u2264 N of interest according to:\npass@k = \\frac{1}{\\text{# of problems}} \\sum_{i=1}^{\\text{# of problems}} \\left(1 - {\\binom{N-C_i}{k} \\over {\\binom{N}{k}}}\\right) \\qquad (1)\nWe use the numerically stable implementation of the above formula suggested in Chen et al. [15]. Results and code will be available at https://scalyresearch.stanford.edu/pubs/large_language_monkeys/."}, {"title": "Repeated Sampling is Effective Across Tasks", "content": "Here, we establish that repeated sampling improves coverage across multiple tasks and a range of sample budgets. We evaluate Llama-3-8B-Instruct and Llama-3-70B-Instruct on CodeContests, MiniF2F, GSM8K, and MATH, generating 10,000 independent samples per problem. For SWE- bench Lite, we use DeepSeek-V2-Coder-Instruct [19], as the required context length of this task exceeds the limits of the Llama-3 models. As is standard when solving SWE-bench issues, we equip our LLM with a software framework that provides the model with tools for navigating through and editing codebases. In our work, we use the open-source Moatless Tools library [62]. Note that solving a SWE-bench issue involves a back-and-forth exchange between the LLM and Moatless Tools. One sample/attempt for this benchmark refers to one entire multi-turn trajectory. To minimize costs, we restrict the number of attempts per issue to 250, with all attempts made independently of one another.\nWe report our results in Figure 2. We also include the single-attempt performance of GPT-40 on each task, as well the single-attempt state-of-the-art for SWE-bench Lite (CodeStory Aide [1] which uses a combination of GPT-40 and Claude 3.5 Sonnet). Across all five tasks, we find that coverage smoothly improves as the sample budget increases. When all LLMs are given a single attempt, GPT-40 outperforms the Llama and DeepSeek models at every task. However, as the number of samples increases, all three of the weaker models exceed GPT-40's single-attempt performance. In the case of SWE-bench Lite, we solve 56% of problems, exceeding the single-attempt SOTA of 43%."}, {"title": "Repeated Sampling is Effective Across Model Sizes and Families", "content": "The results from Section 2.1 indicate that repeated sampling improves coverage. However, we only show this trend for three recent, instruction-tuned models with 8B or more parameters. We now show that these trends hold across other model sizes, families, and levels of post-training. We expand our evaluation to include a broader set of models:\n\u2022 Llama 3: Llama-3-8B, Llama-3-8B-Instruct, Llama-3-70B-Instruct.\n\u2022 Gemma: Gemma-2B, Gemma-7B [48].\n\u2022 Pythia: Pythia-70M through Pythia-12B (eight models in total) [9].\nWe restrict evaluation to the MATH and CodeContests datasets to minimize inference costs, reporting results in Figure 3. Coverage increases across almost every model we test, with smaller models showing some of the sharpest increases in coverage when repeated sampling is applied. On CodeContests, the coverage of Gemma-2B increases by over 300x, from a pass@1 of 0.02% to a pass@10k of 7.1%. Similarly, when solving MATH problems with Pythia-160M, coverage increases from a pass@1 of 0.27% to a pass@10k of 57%.\nThe exception to this pattern of increasing coverage across models is with the Pythia family evaluated on CodeContests. All Pythia models achieve zero coverage on this dataset, even with a budget of 10,000 samples. We speculate that this due to Pythia being trained on less coding-specific data than Llama and Gemma."}, {"title": "Repeated Sampling Can Help Balance Performance and Cost", "content": "One takeaway from the results in Sections 2.1 and 2.2 is that repeated sampling makes it possible to amplify a weaker model's capabilities and outperform single samples from stronger models. Here, we demonstrate that this amplification can be more cost-effective than using a stronger, more expensive model, providing practitioners with a new degree of freedom when trying to jointly optimize performance and costs.\nWe first consider FLOPs as a cost metric, examining the Llama-3 results from Section 2.1. We re-plot our results from Figure 2, now visualizing coverage as a function of total inference FLOPs instead of the sample budget. Since Llama-3 models are dense transformers where the majority of parameters are used in matrix multiplications, we approximate inference FLOPs with the formula:\nFLOPs per token \u2248 2 * (num parameters + 2 * num layers * token dim * context length)\ntotal inference FLOPs \u2248 num prompt tokens * FLOPs per token\n+ num decoded tokens * FLOPs per token * num completions\nInterestingly, the model that maximizes coverage varies with the compute budget and task. On MiniF2F, GSM8K and MATH, Llama-3-8B-Instruct always obtains higher coverage than the larger (and more expensive) 70B model when the FLOP budget is fixed. However for CodeContests, the 70B model is almost always more cost effective. We note that examining FLOPs alone can be a crude cost metric that ignores other aspects of system efficiency [20]. In particular, repeated sampling can make use of high batch sizes and specialized optimizations that improve system throughput relative to single-attempt inference workloads [32, 6, 61]. We discuss this in more detail in Section 5.\nWe also examine the dollar costs of repeated sampling when solving SWE-bench Lite issues using current API pricing. Keeping the agent framework (Moatless Tools) constant, we consider making a single attempt per issue with Claude 3.5 Sonnet and GPT-40, as well as repeated sampling using DeepSeek-V2-Coder-Instruct. We report the average cost per issue and issue resolution rate with each approach in Table 1. While the DeepSeek model is weaker than the GPT and Claude models, it is also over 10x cheaper. In this case, repeated sampling provides a cheaper alternative to paying a premium for access to strong models while achieving a superior issue solve rate."}, {"title": "Characterizing the Benefits of Repeated Sampling", "content": "The relationship between an LLM's loss and its training compute has been well-characterized with training scaling laws [25, 33, 26]. These laws have empirically held over many orders of magnitude and inspire confidence in model developers that large investments in training will pay off. Inspired\nby training scaling laws, here we aim to better characterize the relationship between coverage and the sample budget (i.e. the amount of inference compute), presenting two interesting observations:\n1. The relationship between coverage and the number of samples can often be modelled with an exponentiated power law.\n2. For a given task, the coverage curves of different models from the same family resemble S-curves with similar slopes but distinct horizontal offsets."}, {"title": "Scaling Laws for Repeated Sampling", "content": "Here, we develop an explicit model for the relationship between coverage and the number of samples. The GPT-4 technical report [41] finds that the relationship between a model's mean-log-pass-rate on coding problems and its training compute can be modelled well using a power law. We start by adopting the same function class, but now modelling the log of coverage c as a function of the number of samples k:\nlog(c) \u2248 a{k}^{-b} \\qquad (2)\nwhere a, b \u2208 R are fitted model parameters. In order to directly predict coverage, we exponentiate both sides, ending up with the final model of:\nc \u2248 exp(a{k}^{-b}) \\qquad (3)\nWe provide examples of fitted coverage curves in Figure 5, and additional curves in Appendix C.2. While these laws are not as exact as training scaling laws (most strikingly on MiniF2F-MATH), they provide encouraging early evidence that the benefits of inference scaling can be characterized."}, {"title": "Similarities in Coverage Curves Across Models", "content": "Interestingly, when comparing the coverage curves (with a logarithmic x-axis) of different models from the same family on the same task (see Figure 3), it appears that the traced S-curves have the same slope, but unique horizontal offsets. To investigate this further, we overlay the coverage curves of different models from the same family in Figure 6. We do this by picking an anchor coverage value c, and shifting every curve leftward (in log-space) so that each passes through the point (1, c). This corresponds to a leftward shift by log(pass@k^{-1}(c)), where pass@k^{-1}(c) denotes the closest natural number k such that pass@k = c. We pick c to be the maximum pass@1 score over all models from the same family. These similarities demonstrate that across models from the same family, the increase in the log-sample-budget (or equivalently, the multiplicative increase in the sample budget) needed to improve coverage from c to c' is approximately constant."}, {"title": "Harnessing Repeated Sampling Requires Precision", "content": "So far, we have focused on measuring model coverage, characterizing the benefits of repeated sampling under the best-case scenario where we can always identify correct model samples. We now turn to the complementary problem of precision: given a collection of model samples, can we identify the correct ones? In Section 4.1, we evaluate two common verification methods (majority voting and reward model scoring) on GSM8K and MATH. Additionally, in Section 4.2, we discuss potential pitfalls when relying on unit tests to identify correct software programs."}, {"title": "Common Verification Methods Don't Always Scale with the Sample Budget", "content": "Of the five tasks we evaluate, only GSM8K and MATH lack tools for automatically verifying solutions. Here, we evaluate two common approaches to deciding on a final answer: calculating a majority vote across samples and using a reward model to assign a score to each sample. We test these techniques on their ability to identify correct solutions from the 10,000 samples we generated with Llama-3-8B-Instruct and Llama-3-70B-Instruct in Section 2. We benchmark three methods:\n1. Majority Vote: We pick the most common final answer [55].\n2. Reward Model + Best-of-N: We use a reward model [17] to score each solution, and pick the answer from the highest-scoring sample.\n3. Reward Model + Majority Vote: We calculate a majority vote where each sample is weighted by its reward model score.\nWe use ArmoRM-Llama3-8B-v0.1 [53] as a reward model, which currently has the highest reasoning score on the RewardBench leaderboard [35] among open-weight models. We report our results in Figure 7 as we increase the number of samples. While success rate initially increases with the number of samples for all three methods, it plateaus around 100 samples. Meanwhile, coverage continues to increase with the number of samples and exceeds 95%.\nIn the case of majority voting, this success rate saturation is easily explainable. As the number of samples increases, the proportion of votes allocated to each answer stabilizes, and therefore the success rate plateaus. For some GSM8K and MATH problems, correct solutions are sampled with a probability of 1% or lower (see Figure 8), making them a minority of samples. As the number of samples increases, rare correct solutions will appear for more problems, increasing coverage but not the success rate with majority voting. In order to fully benefit from repeated sampling, sample identification methods must be able to solve these \u201cneedle-in-a-haystack\" cases and identify rare, correct samples.\nGiven the poor performance of the reward model, it is reasonable to wonder how \u201chard\" it is to verify a candidate solution. With GSM8K and MATH, only a sample's final answer is used for assessing correctness, with the intermediate chains of thought being excluded. If models generated only non-sensical chains of thought before guessing a correct final answer, verification may not be any easier than solving the problem in the first place. We investigate this question by manually evaluating 105 chains of thought from correct Llama-3-8B-Instruct solutions to GSM8K problems, reporting our results in Table 2. We find that over 90% of the chains of thought that we graded are faithful, even among problems where correct answers are generated infrequently. These correct reasoning steps indicate that there is signal for a verifier to exploit when identifying correct samples. Interestingly, during this process we also identified one GSM8K problem that has an incorrect ground truth answer (see Appendix E). This incorrect GSM8K problem is also the only one that Llama-3-70B-Instruct did not generate a \"correct\" sample for across 10,000 attempts."}, {"title": "Verifiers and Software Tasks: Two Cautionary Tales", "content": "Software development tasks can occupy a middle-ground with respect to available verification tools. On one hand, the ability to execute and test code allows for a higher degree of automatic verification than is possible with unstructured language tasks. However, tools like unit tests take a black-box approach to verifying a piece of code and are not as comprehensive as methods like proof checkers. These imperfections in the verification process can lead to false positives and/or false negatives that are important to consider when applying repeated sampling. Below we provide two examples of software verifier imperfections that we encountered when generating our results from Section 2.1."}, {"title": "Flaky Tests in SWE-bench Lite", "content": "When producing our results on SWE-bench Lite, we identified that 11.3% of problems have flaky test suites that do not produce consistent results when running them on the same candidate solution. These flaky tests occasionally classify even the dataset's ground-truth issue solutions as incorrect. Additionally, the test suites for some issues can be non-determinstic depending on the candidate solution. For example, two SWE-bench Lite issues involve manipulating Python sets, which are naturally unordered. The gold solutions for these issues explicitly order the items in the set and pass the test suites reliably. However, some model-generated candidate solutions do not impose such an ordering, and therefore pass the tests on some \"lucky\" runs and not others. In Appendix B, we list all of the problem IDs where we identified flaky tests. We also report our SWE-bench Lite results from Figure 2 with the problematic issues removed, finding similar results to our evaluations on the whole dataset."}, {"title": "False Negatives in CodeContests", "content": "Each problem from the CodeContests dataset comes with a set of input-output test cases used to asses the correctness of solutions. These test cases are more comprehensive than those from earlier coding benchmarks like APPS [23], cutting down on the frequency of false positive solutions that pass all test cases but do not fully solve the described problem. However, the construction of the CodeContests test suites leads to false negative solutions that are correct but fail the tests.\nFor some CodeContests problems, the problem description allows for multiple distinct correct outputs for a given test input. However, the corresponding test cases do not handle these scenarios, instead requiring that one particular correct output is emitted. Additionally, many CodeContests test cases have been programmatically generated by mutating original test cases from the problem. Some mutated inputs violate the problem's input specifications (e.g. a mutated input being zero when the description promises a positive integer). These malformed test cases can lead to inconsistent behaviour between different correct solutions."}, {"title": "Discussion and Limitations", "content": "In this work, we explore repeated sampling as an axis for scaling compute at inference time in order to improve model performance. Across a range of models and tasks, repeated sampling can significantly improve the fraction of problems solved using any generated sample (i.e. coverage). When correct solutions can be identified (either with automatic verification tools or other verification algorithms), repeated sampling can amplify model capabilities during inference. This amplification can make the combination of a weaker model and many samples more performant and cost-effective than using fewer attempts from a stronger, more expensive model."}, {"title": "Improving Repeated Sampling", "content": "In our experiments, we explore only a simple version of repeated sampling where all attempts to a problem are generated independently of one another using the exact same prompt and hyperparameters. We believe that this setup can be refined to improve performance, particularly along the following directions:\n1. Solution Diversity: We currently rely on a positive sampling temperature as the sole mech- anism for creating diversity among samples. Combining this token-level sampling with other, higher-level approaches may be able to further increase diversity. For example, AlphaCode conditions different samples with different metadata tags.\n2. Multi-Turn Interactions: Despite automatic verification tools being available when solving CodeContests and MiniF2F problems, we use only a single-turn setup where models generate a solution without any ability to iterate on it. Providing models with execution feedback from these tools should improve solution quality. We are interested in the tradeoffs associated with multi-turn interactions, since each attempt becomes more expensive, but also may be more likely to succeed.\n3. Learning From Previous Attempts: Currently, our experiments fully isolate attempts from each other. Access to existing samples, particularly if verification tools can provide feedback on them, may be helpful when generating future attempts."}, {"title": "Repeated Sampling and Inference Systems", "content": "Repeated sampling is a distinct LLM inference workload from serving chatbot requests. Production chatbot deployments place an emphasis on low response latencies, and adhering to latency targets can force a lower per-device batch size and reduce hardware utilization. In contrast, when sampling many completions to a single prompt, a larger emphasis can be placed on overall throughput and maximizing hardware utilization. Additionally, repeated sampling can benefit from specialized attention optimizations that exploit overlaps in prompts across sequences [32, 6, 61]. Repeated sampling inference can therefore be accomplished at a lower cost than naively making many parallel requests to a chatbot-oriented API. These cost savings can further motivate choosing to sample many times from a cheaper model instead of fewer times from a more expensive one."}, {"title": "Verifiers", "content": "Our results from Section 4 highlight the importance of improving sample verification methods when tools for automatically doing so are unavailable. Equipping models with the ability to assess their own outputs will allow repeated sampling to be scaled to far more tasks. Of particular interest is applying repeated sampling to unstructured tasks like creative writing, which can require a more subjective comparison between different samples than the pass-fail tasks we consider. An alternative direction to developing model-based verifiers is to design converters that can make an unstructured task verifiable, for example by formalizing an informal math statement into a language like Lean so that proof checkers can be applied."}, {"title": "Related Work", "content": "Scaling Inference Compute: Methods that perform additional computation during inference have been successful across many areas of deep learning. Across a variety of game environments, state-of- the-art methods leverage inference-time search that examines many possible future game states before deciding on a move [12, 45, 10]. Similar tree-based methods can also be effective in combination with LLMs, allowing models to better plan and explore different approaches [58, 8, 49, 50]. Another axis for increasing LLM inference compute allows models to spend tokens deliberating on a problem before coming to a solution [57, 56, 59]. Additionally, multiple models can be ensembled together at inference time to combine their strengths [54, 14, 40, 52, 29]. Yet another approach involves using LLMs to critique and refine their own responses [39, 7].\nRepeated Sampling: Previous work has demonstrated that repeated sampling can improve LLM capabilities in multiple domains. One of the most effective use cases is coding [43, 15, 34], where performance continues to scale up to a million samples and verification tools (e.g. unit tests) are often available to automatically score every candidate solution. Recently, Greenblatt [22] shows that repeated sampling is effective when solving puzzles from the ARC challenge [16], observing log-linear scaling as the number of samples increases. In chat applications, repeated sampling combined with best-of-N ranking with a reward model can outperform greedily sampling a single response [28]. In domains without automatic verification tools, existing work shows that using majority voting [55] or a trained model-based verifier [18, 38, 27] to decide on a final answer can improve performance on reasoning tasks relative to taking a single sample. Concurrent with our work, Song et al. [46] finds that using the best available sample improves LLM performance on chat, math, and code tasks, sweeping up to a max of 128 samples.\nScaling Laws: Characterizing how scaling affects model performance can lead to more informed decisions on how to allocate resources. Scaling laws for LLM training find a power law relationship between loss and the amount of training compute and provide estimates for the optimal model and dataset size given a fixed compute budget [25, 33, 26]. Jones [31] finds scaling laws in the context of the board game Hex, observing that performance scales predictably with model size and the difficulty of the problem. Interestingly, they also show that performance scales with the amount of test-time compute spent while performing tree search. Recently, Shao et al. [44] observe scaling laws when augmenting LLMs with external retrieval datasets, finding that performance on retrieval tasks scales smoothly with the size of the retrieval corpus."}, {"title": "Sampling Experimental Setup", "content": "We report results on the 130 questions in the test set of the lean4 MiniF2F dataset that correspond to formalized MATH problems. This dataset is derived from the fixed version of the original MiniF2F dataset created by Zheng et al. [60]. We sample with a temperature of 0.5 and do not use nucleus sampling. We generated 10,000 samples per problem. We use proofs of the following 5 theorems from the validation set as few-shot examples:\n\u2022 mathd_algebra_116\n\u2022 amc12_2000_p5\n\u2022 mathd_algebra_132\n\u2022 mathd_algebra_11\n\u2022 mathd_numbertheory_84\nOur prompt consists of:\n1. Few shot examples.\n2. Header imports present in each problem in the HuggingFace dataset cat-searcher/minif2f-lean4 dataset, an upload of the lean4 MiniF2F dataset.\n3. The theorem definition. In order to avoid leaking information about how to solve the theorem from its name, we replace the name of the theorem with theorem_i. i\u2208 {1,2,3,4,5} for the few-shot examples and i = 6 for the current problem.\nWe set 200 as the max token length for the generated solution. To grade solutions, we use the lean-dojo 1.1.2 library with lean version 4.3.0-rc2. We set a timeout of 10 seconds for every tactic step.\nWe report results on the 140 test set questions that do not include image tags in the problem description. We sample with a temperature of 0.6 and a top-p value of 0.95 following the experiments in CodeLlama [43]. We generate 10,000 samples per problem. We use two few-shot examples from the training set that are randomly sampled per-problem. We set 1024 as the max token length for the generated solution. We use the same answer comparison function as [37] and use the concatenation of public, private, and generated tests to validate correctness of solutions.\nWe report results on 128 randomly selected test-set problems. We sample with a temperature of 0.6 and do not use nucleus sampling. We use the fixed 5 few-shot example from [36] for each problem.\nWe generate 10,000 samples per problem. We set 512 as the max token length for the generated solution. To grade solutions, we use the minerva_math functions from LMEval [21].\nWe report results on 128 randomly sampled test-set problems. We sample with a temperature of 0.6 and do not use nucleus sampling. We use 5 few-shot examples from the training set that are randomly sampled per-problem. We generate 10,000 samples per problem. We set 512 as the max token length for the generated solution. To grade solutions, we follow LMEval [21]."}, {"title": "SWE-bench Lite", "content": ""}]}