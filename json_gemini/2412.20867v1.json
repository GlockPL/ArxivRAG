{"title": "Holistic Construction Automation with Modular Robots: From High-Level Task Specification to Execution", "authors": ["Jonathan K\u00fclz", "Michael Terzer", "Marco Magri", "Andrea Giusti", "Matthias Althoff"], "abstract": "In situ robotic automation in construction is challenging due to constantly changing environments, a shortage of robotic experts, and a lack of standardized frameworks bridging robotics and construction practices. This work proposes a holistic framework for construction task specification, optimization of robot morphology, and mission execution using a mobile modular reconfigurable robot. Users can specify and monitor the desired robot behavior through a graphical interface. Our framework identifies an optimized robot morphology and enables automatic real-world execution by integrating Building Information Modelling (BIM). By leveraging modular robot components, we ensure seamless and fast adaption to the specific demands of the construction task. Experimental validation demonstrates that our approach robustly enables the autonomous execution of robotic drilling.", "sections": [{"title": "I. INTRODUCTION", "content": "In recent decades, robotic automation in manufacturing significantly increased productivity [1]. To this day, a comparative technology leap in the construction sector has not occurred [2]\u2013[5]. Additionally, harsh, non-ergonomic working conditions result in labor shortages in the construction industry [6]. Robotic automation in construction, however, requires versatility, adaptability, and robustness as construction sites are complex, constantly changing, potentially hazardous, and hard to navigate [7].\n\nThe main contribution of this paper is a framework for in situ robotic automation that features (i) an autonomous decomposition of high-level instructions (e.g., \u201cdrill holes\" or \"paint wall\") into executable skills, (ii) identification of an optimized module composition for the robot arm using BIM data of the environment, (iii) online motion planning, and (iv) adaptions to positioning errors of the mobile base. The only actions required by the human worker are specification of the task and assembly of robot modules once the optimization of their composition terminates. While our framework is not limited to a particular task, we focus on autonomous drilling as shown in Figure 1. A supplementary video of the real-world experiment and more can be found on the project website modular-construction-robot.cps.cit.tum.de."}, {"title": "II. RELATED WORK", "content": "This section discusses previous applications of mobile manipulators in construction and, specifically, drilling use cases. Further, we provide an overview of current methods for optimizing modular robot compositions."}, {"title": "A. Robotic automation in building construction", "content": "Some construction tasks, such as cutting bricks or insulation panels, can be automated by special machinery or onsite manufacturing processes [8]. However, highly accurate and flexible interactions with the environment necessitate mobile robotic systems that can self-localize [9]. Navigating the highly unstructured environments of construction sites challenges the sensing and perception capabilities of robots. In [10], 3D scans taken with onboard sensors were used to enable navigation and localization of a bricklaying robot in situ. The perception can be further enriched with data from as-built BIM [11].\n\nLeveraging BIM data in construction has been shown to increase worker productivity [12] and accelerate the deployment of construction robotics [13]. However, as reported by [14], there is still a lack of research on integrating BIM with onsite robotic systems. Previous work proposed the integration of BIM data into a mission parametrization toolchain for non-experts and validated its effectiveness through a paint-spraying experiment [15].\n\nParticularly challenging use cases in construction robotics are precise power tool works on walls or ceilings, such as grinding or drilling holes. The challenges stem from uncertainties in robot perception and disturbances induced by operating the power tools. Recent works present an aerial system for drilling holes limited to free space areas and vertical walls or facades [16] or the development of a mobile manipulator with predefined reach and dexterity [17].\n\nRobots with a fixed kinematic, as presented by industrial manufacturers\u00b9 or in previous research [18]\u2013[20], may not provide the necessary flexibility required in construction [21]. Reconfigurable modular robots - comprising modular joints, links, and sensor modules \u2013 offer better transportability to and on the construction site and can also be adapted to specific requirements in situ. This aligns with previous research on digital in situ fabrication [22], which highlights that versatile, modular, and reusable solutions and real-world experiments are required to enable innovation in construction automation."}, {"title": "B. Optimizing modular robot composition", "content": "The optimization of robot morphologies, and more specifically, finding an optimal module composition for reconfigurable robots, has attracted attention for decades [23]\u2013[27]. Some approaches introduce heuristics and surrogate performance criteria to enable a brute-force search over reduced search spaces [28]\u2013[30]. Most approaches, however, use discrete black-box optimization algorithms [31]\u2013[33]. Since the early work of Karl Sims [34], genetic algorithms (GAs) have been a common choice for the optimization of modular robot morphologies. The work in [35] deploys a GA to co-optimize the morphology and base placement of a modular robot. A lexicographic genetic approach is proposed in [36] to increase the efficiency and interpretability of the evolutionary optimization process. While our work builds upon [36], we extend it to multi-objective problems to explicitly model the tradeoff between performance and robustness. Further, in contrast to previous work, we perform an experimental validation of the optimized designs."}, {"title": "C. Robustness and multi-objective optimization", "content": "It is well-known that a purely simulation-based optimization of real-world systems can lead to suboptimal performance during deployment \u2013 a phenomenon frequently termed the reality gap [37]. This is particularly problematic in unstructured or partially structured environments, like construction sites, where conditions are highly dynamic and unpredictable, and simulation often fails to capture the full complexity of real-world variability. Especially in learning-based approaches, domain randomization has been successfully applied to tackle this issue [38]\u2013[40]. However, past works indicate a tradeoff between the specificity and generality of a solution [41], [42]. In this work, we explicitly model this tradeoff by formulating a multi-objective optimization problem with performance and robustness against positioning errors as competing objectives to find Pareto-optimal solutions. To this end, we incorporate the well-known nondominated sorting-based genetic algorithm (NSGA-II) [43] into the lexicographic optimization procedure previously introduced in [36]."}, {"title": "III. FRAMEWORK", "content": "Our framework is shown in Figure 2. It can be separated into four modules: The user interface and robot synthesis modules are required for mission preparation, whereas mission execution and robot control run during deployment. A user generates and parameterizes a mission through the BIM-based user interface presented in [15]. Based on the user input, the robot synthesis module searches for the optimal configuration of the robot modules in simulation to execute the provided mission and proposes it to the user. Next, the user assembles the modular robot and activates its control setup. Once the robot is ready, the initially configured mission is sent to the robot. Finally, the robot control module adapts an initially planned trajectory based on visual calibration and executes it on the real robot."}, {"title": "A. Robot Synthesis", "content": "Reconfigurable modular robot compositions are simulated and optimized with Timor [44]. We rely on the modular robot modeling language introduced in COBRA [45] and a custom parser module (COBRA BT Parser) to integrate the user interface and the BIM model with Timor. After the optimization algorithm described in Section IV identifies an optimized module composition and a motion trajectory, the worker can proceed with the physical robot assembly. The self-identification of the robot [46] or automatic model generation [44] can be used to obtain a kinematic and dynamic model of the robot once its modules are provided. The motion trajectory is stored and later passed to the robot control module."}, {"title": "B. Robot Control", "content": "The robot control follows a modular setup. While our framework is agnostic to the specific software being used for control, we integrated the following components for deployment:\n\n\u2022 The mobile base navigation, including local and global path planning, localization, and omnidirectional control, is based on the navigation\u00b2 framework [47], [48].\n\n\u2022 The manipulator control, including collision-free trajectory planning and execution, is based on Timor and joint impedance control using the manipulator control library\u00b2.\n\n\u2022 The calibration module based on OpenCV\u00b3 includes a pipeline that detects ArUco landmark poses [49] with a camera to calibrate the robot position with respect to the environment. As the mobile base cannot move with arbitrary precision, even after calibration, the manipulator might not exactly be in the desired position \u2013 in this paper, we refer to this remaining error as the base positioning error."}, {"title": "IV. MODULAR ROBOT COMPOSITION OPTIMIZATION", "content": "The following section introduces our method for optimizing modular robot compositions given a task description and assumptions about the positioning accuracy of the mobile base. Throughout this section, we follow the notation shown in Table II."}, {"title": "A. Preliminaries", "content": "As a running example, consider a ranking of robots {1, 2, 3, 4}, based on how fast they can perform a specific task ($f_{fast}$), how cheap the corresponding hardware is ($f_{cheap}$), and how robust they are to external disturbances ($f_{robust}$). Table I shows the scores $r_i$ of four exemplary robots. The higher the score, the better the robot. There are multiple objectives, so no clear \"best\" robot exists. In the following sections, we will introduce a ranking-based selection method that considers multiple objectives.\n\nPartially Ordered Set. A partially ordered set is a tuple (A, \u2264) of a set A and the order relation <, which is reflexive, antisymmetric, and transitive [50, Def. 1.1].\n\nLexicographic order. Let a, b with len(a) = len(b) = n be two sequences with elements $a_i, b_i \\in (S, \\le)$. We define the lexicographic order of a and b as [51, Def. 1.8]\n\n$a > b \\Leftrightarrow \\exists i \\in [n] : a_i > b_i \\land \\forall j < i : a_j = b_j$,\n$a = b \\forall i \\in [n] : a_i = b_i$ . (1)\n\nIntuitively, this defines a hierarchical order over the elements of every sequence by decreasing importance.\n\nLet ($f_{fast}$, $f_{cheap}$, $f_{robust}$) be the sequence of lexicographic fitness values for the exemplary robots. As the fourth robot is the fastest one and robot three is cheaper than robot two, while they are equally fast, we obtain the lexicographic order $r_4 > r_3 > r_2 > r_1$. However, if we chose our fitness sequence to be ($f_{robust}$, $f_{fast}$, $f_{cheap}$), the order would be $r_1> r_4 > r_3 > r_2$.\n\nPareto optimality. Let f, g with len(f) = len(g) = n be two sequences with $f_i, g_i \\in (F, \\le)$. We say \u201cf dominates g\u201d if it contains a higher value for at least one objective and if all other objectives are at least equal. Formally,\n\n$f > g \\Leftrightarrow \\exists i \\in [n] : f_i > g_i \\land \\forall i \\in [n] : f_i \\geq g_i$ . (2)\n\nAn element f is Pareto-optimal with respect to a set F if it is not dominated by any element in this set [52, eq. 4.59].\n\nLet ($f_{fast}$, $f_{cheap}$, $f_{robust}$) be a multi-objective fitness sequence for the exemplary robots. We can see that $r_3 \\ngeq r_2$ as both robots are equally fast and robust, but robot three is cheaper. However, robots one, three, and four are all Pareto-optimal as none of them is dominated by any other robot."}, {"title": "Genetic algorithm.", "content": "Genetic algorithms change the population of different solution candidates (individuals) to maximize an objective, called the fitness function [53]. Every individual is represented by a genome that encodes its unique attributes. For a fixed number of iterations, a new population is created by selecting a limited number of individuals from the previous population (selection), creating offsprings by combining attributes of existing individuals (crossover), and mutating some of the genomes (mutation). A cycle of selection, crossover, and mutation is called a generation."}, {"title": "NSGA-II.", "content": "We write $ndr(a, A)$ and $cd (a, A)$ whenever we compute the nondomination rank or the crowding distance of an individual a with respect to a population A according to the NSGA-II algorithm as proposed in [43]. A provides an informal introduction to these metrics."}, {"title": "B. Lexicographic nondominant sorting optimization", "content": "We perform a mixed Pareto-lexicographic optimization based on the approach proposed in [36]. This work introduces a genetic algorithm with a selection that is based on a purely lexicographic fitness function. Notably, the approach initially targets a single-objective optimization. The introduction of a lexicographic fitness function is motivated by computational efficiency: By introducing multiple surrogate objectives, the selection process of the genetic optimization can be performed without evaluating the computationally expensive primary objective for a majority of solution candidates.\n\nOur work combines this approach with the NSGA-II algorithm [43] to achieve computationally efficient multi-objective optimization. We compute two sequences $c_i$ and $x_i$ for every individual i in a population. The sequence $c_i$ contains m values that measure compliance with m constraints that can be easily evaluated, such as the sufficient size of a robot or the absence of self-collisions. We define these constraints so that the jth value of $c_i$, $c_{ij}$ is 0, if solution i satisfies constraint j, and negative, otherwise. In addition to previous work, we introduce the sequence\n\n$x_{i} = \\begin{cases} (a_i, b_i, ...) &, \\text{if } c_{i} = 0 \\\\ (- \\infty,- \\infty,...) &, \\text{otherwise,} \\end{cases}$ (3)"}, {"title": "C. Task representation", "content": "We obtain a formalized task representation by parsing the BIM model and user input as described in Sec. III. The representation of goals, obstacles, tolerances, and robots follows the modeling language introduced by the COBRA benchmark [45]. A formal definition for our specific use case is included in B and C."}, {"title": "D. Fitness functions", "content": "For motion planning, we use the toolbox for industrial modular robotics (Timor) [44]. We obtain base movement b(t) and joint angles q (t) over time from a black-box path planner\n\n$\\xi (m, G, C, t) = \\begin{bmatrix} b(t) \\\\ q(t) \\end{bmatrix}$ (5)\n\nThe planner guarantees satisfaction for all constraints C considered in this work, such as collision avoidance. However, inverse kinematics solutions to reach all goals G might not always exist. Further, as we rely on numeric optimization, we might not be able to find them with perfect accuracy. To obtain a scalar expression of the errors e = ($t_e$, $R_e$) (21) given by an imperfect solution, we introduce weighting factors $w_t$, $w_R$ and error measures $d_t : \\mathbb{R}^3 \\rightarrow \\mathbb{R}$ and $d_R: SO(3) \\rightarrow \\mathbb{R}$ and define the distance function\n\n$d(e) = w_td_t(t_e) + w_Rd_R(R_e)$. (6)\n\nWhile the measures can be chosen arbitrarily, we usually use the Euclidean norm for $d_t$ and define $d_R$ as the Euler angle of rotation (22). End effector poses can easily be computed using the forward kinematics FK : $ \\mathbb{R}^3 \\times Q \\rightarrow SE(3)$. This allows us to obtain the minimum pose error for goal $g_i$:\n\n$e(\\xi (t), p_i) = e(p_i, FK(\\xi (t)))$, where\n$\\hat{t} = \\arg \\min_t d(e(p_i, FK(\\xi (t))))$. (7)\n\nFor better readability, we omit the arguments when they are clear from context and write e. If the goal error is within the goal tolerance for every goal in a task, we say that the path $ \\xi (t)$ is feasible.\n\nLet $O_{m,i} (q)$ be the space that is occupied by the ith link of robot m with n joints and joint configuration q. The following constraints for joint limits (8), self-collisions (9), and collisions with the environment (10) all evaluate to true or false:\n\n$C_{lim} \\forall t \\in [T]: q (t) \\in Q$ (8)\n\n$C_{sc} \\forall (i, t) \\in [n] \\times [T], \\forall j < i :$\n$O_{m,i} (q (t)) \\cap O_{m,j} (q (t)) = \\emptyset$ (9)\n\n$C_{col} \\forall (i, t) \\in [n] \\times [T] : O \\cap O_{m,i} (\\xi (t)) = \\emptyset$ . (10)\n\nWe define the fitness functions for constraint satisfaction of robot m as follows.\n\n$c_1 = \\min \\left( \\sum_{i=1}^{n}size(m_i) - \\frac{\\sum_{m_i \\in M} size(m_i)}{\\vert M \\vert}\\right)$ (11)\n\n$c_2 = \\min \\left(0, \\min \\left(count(M,m) - \\frac{\\sum_{m_i \\in M}count(m, m_i) }{\\vert M \\vert} \\right) \\right)$ (12)\n\n$c_3 = - \\sum_{t>T_{cal}} ||b(t) - b(T_{cal}) ||$ (13)\n\n$c_4 = \\begin{cases} 0 &, \\text{if } feasible(\\xi (m, G, \\{C_{lim}\\}, G), t) \\\\ d(e) &, \\text{otherwise.} \\end{cases}$ (14)\n\n$c_5 = \\begin{cases} 0 &, \\text{if } feasible(\\xi (m, G, \\{C_{lim}, C_{sc}\\}, G), t) \\\\ d(e) &, \\text{otherwise.} \\end{cases}$ (15)\n\n$c_6 = \\begin{cases} 0 &, \\text{if } feasible(\\xi (m, G, \\{C_{lim}, C_{sc}, C_{col}\\}, G), t) \\\\ d(e) &, \\text{otherwise.} \\end{cases}$ (16)\n\nThe functions in (11) and (12) can be evaluated without obtaining a kinematic or dynamic model of the robot and indicate whether the individual modules of the robot are large enough to reach all goals and if they are available in situ, respectively. The constraint in (13) forces the base not to move after the visual calibration is performed (t = $T_{cal}$, see also Figure 4). The remaining functions successively evaluate whether the joint path is valid regarding the joint limits (14), self-collisions (15), and collisions with the environment (16). If all constraints are satisfied, we compute the values for our multi-objective fitness criteria. The compactness\n\n$f_c = - \\sum_{i=1}^{n}size(m_i)$ (17)\n\nindicates the negative value of the total size of all modules combined. High compactness usually allows faster transportation and a smaller lever for the forces induced by drilling.\n\nThe robustness fitness function indicates the maximum positioning error our motion planner can account for online. After visual calibration, we obtain a placement error $ \\Delta = (\\Delta x, \\Delta y, \\Delta \\theta)^T$ between the desired and the actual base placement of the robot. The adjustment function $replan(\\xi (t), \\Delta_b)$ indicates whether there is an adjustment $ \\xi $ that, when applied to the joint path $q (t)$, results in the end effector of the robot still following the desired motion. Finally, we define the robustness of a robot m with respect to positioning errors of the mobile base as\n\n$f_r = max\\{\\delta \\in [0, 1] : replan(\\xi (m, G, C, t), \\delta \\Delta_{max})\\}$. (18)\n\nThe maximum displacement $\\Delta_{max}$ can be chosen based on the available hardware and prior experience. We choose [20cm 20cm 15 deg]$^T$ for our experiments. The above definition does not discriminate between robustness against positioning errors in the xy-plane and orientation errors $\\Delta_ \\theta$. If necessary, it can easily be extended to multiple robustness scores, one for every possible error. In practice, we experienced that positioning errors were mainly caused by slipping wheels, rendering an equal consideration of the different error modes plausible.\n\nLastly, the reconfiguration time fitness indicates the time necessary to reconfigure the current module composition m to match a new, desired configuration $m_a$. If the current composition is unknown or non-existent, for example, because the modules are currently disassembled, we set m to the empty tuple, so the reconfiguration fitness measures the initial time for setup. Assume that m and $m_a$ share $n_c$ common modules at the beginning of their kinematic chain. Then, the reconfiguration time fitness is given by\n\n$f_t = -t_m (len(m) + len(m_a) - 2n_c)$ . (19)\n\nHere, we assume that removing or adding a module takes a time of $t_m$, regardless of the module."}, {"title": "V. EXPERIMENTS", "content": "We conducted experiments on a drilling use case in the Fraunhofer Italia ARENA at the NOI Techpark in Bolzano, Italy. The experimental setup is shown in Figure 1. It consists of a movable wall with four blocks (brick, sandstone brick, wood, and insulation material) that is modeled in the used BIM file\u2074."}, {"title": "A. Robot modules", "content": "We use the robot modules introduced in [46] and shown in Figure 1A, together with an RB-VOGUI mobile base\u2075 with a custom cabinet top setup and two lidars (SICK expert S300). In total, we use one mounting base, three elbow- and straight joint modules each, three passive links with a length of 100, 200, and 500 millimeters, respectively, as well as a custom-made end effector, composed of a drill tool (Einhell Herocco 18/20 with custom 3D printed support) and an RGB-D camera (Intel Realsense D435i)."}, {"title": "B. Validation in simulation", "content": "In the simulation setup, we optimized robots to drill two holes of 15cm depth in the sandstone brick. To assess the robustness of a solution against positioning errors of the base, we changed the base position after calibration by a factor of $ \\delta$ 20 cm in both horizontal directions and rotated it by $ \\delta$ 15\u00b0, where $ \\delta \\in [0,1]$ defines the desired level of robustness according to (18). Details about the tolerances used in simulation are listed in C. To analyze the relation between the different objectives, we conducted 100 optimization trials, each starting with a different random initialization. We limited the computational resources per trial to 50 generations each, resulting in 78 minutes on average."}, {"title": "C. Real-world experiments", "content": "Figure 4 shows a simplified version of the behavior tree that consists of one sequence of robot actions used in the experiments. The full tree additionally includes fallback nodes for error handling. Pictures of the drilled holes can be seen in the most-right snapshot in Figure 4 and in Figure 6. A full video of the mission execution is available on the project website modular-construction-robot.cps.cit.tum.de.\n\nBased on prior experience with the mobile base, we chose a minimum robustness score of $ \\delta$ = 0.8. Consecutively, we selected two solutions from our optimization; one with a six-degrees-of-freedom (DoF) robot arm and one with a five-DoF robot arm. For every configuration, we performed three drilling missions on the sandstone brick.\n\nFigure 5 shows the absolute error of the mobile base position relative to the nominal drilling position for each experiment, expressed in terms of $e_x$, $e_y$, and $ \\theta$. Moreover, it indicates the adjustment necessary to correct the initial motion plan according to the positioning error. We compute this score as the maximum change in a single joint angle over all joint configurations in the drilling path $ \\xi (t)$, i.e.,\n\n$\\hat{e} = \\max_{t \\in [T]} (||q(t) - \\hat{q(t)}||_{\\infty})$, (20)\n\nwhere $q$ is the initially planned joint configuration, and $ \\hat{q}$ is the one observed during execution. We chose this metric as it can easily be compared between robots with varying DoF; however, the overall trend shown in Figure 5 persists over different choices of norms.\n\nThe first experiment was conducted with the six-DoF manipulator. Figure 6 shows the sandstone brick after drilling three holes in a horizontal line. The relative vertical precision was within one centimeter.\n\nInitially, the modules were disassembled, as depicted in Figure 1A. Upon receiving the configuration for the robot (a six-DoF setup consisting of the following module sequence: straight, elbow, passive 100mm, straight, elbow, straight, elbow, end effector), the operator assembled the robot in ten minutes. For the second experiment, the robot consisted of the following module sequence: straight, elbow, passive 100mm, straight, elbow, elbow, end effector. The time required to reconfigure the robot and launch the mission was reduced to about five minutes, as the first five modules were shared with the previous configuration."}, {"title": "D. Discussion", "content": "A compactness-robustness tradeoff can clearly be seen in both mean and Pareto-optimal scores. The results shown in Figure 3b indicate a similar tradeoff concerning the reconfiguration time. When starting from an initially assembled robot from a previous task, the first feasible robot for drilling was identified within three minutes. However, if high robustness is essential, a reconfiguration time of over 20 minutes is necessary to assemble the corresponding robot\u2076. Both results underline the benefits of multi-objective optimization: Based on the expected disturbances, the required compactness, and the time at hand, an operator can choose the situationally optimal solution for deployment.\n\nThe robot could adjust for mobile base positioning errors in all real-world experiments. As expected, the adjustment increases with higher positioning errors. Further, as shown in Figure 5, the absolute errors differ between runs, and for five out of six experiments, the necessary adjustment was below 50% of the maximum adjustment. If a more compact (and thereby less robust) robot along the Pareto-optimal designs needs to be chosen, high positioning errors of the base could likely be overcome by reapproaching the wall and repeating the calibration.\n\nThe primary purpose of the conducted experiments was to demonstrate the feasibility of the proposed framework. The gains of the controller were intentionally set to a lower level to prevent excessive force, resulting in reduced precision. This ensures that the robot does not push too far into the wall, even if the vision system fails to accurately detect the marker. Still, as shown in Figure 6, we observed a relative horizontal precision of 1 cm. In future applications, the system could be enhanced with a more accurate vision system to improve its accuracy. Additionally, implementing a force control mechanism would further robustify the system and enable a more precise and adaptive interaction with the environment."}, {"title": "VI. CONCLUSION", "content": "We developed and integrated a holistic framework allowing construction workers to instruct a mobile modular robot arm for building construction. In contrast to existing solutions, the modularity of hardware and software components and multi-objective optimization of robot morphology enables tailoring the proposed approach to specific needs in situ. By integrating BIM information with optimization and control frameworks from the robotics domain, we have created a holistic framework that requires minimal intervention and robotics expertise for deployment. Further, our approach is not limited to geometric data of the used BIM models; future work could incorporate information about material properties to enable automation even for dynamically more challenging tasks, such as impact drilling."}, {"title": "A. NSGA-II metrics", "content": "Nondominated fronts. The Pareto front $F^0 \\subset F$ consists of the Pareto-optimal elements of a set F, i.e., all elements that are not dominated by any other element of F. By removing all Pareto-optimal elements from a set, i.e. performing a reduction, we obtain a reduced set $F^1 = F \\setminus F^0$. All elements on the Pareto-front of $F^1$ have a nondomination rank of one as they are one reduction operation away from being Pareto-optimal with respect to F. This process can be repeated until every element of F is assigned a nondomination rank. The NSGA-II algorithm is based on the concept of nondomination fronts for optimization problems with equally important objectives [43]. In our example, robot two has a nondomination rank of one. All other robots have a nondomination rank of zero, as they are on the Pareto front of the set {$r_1, r_2, r_3, r_4$}.\n\nCrowding distance. Sometimes, many solutions for an optimization problem might be on the same nondomination front. When performing selection within a genetic algorithm, in this scenario, a spread of solutions along the front is often preferred over random sampling. The NSGA-II algorithm introduces the crowding distance to systematically encode this preference. For every individual, it is composed of the distance to the other individuals for every objective function. A formal definition can be found in [43]."}, {"title": "B. Task representation", "content": "The environment is represented as a set of obstacles O. A goal g \u2208 G is a tuple (p,t) that consists of a desired pose p and a tolerance t. The pose defines a desired end-effector position t \u2208 \u211d\u00b3 and orientation R \u2208 SO(3). We introduce the pose error between a desired pose p and an actual end-effector pose PEEF\n\ne(p, PEEF) = (t\u2091, R\u2091), t\u2091 \u2208 \u211d\u00b3, R\u2091 \u2208 SO(3), (21)\n\nwhere t\u2091 and R\u2091 denote the translation and rotation offsets."}, {"title": "C. Tolerances", "content": "A tolerance t : SE(3) \u2192 {true, false} is a function that maps an error term to a binary classification that indicates whether the tolerance is held. We introduce the axis-angle representation of a rotation according to Euler\u2019s theorem on rotations: Any rotation R \u2208 SO(3) can be represented by a unit axis n(R), and a rotation angle\n\n$\\varphi (R) = \\arccos (\\frac{Tr(R)-1}{2})$ (22)\n\nWe introduce a general Euclidean tolerance t\u2090,,,y,z and the general axis tolerance t\u1d64,,v,\u03b5 with tolerance axis u \u2208 {x \u2208 \u211d\u00b3 | \u2211\u1d62x\u1d62 = 1 / x\u1d62 > 0} and \u03b5 \u2208 \u211d\u00b3, ||\u03b5||\u221e < 1 as\n\nt\u2093,y,z(e) = { true, if t\u2091 \u2264 [ x y z ]\u1d40\nfalse, otherwise  (23)\n\nt\u1d64,,v,\u03b5(e) = { true, if \u03c6(R\u2091) \u2264 v\n\u2200n(R\u2091)\u00b7 u \u2264 \u03b5\n\u2200n(R\u2091)\u00b7(-u) \u2264 \u03b5  (24)\nfalse, otherwise\n\nHere, \u2264 and || denote element-wise order and norm. The general Euclidean tolerance constrains the end-effector within a box around the desired pose. The axis tolerance is held for arbitrary rotations around axes \u00b1u or small rotations of at most v about any axis. The parameter \u03b5 accounts for the inaccuracy of numerical computations of the orientation error. For all experiments, we used the Euclidean tolerance t\u2093,y,z with x = y = 0.2 mm and z = 10 mm and the axis tolerance t\u1d64,,v,\u03b5 with u = [0 0 1]\u1d40, v = 2 deg, and \u03b5 = 10\u207b\u00b3 [1 1 1]\u1d40, that allow for arbitrary rotations around and small translations along the drill axis parallel to z but enforce an otherwise precise following of the desired waypoints."}]}