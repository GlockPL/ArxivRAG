{"title": "Complex Event Recognition with Symbolic Register Transducers: Extended Technical Report", "authors": ["Elias Alevizos", "Alexander Artikis", "Georgios Paliouras"], "abstract": "We present a system for Complex Event Recognition (CER) based on automata. While multiple such systems have been described in the literature, they typically suffer from a lack of clear and denotational semantics, a limitation which often leads to confusion with respect to their expressive power. In order to address this issue, our system is based on an automaton model which is a combination of symbolic and register automata. We extend previous work on these types of automata, in order to construct a formalism with clear semantics and a corresponding automaton model whose properties can be formally investigated. We call such automata Symbolic Register Transducers (SRT). The distinctive feature of SRT, compared to previous automaton models used in CER, is that they can encode patterns relating multiple input events from an event stream, without sacrificing rigor and clarity. We study the closure properties of SRT under union, intersection, concatenation, Kleene closure, complement and determinization by extending previous relevant results from the field of languages and automata theory. We show that SRT are closed under various operators, but are not in general closed under complement and they are not determinizable. However, they are closed under these operations when a window operator, quintessential in Complex Event Recognition, is used. We show how SRT can be used in CER in order to detect patterns upon streams of events, using our framework that provides declarative and compositional semantics, and that allows for a systematic treatment of such automata. For SRT to work in pattern detection, we allow them to mark events from the input stream as belonging to a complex event or not, hence the name \"transducers\". We also present an implementation of SRT which can perform CER. We compare our SRT-based CER engine against other state-of-the-art CER systems and show that it is both more expressive and more efficient.", "sections": [{"title": "Introduction", "content": "A Complex Event Recognition (CER) system takes as input a stream of \"simple events\", along with a set of patterns, defining relations among the input events, and detects instances of pattern satisfaction, thus producing an output stream of \"complex events\" [27, 38, 18]. Typically, an event has the structure of a tuple of values which might be numerical or categorical. Time is of critical importance for CER and thus a temporal formalism is used in order to define the patterns to be detected. Such a pattern imposes temporal (and possibly atemporal) constraints on the input events, which, if satisfied, lead to the detection of a complex event. Atemporal constraints may be \"local\", applying only to the last event read from the input stream. For example, in streams from temperature sensors, the constraint that the temperature of the last event is higher than some constant threshold would constitute such a local constraint. More commonly, these constraints involve multiple events of the pattern, e.g., the constraint that the temperature of the last event is higher than that of the previous event. Complex events must often be detected with very low latency, which, in certain cases, may even be in the order of a few milliseconds [38, 25, 32].\nAutomata are of particular interest for the field of CER, because they provide a natural way of handling sequences. As a result, the usual operators of regular expressions, like con-catenation, union and Kleene-star, have often been given an implicit temporal interpretation in CER. For example, the concatenation of two events is said to occur whenever the second event is read by an automaton after the first one, i.e., whenever the timestamp of the second event is greater than the timestamp of the first (assuming the input events are temporally ordered). On the other hand, atemporal constraints are not easy to define using classical automata, since they either work without memory or, even if they do include a memory structure, e.g., as with push-down automata, they can only work with a finite alphabet of input symbols. For this reason, the CER community has proposed several extensions of classical automata. These extended automata have the ability to store input events and later retrieve them in order to evaluate whether a constraint is satisfied [23, 8, 18]. They resemble both register automata [34], through their ability to store events, and symbolic automata [20], through the use of predicates on their transitions. They differ from symbolic automata in that predicates apply to multiple events, retrieved from the memory structure that holds previous events. They differ from register automata in that predicates may be more complex than that of (in)equality.\nOne issue with these CER-specific automata is that their properties have not been systematically investigated, in contrast to models derived directly from the field of languages and automata; see [28] for a discussion about the weaknesses of automaton models in CER. Moreover, they sometimes need to impose restrictions on the use of regular expression operators in a pattern, e.g., nesting of Kleene-star operators is not allowed. A recently proposed formal framework for CER attempts to address these issues [28]. Its advantage is that it provides a logic for CER patterns, with denotational and compositional semantics, but without imposing severe restrictions on the use of operators. An automaton model is also proposed which may be conceived as a variation of symbolic transducers [20]. However, this automaton model can only handle \"local\" constraints, i.e., the formulas on their transitions are unary and thus are applied only to the last event read. A model which combines symbolic and register automata (called symbolic register automata) has recently been proposed in [19]. However, this work focuses on the more theoretical aspects of the proposed automaton model, without investigating how this model may be applied to CER (e.g., by providing a language appropriate for CER or by examining the effects of windows).\nWe propose a system for CER, based on an automaton model that is a combination of symbolic and register automata. It has the ability to store events and its transitions have guards in the form of n-ary conditions. These conditions may be applied both to the last event and to past events that have been stored. Conditions on multiple events are crucial in CER because they allow us to express many patterns of interest, e.g., an increasing trend in the speed of a vehicle. We call such automata Symbolic Register Transducers (SRT). SRT extend the expressive power of symbolic and register automata, by allowing for more complex patterns to be defined and detected on a stream of events. They also extend the power of symbolic register automata, by allowing events in a stream to be marked as belonging to a pattern match or not. This feature is crucial in cases where we need to enumerate all complex events detected at any given timepoint (i.e., exactly report all simple events which compose the complex ones) instead of simply reporting that a complex event has been detected. We also present a language with which we can define patterns for complex events that can then be translated to SRT. We call such patterns Symbolic Regular Expressions with Memory and Output (SREMO), as an extension of the work presented in [36], where Regular Expressions with Memory (REM) are defined and investigated. REM are extensions of classical regular expressions with which some of the terminal symbols of an expression can be stored and later be compared for (in)equality. SREMO allow for more complex conditions to be used, besides those of (in) equality. They additionally allow each terminal sub-expression to mark an element as belonging or not to the string/match that is to be recognized, thus acting as transducers.\nOur contributions may then be summarized as follows:\nWe present a CER system based on a formal framework with denotational and compositional semantics, where patterns may be written as Symbolic Regular Expressions with Memory and Output (SREMO).\nWe show how this framework subsumes, in terms of expressive power, previous similar attempts. It allows for nesting operators and selection strategies. It also allows n-ary expressions to be used as conditions in patterns, thus opening the way for the detection of relational patterns.\nWe extend previous work on automata and present a computational model for patterns written in SREMO, Symbolic Register Transducers (SRT), whose main feature is that it supports relations between multiple events in a pattern. Constraints with multiple events are essential in CER, since they are required in order to capture many patterns of interest, e.g., an increasing or decreasing trend in stock prices. SRT also have the ability to mark exactly those simple events comprising a complex one.\nWe study the closure properties of SRT. By extending previous results from automata theory, we show that, in the general case, SRT are closed under the most common operators (union, intersection, concatenation and Kleene-star), but not under complement and determinization. Failure of closure under complement implies that negation cannot be arbitrarily (i.e., in a compositional manner) used in CER patterns. The negative result about determinization implies that certain techniques (like forecasting) requiring deterministic automata are not applicable.\nWe show that, by using windows, SRT are able to retain their nice closure properties, i.e., they remain closed under complement and determinization. Windows are an indispensable operator in CER because, among others, they limit the search space for pattern matching.\nWe describe the implementation of a CER engine with SRT at its core and present relevant experimental results. Our engine is both more efficient than other engines and supports a language that is more expressive than that of other systems."}, {"title": "Related Work", "content": "Due to their ability to naturally handle sequences of characters, automata have been extensively adopted in CER, where they are adapted in order to handle streams composed of tuples. Typical cases of CER systems that employ automata are the Chronicle Recognition System [26, 24], Cayuga [22, 23], TESLA [17], SASE [8, 49], CORE [28, 15] and Wayeb [12, 9]. There also exist systems that do not employ automata as their computational model, e.g., there are logic-based systems [44, 39] or systems that use trees [40], but the standard operators of concatenation, union and Kleene-star are quite common and they may be considered as a reasonable set of core operators for CER. The abundance of different CER systems, employing various computational models and using various formalisms has recently led to some attempts to provide a unifying framework [28, 30]. Specifically, in [28], a set of core CER operators is identified, a formal framework is proposed that provides denotational semantics for CER patterns, and a computational model is described for capturing such patterns. For an overview of CER languages, see [27], and for a general review of CER systems, see [18]. In this Section, we present previous related work along three axes. First, we discuss previous theoretical work on automata that is related to CER. We subsequently present previous automata-based CER systems. Finally, we briefly discuss some solutions which are beyond the scope of CER in the strict sense of the term, but have characteristics that are of interest to CER."}, {"title": "Extended automaton models: theory", "content": "Outside the field of CER, research on automata has evolved towards various directions. Besides the well-known push-down automata that can store elements from a finite set to a stack, there have appeared other automaton models with memory, such as register automata, pebble automata and data automata [34, 41, 13]. For a review, see [43]. Such models are especially useful when the input alphabet cannot be assumed to be finite, as is often the case with CER. Register automata (initially called finite-memory automata) constitute one of the earliest such proposals [34]. At each transition, a register automaton may choose to store its current input (more precisely, the current input's data payload) to one of a finite set of registers. A transition is followed if the current input is equal to the contents of some register. With register automata, it is possible to recognize strings constructed from an infinite alphabet, through the use of (in)equality comparisons among the data carried by the current input and the data stored in the registers. However, register automata do not always have nice closure properties, e.g., they are not closed under determinization. For an extensive study of register automata, see [36, 37]. We build on the framework presented in [36, 37] in order to construct register automata with the ability to handle \"arbitrary\" structures, besides those containing only (in)equality relations.\nAnother model that is of interest for CER is the symbolic automaton, which allows CER patterns to apply constraints on the attributes of events. Automata that have predicates on their transitions were already proposed in [45]. This initial idea has recently been expanded and more fully investigated in symbolic automata [47, 46, 20]. In symbolic automata, transitions are equipped with formulas constructed from a Boolean algebra. A transition is followed if its formula, applied to the current input, evaluates to TRUE. Contrary to register automata, symbolic automata have nice closure properties, but their formulas are unary and thus can only be applied to a single element from the input string.\nThis is one limitation that we address here. We use Symbolic Regular Expressions with Memory and Output (SREMO) and Symbolic Register Transducers (SRT), a language and an automaton model respectively, that can handle n-ary formulas and be applied for the purposes of CER. With SREMO we can designate which elements of a pattern need to be stored for later evaluation and which must be marked as being part of a match. SREMO can be compiled into SRT whose transitions can apply n-ary formulas/conditions (with n>1) on multiple elements. As a result, SRT are more expressive than symbolic and register automata, thus being suitable for practical CER applications, while, at the same time, their properties can be systematically investigated, as in standard automata theory. In fact, our model subsumes these two automaton models as special cases. It is also an extension of Symbolic Register Automata [19], which do not have any output on their transitions and cannot thus enumerate the detected complex events, since they do not have the ability to mark input events as being part of match. Moreover, the applicability of SRT for CER is studied here for the first time. We show precisely how SRT can be used for CER and how the use of SRT provides expressive power without sacrificing clarity and rigor.\nWe initially presented the results regarding SRT in [10] (we called them Register Match Automata in that report). The difference between that report and the present paper is that now we use a different formalism for expressing patterns at the language level. However, the automaton model remains essentially the same. Automaton models similar to SRT have been independently presented in [19] and [11]. In both cases, the focus was on Symbolic Register Automata, i.e., on automata without any output on their transitions. The former work focused on an extensive theoretical analysis, while the latter on the theoretical applicability of this type of automata for CER, without presenting an implementation."}, {"title": "Extended automaton models as applied in CER", "content": "Automata with registers have been proposed in the past for CER, e.g., in SASE and Cayuga. However, previous systems typically provide operational semantics and it is not always clear a) what operators are allowed, b) at which combinations c) what the properties of their automaton models are. For example, SASE's language seems to support nested Kleene operators. However, this is not the case. SASE constructs automata whose states are linearly ordered. Therefore, Kleene operators can only be applied to single states. They cannot be nested and they cannot contain other expressions, except for single events. As a result, disjunction is also not allowed. Cayuga attempts to address these issues of constraints on its expressive power through the method of resubscription, i.e., expressions which cannot be captured by a single automaton are compiled into multiple automata [21]. Each sub-automaton can then subscribe to the output of other automata, thus creating a hierarchy of automata. Although this is an interesting solution, the resulting semantics remains ambiguous, since the correctness and limits of this approach have not been thoroughly investigated. Our system does not suffer from these limitations. Its novelty is that it provides formal, compositional semantics which allows us to address all of the above issues. We show that negation is the only problematic operator. The other operators may be arbitrarily combined in a completely compositional manner and each pattern can be compiled into a single automaton, something which has not been previously achieved. CORE [28, 29] and Wayeb [12, 9] constitute two more recent automata-based CER systems. CORE automata may be categorized under the class of \"unary\" symbolic automata (or transducers, to be more precise), i.e., they do not support patterns relating multiple events. The same is true for Wayeb, which also employs \"unary\" symbolic automata."}, {"title": "Extended automaton models beyond CER", "content": "An adaptation of finite automata in the context of Data Stream Management Systems (which have strong similarities to CER systems) has also been proposed in [16]. These automata are called augmented finite automata (AFA) and are enriched with registers, in order to capture trends. With respect to compositionality, AFA are similar to SRT: Like SRT, Augmented Finite Automata (AFA) [16] support arbitrary edges and are compositional. On the other hand, AFA have different limitations. Each AFA has a single register (one per active state), whereas there is no such restriction for SRT. AFA are thus less expressive than SRT. Additionally, AFA are not transducers and cannot enumerate the input events of a complex event. They can report event lifetimes, i.e., the duration of a complex event. SRT can also report individual input events. The input events can be reconstructed in a port-processing step, if needed, from the lifetime, but this seems to hold only for contiguous patterns. It is unclear whether this is feasible for non-contiguous patterns. Finally, the properties of AFA have not been theoretically studied, for example with respect to determinization and negation. AFA can handle certain instances of negation, but there are strong reasons to suspect that they are not in general closed under complement, as is the case of register automata. In summary, SRT are more expressive than AFA.\nAnother way to implement CER patterns, in relational databases, is through SQL's MATCH_RECOGNIZE, a proposed clause that can perform pattern recognition on rows [6, 42]. MATCH_RECOGNIZE is very expressive and can in principle capture almost any pattern expressed in a CER language. However, it is uncertain whether it would work in a streaming setting as efficiently as CER systems. Recent work has proposed implementations of MATCH_RECOGNIZE that are more efficient than the one already available in Flink [50, 35]. The proposed optimizations rely on the use of prefiltering and clever indices so that the automaton responsible for pattern recognition is fed only with a small subset of the initial rows. They target the scenario of historical analysis and their extension to a streaming setting is not considered. It still remains an open issue whether and to what extent the proposed optimizations would work for patterns processing events in real time."}, {"title": "Symbolic Regular Expressions with Memory and Output", "content": "The field of CER has been growing strong for the past 20 years. It is thus no surprise that there is no lack of languages, formalisms and systems from which one may choose according to their needs. As a result, there is considerable variability concerning the most relevant and useful operators of CER patterns, their semantics and the corresponding computational models to be used for the actual detecting of complex events. On the one hand, this variability may be viewed as a sign of vigor for the field. On the other hand, the fact that operators and their semantics are sometimes defined informally makes it hard to compare different systems in terms of their expressive capabilities. It also makes it hard to study a single system in itself in a more systematic manner, other than actually running it and observing its behavior.\nAs an attempt to mitigate these problems, we present and describe a framework for CER which has formal, denotational semantics. We first present a language for CER and discuss its semantics. The main feature of this language is that it allows for most of the common CER operators (such as selection, sequence, disjunction and iteration), without imposing restrictions on how they may be used and nested. Our proposed language can also accommodate n-ary conditions, i.e., we can impose constraints on the patterns which relate multiple events of a stream, e.g., that the number of cells in a simulated tumor at the current timepoint is higher than their number at the previous timepoint. We also discuss the semantics of patterns written in our proposed language and show that these are well-defined. As a result, in order to know whether a given stream contains any complex events corresponding to a given pattern, we do not need to resort to a procedural computational model. The semantics of the language may be studied independently of the chosen computational model. Not only is this feature critical in itself, allowing for a systematic understanding of the use of operators, but it could also be of importance for optimization, which often relies on pattern re-writing, assuming that we can know when two patterns are equivalent without actually having to run their computational models. Previous work on CER has produced systems which are highly expressive (e.g., FlinkCEP [4]), but lack a proper, formal description. Some more recent work ([15]) has attempted to construct a system which is both formal and efficient. However, it does not support n-ary expressions, allowing (non-temporal) constraints which are applied only to the last event read from a stream.\nBefore presenting SRT, we first present a high-level formalism for defining CER patterns. We extend the work presented in [36], where the notion of regular expressions with memory (REM) was introduced. These regular expressions can store some terminal symbols in order to compare them later against a new input element for (in) equality. One important limitation of REM with respect to CER is that they can handle only (in)equality relations. In this section, we extend REM so as to endow them with the capacity to use relations from \"arbitrary\" structures. We call these extended REM Symbolic Regular Expressions with Memory and Output (SREMO).\nFirst, in Section 3.1 we repeat some basic definitions from logic theory. We also describe how we can adapt them and simplify them to suit our needs. Next, in Section 3.2 we precisely define the notion of conditions. In SREMO, conditions will act in a manner equivalent to that of terminal symbols in classical regular expressions. The difference is of course that conditions are essentially logic formulas that can reference both the current element read from a string/stream and possibly some past elements. In Section 3.3 we present the syntax for SREMO and in Section 3.4 the definition of their semantics."}, {"title": "Formulas and models", "content": "In this section, we follow the notation and notions presented in [31]. The first notion that we need is that of a V-structure. A V-structure essentially describes a domain along with the operations that can be performed on the elements of this domain and their interpretation.\n\u25ba Definition 2 (V-structure [31]). A vocabulary V is a set of function, relation and constant symbols. A V-structure is an underlying set U, called a universe, and an interpretation of V. An interpretation assigns an element of U to each constant in V, a function from $U^n$ to U to each n-ary function in V and a subset of $U^n$ to each n-ary relation in V.\n\u25ba Example 3. Using Example 1, we can define the following vocabulary\n$V = \\{R, c_1, c_2, c_3, c_4, c_5, c_6\\}$\nand the universe\n$U = \\{(B, 1, 22, 300), (B, 1, 24, 225), (B, 2, 32, 1210), (S, 1, 70, 760), (S, 1, 68, 2000), (B, 2, 33, 95)\\}$\nWe can also define an interpretation of V by assigning each $c_i$ to an element of U, e.g., $c_1$ to (B, 1, 22, 300), $c_2$ to (B, 1, 24, 225), etc. R may also be interpreted as R(x,y) := x.id = y.id, i.e., this binary relation contains all pairs of U which have the same id. For example, ((B, 1, 22, 300), (S, 1, 70, 760)) \u2208 R and ((B, 1, 22, 300), (B, 2,33,95)) \u2209 R. If there are more (even infinite) tuples in a stream/string, then we would also need more constants (even infinite).\nWe extend the terminology of classical regular expressions to define characters, strings and languages. Elements of U are called characters and finite sequences of characters are called strings. A set of strings L constructed from elements of U, i.e., L \u2286 U*, where * denotes Kleene-star, is called a language over U. Then, a stream S is an infinite sequence S = t1, t2,\u2026, where each $t_i \u2208 U$ is a character. By $S_{1..k}$ we denote the sub-string of S composed of the first k elements of S. $S_{m..k}$ denotes the slice of S starting from the mth and ending at the kth element.\nWe now define the syntax and semantics of formulas that can be constructed from the constants, relations and functions of a V-structure. We begin with the definition of terms.\n\u25ba Definition 4 (Term [31]). A term is defined inductively as follows:\nEvery constant is a term.\nIf f is an m-ary function and $t_1,\u2026\u2026,t_m$ are terms, then $f(t_1,\u2026\u2026,t_m)$ is also a term.\nUsing terms, relations and the usual Boolean constructs of conjunction, disjunction and negation, we can define formulas.\n\u25ba Definition 5 (Formula [31]). Let $t_i$ be terms. A formula is defined as follows:\nIf P is an n-ary relation, then $P(t_1,\u2026\u2026,t_n)$ is a formula (an atomic formula).\nIf \u03c6 is a formula, \u00ac\u03c6 is also a formula.\nIf \u03c61 and \u03c62 are formulas, $\u03c6_1 \u2227 \u03c6_2$ is also a formula.\nIf \u03c61 and \u03c62 are formulas, $\u03c6_1 \u2228 \u03c6_2$ is also a formula.\n\u25ba Definition 6 (V-formula [31]). If V is a vocabulary, then a formula in which every function, relation and constant is in V is called a V-formula.\n\u25ba Example 7. Continuing with our example, R($c_1, c_4$) is an atomic V-formula. R($c_1, c_4$) \u2227 R($c_1, c_3$) is also a (complex) V-formula, where $V = \\{R, c_1, c_2, c_3, c_4, c_5, c_6\\}$.\nNotice that in typical definitions of terms and formulas (as found in [31]) variables are also present. A variable is also a term. Variables are also used in existential and universal quantifiers to construct formulas. In our case, we will not be using variables in the above sense (instead, as explained below, we will use variables to refer to registers). Thus, existential and universal formulas will not be used. In principle, they could be used, but their use would be counter-intuitive. At every new event, we need to check whether this event satisfies some properties, possibly in relation to previous events. A universal or existential formula would need to check every event (variables would refer to events), both past and future, to see if all of them or at least one of them (from the universe U) satisfy a given property. Since we will not be using variables, there is also no notion of free variables in formulas (variables occurring in formulas that are not quantified). Thus, every formula is also a sentence, since sentences are formulas without free variables. In what follows, we will thus not differentiate between formulas and sentences.\nWe can now define the semantics of a formula with respect to a V-structure.\n\u25ba Definition 8 (Model of V-formulas [31]). Let M be a V-structure and \u03c6 a V-formula. We define M (M models \u03c6) as follows:"}, {"title": "Conditions", "content": "Based on the above definitions, we will now define conditions over registers. Conditions are the basic building blocks of SREMO. In the simplest case, they are applied to single events and act as filters. In the general case, we need them to be applied to multiple events, some of which may be stored to registers. Conditions will essentially be the n-ary guards on the transitions of SRT.\n\u25ba Definition 10 (Condition). Let M be a V-structure always equipped with the unary relation T for which it holds that $u \u2208 T, \u2200u \u2208 U$, i.e., this relation holds for all elements of the universe U. Let $R = \\{r_1,\u2026\u2026,r_k\\}$ be variables denoting the registers and ~ a special variable denoting an automaton's head which reads new elements. The \u201ccontents\" of the head always correspond to the most recent element. We call R register variables. A condition is essentially a V-formula, as defined above (Definition 5), where, instead of terms, we use register variables. A condition is then defined by the following grammar:\n\u03c4 is a condition.\nP($r_1,\u2026\u2026,r_n$), where $r_i \u2208 R \\cup \\{\\sim\\}$ and P an n-ary relation, is a condition.\n\u00ac\u03c6 is a condition, if \u03c6 is a condition.\n$\u03c6_1 \u2227 \u03c6_2$ is a condition if \u03c61 and \u03c62 are conditions.\n$\u03c6_1 \u2228 \u03c6_2$ is a condition if \u03c61 and \u03c62 are conditions.\n\u25ba Example 11. As an example, consider the simple case where we want to detect stock ticks of type BUY (B), followed by a tick of type SELL (S) for the same company. We would thus need a simple condition on the first tick, denoted as TypeIsB(~), where TypeIsB(x):=x.type=B. TypeIsB(~) has a single argument, the automaton head. We also need another condition for the SELL tick and the company comparison, denoted as TypeIsS(~) \u2227 EqualId(~,r1). We assume that TypeIsS(x) := x.type = S and EqualId(x,y) := x.id = y.id. Note that, beyond the head variable, EqualId also has a register variable as an input argument. We will show later how registers are written.\nSince terms now refer to registers, we need a way to access the contents of these registers. We will assume that each register has the capacity to store exactly one element from U. The notion of valuations provides us with a way to access the contents of registers.\n\u25ba Definition 12 (Valuation). Let $R = \\{r_1,\u2026,r_k\\}$ be a set of register variables. A valuation on R is a partial function $v : R \u2192 U$, i.e., some registers may be \u201cempty\u201d. The set of all valuations on R is denoted by F($r_1,\u2026\u2026,r_k$). Register update happens with v[$r_i \u2190 u$],"}, {"title": "Conditions", "content": "denoting the valuation where we replace the content of $r_i$ with a new element u, producing a new valuation v':\n$v'(r_j) = v[r_i \\leftarrow u] = \\begin{cases}u \\\\ v(r_j)\\end{cases} \\begin{array}{ll}if r_j = r_i \\\\ otherwise\\end{array}$\nSimilarly, v[W \u2190 u], where W \u2208 R, denotes the valuation obtained by replacing the contents of all registers in W with u. We say that a valuation v is compatible with a condition \u03c6 if, for every register variable $r_i$ that appears in \u03c6, v($r_i$) is defined, i.e., $r_i$ is not empty. We will also use the notation v($r_i$) = \u2021 to denote the fact that register $r_i$ is empty, i.e., we extend the range of v to $U \u222a \\{\\ddagger\\}$. We also extend the domain of v to $R\u222a \\{\\sim\\}$. By v(~) we will denote the \u201ccontents\" of the automaton's head, i.e., the last element read from the string.\nA valuation v is essentially a function with which we can retrieve the contents of any register. We can now define the semantics of conditions, similarly to the way we defined models of V-formulas in Definition 8. The difference is that the arguments to relations are no longer elements assigned to terms but elements stored in registers, as retrieved by a given valuation.\n\u25ba Definition 13 (Semantics of conditions). Let M be a V-structure, $u \u2208 U$ an element of the universe of M and $v \u2208 F(r_1,\u2026\u2026,r_k)$ a valuation. We say that a condition \u03c6 is satisfied by (u,v), denoted by (u, v) |= \u03c6, iff one of the following holds:\n\u03c6 := T, i.e., (u, v) |= T for every element and valuation.\n\u03c6 := P($x_1,\u00b7\u00b7\u00b7,x_n$), $x_i \u2208 R\u222a\\{\\sim\\}$, v($x_i$) is defined for all $x_i$ and $u \u2208 P(v(x_1),\u00b7\u00b7\u00b7, v(x_n))$.\n\u03c6 := \u00ac\u03c8 and (u, v) !|= \u03c8.\n\u03c6 := $\u03c6_1 \u2227 \u03c6_2$, (u, v) |= $\u03c6_1$ and (u, v) |= $\u03c6_2$.\n\u03c6 := $\u03c6_1 \u2228 \u03c6_2$, (u, v) |= $\u03c6_1$ or (u, v) |= $\u03c6_2$.\n\u25ba Example 14. Returning to our example, we can check whether the condition \u03c61:=TypeIsB(~) is satisfied by the first element of Table 1, (B, 1, 22, 300). We assume that we start with a valuation v where all registers are empty. Indeed ((B, 1, 22, 300), v)=1, since v(~) is defined and (B, 1,22,300)\u2208 TypeIsB(v(~)). Note that v(~) is always defined because the automaton head always points to an element. The only exception is when we are at the very beginning of a string, without having read any elements."}, {"title": "SREMO syntax", "content": "We are now in a position to define Symbolic Regular Expressions with Memory and Output SREMO. We achieve this by combining conditions via the standard regular operators. Conditions act as terminal expressions, i.e., the base case upon which we construct more complex expressions. Each condition may be accompanied by a register variable, indicating that an event satisfying the condition must be written to that register. It may also be accompanied by an output, either , indicating that the event must be marked as being part of the complex event, or , indicating that the event is irrelevant and should be excluded from any detected complex events.\n\u25ba Definition 15 (Symbolic regular expression with memory and output (SREMO)). A symbolic regular expression with memory and output over a V-structure M and a set of register variables $R = \\{r_1,\u2026\u2026,r_k\\}$ is inductively defined as follows:\n1. e and \u00d8 are SREMO.\n2. If \u03c6 is a condition (as in Definition 10) and $o \u2208 \\{\\bullet, \\circ\\}$ an output, then \u03c6\u2191 o is a SREMO."}, {"title": "SREMO semantics", "content": "In order to define the semantics of SREMO, we need to define how the contents of the registers may change. We thus need to first define how a SREMO, starting from a given valuation v and reading a given string S, reaches another valuation v'. Our final aim is to detect matches of a SREMO e in a string $S=t_1,\u2026, t_n$. A match M={$i_1, ..., i_k$} of e on S is a totally ordered set of natural numbers, referring to indices in the string S, i.e., $i_1 \u2265 1$ and $i_k \u2264 n$. If M={$i_1,..., i_k$} is a match of e on S, then the set of elements referenced by M, S[M"}]}