{"title": "Complex Event Recognition with Symbolic Register Transducers: Extended Technical Report", "authors": ["Elias Alevizos", "Alexander Artikis", "Georgios Paliouras"], "abstract": "We present a system for Complex Event Recognition (CER) based on automata. While multiple such systems have been described in the literature, they typically suffer from a lack of clear and denotational semantics, a limitation which often leads to confusion with respect to their expressive power. In order to address this issue, our system is based on an automaton model which is a combination of symbolic and register automata. We extend previous work on these types of automata, in order to construct a formalism with clear semantics and a corresponding automaton model whose properties can be formally investigated. We call such automata Symbolic Register Transducers (SRT). The distinctive feature of SRT, compared to previous automaton models used in CER, is that they can encode patterns relating multiple input events from an event stream, without sacrificing rigor and clarity. We study the closure properties of SRT under union, intersection, concatenation, Kleene closure, complement and determinization by extending previous relevant results from the field of languages and automata theory. We show that SRT are closed under various operators, but are not in general closed under complement and they are not determinizable. However, they are closed under these operations when a window operator, quintessential in Complex Event Recognition, is used. We show how SRT can be used in CER in order to detect patterns upon streams of events, using our framework that provides declarative and compositional semantics, and that allows for a systematic treatment of such automata. For SRT to work in pattern detection, we allow them to mark events from the input stream as belonging to a complex event or not, hence the name \"transducers\". We also present an implementation of SRT which can perform CER. We compare our SRT-based CER engine against other state-of-the-art CER systems and show that it is both more expressive and more efficient.", "sections": [{"title": "Introduction", "content": "A Complex Event Recognition (CER) system takes as input a stream of \"simple events\", along with a set of patterns, defining relations among the input events, and detects instances of pattern satisfaction, thus producing an output stream of \"complex events\" [27, 38, 18]. Typically, an event has the structure of a tuple of values which might be numerical or categorical. Time is of critical importance for CER and thus a temporal formalism is used in order to define the patterns to be detected. Such a pattern imposes temporal (and possibly atemporal) constraints on the input events, which, if satisfied, lead to the detection of a complex event. Atemporal constraints may be \"local\", applying only to the last event read from the input stream. For example, in streams from temperature sensors, the constraint that the temperature of the last event is higher than some constant threshold would constitute such a local constraint. More commonly, these constraints involve multiple events of the pattern, e.g., the constraint that the temperature of the last event is higher than that of the previous event. Complex events must often be detected with very low latency, which, in certain cases, may even be in the order of a few milliseconds [38, 25, 32].\nAutomata are of particular interest for the field of CER, because they provide a natural way of handling sequences. As a result, the usual operators of regular expressions, like con-catenation, union and Kleene-star, have often been given an implicit temporal interpretation in CER. For example, the concatenation of two events is said to occur whenever the second event is read by an automaton after the first one, i.e., whenever the timestamp of the second event is greater than the timestamp of the first (assuming the input events are temporally ordered). On the other hand, atemporal constraints are not easy to define using classical automata, since they either work without memory or, even if they do include a memory structure, e.g., as with push-down automata, they can only work with a finite alphabet of input symbols. For this reason, the CER community has proposed several extensions of classical automata. These extended automata have the ability to store input events and later retrieve them in order to evaluate whether a constraint is satisfied [23, 8, 18]. They resemble both register automata [34], through their ability to store events, and symbolic automata [20], through the use of predicates on their transitions. They differ from symbolic automata in that predicates apply to multiple events, retrieved from the memory structure that holds previous events. They differ from register automata in that predicates may be more complex than that of (in)equality.\nOne issue with these CER-specific automata is that their properties have not been systematically investigated, in contrast to models derived directly from the field of languages and automata; see [28] for a discussion about the weaknesses of automaton models in CER. Moreover, they sometimes need to impose restrictions on the use of regular expression operators in a pattern, e.g., nesting of Kleene-star operators is not allowed. A recently proposed formal framework for CER attempts to address these issues [28]. Its advantage is that it provides a logic for CER patterns, with denotational and compositional semantics, but without imposing severe restrictions on the use of operators. An automaton model is also proposed which may be conceived as a variation of symbolic transducers [20]. However, this automaton model can only handle \"local\" constraints, i.e., the formulas on their transitions are unary and thus are applied only to the last event read. A model which combines symbolic and register automata (called symbolic register automata) has recently been proposed in [19]. However, this work focuses on the more theoretical aspects of the proposed automaton model, without investigating how this model may be applied to CER (e.g., by providing a language appropriate for CER or by examining the effects of windows).\nWe propose a system for CER, based on an automaton model that is a combination of symbolic and register automata. It has the ability to store events and its transitions have guards in the form of n-ary conditions. These conditions may be applied both to the last event and to past events that have been stored. Conditions on multiple events are crucial in CER because they allow us to express many patterns of interest, e.g., an increasing trend in the speed of a vehicle. We call such automata Symbolic Register Transducers (SRT). SRT extend the expressive power of symbolic and register automata, by allowing for more complex patterns to be defined and detected on a stream of events. They also extend the power of symbolic register automata, by allowing events in a stream to be marked as belonging to a pattern match or not. This feature is crucial in cases where we need to enumerate all complex events detected at any given timepoint (i.e., exactly report all simple events which compose the complex ones) instead of simply reporting that a complex event has been detected. We also present a language with which we can define patterns for complex events that can then be translated to SRT. We call such patterns Symbolic Regular Expressions with Memory and Output (SREMO), as an extension of the work presented in [36], where Regular Expressions with Memory (REM) are defined and investigated. REM are extensions of classical regular expressions with which some of the terminal symbols of an expression can be stored and later be compared for (in)equality. SREMO allow for more complex conditions to be used, besides those of (in) equality. They additionally allow each terminal sub-expression to mark an element as belonging or not to the string/match that is to be recognized, thus acting as transducers.\nOur contributions may then be summarized as follows:\n We present a CER system based on a formal framework with denotational and composi-tional semantics, where patterns may be written as Symbolic Regular Expressions with Memory and Output (SREMO).\n We show how this framework subsumes, in terms of expressive power, previous similar attempts. It allows for nesting operators and selection strategies. It also allows n-ary expressions to be used as conditions in patterns, thus opening the way for the detection of relational patterns.\n We extend previous work on automata and present a computational model for patterns written in SREMO, Symbolic Register Transducers (SRT), whose main feature is that it supports relations between multiple events in a pattern. Constraints with multiple events are essential in CER, since they are required in order to capture many patterns of interest, e.g., an increasing or decreasing trend in stock prices. SRT also have the ability to mark exactly those simple events comprising a complex one.\n We study the closure properties of SRT. By extending previous results from automata theory, we show that, in the general case, SRT are closed under the most common operators (union, intersection, concatenation and Kleene-star), but not under complement and determinization. Failure of closure under complement implies that negation cannot be arbitrarily (i.e., in a compositional manner) used in CER patterns. The negative result about determinization implies that certain techniques (like forecasting) requiring deterministic automata are not applicable.\n We show that, by using windows, SRT are able to retain their nice closure properties, i.e., they remain closed under complement and determinization. Windows are an indispensable operator in CER because, among others, they limit the search space for pattern matching.\n We describe the implementation of a CER engine with SRT at its core and present relevant experimental results. Our engine is both more efficient than other engines and supports a language that is more expressive than that of other systems."}, {"title": "Related Work", "content": "Due to their ability to naturally handle sequences of characters, automata have been extensively adopted in CER, where they are adapted in order to handle streams composed of tuples. Typical cases of CER systems that employ automata are the Chronicle Recognition System [26, 24], Cayuga [22, 23], TESLA [17], SASE [8, 49], CORE [28, 15] and Wayeb [12, 9]. There also exist systems that do not employ automata as their computational model, e.g., there are logic-based systems [44, 39] or systems that use trees [40], but the standard operators of concatenation, union and Kleene-star are quite common and they may be considered as a reasonable set of core operators for CER. The abundance of different CER systems, employing various computational models and using various formalisms has recently led to some attempts to provide a unifying framework [28, 30]. Specifically, in [28], a set of core CER operators is identified, a formal framework is proposed that provides denotational semantics for CER patterns, and a computational model is described for capturing such patterns. For an overview of CER languages, see [27], and for a general review of CER systems, see [18]. In this Section, we present previous related work along three axes. First, we discuss previous theoretical work on automata that is related to CER. We subsequently present previous automata-based CER systems. Finally, we briefly discuss some solutions which are beyond the scope of CER in the strict sense of the term, but have characteristics that are of interest to CER."}, {"title": "Extended automaton models: theory", "content": "Outside the field of CER, research on automata has evolved towards various directions. Besides the well-known push-down automata that can store elements from a finite set to a stack, there have appeared other automaton models with memory, such as register automata, pebble automata and data automata [34, 41, 13]. For a review, see [43]. Such models are especially useful when the input alphabet cannot be assumed to be finite, as is often the case with CER. Register automata (initially called finite-memory automata) constitute one of the earliest such proposals [34]. At each transition, a register automaton may choose to store its current input (more precisely, the current input's data payload) to one of a finite set of registers. A transition is followed if the current input is equal to the contents of some register. With register automata, it is possible to recognize strings constructed from an infinite alphabet, through the use of (in) equality comparisons among the data carried by the current input and the data stored in the registers. However, register automata do not always have nice closure properties, e.g., they are not closed under determinization. For an extensive study of register automata, see [36, 37]. We build on the framework presented in [36, 37] in order to construct register automata with the ability to handle \"arbitrary\" structures, besides those containing only (in) equality relations.\nAnother model that is of interest for CER is the symbolic automaton, which allows CER patterns to apply constraints on the attributes of events. Automata that have predicates on"}, {"title": "Extended automaton models as applied in CER", "content": "Automata with registers have been proposed in the past for CER, e.g., in SASE and Cayuga. However, previous systems typically provide operational semantics and it is not always clear a) what operators are allowed, b) at which combinations c) what the properties of their automaton models are. For example, SASE's language seems to support nested Kleene operators. However, this is not the case. SASE constructs automata whose states are linearly ordered. Therefore, Kleene operators can only be applied to single states. They cannot be nested and they cannot contain other expressions, except for single events. As a result, disjunction is also not allowed. Cayuga attempts to address these issues of constraints on its expressive power through the method of resubscription, i.e., expressions which cannot be captured by a single automaton are compiled into multiple automata [21]. Each sub-automaton can then subscribe to the output of other automata, thus creating a hierarchy of automata. Although this is an interesting solution, the resulting semantics remains ambiguous, since the correctness and limits of this approach have not been thoroughly investigated. Our system does not suffer from these limitations. Its novelty is that it provides formal, compositional semantics which allows us to address all of the above issues. We show that negation is the only problematic operator. The other operators may be arbitrarily combined in a completely compositional manner and each pattern can be compiled into a"}, {"title": "Extended automaton models beyond CER", "content": "An adaptation of finite automata in the context of Data Stream Management Systems (which have strong similarities to CER systems) has also been proposed in [16]. These automata are called augmented finite automata (AFA) and are enriched with registers, in order to capture trends. With respect to compositionality, AFA are similar to SRT: Like SRT, Augmented Finite Automata (AFA) [16] support arbitrary edges and are compositional. On the other hand, AFA have different limitations. Each AFA has a single register (one per active state), whereas there is no such restriction for SRT. AFA are thus less expressive than SRT. Additionally, AFA are not transducers and cannot enumerate the input events of a complex event. They can report event lifetimes, i.e., the duration of a complex event. SRT can also report individual input events. The input events can be reconstructed in a port-processing step, if needed, from the lifetime, but this seems to hold only for contiguous patterns. It is unclear whether this is feasible for non-contiguous patterns. Finally, the properties of AFA have not been theoretically studied, for example with respect to determinization and negation. AFA can handle certain instances of negation, but there are strong reasons to suspect that they are not in general closed under complement, as is the case of register automata. In summary, SRT are more expressive than AFA.\nAnother way to implement CER patterns, in relational databases, is through SQL's MATCH_RECOGNIZE, a proposed clause that can perform pattern recognition on rows [6, 42]. MATCH_RECOGNIZE is very expressive and can in principle capture almost any pattern expressed in a CER language. However, it is uncertain whether it would work in a streaming setting as efficiently as CER systems. Recent work has proposed implementations of MATCH_RECOGNIZE that are more efficient than the one already available in Flink [50, 35]. The proposed optimizations rely on the use of prefiltering and clever indices so that the automaton responsible for pattern recognition is fed only with a small subset of the initial rows. They target the scenario of historical analysis and their extension to a streaming setting is not considered. It still remains an open issue whether and to what extent the proposed optimizations would work for patterns processing events in real time."}, {"title": "Symbolic Regular Expressions with Memory and Output", "content": "The field of CER has been growing strong for the past 20 years. It is thus no surprise that there is no lack of languages, formalisms and systems from which one may choose according to their needs. As a result, there is considerable variability concerning the most relevant and useful operators of CER patterns, their semantics and the corresponding computational models to be used for the actual detecting of complex events. On the one hand, this variability may be viewed as a sign of vigor for the field. On the other hand, the fact that operators and their semantics are sometimes defined informally makes it hard to compare different systems in terms of their expressive capabilities. It also makes it hard to study a single system in itself in a more systematic manner, other than actually running it and observing its behavior.\nAs an attempt to mitigate these problems, we present and describe a framework for CER which has formal, denotational semantics. We first present a language for CER and"}, {"title": "Formulas and models", "content": "In this section, we follow the notation and notions presented in [31]. The first notion that we need is that of a V-structure. A V-structure essentially describes a domain along with the operations that can be performed on the elements of this domain and their interpretation.\nDefinition 2 (V-structure [31]). A vocabulary V is a set of function, relation and constant symbols. A V-structure is an underlying set U, called a universe, and an interpretation of V. An interpretation assigns an element of U to each constant in V, a function from $U^n$ to U to each n-ary function in V and a subset of $U^n$ to each n-ary relation in V.\nExample 3. Using Example 1, we can define the following vocabulary\n$V = {R, C_1, C_2, C_3, C_4, C_5, C_6}$\nand the universe\n$U = {(B, 1, 22, 300), (B, 1, 24, 225), (B, 2, 32, 1210), (S, 1, 70, 760), (S, 1, 68, 2000), (B, 2, 33, 95)}$"}, {"title": "Conditions", "content": "Based on the above definitions, we will now define conditions over registers. Conditions are the basic building blocks of SREMO. In the simplest case, they are applied to single events and act as filters. In the general case, we need them to be applied to multiple events, some of which may be stored to registers. Conditions will essentially be the n-ary guards on the transitions of SRT.\nDefinition 10 (Condition). Let M be a V-structure always equipped with the unary relation T for which it holds that $u \\in T, \\forall u \\in U$, i.e., this relation holds for all elements of the universe U. Let $R = {r_1,......,r_k}$ be variables denoting the registers and $\\sim$ a special variable denoting an automaton's head which reads new elements. The \u201ccontents\u201d of the head always correspond to the most recent element. We call R register variables. A condition is essentially a V-formula, as defined above (Definition 5), where, instead of terms, we use register variables. A condition is then defined by the following grammar:\n T is a condition.\n P($r_1,......,r_n$), where $r_i \\in RU {\\sim}$ and P an n-ary relation, is a condition.\n $\\neg\\phi$ is a condition, if $\\phi$ is a condition.\n $\\phi_1 \\wedge \\phi_2$ is a condition if $\\phi_1$ and $\\phi_2$ are conditions.\n $\\phi_1 \\vee \\phi_2$ is a condition if $\\phi_1$ and $\\phi_2$ are conditions.\nExample 11. As an example, consider the simple case where we want to detect stock ticks of type BUY (B), followed by a tick of type SELL (S) for the same company. We would thus need a simple condition on the first tick, denoted as TypeIsB($\\sim$), where TypeIsB(x):=x.type=B. TypeIsB($\\sim$) has a single argument, the automaton head. We also need another condition for the SELL tick and the company comparison, denoted as TypeIsS($\\sim$) $\\wedge$ EqualId($\\sim$,$r_1$). We assume that TypeIsS(x) := x.type = S and EqualId(x,y) := x.id = y.id. Note that, beyond the head variable, EqualId also has a register variable as an input argument. We will show later how registers are written.\nSince terms now refer to registers, we need a way to access the contents of these registers. We will assume that each register has the capacity to store exactly one element from U. The notion of valuations provides us with a way to access the contents of registers.\nDefinition 12 (Valuation). Let $R = {r_1,......,r_k}$ be a set of register variables. A valuation on R is a partial function v : R \u2192 U, i.e., some registers may be \u201cempty\u201d. The set of all valuations on R is denoted by $F(r_1,......,r_k)$. Register update happens with v[ri \u2190 u],"}, {"title": "SREMO syntax", "content": "We are now in a position to define Symbolic Regular Expressions with Memory and Output SREMO. We achieve this by combining conditions via the standard regular operators. Conditions act as terminal expressions, i.e., the base case upon which we construct more complex expressions. Each condition may be accompanied by a register variable, indicating that an event satisfying the condition must be written to that register. It may also be accompanied by an output, either indicating that the event must be marked as being part of the complex event, or indicating that the event is irrelevant and should be excluded from any detected complex events.\nDefinition 15 (Symbolic regular expression with memory and output (SREMO)). A symbolic regular expression with memory and output over a V-structure M and a set of register variables $R = {r_1,......,r_k}$ is inductively defined as follows:\n \u03f5 and \u00d8 are SREMO.\n If $\\phi$ is a condition (as in Definition 10) and o \u2208 {\u2022, } an output, then $\\phi \\uparrow o$ is a SREMO."}, {"title": "SREMO semantics", "content": "In order to define the semantics of SREMO, we need to define how the contents of the registers may change. We thus need to first define how a SREMO, starting from a given valuation v and reading a given string S, reaches another valuation v'. Our final aim is to detect matches of a SREMO e in a string $S=t_1,......,t_n$. A match $M={i_1,......, i_k}$ of e on S is a totally ordered set of natural numbers, referring to indices in the string S, i.e., $i_1 \\geq 1$ and $i_k \\leq n$. If $M={i_1,......, i_k}$ is a match of e on S, then the set of elements referenced by M, S[M]={$t_{i1},......, t_{ik}$ } represents a complex event. We write $M = M_1 \\cdot M_2$ for two matches $M_1, M_2$ to denote the fact that $M_1 \\cap M_2 = \\emptyset$, $M_1 \\cup M_2 = M$ and $max(M_1) < min(M_2)$.\nDefinition 17 (Semantics of SREMO). Let e be a SREMO over a V-structure M and a set of register variables $R = {r_1,......,r_k}$, S a string constructed from elements of the universe of M, M a candidate match of e on S and $\\upsilon,\\upsilon' \\in F(r_1,......,r_k)$. We define the relation $(e, S, M, \\upsilon) \\vdash \\upsilon'$ as follows:\n (\u20ac, S, M, \u03c5) $ \\vdash$ v' iff S = \u0454 and v = v' (by definition, M = \u00d8).\n (\u03c6\u2191 \u03bf, S, M, v) - v' iff \u00a2 \u2260 \u0454, S = u, (u, v) = \u03c6, \u03c5' = v and\n   o = and M = \u00d8\n  or\n   o and M = {$i_u$}\nwhere $i_u$ is the index of u."}, {"title": "Symbolic Register Transducers", "content": "We now show how SREMO can be translated to an appropriate automaton model and how this model may then be used to perform CER. We also study the closure properties of this automaton model."}, {"title": "Definition of Symbolic Register Transducers", "content": "In order to capture SREMO, we propose Symbolic Register Transducers (SRT), an automaton model equipped with memory, logical conditions on its transitions and a single output on every transition. The basic idea is the following. We add a set of registers R to an automaton in order to be able to store events from the stream that will be used later in n-ary formulas. Each register can store at most one event. In order to evaluate whether to follow a transition or not, each transition is equipped with a guard, in the form of a Boolean formula. If the formula evaluates to TRUE, then the transition is followed. Since a formula might be n-ary, with n>1, the values passed to its arguments during evaluation may be either the current event or the contents of some registers, i.e., some past events. In other words, the transition is also equipped with a register selection. Before evaluation, the automaton reads the contents of the required registers, passes them as arguments to the formula and the formula is evaluated. Additionally, if, during a run of the automaton, a transition is followed, then the transition has the option to write the event that triggered it to some of the automaton's registers. These are called its write registers W, i.e., the registers whose contents may be changed by the transition. Finally, each transition, when followed, produces"}, {"title": "Properties of SRT", "content": "We now study the properties of SRT. First, we prove that SREMO can be compiled to SRT. We then show that SRT are closed under union, intersection, concatenation and Kleene-start but not under complement and determinization. We can thus construct SREMO and SRT by using arbitrarily (in whatever order and depth is required) the four basic operators of union, intersection, concatenation and Kleene-star. However, the negative result about complement suggests that the use of negation in CER patterns cannot be equally arbitrary. Moreover, deterministic SRT cannot be used in cases where this might be required, as in Complex Event Forecasting [12]. If, however, we use an extra window operator, effectively limiting the length of strings accepted by a SRT, we can then show that closure under complement and determinization is also possible.\nWe first prove that, for every SREMO there exists an equivalent SRT. The proof is constructive, similar to that for classical automata. Equivalence between an expression e and a SRT T means that they recognize the same language and have the same matches. See Definitions 18 and 26.\nTheorem 27. For every SREMO e there exists an equivalent SRT T, i.e., a SRT such that Lang(e) = Lang(T) and Match(e, S) = Match(T, S) for every string S."}, {"title": "Streaming symbolic register transducers", "content": "We have thus far described how SREMO and SRT can be applied to bounded strings that are known in their totality before recognition. A string is given to a SRT and an answer is expected about whether the whole string belongs to the automaton's language or not along with any matches detected. However, in CER we are required to handle continuously updated streams of events and detect instances of SREMO satisfaction as soon as they appear in a stream. For example, the automaton of the classical regular expression ab would accept only the string a, b. In a streaming setting, we would like the automaton to report a match every time this string appears in a stream. For the stream a, b, c, a, b, c, we would thus expect two matches to be reported, one after the second symbol and one after the fifth (assuming that we are interested only in contiguous matches).\nSlight modifications are required so that SREMO and SRT may work in a streaming setting (the discussion in this section develops along the lines presented in our previous work [12], with the difference that here we are concerned with symbolic automata with memory and output). First, we need to make sure that the automaton can start its recognition after every new element. If we have a classical regular expression R, we can achieve this by applying on the stream the expression \u2211\u2217\u00b7 R, where \u2211 is the automaton's (classical) alphabet. For example, if we apply R := {a, b, c}\u2217 \u00b7 (a \u00b7 b) on the stream a, b, c, a, b, c, the corresponding automaton would indeed reach its final state after reading the second and the fifth symbols. In our case, events come in the form of tuples with both numerical and categorical values. Using database systems terminology we can speak of tuples from relations of a database schema [28]. These tuples constitute the universe U of a V-structure M. A stream S then has the form of an infinite sequence S = t1, t2,\u2026, where ti \u2208 U. Our goal is\n first, to report the indices i at which a complex event is detected;\n second, to report the indices of the simple events from which a complex event is composed;\n while taking into account the fact that, at a given index i, multiple complex events may be detected.\nMore precisely, if $S_{1..k}$ =\u00b7\u00b7\u00b7, $t_{k\u22121}, t_k$ is the prefix of S up to the index k, we say that a SREMO e is detected at k iff there exists a suffix $S_{m..k}$ of $S_{1..k}$ such that $S_{m..k} \\in Lang(e)$. Additionally, the streaming matches detected at k are defined as Matchstream(e, S) = {M : $M\\in Match(e, S_{m..k}) \\forall m, 1 \\leq m \\leq k$}"}, {"title": "Closure properties and selection strategies", "content": "Thus far we have described a basic set of operators with which we can define complex event patterns and their corresponding computational model. We have shown that our framework, with these basic operators, has unambiguous, compositional semantics. Contrary to previous CER systems, it does not impose ad hoc restrictions on the use of the operators, which may be used in a fully compositional manner. Besides concatenation/sequence, union/conjunction and Kleene-star/iteration, CER systems make extensive use of other operators as well and even constructs which are external to the language itself. In this Section, we focus on the issue of how and if our proposed framework can accommodate these extra operators and constructs. We specifically discuss the following aspects of CER which are very common in the literature, but have been excluded from our presentation thus far: the operators of intersection/conjunction and complement/negation, the possibility of using deterministic automata for CER, the use of windows and the semantics of selection strategies."}, {"title": "Intersection and complement", "content": "We first study the closure properties of SRT under intersection and complement, two popular operators in CER.\nThe formal definition of closure under intersection and complement is as follows:\nDefinition 33 (Closure of SRT(intersection, complement)). We say that SRT are closed under:\n intersection if, for every SRT T\u2081 and T\u2082, there exists a SRT T such that Match(T, S) = Match(T\u2081, S) \u2229 Match(T\u2082, S), i.e., M is a match of T iff it is a match of T\u2081 and T\u2082.\n complement if, for every SRT T, there exists a SRT Tc such that for every string S it holds that M \u2208 Match(T, S) \u21d4 M \u2209 Match(Tc, S).\nWith regards to intersection, we can prove the following:\nTheorem 34. SRT are closed under intersection.\nNote that intersection was not defined as an operator of SREMO in Definition 15. Theorem 34 indicates that we can introduce such an operator without any difficulties. It is important to distinguish intersection from another operator in CER, which is also often called conjunction and whose intended semantics is that a sequence of events must occur, regardless of their temporal order. This conjunction operator does not require any special treatment, as it can"}, {"title": "Determinization of SRT", "content": "In CER, it is typically the case that non-deterministic automata are employed because they can fully enumerate all the detected matches, i.e., report all input events comprising a match. We also use non-deterministic SRT as a computational model for CER because they can enumerate all the detected matches, i.e., report all input events comprising a match. Recall that complex events (or full matches) are defined as sets (of indices) of simple events. Non-deterministic SRT have the ability to create multiple runs as they consume a stream of events. Each run can mark different input events. Each run that reaches a final state can then report all the input events that it has marked. Thus, all complex events can be fully reported. However, deterministic automata are critical in certain applications, as in Complex Event Forecasting [12], where the goal is to forecast whether a complex event is expected to occur, without necessarily being interested in a complete enumeration. For this reason, we also study whether SRT are determinizable.\nWe can show that SRT are not closed under determinization, a result which might seem discouraging. We first provide the definition for deterministic SRT. Informally, a SRT is said to be deterministic if, at any time, with the same input element, it can follow no more than one transition. The formal definition is as follows:\nDefinition 36 (Deterministic SRT (dSRT)). A SRT T with k registers {$r_1,......,r_k$} over a V-structure M is deterministic if, for all transitions $q, \\phi_1 \\uparrow o_1 \\downarrow W_1 \\rightarrow q_1 \\in T.\\Delta$ and $q, \\phi_2 \\uparrow o_2 \\downarrow W_2 \\rightarrow q_2 \\in T.\\Delta$, if $q_1 \\neq q_2$ then, for all $u \\in M.U$ and $v \\in F(r_1,......,r_k)$,\nEither (u, v) = $\u03c6_1$ and (u, v) \u22a8 $\u03c6_2$\nor (u, v) \u22a8 $\u03c6_1$ and (u, v) = $\u03c6_2$\nor (u, v) \u22a8 $\u03c6_1$ and (u, v) \u22a8 $\u03c6_2$."}, {"title": "Windowed SREMO/SRT", "content": "We can overcome the negative results about determinization by using windows in SREMO and SRT. We show that there exists a sub-class of SREMO for which a translation to output-agnostic deterministic SRT is indeed possible. This is achieved if we apply a windowing operator and limit the length of strings accepted by SREMO and SRT. In general", "ew": "e[1..w"}]}