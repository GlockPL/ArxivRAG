{"title": "On Deciding the Data Complexity of Answering Linear Monadic Datalog Queries with LTL Operators (Extended Version)", "authors": ["Alessandro Artale", "Anton Gnatenko", "Vladislav Ryzhikov", "Michael Zakharyaschev"], "abstract": "Our concern is the data complexity of answering linear monadic datalog queries whose atoms in the rule bodies can be prefixed by operators of linear temporal logic LTL. We first observe that, for data complexity, answering any connected query with operators \u25cb/\u25cb\u00af (at the next/previous moment) is either in AC\u00ba, or in ACC\u00b0 \\AC\u00b0, or NC\u00b9-complete, or L-hard and in NL. Then we show that the problem of deciding L-hardness of answering such queries is PSPACE-complete, while checking membership in the classes ACO and ACC\u00ba as well as NC\u00b9-completeness can be done in EXPSPACE. Finally, we prove that membership in AC or in ACCO, NC\u00b9-completeness, and L-hardness are undecidable for queries with operators \u25ca/\u25c7\u00af (sometime in the future/past) provided that NC\u00b9 \u2260 NL and L \u2260 NL.", "sections": [{"title": "Introduction", "content": "We consider monadic datalog queries, in which atoms in the rule bodies can be prefixed by the temporal operators \u25cb/\u25cb\u00af (at the next/previous moment) and \u25ca/\u25ca (sometime in the future/past) of linear temporal logic LTL [16]. This query language, denoted datalog, is intended for querying temporal graph databases and knowledge graphs in scenarios such as virus transmission [24, 47], transport networks [27], social media [40], supply chains [48], and power grids [38]. In this setting, data instances are finite sets of ground atoms that are timestamped by the moments of time they happen at. The rules in datalogm queries are assumed to hold at all times, with time being implicit in the rules and only accessible via temporal operators. We choose LTL for our formalism rather than, say, more expressive metric temporal logic MTL [29, 1] because LTL has been a well established query language in temporal databases since the 1990s (see [41, 43, 13, 32] and the discussion therein on point versus interval-based query languages), also suitable in the context of temporal knowledge graphs as recently argued in [18].\nImagine a PhD student working on a paper while hostel hopping. However, finishing the paper requires staying at the same hostel for at least two consecutive nights."}, {"title": "Preliminaries", "content": "A relational schema \u2211 is a finite set of relation symbols R with associated arities m \u2265 0. A database D over a schema \u2211 is a set of ground atoms R(d\u2081, ..., dm), R \u2208 \u03a3, m is the arity of R. We call di, 1 \u2264 i \u2264 m, the domain objects or simply objects. We denote by AD the set of objects occurring in D. We denote by |D| the number of atoms in D. We denote by [a, b] the set of integers {m | a \u2264 m \u2264 b}, where a, b \u2208 Z. A temporal database D over a schema \u2211 is a finite sequence (D\u2081, D\u2081+\u2081 ..., Dr\u208b\u2081, Dr) of databases over this schema for some l < r, l, r \u2208 Z. Each database Di,l \u2264 i \u2264 r, is called the i'th slice of D and i is called a timestamp. We denote [l, r] by tem(D). The size of D, denoted by |D|, is the maximum between tem(D)| and max{|D\u2081|,...,|D|}. The domain of the temporal database D is Ul<i<r \u2206Di and is denoted by A\u0e18. A homomorphism from Das above to D' = (Dv, D+\u2081..., Dr\u2032\u208b\u2081, Dr') is a function h that maps ADU [l, r] to \u2206p' \u222a [l', r'] so that R(d\u2081, ..., dm) \u2208 De if and only if R(h(d\u2081),...,h(dm)) \u2208 D'h(l)\u00b7\nWe will deal with temporal conjunctive queries (temporal CQs) that are formulas of the form Q(X) = \u2203U\u03c6(X,U), where X,U are tuples of variables and \u03c6, the body of the query, is defined by the following BNF:\n\u03c6 ::= R(Z\u2081, ..., Zm) | (\u03c6\u2227 \u03c6) | \u039f\u03c6"}, {"title": "Temporal Datalog", "content": "We define a temporalised version of datalog to be able to use recursion in querying temporal databases. We call this language temporal datalog, or datalog. A rule of datalog over a schema \u2211 has the form:\nC(X) \u2190 O*R\u2081(\u016a\u2081) \u2227...\u2227O*R\u209b(\u016a\u209b)\nwhere Ri and C are relation symbols over \u2211 and O* is an arbitrary sequence of temporal operators O, \u00af,\u25ca and \u25ca\u00af. The part of the rule to the left of the arrow is called its head and the right-hand side its body. All variables from the head must appear in the body. A program is a finite set of rules. The relations that appear in rule heads constitute its IDB schema, IDB(\u03c0), while the rest form the EDB schema, EDB(\u03c0). A rule is linear if its body contains at most one IDB atom and monadic if the arity of its head is 1. A program \u03c0is linear (monadic) if so are all its rules. We say that the program is in plain datalog if it does not use the temporal operators and in plain LTL if all its relations have arity 1 and every rule uses just one variable. Recursive rules are those that contain IDB atoms in their bodies, other rules are called initialisation rules. The arity of a program is the maximal arity of its IDB atoms.\nOur results are all about connected programs. Namely, define the Gaifman graph of a temporal CQ to be a graph whose nodes are the variables and where two variables are connected by an edge if they appear in the same atom. A rule body is connected if so is its Gaifman graph, and a program is connected when all rules are connected. The size of a program \u03c0, denoted \u03c0\u2758, is the number of symbols needed to write it down, where every relation symbol R\u2208 EDB(\u03c0)UIDB(\u03c0) is counted as one symbol, and a sequence of operators the form Ok is counted as |k| symbols.\nWhen a program is fixed, we assume that all temporal databases that we work with are defined over EDB(\u03c0). So let \u03c0be a program and D a temporal database. An enrichment of D is an (infinite) temporal database E = (Ee)e\u2208z over the schema EDB(\u03c0) U IDB(\u03c0) such that \u0394\u03b5 = AD and for any R\u2208 EDB(\u03c0) and any l \u2208 Z, R(d\u2081,...,dm) \u2208 Ee if and only if R(d\u2081,..., dm) \u2208 De. Thus, the only EDB atoms in E are those of D, but E 'enriches' D with various IDB atoms at different points of time. We say that E is a model of \u03c0 and D if (i) E is an enrichment of D; and (ii) for any rule C(X) \u2190 \u03c8(X,\u016a) of \u03c0, \u03b5 |= C(X) \u2190 \u03c8(X,U), i.e., for all le Z and any tuples d\u2208 \u0394\u0395\u0394 \u0394\u03b5 A, E, (d, 8) implies E, l = C(d). We write D, \u03c0, l = C(d) if for every model E of \u03c0and D it follows that E, l = C(d)."}, {"title": "Expansions for Linear Monadic Queries.", "content": "Leta be a datalogim program and Q(X) be a unary temporal conjunctive query with a single answer variable and containing a unique IDB atom, say D(Y), from \u03c0. Let P(X) be another temporal conjunctive query with a single answer variable, and let P'(Y) be obtained from P(X) by substituting X by Y and all other variables with fresh ones. A composition of Q and P, denoted Qo P, has the form of Q with D(Y) substituted with P'(Y). We note that the variables of Q remain present in QoP and X is an answer variable of QP. If P contains an IDB atom and K(X) is another temporal conjunctive query, the composition can be extended in the same fashion to (QP) o K, and so on. Note that, up to renaming of variables, (Q0P)\u3002K and Q\u0970 (PoK) are the same queries, so we will omit the brackets and write QOPOK.\nExpansions are compositions of rule bodies of a program \u03c0. Let B\u2081, B\u2082,..., Bn\u208b\u2081 be such that Bi is the body of the recursive rule:\nC\u2081(X) \u2190 A\u1d62(X,Y,U\u2081,...,Um\u1d62) \u2227 Ok\u1d62 C\u1d62\u208a\u2081(Y),\nand Bn is the body of an initialization rule\nCn(X) \u2190 B(X, V\u2081, ..., Vmn).\nThe composition B\u2081 \u25cb\u2026o Bn is called an expansion of (\u03c0, C\u2081), and n is its length. The set of all expansions of (\u03c0, C\u2081) is denoted expand(\u03c0, C1). Moreover, let I be the set of all recursive rule bodies of and I be the set of all initialization rule bodies. Then each expansion can be regarded (by omitting the symbol o) as a word in (\u0393)*\u0393, and expand(\u03c0, C\u2081) as a sublanguage of (\u0393)*\u0393. Adopting a language-theoretic notation, we will use small Latin letters w, u, v, etc. to denote expansions. To highlight the fact that each expansion is a temporal conjunctive query with the answer variable X, we sometimes write w(X) \u2208 expand(\u03c0, C).\nIt is a direct generalization from the case of plain datalog [34] that D, \u03c0, l = C(d) if and only if there exists w(X) \u2208 expand(\u03c0, C) such that De = w(d)."}, {"title": "Undecidability for Queries with \u25ca", "content": "Our first result about deciding the complexity of a given query is negative.\nIt is undecidable whether a given datalogim-query can be answered in AC\u00ba, ACC\u00ba, or NC\u00b9 (if NC\u00b9 \u2260 NL). It is undecidable whether the query is L-hard (if L \u2260 NL)."}, {"title": "Automata-Theoretic Tools for Queries with O", "content": "From now on, we focus on queries that use operators \u25cb and \u25cb\u00af only. In this section, we develop a generalisation of the automata-theoretic approach to analysing query expansions proposed in [14]. In Section 5 we use this approach to study the data complexity of this kind of queries."}, {"title": "Decidability for Connected Linear Queries with O", "content": "We use the automata introduced in the previous section to prove a positive result.\n(i) Every connected datalogim query is either in AC\u00ba, or in ACC\u00b0 \\ AC\u00ba, or NC\u00b9-complete, or L-hard. (ii) It is PSPACE-complete to check whether such a query is L-hard; whether it belongs to AC\u00ba, ACC\u00ba, or is NC\u00b9-complete can be decided in EXPSPACE.\nWe first deal with (i). Intuitively, L-hardness is a consequence of the growth of query expansions in the relational domain. If this growth is limited, the query essentially defines a certain temporal property, which can be checked in NC\u00b9. Formally, given a word a \u2208 \u03a9*, we define the height(a) as the number of vertical letters in a. Then, we call a query vertically unbounded if for every k there is a word a \u2208 Accept(\u03c0,G), height(a) > k, such that every prefix of a of height k is in NotAccept(\u03c0, G). Otherwise, the query is called vertically bounded.\nVertically unbounded queries can be shown to be L-hard by a direct reduction from the undirected reachability problem. Namely, take the deterministic automata for NotAccept(\u03c0, G) and Accept(\u03c0, G), supplied by Lemma 11 and Corollary 12, and apply the pumping lemma to obtain words \u03be,\u03c5, \u03b6, \u03b3 such that height(v) > 0, \u03be\u03c5\u03b6 \u2208 NotAccept(\u03c0,G) and \u03be\u03c5\u03ad\u03b6\u03b3 \u0395 Accept(\u03c0, G), for all i \u2265 0. Then, given a graph G and two nodes s, t, use copies of Du to simulate the edges of G, and attach De to s and Dry to t. Thus, you will obtain a temporal database D\u00e7, where D\u00e7, \u03c0,0 |= G(s) if and only if there is a path from s to t."}, {"title": "Conclusions and Future Work", "content": "We have started investigating the complexity of determining the data complexity of answer-ing monadic datalog queries with temporal operators. For linear connected queries with operators 0/0\u00af, we have generalised the automata-theoretic technique of [14], developed originally for plain datalog, to establish an AC\u00b0/ACC\u00b0/NC\u00b9/L/NL classification of tem-poral query answering and proved that deciding L-hardness of a given query is PSPACE-complete, while checking its membership in AC or ACC can be done in EXPSPACE. As a minor side product, we have established PSPACE-hardness of deciding boundedness of atem-poral connected linear monadic datalog queries. Rather surprisingly and in sharp contrast to the 0/0 case, it turns out that checking (non-trivial) membership of queries with op-erators in the above complexity classes is undecidable. The results of this paper lead to a plethora of natural and intriguing open questions. Some of them are briefly discussed below.\n1. What happens if we disallow applications of \u25ca\u25ca to binary EDB predicates in datalogim-queries? We conjecture that this restriction makes checking membership in the above complexity classes decidable. In fact, this conjecture follows from a positive answer to the next question.\n2. Can our decidability results for datalogo be lifted to datalog-queries? Dropping the linearity restriction in the atemporal case results in the extra data complexity class, P, and the higher complexity, 2EXPTIME-completeness, of deciding boundedness. The upper bound was obtained using tree automata in [14], and we believe that this approach can be generalised to connected datalog-queries in a way similar to what we have done above.\n3. On the other hand, dropping the connectedness restriction might turn out to be trickier, if at all possible, as shown by Example 19. Finding a new automata-theoretic character-isation for disconnected datalogim-queries remains a challenging open problem.\n4. A decisive step in understanding the data complexity of answering queries mediated by a description logic ontology and monadic disjunctive datalog queries was made in [8, 17] by establishing a close connection with constraint satisfaction problems (CSPs). In our case, quantified CSPs (see, e.g., [49]) seem to be more appropriate. Connecting the two areas might be beneficial to both of them.\n5. In the context of streaming data, it would be interesting to investigate the data complex-ity classes and the complexity of recognising them for datalogMTL-queries [9, 37, 46]."}], "equations": ["C(X) \u2190 O*R\u2081(\u016a\u2081) \u2227...\u2227O*R\u209b(\u016a\u209b)", "\u03c6 ::= R(Z\u2081, ..., Zm) | (\u03c6\u2227 \u03c6) | \u039f\u03c6", "D, l = R(d\u2081, ..., dm) \u2194 l \u2208 [l,r] and R(d\u2081, ..., dm) \u2208 De", "D, l = \u03c6\u2081 \u2227 \u03c6\u2082 \u21d4 D, l = \u03c6\u2081 and D, l = \u03c6\u2082", "D, l = O\u03c6 \u21d4 D, l + 1 = \u03c6", "D, l = \u25ca\u03c6 \u21d4 D, l' = \u03c6 for some l' > l", "D, r + N + 1 = \u03b7(d) \u21d4 D, l = \u03b7(d) for all l > r + N", "D,l \u2013 N \u2013 1 = \u03b7(d) \u2194 D, l = \u03b7(d) for all l <l-N", "G(X) \u2190 A(X) \u2227OR(X, Y) \u2227OD(Y),", "D(X) \u2190 OD(X),", "D(X) \u2190 B(X).", "G(X) \u2190 \u25c7R(X, Y) \u2227 D(Y).", "D, l = \u03c6 \u2194 D, l = \u03c8\u2084(d,l), for l<l <r", "D, (r + i) = \u03ba(d) \u2194 D = \u03c8(d), for 1 \u2264 i \u2264 N + 1", "D, (l + i) = \u03ba(d) \u21d4 D = \u03c8\u00b2(d), for - N \u22121 \u2264 i \u22641", "\u03c8\u03ba\u2081\u03ba\u2082 = \u03c8\u03ba\u03b9 \u2227 \u03a8\u03ba\u2082", "\u03c8\u03ac\u03ba\u03b9^\u03ba\u2082 = \u03c8\u03ad\u03ba\u03b9 \u2227 \u03c8\u03ad\u03ba\u2082", "\u03c8\u014c(Z) = \u03c8\u03ad(Z, min)", "4+1 (Z) = x+1(Z)", "Vozx(Z) = vox+1(2), for all other i", "Vox(Z,t) = \u2203t'[(t' = t + 1) ^ \u03c8x(Z, t')] \u2228 ((t = max)^(Z))", "Voz (Z) =", "Voz, Z), for 0 < i < N + 1", "Voz (Z) =", "Voz (Z)^\u2203t[(min \u2264 t \u2264 max) ^ \u03c8x(Z,t)], for - N \u2212 1 \u2264 i < 0", "N+1(Z)", "N+1 (Z) = 4+(Z)", "O\u0445(Z,t) = \u2203t'[(t <t')^4x(Z,t')] \u221a \u221a \u03c8 (2)", "S\u00bf(X) \u2190\u25ca*RV(X), 0 \u2264 i \u2264n", "RV (X) \u2190 U\u2081(X, Y) ^ \u25caU\u2081(X, Z),", "RV (X) \u2190 U2(X, Y) \u2227 \u25caU2(X, Z),", "RV(X) \u2190 T(X, Y) ^ \u25caT(X, Z)", "NE\u00af\u00af\u00b9(Y) \u2190 U\u2084(Y, Z) ^ Uc(X, Y)", "NE\u00af\u00af\u00b9(Y) \u2190 U(X, Y) \u2227 \u25caU\uff61(Y, Z)", "NE(Y) \u2190 U(Y, Z) \u2227 \u25caU(X, Y)", "NE(Y) \u2190 U(Y, Z) \u2227 \u25caU(X, Y)", "NE\u00af\u00b9(Y) \u2190 U\u2084(Y, Z) \u2227 \u25ca\u25caU\u2084(X,Y)", "NE(Y) \u2190 U\u2084(Y, Z) \u2227U(X,Y)", "NE(Y) \u2190 U(X, Y) \u2227 \u25ca\u25caU\uff61(Y, Z)", "NE(Y) \u2190 U(X, Y) \u2227 \u25caUc(Y, Z)", "Si(X) \u2190\u25ca*NE\u2081\u00b9 (Y) \u2227 \u25ca\u00baU\u2081(X, Y)", "S\u00bf(X) \u2190 \\*NE\u00ba\u00b2 (Y) \u2227 \u25ca\u1e9eU2(X,Y)", "S\u2081(X) \u2190 T(X, Y) \u2227 \u25ca\u00baU\u2081(X, Y) \u2227 \u25ca \u1e9eU2(X, Y) ^ S; (Y),", "G(X) \u2190 So(X) ^ U\u2081(X, Y) ^ U2(X, Y).", "D(X) \u2190 0k1 R1(\u016a1) \u2227...\u22270ks R\u209b(\u016a\u209b) \u22270*E(Y),", "{|S\u2081(X)| \u2264 \u03c02} \u2208 D", "C(X) \u2190 B(X, Y,U1,...,Um) \u2227 OkD(Y),", "C(c) Bk D(d) if D, l = \u2203U1,...,Um(B(c, d, U1, ...,Um)).", "C(c) \u2190l if D, l = \u2203U1, ..., Um (B(c, U1,...,Um)),", "C(c) \u2190l,k D(d) iff C(c) \u2190l',k D(d)", "C(c) \u2190l iff C(c) \u2190l", "Co(Co) \u2190lo,ko C1(C1) \u2190l1,k1 \u2026\u2026\u2190ln-1,kn-1 Cn (Cn)", "shder (i) = \u03a3k for 0 < i < n", "der' = C(Co) \u2190k C\u2081(C\u2081) \u2190k\u2081 \u2190km-1 Cm(Cm)", "Co(co) = Ci(ci), Cm(cm) = Cj (cj), min{shder'(i)} = 0,", "shder' (m) = 0, and max{shder'(i)} < 2(|IDB(\u03c0)||domD|)\u00b2,", "G(X) \u2190 Next(X, X\u2081) ^ Next(X1, X2) \u2227...\u2227 Next(Xk\u22121, Xk) ^ Qa(Xk),", "F(X) \u2190 Qa(X) ^ Q(X), for a \u2260 b.", "F(X) \u2190 Qa(X) \u2227 Next(X, Y) ^ Q\u266d(Y) ^ F(Y),"]}