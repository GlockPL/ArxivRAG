{"title": "ALGEBRAIC ANTI-UNIFICATION", "authors": ["CHRISTIAN ANTI\u0106"], "abstract": "Abstraction is key to human and artificial intelligence as it allows one to see common structure in otherwise distinct objects or situations and as such it is a key element for generality in AI. Anti-unification (or generalization) is the part of theoretical computer science and AI studying abstraction. It has been successfully applied to various AI-related problems, most importantly inductive logic programming. Up to this date, anti-unification is studied only from a syntactic perspective in the literature. The purpose of this paper is to initiate an algebraic (i.e. semantic) theory of anti-unification within general algebras. This is motivated by recent applications to similarity and analogical proportions.", "sections": [{"title": "1. INTRODUCTION", "content": "Abstraction is key to human and artificial intelligence (AI) as it allows one to see common structure in otherwise distinct objects or situations (Giunchiglia & Walsh, 1992; Saitta & Zucker, 2013) and as such it is a key element for generality in computer science and artificial intelligence (McCarthy, 1987; Kramer, 2007). It has been studied in the fields of theorem proving (e.g. Plaisted, 1981) and knowledge representation and reasoning (KR&R) by a number of authors (e.g. Knoblock, 1994; Sacerdoti, 1974), and it has recently gained momentum in answer set programming (Saribatur & Eiter, 2020; Saribatur, Eiter, & Sch\u00fcller, 2021), one of the most prominent formalisms in the field of KR&R (see e.g. Brewka, Eiter, & Truszczynski, 2011; Lifschitz, 2019). Saribatur et al. (2021) contain a very rich bibliography for readers interested in the literature on abstraction.\nAnti-unification (or generalization) (cf. Cerna & Kutsia, 2023) is the field of mathematical logic and theoretical computer science studying abstraction. It is the \"dual\" operation to the well-studied unification operation (cf. Baader & Snyder, 2001). More formally, given two terms s and t, unification searches for a substitution the most general unifier \u03c3 satisfying $s\\sigma = t \\sigma$, whereas syntactic anti-unification searches for the least general generalization u such that $s = u\\tau$ and $t = u\\theta$, for some substitutions \u03c3,\u03b8. Notice the difference between the two operations: while unification computes a substitution, anti-unification computes a term.\nSyntactic anti-unification has been introduced by Plotkin (1970) and Reynolds (1970), and it has found numerous applications in theoretical computer science and artificial intelligence, as for example in inductive logic programming (Muggleton, 1991) (cf. Cropper & Morel, 2021; Cropper, 2022), programming by example (Gulwani, 2016), library learning and compression (Cao et al., 2023), and, in the form of E-generalization (i.e. anti-unification modulo theory) (Heinz, 1995; Burghardt, 2005) in analogy-making (Weller & Schmid, 2007; Schmidt et al., 2014) (for further applications, see e.g. Barwell et al., 2018; de Sousa et al., 2021; Vanhoof & Yernaux, 2019).\nThe purpose of this paper is to initiate an algebraic theory of anti-unification within general algebras. More formally, given two algebras A and B in the sense of general algebra (cf. Burris &"}, {"title": "2. PRELIMINARIES", "content": "We expect the reader to be fluent in basic general algebra as it is presented for example in Burris and Sankappanavar (2000, \u00a7II).\nA language L of algebras is a set of function symbols\u00b2 together with a rank function $r : L \u2192 N$. Moreover, we assume a denumerable set X of variables distinct from L. Terms are formed as usual from variables in X and function symbols in L and we denote the set of all such terms by $T_{L,x}$. The set of variables occurring in a term s are denoted by X(s) and s has rank k iff $X(s) = {x_1,..., x_k}$. The rank of s is denoted by $r_s$.\nAn L-algebra A consists of a non-empty set A, the universe of A, and for each function symbol f \u2208 L, a function $f_{\\mathfrak{A}} : A^{r(f)} \u2192 A$, the functions of A (the distinguished elements of A are the 0-ary functions). We will not distinguish between distinguished elements and their 0-ary function symbols.\nAn algebra is injective iff each of its function is injective. Notice that every distinguished element a of A is a 0-ary function $a : A^\\emptyset \u2192 A$ which maps some single dummy element in $A^\\emptyset$ to a and thus is injective.\nEvery term s induces a term function $s_{\\mathfrak{A}}$ on A in the usual way. In this paper, we shall not distinguish between terms inducing the same function on the underlying algebra, which is common practice in mathematics where one does usually not distinguish, for example, between the terms 2x\u00b2 and (1 + 1)x\u00b2 in arithmetic.\nFact 1. Every term function induced by injective functions is injective.\nThe term algebra $T_{L,X}$ over L and X is the algebra we obtain by interpreting each function symbol f\u2208 L by\n$f_{T_{L,X}}: T_{L,X}^{r(f)} : s_1 ... s_{r(f)} \u2192 f(s_1,..., s_{r(f)})$.\nA substitution is a mapping $\u03c3 : X \u2192 T_{L,x}$, where $x\u03c3 := x$ for all but finitely many variables, extended from X to terms in $T_{L,X}$ inductively as usual, and we write so for the application of \u03c3 to the term s. For two terms s, t \u2208 $T_{L,X}$, we define the syntactic generalization ordering by\n$s \\leq t \u21d4: s = t\u03c3, for some substitution \u03c3.$"}, {"title": "3. ANTI-UNIFICATION", "content": "This is the main section of the paper. Here we shall introduce algebraic anti-unification and derive some elementary observations.\nIn the rest of the paper, let A and B be L-algebras over some joint language of algebras L, and let (A, B) be a pair of L-algebras. We will always write A instead of $A_{\\mathfrak{A}}$.\nDefinition 2. Given an L-term s, define\n$\\downarrow_{\\mathfrak{A}} s := {s^{\\mathfrak{A}}(o) \u2208 A | o \u2208 A^{r(s)}}$.\nIn case $a \u2208 \\downarrow_{\\mathfrak{A}}s$, we say that s is a generalization of a and a is an instance of s.\nFact 3. Every distinguished element $a \u2208 A$ is an instance of itself since\n$a \u2208 \\downarrow_{\\mathfrak{A}} a = {a}$.\nDefinition 4. Define the (semantic) generalization ordering for two L-terms s and t in (A, B) by\n$s \\sqsubseteq_{(A,B)} t :\u21d4 \\downarrow_{\\mathfrak{A}}s \u2286 \\downarrow_{\\mathfrak{A}}t and \\downarrow_{\\mathfrak{B}} s \u2286 \\downarrow_{\\mathfrak{B}} t,$\nand\n$s \\approx_{(A,B)} t :\u21d4 s \\sqsubseteq_{(A,B)} t and t \\sqsubseteq_{(A,B)} s$.\nExample 5. 0x $ \\approx_{(\\mathbb{N},.,0)} 0$.\nFact 6. The generalization ordering $\\sqsubseteq_{(A,B)}$ is a pre-order between L-terms, for any pair of L-algebras (A, B), that is, it is reflexive and transitive.\nFact 7. For any distinguished element $a \u2208 A$, we have by (1):\n$a \u2208 \\downarrow_{\\mathfrak{A}} a \\Leftrightarrow a \\sqsubseteq_{\\mathfrak{A}} s,$\nand\n$s =_{\\mathfrak{A}} a \\Leftrightarrow s \\approx_{\\mathfrak{A}} a \\Leftrightarrow$ s is a constant function with value a.\nFor two distinguished elements a, b \u2208 A, we have\n$a \\sqsubseteq_{\\mathfrak{A}} b \u21d4 \\downarrow_{\\mathfrak{A}}a\u2286 \\downarrow_{\\mathfrak{A}} b \u21d4 {a} \u2286 {b} \u21d4 a \\approx_{\\mathfrak{A}} b \u21d4 a = b$.\nRemark 8. Notice that our semantic generalization ordering differs from the usual one in syntactic anti-unification \u2264 where a term s is said to be more general than a term tiff there is a substitution \u03c3 such that t = so.\nDefinition 9. For any element $a \u2208 A$, we define\n$\\uparrow_{\\mathfrak{A}} a := {s \u2208 T_{L,x} | a \u2208 \\downarrow_{\\mathfrak{A}}s}$,\nextended to elements $a \u2208 A$ and $b \u2208 B$ by\n$a\\uparrow_{(A,B)} b := (\\uparrow_{\\mathfrak{A}} a) \u2229 (\\uparrow_{\\mathfrak{B}} b).$"}, {"title": "4. GENERALIZATION TYPE", "content": "The following definition is an adaptation of the nomenclature in the excellent survey on anti-unification by Cerna and Kutsia (2023, Definition 5) (triviality is new):\nDefinition 12. The generalization type of a pair of L-algebras (A, B) is called\nnullary iff $a \\uparrow_{(A,B)} b = \\emptyset$, for all $a \u2208 A$ and $b \u2208 B$;\nunitary iff $|a \\uparrow_{(A,B)} b| = 1$, for all $a \u2208 A$ and $b \u2208 B$;\nfinitary iff\n$|a \\uparrow_{(A,B)} b| < \u221e$, for all $a \u2208 A$ and $b \u2208 B$;\n$|a \\uparrow_{(A,B)} b| > 1$, for some $a \u2208 A$ and $b \u2208 B$;\ninfitary iff $|a \\uparrow_{(A,B)} b| = \u221e$, for some $a \u2208 A$ and $b \u2208 B$;\ntrivial iff $a \\uparrow_{(A,B)} b = T_{L,x}$, for all $a \u2208 A$ and $b \u2208 B$.\nFact 13. $ \\uparrow a = {x}$ implies $a \\uparrow_{(A,B)} b = {x}$, for all $b \u2208 B$. Hence, algebras containing elements having only the trivial generalization x cannot be nullary.\nFact 14. $a\\uparrow_{(A,B)} b = {x}$ implies $a \\uparrow_{(A,B)} b = a \\uparrow_{(A,B)} b \u2260 \\emptyset$.\nFact 15. In any pair of algebras (A, B) with $|A| = |B| = 1$, we have $a \\uparrow_{(A,B)} b = a \\uparrow_{(A,B)} b \u2260 \\emptyset$. Hence, algebras consisting of a single element cannot be nullary.\nProof. Every generalization $s \u2208 a \\uparrow_{(A,B)} b$ has to satisfy $\\downarrow_{\\mathfrak{A}} s = {a}$ and $\\downarrow_{\\mathfrak{B}} s = {b}$, which means that there cannot be a generalization t such that$\\downarrow_{(A,B)} t\u2286 \\downarrow_{(A,B)} S.$"}, {"title": "5. CHARACTERISTIC GENERALIZATIONS", "content": "Anti-unifying an element with itself yields the set of minimal general generalizations of that el-ement which, in a sense, \u201ccharacterize\u201d that element since generalizations encode properties of el-ements (for example, 2x is a genearlization of a natural number a iff a is even). This motivates the following definition:\nDefinition 23. Define the set of characteristic generalizations of $a \u2208 A$ in A by\n$a \\sqcup_A a := min \\uparrow_A a = a \\uparrow_A a$.\nExample 24. Recall the situation in Example 11. We have\n$\\uparrow_{BOOL} 0 = {s \u2208 T_{\\{v,\u00ac,0,1\\}x} | s is unsatisfiable}$,\n$\\uparrow_{BOOL} 1 = {x \u2208 T_{\\{v,\u00ac,0,1\\}x} | s is valid}$,\n$0 \\sqcup_{BOOL} 1 = 0 \\uparrow_{BOOL} 1$.\nDefinition 25. We call a set G of generalizations a characteristic set of generalizations of a in A iff\n(1) $G\u2286 \\uparrow a \u2208 \u0391$;\n(2) $G \u2260 a b for all b \u2260 a.\nIn case G = {s} is a singleton, we call s a characteristic generalization of a in A.\nExample 26. $X \\cup X^\\emptyset$ is a characteristic generalization of $U$ in $(2^U, \\cup)$.\nExample 27. $x + (-x)$ is a characteristic generalization of 0 in (Z, +)."}, {"title": "6. HOMOMORPHISMS", "content": "In this section, we show that algebraic anti-unification is compatible with structure-preserving map-pings.\nLemma 28 (Homomorphism Lemma). For any homomorphism $H : A \u2192 B$, any L-term s, and any elements a, b \u2208 A,\n(2)\n$H(\\downarrow_{\\mathfrak{A}} s) \u2286 \\downarrow_{\\mathfrak{B}}s,$\n(3)\n$a \\uparrow_{\\mathfrak{A}} b\u2286 H(a) \\uparrow_{\\mathfrak{B}} H(b).$"}, {"title": "7. MONOUNARY ALGEBRAS", "content": "In the rest of this section, let $A = (A, S)$ be a monounary algebra with $S : A \u2192 A$ the only unary function (we can imagine S to be a generalized \u201csuccessor\u201d function).\nExample 30. We show that the generalization type of the monounary algebra\nis infinitary and trivial. We have\n$\\uparrow_{\\mathfrak{A}} a = {S^m(x) | m \u2265 0} .$\nSince\n$\\downarrow_{\\mathfrak{A}} S^m(x) = \\downarrow_{\\mathfrak{A}}S^n(x) = {a}, for all m, n \u2265 0,$\nwe have\n$S^m(x) =_{\\mathfrak{A}} S^n(x), for all m, n \u2265 0,$\nand thus\n$a \\sqcup_{\\mathfrak{A}} a = {S^m(x) | m \u2265 0} = T_{\\{s\\}\\{x\\}}.$"}, {"title": "8. FINITE UNARY ALGEBRAS AKA SEMIAUTOMATA", "content": "In this section, we study algebraic anti-unification in finite unary algebras, which can be seen as semiautomata, and show that we can use well-known methods from the theory of finite automata to compute sets of (minimally general) generalizations.\nIn the rest of this section, let\n$A = (A, \u03a3 := {f_1, ..., f_n}),$\nfor some n \u2265 1, be a finite unary algebra with finite universe A. We shall now recall that every such algebra is essentially a semiautomaton.\nRecall that a (finite deterministic) semiautomaton (see e.g. Holcombe, 1982, \u00a72.1) is a construct\n$S = (S, \u03a3, \u03b4),$"}, {"title": "9. THE (k, l)-FRAGMENTS", "content": "Since computing the set of all generalizations is rather difficult in general, it is reasonable to study fragments of algebraic anti-unification. For this, we introduce in this section the (k, l)-fragments:\nDefinition 38. Let $X_k := {x_1, . . ., x_k}$, for some $k, l \u2208 N \u222a {0}$ so that $X_\\infty = X$. Define\n$\\uparrow^{(k, l)} a := (\\uparrow_{\\mathfrak{A}} a) \u2229 {s(x_1,..., x_k) \u2208 T_{L,X} | each of the k variables in $X_t$ occurs at most l times in s}.\nWe write k instead of (k, \u221e) so that\n$\\uparrow^k a = (\\uparrow_{\\mathfrak{A}} a) \u2229 T_{L,X_k}.$\nThe simplest fragment \u2013 namely, the (1, 1)-fragment contains only monolinear generalizations containing exactly one occurrence of a single variable x. We denote the monolinear generalization and instantiation operations in A by $\\uparrow^m$ and $\\downarrow_{\\mathfrak{A},m}$, respectively, and the so-obtained anti-unification relation by =\\mathfrak{A},m.\nAs a simple demonstration of fragments, we compute monolinear algebraic anti-unification in the set domain:\nProposition 39. For any universe U and A, B \u2286 U, we have\n$A \\sqcap^{(2^U, \\cup, 2^U)} B =$\n$\\begin{cases}\\{X\\cup (A \\cap B)\\} & A \\neq B,\\\\\\{A\\} & A = B,\\end{cases}$\n$A \\sqcap^{(2^U, \\cap, 2^U)} B =$\n$\\begin{cases}\\{X \\cap (A \\cup B)\\} & A \\neq B,\\\\\\{A\\} & A = B,\\end{cases}$\n$A \\sqcap^{(2^U, , 2^U)} B =$\n$\\begin{cases}\\{X, X^\\complement\\} & A \\neq B,\\\\\\{A\\} & A = B.\\end{cases}$"}, {"title": "10. FINITE ALGEBRAS", "content": "In this section, let A be a finite algebra which means that its underlying universe A is a finite set and it contains finitely many functions. For k \u2265 1, let $X_k := {X_1, ..., X_k}$.\nRecall that a (frontier-to-root) tree automaton (see e.g. G\u00e9cseg & Steinby, 2015)\n$T_{k,a,F(A)} := (A, L, X_k, a, F)$\nconsists of\na finite L-algebra A,\nan initial assignment $a : X_k \u2192 A$, and\na set FC A of final states.\nThe regular tree language recognized by $T_{k,a,F(A)}$ is given by\n$||T_{k,a,F(A)}|| := {s \u2208 T_{L,X_k} | s^{\\mathfrak{A}} a \u2208 F}."}, {"title": "11. GENERALIZED ALGEBRAIC ANTI-UNIFICATION", "content": "In this section, we introduce the following generalization of element-wise anti-unification from above to set-wise anti-unification. In the rest of this section, C is a subset of the universe A of A, and D is a subset of the universe B of B.\nDefinition 40. Define\n$\\uparrow_{\\mathfrak{A}} C := \\bigcup_{a\u2208C} \\uparrow_{\\mathfrak{A}} a$\n$C\\uparrow_{(A,B)} D := (\\uparrow_{\\mathfrak{A}} C) \u2229 (\\uparrow_{\\mathfrak{B}} D)$\n$C\\sqcup_{(A,B)} D := min(C\\uparrow_{(A,B)} D)$\n$\\sqcup_{\\mathfrak{A}} C := C \\sqcup_{\\mathfrak{A}} C$.\nProposition 41. $C\\uparrow_{(A,B)} D = \\bigcup_{a\u2208C,b\u2208D}[a\\uparrow_{(A,B)} b]$.\nProof.\n$C\\uparrow_{(A,B)} D = (\\uparrow_{\\mathfrak{A}} C) \u2229 (\\uparrow_{\\mathfrak{B}} D)$\n$= (\\bigcup_{a\u2208C} \\uparrow_{\\mathfrak{A}} a) \u2229 (\\bigcup_{b\u2208D} \\uparrow_{\\mathfrak{B}} b)$\n$= \\bigcup_{a\u2208C} \\bigcup_{b\u2208D} [(\u2191U a) \u2229 (\u2191S b)]$\n$= \\bigcup_{a\u2208C} \\bigcup_{b\u2208D} [a\u2191(A,B) b].$\nFact 42. We have the following:\n$\\uparrow_{\\mathfrak{A}} {a} = \\uparrow_{\\mathfrak{A}} a$.\n$C\u2286\\downarrow_{\\mathfrak{A}}s \u21d4 s\u2208\\uparrow C$.\n$C = \\downarrow_{\\mathfrak{A}} s \u21d2 s\u2208 \\sqcup_{\\mathfrak{A}} C$.\n$S\u2208 C\\uparrow D \u21d2 C\u222aD\u2286\\downarrow_{\\mathfrak{A}}s.$"}, {"title": "12. CONCLUSION", "content": "This paper introduced algebraic anti-unification in the general setting of general algebra thus com-plementing the purely syntactic theory of anti-unification from the literature as initiated in the seminal works of Reynolds (1970) and Plotkin (1970).\nA major line of future research is to make progress towards the following fundamental problem:\nProblem 44. Given two L-algebras A and B, what is the generalization type of (A, B)? For what kind of algebras is the problem decidable? In those cases where it is decidable, provide an (efficient) algorithm.\nThe framework of this paper is unilingual in the sense that the underlying languages of the in-volved algebras are the same. This is common practice in general algebra. However, one can easily imagine practical scenarios in theoretical computer science and artificial intelligence, where different underlying languages are desired. A major line of future theoretical research therefore is to generalize the notions and results of this paper from a unilingual to a bilingual setting where the underlying languages La and Ly of A and B may differ. One possibility is to use the well-known notion of interpretability of one theory into another (see e.g. Hinman, 2005, \u00a72.6) (recall that an algebra is a structure in the logical sense without relations other than equality).\nFrom a practical point of view, the main line of future research is to study computability and complexity issues. Recall that in \u00a78, we have shown that in finite unary algebras (aka semiautomata), minimally general generalizations can be computed using standard techniques from the theory of finite automata. Moreover, in \u00a710, we have shown that more generally, in any finite algebra, we can use tree automata to compute minimally general k-generalizations, for any k. This is closely related to finite model theory (see e.g. Ebbinghaus & Flum, 1999; Libkin, 2012). However, since in practice we often encounter finitely representable infinite structures (Blumensath & Gr\u00e4del, 2000, 2004), obtaining analous computability results is mandatory.\nAnother important line of applied future research is to develop efficient algorithms for the compu-tation of minimally general generalizations in finite and infinite structures and to provide implemen-tations which can be used in practice."}]}