{"title": "Automated conjecturing in mathematics with\nTxGraffiti", "authors": ["Randy Davila"], "abstract": "TxGraffiti is a data-driven, heuristic-based computer program developed to auto-\nmate the process of generating conjectures across various mathematical domains.\nSince its creation in 2017, TxGraffiti has contributed to numerous mathematical\npublications, particularly in graph theory. In this paper, we present the design\nand core principles of TxGraffiti, including its roots in the original Graffiti pro-\ngram, which pioneered the automation of mathematical conjecturing. We describe\nthe data collection process, the generation of plausible conjectures, and methods\nsuch as the Dalmatian heuristic for filtering out redundant or transitive conjec-\ntures. Additionally, we highlight its contributions to the mathematical literature\nand introduce a new web-based interface that allows users to explore conjec-\ntures interactively. While we focus on graph theory, the techniques demonstrated\nextend to other areas of mathematics.", "sections": [{"title": "1 Introduction", "content": "In 1948, Turing proposed that intelligent machines could play a significant role in\nmathematical research, particularly in tasks that require substantial intelligence but\ninvolve minimal interaction with the external world [1]. This vision laid the foundation\nfor early developments in computer-assisted mathematics. One of the first notable\nefforts in this area was Newell and Simon's Logic Theorist, developed in the 1950s."}, {"title": "2 Fajtlowicz's Graffiti", "content": "As mentioned in the previous section, Fajtlowicz's Graffiti program was the first sys-\ntem to circumvent the problem of filtering through many instances of mathematical\nconjectures. Indeed, Graffiti was able to generate conjectures that resulted in pub-\nlished mathematical results, particularly in graph theory (see [11-36]), as well as in\nmathematical chemistry (see [37-44]). Central to its functionality is the Dalmatian\nheuristic (see [5-10]), designed to produce conjectures about relationships between\nreal-number invariants associated with mathematical objects, such as graphs, matrices,\n$\\alpha\\leq f(invariants)$,\nwhere a might represent a chosen target invariant to conjecture on and where\nf (invariants) could be any arithmetic combination of invariants, such as sums,\nproducts, logs, square roots, or powers.\nThe Dalmatian heuristic applies two crucial tests to determine whether a proposed\nconjecture should be added to the list of conjectures:\nTruth Test: The conjectured inequality must hold for all objects currently in the\ndatabase. For example, if the conjecture proposes an upper bound for an invariant\nacross a set of graphs, it must hold for every graph in the database.\nSignificance Test: The conjecture must provide a better bound for at least one\nobject than any previously proposed conjecture. This ensures that each conjecture\nadded by Graffiti is meaningful, offering new insight by improving upon earlier\nbounds."}, {"title": "2.1 Bingo!", "content": "Graffiti operates by maintaining a database of objects and functions, where each\nobject is associated with a set of numerical invariants. When tasked with searching\nfor upper bounds on a particular invariant, such as a, Graffiti must compute both the\nvalue of a and the values of any functions of other invariants used to form potential\nupper bounds (or lower bounds) for a. This process is carried out for each object in\nthe database."}, {"title": "2.2 Graffiti.pc, Counterexamples, and Data Quality", "content": "Graffiti.pc is another automated conjecturing program developed by DeLaVi\u00f1a under\nthe supervision of Fajtlowicz during PhD studies. Like its predecessor, Graffiti.pc also\nimplements the Dalmatian heuristic and primarily focuses on graph theory conjectures.\nHowever, while Graffiti was written in Pascal and operated on a dataset of a few\nhundred objects, Graffiti.pc was developed in C++ and worked with a significantly\nlarger dataset comprising millions of graphs. This expansion in scope sometimes\nrequired clusters of nodes to compute conjectures efficiently. Though Graffiti.pc was\nprimarily designed for educational purposes, it also made notable contributions to\ndomination theory in graph theory, as evidenced in works like [46-48]. A list of open\nand resolved conjectures of Graffiti.pc can be found on this website."}, {"title": "3 Other Notable Systems", "content": "Automated conjecturing systems have developed independently over the years, each\ncontributing to the growing field of computer-assisted mathematical discovery in\nunique ways. One of the earliest systems, Lenat's AM [49\u201351], developed in the\nlate 1970s, focused on exploring elementary mathematical concepts. Using heuris-\ntic search techniques, AM generated and refined concepts based on predefined rules,\nscoring them for interestingness. Although AM did not produce significant mathemat-\nical results like some later systems, it set a precedent for AI's role in exploring new\nmathematical concepts and relationships, particularly in theory formation. While AM\nrequired human intervention and was limited by its knowledge base, it demonstrated\nthe potential of AI in mathematical discovery.\nAnother early system, Epstein's GT, or Graph Theorist, was developed in the\n1980s and focused specifically on graph theory [52]. GT used symbolic computation\nto construct examples of graphs and explore their properties, generating conjectures\nand proofs. It was one of the first systems dedicated to discovering new conjectures\nin graph theory and played a key role in advancing the use of AI in this domain.\nHowever, Graffiti was the first to lead to publishable results in mathematics.\nColton's HR program [53-55], developed in the late 1990s, was a more general-\npurpose system for concept formation and conjecture generation across multiple\nmathematical fields, including algebra, graph theory, and number theory. HR applied\nproduction rules to foundational domain information the user provides, such as axioms\nor objects (e.g., Cayley tables in group theory or divisors in number theory), to form\nnew concepts. The system evaluated these concepts for interestingness and gener-\nated conjectures by identifying common properties between concepts derived through\ndifferent methods."}, {"title": "4 TxGraffiti Methods", "content": "In this section, we explain the principles behind the conjecturing process of TxGraffiti,\na program written in Python, using a specific example based on graph-theoretic data,\nwhich is accompanied by companion code hosted on this GitHub repository. To begin,\nsee Figure 1, which illustrates a set of 9 connected graphs that serve as the foundation"}, {"title": "4.1 Generating Inequalities", "content": "Once a tabular dataset of precomputed numerical invariants and boolean properties\nfor mathematical objects is available, the next step is to identify valid inequalities\non the data. In this context, we aim to generate conjectures by selecting a target\ninvariant, such as the independence number a, and formulating upper and lower\nbounds. For clarity with what follows, we remind the reader of the standard notation\n[N] = {1, 2, . . ., N} used throughout this section.\nComputing Upper Bounds"}, {"title": "4.2 Limitations in the Forms of Inequalities Generated by\nTxGraffiti", "content": "The inequalities generated by TxGraffiti are currently constrained by the structure of\nthe linear optimization models used to compute upper and lower bounds on the target\ninvariants. For example, when generating upper bounds on the independence number\na of a graph, we use the following optimization model:\n$\\begin{aligned}\\operatorname{minimize}_{m,b} & \\sum_{i=1}^{N}(m \\cdot f(\\text{invariant})_{i} + b - a_{i}) \\\\\\text{subject to } & a_{i} \\leq m \\cdot f(\\text{invariant})_{i} + b, \\quad \\forall i \\in [N] \\text{ if boolean\\_property},\\end{aligned}$\nwhere f(invariant); represents a numerical column in the dataset for the i-th object,\nprovided the object satisfies the boolean property boolean_property.\nThis setup yields the upper bounds of the form:\na\u2264 m. f(invariant) + b,\nwhere f (invariant) could represent any precomputed combination of invariants, such as\n\u03b7-\u03bc (the number of vertices minus the matching number). In this way, TxGraffiti can\nhandle more complex expressions precomputed and stored as columns in the dataset.\nHowever, the limitation lies in the current optimization models only considering one\ncolumn (or invariant) at a time in their formulation.\nExtending the Model to Handle Multiple Invariants Simultaneously\nWhile creating new columns in the dataset representing combinations of invariants\nis possible, the current approach does not inherently capture interactions between\nmultiple invariants in a single optimization step. We could extend the model to consider\nmultiple invariants simultaneously rather than relying on precomputed combinations\nto address this. The optimization model would take the following form:\n$\\begin{aligned}\\operatorname{minimize}_{m_1, m_2,b} & \\sum_{i=1}^{N}(m_1 \\cdot f(\\text{invariant})_{i} + m_2 \\cdot g(\\text{invariant})_{i} + b - a_{i}) \\\\\\text{subject to } & a_{i} \\leq m_1 \\cdot f(\\text{invariant})_{i} + m_2 \\cdot g(\\text{invariant})_{i} + b, \\quad \\forall i \\in [N] \\text{ if boolean\\_property},\\end{aligned}$\nwhere f(invariant); and g(invariant); represent different numerical columns in the\ndataset for the i-th object.\nSolving model 4 would result in a proposed inequality of the form:\nai \u2264 m\u2081f(invariant); + m2g(invariant); + b,\nwhich allows for richer relationships between invariants to be captured. For example,\na bound could simultaneously depend on the number of vertices n and the matching\nnumber \u03bc, leading to potentially deeper insights. This idea can easily be extended to\ninclude three or more invariants.\nBy allowing multiple invariants to be handled within the same optimization\nmodel, TxGraffiti could generate more expressive and complex inequalities, revealing\ninteractions between graph invariants that might go unnoticed. While precomputing\ncombinations of invariants remains a useful strategy, this extended approach would\nenable a more flexible exploration of mathematical relationships without explicitly\nneeding to compute every possible combination beforehand."}, {"title": "4.3 Sorting Conjectures", "content": "Even with a relatively small number of numerical and boolean properties in our\ndataset, TxGraffiti generates 18 proposed upper-bound conjectures on the indepen-\ndence number. As additional numerical and boolean columns are included, this number\ncould easily grow into the hundreds. Furthermore, these conjectures are presented\nwithout any indication of conjecture quality, raising the question: which conjectures\nare more interesting or valuable?\nIn earlier versions of TxGraffiti (2017\u20132019), the program prioritized simplicity by\nsorting conjectures based solely on the touch number\u2014the number of instances in the\ndataset where the proposed inequality held with equality. Conjectures with a touch\nnumber of zero were automatically discarded, and the top min{len(conjectures), k}\n(where k was an integer chosen by the user) conjectures were presented to the user.\nDespite the straightforward nature of this method, it proved highly effective, resulting\nin many published results during that period.\nThe rationale behind this approach is that a higher touch number signifies a\nstronger and tighter relationship between the graph invariants, making the conjec-\nture more valuable. Conjectures with higher touch numbers typically provide more\ninformative and precise bounds. To continue emphasizing conjecture quality, TxGraf-\nfiti still sorts conjectures in non-increasing order by touch number, ensuring that the\ntightest bounds appear first, helping users prioritize the most promising conjectures.\nHowever, to improve the quality of the results, we have recently added more sophis-\nticated filtering mechanisms, described in the next section. These filtering techniques\nfurther refine the set of conjectures by eliminating redundancies and improving the\noverall quality of the conjectures presented."}, {"title": "4.4 The Static-Dalmatian Heuristic", "content": "After sorting the conjectures by their touch numbers, we may still be left with a sub-\nstantial list of conjectured upper bounds on a - in some cases, hundreds of conjectures.\nFurthermore, many of these conjectures are redundant, as they can be derived by\ntransitivity from conjectures higher in the list. To address this redundancy, we adapt\nFajtlowicz's Dalmatian heuristic for conjecture acceptance into a new method, which\nwe refer to as the static-Dalmatian heuristic.\nFajtlowicz's original Dalmatian heuristic was dynamic, continuously refining the\nconjecture set by interacting with new data or revisiting previously generated con-\njectures to ensure only the most valuable conjectures were accepted. In contrast, the\nstatic-Dalmatian heuristic operates on a fixed, finite list of conjectures that have\nalready been sorted based on touch number. The key distinction lies in this static\nproperty static-Dalmatian works on a snapshot of conjectures generated from a sin-\ngle dataset without further refinement from new data, making it more appropriate for\na precomputed list of conjectures.\nThe static-Dalmatian heuristic filters the sorted conjecture list (sorted by touch\nnumber in non-increasing order) to remove redundant conjectures that follow transi-\ntivity from others. The goal is to return a smaller, more meaningful set of conjectures\nrepresenting the most informative and independent bounds based on their sharp\ninstances.\nGiven a dataset and a list of conjectures sorted by touch number, the static-\nDalmatian algorithm proceeds as follows:\n1. Initialize: Start with the conjecture that has the highest touch number (the first\nconjecture in the sorted list) and keep track of the objects where this conjecture\nholds with equality (i.e., the sharp graphs).\n2. Iterate Over Remaining Conjectures: For each subsequent conjecture in the\nsorted list, determine the set of sharp objects for that conjecture.\n\u2022 If the set of sharp objects for the current conjecture matches the sharp objects of\nany previously selected conjecture, the conjecture is added to the list of selected\nconjectures.\n\u2022 If the current conjecture introduces new sharp objects (i.e., objects where the\ninequality holds with equality but was not sharp for any previous conjecture),\nthe conjecture is added to the list, and the set of sharp objects is updated to\ninclude the new sharp instances.\n3. Return the Filtered List: The resulting list contains only the most indepen-\ndent conjectures, eliminating those that follow by transitivity or redundancy from\nhigher-ranked conjectures.\nThe list of conjectures passed into the static-Dalmatian function must be sorted in\nnon-increasing order by touch number. This is because conjectures with higher touch\nnumbers are more informative, holding with equality on a maximum number of objects\nin the dataset. By starting with the conjecture that has the highest touch number, we\nmaximize the initial set of sharp graphs (i.e., objects for which the conjecture holds\nwith equality). Subsequent conjectures are then evaluated relative to this initial set,"}, {"title": "4.5 Full TxGraffiti Conjecture Generation", "content": "To generate conjectures both upper and lower bounds on multiple targets (not just\na), we use the write_on_the_wall function, which encapsulates all of the conjecturing\nprocesses of TxGraffiti into a single algorithm; see Listing 4."}, {"title": "4.6 Evaluating and Refining Conjectures in T\u00e6Graffiti", "content": "The final conjectures generated by TxGraffiti aim not merely to discover new theorems\nbut rather to identify interesting and novel mathematical relationships. Even when"}, {"title": "4.6.1 Identifying Equality from Upper and Lower Bounds", "content": "One important feature of the conjectures generated by TxGraffiti is the ability to\ndeduce equalities from computed upper and lower bounds. When both an upper and a\nlower bound coincide, the conjecture implies an equation rather than just an inequality.\nFor example, consider the following conjectures generated by the write_on_the_wall\nfunction:\nIf G is connected and bipartite, then a(G) = \u03b7 \u2013 \u03bc(G),\nwhere a(G) is the independence number and \u00b5(G) is the matching number. This\nresult is a direct consequence of K\u0151nig's theorem, which asserts that in any bipartite\ngraph, the size of the maximum matching is equal to the size of the minimum vertex\ncover [60]. A corollary of this theorem states that the independence number is precisely\nequal to the number of vertices minus the matching number for bipartite graphs. This\nhighlights how conjectures generated by TxGraffiti can recover well-established results\nin certain cases, thereby validating the conjecturing process's correctness and offering\nadditional insight into known theorems."}, {"title": "4.6.2 Pepper's Rule", "content": "Once a list of conjectures is presented to the user, the next crucial step is analyzing and\nevaluating them. A key approach, drawn from our experience, is what we call Pepper's\nRule. Named after mathematician Ryan Pepper who has likely disproven more con-\njectures from Graffiti, Graffiti.pc, and TxGraffiti than anyone else this rule advises"}, {"title": "4.6.3 TicTac", "content": "Sometimes, a conjecture might be incrementally refined through a process that gen-\nerates counterexamples, leading to small adjustments in the conjecture's bounds. For\nexample, consider a conjecture of the form a \u2264 8 +4, where a and d are graph invari-\nants. If a counterexample is found, the conjecturing system might revise the conjecture\nto a \u2264 8 + 5, which could again be disproven, leading to yet another refinement:\n\u03b1 < \u03b4 + 6. This iterative process can continue indefinitely without arriving at a mean-\ningful or insightful conclusion, as the conjecture is being shifted by a constant amount\neach time a counterexample is found.\nTo avoid this scenario, it is important to search for a single counterexample and\nconduct a more exhaustive search demonstrating the existence of infinitely many coun-\nterexamples. Specifically, instead of revising the conjecture incrementally, we aim to\nprove that for any constant C, there exists a counterexample showing that a > d + C.\nSimilarly, for conjectures involving multiplicative relationships, such as a \u2264 2\u03b4, \u03b1 \u2264 3\u03b4,\nand so on, the goal is to show that a > Cd for any constant C."}, {"title": "4.6.4 Red Burton", "content": "Even when a conjecture is disproven, it does not render the process a failure. This is\nwhere Fajtlowicz's Red Burton heuristic comes into play. After finding a counterex-\nample to a conjecture, the next logical step is to identify the smallest counterexample\nand then prove that it is indeed minimal.\nThe Red Burton heuristic serves two important purposes: First, finding the smallest\ncounterexample provides significant mathematical insight, as these minimal examples\noften reveal the fundamental structural properties of the studied objects. Second, the\nsmallest counterexample is crucial because adding it to the dataset requires recom-\nputing all the graph invariants and properties, many of which are NP-complete\nproblems and computationally expensive. By ensuring that the smallest counterex-\nample is added, we minimize the computational burden associated with this process,\nmaking it more efficient to update the dataset.\nOnce the smallest counterexample is added to the dataset, it ensures that TxGraf-\nfiti will no longer generate the disproven conjecture in future iterations. Since all\nconjectures produced by TxGraffiti are valid on the data they are derived, the former\nconjecture will no longer appear. This approach prevents redundant conjectures and\noptimizes the system's computational efficiency by focusing on minimal examples.\nThus, the Red Burton heuristic transforms a failed conjecture into an opportu-\nnity for deeper understanding and ensures that the system's learning process remains\ncomputationally manageable. By incorporating the smallest counterexamples into the\ndataset, TxGraffiti becomes more robust and adaptive, producing stronger and more\nreliable conjectures without unnecessary computational overhead."}, {"title": "4.7 Code and Reproducibility", "content": "For a customized version of TxGraffiti designed specifically for conjecturing in the\nmathematical field of graph theory, visit the official TxGraffiti interactive website. For\na collection of concise Jupyter notebooks that implement the ideas behind TxGraffiti\non different datasets (beyond graph theory), see this papers corresponding GitHub\nrepository."}, {"title": "5 Publications", "content": "This section presents some results stimulated by conjectures of TxGraffiti. More specif-\nically, we highlight the following results inspired by conjectures of TxGraffiti listed\nin Table 2. Of the results in Table 2, we now focus on the result of the independence\nnumber and matching number of regular graphs Conjecture 9 in Listing 6."}, {"title": "A Number Theory Conjectures", "content": "Definitions\n\u2022 Prime: A positive integer n is a prime number if it has exactly two distinct positive\ndivisors: 1 and itself.\n\u2022 Sum of digits: The sum of digits of a positive integer n", "divisors": "The number of divisors of a positive integer n", "sum": "A positive integer n is a digit power sum if the sum of its digits\nraised to the power of the number of digits equals n.\n\u2022 Palindrome: A positive integer n is a palindrome if it reads the same backward as\nforward.\n\u2022 Goldbach number: A positive integer n is a Goldbach number if it can be\nexpressed as the sum of two prime numbers.\nConjectures\nConjecture A1. For any positive integer n, if n is prime, then the sum of digits of\nn divided by the number of divisors of n is at most one-half the square of the sum of\ndigits of n, with equality on at least 25 integers.\nConjecture A2. For any positive integer n, the sum of digits of n is at least one-\ntenth the square of the sum of its digits plus nine-tenths, with equality on at least 13\nintegers.\nConjecture A3. For any positive integer n, the sum of digits of n is at most one-tenth\nthe value of n plus eighty-one tenths, with equality on at least 10 integers.\nConjecture A4. For any positive integer n, if n is even, then the sum of digits of n\nis at most one-tenth the value of n plus thirty-six fifths, with equality on at least 10\nintegers.\nConjecture A5. For any positive integer n, if n is a digit power sum, then the sum\nof digits of n is at most the value of n, with equality on at least 9 integers.\nConjecture A6. For any positive integer n, if n is a palindrome, then the square of\nits value is at most one hundred twenty-one fourths the square of the sum of its digits,\nwith equality on at least 9 integers.\nConjecture A7. For any positive integer n, if n is a Goldbach number and the sum\nof its digits is a Fibonacci number, then the sum of digits of n divided by the number\nof divisors of n is at most one-fourth the square of the sum of digits of n, with equality\non at least 7 integers.\nConjecture A8. For any positive integer n, if the sum of the factorials of its digits\nis a prime number, then the sum of digits of n is at most one-fifth the square of the\nsum of its digits plus six-fifths, with equality on at least 6 integers.\nConjecture A9. For any positive integer n, if n is a sum of digits prime and n is a\nHarshad number, then the sum of digits of n is at most one-eighth the square of the\nsum of its digits plus fifteen-eighths, with equality on at least 6 integers.\nConjecture A10. For any positive integer n, if n is prime, then the sum of digits of\nn is at most one-ninth the sum of digits of n divided by the number of divisors of n\nplus forty-ninths, with equality on at least 6 integers.\nConjecture A11. For any positive integer n, if n is prime and n is a sum of digits\nprime, then the sum of digits of n divided by the number of divisors of n is at least\nnine times the sum of digits of n minus seventy-seven halves, with equality on at least\n6 integers.\nConjecture A12. For any positive integer n, if n is prime and the sum of its digits\nis a Fibonacci number, then the sum of digits of n divided by the number of divisors\nof n is at least thirteen halves the sum of digits of n minus twenty, with equality on at\nleast 6 integers.\nConjecture A13. For any positive integer n, if n has all prime digits, then the sum\nof digits of n is at most one-tenth the value of n plus sixty-three tenths, with equality\non at least 5 integers.\nConjecture A14. For any positive integer n, if n is even and n has all prime digits,\nthen the sum of digits of n is at most one-tenth the value of n plus nine-fifths, with\nequality on at least 5 integers.\nConjecture A15. For any positive integer n, if n is prime, then the sum of digits\nof n is at least one-tenth the value of n plus nine-tenths, with equality on at least 5\nintegers.\nConjecture A16. For any positive integer n, if the sum of its digits is a Fibonacci\nnumber and n is a Harshad number, then the sum of digits of n is at least one-ninth\nthe square of the sum of its digits plus eight-ninths, with equality on at least 5 integers.\nConjecture A17. For any positive integer n, if the sum of its digits is a Fibonacci\nnumber and n is a factorial digit sum prime, then the sum of digits of n is at least\none-fourth the square of the sum of its digits plus three-fourths, with equality on at\nleast 5 integers.\nConjecture A18. For any positive integer n, if n is prime and n is a factorial digit\nsum prime, then the sum of digits of n is at most one-sixth the square of the sum of\nits digits plus four-thirds, with equality on at least 4 integers.\nConjecture A19. For any positive integer n, if n is prime and n is a factorial digit\nsum prime, then the sum of digits of n is at most one-third the sum of digits of n\ndivided by the number of divisors of n plus four-thirds, with equality on at least 4\nintegers.\nConjecture A20. For any positive integer n, if n is a sum of digits prime, then\nthe sum of digits of n is at least one-tenth the value of n, with equality on at least 4\nintegers.\nConjecture A21. For any positive integer n, if the sum of the factorials of its digits\nis a prime number, then the sum of digits of n is at least one-fifth the square of the\nsum of its digits plus four-fifths, with equality on at least 4 integers.\nConjecture A22. For any positive integer n, if n is a sum of digits prime and n has\nall prime digits, then the sum of digits of n is at least one-ninth the square of the sum\nof its digits plus fourteen-ninths, with equality on at least 4 integers.\nConjecture A23. For any positive integer n, if the sum of its digits is a Fibonacci\nnumber and n is a circular prime, then the sum of digits of n is at least one-tenth the\nsquare of the sum of its digits plus eight-fifths, with equality on at least 4 integers.\nConjecture A24. For any positive integer n, if n is a sum of digits prime, has all\nprime digits, and the sum of its digits is a Fibonacci number, then the sum of digits\nof n is at least one-seventh the square of the sum of its digits plus ten-sevenths, with\nequality on at least 4 integers.\nConjecture A25. For any positive integer n, if n is a circular prime, then the sum\nof digits of n is at least one-ninth the sum of digits of n divided by the number of\ndivisors of n plus sixteen-ninths, with equality on at least 4 integers.\nConjecture A26. For any positive integer n, if the sum of its digits is a Fibonacci\nnumber and n is a circular prime, then the sum of digits of n is at least one-fifth the\nsum of digits of n divided by the number of divisors of n plus eight-fifths, with equality\non at least 4 integers.\nConjecture A27. For any positive integer n, if n is prime, a sum of digits prime,\nand the sum of its digits is a Fibonacci number, then the sum of digits of n divided by\nthe number of divisors of n is at least four times the sum of digits of n minus fifteen\nhalves, with equality on at least 4 integers.\nConjecture A28. For any positive integer n, if n has all prime digits, then the sum\nof digits of n is at most twice the number of divisors of n plus six, with equality on at\nleast 3 integers.\nConjecture A29. For any positive integer n, if the sum of the factorials of its digits\nis a prime number, then the sum of digits of n is at most negative one-sixth the number\nof divisors of n plus thirteen-thirds, with equality on at least 3 integers.\nConjecture A30. For any positive integer n, if n is even and a sum of digits prime,\nthen the sum of digits of n is at most twice the number of divisors of n plus five, with\nequality on at least 3 integers.\nConjecture A31. For any positive integer n, if n is a Harshad number, then the sum\nof digits of n is at most four-sevenths the sum of digits of n divided by the number of\ndivisors of n plus thirty-six sevenths, with equality on at least 3 integers.\nConjecture A32. For any positive integer n, if n is even and a Harshad number,\nthen the sum of digits of n is at most four-fifths the sum of digits of n divided by the\nnumber of divisors of n plus eighteen-fifths, with equality on at least 3 integers.\nConjecture A33. For any positive integer n, if n is prime, a sum of digits prime,\nand has all prime digits, then the sum of digits of n is at most one-fourth the sum of\ndigits of n divided by the number of divisors of n plus fifteen-eighths, with equality on\nat least 3 integers.\nConjecture A34. For any positive integer n, if n is a digit power sum, then the sum\nof digits of n is at least twice the number of divisors of n minus two, with equality on\nat least 3 integers.\nConjecture A35. For any positive integer n, if n is even and a palindrome, then\nthe sum of digits of n is at least twice the number of divisors of n minus four, with\nequality on at least 3 integers.\nConjecture A36. For any positive integer n, if n is a palindrome and the sum of its\ndigits is a Fibonacci number, then the sum of digits of n is at least three-halves the\nnumber of divisors of n minus one, with equality on at least 3 integers.\nConjecture A37. For any positive integer n, if n has all prime digits, then the sum\nof digits of n is at least one-sixth the sum of digits of n divided by the number of\ndivisors of n plus five-thirds, with equality on at least 3 integers.\nConjecture A38. For any positive integer n, if n is prime and a palindrome, then\nthe sum of digits of n is at least two-ninths the sum of digits of n divided by the number\nof divisors of n plus fourteen-ninths, with equality on at least 3 integers.\nConjecture A39. For any positive integer n, if the sum of its digits is a Fibonacci\nnumber and n is a factorial digit sum prime, then the sum of digits of n is at least four\nseven"}]}