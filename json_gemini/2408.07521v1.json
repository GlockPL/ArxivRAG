{"title": "Optimising Dynamic Traffic Distribution for Urban Networks with Answer Set Programming", "authors": ["Matteo Cardellini", "Carmine Dodaro", "Marco Maratea", "Mauro Vallati"], "abstract": "Answer Set Programming (ASP) has demonstrated its potential as an effective tool for concisely\nrepresenting and reasoning about real-world problems. In this paper, we present an application\nin which ASP has been successfully used in the context of dynamic traffic distribution for urban\nnetworks, within a more general framework devised for solving such a real-world problem. In\nparticular, ASP has been employed for the computation of the \"optimal\" routes for all the\nvehicles in the network. We also provide an empirical analysis of the performance of the whole\nframework, and of its part in which ASP is employed, on two European urban areas, which shows\nthe viability of the framework and the contribution ASP can give.", "sections": [{"title": "1 Introduction", "content": "Avoiding congestion and controlling traffic in urban scenarios is becoming nowadays of\nutmost importance due to the rapid growth of our cities' population and vehicles. The\neffective control of urban traffic as a mean to mitigate congestion can be beneficial in\nan economic, environmental and health way. At the end of the 21st century, the world\npopulation is expected to increase to 10.9 Billion, adding well over 3 Billion people\nto the current population (Max Roser and Ortiz-Ospina 2013). This massive growth,\nwhich will directly translate in more vehicles roaming the streets of our cities, demands\nimprovements in the transport infrastructure and a better utilisation of our roads for\nthe purpose of avoiding congesting the network. Traffic jams have a negative impact on\nsafety and fuel consumption, which directly translates to a higher cost for drivers and\nhealth issues for residents near highly trafficked roads, caused by bad air quality and noise\npollution (Van Mierlo et al. 2004). Artificial Intelligence techniques, based on automated\nplanning, have already been employed for optimising traffic flow, and more general in\ntransportation (see, e.g., (Cenamor et al. 2014; Chrpa et al. 2016; Vallati et al. 2016;\nRam\u00edrez et al. 2018; Cardellini et al. 2021; El Kouaiti et al. 2024)), with some benefits,\nbut they fail to scale in the presence of large number of vehicles.\nIn this paper, we present an application in which Answer Set Programming (ASP)\n(Niemel\u00e4 1999; Baral 2003; Brewka et al. 2011; Gelfond and Lifschitz 1991) has been\nsuccessfully used in the context of dynamic traffic distribution for urban networks, within\na more general framework devised for solving such a real-world problem. The framework,\nwhich allows to efficiently optimise and simulate traffic flow in a large roads' network with\nhundreds of vehicles, is composed of four phases: network analysis, domain-independent\nsearch, route optimisation, and mobility simulation. Within the framework, ASP is em-\nployed for representing and reasoning about the optimisation of the flow of traffic inside\na road network by finding the best combination (schedule) of routes for all the vehicles\nin the network. We have performed an analysis on real-world traffic data from two Euro-\npean urban areas in UK and Italy, utilising the state-of-the-art Urban Mobility Simulator\nSUMO (L\u00f3pez et al. 2018) to keep track of the state of the network: the analysis tested the\ncorrectness of the solution, and proved the efficiency and capabilities of the presented\nsolution to reduce the metrics considered, sometimes significantly. Moreover, it shows\nthe contribution ASP gives in terms of performance and metrics: all instances of Milton\nKeynes and Bologna up to 600 vehicles inside the network are solved, optimally, in a\nshort time.\nThe paper is structured as follows. Section 2 presents preliminaries about ASP. Then,\nSection 3 introduces the problem and the solution framework. The last two phases of\nthe framework, i.e., the optimisation via ASP and the mobility simulator, are presented\nin Section 4 and Section 5, respectively, together with the experiments we performed on\nreal data. The paper ends in Section 6 and 7 by discussing related work and by drawing\nsome conclusions, respectively."}, {"title": "2 Background on ASP", "content": "Answer Set Programming (ASP) is a programming paradigm developed in the field of non-\nmonotonic reasoning and logic programming. In this section, we overview the language\nof ASP. More detailed descriptions and a more formal account of ASP, including the\nfeatures of the language employed in this paper, can be found in (Brewka et al. 2011;\nCalimeri et al. 2020). Hereafter, we assume the reader is familiar with logic programming\nconventions.\nSyntax. Variables are strings starting with an uppercase letter, and constants are non-\nnegative integers or strings starting with lowercase letters. A term is either a variable or\na constant. A standard atom is an expression $p(t_1, ..., t_n)$, where $p$ is a predicate of arity\nn and $t_1,...,t_n$ are terms. An atom $p(t_1,...,t_n)$ is ground if $t_1,...,t_n$ are constants.\nA ground set is a set of pairs of the form $(consts: conj)$, where $consts$ is a list of\nconstants and $conj$ is a conjunction of ground standard atoms. A symbolic set is a set\nspecified syntactically as $\\{Terms_1 : Conj_1;\u00b7\u00b7\u00b7; Term_t : Conj_t\\}$, where $t > 0$, and for\nall $i \\in [1,t]$, each $Terms_i$ is a list of terms such that $|Terms_i| = k > 0$, and each $Conj_i$\nis a conjunction of standard atoms. A set term is either a symbolic set or a ground set.\nIntuitively, a set term $\\{X: a(X, c), p(X); Y : b(Y,m)\\}$ stands for the union of two sets:\nthe first one contains the $X$-values making the conjunction $a(X, c), p(X)$ true, and the\nsecond one contains the $Y$-values making the conjunction $b(Y,m)$ true. An aggregate\nfunction is of the form $f(S)$, where $S$ is a set term, and $f \\in \\{\\#count,\\#sum\\}$ is an\naggregate function symbol. An aggregate atom is of the form $f(S) < T$, where $f(S)$ is an\naggregate function, $\\\u4eba \\in \\{<, \\le, >, \\ge,\\neq, =\\}$ is an operator, and $T$ is a term called guard.\nAn aggregate atom $f(S) < T$ is ground if $T$ is a constant and $S$ is a ground set. An atom\nis either a standard atom or an aggregate atom. A ruler has the following form:\n$a_1 | ... | a_n :- b_1,...,b_k, not b_{k+1},...,not b_m$.\nwhere $a_1,...,a_n$ are standard atoms, $b_1,...,b_k$ are atoms, $b_{k+1},...,b_m$ are standard\natoms, and $n,k,m \\ge 0$. A literal is either a standard atom $a$ or its negation $not a$.\nThe disjunction $a_1 | ... | a_n$ is the head of $r$, while the conjunction $b_1, ..., b_k, not b_{k+1}$,\n..., not $b_m$ is its body. Rules with empty body and with only one atom in the head\n(i.e., $n = 1$) are called facts. Rules with empty head are called constraints. A variable\nthat appears uniquely in set terms of a ruler is said to be local in $r$, otherwise it is a\nglobal variable of $r$. An ASP program is a set of safe rules, where a ruler is safe if the\nfollowing conditions hold: (i) for each global variable $X$ of $r$ there is a positive standard\natom $l$ in the body of $r$ such that $X$ appears in $l$, and (ii) each local variable of $r\nappearing in a symbolic set $\\{Terms: Conj\\}$ also appears in a positive atom in $Conj$. A\nweak constraint (Buccafurri et al. 2000) $w$ is of the form:\n$:~ b_1, ..., b_k, not b_{k+1},..., not b_m. [w@l]$\nwhere $w$ and $l$ are the weight and level of $w$, respectively. (Intuitively, $[w@l]$ is read as\n\"weight w at level l\u201d, where the weight is the \u201ccost\u201d of violating the condition in the body\nof $w$, whereas levels can be specified for defining a priority among preference criteria). An\nASP program with weak constraints is $\\Pi = \\langle P, W\\rangle$, where $P$ is a program and $W$ is a set\nof weak constraints. A standard atom, a literal, a rule, a program or a weak constraint\nis ground if no variables appear in it.\nSemantics. Let $P$ be an ASP program. The Herbrand universe $U_P$ and the Herbrand\nbase $B_P$ of $P$ are defined as usual. The ground instantiation $G_P$ of $P$ is the set of all\nthe ground instances of rules of $P$ that can be obtained by substituting variables with\nconstants from $U_P$. An interpretation $I$ for $P$ is a subset $I$ of $B_P$. A ground literal $l$\n(resp., $not l$) is true w.r.t. $I$ if $l \\in I$ (resp., $l \\notin I$), and false (resp., true) otherwise.\nAn aggregate atom is true w.r.t. $I$ if the evaluation of its aggregate function (i.e., the\nresult of the application of $f$ on $S$) w.r.t. $I$ satisfies the guard; otherwise, it is false. A\nground rule $r$ is satisfied by $I$ if at least one atom in the head is true w.r.t. $I$ whenever\nall conjuncts of the body of $r$ are true w.r.t. $I$. A model is an interpretation that satisfies\nall rules of a program. Given a ground program $G_P$ and an interpretation $I$, the reduct"}, {"title": "3 Case Study and Proposed Solution Framework", "content": "In this section, we present our case study about dynamic traffic distribution for urban\nnetworks, and the solution framework we propose, in two separate subsections.\n3.1 Problem Description\nUrban traffic routing aims to mitigate traffic congestion by navigating the vehicles and\nrecommending less-congested routes, hence supporting a better use of the capacity of the\nurban network. Recent advances in connected autonomous vehicles (CAVs) technology\nprovide an opportunity for routing approaches to be increasingly practicable and to\nrevolutionise the field, as the communication capabilities of CAVs can allow roadside\nagents to collect real-time traffic information, and can support real-time communication\nbetween the vehicle and a centralised traffic control system (Shladover 2018; Vallati and\nChrpa 2018). A centralised approach aims to provide the optimal routes for each CAV\nfrom the perspective of the traffic management centre, with the clear benefit of having\na holistic vision of the controlled urban region. In other words, the centralised approach\nallows considering both the dynamic system optimal principle (Merchant and Nemhauser\n1978) and the dynamic user optimal principle (Friesz et al. 1989) when routing vehicles,\nand the trade-off between the two according to traffic conditions.\nIn this work, we consider a centralised scenario where a controller oversees the network\nin real time. The controller has knowledge of the network structure, that can possibly\nbe updated according to accidents or other unexpected events. While in operation, the\ncontroller is provided with the list of incoming vehicles (controlled), and the position of\nthe vehicles already navigating the network (hereinafter referred to as simulated). On the\nbasis of this information, the controller provides an optimised route for controlled vehi-\ncles, that aims at minimising overall congestion while considering the dynamic aspects\nof traffic.\nWe assume that vehicles entering the controlled region communicate to the controller\ntheir destination and their current path, via an existing Vehicular Ad-hoc Network\n(VANET) (Cucor 2021), and the controller assesses the network status in terms of ex-\npected or recorded congestion, and returns a route to the vehicle under the form of a\nsequence of links to follow (Shahi et al. 2020). The vehicle then follows the given path,\nand such path can be considered by the traffic controller for informing the routing of\nfuture incoming vehicles.\nIt is worth highlighting that for the sake of traffic distribution and route optimisation,\ntraffic signals are not explicitly modelled. This is established practice in the transporta-\ntion field (see, e.g., (Bliemer and Raadsen 2020; Batista et al. 2021)) for a number of\nreasons. First, traffic signals can be implicitly modelled by considering the average time\nneeded to navigate through a link and the corresponding junction to leave it: this is a very\nefficient way to reduce the complexity of the task. Second, the main driving factors of\ncongestion in urban areas are demand, the structure of the network, and the capacity of\nlinks - in a sense, traffic signals are only ensuring that shared resources of the network are\naccessed correctly. Further, the setting of traffic lights is often unknown, even for those\nworking on fixed-time mode, while reactive traffic control approaches implement algo-\nrithms to react to perceived traffic conditions, so counter engineering their behaviour is\nnot trivial and adds significant computational complexity to the traffic distribution task.\n3.2 The Solution Framework\nFigure 1 presents our solution framework and its four components. In the following, we de-\nscribe the first two components, i.e., the Network Analyser and the Domain Independent\nSearch, while the last two components will be presented in Sections 4 and 5, respectively.\nThe implemented framework, tailored to be used with the considered simulation and\nscenarios, is available at: https://github.com/matteocarde/tplp-traffic\nNetwork Analyser. The purpose of the Network Analyser component is to simplify\nthe topology of the network. It takes several inputs, including the network structure\nrepresented as a XML file, the list of incoming new vehicles, and the positions of vehicles\nthat already have a route within the network. For the sake of this implementation of the\nframework, all input files are in the format used by the SUMO simulator. The Network\nAnalyser then generates a simplified logical representation that describes the network,\ncreating a model of the search space where viable solutions can be found in the next\nphase.\nTo achieve this, the Network Analyser employs a preprocessor that is specifically de-\nsigned to build an internal model of the road network. The preprocessor performs various\ntasks to simplify the network, for instance, (i) joining small streets together, (ii) simplify-\ning intersections in roundabouts, and (iii) removing streets from the network that cannot\nbe used by vehicles, such as no-traffic zones or streets reserved for public transportation.\nRegarding (i) and (ii), it is important to highlight a technical detail implemented by the\nprocessor. The output of the Network Analyser serves as input for the Domain Indepen-\ndent Search component and, subsequently, to the ASP Optimiser component. Since these\ncomponents need to capture the complete flow of traffic, they must be time-dependent.\nTo achieve accurate time-dependent analysis, it is crucial to discretise time into steps\nthat are the right trade-off: being small enough to capture real traffic nuances but large\nenough to allow for efficient planning. The problem of finding the right discretisation step\nwhen planning in temporal scenarios is a well-known problem in planning (see, e.g., (Gi-\ngante et al. 2022; Cardellini et al. 2024b)). In our case, a large discretisation step could\ngreatly impact on the quality of the produced plan. To exemplify this, let us suppose\nthat a vehicle is about to navigate two streets, $s_1$ and $s_2$, with $s_1$ leading to $s_2$. The time\nto navigate $s_1$, at a speed of 45km/h is of 14s, and the time for $s_2$ is of 12s. In an ideal\nsettings with constant speed and continuous time, it would take a vehicle 26s in total to\ncross the 2 streets. If instead we account for a discretisation step of 10s, both $s_1$ and $s_2$\nwill take 2 discretisation steps to cross, i.e., 20s, with a total time of 40s. It is evident\nthat large discretisation steps can lead to significantly misleading navigation times being\nconsidered. Further, with large discretisation steps, the times needed to cross streets tend\nto be the same, and thus the ASP Optimiser component could opt for solutions where the\nvehicles take routes with the less number of streets possible, but which in reality would\namount to greater running times. Having a smaller discretisation step, like of 1s, could\nguarantee that the solution is more cogent to the reality, but this would greatly increase\nthe complexity of the optimisation problem and negatively affect the total solving time.\nMoreover, this discretisation step has an impact on the network's topology. For exam-\nple, in most of the existing traffic simulation tools, a roundabout comprises multiple small\nstreets that connect all incoming and outgoing streets at various intersections. However,\nrepresenting each small street individually during the optimisation phase would not be\naccurate, as each of these small streets would need to be run in a time equal to the dis-\ncretisation step, resulting in a large simulated running time not representative of the real\nrunning time. To address this, the preprocessor combines the small streets that connect\nthe incoming and outgoing streets of the roundabout, creating one longer street for each\nenter/exit combination of the roundabout, which can more realistically model the flow\nof traffic within the discretised time steps. As a result of this grouping, a single street\nis represented multiple times in the network. Ensuring that the total capacity of the\nroundabout is respected becomes the responsibility of the optimiser, which will ensure\nthat the maximum number of vehicles inside the roundabout will be respected. More-\nover, having removed any streets from the network that cannot be used by vehicles, such\nas no-traffic zones or streets reserved for public transportation, we might be left with\nintersections with only two intersecting streets and which can thus be joined to better\ndeal with the discretisation step. In our experimental settings, after having performed\nthe aforementioned simplifications, we performed a simulation analysis on how different\ndiscretisation steps would have affected the running times of a vehicle that needed to run\nthrough several runs and choose the one that allowed for a total running time as close\nas possible to the real running time. We thus chose the discretisation step of 5s.\nDomain Independent Search. The Domain Independent Search component receives\nthe simplified network representation generated by the Network Analyser as input. Its\nmain purpose is to identify and output suitable routes for vehicles entering the network\nand determine the time ranges in which these vehicles will enter or exit each street along\ntheir routes.\nThe origin and destination of each approaching vehicle are known in advance, and the\nframework aims to find high-quality routes that connect these two points. To achieve\nthis, the search phase computes all possible (acyclic) paths in the network graph that\nconnect the source and target streets for each entering vehicle. However, in large and\ncomplex maps, this would result in an unmanageable number of routes. To tackle this,\nfor each vehicle approaching the network, we firstly employ a Dijkstra search algorithm\nto explore the network graph. Starting from the source street, for each adjacent street,\nwe define a new route, composed of the source street and the adjacent street, labelled\nwith the sum of their length. We insert all the generated routes into a priority queue,\nwe select the route with the smallest length and, by concatenating each adjacent street\nof the final street of the route with the route itself, we keep iterating the procedure,\nexploring the network. When the target street is reached, due to the properties of the\nDijkstra algorithm, we know to have found the shortest route between the source and\nthe target street. However, differently from the standard Dijkstra approach, we don't\nconclude the search when the target street is found, but we simply save the route, not\nputting it back in the priority queue and keep exploring the network, saving a new route\nevery time the target street is reached. A loop detection mechanism is put in place to\ndetect when the concatenation of a new street would cause a cycle and simply discard\nthe generated route. We stop the procedure when a desired number of (acyclic) routes is\nreached (in our experimental setting, 60 routes, appropriate for the sizes of the networks\nconsidered). These routes are guaranteed, by the Dijkstra algorithm, to be the shortest\namong all the possible routes but are not guaranteed to be the fastest, since congestion\ncould change the running times of a street.\nUnfortunately, these routes, computed for each approaching vehicle, could still be too\nmany to be considered by the solver. Moreover, most of the routes could only differ slightly\nby a few streets and thus quite interchangeable in distributing the traffic. Instead, we are\ninterested in having a smaller number of routes but \u201cmost different\u201d between each other,\ni.e., sharing the least number of streets possible. This way, the ASP solver could decide\nto direct a vehicle to a longer route, but which is less congested and actually faster to\nrun through. To compute these \u201cmost different\u201d routes for each pair of routes $r_1$ and $r_2$\nwe compute a similarity score through a function $\\sigma(r_1,r_2) \\in [0,1]$. In our experimental\nsetting, the function $\\sigma$ is computed as\n$\\sigma(r_1,r_2) = \\frac{|streets(r_1) \\cap streets(r_2)|}{min(|streets(r_1)|, |streets(r_2)|)},$\nwhere $streets(r)$ is the set of the streets of a route $r$. Then, we create a set $\\mathcal{R} =\n\\{R_1,..., R_q\\}$ where each $R_i \\in \\mathcal{R}$ is a set of routes such that for each pair of routes $r_1, r_2$\nwe have $r_1, r_2 \\in R_i$ if $\\sigma(r_1,r_2) < \\sigma_T$ and $r_1 \\in R_i, r_2 \\in R_j$ with $i \\neq j$ if $(\\sigma(r_1,r_2) \\ge \\sigma_T$,\nwith $\\sigma_T \\in [0, 1]$ being a similarity threshold (in our experimental setting, $\\sigma_T = 0.5$). The\nsize $q$ of the set $\\mathcal{R}$ depends on the instance but, usually, it is not greater than 3, since\nfor every source street being at the edge of the network, there are usually three cardinal\ndirections in which the vehicles can go, and thus three possible sets of \"most different\"\nroutes. From each of the set $R_i$, we then select the top $k$ routes inside $R_i$, ordered by\nlength (in our experimental setting, $k = 5$, thus usually having 15 final routes to choose\nfor each approaching vehicle). It is worth noting that the ASP Optimiser can therefore\nfind the optimal route, according to the destination of the vehicle and the network con-\ndition, out of the identified $k$ final routes. In principle, the optimal route selected by the\nASP Optimiser can be different from the global optimal route: this is not deemed to be\nan issue in urban areas, where the highly dynamic nature of traffic plays a major role.\nWe will see in the encoding of the ASP Optimiser in the following section that, to deal\nwith the temporal dimension, we will discretise time by a quantum (in our setting 5s)\nand then emulate the evolution of the movement of each vehicle running its route, where\nvehicles can enter or exit a street only on times multiple of this quantum. For the rapid\nexecution of the ASP Optimiser component, we compute in advance time ranges for when\nvehicles could enter and exit the streets along their routes. This computation serves two\npurposes: speeding up the simulation of traffic flow and reducing overall computation\ntime. By utilising the knowledge of all the vehicles' routes within the network (as deter-\nmined when the vehicles are approaching the network), it becomes possible to compute\ntime ranges for the entrance and exit timings in every street of a potential route run by\nan approaching vehicle by solving two relaxed simulations for each vehicle:\n1. the first simulation is performed assuming that no other vehicle is present in the\nnetwork, i.e., there is no congestion, and thus the vehicle can run at its maximum\nspeed (45 km/h),\n2. the other simulation is performed assuming that all other vehicles in the map occupy\nall the streets of their routes at the same moment, thus obtaining, for each street,\nthe maximum amount of congestion possible. For each street, we then compute the\nspeed of the vehicles, proportional to the level of congestion, and from that speed\nwe get the time to traverse the street.\nThese two relaxed simulations provide an estimate of the minimum and maximum entry\nand exit time for each vehicle. Computing the speed proportional to the congestion can\nbe done in several ways, in our experimental setting we perform it this way. We firstly\ncompute the capacity of the street, which is the number of possible vehicles which could\noccupy the street. This number is proportional to the length of the street and the number\nof lines of the street. In our experimental settings, we make the assumption that a car\noccupies 8m, i.e., the sum of the length of a standard car, usually 5m, and the safety\ndistance of 3m in the front. In a real scenario, the safety distance depends on the speed of\nthe car, which is, however, what we want to compute. Nevertheless, in an urban scenario,\nwhere vehicles are not allowed high speed, the safety distance of 3m was validated by\ntraffic operators. We compute the capacity of a street $s$ as\n$capacity(s) = \\left\\lfloor\\frac{lines(s) \\times length(s)}{8m}\\right\\rfloor$\nWe select the rounded up value to avoid small streets to have a capacity of 0. We can now\nestimate the speed of the cars in the streets. Let vehicles(s) be the number of vehicles\nin the streets, i.e., its congestion. The speed of a street $s$ is estimated as\n$speed(s) = \\begin{cases}\n45km/h & \\text{if } 0 \\le vehicles(s) < 0.4 \\times capacity(s), \\\\\n30km/h & \\text{if } 0.4 \\times capacity(s) \\le vehicles(s) < 0.7 \\times capacity(s), \\\\\n15km/h & \\text{if } 0.7 \\times capacity(s) \\le vehicles(s).\n\\end{cases}$\nWhile this approach is only an estimation, it was validated, together with the thresholds\n(i.e., 0.4 and 0.7), by traffic operators and gave good results in the experimental setting.\nThe selected routes for each approaching vehicle together with the minimum and max-\nimum entry and exit times are then passed to the third component of the architecture,\nthe ASP Optimiser, dealing with optimisation of the routes."}, {"title": "4 ASP for the Optimisation Phase", "content": "In the section, we detail the third component of the solution framework, referred to as\nASP Optimiser, which has the role to select the best route for each vehicle entering the\nnetwork. Specifically, the input of the component is a set of ASP facts, referred to, in\nthe following, as Data Model, and it uses an ASP encoding to compute the best route for\nevery vehicle approaching the network.\nData Model. The data model consists of the following atoms:\n\u2022 streetOnRoute(S,R,MIN,MAX) represents the relationship between street S and\nroute R. The variables MIN and MAX, computed by the Search component, define the\nexpected time range for a vehicle starting at t = 0 to traverse route R and enter\nstreet S.\n\u2022 link(S1, S2) indicates that there is a connection from street S1 to street S2.\n\u2022 vehicle(V,T) defines the presence of a vehicle V of type T on the map. T can\nbe either con (controlled vehicle) or sim (simulated vehicle). We remind that a\ncontrolled vehicle is a new vehicle entering the region for which a route has to be\nidentified, while a simulated vehicle already has a set route, and the system only\nneeds to track its presence on the map.\n\u2022 origin(V,FROM) designates street FROM as the starting point of vehicle V during\nthe planning process. For controlled vehicles, the origin represents the street where\nthe vehicle first enters the map. Similarly, destination(V,TO) specifies street TO\nas the final destination that will take the vehicle V outside the map.\n\u2022 possibleRouteOfVehicle(V,R) indicates that vehicle V can follow route R to move\nfrom its origin to its destination. For simulated vehicles, there will be only one\npossible route available, determined when the vehicle entered the network. For\ncontrolled vehicles, this atom represents a subset of all possible routes from the\norigin to the destination (as discussed in the previous section).\n\u2022 time(T) represents the time unit used for scheduling, ranging from 0 to the maxi-\nmum horizon when all vehicles have left the network.\n\u2022 capacity(S,N) denotes the capacity of street S, with N indicating the capacity\nvalue, as computed by Eq. 1.\n\u2022 trafficTravelTime(K,S,T) represents the time required to traverse street S under\ndifferent traffic conditions. The variable K can take values of heavy, medium, or\nlow, indicating the traffic amount. These amounts are correlated to the speeds of\n15 km/h, 30 km/h, or 45 km/h, respectively, as computed by Eq. 2. The time T is\nsimply computed by dividing the length of the street with the relative speed.\n\u2022 maxTrafficTravelTime(S,T) models the time it would take to clear the street in\ncase of congestion when it reaches its maximum capacity.\n\u2022 trafficThreshold(K,S,MIN,MAX) defines the range between MIN and MAX of ve-\nhicles in street S that categorise K\u2208 {heavy, medium, low} traffic, correspond-\ning to the traffic levels mentioned in Eq. 2 (for example, if K is medium then\nMIN = 0.4 \u00d7 capacity(s) and MAX = 0.7 \u00d7 capacity(s)).\n\u2022 roundabout (R, C) indicates the existence of a roundabout R with a maximum ca-\npacity of C, computed as the sum of all capacities of the streets of the roundabout.\n\u2022 streetInRoundabout(SS,R) indicates that the simplified (result of original street's\ngrouping) street SS is part of the roundabout R.\nThe output of the ASP Optimiser consists of the following atoms:\n\u2022 solutionRoute(V,R) assigns a route R to the vehicle V.\n\u2022 enter(V,S,IN) and exit(V,S,OUT) specify the times when a simulated vehicle\nV enters and exits street S. We remind that an upper and lower bound of these\nvalues is determined in the Search phase and provided as input through the atom\nstreetOnRoute(.,.,.,.).\nASP Encoding. Figure 2 presents the rules utilised in the ASP encoding. Rule r\u2081 defines\nthe atom solutionRoute, which, for every controlled vehicle, selects exactly one route\namong the different selected routes (computed during the Search phase) that transport\nthe vehicle from its origin to its destination. On the other hand, rule r2 assigns the\nsolutionRoute for simulated vehicles to be the route they are already following. Rule\nr3 computes an entry time within the minimum and maximum range for each controlled"}, {"title": "5 Experiments, Monitoring, and Execution", "content": "For the last phase of the framework (Mobility Simulator)", "area": "this kind of events can reduce the capacity of roads, or completely block\nportions of the network, according to severity. This information about unexpected or\nunplanned events can be fed back to the Network Analyser to update its internal repre-\nsentation of the network and of the links, hence ensuring that the subsequent modules\nare reasoning upon a more accurate representation of reality. In this implementation we\ndid not explicitly take into account these classes of events, as they are complex to simu-\nlate with SUMO and may require domain expertise to be properly modelled and encoded.\nHowever, the framework is designed to support this kind of updates, with no modification\nto the presented modules \u2013"}]}