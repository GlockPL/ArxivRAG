{"title": "Graph Coloring to Reduce Computation Time in Prioritized Planning", "authors": ["Patrick Scheffe", "Julius Kahle", "Bassam Alrifaee"], "abstract": "Distributing computations among agents in large networks reduces computational effort in multi-agent path finding (MAPF). One distribution strategy is prioritized planning (PP). In PP, we couple and prioritize interacting agents to achieve a desired behavior across all agents in the network. We characterize the interaction with a directed acyclic graph (DAG). The computation time for solving MAPF problem using PP is mainly determined through the longest path in this DAG. The longest path depends on the fixed undirected coupling graph and the variable prioritization. The approaches from literature to prioritize agents are numerous and pursue various goals. This article presents an approach for prioritization in PP to reduce the longest path length in the coupling DAG and thus the computation time for MAPF using PP. We prove that this problem can be mapped to a graph-coloring problem, in which the number of colors required corresponds to the longest path length in the coupling DAG. We propose a decentralized graph-coloring algorithm to determine priorities for the agents. We evaluate the approach by applying it to multi-agent motion planning (MAMP) for connected and automated vehicles (CAVs) on roads using, a variant of MAPF.", "sections": [{"title": "1 Introduction", "content": null}, {"title": "1.1 Motivation", "content": "In multi-agent planning problems, several agents may share a common objective or must respect common constraints. Traditional multi-agent path finding (MAPF) is a problem where multiple agents navigate through an environment modeled as a graph G\u043c = (V\u043c, \u0415\u043c). This graph consists of a set of vertices VM, representing locations, and a set of edges EM, representing the paths connecting these locations. Each agent i aims to move from its starting vertex si e VM to its target vertex ti \u2208 VM. The primary constraint for each agent is to avoid collisions with other agents. A collision occurs if two agents, i and j, occupy the same vertex v at the same time step k, which can be represented by the tuple"}, {"title": "Definition 1 (Prediction)", "content": "A prediction x(ji)k of agent j is agent j's optimized solution at time k. A prediction x(ji)k of agent j in agent i is agent j's prediction from agent i's perspective at time k.\nOne of the difficulties in distributed optimization approaches such as PP is guaranteeing prediction consistency among the agents in the network (Alrifaee, He\u00dfeler, & Abel, 2016; C. Kloock & Werner, 2020; Trodden & Richards, 2013), or compensating for the lack thereof. Let the set of agent i's neighbors be denoted by V(i) and equal the set of agents that agent i considers in its subproblem (see Section 1.4 for a precise definition)."}, {"title": "Definition 2 (Prediction Consistency)", "content": "A network is prediction consistent at time step k if the prediction x(ji)k of all neighbors je V(i) in every agent i e V equals their own prediction x(j)k, i.e.,"}, {"title": "1.2.1 Parallel PP", "content": "In parallel PP, agents compute solutions parallelly and exchange predictions afterwards. Assuming no delay introduced by the communication, the communicated predictions can be used no earlier than in the following time step. Each agent consequently shifts the received predictions by one time step such that the prediction time matches the time in its planning problem. Assuming continuous computation, the entries at the end of the prediction are missing after such a shift and must be estimated (Alrifaee, 2017). When an agent deviates from the prediction it communicated in the previous time step, the predictions become inconsistent. Since the subproblems are then solved using different data, the MAPF solution might inadvertently violate constraints or become unstable. Consequently, parallelizing the computation requires dealing with the problem of prediction inconsistency, as presented in the following literature review.\nA solution to the problem of prediction inconsistency is to constrain an agent's change from a previous prediction. Dunbar and Caveney (2012) and Zheng, Li, Li, Borrelli, and Hedrick (2017) show stability of PP with parallel computation applied to vehicle platoons. Nearly consistent predictions are achieved with a penalty on changes of previously predicted plans and a terminal constraint. Dunbar and Murray (2006) stabilize a distributed formation controller by limiting the control action to restrain deviations from previously predicted plans. Another approach to enable parallel computation in linear time-invariant systems is tube-based distributed model predictive control, in which each controller rejects bounded disturbances (Richards & How, 2007). While there are improvements to tighten the tubes (Farina & Scattolini, 2012; Riverso & Ferrari-Trecate, 2012), a downside to tube-based MPC remains the conservativeness of its solutions. In our previous work (Scheffe, Xu, & Alrifaee, 2024), the predictions of neighbors, and thus the constraints, are overapproximated by their reachable set. Consequently, agents can compute in parallel while guaranteeing satisfaction of the original constraint. However, the overapproximation tightens the constraints compared to sequential PP and therefore leads to more conservative solutions.\nAlthough successful in their respective applications, the above approaches have higher input constraints and therefore less flexibility when solving the planning problem. This might lead to more conservative solutions or even constraint violations."}, {"title": "1.2.2 Sequential PP", "content": "In sequential PP, agents compute their solutions sequentially. An agent waits for the prediction of higher prioritized agents before it solves its own planning problem. In one time step, every agent in the network agrees on the predictions of others. Thus, sequential PP guarantees prediction consistency among the agents in the network (Alrifaee et al., 2016), but suffers from increasing computation time.\nThe following literature review considers approaches in which agents compute sequentially. In sequential computation of PP, the prioritization determines the computation order"}, {"title": "1.2.3 Parallelization in Sequential PP", "content": "When agents need to consider common objectives or constraints, we term these agents coupled. For agents that are not coupled, prioritizations exist such that their computations can be parallelized without risking an inadvertent violation of constraints (Alrifaee,"}, {"title": "1.3 Contribution of this Article", "content": "In PP, the number of agents whose computations can be parallelized depends on the coupling and the prioritization. The coupling is often determined by the application. Therefore, the computation time to solve MAPF using PP can only be influenced through the prioritization. We present a prioritization algorithm to reduce computation time by maximizing the number of parallel agent computations. We formalize the problem of maximizing the number of parallel agent computations and prove the problem's equivalence to a graph coloring problem. We formulate our algorithm for graph coloring such that it can be solved in a decentralized fashion by each agent."}, {"title": "1.4 Notation", "content": "In this paper, we speak of agents whenever concepts are generally applicable to PP. A variable x is marked with a superscript x(i) if it belongs to agent i. The actual value of a variable x at time k is written as xk, while values predicted for time k + l at time k are written as xk+l|k. A trajectory is denoted by replacing the time argument with (\u00b7) as in x\u00b7k. For any set S, the cardinality of the set is denoted by |S|.\nWe use graphs as a modeling tool of networks. Every agent is associated with a vertex, so the terms are used synonymously."}, {"title": "Definition 3 (Directed graph)", "content": "A directed graph G = (V,\u00bf) is a pair of two sets, the set of vertices V = {1, ..., NA} and the set of directed edges \u0109 \u2286 V \u00d7 V. The edge from i to j is denoted by (i \u2192 j). An oriented graph is a directed graph obtained from an undirected graph by replacing each edge (i \u2013 j) with either (i \u2192 j) or (j \u2192 i).\nWe characterize the relation between agents by their adjacency."}, {"title": "Definition 4 (Adjacency)", "content": "A vertex jis a predecessor of vertex i iff (j \u2192 i) \u2208 E. The set of predecessors of vertex i is denoted by"}, {"title": "1.5 Structure of this Article", "content": "The rest of this article is organized as follows. First, our PP framework for multi-agent motion planning (MAMP) is introduced in Section 2. MAMP is a variant of MAPF, in which the kinodynamic constraints of agents are taken into account during planning. The problem that the present paper addresses is formally defined in Section 3, before our solution to it using graph coloring is presented in Section 4. We show numerical results of our approach in Section 5 by applying it to MAMP for connected and automated vehicles (CAVs) at intersections."}, {"title": "2 Prioritized Planning for Multi-Agent Motion Planning", "content": "This section provides a background to PP applied to MAMP and prioritization. MAMP is a variant of MAPF which can be applied to CAVs. While MAPF abstracts the environment and system dynamics in a graph representation, MAMP explicitly considers the system dynamics as ordinary differential equations and models the environment by static obstacles represented as polygons. Further, MAPF aims at planning a complete path from a start to a goal vertex. Contrary, the objective in our MAMP application is to plan for a fixed time horizon and to shift the horizon every time step, commonly known as receding horizon planning or online replanning (Cashmore et al., 2019; Li, Tinka, et al., 2021; Scheffe, Pedrosa, Fla\u00dfkamp, & Alrifaee, 2023; Shahar et al., 2021; Silver, 2005). The planning problem in MAMP is modeled as an optimal control problem (OCP). Certainly, there exists work that extend beyond traditional categorization of MAPF by, e.g., incorporating system dynamics (Alonso-Mora, Beardsley, & Siegwart, 2018; Le & Plaku, 2018; Luo et al., 2016).\nOur framework PP framework for MAMP is illustrated in Figure 1. Agents solve their OCP (Section 2.2) when they have received all predictions from their predecessors, and send their predictions to their successors. To determine the predecessors and successors of agents, we couple (Section 2.1) and prioritize (Section 4) them. This paper focuses on the prioritization step, which we evaluate in the application of MAMP for CAVs. We sketch coupling and solving the OCP for trajectory planning in the following for context. Whenever we refer to a MAMP problem incorporating the entire network of agents, we term this as an MAMP instance."}, {"title": "2.1 Couple", "content": "If agents interact via their objective or constraint functions, we speak of coupled agents. A coupling graph represents the interaction between agents."}, {"title": "Definition 5 (Directed coupling graph)", "content": "A directed coupling graph (k) = (V, \u0108(k)) is an oriented graph obtained from orienting the edges of an undirected coupling graph at time step k. If an edge (i \u2192 j) is directed from agent i to agent j, then agent j is responsible for considering the respective coupling objective and constraint in its planning problem.\nThe application in which MAMP is used determines which coupling objectives and constraints must be considered in the OCPs. For example, collision freeness between robots can be achieved via coupling constraints.\nThe undirected coupling graph can often be determined in networked applications before solving the OCP. In robot applications, if robots move on predetermined paths, we can couple robots if these paths intersect. Paths can be predetermined for road vehicles following lanes, or for warehouse robots (Ma, Li, Kumar, & Koenig, 2017). In MAMP, agents move freely. We analyze their reachable set for the prediction horizon, and couple them if their reachable sets intersect, similar to Scheffe et al. (2024)."}, {"title": "2.2 Solve OCP", "content": "The objective of an agent i is to follow a reference trajectory:"}, {"title": "3 Problem Statement", "content": "The goal of our prioritization function is to reduce the computation time of the MAMP instance. Agents can compute decentralized components of the PP framework in parallel, i.e., coupling and prioritizing in Figure 1. However, coupled agents must plan in sequence to guarantee prediction consistency. When all agents plan sequentially, the computation time grows approximately linearly with the number of agents. However, if some agents are uncoupled, they can potentially plan in parallel without affecting the prediction consistency. An agent starts to plan as soon as it has received the predictions from each of its predecessors. This offers a chance to reduce the computation time. We term the highest number of sequentially planning agents the number of computation levels Ne in the MAMP instance. The number of computation levels corresponds to the longest path in the directed coupling graph G. With the following definitions, we can formalize the number of computation levels."}, {"title": "Definition 6 (Degree)", "content": "The degree"}, {"title": "Assumption 1", "content": "The planning times T(i) of all agents i are similar,"}, {"title": "Assumption 1", "content": "is mild if we use an anytime algorithm for planning. An anytime algorithm aims to find an initial solution quickly and then incrementally improve the solution as time allows (Likhachev, Gordon, & Thrun, 2003). Limiting the planning time results in nearly constant planning times of all agents."}, {"title": "Assumption 2", "content": "The planning time of an agent is far greater than the prioritization time,"}, {"title": "Assumption 2", "content": "is reasonable if an involving planning problem is solved in the MAMP. This is the case if, e.g., the OCP solved in MAMP is nonconvex, as in trajectory planning for CAVs.\nAccording to Assumption 2, we can overapproximate the prioritization time as the maximum of all prioritization times Tu)prio for simplicity. To obtain the computation time T of the MAMP instance, we weigh the vertices V with their respective planning time by a weighting function fw: V \u2192 R"}, {"title": "4 Problem Solution", "content": "This section first introduces the concept of prioritization in PP in Section 4.1. We prove the equivalence of Problem 1 to a vertex coloring problem in Section 4.2. We solve Problem 1 with the decentralized algorithm presented in Section 4.3."}, {"title": "4.1 Priority Idea", "content": "In PP, we prioritize the agents in the network (Alrifaee et al., 2016; Kuwata et al., 2007). Prioritizing agents results in clear responsibilities and determines the order of computations in sequential PP. A prioritization function p: V \u2192 N prioritizes every agent's vertex in the network. If p(i) < p(j), then agent i has a higher priority than agent j, or agent i is prioritized over agent j.\nBy prioritizing, we can transform an undirected coupling graph into a directed coupling graph which is a DAG. An edge points towards the vertex with lower priority,"}, {"title": "Lemma 1", "content": "Given the construction rule in (17), the directed coupling graph \u011c resulting from the undirected coupling graph G and a valid prioritization function p regarding (18) is a DAG."}, {"title": "4.2 Graph Coloring", "content": "The goal of vertex coloring is to partition a set of vertices V of a graph into a set of colors C\u2282N>0 such that no two adjacent vertices are of the same color. The mapping of vertices"}, {"title": "Theorem 1", "content": "Let a graph G be colored by the coloring function 4:V \u2192 C. Let Pcolor be a prioritization function that fulfills (21), so we can convert a colored coupling graph G to a coupling DAGG. The number of colors Nc corresponds to the number of levels Nc."}, {"title": "Theorem 2", "content": "Problem 1 is equivalent to Problem 2 with a prioritization function that respects (21)."}, {"title": "4.3 Polynomial-time Decentralized Graph Coloring", "content": "In this section we describe our approach of graph coloring. In contrast to approaches from literature (Kuwata et al., 2007; Welsh & Powell, 1967), we propose a decentralized algorithm. The input to the algorithm is the undirected coupling graph, in which every vertex is associated with a unique number. Every agent in the networked control system solving this algorithm must obtain the same prioritization to realize decentral execution.\nTo overcome the efficiency problem of optimal graph coloring algorithms, we approximate the solution to the minimal graph coloring with a greedy algorithm such that Nc/x(G) is close to 1 (Garey & Johnson, 1976). Greedy coloring algorithms select and color vertices one after another with the corresponding smallest possible color c\u0454 \u0421.\nTo select the next vertex to be colored, we propose a heuristic based on a combination of a saturation degree ordering (SDO), a largest degree ordering (LDO), and a first-fit ordering (FFO) (Al-Omari & Sabri, 2006; Hasenplaugh, Kaler, Schardl, & Leiserson, 2014) to achieve a consistent and near-optimal coloring among agents. It arranges vertices corresponding to an SDO, an LDO, and an FFO, in descending importance for the ordering. An SDO arranges the vertices in descending order according to the saturation degree, i.e., the number of their differently colored neighbors. An LDO arranges the vertices in descending order according to the number of neighbors d(i). An FFO arranges the vertices by their unique number. For decentralized execution, the result of our algorithm must be consistent across all agents. The first two orderings can be ambiguous, if multiple vertices have the same saturation degree and the same number of neighbors. However, such ambiguities are always resolved through unique vertex numbers, guaranteeing a consistent coloring among the agents. Consequently, the algorithm results in the same coloring for all agents, given the same input.\nAlgorithm 1 details our coloring algorithm. The algorithm iteratively colors vertices until every vertex is colored (Line 3). All vertices yet to be colored are investigated in the for-loop in Line 5. If the current saturation degree s is greater than the current maximum saturation degree Smax, Smax and the next vertex to be colored imax are updated (Lines 8 and 9). This procedure corresponds to an SDO. If the saturation degrees are equal, the algorithm returns to an LDO (Line 10) and updates imax with i if i has a higher degree than the current imax. Otherwise, imax remains the first vertex in the list of vertices according to an FFO. The set of valid colors for vertex imax is the set difference of all colors and its adjacent colors (Lines 12 and 13). The minimal possible color is assigned to imax with (Line 14), and the vertex is removed from the set of uncolored vertices (Line 15). Since in each iteration of the outer loop one vertex is colored, the algorithm will terminate in NA iterations. Since the number of available colors is infinite, the algorithm will always return a valid coloring.\nAn FFO needs to iterate only once over the set of vertices, resulting in a time complexity of O(NA). An LDO needs to compare the degree of every vertex, leading to a"}, {"title": "5 Evaluation in a Trajectory Planning Application of CAVs", "content": "We evaluate the presented approach on reducing computation time by prioritization in the context of CAVs. In Section 5.2, we present the experiment setup, an intersection scenario"}, {"title": "5.1 Trajectory Planning", "content": "In our application of trajectory planning for CAVs, the objective (6a) of a CAV i is to stay close to a reference trajectory. In our work, the vector field ffi) is a nonlinear kinematic single-track model (Rajamani, 2006, section 2.2). The coupling constraint (6g) achieves collision avoidance with predecessors.\nIt is computationally hard to find the global optimum to OCP (6) due to its nonlinearity and nonconvexity. We approximate (6) with a receding horizon graph search based on our"}, {"title": "5.2 Intersection Scenario", "content": "We evaluate the presented approach to reduce computation time by prioritization to distributed trajectory planning for road vehicles at an intersection with two incoming and two outgoing lanes for each direction. The intersection is part of a simulation of the Cyber-Physical Mobility Lab, an open-source, remotely-accessible testbed for CAVs (M. Kloock et al., 2021). Figure 3 depicts the initial states with eight vehicles as well as the associated undirected coupling graph. From each direction, one vehicle is turning right, and one vehicle is moving straight. The experiments run for kexperiment = 25 time steps with a time step duration of 0.2s. The MPC uses a prediction horizon of Np = 8, the MCTS which solves the OCP uses Nexp = 2500 expansions."}, {"title": "5.3 Computation Time", "content": "Figure 4 shows the computation time of the MAMP instance according to (15) for different prioritizations. For each prioritization, the median and maximum computation time over all time steps are displayed. In our experiment, we decrease the maximum computation time by more than 57.9% compared to the prioritization Pconstant.\nThe decrease in computation time comes mostly from a reduction in the number of computation levels. Each prioritization produces a directed coupling graph, which results in a certain number of computation levels. As the number of different prioritizations for NA vehicles is NA!, there are 8! = 40320 different prioritizations for the vehicles.\nFigure 5 shows the number of computation levels for these prioritizations, which ranges from three to eight given the undirected coupling graph in Figure 3.\nFigure 6 shows the median and maximum computation levels Ne over all time steps. As vehicles move during the experiment, the undirected coupling graph changes, and with it the number of computation levels. The median is at two, since as vehicles exit the intersection, only two vehicles are coupled in each outgoing lane. With our algorithm to solve the OCP (Section 5.1), we obtain a strong correlation between the number of computation levels and the computation time of the MAMP instance. The maximum number of computation levels for prandom is five, which can be expected given most prioritizations result in four or five computation levels (Figure 5).\nFigure 7 depicts the directed coupling graphs resulting from Pconstant and our proposed coloring prioritization function Pcolor for the first time step of the experiment with the"}, {"title": "5.4 Quality of Trajectories", "content": "The quality of trajectories Jp of a prioritization algorithm p according to the cost of the OCP of each vehicle is given as\nwith kexperiment being the number of time steps in the experiment, and Ji) (k) given in (5). The cost normalized to that of the prioritization Pconstant is shown in Figure 8. In our experiment, the cost increased by 26.2% compared to the prioritization Pconstant. All vehicles were able to pass the intersection with all prioritizations."}, {"title": "6 Discussion", "content": "In the following, we discuss our approach which prioritized agents using graph coloring. The discussion regards the computation effort, the quality of agents' solutions in the MAMP instance, and the communication effort."}, {"title": "6.1 Computation Effort", "content": "The computation time of our coloring algorithm scales in an order of O(N3) with the number of agents as discussed in Section 4.2. This effort should at least be compensated by the reduced computation time for the MAMP instance. The amount of reduced computation time for the MAMP instance depends on mainly two factors.\nThe first factor is the computation demand for the control problem in each agent. If the control problem in each agent is computationally simple, the reduction of computation levels might not be very beneficial. However, nonconvex optimization problems, such as trajectory planning with collision avoidance, typically are computationally demanding and therefore benefit from a reduction of computation levels. If the computation demand is sensitive to the prioritization and thus the constraints, which can be the case in A*-based algorithms, the reduction in computation levels might be counteracted by an increase in computation demand. In sampling-based algorithms like MCTS, the nearly constant computation demand mainly depends on the number of explored samples. Thus, the reduction of computation time is proportional to the reduction of computation levels.\nThe second factor is the undirected coupling graph of the MAMP instance. For a fully connected coupling graph, any prioritization algorithm results in NA computation levels. For a coupling graph which is a path graph, the worst prioritization with regards to the computation time would result in NA levels, whereas our prioritization through graph coloring always results in only two levels. A path graph is a graph that consists of a single path (Lunze, 2019) in which each vertex has a degree of two except the vertices at the end and beginning of the path have a degree of one. Coupling graphs that have a chromatic number of two, such as the one shown in Figure 9, are bipartite graphs. For the graph in Figure 9, a prioritization with priorities according to vertex numbers would result in eight computation levels, while our proposed coloring algorithm achieves two computation levels."}, {"title": "Theorem 3", "content": "Given an undirected coupling graph G, the minimum number of computation levels Nc is upper bounded by the maximum degree of vertices in the graph, i.e.,"}, {"title": "6.2 Quality of Solutions", "content": "The quality of a solution consists of its cost, and its feasibility, i.e., does a solution exist which satisfies all constraints. Our approach does not need any application-specific knowledge about agents' constraints or interactions. On the one hand, this makes the approach"}, {"title": "6.3 Communication Effort", "content": "The communication in our PP framework (Figure 1) is limited to communicating predictions to successors, i.e., communication takes place where agents are connected in the directed coupling graph. The number of sequential communications corresponds to the number of computation levels. Therefore, through reducing the number of computation levels, our approach also reduces the number of sequential communications. However, communication instead takes place in parallel, which puts a higher communication load on the communication infrastructure. Depending on the infrastructure, the implications on the communication can be beneficial or detrimental."}, {"title": "7 Conclusion", "content": "We proposed a prioritization strategy which reduces the computation time in PP for MAMP, a variant of MAPF. We proved the equivalence of this problem to graph coloring of a given undirected coupling graph of the MAMP instance and prioritizing agents on the basis of the vertex colors. Our coloring algorithm works in a decentralized fashion, which avoids a single point of failure and reduces the amount of communication required. We successfully applied our process for prioritization to vehicles crossing an eight-lane intersection using an PP approach for MAMP based on MPC, for which the reduction of computation time is around 57.9% compared to a baseline approach from literature. Our approach can be applied to any domain with prioritized computations, provided that the coupling graph is known. Especially in large-scale systems with sparse coupling graphs, our approach can significantly reduce the computation time and thus improve the scalability.\nThe feasibility of each agent's planning problem and the quality of the solutions also depend on the prioritization. In our experiment, the solution cost was increased by 26.2% compared to a baseline approach from literature. In the future, we will further investigate prioritization considering feasibility and quality of solutions."}]}