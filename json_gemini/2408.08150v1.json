{"title": "Winning Snake: Design Choices in Multi-Shot ASP", "authors": ["Elisa B\u00f6hl", "Stefan Ellmauthaler", "Sarah Alice Gaggl"], "abstract": "Answer set programming is a well-understood and established problem-solving and knowledge representation paradigm. It has become more prominent amongst a wider audience due to its multiple applications in science and industry. The constant development of advanced programming and modeling techniques extends the toolset for developers and users regularly. This paper compiles and demonstrates different techniques to reuse logic program parts (multi-shot) by solving the arcade game snake. This game is particularly interesting because a victory can be assured by solving the NP-hard problem of Hamiltonian Cycles. We will demonstrate five hands-on implementations in clingo and compare their performance in an empirical evaluation. In addition, our implementation utilizes clingraph to generate a simple yet informative image representation of the game's progress.", "sections": [{"title": "1 Introduction", "content": "Answer set programming (ASP) (Brewka et al. 2011) is an established declarative pro- gramming paradigm based on stable model semantics (Gelfond and Lifschitz 1988). It combines attributes of different fields of computer science such as knowledge representa- tion, logic programming and SAT solving and is suited for numerous tasks like planning and configuration problems (Gebser et al. 2011). ASP is of interest as theoretical concept for computer science. Its declarative way of describing problems in a rule-based language allows for fast prototyping, offering great value for product applications as well. The ability to solve hard, discrete optimization problems makes ASP appealing for industrial applications. In recent years, different specialized ASP-tools such as clingo (Gebser et al. 2019a), DLV (Adrian et al. 2018), WASP (Alviano et al. 2013), or alpha (Weinzierl 2017) where introduced. clingo established itself as prominent choice, with its various tools and in-depth documentation, continuous development and many publications on various problems (Gaggl et al. 2015; Takeuchi et al. 2023; Rajaratnam et al. 2023). With the growth of its applications, the implementation of advanced logic programs gains traction. Traditionally, the clingo workflow grounds a logic program (i.e. replac- ing variables by contents) and solves the resulting program afterwards. In an iterative"}, {"title": "2 Preliminaries", "content": ""}, {"title": "2.1 Answer Set Programming", "content": "A (disjunctive) program I in ASP is a set of rules r of the form:\n$a_1;...; a_m:- a_{m+1},..., a_n, not a_{n+1},..., not a_o$.\nwhere each atom $a_i$ is of the form: p(t1,...,tk), p is a predicate symbol of arity k and t1,..., tk are terms built using constants and variables. For predicates with arity k=0, we will omit the parenthesis. A naf (negation as failure) literal is of the form a or not a for an atom a. A rule is called fact if m=1 and o=0, normal if m=1 and integrity constraint if m=0. Each rule can be split into a head h(r) = {$a_1,...,a_m$} and a body B(r) = {$a_{m+1},...,not a_o$}, which divides into a positive part $B^+(r) = {a_{m+1},...,a_n}$ and a negative part $B^-(r) = {a_{n+1},..., a_o}$. An expression (i.e. term, atom, rule, program, ...) is said to be ground if it does not contain variables. Let M be a set of ground atoms, for a ground ruler we say that M $\\models$ r iff M$\\cap$h(r) $\\neq$ $\\emptyset$ whenever $B^+(r) \\subseteq M$ and $B^-(r) \\cap M = \\emptyset$. M is a model of P if M $\\models$ r for each r$\\in$ P. M is a stable model (also"}, {"title": "2.2 Multi-Shot ASP in clingo", "content": "clingo provides an API (Gebser et al. 2019b) to access the functionality of an ASP program within an imperative language such as python. The standard procedure is to create a clingo control object in the wrapper program, assign one or more logic pro- gram inputs, ground it, and solve it. This setup allows to alter and repeatedly run logic programs (multi-shot). Besides basic functionality, the clingo control object provides access to several me- chanics connected to the logic program. Parametrized subprograms allow grounding of rules with values of constants determined at runtime, enabling flexible data management. The solving is initialized via a solve call. The corresponding function accepts attributes to influence the execution of the solving, such as assumptions. Assumptions are a list of atom/truth value pairs, which state valid mappings for the current solve call. Another mechanic to influence truth values of atoms are externals. They are declared in the form #external a:b\u2081,...,bm. with conditional literal a:b\u2081, ...,bm within the logic program. An atom marked as external has a fixed truth value similar to a fact, except that in between solve calls the actual value can be changed via the function assign_external. It is even possible to remove an external permanently by releasing it. Next to assumptions and externals, there is also the possibility to directly influence the ongoing search for models. During the solve call, truth values can be assigned to (negated) conjunctions of atoms (clauses and nogoods). In clingo this functionality is accessible by either implementing a custom propagator or indirectly through the context of a model object. The model object can be obtained by providing a callback model handling function to the solve call."}, {"title": "2.3 Graphs, Paths, and Hamiltonian Cycles", "content": "A grid graph G(n, m) is an undirected graph formed by a rectangular grid of vertices (Itai et al. 1982). The grid consists of n rows and m columns, denoted as G(n,m) = (V, E), where V represents the set of vertices with |V| = n$\\cdot$m and E $\\subseteq$ V$\\times$V represents the set"}, {"title": "2.4 Snake Game", "content": "The game snake is a classic arcade game, where the user steers a snake's head on a grid similar to a grid graph of dimension n$\\times$m. The snake $\\&\\#x212f;$ can be interpreted as a list of grid coordinates, for example $\\&\\#x212f;$ = [(6, 2), (5, 2), (4, 2), (4, 3), (3, 3)] for Figure 1(b) starting with the tail and ending with the head. Possible movements for the head are left, right, up and down to reach adjacent fields on the grid. The snake body follows the head movement, meaning starting with $\\&\\#x212f;$ after one step the new snakes $\\&\\#x212f;$' body elements $\\&\\#x212f;\\#x2d;i-1$ now equal $\\&\\#x212f;$i as illustrated in Figures 1(b),1(c)."}, {"title": "3 Formalizing and Winning snake Optimally with ASP", "content": "We introduced the preliminaries and the game snake. We will now move towards defining the game objectives, then presenting strategies and their implementation in ASP.\nGoal Specification. The game itself invokes the implicit goal to maximize the snake length before the game terminates. Our first objective is to guarantee winning the game. This means at every point the snake is able to reach maximal length, independent of apple placement (G1). Second, we aim to minimize the number of snake movements (steps) to finish the game (G2). Third, we aim to minimize the computation time (G3)."}, {"title": "3.1 Problem Description for Iterations", "content": "One snake game consists of n$\\cdot$m-2 iterations of searching a path from a given snake $\\&\\#x212f;$ to a given apple $\\clubsuit$ for given grid dimensions n$\\times$m. Therefore, we can formalize a problem description for one iteration.\nGeneral Snake. Given a path $\\&\\#x212f;$, a goal vertex $\\clubsuit$ $\\in$ {$\\&\\#x212f;_1,..., $\\&\\#x212f;_{|\\&\\#x212f;|$}$}$ on a grid graph G(n,m), derive a path p = [$p_1,..., $\\&\\#x212f;_{|\\&\\#x212f;|},..., p_{|p|}$], such that $p_{|p|}$ = $\\clubsuit$ iff a = |p| and for every 1<j<k<|p| with $p_j$ = $p_k$, then k \u2212 j $\\geq$ |$\\&\\#x212f;$|. \nGeneral Snake has three key points: the path has to start with $\\&\\#x212f;$, the $\\clubsuit$ vertex appears exactly once at the end and if a vertex repeats, enough steps lie between repetitions for the snake to move out of the way. General Snake covers all possible solutions for one iteration of snake."}, {"title": "3.2 Snake Strategies", "content": "To solve a whole snakes game, we will iteratively solve its n$\\cdot$m-2 HS resp. MHS problems (basic setup). Starting in the first iteration with $\\&\\#x212f;$ = [(1, 1)], every iteration has a starting snake $\\&\\#x212f;$ and random apple coordinates $\\clubsuit$ $\\in$ {$\\&\\#x212f;_1,..., $\\&\\#x212f;_{|\\&\\#x212f;|$}$}$ as variable input. From the output path p = [$\\&\\#x212f;_1,..., $\\&\\#x212f;_2, ..., p_j,..., p_{nm}$] with $p_j$ = $\\clubsuit$ we can derive the snake coordinates $\\&\\#x212f;'$ for the next iteration: $\\&\\#x212f;'$ = [$p_{j-|\\&\\#x212f;|},..., p_j$].\nWe will now introduce the naive strategy, which aims to finish the game consistently by solving its HS problems. In the first iteration, the naive strategy derives an HC. This path is followed repeatedly, removing the requirement to generate new HCs altogether. This strategy takes on average $(nm-|\\&\\#x212f;|+1)/2$ steps per iteration. The first HC can be derived in polynomial time, by replicating column two and three and row three from Figure 2(b) for arbitrary grid sizes\u00b2. The number of steps per iteration is bound by the number of fields, consequently putting the naive strategy in polynomial time as well. The naive strategy aims playing safe (G1). To minimize the total number of steps (G2) we introduce the conservative strategy, which allows the HC to change in between iterations. Hence, we follow the basic setup and solve MHS problems. Solving MHS lies in FNPNP, which places the conservative strategy in the same complexity class. Addressing the computation time (G3) we have to discuss and compare different im- plementations and design choices, which will be covered throughout this publication."}, {"title": "3.3 Multi-Shot Implementation Approaches", "content": "By following the conservative strategy, playing snakes boils down to generating HCs efficiently. ASP is well suited for this task, NP-Problems can be easily expressed. Fur- thermore, snake can be implemented quite space efficient as well: Algorithm 1 shows the base logic program for the initial iteration, with head/1 and apple/1 as variable input. field/1 defines the nodes of the grid, connected/2 the edges, next/2 represent the path choices and path/1 ensures a closed cycle. Finally, with mark/1 the path segment between head and apple is marked to be minimized in the last line. In latter iterations, a snake body can be enforced by manipulating corresponding next/2 atoms. ASP base Algorithm 1 can be utilized to iteratively solve snake in different ways. A simple approach is to ground and solve the logical program for each iteration and discard it afterwards (one-shot). However, there are several reasons to reuse a logic program. For instance, time intense grounding or minimal changes can be exploited, especially for iter- ative progressing problems. There are several approaches to reuse a logic program. Main contribution of this work is a compilation and demonstration of different approaches. Therefore, we will now introduce five different clingo implementations to solve snake. Technically, they will mainly differ in the method to manipulate next/2 atoms. An outline of the wrapper functionality for multi-shot approaches can be seen in Al- gorithm 2, which implements the conservative strategy. In Lines 1-3 the logic program, $\\&\\#x212f;$ and step counter are initialized. The initialization (Line 1) for multi-shot approaches includes grounding apple/1 and head/1 as externals:\n#external apple(XY): field(XY).\n#external head(XY) : field(XY).\nWithout these (external) atoms, the optimization statement can not be formulated. In a loop, $\\clubsuit$ is picked at random (Line 5) and corresponding external values for the apple position and snake head are set (Lines 6, 7, 9, 10). The main part is represented by he retrieve function (Line 8). Here, the values of $\\&\\#x212f;$ will be tied to corresponding next/2 atoms from the logic program. Furthermore, the solve process is started and resulting models are managed and converted into paths. The implementation of the retrieve func-"}, {"title": "4 Experimental Evaluation", "content": "Setup. To compare performance of the different approaches, we implemented all five approaches of the conservative strategy and let them solve 100 snake games for different square grid sizes (n = m, n$\\in$ {6, 8, 10, 12, 14, 16}). The experiments run on a MacBook Pro (2017, 16 GB RAM, Intel Core i7, 2.8 GHz), with clingo v. 5.4.0 and python v. 3.7.4. For each run, each of the n$\\cdot$m-2 iterations has a 60 seconds timeout for the solve call. Image generation via clingraph (Hahn et al. 2022) is disabled. We utilize a symmetry breaking method to mirror the grid, such that the head al- ways lies in the first quadrant of the grid. We used ASP-Chef (Alviano et al. 2023) for prototyping of the logic program. Our implementation and logfiles are available online\u00b3.\nEvaluation. We expect snake to be feasible to a certain extend (E1). Furthermore, we expect multi-shot and one-shot to differ performance wise (E2) and we expect multi-shot to outperform one-shot due to the grounding bottleneck (E3). As educated guess, we expect ad hoc to outperform preground based on unused externals (E4). Due to imple- mentation details, we expect assume to terminate slightly faster than nogood (E5). According to our three objectives, we are interested in three features: the win/loose ratio (G1), the number of total steps (G2) and the total time (G3). Since our strategy uses the previous HC as starting model, there is a 100% win ratio and G1 is fully met. For G2, we compare the total number of steps, which are listed in Table 1(a). For most grid sizes the numbers do not vary significantly. This is not surprising, since they implement the same algorithm. However one-shot falls behind for larger grid sizes (n $\\geq$ 14, E2)."}, {"title": "5 Conclusion and Future Work", "content": "This paper aims to compile different ASP multi-shot approaches on an compact and hands-on showcase. While one-shot is straightforward to implement, applications with limited resources (such as timeouts) may substantially benefit from multi-shot imple- mentations, as demonstrated in our evaluation. For our example, the grounding bottle- neck was not an issue due to a minimalistic implementation. one-shot outperformed the multi-shot approaches as long as the timeout was not met. For harder problems, the timeout had a huge impact on the performance. The multi-shot approaches could utilize the search progress from previous solving attempts, reducing the impact of the timeout in the following iterations and therefore outperforming one-shot. The different multi- shot approaches possess varying characteristics, therefore the optimal choice depends on the application and the setup. The approaches ad hoc and assume have indicated stable performance and are comparatively easy to implement.\nFuture work might entail another showcase application to demonstrate performance differences between the different multi-shot approaches. In addition, while the definition of MHS is sound, a different problem description may lead to even shorter paths while still guaranteeing winning the game. An example scenario can be seen in Figure 2(c), where shorter paths to enforcing a win can be derived. For this more sophisticated problem only the snake end positioning has to be able to form an HC. However, this new problem, resulting strategies, extended implementations and additional evaluation go beyond the scope of this paper. Also, the introduced strategies rely on a continuous setting, meaning our strategies can not be started from an arbitrary snake placement as seen in Figure 1(d). Strategies starting with random snake placements may be covered in the future."}]}