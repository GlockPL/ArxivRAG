{"title": "Exploiting Symmetries in MUS Computation", "authors": ["Ignace Bleukx", "H\u00e9l\u00e8ne Verhaeghe", "Bart Bogaerts", "Tias Guns"], "abstract": "In explainable Constraint Solving (XCS), it is common to extract a Minimal Unsatisfiable Subset (MUS) from a set of unsatisfiable constraints. This helps explain to a user why a constraint specification does not admit a solution. Finding MUSes can be computationally expensive for highly symmetric problems, as many combinations of constraints need to be considered. In the traditional context of solving satisfaction problems, symmetry has been well studied, and effective ways to detect and exploit symmetries during the search exist. However, in the setting of finding MUSes of unsatisfiable constraint programs, symmetries are understudied. In this paper, we take inspiration from existing symmetry-handling techniques and adapt well-known MUS-computation methods to exploit symmetries in the specification, speeding-up overall computation time. Our results display a significant reduction of runtime for our adapted algorithms compared to the baseline on symmetric problems.", "sections": [{"title": "1 Introduction", "content": "The field of eXplainable Constraint Solving (XCS) is a sub-field of explainable AI (XAI) focused on explaining the solutions, or lack thereof, of constraint (optimization) problems. Explaining why a set of constraints does not admit a solution is often done through a Minimal Unsatisfiable Subset (MUS), i.e., an irreducible subset of the constraints rendering the problem unsatisfiable. This subset of constraints is then easier for a user to analyze than the full problem. MUSes are also used for debugging constraint models (Leo and Tack 2017), including minimization of faulty models when fuzz testing (Paxian and Biere 2023), explaining why an objective value is optimal (Bleukx et al. 2023) or to explain why a fact follows from the constraints (Bogaerts, Gamba, and Guns 2021).\nMUS computation techniques are well-studied and well-known in the XAI literature. Frequently used algorithms can be classified into shrinking\u00b9 methods (Marques-Silva 2010); divide-and-conquer algorithms such as QuickXplain (Junker 2001) and implicit-hitting-set based methods (Ignatiev et al. 2015).\nIn some cases, it can be useful to not just compute a single MUS but to enumerate a collection of MUSes or even all of them, as some MUSes may be easier understood by a user than others. Many algorithms for computing a set of MUSes rely on the \u201cseed-and-shrink\u201d paradigm (Bend\u00edk and Cern\u00e1 2020a,b), where variants of the MARCO-algorithm are among the most popular techniques (Liffiton et al. 2016). MUS-computation and enumeration techniques have been discussed extensively (Marques-Silva and Menc\u00eda 2020; Gupta, Genc, and O'Sullivan 2021).\nA prime concern for MUS computation and enumeration techniques is efficiency, especially for large problems, as checking if a valid assignment exists for a set of constraints can already be NP-hard (Biere et al. 2021). In practice, many techniques exist to speed up solving, e.g., by exploiting the problem structure. One of these, which has barely been studied in the context of MUS computation, is the exploitation of symmetries in the problem formulation.\nMany real-world problems exhibit some kind of (variable and/or value) symmetry. For example, packing items into equivalent trucks, assigning shifts to equivalent workers or scheduling tasks on equivalent machines. Such symmetries can slow down combinatorial solvers, as they might have to consider all symmetric alternatives to an assignment. Solvers can exploit symmetries to prune the search space and/or speed up the search (Gent, Petrie, and Puget 2006; Sakallah 2021). Symmetry exploitation techniques are either static or dynamic. Static techniques involve adding symmetry breaking constraints to the specification before starting the solver. Dynamic techniques exploit the symmetries during search, e.g., by automatically learning symmetric clauses (Devriendt et al. 2012; Chu et al. 2014; Mears et al. 2014; Devriendt, Bogaerts, and Bruynooghe 2017), by modifying their branching behaviour (Fahle, Schamberger, and Sellmann 2001; Sabharwal 2005) or by generating symmetry breaking constraints during the solvers' execution (Metin et al. 2018). Furthermore, several tools exist for automatically detecting symmetries in the constraint specifications for a variety of input formats (Drescher, Tifrea, and Walsh 2011; Devriendt et al. 2016; Van Caudenberg and Bogaerts 2022; Anders, Brenner, and Rattan 2024).\nWhile symmetry-handling has extensively been studied for methods solving constraint satisfaction or optimization problems, they have barely been studied in the context"}, {"title": "2 Background", "content": "The methods presented in this paper are defined on constraints with Boolean variables only, but they can be generalized to richer constraint-solving paradigms such as SMT, MIP, or CP. In this section, we recall several essential concepts and introduce the notation used throughout this paper.\nA literal $l$ is a Boolean variable $x$ or its negation $\u00acx$. We use $\u03a6$ to represent a set of constraints over Boolean variables. The set of literals in a constraint specification $L(\u03a6)$ contains all variables occurring in $\u03a6$ and their negation. When $\u03a6$ is clear from the context, we simply write $L$. An assignment $\u03b1$ maps Boolean variables in $\u03a6$ to either true or false. An assignment is total if it assigns every variable in $\u03a6$, and partial otherwise. Assignments can be represented as a subset of literals, namely those assigned to true (Audemard and Simon 2018). When a partial assignment \u00b5 can be expanded to a total one while satisfying 6, we write $\\mu\\approx \\phi$.\nModern SAT-solvers allow the use of assumption variables (Nadel and Ryvchin 2012; Hickey and Bacchus 2019). In combination with implication constraints, they can be used to test whether a subset of constraints is satisfiable. For each constraint $c$ in $\u03a6$, we introduce a Boolean indicator variable $a_c$ and use this variable to construct the half-reification of $c$: $a_c \u2192 c$ (Feydy, Somogyi, and Stuckey 2011). We refer to the set of indicators as $A$ and, abusing notation, we refer to the constraint specification $\u03a6$ where all constraints are half-reified using variables $a_c$ as $A \u2192 \u03a6$. Now, any full assignment of $A$ (which is also a partial assignment of $A \u2192 \u03a6$), can be interpreted as a subset of constraints. Namely, a constraint $c$ is part of the subset if its indicator variable $a_c$ is set to true. So, when assuming a subset of literals $A$ to be true, we can test whether a subset of constraints admits a valid assignment using a SAT-solver. Moreover, if no such assignment exists, SAT-solvers can return a sufficient set of assumption variables that cause unsatisfiability. Hence, we assume to have an oracle that takes as input a set of constraints $\u03a6$ and which returns a tuple $(is\\_sat, \u03b1, U)$. Here, $is\\_sat$ is a Boolean flag indicating whether $\u03a6$ is satisfiable. When $is\\_sat$ is set to true, $\u03b1$ is the assignment found by the oracle, and $U \u2286 \u03a6$ is a sufficient subset of constraints causing unsatisfiability otherwise.\nConstraint specifications can exhibit symmetries. We distinguish two types of symmetries: syntactic and semantic.\nDefinition 1 (Syntactic symmetry (Devriendt et al. 2016)). Let $\u03c0$ be a permutation of all literals $L$ in constraints $\u03a6$. A syntactic symmetry of $\u03a6$, is a permutation $\u03c0$ that commutes with negation (i.e., $\u03c0(\u00acl) = \u00ac\u03c0(l)$), and that when applied to the literals in each of the constraints in $\u03a6$, maps $\u03a6$ to itself.\nDefinition 2 (Semantic symmetry (Devriendt et al. 2016)). Let $\u03c0$ be a permutation of all literals $L$ in constraints $\u03a6$. A semantic symmetry of $\u03a6$ is a permutation $\u03c0$ that commutes with negation and that preserves satisfaction to $\u03a6$ (i.e., $\u03c0(\u03b1)$ satisfies $\u03a6$ iff $\u03b1$ satisfies $\u03a6$).\nAny syntactic symmetry is also a semantic symmetry but not vice versa (Sakallah 2021). In practice, most symmetry-detection tools only detect syntactic symmetries (Devriendt et al. 2016), but all concepts in this paper are valid for semantic symmetries too, unless specified otherwise. Therefore, we refer to \"symmetries\" in general in the remainder of this paper. We write permutations using disjoint cycle notation. E.g., $\u03c0 = (abc)(de)$ denotes the permutation with: $\u03c0(a) = b$, $\u03c0(b) = c$, $\u03c0(c) = a$, $\u03c0(d) = e$ and $\u03c0(e) = d$\nSome structured symmetry groups can be summarized as a row-interchangeable symmetry (Flener et al. 2002; Devriendt, Bogaerts, and Bruynooghe 2014).\nDefinition 3 (Row-interchangeability). A matrix $M = (x_{rc})$ of literals describes a row-interchangeability symmetry group if for each permutation \u03c1 of its rows, $\u03c0_\u03c1: x_{rc} \\mapsto x_{\u03c1(r)c}$ is a symmetry of $\u03a6$.\nThe last required concept in this paper is that of Minimal Unsatisfiable Subsets (MUS) (Marques-Silva 2010).\nDefinition 4 (Minimal Unsatisfiable Subset). A Minimal Unsatisfiable Subset (MUS) of a set of constraints $\u03a6$ is a set $U \u2286 \u03a6$ that is unsatisfiable and for which any proper subset $U' \u2282 U$ is satisfiable.\nInformally, an MUS is a minimal set of constraints that renders the problem unsatisfiable. Note that there may be several MUSes for a given unsatisfiable constraint problem."}, {"title": "3 Symmetries for the MUS problem", "content": "In this section, we define symmetries of the MUS problem. Solving the MUS problem requires reasoning over subsets of constraints, whereas the traditional setting of solving a satisfaction problem requires reasoning over assignments. Hence, symmetries for the MUS problem are symmetries of constraints.\nNote that any syntactic symmetry of variables in a set of constraints induces a symmetry of constraints (Cohen et al. 2006), as illustrated below.\nExample 1 (Pigeon hole problem). Consider a pigeon-hole problem $php(p, h)$ with $p$ pigeons and $h$ holes:\n$\\sum_{j=1}^{h} x_{ij} \\geq 1 \\quad \\forall i \\in \\{1,...,p\\} \\quad \\quad (P_i)$\n$\\sum_{i=1}^{p} x_{ij} \\leq 1 \\quad \\forall j \\in \\{1,...,h\\} \\quad \\quad (H_j)$\nWhere $x_{ij}$ are Boolean variables indicating whether pigeon $i$ is assigned to hole $j$. We refer to the constraint that"}, {"title": "3.1 Computing constraint symmetries", "content": "We propose to use existing symmetry-detection tools such as BREAKID (Devriendt et al. 2016), which traditionally detect symmetries of variable assignments, and transform the input to these tools to detect symmetries in constraints. In particular, we introduce indicator variables $a_c$ to construct $A \u2192 \u03a6$ as defined in Section 2.\nBefore introducing symmetries that can be used when computing MUSes, we generalize the concept of symmetries of assignments to symmetries of partial assignments.\nDefinition 5 (Partial symmetries). Let $S \u2286 L(\u03a6)$ be a subset of all literals $L(\u03a6)$, closed under negation. A partial S-symmetry of a specification $\u03a6$ is a permutation of $S$ that commutes with negation and that preserves satisfiability to $\u03a6$. That is, for any assignment \u00b5 of $S$, $\u03bc \\approx \u03c6$ iff $\u03c0(\u03bc) \\approx \u03c6$.\nSome tools allow us to search for partial symmetries explicitly, but they can be derived from \u201cclassical symmetries\" as in Definitions 1 and 2, as the following holds.\nProposition 1 (Deriving partial symmetries). Let S be a subset of L($\u03a6$) closed under negation and \u3160 a symmetry of \u03c6. If \u03c0(S) = S, then \u03c0|s is a partial S-symmetry of \u0444.\nWe are now ready to fully define the concept of constraint symmetries as used in this paper.\nDefinition 6 (Constraint symmetry). A permutation \u3160 of the constraints in $\u03a6$ is called a constraint symmetry for $\u03a6$ if for any subset C\u2286 \u03c6, \u03c0(C) is satisfiable iff C is satisfiable.\nThe following proposition describes the exact relation between partial-symmetries and constraint symmetries.\nProposition 2. Let \u3160 be a permutation of variables (that is a permutation of literals that does not cross polarity) A in A \u2192 \u03c6, then \u3160 directly maps to a permutation of constraints \u03c0\u03c6. Under this mapping, \u03c0 is an A-symmetry iff n is a constraint symmetry.\nIntuitively, a subset of indicators \u201cenables\u201d a set of constraints and, when this initial set is (un)satisfiable, so is the set of constraints that is enabled by their symmetric image. Hence, by computing partial symmetries of the specification $A \u2192 \u03a6$, we can compute constraint symmetries using any existing tool supporting it. We refer to the above method of finding constraint symmetries as CONSTRAINTSYMMETRIES($\u03a6$).\nFollowing Proposition 3, constraint symmetries map MUSes to MUSes and non-MUSes to non-MUSes.\nProposition 3. Given a constraint symmetry of & and a subset U \u2286 $. Then, \u03c0(U) is an MUS of & if and only if U is an MUS of $."}, {"title": "4 Constraint symmetries in MUS algorithms", "content": "Once detected, symmetries can be exploited to speed up the search for valid assignment(s) that satisfy \u03a6. Static techniques include adding symmetry breaking constraints to the constraints specification before solving. Such constraints can speed-up the search by excluding a part of the search space. A well-known symmetry breaking constraint is the Lex-Leader constraint, which excludes, given an order of the variables, any assignment $\u03b1$ if its symmetric counterpart $\u03c0(\u03b1)$ is lexicographically below $\u03b1$. Symmetry detection tools can often generate a set of breaking constraints along with the generators for each detected symmetry group. Symmetry breaking constraints may break the symmetry completely or only partially (McDonald 2002).\nDynamic symmetry handling involves modifying the search algorithm of the solver itself to exploit the symmetries in the constraints. For example, by avoiding symmetric branches in the search tree or by modifying propagation algorithms to exploit symmetries in the problem specifically. While symmetry handling techniques have been extensively studied in the context of solving constraint programs, they do not directly apply to finding MUSes.\nIn particular, by adding a set of symmetry breaking constraints $B$ to constraints $\u03a6$, any MUS of the \u201cbroken specification\" will be a subset of $U \\cup B$. This means that $U \\cup B$ can contain more MUSes than the original set of constraints, and new MUSes do not necessarily map to an original MUS.\nIn this section, we generalize symmetry handling techniques to constraint symmetries for use in MUS-finding algorithms. We explore both static symmetry breaking and techniques to exploit symmetries dynamically."}, {"title": "4.1 Symmetric transition constraints", "content": "One of the simplest classes of algorithms for finding an MUS are \u201cshrinking\u201d based methods (Marques-Silva 2010; Wieringa 2014). These methods iteratively drop a constraint c from \u03a6, and call an oracle to check whether the remainder is (un)satisfiable. If the remaining core is still UNSAT, the constraint can safely be dropped from the formula. Otherwise, the constraint is required to ensure the unsatisfiability of the core and is marked as such (line 6 in Algorithm 1). When a constraint is marked as required, it is called a transition constraint (Belov and Marques-Silva 2011).\nDefinition 7 (Transition constraint). Given an unsatisfiable set of constraints U containing constraint c. If U \\ {c} is satisfiable, c is called a transition constraint.\nBelov, Lynce, and Marques-Silva (2012) propose an optimization to this simple approach called clause set refinement. This technique exploits the core found by the solver after it decides the input is unsatisfiable. In particular, the core returned by the solver may be smaller than the working core at that point in the algorithm. Hence, we can use the solver core $U'$ to further shrink the working core. This technique is shown on line 13 in Algorithm 1.\nTo exploit symmetries in shrinking-based methods, we use the set of symmetry generators directly. In particular, we mark symmetric counterparts of transition constraints. We illustrate this in Example 2."}, {"title": "4.2 Symmetry breaking in MUS-computation", "content": "In this section, we investigate how symmetry breaking can be used to speed-up MUS computation. That is, instead of finding any MUS, we search for a lex-minimal MUS.\nExample 3 (Lex-minimal MUS). Given the set of MUSes from Example 1, and the following constraint order:\n$P_1 < P_2 < P_3 < P_4 < H_1 < H_2$\nThen {P1, P2, P3, H1, H2} is the only lex-minimal MUS.\nLex-minimal MUSes can be computed using the Quick-Xplain algorithm. QuickXplain takes as input a partial ordering of constraints and computes a preferred MUS based on that ordering. Hence, when providing an ordering mapping to the lex-leadership relation, QuickXplain finds a lex-minimal MUS. However, such ordering is often not reported by symmetry detection tools as they internally use the order to construct a set of breaking constraints, which can be used for static symmetry breaking. Therefore, we do not consider the QuickXplain algorithm here and instead focus on methods that can directly use symmetry breaking constraints returned by the detection tool. In particular, instead of finding any MUS, we search for an Optimal Constrained Unsatisfiable Subset (OCUS) (Gamba, Bogaerts, and Guns 2023).\nDefinition 8 (OCUS). Given a set of constraints $\u03a6$, a cost function f: 2 \u2192 N and predicate p : 2 \u2192 {false, true}. Then $U \u2286 \u03a6$ is an OCUS with respect to $f$ and $p$ if:\n\u2022 U is unsatisfiable\n\u2022 p(U) is true\n\u2022 for all other unsatisfiable subsets $U' \u2286 \u03a6$ for which p(U') holds, f(U) \u2264 f(U')\nIn this paper, we use the concept of an OCUS to find an MUS with minimal cardinality by using a linear cost function $f$ with equal weights. Combined with a set of constraint"}, {"title": "4.3 Enumeration of symmetric MCSes", "content": "Implicit Hitting Set algorithms for computing MUSes are based on the hitting set dualization as stated in Proposition 5. They construct the set of minimal correction subsets lazily, by iteratively calling a hitting set solver and computing one or more correction subsets from the given hitting set. In general, the more correction subsets can be added in each iteration of the algorithm, the fewer iterations are required to find an MUS. Indeed, as shown by Ignatiev et al. (2015), enumeration of disjoint MCSes using for example Algorithm 3, significantly improves the algorithm's runtime.\nOur contribution in this section also adds more MCSes in a single iteration of the algorithm. We propose to use the symmetry-groups detected directly by enumerating symmetric images of correction subsets (line 8 of Algorithm 2 when the dynamic? flag is enabled).\nWe illustrate our idea in the following example:\nExample 5. Take again the running example of php(4, 2). Imagine the sets to hit at some point in the algorithm are:\n{H1}, {P1, P2}\nThen, a minimal hitting set is {H1, P\u2081}, and from this subset, we can compute a minimal correction subset, for example, {P2, P3}. As all pigeon constraints are interchangeable, we can find the symmetric versions of the above MCS:\n{P1, P2}, {P1, P3}, {P1, P4}, {P2, P4}, {P3, P4}\nBy adding all of these correction subsets to the sets to hit, the hitting set computed in the next iteration of the algorithm is guaranteed to include at least 3 out of the 4 pigeon constraints, as required in any MUS for this problem.\nNote that the number of symmetric MCSes may be exponential. Therefore, enumerating all of the MCSes can actually slow down the algorithm instead. Either because just enumerating them is hard, or because the hitting set solver is slowed down significantly by the surplus in sets to hit. In the experimental section, we evaluate several settings of the algorithm to investigate good values for the upper bound on the number of symmetric MCSes to add in each iteration.\nIn the implementation of the algorithm, we avoid re-generating MCSes by keeping track of the global set H."}, {"title": "4.4 Symmetries for MUS-enumeration", "content": "The previous sections describe modifications to algorithms for computing one MUS. In some applications, users may be interested in a collection of MUSes instead. To this end, Liffiton et al. (2016) proposed the MARCO algorithm (Algorithm 4).\nSimilar to the IHS algorithm presented before, the MARCO algorithm is based on the hitting set dualization of MUSes and MCSes (Proposition 5) and explores the power-set of all constraints in an efficient way. In particular, instead of calculating a minimal hitting set to the set of correction subsets, MARCO computes any hitting set (line 3 in Algorithm 4), which is called the seed. Next, a SAT oracle is invoked to check whether the computed seed is satisfiable. If this is the case, the seed is used to calculate a correction subset, which is then added to the hitting-set solver. When the seed is unsatisfiable, it is shrunk further down to an MUS, and the hitting-set-solver is instructed to exclude any superset of the found MUS as next seeds.\nWhen many symmetries are present in the constraint specification, the problem may contain many MUSes that are similar from a user perspective (Leo et al. 2024). To reduce the cognitive load on a user, we propose to use symmetry breaking constraints in the map-solver to specify a preference on the seed to compute from the map. This modification will only generate seeds that adhere to the lex-leadership relation defined by the symmetry breaking constraints, and hence the number of MUSes enumerated by the algorithm is reduced. When the full set of MUSes is required for the application at hand, it can be reconstructed in post-processing based on Proposition 3. This is similar to how symmetries are used when counting solutions to a satisfaction problem (Wang et al. 2020).\nNote that any method may be used to grow and shrink the seed in the MARCO algorithm. Therefore, any symmetry-related optimizations to either shrinking or growing-algorithms may directly benefit the performance of MARCO as well. E.g., for shrinking, one can use SYMM-SHRINK (Algorithm 1) and for growing similar symmetry-inspired techniques can be devised."}, {"title": "5 Experiments", "content": "In this section, we evaluate our proposed modifications to algorithms for MUS-computation and enumeration on a set of benchmark instances. We aim to answer the following experimental questions:\nEQ1 To what extent is making MUS-computation symmetry-aware beneficial in terms of runtime?\nEQ2 How can symmetries be used for MUS enumeration?\nEQ3 How do MUS-computation algorithms benefit from the detection of row-interchangeability symmetries?\nWe run all methods presented in this paper on unsatisfiable constraint problems encoded as pseudo-Boolean problems. Our benchmark consists of 272 instances with 146 pigeon-hole problems, 66 n+k-queens problems, and 60 bin-packing problems.\nWe implemented\u00b2 all MUS-finding algorithms on top of the CPMpy constraint modeling library (Guns 2019), version 0.9.20 in Python 3.10.14. Pseudo-Boolean solver Exact v1.2.1 (Devriendt 2023; Elffers and Nordstr\u00f6m 2018) is used as SAT-oracle and Gurobi v11.0.2 as hitting-set-solver. Symmetries are computed using a custom branch of BREAKID\u00b3 (Devriendt et al. 2016). All methods were run on a single core of an Intel(R) Xeon(R) Silver 4214 CPU with 128GB of memory on Ubuntu 20.04. We used a time-out of 1h which includes symmetry-detection by BREAKID and unrolling to symmetric MUSes in LEX-MARCO."}, {"title": "5.1 MUS computation", "content": "Figure 1 shows the runtime of all methods for computing MUSes discussed in this paper. We first focus on Figure 1a, which compares the runtime of shrink-based methods. We compare the default algorithm (Shrink), the version removing symmetric transition constraints (Symm-Shrink), and its version when recomputing symmetries in each iteration of the algorithm (Symm-ShrinkR). For both symmetry-aware algorithms, we also compare the runtime when instructing BreakID to detect no row-interchangeability symmetries.\nWe can clearly see the removal of symmetric transition constraints is beneficial for the runtime of the algorithm as Symm-Shrink solves all instances between 5 and 10 times faster compared to the default. Still, the detection of row-interchangeability symmetries is essential for a successful implementation of this approach. For most instances in our benchmarks, recomputing symmetries in each iteration of the algorithm proves to be less efficient, even compared to the default algorithm (EQ3)."}, {"title": "5.2 MUS enumeration", "content": "We use the MARCO algorithm and Lex-MARCO with post-processing to unroll the set of lex-minimal MUSes to the full set. Both algorithms used the non-symmetric version of SHRINK for shrinking and the BLS procedure from Marques-Silva et al. (2013) for growing. Figure 2 shows the number of MUSes enumerated within 1h. From the left-hand side, it is clear the number of MUSes computed from the lex-minimal seeds is reduced for most of the instances compared to running vanilla MARCO. Instances found above the diagonal timed out for MARCO and the number of MUSes enumerated so far was smaller than the number of MUSes computed from the lex-minimal seeds by Lex-MARCO."}, {"title": "6 Conclusion and outlook", "content": "In this paper, we propose various modifications to algorithms for finding MUSes inspired by symmetry breaking in SAT-and PB-solving. We demonstrated how to use off-the-shelf symmetry-detection tools to find symmetries in constraint specifications and how to use those symmetries in MUS computation techniques. Our results show that the presence of symmetry can indeed slow down MUS-finding algorithms, and symmetry handling methods are essential for finding MUSes quickly. This paper opens the door for future symmetry-inspired enhancements for computing MUSes, and as a next step, we plan to implement our methods into an existing state-of-the-art MUS finder. This allows us to evaluate our methods on competition benchmarks and compare them to other techniques, such as model rotation."}, {"title": "A Proofs", "content": "Proposition 1 (Deriving partial symmetries). Let $S$ be a subset of $L(\u03a6)$ closed under negation and \u3160 a symmetry of \u03c6. If \u03c0(S) = S, then \u03c0|s is a partial S-symmetry of \u0444.\nProof. Let \u00b5 be any assignment of S (which is a partial assignment of the set of all variables). We need to show that \u00b5\\approx \u03c6iff \u03c0(\u03bc) \u2248 \u03c6. First assume \u03bc\u2248 \u03c6. In this case there is an a that extends \u03bc and such that a = \u03c6. But this means that \u03c0(\u03b1) is a complete assignment that extends \u03c0(\u03bc) and since \u03c0 is a symmetry, \u03c0(\u03bc) = \u03c6, so indeed \u03c0(\u03bc) \u2248 \u03c6. For the other direction, if \u03c0(\u03bc) \u2248 \u03c6 there is an a that extends \u03c0(\u03bc) and satisfies \u03c6. But then \u03c0\u22121(a) extends \u03bc and also satisfies, which indeed shows that \u03bc\u2248 \u03c6.\nProposition 2. Let \u3160 be a permutation of variables (that is a permutation of literals that does not cross polarity) A in A \u2192 \u03c6, then \u3160 directly maps to a permutation of constraints \u03c0\u03c6. Under this mapping, \u03c0 is an A-symmetry iff & is a constraint symmetry.\nProof. Let \u00b5 be an assignment of A and let $C_\u03bc \u2286 \u03c6$ be the set of constraints activated by \u03bc. If \u03c0 does not cross polarity, then each positive literal in \u03bc is mapped by \u03c0 to exactly one other positive literal in \u03bc, thus \u03c0(\u03bc) activates a new set of constraints \u03c0\u03c6(C\u03bc). If \u03c0 is a an A-symmetry, \u00b5 can be extended to a full assignment iff \u03c0(\u03bc) can. Hence, C\u00b5 is satisfiable iff \u03c0\u03c6(C\u00b5) is satisfiable, ensuring \u03c0\u4f48 is a constraint symmetry.\nFor the reverse mapping: if \u03c0\u03c6 is a constraint symmetry, and C is satisfiable, then clearly the partial assignment of \u03bc and \u03c0(\u03bc) can be extended to a full assignment, namely a solution to C and \u03c0(C) respectively. If C is unsatisfiable, then \u03bc and \u03c0(\u03bc) cannot be extended to a full solution."}, {"title": "B Example of a row-interchangeability symmetry", "content": "Consider the row-interchangeability symmetry as defined by the following matrix.\n$\\begin{bmatrix}a_{11} & a_{12} & a_{13} \\\\ a_{21} & a_{22} & a_{23} \\\\ a_{31} & a_{32} & a_{33} \\\\ a_{41} & a_{42} & a_{43} \\\\ \\end{bmatrix}$\nWhen executing SYMM-SHRINK, consider the current core to be $U = \\{a_{11}, a_{12}, a_{21}, a_{22}, a_{32}, a_{41}, a_{42}, a_{43}\\}$ and a transition constraint corresponding to the indicator variable $a_{12}$. Then, the only symmetry mapping U to U defined by the matrix is swapping the first and second rows. Hence, the only symmetric transition constraint is the one corresponding to $a_{22}$."}, {"title": "C Benchmarks", "content": "In this section, we provide the detailed description of the benchmarks used in this paper. All benchmarks are derived from those used in the literature, with minor modifications in order to make the models unsatisfiable.\nPigeon hole problem We generated instances of saturated pigeon-hole problems, ranging from 5 to 150 pigeons with in increments of 2. For each number of pigeons, the number of holes were limited to #pigeons-2 and #pigeons-3. This results in a total benchmark set of 146 instances.\n$\\sum_{j=1}^{h} x_{ij} \\geq 1 \\quad \\forall i = 1..p \\quad \\quad (P_i)$\n$\\sum_{i=1}^{p} x_{ij} \\leq 1 \\quad \\forall j = 1..h \\quad \\quad (H_j)$"}, {"title": "N+k-queens", "content": "The n-queens problem is a classic problem when investigating symmetries in constraint satisfaction problems. The problem consists of finding an arrangement of n queens on an\u00d7n dimensional chess-board, in such a way that no two queens can attach each other. In the unsatisfiable variant, we enforce k queens extra on the board. We generated 66 instances, with n ranging from 4 to 25 and k set to 2, 3 or 4.\n$\\sum_{i=1}^{n} x_{ij} \\leq 1, \\forall j = 1..n$\n$\\sum_{j=1}^{n} x_{ij} \\leq 1, \\forall i = 1..n$\n$\\sum_{i=1}^{n-j+1} Xi+j-1, 1 \\leq 1, \\forall j = 1..n$\n$\\sum_{i=1}^{n-j+1} Xn-i-j+2,i \\leq 1, \\forall j = 1..n$\n$\\sum_{i=1}^{n-j+1} Xi+j-1,n-i+1 \\leq 1, \\forall j = 2..n$\n$\\sum_{i=1}^{n-j+1} Xn-i-j+2,n-i+1 \\leq 1, \\forall j = 2..n$\n$\\sum_{i=1}^{n} \\sum_{j=1}^{n} x_{ij} = n + k$"}, {"title": "Binpacking", "content": "Bin-packing considers the problem of packing n items with a given value (size) into b equivalent bins with a fixed capacity c. The goal is to find an allocation of items to bins such that the number of used bins is minimized. We generate 60 instances similar to the approach in (Schwerin and W\u00e4scher 1997). We range the number of bins from 5 to 25 and sample the size of each item from U(5, 10). The capacity of each bin is fixed to 25 and the problems are made unsatisfiable by limiting the number of available bins to 70, 80 or 90% of the required number of bins.\n$\\sum_{i=1}^{n} Wij Xij \\leq c, \\forall j = 1..b$"}]}