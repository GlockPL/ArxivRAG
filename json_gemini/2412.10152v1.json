{"title": "Direct Encoding of Declare Constraints in ASP\u2021", "authors": ["FRANCESCO CHIARIELLO", "VALERIA FIONDA", "ANTONIO IELO", "FRANCESCO RICCA"], "abstract": "Answer Set Programming (ASP), a well-known declarative logic programming paradigm, has recently found practical application in Process Mining. In particular, ASP has been used to model tasks involving declarative specifications of business processes. In this area, Declare stands out as the most widely adopted declarative process modeling language, offering a means to model processes through sets of constraints valid traces must satisfy, that can be expressed in Linear Temporal Logic over Finite Traces (LTLf). Existing ASP-based solutions encode Declare constraints by modeling the corresponding LTLf formula or its equivalent automaton which can be obtained using established techniques. In this paper, we introduce a novel encoding for Declare constraints that directly models their semantics as ASP rules, eliminating the need for intermediate representations. We assess the effectiveness of this novel approach on two Process Mining tasks by comparing it with alternative ASP encodings and a Python library for Declare. Under consideration in Theory and Practice of Logic Programming (TPLP).", "sections": [{"title": "1 Introduction", "content": "In the context of process mining, a process typically refers to a sequence of events or activities that are performed in order to accomplish a particular goal within a business or organizational setting (Van der Aalst and Weijters 2004). Process Mining (van der Aalst 2022) is an interdisciplinary field offering techniques and tools to discover, monitor, and improve real processes by extracting knowledge from event logs readily available in today's information systems. One of the main tasks of Process Mining is conformance checking, assessing the correctness of a specific execution of a process, known as trace, against a process model. Such a process model is a formal mathematical representation enabling various analytical and reasoning tasks related to the underlying process. Process models adopt either an imperative or a declarative language form, with the former explicitly describing all possible process executions, and the latter using logic-based constraints to define what is not permitted within process executions. Imperative process models are suitable for well-structured routine processes but often fall short in scenarios involving complex coordination patterns. Declarative models, conversely, offer a flexible alternative in such scenarios.\nLinear temporal logic over finite traces (LTLf) (De Giacomo and Vardi 2013) has emerged"}, {"title": "2 Preliminaries", "content": "In this section fundamental concepts related to Process Mining, linear temporal logic over finite traces, the Declare process modeling language, and Answer Set Programming are discussed."}, {"title": "2.1 Process Mining", "content": "Process Mining (van der Aalst 2022) is a research area at the intersection of Process Science and Data Science. It leverages data-driven techniques to extract valuable insights from operational processes by analyzing event data (i.e., event logs) collected during their execution. A process can be seen as a sequence of activities that collectively allow to achieve a specific goal. A trace represents a concrete execution of a process recording the exact sequence of events and decisions taken in a specific instance. Process Mining plays a significant role in Business Process Management (Weske 2019), by providing data-driven approaches for the analysis of events logs directly extracted from enterprise information systems. Typical Process Mining tasks include: Conformance checking that aims at verifying if a trace is conformant to a specified model and, for logic-based techniques, Query Checking that evaluates queries (i.e., formulae incorporating variables) against the event log. Several formalisms can be used in process modelling, with Petri nets (van der Aalst 1998) and BPMN (Chinosi and Trombetta 2012) being among the most widely used, both following an imperative paradigm. Imperative process models explicitly describe all the valid process executions and can be impractical when the process under consideration is excessively intricate. In such cases, declarative process modelling (Di Ciccio and Montali 2022) is a more appropriate choice. Declarative process models specify the desired properties (in terms of constraints) that each valid process execution must satisfy, rather than prescribing a step-by-step procedural flow. Using declarative modeling approaches allows to easily specify the desired behaviors: everything that does not violate the rules is allowed. Declarative specifications are expressed in Declare (van der Aalst et al. 2009), LTL over Finite Traces (LTLf) (Finkbeiner and Sipma 2004), or LTL over Process Traces (LTLp) (Fionda and Greco 2018)."}, {"title": "2.2 Linear Temporal Logic over Finite Traces", "content": "This section recaps minimal notions of Linear Temporal Logic over Finite Traces (LTLf) (De Giacomo and Vardi 2013). We introduce finite traces, the logic's syntax and semantics, then informally describe its temporal operators, and some Process Mining application-specific notation.\nFinite Traces. Let A be a set of propositional symbols. A finite trace is a sequence \u03c0 =\n\u03c0\u2080\u00b7\u00b7\u00b7 \u03c0\u2099\u208b\u2081 of n propositional interpretations \u03c0\u1d62 \u2286 A, i = 0, ..., n \u2212 1, for some n \u2208 N. The interpretation \u03c0\u1d62 is also called a state, and |\u03c0| = n denotes the trace length.\nSyntax. LTLf is an extension of propositional logic that can be used to reason about temporal properties of traces. It shares the same syntax as Linear Temporal Logic (LTL) (Pnueli 1977), but it is interpreted over finite traces rather than infinite ones. An LTLf formula \u03c6 over A is defined according to the following grammar:\n\u03c6 ::= T | a | \u00ac\u03c6 | \u03c6 \u2227 \u03c6 | X\u03c6 | \u03c6\u2081U\u03c6\u2082,\nwhere a \u2208 A. We assume common propositional (\u2228, \u2192, \u2194, etc.) and temporal logic shorthands. In particular, for temporal operators, we define the eventually operator F\u03c6 = TU\u03c6, the always operator G\u03c6 = \u00acF\u00ac\u03c6, the weak until operator \u03c6W\u03c6' = G\u03c6 \u2228 \u03c6U\u03c6' and weak next operator Xw\u03c6 = \u00acX\u00ac\u03c6 = X\u03c6 \u2228 \u00acXT."}, {"title": "2.3 Declare modeling language", "content": "Declare (van der Aalst et al. 2009) is a declarative process modeling language that consists of a set of templates that express temporal properties of process execution traces. The semantics of each Declare template is defined in terms of an underlying LTLp formula. Declare templates can be classified into four distinct categories, each addressing different aspects of process behavior: existence templates, specifying the necessity or prohibition of executing a particular activity,"}, {"title": "3 Translation-based ASP encodings for Declare", "content": "This section introduces ASP encodings for conformance checking of Declare models and query checking of Declare constraints with respect to an input event log, based on the translation to automata and syntax trees. Both encodings share the same input fact schema to specify which Declare constraints belong to the model, or which constraint we are performing query checking against. These encodings are indirect, since they rely on a translation, but also general in the sense that they can be applied to the evaluation of arbitrary LTLp formulae. This is achieved, in the case of the syntax tree encoding, by reifying the syntax tree of a formula and by explicitly modeling the semantics of each LTLp temporal operator through a logic program, and in the case of the automaton encoding, by exploiting the well-known LTLp-to-automaton translation (Chiariello et al. 2023; De Giacomo and Vardi 2013). Thus, one can use these two encodings to represent Declare constraints by their LTLp definitions. The automaton-based encoding is adapted from (Chiariello et al. 2022), the syntax tree-based encoding is adapted from (Kuhlmann et al. 2023; Kuhlmann and Corea 2024) \u2013 integrating changes to allow for the above-mentioned shared fact schema and evaluation over multiple traces. A similar encoding has also been used in (Ielo et al. 2023) to learn LTLf formulae from sets of example traces (using the ASP-based inductive logic programming system ILASP (Law 2023)) and to implement an ASP-based LTLf bounded satisfiability solver (Fionda et al. 2024).\nEarlier work in answer set planning (Son et al. 2006) also exploited LTL constraints using a similar syntax tree-reification approach. We start by defining how event logs and Declare constraints are encoded into facts, then introduce conformance checking and query checking encodings with the two approaches."}, {"title": "3.1 Encoding process traces and Declare models", "content": "Encoding process traces. For our purposes, an event log L is a multiset of process traces, thus a multiset of strings over an alphabet of propositional symbols A (representing activities). We assume that each trace \u03c0 \u2208 L is uniquely indexed by an integer, and we denote that the trace \u03c0 has index i by id(\u03c0) = i. This is a common assumption in Process Mining, where i is referred to as the trace identifier. Traces are modeled through the predicate trace/3, where the atom trace(i,t,a) encodes that \u03c0t = a,id(\u03c0) = i that is, the t-th activity in the i-th trace is a. Given a process trace \u03c0, we denote by E(\u03c0) the set of facts that encodes it. Thus, an event log L is encoded as E(L) = \u222a\u03c0\u2208L E(\u03c0).\nEach Declare template, informally, can be understood as a \u201cLTLp formula with variables\u201d. Substituting these variables with activities yields a Declare constraint. How templates are instantiated into constraints, and how constraints are evaluated over traces, depends on the ASP encoding we use. However, all encodings share a common fact schema where constraints are expressed as templates with bound variable substitutions.\nEncoding Declare constraints. A Declare constraint is modeled by predicates constraint/2 and bind/3. The former model which Declare template a given constraint is instantiated from and the latter which activity-variable bindings instantiate the constraint. An atom constraint(cid, template) encodes that the constraint uniquely identified by cid is an instance of the template template. The atom bind(cid,arg, value) encodes that the constraint uniquely identified by cid is obtained by binding the argument arg to the activity value. Given a Declare model M =\n{C1,...,cn}, where the subscript i uniquely indexes the constraint ci, we denote by E(M) the set of facts that encodes M, that is E(M) = \u222ac\u2208M E(c). Recall that in Declare \u03c0 |= M if and only if \u03c0 |= c for all c \u2208 M, thus there is no notion of \u201corder\u201d among the constraints within M and it does not matter how indexes are assigned to constraints as long as they are unique."}, {"title": "3.2 Encoding Conformance Checking", "content": "All the Declare conformance checking encodings we propose consist of a stratified normal logic program (Lloyd 1987; Apt et al. 1988) P\nCF such that given a log L and a Declare model M we have that for all \u03c0\u1d62 \u2208 L, \u03c0\u1d62 |= c\u2c7c \u2208 M if and only if the unique model of PCF \u222a E(M) \u222a E(L)"}, {"title": "3.3 Encoding Query Checking", "content": "The query checking problem takes as input a Declare template I, an event log L and consists in deciding which constraints c can be instantiated from I such that \u03c3(c, L) \u2265 k, where \u03c3(c, L)\nis the support and denotes the fraction of traces in L that are models of c. The problem has been formally introduced in (Chan 2000) for temporal logic formulae, and in (R\u00e4im et al. 2014) it has been framed into a Process Mining setting, in the context of LTLf. An ASP-based solution to the"}, {"title": "4 Direct ASP encoding for Declare", "content": "The encodings described in previous section are general techniques that enable reasoning over arbitrary LTLp formulae. Both encodings require, respectively, to keep track of each subformula evaluation on each time-point of a trace in the case of the syntax-tree encoding, and to keep track of DFA state during the trace traversal, in the case of the automaton encoding. However, Declare patterns do not involve complex temporal reasoning, with deep nesting of temporal operators. Hence Declare templates admit a succinct and direct encoding in ASP that does not keep track of such evaluation at each time-point of the trace. The encoding discussed in this section exploits this, providing an ad-hoc, direct translation of the semantics of Declare constraints into ASP rules.\nThe general approach we follow in defining the templates, is to model cases in which constraints fail through a fail/2 predicate. In our encoding, a constraint c over a trace tid holds true if we are unable to produce the atom fail(c,tid). Due to the activation-target semantics of Declare templates, sometimes it is required to assert that an activation condition is matched in the suffix of the trace by a target condition. In the encoding, this is modeled by the witness/3 predicate. This mirrors the activation and target concepts in the definition of Declare constraints. Note that, this approach is not based on a systematic, algorithmic rewriting, but on a template-by-template ad-hoc analysis. In the rest of the section, we show the principles behind our ASP encoding for the Declare templates in Table 1.\nResponse template. Recall from Table 1 that Response(a,b) is defined as the LTLp formula G(a \u2192 Fb), whose informal meaning is that whenever a happens, b must happen somewhere in the future. Thus, every time we observe an a at time t, in order for Response(a, b) to be true, we have to observe b at a time instant t' > t. The first rule below encodes this situation. If we observe at least one a that is not matched by any b in the future, the constraint fails, as encoded in the second rule. The following equivalences exploit the duality of temporal operators G, and F:\n\u00acG(a \u2192 Fb) = F\u00ac(a \u2192 Fb) = F\u00ac(\u00aca \u2228 Fb) = F(a \u2227 \u00acFb)\nPrecedence template. Recall from Table 1 that the constraint Precedence(x, y) is defined as the LTLp formula \u00acyWx = G(\u00acy) \u2228 \u00acyUx, whose informal meaning is that if y occurs in the trace, x must have happened before. Notice that in order to witness the failure of this constraint, it is enough to reason about the trace prefix up to the first occurrence of y, since in the definition of the template the until operator is not under the scope of a temporal operator. The following equivalences hold:\n\u00ac(\u00acyWx) = \u00ac(G(\u00acy) \u2228 \u00acyUx) = \u00acG(\u00acy) \u2227 \u00ac(\u00acyUx) = Fy \u2227 \u00ac(\u00acyUx) = Fy \u2227 yR\u00acx\nAlternate Response template. Recall from Table 1 that AlternateResponse(a,b) is defined as the LTLp formula G(a \u2192 X(\u00acaUb)), whose informal meaning is that whenever a happens, b must happen somewhere in the future and, up to that point, a must not happen. Failure conditions follow from the this chain of equivalences:\n\u00acG(a \u2192 X(\u00acaUb) = F(a \u2227 \u00acX(\u00acaUb)) = F(a \u2227 Xw\u00ac(\u00acaUb)) = F(a \u2227 Xw(aR\u00acb))\nAlternatePrecedence template. Recall from Table 1 that the constraint AlternatePrecedence(x,y) is defined as the LTLp formula\n(\u00acyWx) \u2227 G(b \u2192 Xw(\u00acyWx)) = Precedence(a,b) \u2227 G(b \u2192 XwPrecdence(a,b))\nwhose informal meaning is that every time y occurs in the trace, it has been preceded by x and no\nChainResponse template. Recall that from Table 1 that the constraint ChainResponse(x,y) is defined as the LTLp formula G(x \u2192 Xy), whose informal meaning is that whenever x occurs, it must be immediately followed by y. The failure conditions follow from the following chain of equivalences:\n\u00ac(G(x \u2192 Xy)) = F\u00ac(x \u2192 Xy) = F\u00ac(\u00acx \u2228 Xy) = F(x \u2227 \u00acXy) = F(x \u2227 Xw\u00acy)\nChainPrecedence template. Recall that from Table 1 that the constraint ChainResponse(x, y) is defined as the LTLp formula G(Xy \u2192 x) \u2227 \u00acb, whose informal meaning is that whenver y occurs, it must have been immediately preceded by x. The failure conditions follow from the following"}, {"title": "5 Experiments", "content": "In this section, we report the results of our experiments comparing different methods to perform conformance checking and query checking of Declare models, using the ASP-based representations outlined in the previous sections and Declare4Py, a recent Python library for Declare-based process mining tasks which also implements - among other tasks, such as log generation and process discovery - conformance checking and query checking functionalities. While the approaches discussed here are declarative in nature, Declare4Py implements Declare semantics by imperative procedures, based on the algorithms in (Burattin et al. 2016), that scan the input traces."}, {"title": "5.1 Conformance checking & Query checking on real-world logs", "content": "Conformance Checking. We consider the conformance checking tasks (Li,M), with M \u2208 {C\u2070.\u00b2\u2075, C\u2070.\u2075\u2070, C\u2070.\u2077\u2075, CIV}, over the considered logs and its Declare models. Figure 7 reports the solving times for each method in a cactus plot. Recall that a point (x,y) in a cactus plot represents the fact that a given method solves the x-th instance, ordered by increasing execution times, in y seconds. Table 3 reports the same data aggregated by the event log dimension, best run-time in bold. Overall, our direct encoding approach is faster than the other ASP-based encodings as well as D4Py on considered tasks. ASP\nCF and D4Py perform similarly, whereas ASP is less efficient. It must also be noticed that D4Py, beyond computing whether a trace is compliant or not with a given constraint, also stores additional information such as the number of times a constraint is violated, or activate, while the ASP encodings do not. However, the automata and direct encoding can be straightforwardly extended in such sense; in particular, similar \u201cbook-keeping\" in the direct encoding is performed by the fail/3 and witness/3 atoms.\nQuery Checking. We consider the query checking instances (t, Li, s) where t is a Declare template, from the ones defined in Table 1, s \u2208 {0.50,0.75, 1.00} is a support threshold, and Li is a log. Figure 8 summarizes the results in a cactus plot, and Table 4 aggregates the same data on the log dimension, best runtime in bold. ASP is again the best method overall, outperforming other ASP-based methods with the exception of ASP\nCF on the RP log tasks. Again, ASP\nCF and D4Py perform similarly and ASP is the worst.\nDiscussion. In the comparative evaluation of the different methods for conformance and query checking tasks, our direct encoding approach ASP showed better performance compared to"}, {"title": "5.2 Behavior on longer traces", "content": "Lastly, we analyze how the automata-based and direct ASP encodings scale w.r.t the length of the traces. We generate synthetic event logs (details in the appendix) of 1000 traces of fixed length (up to 1000 events) for each constraint, and we perform conformance checking with respect to a single constraint, chosen among the Response and Precedence hierarchies. Table 7 reports the result of our experiment. We compare only automata and direct encodings, since the previous"}, {"title": "6 Conclusion", "content": "Declare is a declarative process modeling language, which describes processes by sets of temporal constraints. Declare specifications can be expressed as LTLp formulae, and traditionally have been evaluated by executing the equivalent automata (Di Ciccio and Montali 2022), regular expressions (Di Ciccio and Mecella 2015), or procedural approaches (de Leoni and van der Aalst 2013). Translation-based approaches (on automata, or syntax trees) are at the foundation of existing ASP-based solutions (Chiariello et al. 2022; Kuhlmann et al. 2023). This paper proposes a novel direct encoding of Declare in ASP that is not based on translations. Moreover, for the first time, we put on common ground (regarding input fact schema) and compare available ASP solutions for conformance checking and query checking. Our experimental evaluation over well-known event logs provides the first aggregate picture of the performance of the methods considered. The results show that our direct encoding, albeit limited to Declare, outperforms other ASP-based methods in terms of execution time and peak memory consumption and compares favourably with dedicated libraries. Thus, ASP provides a compact, declarative, and efficient way to implement Declare constraints in the considered tasks. Interesting future avenues of research are to investigate whether this approach can be extended to data-aware (de Leoni and van der Aalst 2013) variants of Declare that take into account data attributes associated to events in a trace, to probabilistic extensions of Declare (Alviano et al. 2024; Vespa et al. 2024; Alman et al. 2022) that associate uncertainty (in terms of probabilities) to constraints in a declarative process model, as well as other Declare-based Process Mining tasks."}, {"title": "Appendix A Validation", "content": "In this paper, we do not investigate whether there exists an automatic translation from arbitrary LTLf or LTLp into ASP rules (beyond indirect techniques), but we focus solely on the Declare constraints, providing ad-hoc encodings written by hand w.r.t their informal semantics. To validate the correctness of these encodings, in our use case, we applied a bounded model checking-like approach, searching for a \u201cbehavioral counterexample\u201d between our encoding of each particular constraint and a ground truth logic program - which corresponds to the logic program that captures the behavior of the state machine which is equivalent to the LTLp definition of the constriant at hand. That is, given a Declare constraint c, we consider its LTLp definition \u03c6 and its corresponding DFA M\u03c6, and its direct encoding Pc. In particular, if we are able to find a trace \u03c0 such that \u03c0 |= Pc, but \u03c0 \u2209 L(\u03c0) - or viceversa, \u03c0 \u2226 Pc but \u03c0 \u2208 L(\u03c0) - then \u03c0 is a witness of the fact that our direct encoding Pe for the Declare constraint c encodes a wrong behavior (accepting a trace it should not accept, or rejecting a trace it should accept). We tested our encodings for counterexamples of length up to 20 over the {a,b, *} alphabet, where a plays the role of the constraint activation, b its target, and * a placeholder for \"other characters\". As discussed in the automata encoding section, if two propositional symbols do not appear in a LTLp formula, they are interchangeable in a trace and won't alter the satisfaction of the trace."}, {"title": "Appendix B Synthetic Log Generation", "content": "To generate synthetic traces for our experiment, we use the following logic program. Each stable model corresponds to a unique trace. For each constraint in Table 1, we generate a log of 1000 traces (half positive, half negative) over an alphabet of 15 activities. To generate positive traces, we set the external atom negative to false, to generate negative traces we set the negative external atom to true using the Clingo Python API. The constant t represents the length of each trace, it is set as runtime as well. The input facts are the encoding of a Declare constraint, along with the logic program which encodes the semantics (either the automata, syntax tree or direct one)."}, {"title": "Appendix C An example use case for Declare-based process mining", "content": "This is an example application of Declare, regarding the Sepsis Cases Event Log (Mannhardt and Blinde 2017). The log contains events logged by the information system of a dutch hopsital, concerning patients with a diagnosis/suspected diagnosis of sepsis. Here is the official description of the event log: This real-life event log contains events of sepsis cases from a hospital. Sepsis is a life threatening condition typically caused by an infection. One case represents the pathway through the hospital. The events were recorded by the ERP (Enterprise Resource Planning) system of the hospital. There are about 1000 cases with in total 15,000 events that were recorded for 16 different activities. Moreover, 39 data attributes are recorded, e.g., the group responsible for the activity, the results of tests and information from checklists. Events and attribute values have been anonymized. The time stamps of events have been randomized, but the time between events within a trace has not been altered. Suppose we are interested in conformance checking the log traces against the Declare model containing the constraints:\n\u2022 Precedence(Antibiotics, IVLiquid)\n\u2022 ExclusiveChoice(ReleaseA, ReleaseB)\n\u2022 ChainPrecedence(ERTriage,AdmissionIC)\nThe model states that the activities ReleaseA, ReleaseB (e.g., releasing a patient from the hospital with different types of diagnosis) are mutually exclusive. Admission in the intensive care unit (AdmissionIC) should be immediately preceded by a triage (ERTriage); The IV Liquid (IV Liquid) exam should not be performed before patients undergo Antibiotics. A Declare model could be either designed by a domain expert, according to e.g. its clinical practice, or clinical guidelines, or discovered automatically from data. Conformance checking allows to identify which traces are compliant, or non-compliant, with the given model, and understand which constraints are violated. To run this example:\nclingo example_1/*\nSuppose instead we are interested in all the activities that immediately follow the admission in intensive care (AdmissionIC) in at most 30% of the log. This could be useful for clinicians to analyze if clinical practices are correctly being followed. This amounts to performing the query"}, {"title": "Appendix D. Encodings", "content": "All the encodings are available under the folders ltlf_base (syntax tree encoding), automata (automata encoding), and asp_native (direct encoding) in our repository. Each folder contains a templates. 1p file, which are the set of facts that encode the Declare templates as sketched in Section 3 (e.g., automata transition tables and syntax tree reification - notice this file is empty for the direct encoding), and a semantics.lp file which encode logic programs to evaluate automata runs over traces (for the automata encoding), temporal logic operators' semantics as normal rules (for the syntax tree encoding) and the direct translation of Declare into ASP rules for the direct encoding. For completeness, we report here the contents of asp_native semantics.lp, along with pictures that map each constraints' failure conditions to ASP rules.\nFor all constraints, a constraint c holds over a trace tid if we derive the sat (c,tid) atom, that is, if we are unable to show a failure condition for c over tid:"}, {"title": "D.1 Response-based templates", "content": "D.1.1 Response"}, {"title": "D.2 Precedence-based templates", "content": "D.2.1 Precedence\nWe use a dedicated rule to model that x never occurs, when it does not exist, the #min aggregate would yield the term #sup."}, {"title": "D.2.2 Alternate Precedence", "content": ""}, {"title": "D.2.3 Chain Precedence", "content": ""}, {"title": "D.3 Succession-based templates", "content": "Recall that Succession templates are defined as the conjunction of the corresponding Precedence, Response templates at the same level of the subsumption hierarchy (see Figure 2). Hence, its failure conditions are the union of the failure conditions of its subformulae.\nD.3.1 Succession"}, {"title": "D.3.2 Alternate Succession", "content": ""}, {"title": "D.3.3 Chain Succession", "content": ""}, {"title": "D.4 Choice, Existence templates", "content": "This set of templates, the most general ones in Declare, at the bottom of the subsumption hierarchy, do not involve temporal operators in their LTLp definition, but only atomic operators (e.g., activity occurrences in the whole trace). They are easily seen as projections on the trace/3 predicate."}]}