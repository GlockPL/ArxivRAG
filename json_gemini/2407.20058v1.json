{"title": "Shapley Value Computation in Ontology-Mediated Query Answering", "authors": ["Meghyn Bienvenu", "Diego Figueira", "Pierre Lafourcade"], "abstract": "The Shapley value, originally introduced in cooperative game theory for wealth distribution, has found use in KR and databases for the purpose of assigning scores to formulas and database tuples based upon their contribution to obtaining a query result or inconsistency. In the present paper, we explore the use of Shapley values in ontology-mediated query answering (OMQA) and present a detailed complexity analysis of Shapley value computation (SVC) in the OMQA setting. In particular, we establish a FP/#P-hard dichotomy for SVC for ontology-mediated queries (T, q) composed of an ontology T formulated in the description logic ELHI\u2081 and a connected constant-free homomorphism-closed query q. We further show that the #P-hardness side of the dichotomy can be strengthened to cover possibly disconnected queries with constants. Our results exploit recently discovered connections between SVC and probabilistic query evaluation and allow us to generalize existing results on probabilistic OMQA.", "sections": [{"title": "Introduction", "content": "The Shapley value was originally proposed in the context of cooperative game theory as a method for fairly distributing the wealth of a coalition of players based upon their respective contributions. It has appealing theoretical properties, having been shown to be the unique wealth distribution measure that satisfies a set of desirable axioms. Since its proposal in (Shapley 1953), it has found application in numerous domains, including various areas of computer science. In artificial intelligence, the Shapley value has been utilized for defining inconsistency measures of propositional (Grant and Hunter 2006; Hunter and Konieczny 2010) and description logic knowledge bases (Deng, Haarslev, and Shiri 2007), and more recently for defining explanations of machine learning models (Lundberg and Lee 2017). The Shapley value has also gained attention in the database area (Bertossi et al. 2023), where it has been employed both for defining inconsistency values of databases (Livshits and Kimelfeld 2022) and also for providing quantitative explanations of query answers (Livshits et al. 2021). While other quantitative measures, such as causal responsibility and the Banzhaf power index (aka causal effect), have also been considered for databases, the Shapley value has thus far garnered the most attention. We direct readers to (Livshits et al. 2021; Abramovich et al. 2024) for more details on alternative measures and how they relate to the Shapley value.\nIn general, Shapley value computation is known to be computationally challenging, being #P-hard in data complexity for common classes of queries, such as conjunctive queries. This has motivated non-uniform complexity studies aimed at pinpointing which queries admit tractable Shapley value computation (Reshef, Kimelfeld, and Livshits 2020; Khalil and Kimelfeld 2023), in particular, by establishing fruitful connections with probabilistic query evaluation and variants of model counting (Deutch et al. 2022; Kara, Olteanu, and Suciu 2023; Bienvenu, Figueira, and Lafourcade 2024).\nIn the present paper, we revisit the use of the Shapley value in the ontology setting, building upon these recent advances in the database area. We shall mostly focus on how the Shapley value can be employed for explaining answers in the context of ontology-mediated query answering (OMQA). We recall that the OMQA is used to improve access to incomplete and possibly heterogeneous data through the addition of ontology layer, which provides a user-friendly vocabulary for query formulation as well as domain knowledge that is taken into account when computing the query answers. Over the past fifteen years, OMQA has grown into a vibrant research topic within both the KR and database communities (Poggi et al. 2008; Cal\u00ec et al. 2011; Mugnier and Thomazo 2014; Bienvenu and Ortiz 2015; Xiao et al. 2018). With the increasing maturity and deployment of OMQA techniques, there is an acknowledged need to help users understand the query results. Various notions of explanations with different levels of detail can be considered for OMQA, ranging from providing proofs of how an answer can be derived (Liebig et al. 2008; Alrabbaa et al. 2022) to generating minimal subsets of the KB that suffice to obtain the answer or identifying the assertions and/or axioms that are relevant in the sense that they belong to such a minimal subset (Bienvenu, Bourgaux, and Goasdou\u00e9 2019; Ceylan et al. 2019; Ceylan et al. 2020). The Shapley value offers a more nuanced, quantitative version of the latter approach, by assigning the relevant assertions and axioms scores based upon their level of responsibility or importance in obtaining the considered query answer (or entailment).\nFor our study of Shapley value computation, we will work with description logic (DL) knowledge bases (KB), consisting of an ABox (dataset) and TBox (ontology). We introduce some natural ways of defining the Shapley value computation (SVC) problem in the DL setting, by varying what is to be explained (entailment of a TBox axiom, ABox assertion, or query answer), which parts of the KB are assigned values, and how the complexity is measured. To begin our study, we establish the #P-hardness of the Shapley value computation of a simple graph reachability query, which we then employ to show #P-hardness of several variants of the SVC problem, even for inexpressive DLs and atomic queries. In light of these initial negative results, we embark on a non-uniform complexity analysis, whose aim is to classify the data complexity of the Shapley value computation problems SVCQ associated with each ontology-mediated query (OMQ) Q = (T, q). By transferring recent results from the database setting, we establish a FP/#P-hard dichotomy result of Shapley value computation problem SVC for OMQs Q = (T, q) where the TBox T is formulated in the Horn DL ELHI\u2081 and q is a constant-free connected homomorphism-closed query. Moreover, if restricted to the case where q is a conjunctive query, then the dichotomy is effective, i.e. we can decide whether SVCQ is ELHI_ or #P-hard. Our final and most technically challenging result is to show that the #P-hardness part of the dichotomy can be strengthened to cover OMQs based upon a wider range of queries q. Specifically, we show that for any OMQ Q = (T, q) based upon a ELHI\u2081 TBox and a UCQ q (which may be disconnected and/or contain constants), non-FO-rewritability of Q implies #P-hardness of SVCQ. Due to the tight connections holding between Shapley value computation and probabilistic query evaluation, the proof of this result can be further used to obtain a ELHI\u2081/#P-hard dichotomy for probabilistic ontology-mediated queries from (ELHI, UCQ), substantially generalizing existing results.\nThe paper is structured as follows. Section 2 introduces key notions from databases and description logics, and Section 3 defines Shapley values and recalls useful results about Shapley values in databases. We also prove a new hardness result for graph reachability queries, which we apply in Section 4 to show hardness of Shapley value computation in various ontology settings. In Section 5, we present our ECHI\u2081/#P-hard dichotomy result for OMQs in the Horn DL ELHI\u2081, and in Section 6, we strengthen the #P-hardness result to cover a wider range of queries. We conclude the paper in Section 7 with a summary of our contributions and a discussion of future work.\nSome proof details have been omitted for lack of space, but they are provided in the appendix."}, {"title": "Preliminaries", "content": "We recall some important notions related to description logics (DLs), databases, queries, and complexity, directing readers to (Baader et al. 2017) for a detailed introduction to DLs. Our presentation of DLs and databases slightly differs from the 'usual' ones so as that we may employ some definitions and notations in both settings.\nDatabases A database D is a finite set of relational facts P(d), where P is a k-ary symbol drawn from a countably infinite set of relation symbols ND and a is a k-ary tuple of (individual) constants drawn from a countably infinite set N\u2081. We shall also consider extended databases which may contain infinitely many facts P(a), and where the elements of @ are drawn from N\u2081 and from a countably infinite set Nu of unnamed elements. The domain dom(D) of D contains all constants and unnamed elements occurring in D, and we use const(D) for the constants in D. When D is a database, dom(D) = const(D).\nA homomorphism from an extended database D to an extended database D' is a function h : dom(D) \u2192 dom(D') such that P(h(a)) \u2208 D' for every P(a) \u2208 D. We write D hom D' to indicate the existence of such an h. If additionally h(c) = c for every c E C\u2229 const(D), with CC N\u2081, then we call h a C-homomorphism and write D Chom D'. We say that a (possibly extended) database D is connected if so is the underlying undirected graph with vertices dom(D) UD and edges {(ai, P(a1,...,ak)) |\nP(\u03b11,...,\u03b1\u03ba) \u2208 D}. The connected components of D are the maximal subsets of D that occur within a connected component of the associated graph.\nQueries In the most general sense, a k-ary query (k \u2265 0) can be defined as a function q that maps every extended database D to a set of k-tuples of constants from const(D) (the answers to q). Queries of arity 0 are called Boolean. When q is a Boolean query, each D is mapped either to {()} or {}. In the former case, we say that D satisfies q and write D= q. If additionally D' \u00a5 q for every D' \u2286 D, then we shall call D a minimal support for q.\nA Boolean query q is said to be closed under homomorphisms, or hom-closed, if D = q and D hom\u203a D' implies that D' = q. The notion of C-hom-closed is defined analogously using thom in place of hom. When q is (C-)hom-closed, D = q iff D contains some minimal support for q.\nSo far we have considered an abstract notion of query, but in practice, queries are often specified in concrete query languages. First-order (FO) queries are given by formulas in first-order predicate logic with equality, whose relational atoms are built from predicates from ND and terms drawn from N\u2081 U Ny, with Ny a countably infinite set of variables, equipped with standard FO logic semantics (i.e. D = q if D, viewed as a first-order structure, satisfies the FO sentence q). Two prominent classes of FO queries are conjunctive queries (CQs), and unions of conjunctive queries (UCQs) which are finite disjunctions of CQs having the same free variables. We remark that Boolean (U)CQs without constants are hom-closed, and Boolean (U)CQs with constants in Care C-hom-closed. Other examples of (C)-hom-closed queries include Datalog queries and regular path queries.\nDL Knowledge Bases A DL knowledge base (KB) K = (A, T) comprises an ABox (dataset) A and a TBox (ontology) T, which are built from countably infinite sets Nc of concept names (unary predicates) and N\u20a8 of role names (binary predicates) with NC UNRC ND, and the individual constants from N\u2081. An ABox is a database with relations drawn from NcU NR and thus contains two kinds of facts: concept assertions A(c) (A \u2208 Nc, c\u2208 N\u2081) and role assertions r(c, d) (r \u2208 N\u20a8, c, d \u2208 N\u2081). A TBox is a finite set of axioms, whose form is dictated by the DL in question. We use L TBox to refer to a TBox formulated in the DL L. For example, in the DL ELHI considered later in this paper, complex concepts are constructed as follows:\n$\u0421 := \u0422 \\vert \u0410 \\vert \u0421 \\sqcap \u0421' \\vert \\exists R.C$\n$A \\in N_C, R \\in N_{\\mathcal R}$\nwhere $N_\\mathcal R = N_R \\cup \\{r^- \\vert r \\in N_R\\}$, and ELHI\u300d TBoxes consist of concept inclusions $C \\sqsubseteq D$ (with C, D complex concepts) and role inclusions $R \\sqsubseteq S$ with R, S \u2208 N\uc9f8. We shall also consider DL-Litecore TBoxes, which are composed of concept inclusions of the form\n$B_1 \\sqsubseteq (-)B_2\\quad B_1 := A \\vert\\exists R.\\top\\quad A\\in N_C, R\\in N_\\mathcal R$\nThe semantics of DL KBs is defined using interpretations 1 = (\u0394\u00b9, .1), where \u2206\u00b9 \u2286 N\u013bU N\u016b is a non-empty set and .I a function that maps every A \u2208 Nc to a set A\u00b9 \u2286 \u0394\u0399 and every r\u2208 NR to a binary relation r\u00b9 \u2286 \u25b3 \u00d7 \u25b31. The function is straightforwardly extended to interpret complex concepts and roles: $\u0422^1 = \u0394^1, (\u0421 \\sqcap D)^1 = C^1 \u2229 D^1$, $(\\exists R.C)^1 = \\{d \\vert \\exists e \\in C s.t. (d, e) \\in r^1\\}$, $(-G)^1 = \u0394^1 \\setminus G^1$, and $(r^-)^2 = \\{(e,d) \\vert (d,e) \\in r\\}$. Note that by requiring that \u2206 CN U Nu, we ensure that every interpretation I can be viewed as an extended database D\u2081 = {A(e) | e \u2208 AZ} \u222a {r(d,e) | (d, e) \u2208 r}, and we shall view I as an extended database when convenient.\nAn interpretation I satisfies a (concept or role) inclusion G\u2286 HifGI \u2286 H\u00b9, and it satisfies an assertion A(c) (resp. r(c, d)) if c \u2208 AZ (resp. (c, d) \u2208 r\u00b9). We call I a model of a TBox T if it satisfies every axiom in T, a model of an ABox A if it satisfies every assertion in A, and a model of a KB (A, T) if it is a model of both T and A. We use Mod(K) for the set of models of a KB K. A KB K is consistent if Mod(K) \u2260 0 (else it is inconsistent). An ABox A is T-consistent when the KB (A, T) is consistent. An axiom a is entailed from a TBox T, written T = a, if every model of T satisfies a, and an axiom or assertion a is entailed from a KB K, written K = a, if every model of K satisfies a.\nQuerying DL KBS We say that a Boolean query q is en-tailed from a DL KB K, written K = q, if D1 = q for every I \u2208 Mod(K). The certain answers to a non-Boolean k-ary query q(x) w.r.t. a KB K = (A, T) are the k-tuples \u1ea3 of constants from const(A) such that K = q(a), with q(a) the Boolean query obtained by substituting a for the free variables 7. Note that when the KB is inconsistent, every Boolean query is trivially entailed, so every possible tuple a of ABox constants counts as a certain answer.\nWhile it is traditional to view queries as being posed to the KB, it is sometimes more convenient to adopt a database perspective and treat T and q together as constituting a composite ontology-mediated query (OMQ) Q = (T, q), which is posed to the ABox A. When we adopt this perspective, we will write A = (T, q) or A = Q to mean (A,T) = q. When convenient, we will use the notation (L, Q) to designate the class of all OMQs (T, q) such that T is formulated in the DL L and q is a query from the class of queries Q.\nA prominent technique for computing certain answers (or checking query entailment) is to rewrite an OMQ into another query that can be directly evaluated using a database system. Formally, we call a query q*(x) a rewriting of an OMQ (T, q) if for every ABox A and candidate answer \u00e3:\n$A \\models (T, q(\\bar{a})) \\text{ iff } A \\models q^*(\\bar{a})$\nIf we modify the above definition to only quantify over T-consistent ABoxes, then we speak instead of a rewriting w.r.t. consistent ABoxes. When q* is a first-order query, we call it a first-order (FO) rewriting. If an OMQQ possesses an FO-rewriting, we say that Q is FO-rewritable, else it is called non-FO-rewritable.\nIn Horn DLs, like ELHI\u2081 and DL-Litecore, every consistent KB K = (A, T) admits a canonical model IA,T with \u25b3IA,TC const(A) U N\u016b with the special property that it embeds homomorphically into every model of K. More precisely, DIAT Chom D\u2081 for every I \u2208 Mod(K) and every CC Nj. While the definition of IA,T depends on the particular Horn DL, the construction typically involves completing the ABox by adding tree-shaped structures using unnamed elements to satisfy the TBox axioms in the least constrained way possible. Importantly, if K = (A, T) admits a canonical model IA,T, then for every C-hom-closed query q (with CC N\u2081):\n$K\\models q(a) \\text{ iff } I_{A,T} \\models q(a)$\nIn particular, this holds when q is a (U)CQ.\nComplexity We assume familiarity with FP, the set of functions solved in polynomial-time; and #P, the functions which output the number of accepting runs in polynomial-time nondeterministic Turing machines. We will work with polynomial-time Turing reductions between computational tasks, and we write P\u2081 =P P2 to denote that there are polynomial-time algorithms to compute Pi using unit-cost calls to P3-i, for both i \u2208 {1, 2}."}, {"title": "Shapley Value: Definition & Basic Results", "content": "In this section, we formally define the Shapley value, recall relevant existing results, and prove a new intractability result for computing Shapley values in reachability games.\n3.1 Definition of Shapley Value\nThe Shapley value (Shapley 1953) was introduced as a means to fairly distribute wealth amongst players in a a cooperative game, based upon their respective contributions. A cooperative game consists of a finite set of players P and a wealth function v : (P) \u2192Q that assigns a value to each coalition (i.e., set) of players, with v(0) = 0. Picture a scenario where the players arrive one by one in a random order, and each one earns what she added to the current coalition's wealth on arrival. The Shapley value of a player p\u2208 P is defined as her expected earnings in this scenario, which can be expressed as:\n$Sh(P, v, p) := \\frac{1}{\\vert P\\vert !} \\sum_{\\sigma\\in S(P)} (v(\\sigma_{\\leq p}) - V(\\sigma_{<p}))$  (1)\nwhere S(P) denotes the set of permutations of P and <p (resp. p) the set of players that appear before p (resp. before or at p) in the permutation \u03c3. Intuitively, we take the average marginal contribution v (\u03c3\u2264p) \u2013 v (\u03c3<p) of player p, across all possible orderings o of the players. Eq. (1) can be equivalently reformulated as:\n$\\sum_{B \\subset P \\setminus \\{p\\}} \\frac{\\vert B\\vert!(P - B - 1)!}{\\vert P\\vert !} (v(B\\cup \\{p\\}) - v(B))$ (2)\nwhich will be more convenient in our proofs.\n3.2 Existing Results from the Database Setting\nThere has been significant interest lately in the problem of computing the Shapley value of database facts as a means of quantifying their contributions to a query answer. The formal setting is as follows: the database D is partitioned into endogenous and exogenous facts, D = Dn Dx, the players of the cooperative game are the endogenous facts Dn, and the wealth function of a given Boolean query q is defined, for every subset BC Dn of endogenous facts, as vq(B) =\nUx where UB = 1 (resp. vx = 1) if Dx \u222a B = q (resp. if Dx = q), and 0 otherwise. Shap-ley value computation on q, denoted SVCq, is the problem of computing the Shapley value Sh(Dn, vq, a) for the input partitioned database DnDx and fact a \u2208 Dn. We will write SVC to refer to the task when restricted to purely endogenous databases, i.e., partitioned databases with only endogenous assertions (of the form D = (Dn, Dx) with Dx = 0).\nProbabilistic Query Evaluation We will exploit known connections between SVC and probabilistic query evaluation. A tuple-independent probabilistic database is a pair D = (S, \u03c0) where S is a database and \u3160 : S \u2192 (0, 1] is a probability assignment. For a Boolean query q, Pr(D = q) is the probability of q being true, where each assertion a has independent probability \u03c0(\u03b1) of being in the database. The problem of computing, given a tuple-independent probabilistic database D, the probability Pr(D = q) is known as the probabilistic query evaluation problem, or PQEq. We consider three restrictions of PQEq, by limiting the probabilities that appear in the image Im(\u03c0) of the probability assignment of the input probabilistic database:\n\u2022 PQEq(1/2): input (S, \u03c0) is such that Im(\u03c0) = {1/2};\n\u2022 PQEq(1/2; 1): input (S, \u03c0) is such that Im(\u03c0) = {1/2, 1};\n\u2022 single proper probability query evaluation (SPPQE): input (S, \u03c0) is s.t. Im(\u03c0) = {p, 1} for some p \u2208 (0, 1].\nThese restricted versions of PQE can be also found in the literature under the names of their counting problem counterparts: PQE(1/2) is also known as the \u201cmodel counting", "uniform reliability": "roblems, and PQE(1/2; 1) as the", "counting": "roblem.\nKnown results In (Livshits et al. 2021), a FP/#P-hard dichotomy was established for self-join-free CQs (i.e. not having two atoms with the same relation name). The dichotomy coincides with the FP/#P-hard dichotomy for PQE (Dalvi and Suciu 2004), and the tractable queries admit a syntactical characterization, known as hierarchical queries. In fact, the PQE dichotomy extends to the more general class of UCQs (Dalvi and Suciu 2012), where the queries for which PQE is tractable are known as safe UCQs (hence, in particular hierarchical CQs are safe). However, it is an open problem whether UCQs (or even CQs with self-joins) also enjoy a dichotomy for SVC. Concretely, it is unknown if SVC is #P-hard for all unsafe UCQs (or even CQs).\nRecent work has clarified the relation between the two dichotomies by reducing SVC to PQE (Deutch et al. 2022) and reproving the hardness of SVC (Kara, Olteanu, and Suciu 2023) by reduction from the same model counting problem for Boolean functions that had been used to show hardness of PQE for non-hierarchical self-join-free CQs (Dalvi and Suciu 2004). Further, SPPQE and SVC have been shown to be polynomial-time inter-reducible for many fragments of hom-closed queries (Bienvenu, Figueira, and Lafourcade 2024), in particular for connected queries without constants.\nTheorem 1. (Bienvenu, Figueira, and Lafourcade 2024, Corollaries 4.1 and 4.2) For every connected hom-closed Boolean query q, SPPQEq =P SVCq; further, on graph databases, SVCq is in FP if q is equivalent to a safe UCQ and #P-hard otherwise.\nIn the context of the previous statement, a graph database is a database restricted to relations of arity 1 or 2 (hence an ABox can be seen as a graph database). The result above relies crucially on the #P-hardness of PQE(1/2) (and hence of SPPQE) for non-FO-rewritable (a.k.a. unbounded) hom-closed queries on graph databases (Amarilli 2023), and the FP/#P-hard dichotomy of PQE(1/2; 1) for UCQs (Dalvi and Suciu 2012; Kenig and Suciu 2021).\n3.3 Hardness of SVC for Reachability Games\nThis subsection shows the #P-hardness of the Shapley value computation of graph reachability, which, as we shall see in Section 4, implies the #P-hardness of several problems in the setting of ontologies.\nConsider the Boolean query st-reach which asks whether there is a directed path from a vertex s to a vertex t in a (directed) graph. A graph can be seen as a graph database using a single binary relation, and s, t are individuals. As we show next, computing the Shapley value for this simple query is already #P-hard, even in the restricted case of purely endogenous databases.\nProposition 2. SVCst-reach is #P-hard."}, {"title": "Shapley Values in the Ontology Setting and First Intractability Results", "content": "Now that we that have seen how the Shapley value has been applied in the database setting"}, ".", 14, 4, ".", 1, 2, 2, 4, "alues", "14/24", "6/24", "2/24", 4.0, 1, 2, 3, 4, 1.0, 1, 2, ".", ".", ".", ".", "ACB(S)", 1, {"": "vs = vx where vs = 1 (resp. vx = 1) if (Ax U (S\u2229 An)"}, {"": "let G = (V", "TG": {"A": {"ingredients": "poulardeNantua HasIngr crayfish and poulardeNantua HasSauce nantuaSauce Hasingr crayfish.\nIn terms of complexity the problem will once again be #P-hard due to reachability", "": {"An": {"cs": "c. Then define the purely exogenous TBox T := {BND \u2286 A", "ontologies": "nProposition 7. The problem of computing Shapley values of CQs of the form A(c) (with A \u2208 Nc and c\u2208 N\u2081) over partitioned KBs on DL-Litecore is in FP when restricted to KBs with only exogenous TBox axioms.\nProof. Note that one can compute", "relevance": "in Example 3"}}}}}]}