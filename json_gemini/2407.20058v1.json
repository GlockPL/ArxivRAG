{"title": "Shapley Value Computation in Ontology-Mediated Query Answering", "authors": ["Meghyn Bienvenu", "Diego Figueira", "Pierre Lafourcade"], "abstract": "The Shapley value, originally introduced in cooperative game theory for wealth distribution, has found use in KR and databases for the purpose of assigning scores to formulas and database tuples based upon their contribution to obtaining a query result or inconsistency. In the present paper, we explore the use of Shapley values in ontology-mediated query answering (OMQA) and present a detailed complexity analysis of Shapley value computation (SVC) in the OMQA setting. In particular, we establish a FP/#P-hard dichotomy for SVC for ontology-mediated queries (T, q) composed of an ontology T formulated in the description logic ELHI\u2081 and a connected constant-free homomorphism-closed query q. We further show that the #P-hardness side of the dichotomy can be strengthened to cover possibly disconnected queries with constants. Our results exploit recently discovered connections between SVC and probabilistic query evaluation and allow us to generalize existing results on probabilistic OMQA.", "sections": [{"title": "1 Introduction", "content": "The Shapley value was originally proposed in the context of cooperative game theory as a method for fairly distributing the wealth of a coalition of players based upon their respective contributions. It has appealing theoretical properties, having been shown to be the unique wealth distribution measure that satisfies a set of desirable axioms. Since its proposal in (Shapley 1953), it has found application in numerous domains, including various areas of computer science. In artificial intelligence, the Shapley value has been utilized for defining inconsistency measures of propositional (Grant and Hunter 2006; Hunter and Konieczny 2010) and description logic knowledge bases (Deng, Haarslev, and Shiri 2007), and more recently for defining explanations of machine learning models (Lundberg and Lee 2017). The Shapley value has also gained attention in the database area (Bertossi et al. 2023), where it has been employed both for defining inconsistency values of databases (Livshits and Kimelfeld 2022) and also for providing quantitative explanations of query answers (Livshits et al. 2021). While other quantitative measures, such as causal responsibility and the Banzhaf power index (aka causal effect), have also been considered for databases, the Shapley value has thus far garnered the most attention. We direct readers to (Livshits et al. 2021; Abramovich et al. 2024) for more details on alternative measures and how they relate to the Shapley value.\nIn general, Shapley value computation is known to be computationally challenging, being #P-hard in data complexity for common classes of queries, such as conjunctive queries. This has motivated non-uniform complexity studies aimed at pinpointing which queries admit tractable Shapley value computation (Reshef, Kimelfeld, and Livshits 2020; Khalil and Kimelfeld 2023), in particular, by establishing fruitful connections with probabilistic query evaluation and variants of model counting (Deutch et al. 2022; Kara, Olteanu, and Suciu 2023; Bienvenu, Figueira, and Lafourcade 2024).\nIn the present paper, we revisit the use of the Shapley value in the ontology setting, building upon these recent advances in the database area. We shall mostly focus on how the Shapley value can be employed for explaining answers in the context of ontology-mediated query answering (OMQA). We recall that the OMQA is used to improve access to incomplete and possibly heterogeneous data through the addition of ontology layer, which provides a user-friendly vocabulary for query formulation as well as domain knowledge that is taken into account when computing the query answers. Over the past fifteen years, OMQA has grown into a vibrant research topic within both the KR and database communities (Poggi et al. 2008; Cal\u00ec et al. 2011; Mugnier and Thomazo 2014; Bienvenu and Ortiz 2015; Xiao et al. 2018). With the increasing maturity and deployment of OMQA techniques, there is an acknowledged need to help users understand the query results. Various notions of explanations with different levels of detail can be considered for OMQA, ranging from providing proofs of how an answer can be derived (Liebig et al. 2008; Alrabbaa et al. 2022) to generating minimal subsets of the KB that suffice to obtain the answer or identifying the assertions and/or axioms that are relevant in the sense that they belong to such a minimal subset (Bienvenu, Bourgaux, and Goasdou\u00e9 2019; Ceylan et al. 2019; Ceylan et al. 2020). The Shapley value offers a more nuanced, quantitative version of the latter approach, by assigning the relevant assertions and axioms scores based upon their level of responsibility or importance in obtaining the considered query answer (or entailment).\nFor our study of Shapley value computation, we will work with description logic (DL) knowledge bases (KB), consisting of an ABox (dataset) and TBox (ontology). We introduce some natural ways of defining the Shapley value computation (SVC) problem in the DL setting, by varying what is to be explained (entailment of a TBox axiom, ABox assertion, or query answer), which parts of the KB are assigned values, and how the complexity is measured. To begin our study, we establish the #P-hardness of the Shapley value computation of a simple graph reachability query, which we then employ to show #P-hardness of several variants of the SVC problem, even for inexpressive DLs and atomic queries. In light of these initial negative results, we embark on a non-uniform complexity analysis, whose aim is to classify the data complexity of the Shapley value computation problems SVCQ associated with each ontology-mediated query (OMQ) Q = (T, q). By transferring recent results from the database setting, we establish a FP/#P-hard dichotomy result of Shapley value computation problem SVC for OMQs Q = (T,q) where the TBox T is formulated in the Horn DL ELHI\u2081 and q is a constant-free connected homomorphism-closed query. Moreover, if restricted to the case where q is a conjunctive query, then the dichotomy is effective, i.e. we can decide whether SVCQ is ELHI_ or #P-hard. Our final and most technically challenging result is to show that the #P-hardness part of the dichotomy can be strengthened to cover OMQs based upon a wider range of queries q. Specifically, we show that for any OMQ Q = (T, q) based upon a ELHI\u2081 TBox and a UCQ q (which may be disconnected and/or contain constants), non-FO-rewritability of Q implies #P-hardness of SVCQ. Due to the tight connections holding between Shapley value computation and probabilistic query evaluation, the proof of this result can be further used to obtain a ELHI\u2081/#P-hard dichotomy for probabilistic ontology-mediated queries from (ELHI, UCQ), substantially generalizing existing results.\nThe paper is structured as follows. Section 2 introduces key notions from databases and description logics, and Section 3 defines Shapley values and recalls useful results about Shapley values in databases. We also prove a new hardness result for graph reachability queries, which we apply in Section 4 to show hardness of Shapley value computation in various ontology settings. In Section 5, we present our ECHI\u2081/#P-hard dichotomy result for OMQs in the Horn DL ELHI\u2081, and in Section 6, we strengthen the #P-hardness result to cover a wider range of queries. We conclude the paper in Section 7 with a summary of our contributions and a discussion of future work.\nSome proof details have been omitted for lack of space, but they are provided in the appendix."}, {"title": "2 Preliminaries", "content": "We recall some important notions related to description logics (DLs), databases, queries, and complexity, directing readers to (Baader et al. 2017) for a detailed introduction to DLs. Our presentation of DLs and databases slightly differs from the 'usual' ones so as that we may employ some definitions and notations in both settings.\nDatabases A database D is a finite set of relational facts P(d), where P is a k-ary symbol drawn from a countably infinite set of relation symbols ND and a is a k-ary tuple of (individual) constants drawn from a countably infinite set N\u2081. We shall also consider extended databases which may contain infinitely many facts P(a), and where the elements of @ are drawn from N\u2081 and from a countably infinite set Nu of unnamed elements. The domain dom(D) of D contains all constants and unnamed elements occurring in D, and we use const(D) for the constants in D. When D is a database, dom(D) = const(D).\nA homomorphism from an extended database D to an extended database D' is a function h : dom(D) \u2192 dom(D') such that P(h(a)) \u2208 D' for every P(a) \u2208 D. We write D hom\u203a D' to indicate the existence of such an h. If additionally h(c) = c for every c E C\u2229 const(D), with CC N\u2081, then we call h a C-homomorphism and write D Chom, D'. We say that a (possibly extended) database D is connected if so is the underlying undirected graph with vertices dom(D) UD and edges {(ai, P(a1,...,ak)) | P(\u03b11,...,\u03b1\u03ba) \u2208 D}. The connected components of D are the maximal subsets of D that occur within a connected component of the associated graph.\nQueries In the most general sense, a k-ary query (k \u2265 0) can be defined as a function q that maps every extended database D to a set of k-tuples of constants from const(D) (the answers to q). Queries of arity 0 are called Boolean. When q is a Boolean query, each D is mapped either to {()} or {}. In the former case, we say that D satisfies q and write D= q. If additionally D' \u2260 q for every D' \u2286 D, then we shall call D a minimal support for q.\nA Boolean query q is said to be closed under homomorphisms, or hom-closed, if D = q and D hom\u203a D' implies that D' q. The notion of C-hom-closed is defined analogously usingthom in place of hom. When q is (C-)hom-closed, D= q iff D contains some minimal support for q.\nSo far we have considered an abstract notion of query, but in practice, queries are often specified in concrete query languages. First-order (FO) queries are given by formulas in first-order predicate logic with equality, whose relational atoms are built from predicates from ND and terms drawn from N\u2081 U Ny, with Ny a countably infinite set of variables, equipped with standard FO logic semantics (i.e. D = q if D, viewed as a first-order structure, satisfies the FO sentence q). Two prominent classes of FO queries are conjunctive queries (CQs), and unions of conjunctive queries (UCQs) which are finite disjunctions of CQs having the same free variables. We remark that Boolean (U)CQs without constants are hom-closed, and Boolean (U)CQs with constants in Care C-hom-closed. Other examples of (C)-hom-closed queries include Datalog queries and regular path queries.\nDL Knowledge Bases A DL knowledge base (KB) K = (A, T) comprises an ABox (dataset) A and a TBox (ontology) T, which are built from countably infinite sets Nc of concept names (unary predicates) and N\u20a8 of role names (binary predicates) with NC UNRC ND, and the individual"}, {"title": null, "content": "constants from N\u2081. An ABox is a database with relations drawn from NcU NR and thus contains two kinds of facts: concept assertions A(c) (A \u2208 Nc, c\u2208 N\u2081) and role assertions r(c, d) (r \u2208 N\u20a8, c, d \u2208 N\u2081). A TBox is a finite set of axioms, whose form is dictated by the DL in question. We use L TBox to refer to a TBox formulated in the DL L. For example, in the DL ELHI considered later in this paper, complex concepts are constructed as follows:\n$\u0421 := \u0422 | \u0410 | \u0421\\cap \u0421' | \u2203R.C  A \u2208 Nc, R\u2208 N$\nwhere N = NR \u222a {r\u00af | r \u2208 N\u20a8}, and ELHI\u300d TBoxes consist of concept inclusions CD (with C, D complex concepts) and role inclusions R \u2286 S with R, S \u2208 N\uc9f8. We shall also consider DL-Litecore TBoxes, which are composed of concept inclusions of the form\n$B\u2081\ub4dc(-)B2  B\u2081 := A |\u2203R.T A\u2208Nc, R\u2208N$\nThe semantics of DL KBs is defined using interpretations 1 = (\u0394\u0399, .1), where \u2206\u00b9 \u2286 N\u013bU N\u016b is a non-empty set and .I a function that maps every A \u2208 Nc to a set A\u00b9 \u2286 \u0394\u0399 and every r\u2208 NR to a binary relation r\u00b9 \u2286 \u25b3 \u00d7 \u25b31. The function is straightforwardly extended to interpret complex concepts and roles: $T1 = \u22061, (\u0421\u041f D)1 = C1 \u2229 DI, (R.C) = {d | \u2203e \u2208 Cs.t. (d, e) \u2208 r1}, (-G)1 = \u25b31 \\ G1, and (r\u00af)2 = {(e,d) | (d,e) \u2208 r}$. Note that by requiring that \u2206 CN U Nu, we ensure that every interpretation I can be viewed as an extended database D\u2081 = {A(e) | e \u2208 AZ} \u222a {r(d,e) | (d, e) \u2208 r}, and we shall view I as an extended database when convenient.\nAn interpretation I satisfies a (concept or role) inclusion G\u2286 HifGI \u2286 H\u00b9, and it satisfies an assertion A(c) (resp. r(c, d)) if c \u2208 AZ (resp. (c, d) \u2208 r\u00b9). We call I a model of a TBox T if it satisfies every axiom in T, a model of an ABox A if it satisfies every assertion in A, and a model of a KB (A, T) if it is a model of both T and A. We use Mod(K) for the set of models of a KB K. A KB K is consistent if Mod(K) \u2260 0 (else it is inconsistent). An ABox A is T-consistent when the KB (A, T) is consistent. An axiom a is entailed from a TBox T, written T = a, if every model of T satisfies a, and an axiom or assertion a is entailed from a KB K, written K = a, if every model of K satisfies a.\nQuerying DL KBS We say that a Boolean query q is en-tailed from a DL KB K, written K = q, if D1 = q for every I \u2208 Mod(K). The certain answers to a non-Boolean k-ary query q(x) w.r.t. a KB K = (A, T) are the k-tuples \u1ea3 of constants from const(A) such that K = q(a), with q(a) the Boolean query obtained by substituting a for the free variables 7. Note that when the KB is inconsistent, every Boolean query is trivially entailed, so every possible tuple a of ABox constants counts as a certain answer.\nWhile it is traditional to view queries as being posed to the KB, it is sometimes more convenient to adopt a database perspective and treat T and q together as constituting a composite ontology-mediated query (OMQ) Q = (T,q), which is posed to the ABox A. When we adopt this perspective, we will write A = (T, q) or A = Q to mean (A,T) = q. When convenient, we will use the notation (L, Q) to designate the class of all OMQs (T, q) such that T is formulated in the DL L and q is a query from the class of queries Q.\nA prominent technique for computing certain answers (or checking query entailment) is to rewrite an OMQ into another query that can be directly evaluated using a database system. Formally, we call a query q*(x) a rewriting of an OMQ (T, q) if for every ABox A and candidate answer \u00e3:\n$A = (T, q(a))  iff A = q*(a)$\nIf we modify the above definition to only quantify over T-consistent ABoxes, then we speak instead of a rewriting w.r.t. consistent ABoxes. When q* is a first-order query, we call it a first-order (FO) rewriting. If an OMQQ possesses an FO-rewriting, we say that Q is FO-rewritable, else it is called non-FO-rewritable.\nIn Horn DLs, like ELHI\u2081 and DL-Litecore, every consistent KB K = (A,T) admits a canonical model IA,T with \u25b3IA,TC const(A) U N\u016b with the special property that it embeds homomorphically into every model of K. More precisely, DIAT C-hom D\u2081 for every I \u2208 Mod(K) and every CC Nj. While the definition of IA,T depends on the particular Horn DL, the construction typically involves completing the ABox by adding tree-shaped structures using unnamed elements to satisfy the TBox axioms in the least constrained way possible. Importantly, if K = (A, T) admits a canonical model IA,T, then for every C-hom-closed query q (with CC N\u2081):\n$Kq(a) iff IA,T = q(a)$\nIn particular, this holds when q is a (U)CQ.\nComplexity We assume familiarity with FP, the set of functions solved in polynomial-time; and #P, the functions which output the number of accepting runs in polynomial-time nondeterministic Turing machines. We will work with polynomial-time Turing reductions between computational tasks, and we write P\u2081 =P P2 to denote that there are polynomial-time algorithms to compute Pi using unit-cost calls to P3-i, for both i \u2208 {1, 2}."}, {"title": "3 Shapley Value: Definition & Basic Results", "content": "In this section, we formally define the Shapley value, recall relevant existing results, and prove a new intractability result for computing Shapley values in reachability games.\n3.1 Definition of Shapley Value\nThe Shapley value (Shapley 1953) was introduced as a means to fairly distribute wealth amongst players in a a cooperative game, based upon their respective contributions. A cooperative game consists of a finite set of players P and a wealth function v : (P) \u2192Q that assigns a value to each coalition (i.e., set) of players, with v(0) = 0. Picture a scenario where the players arrive one by one in a random order, and each one earns what she added to the current coalition's wealth on arrival. The Shapley value of a player p\u2208 P is defined as her expected earnings in this scenario, which can be expressed as:\n$Sh(P, v, p) := \\frac{1}{|P|!} \\sum_{\\sigma \\in S(P)} (v(\\sigma_{\\leq p}) - V(\\sigma_{<p}))$ (1)\nwhere S(P) denotes the set of permutations of P and <p (resp. p) the set of players that appear before p (resp. before or at p) in the permutation \u03c3. Intuitively, we take the average marginal contribution v (\u03c3\u2264p) \u2013 v (\u03c3<p) of player p, across all possible orderings o of the players. Eq. (1) can be equivalently reformulated as:\n$\\sum_{B \\subset P\\backslash{p}} \\frac{|B|!(|P| - |B| - 1)!}{|P|!} (v(B\\cup \\{p\\}) - v(B))$ (2)\nwhich will be more convenient in our proofs.\n3.2 Existing Results from the Database Setting\nThere has been significant interest lately in the problem of computing the Shapley value of database facts as a means of quantifying their contributions to a query answer. The formal setting is as follows: the database D is partitioned into endogenous and exogenous facts, D = Dn Dx, the players of the cooperative game are the endogenous facts Dn, and the wealth function of a given Boolean query q is defined, for every subset BC Dn of endogenous facts, as $v_q(B) =\\begin{cases} U_B & \\text{where $U_B = 1$ (resp. $U_X = 1$) if $D_X \\cup B = q$ (resp. if $D_X = q$)} \\\n0 & \\text{otherwise.} \\end{cases}$. Shap-ley value computation on q, denoted SVCq, is the problem of computing the Shapley value Sh(Dn, vq, a) for the input partitioned database DnDx and fact a \u2208 Dn. We will write SVC to refer to the task when restricted to purely endogenous databases, i.e., partitioned databases with only endogenous assertions (of the form D = (Dn, Dx) with Dx = 0).\nProbabilistic Query Evaluation We will exploit known connections between SVC and probabilistic query evaluation. A tuple-independent probabilistic database is a pair D = (S, \u03c0) where S is a database and \u3160 : S \u2192 (0, 1] is a probability assignment. For a Boolean query q, Pr(D = q) is the probability of q being true, where each assertion a has independent probability \u03c0(\u03b1) of being in the database. The problem of computing, given a tuple-independent probabilistic database D, the probability Pr(D = q) is known as the probabilistic query evaluation problem, or PQEq.\nWe consider three restrictions of PQEq, by limiting the probabilities that appear in the image Im(\u03c0) of the probability assignment of the input probabilistic database:\n*   PQEq(1/2): input (S, \u03c0) is such that Im(\u03c0) = {1/2};\n*   PQEq(1/2; 1): input (S, \u03c0) is such that Im(\u03c0) = {1/2, 1};\n*   single proper probability query evaluation (SPPQE): input (S, \u03c0) is s.t. Im(\u03c0) = {p, 1} for some p \u2208 (0, 1].\nThese restricted versions of PQE can be also found in the literature under the names of their counting problem counterparts: PQE(1/2) is also known as the \u201cmodel counting\u201d or \u201cuniform reliability\u201d problems, and PQE (1/2; 1) as the \"generalized model counting\" problem.\nKnown results In (Livshits et al. 2021), a FP/#P-hard dichotomy was established for self-join-free CQs (i.e. not having two atoms with the same relation name). The dichotomy coincides with the FP/#P-hard dichotomy for PQE (Dalvi and Suciu 2004), and the tractable queries admit a syntactical characterization, known as hierarchical queries. In fact, the PQE dichotomy extends to the more general class of UCQs (Dalvi and Suciu 2012), where the queries for which PQE is tractable are known as safe UCQs (hence, in particular hierarchical CQs are safe). However, it is an open problem whether UCQs (or even CQs with self-joins) also enjoy a dichotomy for SVC. Concretely, it is unknown if SVC is #P-hard for all unsafe UCQs (or even CQs).\nRecent work has clarified the relation between the two dichotomies by reducing SVC to PQE (Deutch et al. 2022) and reproving the hardness of SVC (Kara, Olteanu, and Suciu 2023) by reduction from the same model counting problem for Boolean functions that had been used to show hardness of PQE for non-hierarchical self-join-free CQs (Dalvi and Suciu 2004). Further, SPPQE and SVC have been shown to be polynomial-time inter-reducible for many fragments of hom-closed queries (Bienvenu, Figueira, and Lafourcade 2024), in particular for connected queries without constants.\nTheorem 1. (Bienvenu, Figueira, and Lafourcade 2024, Corollaries 4.1 and 4.2) For every connected hom-closed Boolean query q, SPPQEq =P SVCq; further, on graph databases, SVCq is in FP if q is equivalent to a safe UCQ and #P-hard otherwise.\nIn the context of the previous statement, a graph database is a database restricted to relations of arity 1 or 2 (hence an ABox can be seen as a graph database). The result above relies crucially on the #P-hardness of PQE(1/2) (and hence of SPPQE) for non-FO-rewritable (a.k.a. unbounded) hom-closed queries on graph databases (Amarilli 2023), and the FP/#P-hard dichotomy of PQE(1/2; 1) for UCQs (Dalvi and Suciu 2012; Kenig and Suciu 2021).\n3.3 Hardness of SVC for Reachability Games\nThis subsection shows the #P-hardness of the Shapley value computation of graph reachability, which, as we shall see in Section 4, implies the #P-hardness of several problems in the setting of ontologies.\nConsider the Boolean query st-reach which asks whether there is a directed path from a vertex s to a vertex t in a (directed) graph. A graph can be seen as a graph database using a single binary relation, and s, t are individuals. As we show next, computing the Shapley value for this simple query is already #P-hard, even in the restricted case of purely endogenous databases.\nProposition 2. SVCst-reach is #P-hard."}, {"title": "4 Shapley Values in the Ontology Setting and First Intractability Results", "content": "Now that we that have seen how the Shapley value has been applied in the database setting, we can adapt the definitions and techniques to the context of OMQA. There are different ways to formalize this, in particular, the ontology may be considered to be part of the input or not. Remember that in Proposition 2 we identified the inherent difficulty of reachability-like queries for SVC. Since reasoning on TBox axioms inherently involves some form of reachability analysis, we will show that SVC is #P-hard as soon as the TBox is taken as being part of the input. This will motivate us to consider a different way of formulating and analyzing the SVC problem in later sections.\nWe first present a running example, which showcases the use of the Shapley value in the ontology setting.\nExample 3. Consider the ELHI KB defined in Figure 2, where the ABox (bottom half) contains information on some ingredients and recipes, and the TBox (top half) defines more complex notions such as a \u2018land-sea recipe'. For instance, HasIngr.FishBased FishBased intuitively translates as 'anything that has a fish-based ingredient is fish-based'.\nA user of this KB might obtain poulardeNantua as an answer to the query LandSea(x), and wonder which ingredients are the most responsible for this fact. She can thus set everything but the role assertions (which specify ingredients) as exogenous and compute the Shapley values for the Boolean query LandSea(poulardeNantua). The modeling choice to set only role assertions as endogenous corresponds to considering the background knowledge provided by the TBox and the concept assertions as being external to responsibility attribution, since they are not part of recipes.\nWe can compute the values via Eq. (1). There are 4! = 24 possible permutations over the 4 endogenous role assertions {e1, 62, 63, e4}. 14 out of 24 permutations are s.t. $v (\u03c3_{\\leq e_1})-v(\\sigma_{<e_1}) = 1$, and similarly 6 for e2, 2 for e\u0499, and 2 for e4, making the respective Shapley values: 14/24, 6/24, 2/24 and 2/24.\nAs expected, e1 has the highest responsibility because it is necessary to satisfy the query, then comes e2 that only needs to be combined with e\u2081 and finally e3 and e4 that must be used together in addition to e1.\nOf course a naive application of Eqs. (1) or (2) is not efficient, since they involve an exponential number of permutations or subsets. This raises the natural question of when a tractable approach can be found.\nIn the remainder of this section we illustrate how the hardness for SVCst-reach can be used to prove the hardness of many natural applications of the Shapley value using the same example KB depicted in Figure 2.\n4.1 Shapley Values for Axiom Entailment\nA first application of the Shapley value to ontologies is to focus solely on the TBox and determine which axioms are most responsible for a given TBox entailment, e.g. to find out why crustaceans count as fish-based. Unfortunately, the transitive nature of concept inclusions make this a reachability question and hence #P-hard in light of Proposition 2. In fact, hardness holds already for the simplest possible DL Lmin containing only concept name inclusions."}, {"title": null, "content": "Proposition 4. For every TBox T and S \u2286 T and pair of concept names A, B, define V ACB(S) := 1 if S |= A \u2286 B, and 0 otherwise. The problem of computing, given a Lmin TBox T, concept names A, B, and an axiom \u03bc\u2208 \u03a4, the Shapley value of \u00b5 in the game (T, va\u2286B) is #P-hard.\nProof. To reduce from SVC3t-reach, let G = (V, E) a directed graph and s, t \u2208 V. Consider the TBox T\u2084 := {Ax \u2286 Ay | (Ax, Ay) \u2208 E} (it only contains concept name inclusions) and the concept inclusion As At. By construction the reachability from s to t is equivalent to the entailment of As At, which means the two games are isomorphic.\n4.2 Shapley Values for Query Entailment\nWe next consider the application of the Shapley value to explaining query entailment w.r.t. a DL KB. In our running example, a user may ask why there is a fish-based recipe in the KB of Figure 2 if there is no Fish as-sertion. She could therefore compute the Shapley values for the CQ \u2203x.FishBased(x) and discover that the crayfish is considered fish-based because of the assertion Crustacean (crayfish) and the axioms Crustacean Seafood FishBased. However, the chain of inclusions needed to satisfy the query expresses a form of reachability, and thus we can transfer the #P-hardness of SVCst-reach.\nIn this setting we consider as input a partitioned KB K = (An Ax, Tn Tx) and the task is to compute the Shapley value of the statements in An U Tn, in order to quantify their responsibility in K entailing q. Concretely, for any Boolean query q we consider the associated cooperative game having An U Tn as players and $v_q(S) := v_S = v_X$ where vs = 1 (resp. vx = 1) if (Ax U (S\u2229 An), TU (S\u2229 T\u2081)) = q (resp. if (Ax, Tx) = q), and 0 otherwise.\nProposition 5. The problem of computing Shapley values for Boolean CQs over partitioned KBs on Lmin is #P-hard. Hardness holds even for queries given as ABox assertions.\nProof. We build a TBox to reduce from SVCst-reach: let G = (V, E) be a directed graph and s,t \u2208 V, from which we define TG := {Ax \u2286 Ay | (Ax, Ay) \u2208 E}, with A\u2081 = A, and A := {As(c)}. We set the ABox as exogenous and the TBox as endogenous. Then a subset X C TG is s.t. (A, X) = q iff X = As \u2286 At iff X defines a subset of E which admits a path from s to t. The game for (TG, A) is therefore isomorphic to the one for SVCst-reach on G.\n4.3 Shapley Values on Exogenous Ontologies\nPropositions 4 and 5 show that computing Shapley values of axioms is inevitably intractable, as reasoning on concept and role inclusions naturally involves reachability. One idea to sidestep this issue would be to treat the whole TBox as exogenous. Conceptually, this corresponds to treating TBox axioms as given or obvious, thereby focusing on explanations in terms of the ABox assertions. In our running example of Figure 2, the user may wonder what ingredients make the Poularde Nantua recipe fish-based. She could compute Shapley values for the CQ FishBased(poulardeNantua), setting everything but the Hasingr-roles as exogenous, and discover that the recipe is fish-based because of the two"}, {"title": null, "content": "chains of ingredients: poulardeNantua Hasingr, crayfish and poulardeNantua HasSauce, nantuaSauce Hasingr crayfish.\nIn terms of complexity the problem will once again be #P-hard due to reachability, which this time is expressed within the data itself. The culprit is the axiom HasIngr.FishBased FishBased, which can be found in any DL at least as expressive as EL.\nProposition 6. Let q be a CQ of the form A(c), for A \u2208 Nc and c\u2208 N\u2081. Then the problem of computing Shapley values for q over partitioned KBs on EL is #P-hard, even if we assume that the TBox only contains exogenous axioms.\nProof. Let G = (V, E) be a directed graph and s,t \u2208 V, from which we define the partitioned ABox given by Ax := {B(cs), D(ct)} and An := {r(cx, Cy) | (x, y) \u2208 E} with B, D, r and the cx being all fresh, except cs := c. Then define the purely exogenous TBox T := {BND \u2286 A, \u2203r.D \u2286 D}. Then a coalition X \u2286 An is s.t. (XUAx, T) = q iff it defines a subset of G where there is a path from s to t. The corresponding cooperative game is then the same as the one defining SVCst-reach, hence the desired reduction.\nInterestingly, we can show that the problem stated in the preceding result is tractable for DL-Lite ontologies:\nProposition 7. The problem of computing Shapley values of CQs of the form A(c) (with A \u2208 Nc and c\u2208 N\u2081) over partitioned KBs on DL-Litecore is in FP when restricted to KBs with only exogenous TBox axioms.\nProof. Note that one can compute, in polynomial time, a set of facts {1, ..., am} \u2286 A such that for every A' \u2286 A, we have A = (T, A(c)) iff A' = a1 V\uff65\uff65\uff65 V am. This is only possible because T is a DL-Litecore TBox.\nWe can then compute the Shapley values for q* = a1 V ...Vam and the database An Ax, disregarding the TBox T since it is exogenous. We observe that if Ax contains some ai, all facts in An have value zero. Otherwise, only the facts a\u017c will have a non-zero Shapley value, and their values can be easily computed using Eq. (2) and the observation that there are precisely (An-m) subsets BC An \\ {az} of size k such that vq* (B\u222a {az}) \u2013 vq* (B) = 1.\nDetermining for which classes of non-atomic CQs the previous proposition holds w.r.t. DL-Lite ontologies is challenging, as it would require us to first establish a full complexity characterization for plain CQs (without an ontology, on a binary signature), which remains an open question.\n4.4 Approximation and Relevance\nIn view of the hardness results of Propositions 4 to 6, an alternative would be to give up on the precise Shapley value and instead find an approximation, or at the very least distinguish between elements having a zero or non-zero Shapley value. We call the elements with non-zero values relevant, because they are exactly those that appear in some minimal"}, {}]}