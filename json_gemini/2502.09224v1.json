{"title": "Order-Sorted Intensional Logic: Expressing Subtyping Polymorphism with Typing Assertions and Quantification over Concepts*", "authors": ["\u0110or\u0111e Markovi\u0107", "Marc Denecker"], "abstract": "Subtyping, also known as subtype polymorphism, is a concept extensively studied in programming language theory, delineating the substitutability relation among datatypes. This property ensures that programs designed for supertype objects remain compatible with their subtypes.\nIn this paper, we explore the capability of order-sorted logic for utilizing these ideas in the context of Knowledge Representation. We recognize two fundamental limitations: First, the inability of this logic to address the concept rather than the value of non-logical symbols, and second, the lack of language constructs for constraining the type of terms. Consequently, we propose guarded order- sorted intensional logic, where guards are language constructs for annotating typing information and intensional logic provides support for quantification over concepts.", "sections": [{"title": "1 Introduction", "content": "The logic-based approach to knowledge representation (KR) dates back to the early ages of artificial intelligence. From the inception of this approach, limitations of untyped logic were identified. These issues led to the use of many-sorted logic [10], and order-sorted logic (OSL) [1]. In many-sorted logic, the domain of discourse (or universe) is partitioned into different sorts/types, all disjoint. The latter assumption is lifted in order-sorted logic, and sorts/types can be organized in a hierarchy by inclusion.\nWhen extending first-order logic with ordered sorts, the concept of subtyping polymorphism emerges [8, Chapter 15]. A prime example of this concept is the modeling of characteristic behaviors among different animals. Dogs bark, cats meow, etc., while nearly all animals produce species-specific sounds. In this scenario, animal serves as the overarching type, with specific animal types acting as subtypes. In many programming languages, one can invoke a method such as produce sound for an animal, which dynamically dispatches behavior based on the specific species of the animal. Logic is characterized by model semantics, and hence, it lacks the notion of method invocation found in programming languages. Nonetheless, logical statements can draw inspiration from this concept. For instance, consider the statement: \u201cThere is an animal in my yard that is either barking or meowing\u201d. Considering that barking and meowing are predicates defined respectively on types dog and cat which are subtypes of the type animal, expressing such statements in OSL may easily lead to untyped formulae, as we shall see later.\nIn this paper, we explore the principles underlying subtyping polymorphism and highlight challenges in its representation within order-sorted first-order logic. Additionally, we identify the two key principles essential for naturally expressing such concepts in any logic employing order-sorts. The first principle relates to the inherent incapacity of standard OSL to condition the subtyping relation of a term. For"}, {"title": "2 Preliminaries \u2013 Order-sorted Logic", "content": "This section formally defines order-sorted logic. We start with the notion of a vocabulary.\nDefinition 1. An OSL vocabulary \u2211 of non-logical symbols is a quadruple (T2, S2, <:2, tsx) where:\n\u2022 T\u2211 is a set of type symbols T. Type symbols U (universe), B (boolean), and N (natural numbers) are always member of T\u2211.\n\u2022 Sx is a set of function and predicate symbols.\n\u2022 <:\u2211 is a subtyping relation on T\u2211. Type S is a direct subtype of T ifS <:2 T. For each type T (except U) without direct supertype declaration T <:\u2211 S, we implicitly assume T <:\u2211 U. Accordingly, B <:2 U and N <:2 U.\n\u2022 ts\u2211 is a type signature associating to every symbol in S\u2211 a word of the following format (T1\u00d7\u2026\u00d7 Tn) \u2192 T (i.e., type term). If T = B, the symbol is a predicate symbol, otherwise it is a function symbol. The sets of predicate and function symbols are denoted with S, respectively S.\nType T1 is called a subtype of T2 if there is a path from T1 to T2 in the relation <:2.\nProposition 1. Given vocabulary \u2211, every type T in \u03a4\u2211 (except U) is subtype of U.\nProof. Follows directly from Definition 1.\nA symbol with type term () \u2192 T is an object (or a constant function) symbol. A symbol with type term () \u2192 B is a propositional symbol."}, {"title": "3 Analysis of subtyping polymorphism", "content": "As previously noted, the statement bark(tom) is considered unacceptable (ill-typed) due to the category clash it contains. Specifically, barking does not apply to cats. One might argue that such statement could be accepted if always interpreted as false, thereby justifying its meaning as \u201cTom is a dog and bark(tom)\u201d. Since Tom is not a dog, the statement is false. But what then is the meaning of \u00acbark(tom)? If it is interpreted as \u201cTom is a dog and \u00acbark(tom)\u201d, then this formula is false, violating the law of excluded middle. An alternative interpretation is \u201c\u00ac(Tom is a dog and bark(tom))\u201d, in which case the formula is true, which seems to be a more reasonable choice in this case. However, notice that this statement is equivalent to \"If Tom is a dog then \u00abbark(tom)\u201d.\nThis brings us to an alternative interpretation of ill-typed formulae. One could argue that the initial formula bark(tom) should be interpreted as \u201cIf Tom is a dog then bark(tom)\u201d. Consequently, it is jus- tified to assert that statement bark(tom) carries ambiguity, and hence can be considered as potentially dangerous, and therefore should be rejected (corresponding to a well-typed criterion). However, we ar- gue that extending OSL language to support explicitly disambiguated forms of these ill-typed formulae is beneficial. We demonstrate this in the remainder of the section.\nConsider the definition of the predicate makingSound : Animal \u2192 B representing the set of all animals producing their specific sound. In the running example cats and dogs. This can be formalized in OSL as:\nVa[Animal] : makingSound(a) \u21d4((\u2203c[Cat]: a Animal-Cat c\u0245meow(c))V (\u2203d[Dog]: a Animal-Dog d\u0245bark(d))) (1)\nNote that equalities Animal-Cat and Animal-Dog are necessary since they operate on different types. Returning to the main point, in this example, it would be beneficial to constrain the type of variable a which ranges over type Animal in the following way.\nVa[Animal] : makingSound(a) \u2192 ((Cat(a) \u21d2 meow(a)) V (Dog(a) \u21d2 bark(a))) (2)\nSimilarly, the statement \u201call animals produce their specific sound\u201d could be expressed as:\nVa[Animal]: ((Cat(a) \u21d2 meow(a)) \u2227 (Dog(a) \u21d2 bark(a))) (3)\nHowever, these do not constitute OSL formulae as types are used as predicates and variable a of type Animal remains an argument of predicates meow and bark. Notice that there is room for improvement"}, {"title": "4 Guarded order-sorted logic", "content": "The extension of OSL with the concept of guarding terms by typing assertions is characterized in the following definition.\nDefinition 4. Definition 1 of an OSL vocabulary \u2211 is extended with the following rule: if T is a type symbols in T2, then T \u2208 S\u2211 and tsx(T) = U \u2192 B.\nDefinition 3 of an OSL typing relation, is extended with the two new rules, namely conjunction guarding (G-c) and implication guarding (G-i):\nn\u03c9 \u0395FUni=1{ti : Ti} \u00a3 $ : B\u03c9\u03c4 (\u03a41 (t1) >\u2026\u2227Tn(tn) \u21d2 \u00a2) : B(G-i)\n\u03c9- (T\u2081 (t\u2081) ^\u2026^Tn(tn) ^ \u03c6): B(G-c)\nExample 3. In the guarded OSL, statement \u201cThere is an animal (that is a cat) meowing!\u201d can be expressed as: \u2203a[Animal] : Cat(a)\u2227meow(a). Towards making the judgment that this formula is well- typed (i.e., of type B), let the context & correspond to the typing signature of vocabulary from Example 1:\nw = {Cat : U \u2192 B; Dog : U \u2192 B; age : U \u2192 N; ... meow : Cat \u2192 B}\nFor compact representation of derivation we use the following abbreviations:\nw' = w\u222a{a : Animal}\u03c9\" = \u03c9'\u222a {a : Cat}\nThe following derivation provides the judgment that this formula is well-typed:\n1'Fa: Animal2Animal <:2 UT-sub'Fa: U3meow: Cat \u2192 B\u2208\u03c9\"a : Cat \u2208 \u03c9\"\u03c9\" \u251cmeow(a) : B\u03c9'\u251cCat(a)^meow(a) : BG-c\u251c\u2203a[Animal] : Cat(a)^meow(a) : BT-ex\nThe justification for each of the final premises (\u221a) is:\n\u221a 1 a: Animal \u2208 w' since w' = \u0153\u222a{a : Animal}.\n\u221a2 Since Animal has no supertype in \u2211, it follows that Animal <:\u2211 U (Definition 1).\n\u221a 3 meow: Cat \u2192 B \u2208 \u03c9\" since it is in w and w\" = \u03c9\u222a{a : Animal}\u222a{a : Cat}.\n\u221a 4 a : Cat \u2208 w\" since w\" = \u03c9'\u222a{a : Cat} (due to Definition 4, rule (G-C))."}, {"title": "5 Order-sorted intensional logic", "content": "The main concern of intensional logic is the difference between a concept (or intension) and, its value (or extension) in a state of affairs. A prototypical example is the \u201cmorning star\u201d and \u201cevening star\u201d, which represent distinct concepts (respectively, the star in the east before sunrise, and the star in the west after sunset), while denoting the same object in the actual state of affairs (the planet Venus). In the computational intensional logic of [2], intensions of predicates are first class objects that can be quantified over and stored in other predicates. For example, given a predicate humanDisease containing a set of intensions of unary predicates over humans (e.g., flu,measels, ...) and type C representing all concepts, one can define healtyHuman as:\n\u221ah[Human] : (healthyHuman(h) \u21d4 \u00ac\u2203c[C] : humanDisease(c) ^$(c)(h))\nHere $(c) is the value of the intensional object c. A similar approach can be applied to improve the formula (2) from Section 3; here sound is a unary predicate over animal sound intensions (in the running example meow and bark):\nVa[Animal] : makingSound(a) \u21d4\u2203c[C] : sound(c)^$(c)(a) (4)\nHowever, this formula has a typing issue since sound concepts (variable c) can not be applied to an arbitrary animal (variable a), which is done by $(c)(a). This issue will be addressed after we formally introduce ordered-sorted intensional logic. First, a new built-in type C representing the set of concepts of the vocabulary is added to the OSL vocabulary. This type represents the collection of all symbols (types, functions, and predicates) within the vocabulary. The concept associated with a symbol s is denoted by \u2018s and can be accessed with the reference operator \u2018(s). The dual dereference operator $(s) is a unary higher-order function that, given a concept s, returns the function or predicate associated with the symbol s. Therefore, $(s) is always followed by another bracket containing a tuple of terms that are applied to the resulting function or predicate. Accordingly, these terms should match the type and arity of the symbol. Formally:\nDefinition 6. The order-sorted intensional logic is defined by the following extensions:\n1. An OSL vocabulary \u2211 contains the build-in type C (concepts).\n2. Type C denotes the set of all concepts in the vocabulary {S| s \u2208 S2U T\u00a3}.\n3. Given an OSL vocabulary \u03a3, for s \u2208 S\u2211 UTx, \u2018(s) is a term of type C.\n4. If term c is of type C then $(c)(t) is an OSL expression, where \u012b is a tuple of terms."}, {"title": "6 Guarded order-sorted intensional logic", "content": "Formula (5) enhances the original statement (2) by employing intensional constructs for guarding it. However, achieving this required the introduction of a helper function relating kinds to their sounds, despite this information being present in the type of predicates meow and bark. We address this issue by integrating guards (Section 4) and intensional logic (Section 5). First, we demonstrate it on the running example.\nExample 7. Recall the formula (2):\nVa[Animal] : makingSound(a) \u21d4 (Cat(a)\u2227meow(a)) \u2228 (Dog(a) \u2227bark(a)).\nEmploying implicit guarding, the same can be expressed as:\nVa[Animal] : makingSound(a) \u2192 [[meow(a)]] \u2228 [[bark(a)]].\nIntroducing quantification over Sound (sounds) results in:\nVa[Animal] : makingSound(a) \u21d4 \u2203s[Sound] : [[$(s)(a)]].\nIn this example, we began with the explicitly guarded formula and condensed it into a compact ver- sion using implicit guarding and quantification over concepts. Consequently, the resulting statement is well-typed. Notably, variable a is implicitly constrained to the appropriate type based on the predi- cate to which it is applied. This reflects the main goal of the paper, which is incorporating subtyping polymorphism in order-sorted logic.\nExample 8. The same methodology applies to formula (3):\nVa[Animal]: ((Cat(a) \u21d2 meow(a)) \u2227 (Dog(a) \u21d2 bark(a)))\nUsing implicit guarding on this formula we obtain: \u2200a[Animal] : \u3008\u3008meow(a)\u3009\u3009 \u2227 \u3008\u3008bark(a))), and with quantifying over Sound: Va[Animal] : \u2200s[Sound] : {{$(s)(a))).\nPrevious examples demonstrate principles for expressing properties of objects depending on their type using guarded order-sorted intensional logic. The following proposition generalizes the modeling principles discussed so far.\nProposition 2. Given OSL vocabulary \u03a3:\n\u2022 Let p1,... Pm be n-ary predicate symbols in \u03a3\n\u2022 Let these symbols have type signature in \u03a3 as:\ntsx(P1) = \u03a411 \u00d7 \u00d7 T1n \u2192 Btsx(Pm) = Tm1 \u00d7\u2026\u00d7 Tmn \u2192 B\n\u2022 Let $1,..., Sn be types in \u2211 such that:\nT11 <: $1Tm1 <: $1\nTin <: SnTmn <: Sn\n\u2022 Let P be a type in \u2211 such: P <: C := {\u2018(p1), ...,\u2018(Pm)}.\n\u2022 Let p be a term of type P, and ti term of type Si."}, {"title": "7 Well-typedness in order-sorted intensional logic", "content": "We argued in Section 5 that the well-typedness of formulae with intensional language constructs is not trivial. In this section, we elaborate on these issues and propose the foundations for the typing system suitable for the new language.\nRecall the methodology employed in formula (5) to guard the formula in Example 6. We introduced a function soundOfKind to establish the connection between animal kinds and their specific sounds. It is important to note that the well-typedness of formula (5) depends on the correct mapping of animal kinds to sounds by this function. For example, if the function incorrectly maps Cat to bark, the formula (5) would be ill-typed. This underscores the dependence of well-typedness on the extensions (values) of types and functions. However, the typing system from Definition 3 cannot account for such dependen- cies, as the type of function soundOfKind does not provide sufficient information.\nThe first step towards a richer type system is the introduction of typing annotations that would clarify the typing of a concept. This idea is presented in [2, Section 4]. For example, when quantifying over concepts, one has to provide information about the type of these concepts.\n\u2200s \u2208 C[Animal \u2192 B] : y\nIn this statement variable s ranges over concepts from the vocabulary which are of type Animal \u2192 B. In Example 1 these are Cat, Dog, bark, meow. Similar information can be provided in the declaration of subtypes of concepts. For example, declaring a new type \"kind of animals\" (earlier introduced for"}, {"title": "8 Semantics of the language", "content": "The formal model semantics of the logic presented in this paper rely on a combination of order-sorted logic [1, Section 4.2] and intensional logic [2, Section 3.2]. Note that in all our examples, extensions of types and functions ranging over concepts are fixed (i.e., Sound contains exactly bark and meow). This allows for grounding intensional language constructs and semantically reducing the logic to standard OSL. However, this section outlines the semantics of the order-sorted intensional logic. First, we define the notion of structure, a value assignment to vocabulary symbols.\nDefinition 7. A structure A over an OSL vocabulary \u2211 interprets all symbols s in \u2211 (denoted as s\u2248) such that:\n1. The value of each type symbol T in T\u2082 is a non-empty set TA.\n\u2022 Type B (boolean) is always assigned the set of truth values B2 = {true, false}\n\u2022 Type N (natural numbers) is always assigned the set N2 = {0,1,2,...}\n\u2022 Type C (concepts) is assigned the set CA = {F| s \u2208 S\u2211UT2}. Here \u00a7 is the atomic object formally representing the concept behind the symbol s.\n2. If type symbol T is a direct subtype (<:x) of T1, then TAC TA.\n3. Each symbol s in S\u2211 with type signature tsx(s) = (T\u2081 \u00d7 \u2026 \u00d7 T\u339e) \u2192 T, is assigned a set sa \u2286 TY\u00d7\u2026\u00d7 TA\u00d7TA such that:\n\u2022 for each tuple (d1,..., d\u2081) \u2208 T\u00d7\u00a8\u00d7 Tr there is an element e \u2208 T24 such that (d1,..., dn, e\u2081) \u2208 SA\n\u2022 for all tuples (d1,...,dn, e1), (d1,..., dn, e2) \u2208 s\", it holds that e\u2081 = e2.\n\u2022 If s is a type predicate T, then s\u00b2 = {(d, true) | d \u2208 T} \u222a {(d, false) | d \u2208 U\\T}.\nIf s is a function symbol and (d1,..., dn, e) \u2208 s\u00a4, we write that s\u00b2(d1,...,dn) = e.\nA common assumption is that each domain object has an identifier, a symbol that makes it possible to directly refer to that value from the theory. With the notion of a structure formalized, we proceed with defining the value of an expression in a structure.\nDefinition 8. Given vocabulary \u03a3, let a be an OSL expression (over \u03a3), and A a structure interpreting all symbols in \u03a3. Further, let, for each free variable x occurring in a as an argument of type T, structure A assign value x\u09a5 \u2208 TA (with A[x : d] we denote that structure A is extended with assignment of value d to variable x). The value of a in A, denoted as [[a]]\", is defined by induction on the structure of a:\n[x]]A = xa[[true]]A = true[[false]]A = false[f(T1,..., Tn)]]A = f([[1]],..., [\u03c4]]A)[p(T1,..., \u03c4\u03b7)]]A = p([[\u03c4\u03b9]],..., [\u03c4\u03b7]])[[\u00ac]]A = if [[]] = false;false, if [[]] = true[[1 \u2228 \u00a22]]A = true, if [[1]] = true or [[2]] = true;false, if [[$1]A = [[$2]A = false[[\u2203x[T] : 0]]A = true, if for some d \u2208 TA, [[$]]A[x:d] = true;false, if for all Il d\u2208 TA, [[$]A[x:d] = false[['(s)]] = s, for s \u2208 S\u2211 UT2"}, {"title": "9 Related work and discussion", "content": "Frame Logic (F-logic), introduced in [5], is a knowledge representation language that combines concep- tual modeling with object-oriented and frame-based languages. In this language, it is possible to use types as predicates which is sufficient for expressing formulae like (2) and (3). Logic programming in- corporating polymorphically order-sorted types is investigated in [9]. The Flora-2 [6] system combines F-logic and HiLog [3], resulting in an even more expressive language. The key differences between these languages and guarded OSL are: (i) F-logic is mainly utilizing subtyping from the perspective of object-oriented paradigm while the focus of this paper is on a more general notion of types. (ii) Results of these papers are related to parametric polymorphism [8, Chapter 23] rather than subtyping polymor- phism. Parametric (Ad hoc) polymorphism includes generic types, polymorphic predicate and function symbols and quantification over types. An example is mother and father functions, mapping animals of a certain kind to another animal of that same kind. Using parametric polymorphism the typing signa- ture of this function can be expressed as (mother : \u2200k <:\u2211 Animal . k \u2192 k). Even though this notation strongly resembles the idea presented in Section 7 they are different. Here, variable k ranges over types, while in the other example, this does not have to be the case. However, the dependent type approach with intensional logic can sometimes simulate parametric polymorphism. In this particular example: (mother : k \u2192 k | k : CT[Animal]). (iii) These languages lack intensional aspects. While HiLog allows for higher-order language constructs, it does not include concepts. This means that using functions such as soundOfKind to \u201ccompose\u201d formulae is not possible. In other words, one can see the intensional logic presented in this paper as a mechanism for expressing templates of formulae. This is because objects from the vocabulary are first-class citizens. This is not the case with the higher-order logic. (iv) Implicit type guarding is not supported in these languages. In particular, to the best of our knowledge, no other languages use such language constructs (except for our previous work [7] where guards ensure the safe application of partial functions). However, this paper demonstrates the importance of implicit guarding and power coming from combining it with intensional logic.\nThe points (iii) and (iv) suggest that these languages may encounter similar problems to those con- cerning OSL discussed in Section 3 and intensional logic from Section 5.\nOn the other side, the scope of this paper is limited to subtyping polymorphism. Future research should explore how the approach presented in this paper relates to parametric (Ad hoc) polymorphism. In particular, it is worth investigating whether the two typing systems have the same expressive power. Another research question that opens here is what if we perceive typed logic as a logic of partial pred- icates, what is then the relation between guarding presented in this paper and guarding that ensures arguments of a function are in its domain of definedness (our previous work [7]).\nSimilar to the approach demonstrated in formula (5), it is possible to define higher-order functions in HiLog to map propositions to propositions, thereby achieving similar outcomes. However, this ap- proach carries the same issues as the one with intensional logic. Namely, it requires introduction of new"}, {"title": "10 Conclusion", "content": "In this paper, we addressed the challenge of subtyping polymorphism within order-sorted logic. Through our investigation, we identified two essential requirements: intensional logic and implicit guarding with typing assertions. Consequently, we introduced guarded order-sorted intensional logic and demonstrated its effectiveness for this task.\nThe main contributions of this paper are: (i) implicit guarding, language constructs introduced in Definition 5 allowing conditioning of types for terms based on their application; (ii) combining implicit guarding and intensional logic (i.e., quantification over concepts) for expressing subtyping polymor- phism, as elaborated in Propositions 2 and 3. Additionally, this paper opens two new research topics: the well-typedness conditions of guarded order-sorted intensional logic and its relation to dependent types (see Section 7), and second, the relation of order-sorted logic as presented in this work and logic of partial functions (see Section 9)."}]}