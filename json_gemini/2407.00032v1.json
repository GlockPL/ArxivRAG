{"title": "Design a Win-Win Strategy That Is Fair to Both Service Providers and Tasks When Rejection Is Not an Option", "authors": ["Yohai Trabelsi", "Pan Xu", "Sarit Kraus"], "abstract": "Assigning tasks to service providers is a frequent procedure across various applications. Often the tasks arrive dynamically while the service providers remain static. Preventing task rejection caused by service provider overload is of utmost significance. To ensure a positive experience in relevant applications for both service providers and tasks, fairness must be considered. To address the issue, we model the problem as an online matching within a bipartite graph and tackle two minimax problems: one focuses on minimizing the highest waiting time of a task, while the other aims to minimize the highest workload of a service provider. We show that the second problem can be expressed as a linear program and thus solved efficiently while maintaining a reasonable approximation to the objective of the first problem. We developed novel methods that utilize the two minimax problems. We conducted extensive simulation experiments using real data and demonstrated that our novel heuristics, based on the linear program, performed remarkably well.", "sections": [{"title": "1 Introduction", "content": "In resource allocation, numerous problems can be represented as online matching in bipartite graphs. One side of the graph comprises service providers (interchangeably called workers in this paper), while the other consists of allocated task types. The graph's edges indicate the qualifications of service providers to perform tasks of specific types.\nIn online matching problems, a common scenario involves one dynamic side and one static side. This dynamic-static setup finds application in various contexts, such as matching riders(dynamic) to drivers(static) [Dickerson et al., 2021], connecting search queries(dynamic) to advertisers in sponsored search(static) [Delong et al., 2022], and facilitating the teleoperation of autonomous vehicles (AVs) [Ackerman Viden et al., 2023]. The primary objective in these problems is to optimize some criteria from the perspective of the allocator. Some other works are dedicated to optimizing allocation fairness. For example, in the domain of ride-sourcing, a method to achieve allocation fairness was proposed in [Lesmana et al., 2019]. Additionally, certain studies address cases where fairness should be maintained for both online tasks and offline workers [Esmaeili et al., 2023].\nOur work is motivated by the teleoperation of AVs that has garnered increasing attention recently (e.g., [Zhang, 2020; Ackerman Viden et al., 2023; Tener and Lanir, 2022]). The primary role of teleoperation is to aid AVs by intervening in challenging driving situations\u00b9. Ensuring a fair allocation of teleoperators to driving tasks is crucial for enhancing the satisfaction of both teleoperators and AVs' users. Particularly, if certain intervention requests have significantly longer waiting times or if some teleoperators are disproportionately busier than others, such imbalances can lead to dissatisfaction among those affected. In addition, as a person in the vehicle is awaiting the teleoperator's intervention, a rejection of a request is unacceptable. Another property of this application is that the teleoperators (workers) are reusable, which means they are ready to perform a new intervention request (task) once they finish a previously allocated request.\nWe model the problem as online matching in a bipartite graph and propose several approaches to optimize fairness for both the tasks (e.g., intervention requests) and the workers (e.g., teleoperators) involved in the process. Our notion of fairness is aligned with Rawls' theory of justice [Rawls, 1999].\nWe introduce two minimax problems within the given context. The first concerns fairness regarding tasks relative to waiting times, while the second focuses on Rawlsian fairness for service providers based on their workload. In both scenarios, task rejection is not permissible. We demonstrate that the second problem can be efficiently formulated as a linear problem. Notably, the solution to the second problem mirrors the first when task durations from each worker conform to the same distribution. In cases where this isn't true, we show that the second problem's solution approximates the first problem's solution, supported by a provable approximation ratio. Our study concludes with extensive simulations that underscore the efficacy of these minimax problems. Furthermore, we devise innovative heuristics that leverage the minimax solutions. These heuristics enhance task fairness while preserving favorable outcomes for worker fairness.\nOur main contributions are: (1) We propose two models to promote fairness among tasks and workers. (2) We"}, {"title": "1.1 Related Work", "content": "In this section, we describe previous works about fair allocation and allocation with delays. Notably, to our knowledge, our work distinguishes itself by being the first to consider fairness and allocation delays together.\nFair allocation Some studies address fair allocation, focusing on only one side of the graph, as seen in [Ma et al., 2020]. Although their fairness approach resembles ours, it pertains solely to one side of the graph, which falls short of our requirements. Other research, like [Patro et al., 2020], deals with fairness in recommendation systems. However, the fairness objectives in recommendation systems significantly differ from those in task allocation contexts. Practical solutions for enhancing fairness for both service providers and tasks are explored in works such as [Zhou et al., 2023]. Regrettably, this branch of research lacks theoretical performance bounds for their solutions. The fairness principles in [Esmaeili et al., 2023] closely align with ours. They consider both workers (offline side) and tasks (online side), embracing Rawlsian welfare [Rawls, 1958]. Nonetheless, task rejection is permissible in their scenario if workers are unavailable.\nAllocation with delayed assignments The original online matching problem was introduced in [Karp et al., 1990], where static nodes (workers) are instantly paired with dynamic nodes (tasks) upon arrival. However, real scenarios often lack immediate worker availability for tasks, prompting consideration for task execution delays over outright rejection. Numerous works tackle resource allocation with potential task delays. However, many of these approaches (e.g., [Righter, 1987; Li et al., 2023]) prioritize utility maximization without factoring in task wait times or worker workload. Some leverage reinforcement learning for such issues yet often make batch decisions, leading to suboptimal outcomes. Moreover, theoretical guarantees are frequently absent. An LP-based method for delayed allocations is presented in [Ackerman Viden et al., 2023], optimizing a complex utility function that accounts for task waiting times but overlooks worker workload.\nAnother pertinent domain involves queue admission control systems with multiple classes. Here, diverse customer types (tasks) arrive dynamically, and a decision-maker determines which task to accept, as demonstrated in [Rigter et al., 2022]. However, several studies in this realm do not distinguish between workers, while others permit task rejection. To our knowledge, the problem of two-sided fair allocation when task rejection is not allowed has not yet been addressed."}, {"title": "2 Preliminaries", "content": "Suppose we use a bipartite graph G = (I, J, E) to model the worker-task network, where I denotes the set of offline workers (e.g., teleoperators), J the set of types of tasks, and an edge e = (i, j) indicates the feasibility of worker i to serve the task (of type) j. Note that at certain points within this paper, we abuse the notation by referring to j as a task instead of a task type. We also abuse the notation by referring to an edge e = (i, j) as (ij). Tasks of type j\u2208 J arrive following an independent Poisson process of rate \\(l_j > 0\\). For each edge e = (i, j) \u2208 E, we assume it takes worker i an exponentially distributed service time\u00b2 of rate \\(\\mu_{ij} > 0\\) to complete a task of type j (i.e., with mean of \\(1/\\mu_{ij}\\))\u00b3. For each worker i and task j, let \\(N_i \\subseteq J\\) and \\(N_j \\subseteq I\\) denote the set of neighbors of i and j in the graph G. The assigning rule is as follows. Upon the arrival of a task of type j, we (as the central coordinator) have to assign it to a feasible worker i \u2208 Nj immediately: if i is free (or available) at that time, then i will serve j right away; otherwise, j will join the virtual queue of i and it will stay there until being served by i."}, {"title": "2.1 Allocation Policy and Related Concepts", "content": "Consider an allocation policy \u03c0(x) (possibly randomized), characterized as a vector x = {xij|(ij) \u2208 E}, where xij \u2208 [0, 1] denotes the percentage of task (of type) j assigned to and served by worker i. In the following, we discuss a few important properties and concepts related to \u03c0(x). Let Qi be the virtual queue maintained by worker i \u2208 I.\nArrival rate on Qi, denoted by \\(\\lambda_i\\). Observe that x = (xij) can be viewed alternatively as the probability that assigns each arriving j to i. Thus, we claim that Qi admits a Poisson arrival process of rate \\(\\lambda_i := \\sum_{j\\in N_i} \\lambda_j \\cdot x_{ij}\\). By the property of the Poisson process (See section 2.3.2 at [Gallager, 2011]), conditioning on the arrival of task (of type) j \u2208 J on i, we claim that \\(Pr[j = j] = x_{ij} \\cdot \\lambda_j/\\lambda_i\\) for each j \u2208 Ni.\nService time on Qi, denoted by Si. The analysis above shows that the task joining Qi is of type j \u2208 Ni with probability equal to \\(x_{ij} \\cdot \\lambda_j/\\lambda_i\\). Thus, the overall service time \\(S_i = \\sum_{j\\in N_i} x_{ij} \\cdot\\)"}, {"title": "2.2 Two Fairness-Related Objectives", "content": "In this paper, we propose the following two fairness metrics and objectives when optimizing a policy \u03c0(x).\nFAIR-T: Fairness promotion among tasks, denoted by min max \\(W_j\\). We quantify the overall fairness among users achieved by policy \u03c0(x) as the maximum expected relative waiting time among all task types, i.e., max \\(w_j\\). A formula for calculating the relative waiting time is shown in (5). Note that here we choose the relative version instead of the absolute one (i.e., max \\(w_j\\)) following, for example, the paper [Maister and others, 1984] that asserts that \u201cthe more valuable the service, the longer the customer will wait.\" A compelling example is that:\u201cSpecial checkout counters were originally provided because customers with only a few items felt resentful at having to wait a long time for what was seen as a simple transaction. Customers with a full cart of groceries were much more inclined to tolerate lines.\"\nFAIR-S: Fairness promotion among workers, denoted by min maxiel \\(p_i\\). Recall that for each worker i \u2208 I, the workload pi \u2208 (0,1), as defined in (2), captures the percentage of busy time on worker i. Thus, the maximum workload, i.e., maxi\u2208I pi, reflects the highest degree of being occupied among all workers under policy \u03c0(x). By opting for minimization of the maximum workload, denoted by min maxi\u2208I Pi, we aim to minimize the occupation time of the most occupied worker as substantially as feasible."}, {"title": "2.3 Two Optimization Programs", "content": "Consider an allocation policy \u03c0(x) parameterized by x = (xij), where xij with (ij) \u2208 E denotes the percentage of task of type j assigned to worker i. For ease of notation, we will use i ~ j (and j ~ i) to represent i \u2208 Nj (and j \u2208 Ni) throughout this paper. We formulate FAIR-T and FAIR-S as minmax programs as follows.\n(PT) min max \\((wj = \\sum_{i\\sim j}\\frac{ x_{ij}\u00b7 \\frac{\\sum_{l\\sim i} x_{il}\u03bb}{\u00b5_{i}}}{1 - \\frac{\\sum_{l\\sim i} x_{il}\u03bb}{\u00b5_{i}}}\u00b7\u00b5_{ij}}{\\frac{1}{\u00b5_{ij}}}\\), j\u2208J)\n\\(x_j := \\sum_{i \\sim j} x_{ij} = 1, \\forall j\\in J\\)\n\\(p_i = \\sum_{l \\sim i}x_{il}\u03bb/\u00b5_{il} \\leq 1, \\forall i\\in I\\)\n\\(0 \\leq x_{ij} \\leq 1, \\forall (ij) \\in E\\)\n(PS) min max \\(p_i\\),\niel\n\\(x_j := \\sum_{i \\sim j} x_{ij} = 1, \\forall j\\in J\\)\n\\(p_i = \\sum_{l \\sim i}x_{il}\u03bb/\u00b5_{il} \\leq 1, \\forall i\\in I\\)\n\\(0 \\leq x_{ij} \\leq 1, \\forall (ij) \\in E\\)\nWe refer to the above programs as PT and PS, respectively. Let \\(x^*\\) and \\(x^{\\Box}\\) be optimal solutions to PT and PS, respectively.\nLemma 1. \u03c0(\\(x^*\\)) and \u03c0(\\(x^{\\Box}\\)) are optimal policies under FAIR-T and FAIR-S, respectively."}, {"title": "3 The Relation Between the Two Fairness Optimization Problems", "content": "Consider a general setting denoted by \u03bc := (\u00b5ij), where \u00b5ij with (ij) \u2208 E represents the parameter for the exponential distribution of the service time taken by worker i to serve task j. Let \\(\\eta_t(\\mu, x)\\) denote the objective value of PT(\u03bc) with respect to the input u and a feasible solution x = (xij). Similarly, \\(\\eta_s(\\mu, x)\\) denotes the objective value of PS(\u03bc). When the context is clear, we may omit either the first or second argument for \\(\\eta_t\\) and \\(\\eta_s\\). For any given input \u03bc, let \\(\\eta_t^*(\\mu)\\) and \\(\\eta_s^*(\\mu)\\) denote the optimal values of PT(\u03bc) and PS(\u03bc) respectively.\nTheorem 1. Let \\(x^{\\Box}\\) be an optimal solution to PS(\u03bc). We have\n\\[\\eta_t (\\mu,x^\\Box) \\leq \\frac{1+ \\frac{K-1}{1 -\\eta_s^* (\\mu)} \\eta_s^* (\\mu)}{\\frac{1}{K}} = K \\cdot \\Big( 1 + \\frac{K-1}{1 -\\eta_s^* (\\mu)} \\Big) \\cdot \\eta_s^* (\\mu),\\quad \\quad (14)\\]\nwhere \\(K = \\max_{i\\in I} \\Big( \\max_{j\\sim i,j'\\sim i} \\frac{P_{ij}}{P_{i,j'}} \\Big) \\geq 1\\), which captures the maximum pairwise ratio among the expectations of all service time on each given worker.\nFor a private case of Theorem 1- where \u043a = 1 we prove that \\(\\eta_t (\\mu,x^\\Box) = \\eta_s^* (\\mu)\\) (Theorem 2).\nThese results serve as the bedrock of the whole proof for Theorem 1, which is deferred to the Appendix for space reasons. Toward the proof of K = 1, we first define the following minimax programs and show their equivalence to PT and PS, respectively, for k = 1.\n(PT) min max \\\\((w_j =  \\frac{\\lambda}{\\mu_j} \\sum_{i\\sim j} \\frac{X_{ij}}{1-P_i} ),\\quad\\quad (15)\\\\)\n\\(x_j := \\sum_{i \\sim j} x_{ij} = 1,\\quad \\forall j\\in J \\quad \\quad (16)\\\n\\(P_i = (\u03bb/\u00b5\u2081) \u2211 Xij \u2264 1, Vi e I \\quad \\quad (17)\\\n\\(0 \u2264 Xij \u2264 1, (ij) \u2208 E. \\quad \\quad (18)\\\n(PS) min max pi, \\quad \\quad (19)\niel\n\\(x_j := \\sum_{i \\sim j} x_{ij} = 1, \\forall j\\in J \\quad \\quad (20)\\\n\\(Pi = (\u03bb/\u03bc\u2081) \u2211 xij \u2264 1, Vi \u2208 I \\quad \\quad (21)\\\n\\(0 \u2264 Xij \u2264 1, (ij) \u2208 E. \\quad \\quad (22)\\\nLemma 3. For k = 1, the programs PT and PT are equivalent and the programs PS and PS are also equivalent."}, {"title": "4 Experiments", "content": "This section presents an algorithm derived from solutions to one of the minimax problems. We also describe a heuristic based on this algorithm, which gives preference to assigning tasks to available workers, thereby enhancing allocation through the effective workload of free workers. In addition, this section introduces two real-time greedy heuristics, which function as baseline methodologies.\nMinimax problems based algorithm: We first describe Algorithm 1. This algorithm has offline and online phases. In the offline phase (line 2), a solution to one of the minimax problems is computed. In the online phase (lines 4-7), when a task arrives, the task is assigned to the queue of a worker according to the probabilities computed by the program in the offline phase. This algorithm has two variants: One solves PT in the offline phase while the other solves PS.\nMinimax problems based heuristic: A notable issue with Algorithm 1 is that tasks can wait for a busy worker despite other available workers. This leads to suboptimal performance. To address this, we create a heuristic based on Algorithm 1. Like Algorithm 1, in Algorithm 2, task assignment probabilities are computed offline to mitigate this problem. In the online phase, incoming tasks are assigned to free workers. If multiple workers are free, their precomputed probabilities (from the offline phase) are normalized to sum to 1. A worker is subsequently chosen randomly, guided by these normalized probabilities. If there are no free workers, the tasks are assigned according to their probabilities as in Algorithm 1. Algorithm 2 describes this heuristic. As in Algorithm 1, there are two variants of Algorithm 2: One solves PT in the offline phase, while the other solves PS.\nThis method targets reduced waiting times, especially during low-load periods. However, this change might decrease worker workload or waiting times for other tasks, as it deviates from calculated optimal probabilities. In practice, we find that the trade-off for worker and task fairness is reasonable, given the substantial benefits for all tasks' fairness.\nComputational complexity of Algorithms 1 and 2 Both algorithms 1 and 2 have offline and online phases. The offline phase is identical for both algorithms and requires the solution of PT or PS. Following [Cohen et al., 2021], the runtime for solving the linear program- PS can be as low as \\(O^* (N^{2+1/6}log(N/d))\\), where d is the relative accuracy and"}, {"title": "4.2 Experimental Settings", "content": "We ran experiments on the teleoperation domain. As already mentioned in Section 1, the teleoperation of AVs involves intervention tasks that are assigned to the teleoperators who perform them. We adapted the dataset of [Ackerman Viden et al., 2023] for our two-sided fairness study. More details about the experimental settings and additional experimental results have been moved to the Appendix. Source code and data for running the experiments are available at [Trabelsi, 2024].\nThe tasks, their durations and their arrival rates Our study built upon the four task types defined by Viden et al. (2023). Their dataset provided valuable insights into the average duration times for each teleoperator (worker) and task type in a simulation. We explored three distinct approaches to define task duration in our experiments. All approaches involved sampling durations from exponential distributions, but the difference lay in the means of these distributions.\nThe teleoperators and the tasks they can perform Using the dataset of Viden et al. (2023), we initially had 10 teleoperators (workers) and 4 task types. We form a bipartite graph with 10 teleoperators on one side and 4 task types on the other. The dataset provides average task completion times for each teleoperator-task pair. An edge is established between a teleoperator and a task type if their average time matches or exceeds the task type's median value. Following this process,"}, {"title": "4.3 Results and Discussion", "content": "Effect of changing K In Figures 2(a,b), we illustrate the performance of various methods across diverse k values. In Figure 2(a), we measure the maximum task waiting time. We see that the gap between SIM(PS) and SIM(PT), as well as the gap between SIM-F(PS) and SIM-F(PT), increase with \u03ba. This aligns with the fact that with higher values of k, the approximation ratio of PS's solution relative to PT's objective is greater. However, the ratio between the different methods measured in practice is lower than the worst-case theoretical ratio given by Theorem 1 (which is greater than \\(K^3\\)).\nIn Figure 2(b), we measure the maximum worker workload. The differences between SIM(PT) vs SIM(PS) are very small for k \u2264 3, but they become more significant for \\(K\\)\u2208 {4,5}. Surprisingly, there is a different effect with SIM-F(PT) and SIM-F(PS). SIM-F(PT) performs slightly better than SIM-F(PS). We conjecture that the initial selection of free workers has a more detrimental effect in SIM-F(PS), which integrates two distinctly different methods, in contrast to the relatively similar approaches in SIM-F(PT). We also see that for larger values of k, both SIM(PT) and SIM(PS) perform worse than for lower values.\nEffect of changing the task load Figures 2(c,d) might help the teleoperation center's owner decide whether the current number of workers is sufficient. It is noticeable that in Figure 2(c) there is a significant jump from 120000 to 140000 tasks per day. This means that perhaps the owner should employ more workers in this case. Referring to Figure 2(d) may lead us to similar conclusions. Employing more workers is advisable if individual worker workload is excessively high.\nEffect of changing the task balance Figures 2(e,f) represent the performance of the different algorithms when changing the task balance. The left bar represents an even distribution for each task type (0.25). The second bar represents"}, {"title": "5 Conclusion", "content": "This paper addresses two-sided fairness problems represented as online bipartite matching with accommodated delays. We introduce two minimax problems: PT to minimize the maximum workload of workers and PS to minimize the maximum waiting time of tasks. We show that the second problem can be formulated as a linear program and thus solved efficiently. Moreover, we showed that the policy using a solution for PS approximates the solution for PT, and we then presented an upper bound on the approximation ratio. Finally, we compared the performance of different approaches (most of them used the solutions to the problems) and empirically evaluated their performance.\nFuture research may explore different definitions of fairness."}]}