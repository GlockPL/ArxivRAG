{"title": "Platform-Aware Mission Planning", "authors": ["Stefan Panjkovic", "Alessandro Cimatti", "Andrea Micheli", "Stefano Tonetta"], "abstract": "Planning for autonomous systems typically requires reasoning with models at different levels of abstraction, and the harmonization of two competing sets of objectives: high-level mission goals that refer to an interaction of the system with the external environment, and low-level platform constraints that aim to preserve the integrity and the correct interaction of the subsystems. The complicated interplay between these two models makes it very hard to reason on the system as a whole, especially when the objective is to find plans with robustness guarantees, considering the non-deterministic behavior of the lower layers of the system.\nIn this paper, we introduce the problem of Platform-Aware Mission Planning (PAMP), addressing it in the setting of temporal durative actions. The PAMP problem differs from standard temporal planning for its exists-forall nature: the high-level plan dealing with mission goals is required to satisfy safety and executability constraints, for all the possible non-deterministic executions of the low-level model of the platform and the environment. We propose two approaches for solving PAMP. The first baseline approach amalgamates the mission and platform levels, while the second is based on an abstraction-refinement loop that leverages the combination of a planner and a verification engine. We prove the soundness and completeness of the proposed approaches and validate them experimentally, demonstrating the importance of heterogeneous modeling and the superiority of the technique based on abstraction-refinement.", "sections": [{"title": "Introduction", "content": "A commonly employed architecture to realize autonomous systems consists in using automated planning for the synthesis of plans to achieve given mission goals, which are then executed on the system's platform (and the environment the system operates in). This separation of concerns allows the planner to reason on a high-level model, disregarding details and non-deterministic behaviors of the platform. However, in safety-critical applications, the mission objectives (also called \"science objectives\", in the space domain) often conflict with the safety constraints dictated by the platform and the environment (also called \"engineering constraints\"). The former are easily expressible as goals in the planning problem and are existential in nature (i.e., one needs to find any plan achieving the goals), whereas safety constraints are universally quantified over all the possible executions of the given plan (i.e., one needs to prevent any execution violating the safety). To represent this scenario and to offer reasoning guarantees on the autonomous system as a whole, we need to model both the planning objectives and the possible platform behaviors, formalizing the link between these levels.\nIn this paper, we aim at finding solution plans achieving high-level mission goals and offering formal robustness guarantees on the execution of such plans on the platform. We formalize and tackle the \"Platform-Aware Mission Planning\" (PAMP) problem, which aims at finding a plan guaranteed to achieve the mission objectives, such that all the possible evolutions of the platform controlled by the plan satisfy a set of safety and executability properties, taking into account both the flexibility of the execution platform (that is, the possible choices the platform can operate while obeying a given plan) and the non-determinism from the environment. Concretely, we propose a formal framework, in which a high-level temporal planning representation is coupled with a low-level description of the platform that executes the generated plans. We use a standard temporal planning model adapted from Gigante et al. (2022) and a timed automaton (Alur and Dill 1994) to represent the platform level. This formal framework uses existing models and is thus easily instantiated in practice; moreover, it mirrors the architecture of real-world autonomous systems (Gat 1998).\nWe propose two techniques to solve the PAMP problem. First, we develop a baseline \u201camalgamated\" approach grounded in Satisfiability Modulo Theory (SMT) (Barrett et al. 2009): we combine a standard encoding for temporal planning with a novel encoding for the executability and safety of a symbolic temporal plan. The resulting formula is quantified (\u2200), mirroring the intuitive quantifier alternation in the problem definition. Second, we propose a much more efficient approach exploiting the subdivision of the framework in two layers of abstraction. The technique uses a state-of-the-art heuristic search temporal planner to generate candidate plans, which are then checked for safety and executability, explaining the conflicts as sequences of events that the planner is required to avoid for subsequent candidates. This check employs a specialized version of the amalgamated SMT encoding. We formally prove the soundness and completeness of the proposed approaches and we develop two scalable case-studies to empirically evaluate them, showing their empirical effectiveness."}, {"title": "Background", "content": "Temporal Planning We start by defining the syntax of a temporal planning problem: we adapt the formal model used by Gigante et al. (2022), which is quite close to PDDL 2.1 level 3 (Fox and Long 2003).\nDefinition 1 (Temporal Planning Problem). A temporal planning problem \u03a0 is a tuple $\u27e8P, A, I,G\u27e9$, where $P$ is a set of propositions, $A$ is a set of durative actions, $I : P \u2192 {T, \\bot}$ is the initial state and $G \u2286 P$ is the goal condition. A snap (instantaneous) action is a tuple $h$ $\u27e8pre(h), eff^+ (h), eff^\u2212(h)\u27e9$, where $pre(h) \u2286 P$ is the set of preconditions and $eff^+ (h), eff^\u2212 (h) \u2286 P$ are two disjoint sets of propositions, called the positive and negative effects of $h$, respectively. We write $eff(h)$ for $eff^+(h)\u222aeff^\u2212 (h)$. A durative action $a \u2208 A$ is a tuple $(a^\u2212, a^+, pre\u2194(a), [L_a, U_a])$, where $a^\u2212$ and $a^+$ are the start and end snap actions, respectively, $pre\u2194(a) \u2286 P$ is the over-all condition, and $L_a \u2208 Q_{>0}$ and $U_a \u2208 Q_{>0}\u222a {\u221e}$ are the bounds on the action duration.\nA (time-triggered) plan is defined as a set of triples, each specifying an action, its starting time and its duration.\nDefinition 2 (Plan). Let \u03a0 = $\u27e8P,A,I,G\u27e9$ be a temporal planning problem. A plan for \u03a0 is a set of tuples $\u03c0 = {(a_1, t_1, d_1), ..., (a_n, t_n, d_n)}$, where, for each $1 \u2264 i \u2264 n$, $a_i \u2208 A$ is a durative action, $t_i \u2208 Q_{>0}$ is its start time, and $d_i \u2208 Q_{>0}$ is its duration.\nWe will call length of a time-triggered plan \u03c0 (denoted with $|\u03c0|$) the number of snap actions in \u03c0 (i.e. twice the number of durative actions).\nA time-triggered plan \u03c0 is a solution plan for the problem \u03a0 if, starting from the initial state $I$, each durative action in the plan can be applied at the specified time with the given duration (the preconditions of its start and end snap actions are true at the start and at the end of the action respectively), and if by applying all the effects a final state is reached after the end of the last action in which the goal condition is satisfied. The formal semantics is presented in (Gigante et al. 2022), which we omit here for the sake of brevity.\nWe assume a semantics without self-overlapping of actions (Gigante et al. 2022), which makes the temporal planning problem decidable: it is not possible for two instances of the same ground action to overlap in time.\nDefinition 3 (Action self-overlapping). A plan ${\u27e8a_1, t_1, d_1\u27e9,..., \u27e8a_n, t_n, d_n\u27e9}$ is without self-overlapping if there exist no i,j \u2208 $\\{1, ..., n\\}$ such that $a_i = a_j$ and $t_i \u2264 t_j < t_i + d_i$.\nThis formal model of temporal planning is simplified with respect to concrete planning languages (e.g. for the sake of simplicity we only defined the ground model, while most languages allow a first-order lifted representation for compactness), but it already achieves the full computational complexity of very expressive languages such as ANML (Gigante, Micheli, and Scala 2022).\nTimed Automata Here, we recall the standard definitions.\nDefinition 4 (Clock constraints). Let $X$ be a finite set of elements called clocks. A clock constraint is a conjunctive formula of atomic constraints of the form $x \u223c n$ or $x \u2212 y \u223c n$, where $x, y \u2208 X$, $\u223c\u2208 \\{<, \u2264, =, \u2265, >\\}$ and $n \u2208 N$. We use $C(X)$ to denote the set of clock constraints on $X$.\nA Timed Automaton generalizes finite-state automata by means of clock variables that can be reset and track the advancement of time.\nDefinition 5 (Timed Automaton). A Timed Automaton (TA) is a tuple $T = (\u03a3, L, l_0, X, \u2206, Inv)$, where:\n\u2022 $\u03a3$ is the alphabet;\n\u2022 $L$ is a finite set of locations;\n\u2022 $l_0 \u2208 L$ is the initial location;\n\u2022 $X$ is a finite set of clocks;\n\u2022 $\u2206 \u2286 L \u00d7 C(X) \u00d7 \u03a3 \u00d7 2^X \u00d7 L$ is the transition relation;\n\u2022 $Inv : L \u2192 C(X)$ maps each location to its invariant.\nWe will write $l \\xrightarrow{g,a,r} l'$ when $(l, g,a,r,l') \u2208 \u2206$.\nDefinition 6 (State of TAs). Given a TA $T = (\u03a3, L, l_0, X, \u2206, Inv)$, a state of $T$ is a pair $(l, u)$, where $l \u2208 L$ and $u : X \u2192 R_{\u22650}$ is a clock assignment.\nWe use $u \\models g$ to mean that the clock values denoted by $u$ satisfy the guard $g \u2208 C(X)$. For $d \u2208 R_{\u22650}$, we use $u + d$ to denote the clock assignment that maps all clocks $c \u2208 X$ to $u(c) + d$. For $r \u2286 X$, we use $[r \u2192 0]u$ to denote the clock assignment that maps all $c \u2208 r$ to 0, and all $c \u2208 X\\r$ to $u(c)$.\nDefinition 7 (Semantics of TAs). The semantics of a TA is defined in terms of a transition system, with states of the form $(l, u)$ and transitions defined by the following rules:\n\u2022 $\u27e8l, u\u27e9 \\xrightarrow{d} \u27e8l, u + d\u27e9$ if $u \\models Inv(l)$ and $(u + d) \\models Inv(l)$, for $d \u2208 R_{\u22650}$;\n\u2022 $\u27e8l, u\u27e9 \\xrightarrow{g,a,r} \u27e8l', u'\u27e9$ if $l \\xrightarrow{g,a,r} l'$, $u \\models g$, $u' = [r \u2192 0]u$ and $u' \\models Inv(l')$.\nDefinition 8 (Timed trace). Let $T = (\u03a3, L, l_0, X, \u2206, Inv)$ be a TA. A timed action is a pair $(t, a)$, where $t \u2208 R_{\u22650}$ and $a \u2208 \u03a3$. A timed trace is a (possibly infinite) sequence of timed actions $\u03be = \u27e8\u27e8t_1, a_1\u27e9, \u27e8t_2, a_2\u27e9,..., \u27e8t_i, a_i\u27e9,...\u27e9$, where $t_i \u2264 t_{i+1}$ for all $i \u2265 1$.\nDefinition 9 (Run of a TA). The run of a TA $T = (\u03a3, L, l_0, X, \u2206, Inv)$ with initial state $(l_0, u_0)$ over a timed trace $\u03be = \u27e8\u27e8t_1, a_1\u27e9, \u27e8t_2, a_2\u27e9,...\u27e9$ is the sequence of transitions $\u27e8l_0, u_0\u27e9 \\xrightarrow{d_1, a_1} \u27e8l_1, u_1\u27e9 \\xrightarrow{d_2, a_2} \u27e8l_2, u_2\u27e9...$, where $d_1 = t_1$ and $d_i = t_i - t_{i\u22121}$ for all $i \u2265 2."}, {"title": "Problem definition", "content": "In this section, we formalize our composite framework and the Platform-Aware Mission Planning (PAMP) problem.\nIn our framework, we consider an autonomous system architecture with two layers of abstraction: a planning layer, represented as a temporal planning problem, describing the high-level durative actions and a mission goal; and a platform layer, represented as a TA, which describes the low-level details and internal actions of the platform that is controlled by the planner. We consider an interface between the two layers where each start and end event of an action of the planning problem is associated with a signal of the TA (a letter of its alphabet), and define the execution of a time-triggered plan by synchronizing the action start/end commands of the plan with transitions of the platform labeled with the corresponding events. In the time between two high-level commands, the platform can freely evolve by performing internal transitions and advancing time.\nExample. Figures 1a and 1b show a small running example of the considered framework. An industrial process needs to be completed by starting a \"Process\" (P) action and applying in parallel two \"Work\" (W) actions. In the planning model, we have a Boolean variable processing (initially false) and a bounded integer variable completed-steps (initially 0).\nThe \"Process\u201d action sets the processing variable to true at the start, and sets it back to false at the end. The \"Work\" action has an over-all condition requiring the processing variable to be true during the entire duration of the action, and an end effect that increments the value of the completed-steps variable by 1. There is also a \"Cooldown\" action, which does not have any effect on the variables of the planning model. The goal requires that the \"Work\" action is applied two times (i.e. completed-steps == 2). At the platform layer, modeled by the TA shown in Fig. 1a, there are transitions with labels corresponding to the start/end events of the high-level durative actions (e.g. W- corresponds to the start of the \"Work\" action), and internal transitions that the platform can take, which are not linked to high-level events (the transitions with label \u03c4 in this example). The TA encodes a low-level constraint between successive applications of the \"Work\" actions that is not modeled in the planning problem: when a \"Work\" action is performed (reaching the W_ENDED location), a component becomes heated and needs to cool down before the next \"Work\" action can be applied, and this occurs either by waiting 10 time units (transition from W_ENDED to W_RESUMING with guard c \u2265 10), or by explicitly applying a \"Cooldown\" action which cools the component after 2 time units (transitions to C_STARTED and P_STARTED with labels C and C+). Moreover, the process has a deadline of 50 time units, after which the platform can reach an undesirable state (transition from W_ENDED to BAD with guard cp > 50).\nWe start by introducing the notion of states that are reachable by executing a plan on a TA. Intuitively, the states that can be reached by executing a sequence of timed snap actions \u03c1 on a TA T, are all the states that belong to a run of T where all and only the snap actions in \u03c1 are applied, by taking the corresponding transitions at the times specified in \u03c1. We formally define this with a function H, that maps the snap actions of \u03c1 with steps in the run of T where the transitions with the corresponding labels are taken.\nDefinition 10 (States reachable by plan execution). Let \u03a0 = $\u27e8P, A, I, G\u27e9$ be a temporal planning problem, and let $T = (\u03a3, L, l_0, X, \u2206, Inv)$ be a TA such that $\u03c4_a^\u2212, \u03c4_a^+ \u2208 \u03a3$, for all actions $a \u2208 A$. Let $\u03c1 = \u27e8\u27e8t_1, e_1\u27e9,..., \u27e8t_n, e_n\u27e9\u27e9$ be a (possibly empty) ordered sequence of timed snap actions of \u03a0, where $t_i < t_{i+1}$ for all $i \u2208 \\{1, ..., n \u2212 1\\}$. A state $r_s$ is \"reachable\" by executing \u03c1 on T from the initial state $r_0 = (l_0, u_0)$ if and only if there exists a run $r_0 \\xrightarrow{d_1, \u03c3_1} ... \\xrightarrow{d_k, \u03c3_k} r_k$, with $0 \u2264 s \u2264 k$, and an injective function $H : \\{0, 1, ..., n\\} \u2192 \\{0, 1,..., k\\}$ with the following properties:\n1. $H(0) = 0$ (Required to handle the case with $\u03c1 = \u27e8\u27e9$);\n2. for all $i \u2208 \\{1, . . ., n\\}$, for all $j \u2208 \\{1, ..., k\\}$, if $H(i) = j$ then $r_j \\xrightarrow{\u03c3_j} e_i$; and $t_i = \\sum_{l=1}^i d_l$;\n3. for all $j \u2208 \\{1,..., k\\}$, if $j \\notin Im(H)$ then for all $e \u2208 \\{\u03c4_a^\u2212, \u03c4_a^+ : a \u2208 A\\}$, $\u03c3_j \\neq \u03c4_e$.\nWe define analogously the set of states that are reachable after executing \u03c1 on T from the initial state $r_0$, denoted by $ReachableAfter_T(r_0, \u03c1)$ (while in the previous definition we consider all states $r_s$ along the run, here we include in the set only the final state $r_k$).\nIn the running example, consider the sequence \u03c1 = $\u27e8\u27e80, P-\u27e9, \u27e81, W-\u27e9, \u27e821, W+\u27e9\u27e9$. Then we have that\n$Reachabler (OFF, \u03c1)$ =\n$\\{OFF, P\\_STARTED, W\\_STARTING, W\\_STARTED, W\\_ENDED, BAD\\}$\n$ReachableAfter_T(OFF, \u03c1)$ = $\\{W\\_ENDED, BAD\\}$\nFor instance, $BAD \u2208 ReachableAfter_T(OFF, \u03c1)$ since there exists the run $OFF \\xrightarrow{d_1=0, \u03c3_1=P-} P\\_STARTED \\xrightarrow{d_2=1, \u03c3_2=W-} W\\_STARTING \\xrightarrow{d_3=2, \u03c3_3=\u03c4} W\\_STARTED \\xrightarrow{d_4=18, \u03c3_4=W-} W\\_ENDED \\xrightarrow{d_5=31, \u03c3_5=\u03c4} BAD$ and the function H s.t. H(1)=1, H(2) = 2 and H (3) = 4, satisfying Definition 10.\nNext, we formalize the notion of executability of a time-triggered plan on the platform. Intuitively, we say that a time-triggered plan is executable on a TA if every snap action of the plan is applicable at the prescribed time, for any possible internal behavior of the platform, assuming that the platform applied all the previous commands of the plan. A snap action is applicable if a corresponding transition can be taken at the time specified in the plan.\nFormally, given a state $(l, u)$ of T, a snap action $\u03c4_e$ is applicable in $(l, u)$ if and only if there exists a transition $l \\xrightarrow{g, \u03c4_e, r} l'$ such that $u \\models g$ and $[r \u2192 0]u \u2208 Inv(l')$.\nFor a time-triggered plan \u03c0 = ${\u27e8a_1, t_1, d_1\u27e9,..., \u27e8a_n, t_n, d_n\u27e9}$, we indicate with $\u03c1_\u03c0 = \u27e8\u27e8t_1, \u03c4_{a_1}^\u2212\u27e9,..., \u27e8t_{2n}, \u03c4_{a_n}^+\u27e9\u27e9$ the ordered sequence of timed snap actions of \u03c0, with $t_i < t_{i+1}$ for all $i\u2208 \\{1,..., 2n \u2212 1\\}$. For simplicity, we assume that all the valid plans of the considered planning problems do not contain simultaneous events, i.e. snap actions scheduled at the same time: since the semantics of TA is super-dense (multiple discrete steps can be taken at the same time in a specific order), in order to properly define and check the executability of a plan with simultaneous events for all platform behaviors, all the possible orderings for the sets of simultaneous events would need to be considered. Given a sequence of timed snap actions $\u03c1 = \u27e8\u27e8t_1, e_1\u27e9, . . ., \u27e8t_n, e_n\u27e9\u27e9$, we denote with $\u03c1_i = \u27e8\u27e8t_1, e_1\u27e9, ..., \u27e8t_i, e_i\u27e9\u27e9$ the prefix obtained by considering the first $i \u2264 n$ timed snap actions. We denote with $\u03c1_0 = \u27e8\u27e9$ the empty sequence.\nDefinition 11 (Time-triggered plan executability on TA). Let \u03a0 be a temporal planning problem and let T be a TA with initial state $r_0 = (l_0, u_0)$. Suppose that T has a global clock \u03b3 that is not reset in any transition and has value 0 in the initial state. An ordered sequence of timed snap actions $\u03c1 = \u27e8\u27e8t_1, e_1\u27e9,..., \u27e8t_n, e_n\u27e9\u27e9$ is executable on T if and only if for all $i \u2208 \\{0,...,n \u2212 1\\}$, for all $r = (l,u) \u2208 ReachableAfter_T(r_0, \u03c1_i)$, if $u(\u03b3) = t_{i+1}$ then $e_{i+1}$ is applicable in r. A time-triggered plan \u03c0 of \u03a0 is executable on T if its sequence of timed snap actions $\u03c1_\u03c0$ is executable on T.\nFor example, the sequence $\u03c1 = \u27e8\u27e80, P-\u27e9, \u27e81, W-\u27e9, \u27e821, W+\u27e9, \u27e822, W-\u27e9, \u27e842, W+\u27e9, \u27e845, P+\u27e9\u27e9$, which corresponds to the second plan in Fig. 1b is not executable on the TA of Fig. 1a, because it is possible to reach location W_ENDED with \u03b3 = 22 and c = 1 (this state belongs to ReachableAfter_T(r_0, \u03c1_3)) and the transition with label W- is not applicable (the guard c \u2265 10 is false).\nWe formalize the notion of safety for a plan w.r.t a TA, given a set of bad states B, by requiring that all the states that can be reached by executing $\u03c1_\u03c0 = \u27e8\u27e8t_1, e_1\u27e9,..., \u27e8t_n, e_n\u27e9\u27e9$, within time $t_n$, do not belong to B.\nDefinition 12 (Plan safety w.r.t. TA). Let \u03a0 be a temporal planning problem and let T be a TA with initial state $r_0 = (l_0, u_0)$. Suppose that T has a global clock \u03b3 that is not reset in any transition and has value 0 in the initial state. Let $B \u2286 L \u00d7 R^X$ be a set of bad states for T. An ordered sequence of timed snap actions $\u03c1 = \u27e8\u27e8t_1, e_1\u27e9, ..., \u27e8t_n, e_n\u27e9\u27e9$ is B-safe w.r.t. T if and only if for all states $r = (l,u) \u2208 Reachabler (r_0, \u03c1)$ such that $u(\u03b3) < t_n$, $r \\notin B$. A time-triggered plan of \u03a0 is B-safe w.r.t. T if its sequence of timed snap actions $\u03c1_\u03c0$ is B-safe w.r.t. T.\nConsider the running example, and suppose that B is the set of all states with location BAD. The sequence \u03c1 = $\u27e8\u27e80, P-\u27e9, \u27e81, W-\u27e9, \u27e821, W+\u27e9, \u27e832, W-\u27e9, \u27e852, W+\u27e9, \u27e855, P+\u27e9\u27e9$, which corresponds to the first plan in Fig. 1b, is not B-safe, because it is possible to reach location BAD with \u03b3 = 53 between the application of the last two snap actions $\u27e852, W+\u27e9$ and $\u27e855, P+\u27e9$ (this state belongs to Reachabler(r_0, \u03c1)).\nWe can now formally define the PAMP problem, where the objective is to find a solution plan for the planning problem, such that it is safe and executable for all the platform traces that are compliant with the plan.\nDefinition 13 (PAMP). A Platform-Aware Mission Planning (PAMP) problem is a tuple $Y = (\u03a0, T, B)$, where \u03a0 is a temporal planning problem, T is a TA, and $B \u2286 L \u00d7 R^X$ is a set of bad states for T. A solution for Y is a plan \u03c0 such that: (i) \u03c0 is a valid solution plan for \u03a0; (ii) \u03c0 is executable on T; (iii) \u03c0 is B-safe w.r.t. T.\nThe third plan in Fig. 1b is a solution for the example PAMP problem. The application of the \"Cool\" action between the two \"Work\" actions makes it fully executable and safe, since the BAD is unreachable (cp > 50 remains false)."}, {"title": "Solution approaches", "content": "In this section, we propose two approaches for solving the PAMP problem. We assume that a constant k is given, which represents the maximum possible ratio between the length of a platform trace and the length of the executed plan. Hence, when considering a plan \u03c0 of length L (the number of snap actions in the plan), we will analyze its safety and executability for platform traces of length up to kL. It is reasonable to assume that such a constant exists and that it can be computed for a platform, as plans have a finite duration and in most practical systems only a finite number of transitions can be taken in a given time.\nEncoding-based approach We will now describe our SMT encoding of the PAMP problem (Fig. 2). Consider a temporal planning problem \u03a0, a timed automaton T modeling the platform, a set of bad states B, and a bound h on the length of the plan. We assume that T contains a global clock \u03b3 with initial value 0, that is never reset in any transition. The encoding represents two distinct traces: a plan trace with h timed steps, and a platform trace with kh timed steps. In each step of a plan trace at most one snap action can be applied (as we discussed in the previous section).\nWe start by defining the variables of our encoding. For every step i \u2208 $\\{1, ..., h\\}$ of the plan trace, we use the real variable $t_i$ to denote the time associated to step i; for every action a, we use the Boolean variable $a^h_i$ to denote whether the action a is started at step i, and the real variable $d^a_i$ to represent the duration of action a when started at step i. For every step i \u2208 $\\{1,...,kh\\}$ of the platform trace, we use the variable $l_i$ to denote the location of T at step i; for every clock c, we use the variable $c_i$ to represent the value of clock c at step i (the value of the global clock \u03b3 at step i is $\u03b3_i$); finally, for every action a, we use the Boolean variable $\u03c4_i^{a+}$ (respectively $\u03c4_i^{a\u2212}$) to denote whether a transition with label $\u03c4_a^+$ (respectively $\u03c4_a^\u2212$) will be taken by T at step i."}, {"title": "Abstraction-refinement approach", "content": "In our second approach, based on an abstraction-refinement loop, we consider the planning problem and the validation problem separately: a temporal planner generates solution plans considering only the planning problem, and then the produced candidate plans are checked for executability and safety at the platform layer. Since we are considering time explicitly, it is not feasible to exclude single time-triggered plans at each validation check, as the planner, that is not aware of the platform constraints, can in most cases just slightly change the timing of the actions and the same problem would occur at the platform layer. Instead, at each failed validation check we want to exclude classes of plans, by determining that a certain sequence of discrete choices is infeasible, for any possible scheduling of the chosen snap actions.\nFor solving the planning problem, we rely on the TAMER temporal planner (Valentini, Micheli, and Cimatti 2019), which is a sound and complete approach for temporal planning that is able to return plans expressed as Simple Temporal Networks (STN) (Dechter, Meiri, and Pearl 1991): a returned solution STN is characterized by a fixed ordering of snap actions $e_1,...,e_n \u2190 PATH(\u03c0_{stn})$, with each snap action $e_i$ associated to a symbolic time $t_i$. The times are ordered increasingly, with additional constraints between pairs of start/end snap actions representing the duration constraints of the corresponding durative actions. The planning algorithm implements an explicit-state heuristic-search approach, that works by exploring all the possible ordered sequences of snap actions, and updating in each state a STN whenever a new snap action is added to the sequence. If the set of STN constraints of a state becomes infeasible, then it can be pruned, as it means that the chosen sequence of discrete events cannot be scheduled while respecting the temporal constraints of the problem. If a goal state is reached, then all the time-triggered plans that satisfy the STN constraints of that state are valid solution plans, and a specific solution can be extracted by solving the constraints.\nThe main idea of our approach is to validate on the platform the set of STN constraints $\u03c0_{STN}$ produced by the planner, using an encoding similar to the one of the previous approach (Fig. 2). If there exists a solution to the STN constraints, that satisfies the executability and safety notions for all the platform traces, then it corresponds to an answer to the PAMP problem. Otherwise, we determine the shortest prefix $e_1,..., e_i$ of the sequence of snap actions $PATH(\u03c0_{STN})$, such that by considering only the STN constraints of $e_1,..., e_i$, there does not exist a way to schedule them while guaranteeing executability and safety for all platform traces. If such a prefix is found, it can be learned by the planner, and all the states that are found during exploration whose path starts with a learned prefix can be pruned.\nThe overall procedure is detailed in Algorithm 1. The planning problem \u03a0 is solved, and we obtain a set of solution plans $\u03c0_{STN}$, characterized by a fixed order of snap actions $e_1,..., e_n \u2190 PATH(\u03c0_{stn})$, together with a set of temporal constraints between their associated times $t_1,..., t_n$. The solution $\u03c0_{STN}$ is then passed to CHECK, together with the set of bad states B. The CHECK procedure iterates over all the prefixes i \u2208 {1,...,n}, and builds the formula $\u03c0'_{STN}$, which is the subset of constraints of $\u03c0_{STN}$ considering only $t_1,..., t_i$ ([$\u03c0_{STN}$]_i is the conjunction of all the constraints containing $t_i$ and one of the times in $\\{t_1, . . ., t_{i\u22121}\\}$). The constraints $\u03c0'_{STN}$ are then used to produce the formula \u03a6i, which is an encoding of the PAMP problem, considering only candidate plans represented by $\u03c0'_{STN}$: in the formula of Fig. 2, PLANVALID\u03a0 is replaced with $\u03c0'_{STN}$, while the forall formula is simplified considering the specific discrete choices $e_1,..., e_i$ that are made by each plan represented by $\u03c0'_{STN}$ (for each step j \u2208 $\\{1, ..., i\\}$, the truth value of all the variables $a^h_i$ is known and can be substituted in the formula). The formula \u03a6\u2081 is then provided to an SMT solver: if it is unsatisfiable, then we can deduce that the prefix $e_1,..., e_i$ is not valid for the platform, for any possible scheduling of the snap actions that respects the planning constraints, and therefore this path can be \"learned\" by the planner and used for pruning; if it is satisfiable, then the next prefix can be considered, and if the whole plan was being considered then a final solution can be extracted from such a model.\nTheorem 2 (Soundness and completeness of abstraction-refinement algorithm). For every PAMP problem Y = (\u03a0, T, B) and every bound \u03ba:\n1. if PAMP-REF(\u03a0, T, B, \u03ba) terminates and returns plan \u03c0, then \u03c0 is a valid solution for Y;\n2. if there exists a solution for Y, then PAMP-REF (\u03a0, T, B,\u03ba) will eventually terminate and return a solution for Y.\nProof. (Sketch)\n1. Suppose that the procedure returns plan \u03c0. \u03c0 is a valid solution to the planning problem \u03a0, because of the soundness of the TAMER planner (Valentini, Micheli, and Cimatti 2019) and the correctness of the encoding of the STN constraints (that replace the formula $PLANVALID(t, a,d,h)$ in the $\u03a6_h$ encoding). The plan then satisfies an analogous encoding of the forall subformula of $\u03a6_h$ (which is simplied taking into account the specific action choices made by TAMER), and this guarantees the executability and safety properties (the proof follows the same reasoning of soundness in Theorem 1).\n2. If a solution \u03c0 to Y exists, then because of the completeness of the TAMER planner and the fact that the excluded prefixes do not satisfy the $\u03a6_h$ encoding, the plan will be eventually returned by TAMER (unless a different solution is found earlier for Y). The plan then satisfies an analogous encoding of the forall subformula of $\u03a6_h$, which confirms the executability and safety properties of \u03c0 (the proof follows the soundness in Theorem 1)."}, {"title": "Related Work", "content": "In this paper", "functions": "we allow for generic timed automata models.\nViehmann", "layers": "we use the labels in the timed automata to model \"commands\" that are sent by the plan, while Viehmann, Hofmann, and Lakemeyer use"}]}