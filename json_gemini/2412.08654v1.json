{"title": "A Behavior Tree-inspired programming language\nfor autonomous agents", "authors": ["Oliver Biggar", "Iman Shames"], "abstract": "We propose a design for a functional programming language for au-\ntonomous agents, built off the ideas and motivations of Behavior Trees\n(BTs). BTs are a popular model for designing agents behavior in robotics\nand AI. However, as their growth has increased dramatically, the simple\nmodel of BTs has come to be limiting. There is a growing push to in-\ncrease the functionality of BTs, with the end goal of BTs evolving into\na programming language in their own right, centred around the defining\nBT properties of modularity and reactiveness.\nIn this paper, we examine how the BT model must be extended in\norder to grow into such a language. We identify some fundamental prob-\nlems which must be solved: implementing 'reactive' selection, 'monitoring'\nsafety-critical conditions, and passing data between actions. We provide\na variety of small examples which demonstrate that these problems are\ncomplex, and that current BT approaches do not handle them in a manner\nconsistent with modularity. We instead provide a simple set of modular\nprogramming primitives for handling these use cases, and show how they\ncan be combined to build complex programs. We present a full specifi-\ncation for our BT-inspired language, and give an implementation in the\nfunctional programming language Haskell. Finally, we demonstrate our\nlanguage by translating a large and complex BT into a simple, unambigu-\nous program.", "sections": [{"title": "1 Introduction", "content": "How do we express agent behavior in a programming language? Understanding this question is key to designing reliable autonomy in robotics. Compared to traditional programming, autonomous systems present new challenges and requirements [19], in particular an emphasis on real-time behavior, safety and transparency. We would like to be able to design our autonomy in a language which is centred on these fundamental principles.\nOne model for behavioral programming is the Behavior Tree (BT) [10]. This tree-structured design originated in game AI, and has become significantly pop-ular in both game AI and robotics [16, 26]. Their popularity reflects their simple and effective design philosophy, which places the key principles of modularity and real-time reactiveness in a central role [9, 5]. The building blocks of BTs (the leaves of the tree) are asynchronous actions, which can take time and suc-ceed or fail. We build more complex behaviors from these actions through by composition, using a small number of 'control flow nodes'. This gives the model a simple tree structure, and reasoning about behavior remains straightforward, even as the tree grows. Further, the two main control flow nodes, Sequence and Fallback, have built-in real-time reactiveness to unexpected events [26], reflect-ing the importance of this kind of behavior in building autonomous systems.\nThe importance of modularity and reactiveness is one of the main differences between BTs and the previously-dominant behavioral model, Finite State Ma-chines (FSMs) [15]. FSMs are an expressive model with uses in many fields, but this flexibility can lead to abuse, and in practice FSMs can grow to great size and complexity as the modelled behavior grows [10]. The structure of FSMs is similar to early imperative languages which made extensive use of the goto statement [11], resulting in unreadable 'spaghetti code' [10]. BTs, by contrast, have a structure which resembles a function call, and this programming analogy is a one of the original motivations for BTs [24]. This reflects a general program-ming principle learned in the structured programming revolution: a language should not only make good programming easy, it should make bad programming difficult. BTs isolated the strengths and weakness of FSMs, and built these into a new model which strictly enforced a modular design.\nMore generally, and perhaps unsurprisingly, programming language design has been a significant source of inspiration for both BT concepts and philosophy [10, 24, 3, 5]. A new ecosystem of tools has grown around the simple core model of BTs, augmenting them with constructs for handling data [29, 27], concurrency [7], parallelism [6], learning [30, 18], formal methods [2, 28], and much more [8, 16, 10, 13]. Moreover, tools exist to automatically generate code"}, {"title": "2 What are Behavior Trees?", "content": "We must firstly describe what a Behavior Tree is. There exist many variations in terminology, but for the purpose here we will follow the standard setup from [10], a well-known textbook on Behavior Trees in robotics. See Figure 2 for an example from [10]. For the unfamiliar, [10] provides a very thorough introduc-tion to BTs and their motivations.\nBehavior Trees are a tree-structured control architecture, designed to model the discrete task-switching behaviors of autonomous agents. This tree structure provides modularity each subtree can be treated as an individual behavior, with the internal nodes representing composition of behaviors. Execution of a BT proceeds through 'ticks', which are generated at the root and repeatedly poll the subtrees\u00b9Nodes execute when they are ticked. Internal nodes (called"}, {"title": "3 Reactiveness", "content": "Reactiveness, in the sense of being able to respond quickly to real-time stimuli, is critical in robotics [26]. BTs embrace the central role of reactiveness, and provide the means to construct reactive behavior using a small collection of"}, {"title": "3.1 Reactive selection and the \u2018progress problem'", "content": "The monitoring and reactive selection use cases we described above certainly seem like plausible uses of reactiveness, but why should they be the only uses of reactiveness? Why should we view these operations as the fundamental reactive constructions, rather than, for instance, Sequence and Fallback? Our argu-ment is that BTs which are not in particular decision-tree-like form which de-fines the reactive selection operation-suffer from a fundamental problem caused by the tick mechanism which defines Sequence and Fallback. Attempts to cir-cumvent this problem lead to confusing, non-modular and ambiguous BTs which mix reactive and non-reactive behavior.\nWe begin with a seemingly simple question: what does the Sequence op-eration mean? (Note that Fallback is the same as Sequence with the role of Success and Failure reversed, so we are simultaneously trying to understand Fallback). Consider a Sequence composition bhvr1 \u2192 bhvr2 of two Actions action1 and action2. The classical tick-based definition is the following: on each tick, the sequence node first ticks action1, which either: (i) returns Fail-"}, {"title": "3.2 When is reactiveness appropriate?", "content": "In the previous section we established that, because of the progress problem, we can only unambiguously interpret reactive BTs when they are in reactive selection form, where they reduce to reactive Decision Trees. We think that writing them explicitly in this form is clearer than using nested Sequence and Fallback.\nIf we are given a BT which is not in reactive selection form, and we want to express it unambiguously, we need to translate it into either non-reactive oper-ations, or reactive selection form. Often, both are possible: in this section we discuss the tradeoffs involved in choosing one or the other. We can summarise this section as follows: we should use reactiveness only when we explic-itly need some behaviors to interrupt other behaviors and in that case we should make very clear the circumstances under which interruption takes place.\nWe start with an example where interruptions, and so reactiveness, is ab-solutely necessary. Our example involves handling prioritised tasks, like the (battery>10% ? recharge) \u2192 task subtree in Fig 2, which in reactive se-lection form could be written as\nHere, the reactiveness is giving us a modular and readable behavior which imme-diately interrupts task when the battery is low, without the designer of task"}, {"title": "3.3 Pre-empting Success and Failure", "content": "One benefit of reactiveness, in the BT sense, is that we can skip actions that are not necessary [10]. For instance, in the above example, if the robot is in the room we can skip open door and passThrough door. Likewise, we can automatically recover from failures of preconditions, so, for instance, if the door closes while we are passing through it we immediately switch to open door.\nHowever, these benefits are not free. First, they only apply to behaviors whose Success and Failure can be represented by explicit success conditions. As we discussed in the circle example above, some behaviors do not have meaningful external conditions representing their Success or Failure. Even in our door example, these conditions can be questionable. Consider\nThis pre-emptively skips or interrupts passThrough door if its post-condition insideRoom is true. A benefit of this approach is that if we achieve entry into the room unexpectedly, for instance because a human operator moved the robot while passThrough door is running, we can interrupt it and move immediately to close door. In some applications, this may be useful, but here it is proba-bly too optimistic-do we need to account for this unexpected way to achieve success? Depending on its implementation, passThrough door may return Suc-cess in this case anyway. This comes at a cost too. We implicitly assumed that passThrough door was successful if and only if the condition insideRoom was true. While passThrough door should result in the robot being in the room, a good implementation would actually bring us some distance into the room, rather than pre-emptively interrupting passThrough door the moment we cross the threshold. In this case, it is probably simpler and more modular to use the non-reactive passThrough door \u2192* close door, allowing passThrough door to determine the distance it brings us into the room before succeeding, rather than interrupting it. Contrast this with a case like"}, {"title": "3.4 Chattering and one-sided reactiveness", "content": "Let's go back to the first example we used from Figure 2, which is\nAs we discussed in the previous section, handling prioritised tasks (in this case by ensuring we recharge whenever necessary) is one of the key use cases where reactiveness is needed. Specifically, we need to constantly check the battery level, and interrupt the task when that level is too low.\nHowever, reactive selections, like the if-statements they are based on, are symmetric with respect to the condition. So even though we interrupt task when the battery drops less than 10%, we symmetrically interrupt recharge when the level rises above 10%. This leads to chattering: the battery increases above 10%, so we resume task, then decreases below 10%, so we recharge, then increases above 10%, so we resume the task, and so on. We cannot avoid this behavior using only the reactive BT operations. But a non-reactive behavior also doesn't work we want one-directional reactiveness, so the battery level interrupts task but cannot interrupt recharge.\nWe call this situation monitoring, where we have prioritised tasks which can interrupt each other only in the order of priority. This is the idea behind Teleo-reactive programs [23]. Precisely, we want the following semantics.\nIn the context of our battery example, this would be monitor batteryLow recharge task. While running task we monitor the battery level, and when-ever it becomes 'low' we switch to recharge, which is run to completion, and then the whole tree is resumed. There is no chattering, and we can recharge as many times as necessary while performing the task. The subtree completes if we successfully complete task.\nWe can't implement monitor with the existing BT operations, without using additional variables. Even if we could define operations recursively (generally not possible in BT libraries) the closest analogue is:"}, {"title": "4 Data", "content": "Programming languages have two main roles: structuring instructions, and or-ganising data. Behavior Trees, with their roots in robotics and AI, have his-torically focused on the former. This makes sense; many simple behaviors are constructed simply from a sequence of instructions, and the agent does not need to pass data around.\nHowever, as robotic behaviors become more complex, manipulating data becomes just as important as in classical programming languages. For instance, many actions take data as an argument: in the previous section, the behaviors open, passThrough and close take a door object as an argument; moveTo takes a target location; and so on. Similarly, many actions also produce data: for instance, we might use an action findDoors to identify which doors are available; locateItem to find an item; or batteryLevel action to obtain the battery level as a number. If our subsequent actions or decision-making depends on the output of our current action, then we must have a mechanism for passing data within a BT.\nThis point has been recognised for a long time in the BT literature, and modern BT libraries have a number of approaches for handling data [8]. The classical approach is to use a Blackboard [10]. Essentially, a Blackboard is a location where variables can be freely written to and retrieved. That is, all variables are stored globally with no restrictions on access\u00b9\u00b2. Unfortunately, blackboards can be quite opaque, and they are not modular. In programming, we have known for a long time that global variables are not a good idea, because they break the modularity of structured programs, leading to cryptic bugs and generally difficult-to-read programs.\nBecause modularity is the critical property which separates BTs from FSMs, we want to pass data in a way which is as modular as possible. We choose a simple solution: behaviors are simply asynchronous functions, which can both take arguments and return values. When we want one behavior to have access to a value from another, we use function composition. In fact, because we view modularity as such a critical property in BTs, we take quite a strict approach to passing values: we only pass values through composition. This is the approach taken by Haskell.\nBTs combine behaviors using a small collection of operations. We want to integrate these operations with function composition. The first observation we need is that actually only one operation needs to be modified to handle data: (non-reactive) sequence. This is because this is the only operation which waits for its first argument to complete, successfully, before running its second argument. By contrast, (non-reactive) fallback runs its second argument when the first fails. In programming, a failed action returns an Exception rather than a value of its declared type. The reactive operations rSelect and monitor interrupt their arguments before they might return. Hence, all we need to"}, {"title": "4.1 Booleans and branching", "content": "The existence of return types instead of the flags Success, Failure and Running allows us to avoid a problem which is present in many classical BTs. Generally, the values Success and Failure are used implicitly as boolean values, especially in Condition nodes. Again, this is avoided in programming, and there is a good reason why: we can't distinguish between Failure, indicating our behavior did not work, and False, indicating the Condition is not true. Conditions, like any other robotic action, can fail for many reasons, and we need to identify when this has happened.\nThe following example demonstrates the severity of the problem. Consider a Condition dangerNearby, which detects some kind of threat to the robot. We build this into a (reactive selection form) BT: (dangerNearby ? doTask) \u2192 hide. However this BT can't distinguish between dangerNearby failing, possibly because some sensors are broken, and it successfully returning with the value False, indicating there is no danger nearby. In both cases we run doTask.\nLuckily, we can now avoid this problem: a Condition is a behavior whose type is Behavior Bool, that is, it returns a boolean. Recalling our discussion in Section 3.4, we would probably write this BT using monitor:"}, {"title": "5 Specification for the Behavior Language", "content": "Over the previous sections, we discussed how to distill the concepts of reactive-ness and modularity into a programming language for behavior. In this section we lay out the requirements of such a language. In particular, we explain the concepts in our Haskell implementation. While we believe Haskell is a partic-ularly neat language for implementing these operations, the key contribution here is the ideas and operations, which could be implemented in any language. Recall that we needed a behavior language to be first and foremost a lan-guage, equipped with all the control structures and tools that we expect of any language, including the ability to name functions and variables, to write loops and to branch. From here, we will focus on the behavior-specific operations like reactiveness, sequencing and fallback, which we have discussed throughout this paper.\n\u2022 Behaviors\nThe first piece of our Behavior language is the Behavior type, which en-capsulates a robotic action which returns a type. Behaviors may read from input, produce output and execute for an arbitrary amount of time. Behavior a is a type constructor which takes a single type argument a, representing the return type of the behavior. A behavior which returns a floating-point number, for instance, has type Behavior Float. Behavior is a type synonym for the built-in Haskell type 10. A behavior with argu-ments has the form of a function returning a behavior, so for instance a be-havior moveTo might have type moveTo :: Location -> Behavior (), indicating that it takes a Location and returns a Behavior with the null type ().\n\u2022 Sequencing Behaviors with data\nWe the simplest way of joining Behaviors is the (non-reactive) sequence operator \u2192*. For this, we use the Haskell function bind, written infix as >>=.\nSpecifically, running bt = bhvr1 >>= bhvr2 runs bhvr1:: Behavior a to completion, then hands the result (of type a) to bhvr2 :: a -> Behavior b, runs it and returns the result of type b. This is a fundamental construc-tion in Haskell, and so a special 'imperative-like' syntax is provided for it, called do-notation. bhvr1 >>= bhvr2 can be written:"}, {"title": "6 Example", "content": "In this section we demonstrate how we can use our library to rewrite the BT in Figure 2 as executable Haskell code. First, we outline the available behaviors and objects:"}, {"title": "7 Conclusions", "content": "In this paper we discussed the challenges of extending BTs to full programming language, and presented some modular solutions. This is summarised in our overall language specification, and accompanying implementation in Haskell. We hope that our findings will provide insight for the process of developing a modern approach to programming autonomous behavior.\nThere is an immediate direction for future work: constructing a full imple-mentation capable of performing non-trivial tasks on real hardware, and ideally interfacing with pre-existing tools like ROS [20]. This would take significant effort, but could be of great value, given the interest in BTs."}]}