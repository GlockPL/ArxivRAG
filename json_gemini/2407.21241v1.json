{"title": "Bug Analysis Towards Bug Resolution Time Prediction", "authors": ["Hasan Yagiz \u00d6zkan", "Poul E. Heegaard", "Wolfgang Kellerer", "Carmen Mas-Machuca"], "abstract": "Bugs are inevitable in software development, and their reporting in open repositories can enhance software transparency and reliability assessment. This study aims to extract information from the issue tracking system Jira and proposes a methodology to estimate resolution time for new bugs. The methodology is applied to network project ONAP, addressing concerns of network operators and manufacturers. This research provides insights into bug resolution times and related aspects in network softwarization projects.", "sections": [{"title": "I. INTRODUCTION", "content": "Network softwarization entails replacing dedicated hardware for specific applications with programmable components, leading to advantages like easy maintenance, flexibility, scalability and decreased costs associated with development and operations [1]. Software Defined Networking (SDN) and Network Function Virtualization (NFV) are examples of these softwarization efforts. In this context, manufacturers rely on open-source solutions to provide extra functionalities while complying with the standards. However, despite the advantages of network softwarization, operators are reluctant to use these solutions as the software is more complexity, incurring to more bugs, as well as the code reliability is uncertain as it is open to any software developer(s) differing in terms of programming skills, experience, trustiness, etc.\nIn order to increase the transparency of software reliability, any bugs which are encountered during the operation of a software, are reported in open repositories. These repositories allow knowing the reported bugs, their status, etc., which are useful to evaluate the software reliability. Each software project has defined a bug resolution process, which should be followed by any software developer (i.e., debugger) of that project.\nThe goal of this study is first of all, give an overview of the information that can be extracted from these repositories. Some information can be directly obtained from the gathered data, but some other need some processing. Secondly, we propose a methodology that can be used to estimate the resolution time of new bugs. The proposed methodology has been applied to several network related projects such as ONOS, ONAP, etc. We believe that network operators and manufacturers using an open source project like those, are concerned about the bug resolution times and other aspects addressed in this paper.\nThe contributions of this paper are:\nCollection strategy of reported bugs and the required filtering.\nBasic data analysis such as identification of the most common paths in the workflow, the transition distribution between different states, bug resolution time distribution, etc.\nAdvance data analysis e.g., impact of aspects such as priority, reporter to the debugging time.\nInvestigating state probabilities of the bugs in time.\nComparison of the bug resolution time prediction with different strategies\nPredicting the exact bug resolution time for different bugs with neural network."}, {"title": "II. RELATED WORK", "content": "This section will discuss previous works on bug data analysis and bug resolution processes.\nIssue tracking systems are mined, and researchers of [2] use this process to offer the dataset of all the issues from different projects. Additionally, the authors of [3] conduct various analyses of the collected data, which comes from 55 different Apache projects. These 55 projects are classified into 9 categories, such as big data, security, and libraries. The authors examine the percentage of fields that change the reporting of the bugs. They define bug resolution duration time from the creation and closure of a bug as a bug-fix effort and compare the bug resolution times across different project categories. Additionally, they investigate when the priority and assignee are defined and analyze the number of bugs in which these values change after the initial bug report. Furthermore, the study delves into the changes in bug status, analyzing the"}, {"title": "III. DATA REPOSITORIES", "content": "Issue tracking systems are software tools used to manage software projects' development, maintenance and debugging processes [2]. These systems use issues which can describe bugs, feature requests, milestones and any other tasks, depending on the requirements of the considered project. Moreover, issue tracking systems also serve as a repository for the history of reported and addressed issues. Thus, they offer an excellent opportunity to understand the software project's development and debugging process. Most open-source software use publicly available issue-tracking systems because it facilitates collaboration among software developers and debuggers by giving access to the status, process, and resolution of the reported issues.\nJira is one of the most popular issue-tracking systems used by many different open-source projects [6]. As an issue tracking system, the issue types in Jira extend beyond 'Bug,' including 'Task,' 'Story,' and more. Every issue is kept in the Jira repository of the respective project. Therefore, Jira repositories become a valuable information source for the project's development history. Jira defines a workflow, which comprises of a sequence of stages that issues may undergo, from their creation (referred as \"Open\") and ending with their resolution (referred as \"Closed\"). The workflow is depicted in Fig. 1 in blue color. Although Jira provides this initial workflow, it can be customized to meet the specific requirements of a project."}, {"title": "A. Bug related data", "content": "In this work, we are interested in the bug resolution time and hence, all issues other than 'Bug' are filtered out. Jira provides a collection of reported bugs. This collection contains details about the bug and its resolution process. Certain information is provided when a bug is reported, while others change throughout the resolution process. The following information is utilized in our analysis:\nPriority indicates the importance of the bug. The priority levels vary between projects. Hence, in this work, priorities 1 and 2 refer to the highest and second highest priority of any project.\nReporter is the person reporting the bug.\nAssignee is the person who is responsible for fixing the bug."}, {"title": "B. Bug resolution process", "content": "As bugs in Jira are a specific type of issue, they also follow the workflow for the issues. While other transitions from Fig. 1 are also utilized, a primary path within the workflow is typically followed for the bug resolution process. A bug begins in the 'Open' state when it is initially reported. Once a developer starts working on the bug resolution, the state is changed to 'In Progress'. The state of the bug changes to the 'Resolved' state, once the bug is resolved, where it awaits approval by another team member. After approval, the bug is closed by moving to the 'Closed' state. However, a bug may reappear so that it can be reopened and returned to the 'Reopen' state."}, {"title": "IV. BUG COLLECTION AND ANALYSIS", "content": "A developed Python script has been deployed for the proposed bug collection and analysis. It is important to mention that the bugs for ONAP and ONOS were collected directly from Jira. However, the bugs for Apache were collected from the dataset at [3]. The data analysis included in this work focuses on the two top-priority bugs (i.e., priority 1 and 2)."}, {"title": "A. Bug collection and filtering", "content": "The collected data in this study includes the reported bugs from the start of each project to the collection date (in this case, 05.04.2023). The collected data encompasses all bug related details (refer to Section III-A) as well as all related information during the bug resolution process such as transition states and times, authors involved in each change, etc.\nIn this study, we investigate the bug resolution process. However, the dataset does not only include the data relevant to our study, but it also includes exceptional/unwilling data, which must be filtered. Let us introduce the proposed data filtering on the dataset:\nNot Resolved Bugs: Not all reported bugs are necessarily resolved; some of them may be closed for alternative reasons. The resolution status is determined as a result of the debugging process. In the case of ONAP and ONOS bugs, the resolution status begins as 'Unresolved' and subsequently changes to one of the multiple resolution statuses, which are listed in Table I. The table also presents the respective percentages of each status. As this study targets the resolution time of bugs, only the bugs with the status 'Done' and 'Fixed' are considered, which account for more than 80% of the priority 1 and 2 bugs for both ONAP and ONOS projects. Regarding the Apache dataset, no filtering is necessary as the considered dataset contains only bugs with a resolution status of 'Fixed'.\nTransient State: As depicted in Fig. 1, the resolution process consists of a set of transitions between different states, starting at \"Open\" and ending at \"Closed\". For the bug resolution time study, it is relevant to know the time at each state before any transition. However, in certain cases, bugs may spend only a few minutes or even seconds in a particular state. This short duration might not provide accurate information about the actual effort expended in that state. Transient states of this nature can arise due to automated tasks or the practice of updating Jira after completing multiple states. Consequently, states with a duration shorter than a few minutes are removed as a state, and the time is added to the original state.\nNot Defined States: Observations of the dataset revealed that a few bugs have states that are not defined within the workflow of the project. The number of such states is significantly lower than those within the Jira workflow. Since the states are not in the workflow, we filter them out. The duration spent in these states is accumulated with the previous state, ensuring that the resolution duration remains unaffected.\nLoop to the same State: There is a possibility that a bug has a transition from a state to the same state (referred as loop). Some of these transitions are defined as such in Jira, while others may arise due to the removal of transient states or undefined states. In the case of a loop, no additional transition is considered, and the time spent in these states is merged.\nTransitions from \"Close\" State: The goal of finding the bug resolution time implies that bugs eventually reach the \"Closed\" state. While some bugs may occasionally be reopened after a certain period, it is often observed that reopening occurs after a substantial amount of time, which significantly inflates the resolution time. To address this issue, the \"Closed\" state is treated as an absorbing state, meaning that once a bug reaches this state, any subsequent transitions from the \"Closed\" state are excluded."}, {"title": "B. Bug resolution time distribution and common flows in transition workflow", "content": "The resolution time is defined as the time elapsed from the reporting of a bug (i.e., in the \"Open\" state) to the time when it reaches the \"Closed\" state. The resolution time is the sum of the time spent on various states, but it does not provide information about the duration spent on each individual state.\nIn this section, we introduce the resolution time analysis for the particular case of the priority 1 bugs of the ONAP project. These priority 1 bugs amount to a total of 906 in the project. The most common resolution paths for all the ONAP priority 1 bugs, can be found, as summarized in Table II. It can be observed in this case, that almost 91% of the bugs follow the seven main paths. Furthermore, 45% of the bugs follow the path Open-In Progress-Closed or Open-Closed."}, {"title": "C. Impact of different bug aspects", "content": "This section investigates the impact of different properties of the bugs on the bug resolution time. Properties like priority level, assignee and reporter of a particular bug may impact its resolution duration. The Apache dataset encompasses various projects, but we have excluded this data to eliminate variations caused by project differences. The number of bugs in ONOS should be higher to ensure a meaningful comparison. Thus, ONAP is the preferred option for investigating the assignee's and reporter's influence. Similar to the previous case, the bugs are separated based on priority.\nLet us first analyse the impact of the reporter on the bug resolution time. The reporter of the bug may impact the time given his/her experience by providing an accurate and clear bug description as well as listing all the essential information to reproduce the bug accurately."}, {"title": "D. Bug Distribution across States over Time", "content": "In this section, the distribution of bug states over time is presented. It presents the probabilities of being in specific states at given times for the ONAP, ONOS, and Apache projects.\nThe time when a bug is reported (i.e., the bug is at 'Open' state), is considered to be the time 0. Hence, at this time, the initial percentage of bugs in the 'Open' state is 100% (1.0) and zero at the other states. As time progresses, the bugs change to different states, leading to different distributions across the various states. The percentage of bugs in different states over time is provided for ONAP, ONOS and Apache projects in Fig. 5 for priorities 1 and 2. In all cases, it can be easily observed that since the 'Closed' state is absorbing, there is an always increasing percentage of bugs in that state.\nThe analysis of Fig. 5 reveals a notable distinction in bug resolution times among different projects. Specifically, in ONAP, bugs consistently tend to reach the 'Closed' state within approximately 8,000 hours, independently of the priority. Conversely, such a trend is not observed for bugs in ONOS and Apache projects, as after this time, still 10-20% of the bugs have not reached the \"Closed\" state. This divergence stems from the approach adopted by Apache projects, where the emphasis is not solely on expeditiously closing bugs, but rather on considering them solved once they reach the 'Resolved' state. Additionally, in the ONOS project, some bugs remained in the 'Delivered' state for an extended period before eventually being closed.\nExamining the percentage of bugs that achieve 'Closed' status, it can be observed that for priority 1 bugs, 50% is reached after around 1,200 hours, while for priority 2 bugs, it takes approximately 2,000 hours. Comparatively, in ONAP and ONOS projects, more than half of the bugs are closed within 300 hours for priority 1 bugs and within 500 hours for priority 2 bugs. Analyzing the graph depicting bugs in the 'Closed' state, it becomes apparent that the curve for ONAP bugs exhibits a steeper ascent compared to that of ONOS and Apache projects. Additionally, it is noticeable that the number of bugs in the 'Open' state decreases more rapidly in the ONAP project. This observation suggests that the debugging teams in ONAP work on the bugs at an earlier stage in comparison to the other projects.\nHowever, it is important to note that making a direct comparison is challenging due to variations in the strategies employed by different working groups when transitioning between states in their respective workflows. Some projects may strictly update the bug's state as soon as it is reached in the actual handling process, while others may implement such changes after a certain amount of time has passed. This discrepancy becomes visible in the utilization of the 'Delivered' state in Fig. 5. In Apache projects, bugs in the 'Delivered' state can be considered solved, whereas the same claim may not hold true for ONAP and ONOS projects."}, {"title": "V. PREDICTING RESOLUTION TIME WITH NEURAL NETWORK", "content": "Even after doing filterings, which are explained in Section IV, there are still bugs that can be filtered. One of the main reason to filter is the long living bugs, which are discussed in Subsection IV-D. Possible reasons of the short and long living bugs and different possibilities to filtering those bugs are discussed in [8], [9]. It has been explained that some bugs are forgotten, wrongly labeled or reported after its resolution. Therefore removing short living bugs or long living bugs might improve prediction quality. In results we compared different filtering strategies for the bugs. In [8], authors discuss removing long living bugs with the help of inner fence and outer fence. We also used the same strategy if all the bugs outside of inner fence is removed it is called removing mild outliers in case of all bugs above outer fence is removed is called removing extreme outliers. As an extend to these outlier removal we also proposed to remove the bugs without any update (comment, state change etc.) for more than 30 days. We compared these filtering methods and investigate their impact on the results.\nWe used neural networks (NN) to predict the resolution time of the bugs. The results are compared with Naive Bayesian (NB) and k Nearest Neighbour (kNN) algorithms. These two algorithms are chosen because they are widely used for resolution time prediction [4], [5], [8], [9]. Since the NB and KNN cannot be applied to get numerical results but only used for classification, the results which used for comparison takes two classes into account. These two classes divided depending on the resolution time. If the resolution time is shorter than median resolution time of the training dataset, the bug considered as 'fast' bug otherwise it is classed as 'slow' bug.\nThe input of the NN is the information related to the priority, subproject, assignee, reporter and either the assignee is same person of the reporter or not. Two different NN model compared for the classification one of them is trained for binary classification and returns either the bug is belongs to 'fast' or 'slow' group and the other one predicts the exact resolution time. The size and input of those models are same, where the difference lies on the loss, activation functions and the output values. For binary predicted output values are either 0 or 1 and for exact value prediction values are time to solve as hours. Since the exact time prediction is not same as binary classification, the time prediction values should be converted to two class depending on either it is predicted lower than median time or higher than median time to resolve. Both two NN consist of 5 layers, where the first one is dedicated to normalization of the input data.\nThe ONAP project is selected for the model training, because it has more bug reports than the ONOS project and insufficient amount of data might impact the performance of the NN. In order to make prediction we divided the dataset into two group, training, which corresponds to 80% of all dataset and test which is the rest of the dataset. In order to be able to generalize the results we cross validate our results with randomly dividing the dataset 10 times. As it can be seen from the Fig.6, even though NN does not make binary estimation of 'slow' and 'fast' its accuracy is higher than KNN estimation for any type of filtering. NN results for binary classification provides either best or second best results in any case. The filtering does not help to improve the results, one reason for that can be the reduction of the training dataset. Another possible reason is the filtered bugs mostly have similar information like assignee or subproject and classifying them as 'slow' increase the accuracy.\nThe results for exact time prediction is given in Figure 7. It can be seen that the median normalized prediction error is 20% for all bugs and 30% for filtered bugs. One of the reason for this high error can be the holiday periods and weekends. The bug report day actually plays an important role on its resolution time. Even though there is an error around 20% between predicted and real time to solve, predicted value can be more helpful than two classes."}, {"title": "VI. CONCLUSION", "content": "In this work the importance of different aspects of the bugs on their resolution process has been shown. The time to solve a bug decrease, when the reporter is assigned to the issue. Also the impact of different resolution process or strategy to report this process has been shown. It has been seen that in Apache projects, reaching to the 'Closed' state is not forced like ONAP, instead the bugs stays in 'Resolved' state for long time. It has been shown that bug resolution time can be estimated with neural networks and the predicted value can be used by the developer teams to distribute their workforce according to the estimation. This work can be extended with using different machine learning techniques like pretraining and data augmentation to make a valid prediction for new and smaller projects."}]}