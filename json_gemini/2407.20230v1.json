{"title": "SAPG: Split and Aggregate Policy Gradients", "authors": ["Jayesh Singla", "Ananye Agarwal", "Deepak Pathak"], "abstract": "Despite extreme sample inefficiency, on-policy reinforcement learning, aka policy gradients, has become a fundamental tool in decision-making problems. With the recent advances in GPU-driven simulation, the ability to collect large amounts of data for RL training has scaled exponentially. However, we show that current RL methods, e.g. PPO, fail to ingest the benefit of parallelized environments beyond a certain point and their performance saturates. To address this, we propose a new on-policy RL algorithm that can effectively leverage large-scale environments by splitting them into chunks and fusing them back together via importance sampling. Our algorithm, termed SAPG, shows significantly higher performance across a variety of challenging environments where vanilla PPO and other strong baselines fail to achieve high performance. Webpage at https://sapg-rl.github.io.", "sections": [{"title": "1. Introduction", "content": "Broadly, there are two main categories in reinforcement learning (RL): off-policy RL, e.g., Q-learning [32], and on-policy RL, e.g., policy gradients [29]. On-policy methods are relatively more sample inefficient than off-policy but often tend to converge to higher asymptotic performance. Due to this reason, on-policy RL methods, especially PPO [27], are usually the preferred RL paradigm for almost all sim2real robotic applications [19, 1, 2] to games such as StarCraft [30], where one could simulate years of real-world experience in minutes to hours.\nRL is fundamentally a trial-n-error-based framework and hence is sample inefficient in nature. Due to this, one needs to have large batch sizes for each policy update, especially in the case of on-policy methods because they can only use data from current experience. Fortunately, in recent years, the ability to simulate a large number of environments in parallel has become exponentially larger due to GPU-driven physics engines, such as IsaacGym [17], PhysX, Mujoco-3.0, etc. This means that each RL update can easily scale to batches of size hundreds of thousands to millions, which are over two orders of magnitude higher than what most RL benchmarks typically have.\nIn this paper, we highlight an issue with typical on-policy RL methods, e.g. PPO, that they are not able to ingest the benefits with increasingly larger sample sizes for each update. In Figure 2, we show that PPO performance saturates after a certain batch size despite the ceiling being higher. This is due to the issue in data sampling mechanisms. In particular, at each timestep actions are sampled from a Gaussian with some mean and variance. This implies that most sampled actions are near the mean and with large number of environments, many environments are executing the same actions leading to duplicated data. This implies that the performance of PPO saturates at some point as we increase the number of environments.\nWe propose a simple fix to this problem. Instead of running a single PPO policy for all environments, we divide environments into blocks. Each block optimizes a separate policy, allowing for more data diversity than just i.i.d. sampling from the same Gaussian. Next, we do an off-policy update to combine data from all these policies to keep the update consistent with the objective of on-policy RL. This allows us to use the PPO's clipped surrogate objective, maintaining the stability benefits of PPO while latching onto high reward trajectories even though they are off-policy. A schematic of our approach, termed SAPG, is shown in Figure 1. We evaluate SAPG across a variety of environments and show significantly high asymptotic performance in environments where vanilla PPO even fails to get any positive success."}, {"title": "2. Related Work", "content": "Policy gradients REINFORCE [33], one of the earliest policy gradient algorithms uses an estimator of the objective using simple Monte Carlo return values. Works such as [14] and [28] improve the stability of policy gradient algorithms by employing a baseline to decrease the variance of the estimator while not compromising on the bias. [26, 27] incorporate conservative policy updates into policy gradients to increase the robustness.\nDistributed reinforcement learning Reinforcement learning algorithms are highly sample inefficient, which calls for some form of parallelization to increase the training speed. When training in simulation, this speed-up can be achieved by distributing experience collection or different parts of training across multiple processes.[22, 21, 6, 12] However, through the introduction of GPU-based simulators such as IsaacGym [17], the capacity of simulation has increased by two to three orders of magnitude. Due to this, instead of focusing on how to parallelize parts of the algorithm, the focus has shifted to finding ways to efficiently utilize the large amount of simulation data. Previous works such as [1, 2, 8, 25, 10] use data from GPU-based simulation to learn policies in complex manipulation and locomotion settings. However, most of these works still use reinforcement learning algorithms to learn a single policy, while augmenting training with techniques like teacher-student-based training and game-based curriculum. We find that using the increased simulation capacity to naively increase the batch size is not the best way to utilize massively parallel simulation.\n[24] develop a population-based training framework that divides the large number of environments between multiple policies and using hyperparameter mutation to find a set of hyperparameters that performs well. However, even this does not utilize all the data completely as each policy learns independently. We propose a way to ensure most of the data from the environments contributes to learning by using all collected transitions for each update.\nOff-policy Policy Gradients Unlike on-policy algorithms, off-policy algorithms can reuse all collected data or data collected by any policy for their update. Most off-policy algorithms [20, 16, 9] try to learn a value function which is then implicitly/explicitly used to learn a policy. [15] developed a variant of Deep Deterministic Policy Gradient (DDPG) called PQL which splits data collection and learning into multiple processes and shows impressive performance on many benchmark tasks. We use PQL as one of our baselines to compare our method to off-policy RL in complex tasks. Although off-policy algorithms are much more data-efficient, they usually get lower asymptotic performance than on-policy policy gradients. This has inspired works to develop techniques to use off-policy data in on-policy methods. [11] has been one of the major techniques used to realize this. Previous works [5, 31, 6, 7] develop techniques to use off-policy data in on-policy algorithms using importance sampling-based updates along with features such as bias correction."}, {"title": "3. Preliminaries", "content": "In this paper, we propose a modification to on-policy RL to achieve higher performance in the presence of large batch sizes. We build upon PPO, although our proposed ideas are generally applicable to any on-policy RL method.\nOn-policy RL Let $(S, A, P, r, \\rho, \\gamma)$ be an MDP where $S$ is the set of states, $A$ the set of actions, $P$ are transition probabilities, $r$ the reward function, $\\rho$ the initial distribution of states and $\\gamma$ the discount factor. The objective in reinforcement learning is to find a policy $\\pi(a|s)$ which maximises the long term discounted reward $J(\\pi) = \\mathbb{E}_{s_0\\sim\\rho, a_t\\sim\\pi(\\cdot|s_t)}[\\sum_{t=0}^{T-1} \\gamma^t r(s_t, a_t)]$.\nPolicy-gradient algorithms [33, 14, 26, 21] optimize the policy using gradient descent with Monte Carlo estimates of the gradient\n$\\nabla_{\\theta} J(\\pi_{\\theta}) = \\mathbb{E}_{s \\sim \\rho_{\\pi_{\\theta}}, a \\sim \\pi_{\\theta}(\\cdot|s)}[\\nabla_{\\theta}log(\\pi_{\\theta}(a|s)) A_{\\theta}(s,a)] $\nwhere $A^{\\pi_{\\theta}}(s, a)$ is an advantage function that estimates the contribution of the transition to the gradient. A common choice is $A^{\\pi_{\\theta}}(s,a) = Q^{\\pi_{\\theta}}(s,a) - V^{\\pi_{\\theta}}(s)$, where $Q^{\\pi_{\\theta}}(s, a), V^{\\pi_{\\theta}}(s)$ are estimated Q and value functions. This form of update is termed as an actor-critic update [14]. Since we want the gradient of the error with respect to the current policy, only data from the current policy (on-policy) data can be utilized.\nPPO Actor critic updates can be quite unstable because gradient estimates are high variance and the loss landscape is complex. An update step that is too large can destroy policy performance. Proximal Policy Optimization (PPO) modifies Eq. 1 to restrict updates to remain within an approximate \"trust region\" where there is guaranteed improvement [26, 13].\n$L_{on}(\\pi_{\\theta}) = \\mathbb{E} [min(r_t(\\pi_{\\theta}),clip(r_t(\\pi_{\\theta}), 1 - \\epsilon, 1 + \\epsilon))A_{old}]$\nHere, $r_t(\\pi_{\\theta}) = \\frac{\\pi_{\\theta}(a_t|s_t)}{\\pi_{old}(a_t|s_t)}$, $\\epsilon$ is a clipping hyperparameter and $\\pi_{old}$ is the policy collecting the on-policy data. The clipping operation ensures that the updated $\\pi$ stays close to $\\pi_{old}$. Empirically, given large numbers of samples, PPO achieves high performance, is stable and robust to hyperparameters. However, it was developed for relatively small batch sizes ($\\approx$ 100 parallel envs). We find that in the large-scale setting (>10k envs), it is suboptimal because many parallel envs are sampling nearly identical on-policy data."}, {"title": "4. Split and Aggregate Policy Gradients", "content": "Policy gradient methods are highly sensitive to the variance in the estimate of gradient. Since CPU-based simulators typically run only 100s of environments in parallel, conventional wisdom is to simply sample on-policy data from a Gaussian policy in all the environments since as the number of datapoints increases, the Monte Carlo estimate becomes more accurate. However, this intuition no longer holds in the extremely large-scale data setting where we have hundreds of thousands of environments on GPU-accelerated simulators like IsaacGym. IID sampling from a Gaussian policy will lead to most actions lying near the mean, and most environments will execute similar actions, leading to wasted data (fig. 2).\nWe propose to efficiently use large numbers of N environments using a divide-and-conquer setup. Our algorithm trains a variety of M policies $\\pi_1,..., \\pi_M$ instead of having just one policy. However, simply training multiple policies by dividing environments between them is also inefficient. This is equivalent to training an algorithm with different seeds and choosing the best seed. One approach is to add hyperparameter mutation [24] to the policies and choosing the hyperparameters that perform the best among all of them. However, even in this case, all of the data from the \"worse\" policies goes to waste, and the only information gained is that some combinations of hyperparameters are bad, even though the policies themselves may have discovered high reward trajectories. We need to somehow aggregate data from multiple policies into a single update. We propose to do this via off-policy updates.\n4.1. Aggregating data using off-policy updates\nOne of the major drawbacks of on-policy RL is its inability to use data from past versions of the policy. One solution is to use importance sampling [5, 18] to weight updates using data from different policies. In practice, this is not used since given limited compute it is beneficial to sample on-policy experience that is more directly relevant. However, this is no longer true in the large batch setting where enough on-policy data is available. In this case, it becomes advantageous to have multiple policies $\\pi_1,..., \\pi_M$ and use them to sample diverse data, even if it is off-policy. In particular, to update policy $\\pi_i$ using data from policy $\\pi_j, j \\in \\mathcal{X}$ we use [18]\n$\\mathcal{L}_{off}(\\pi_i; \\mathcal{X}) = \\frac{1}{|\\mathcal{X}|} \\sum_{j \\in \\mathcal{X}} \\mathbb{E}_{(s,a) \\sim \\pi_j} [min (r_{\\pi_i} (s, a),clip (r_{\\pi_i} (s, a), \\mu(1 - \\epsilon), \\mu(1 + \\epsilon))) A^{\\pi_{i,old}} (s, a)]$\nwhere $r_{\\pi_i} (s, a) = \\frac{\\pi_i(s,a)}{\\pi_j(s,a)}$ and $\\mu$ is an off-policy correction term $\\mu = \\frac{\\pi_j(s,a)}{\\pi_{i,old}(s,a)}$. Note that when $i = j$, then $\\pi_j = \\pi_{i,old}$ and this reduces to the on-policy update as expected. This is then scaled and combined with the on-policy term (eq. 2)\n$\\mathcal{L}(\\pi_i) = \\mathcal{L}_{on}(\\pi_i) + \\lambda \\cdot \\mathcal{L}_{off} (\\pi_i; \\mathcal{X})$\nThe update target for the critic is calculated using n-step returns (here n = 3).\n$V^{target}(s_t) = \\sum_{k=t}^{t+2} \\gamma^{k-t} r_k + \\gamma^3 V_{j,old}(s_{t+3})$\nHowever, this is not possible for off-policy data. Instead, we assume that an off-policy transition can be used to approximate a 1-step return. The target equations are as follows\n$V^{target}_{i, off}(s_t) = r_t + \\gamma V_{j,old}(s_{t+1})$\nThe critic loss is then\n$\\mathcal{L}_{critic} (i) = \\mathbb{E}_{(s,a) \\sim \\pi_i} [(V_{\\pi_i} (s) - V^{target}(s))^2]$\n$\\mathcal{L}^{off}_{critic} (\\pi_i; \\mathcal{X}) = \\frac{1}{|\\mathcal{X}|} \\sum_{j \\in \\mathcal{X}} \\mathbb{E}_{(s,a) \\sim \\pi_j} [(V_{\\pi_i} (s) - V^{target}(s))^2]$\n$\\mathcal{L}_{critic} (\\pi_i) = \\mathcal{L}^{on}_{critic} (\\pi_i) + \\lambda \\cdot \\mathcal{L}^{off}_{critic} (\\pi_i; \\mathcal{X})$\nGiven this update scheme, we must now choose a suitable $\\mathcal{X} \\subseteq \\{1, ..., M\\}$ and the set of $\\lambda$s to update, along with the correct ratio $\\lambda$. We explore several variants below.\n4.2. Symmetric aggregation\nA simple choice is to update all $\\pi_i$'s with the data from all policies. In this case, we choose to update each policy $i \\in \\{1,2,..., M\\}$ and for each $i$ use off-policy data from all other policies $\\mathcal{X} = \\{1,2,..., i-1, i+1, ..., M\\}$. Since gradients from off-policy data are typically noisier than gradients from on-policy data, we choose $\\lambda = 1$, but subsample the off-policy data such that we use equal amounts of on-policy and off-policy data.\n4.3. Leader-follower aggregation\nWhile the above choice prevents data wastage, since all the policies are updated with the same data, it can lead to policies converging in behavior, reducing data diversity and defeating the purpose of having separate policies. To resolve this, we break symmetry by designating a \"leader\" policy $i = 1$ which gets data from all other policies $\\mathcal{X} = \\{2,3,..., M\\}$ while the rest are \u201cfollowers\u201d and only use their own on-policy data for updates $\\mathcal{X} = \\emptyset$. As before, we choose $\\lambda = 1$, but subsample the off-policy data for the leader such that we use equal amounts of on-policy and off-policy data in a mini-batch update.\n4.4. Encouraging diversity via latent conditioning\nWhat is the right parameterization for this set of policies? One simple choice is to have a disjoint set of parameters for each $\\pi_i$ with no sharing at all. However, this implies that each follower policy has no knowledge of any other policy whatsoever and may get stuck in a bad local optimum. We mitigate this by having a shared backbone $\\mathcal{B}_\\theta$ for each policy conditioned on hanging parameters $\\phi_i$ local to each policy. Similarly, the critic consists of a shared backbone $\\mathcal{C}_\\psi$ conditioned on parameters $\\omega_i$. The parameters $\\theta, \\psi$ are shared across the leader and all followers and updated with gradients from each objective, while the parameters $\\phi_i, \\omega_i$ are only updated with the objective for that particular policy. We choose $\\phi_i \\in \\mathbb{R}^{32}$ for complex environments while $\\phi_i \\in \\mathbb{R}^{16}$ for the relatively simpler ones.\n4.5. Enforcing diversity through entropy regularization\nTo further encourage diversity between different policies, in addition to the PPO update loss $\\mathcal{L}_{on}$ we add an entropy loss to each of the followers with different coefficients. In particular, the entropy loss is $H(\\pi(a | s))$. The overall loss for the policy $i$ (or the $(i - 1)$th) follower is $\\mathcal{L}(\\pi_i) = \\mathcal{L}_{on} (\\pi_i) + \\lambda_{ent}(i - 1) \\cdot H(\\pi(a | s))$. The leader doesn't have any entropy loss. Different scales of coefficients produce policies with different explore-exploit tradeoffs. Followers with large entropy losses tend to explore more actions even if they are suboptimal, while those with small coefficients stay close to optimal trajectories and refine them. This leads to a large data coverage with a good mix of optimal as well as diverse trajectories. We treat $\\lambda_{ent}$ as a hyperparameter.\n4.6. Algorithm: SAPG\nWe roll out $M$ different policies and collect data $\\mathcal{D}_1,..., \\mathcal{D}_M$ for each. Follower policies $2,..., M$ are updated using the usual PPO objective with minibatch gradient descent on their respective datasets. However, we augment the dataset of the leader $\\mathcal{D}_1$ with data from $\\mathcal{D}_2, ..., \\mathcal{D}_M$, weighed by the importance weight $\\mu$. The leader is then updated by minibatch gradient descent as well."}, {"title": "5. Experimental Setup", "content": "We conduct experiments on 5 manipulation tasks (3 hard and 2 easy) and compare them against SOTA methods for the large-scale parallelized setting. We use a GPU-accelerated simulator, IsaacGym [17] which allows simulating tens of thousands of environments in parallel on a single GPU. In our experiments, we focus on the large-scale setting and simulate 24576 parallel environments unless otherwise specified. Note that this is two orders of magnitude larger than the number of environments PPO [27] was developed on, and we indeed find that vanilla PPO does not scale to this setting."}, {"title": "5.1. Tasks", "content": "We consider a total of 6 tasks grouped into two parts: Four hard tasks and two easy tasks. Hard and easy is defined by the success reward achieved by off-policy (in particular, PQL) methods in these environments. In easy environments, even Q-learning-based off-policy methods can obtain non-zero performance but not in hard tasks. See appendix sec. A.\nHard Difficulty Tasks All four hard tasks are based on the Allegro-Kuka environments [24]. These consist of an Allegro Hand (16 DoF) mounted on a Kuka arm (7 dof). The performance of the agent in the above three tasks is measured by the successes metric which is defined as the number of successes in a single episode. Three tasks include:\n\u2022 Regrasping: The object must be lifted from the table and held near a goal position $g_t \\in \\mathbb{R}^3$ for K = 30 steps. This is called a \"success\". The target position and object position are reset to a random location after every success.\n\u2022 Throw: The object must be lifted from the table and thrown into a bucket at $g_t \\in \\mathbb{R}^3$ placed out of reach of the arm. The bucket and the object position are reset randomly after every successful attempt.\n\u2022 Reorientation: Pick up the object and reorient it to a particular target pose $g_t \\in \\mathbb{R}^7$ (position + orientation). The target pose is reset once the agent succeeds. This means that the agents needs to reorient the object in different poses in succession, which may sometimes entail placing the objects on the table and lifting it up in a different way.\n\u2022 Two Arms Reorientation: Similar to the reorientation task above, pick up the object and reorient it to a particular target pose. However, there are two arms in the system, adding the additional complexity of having to transfer objects between arms to reach poses in different regions of space.\nEasy Difficulty Tasks: In addition, we test on the following dexterous hand tasks. As before, the observation space consists of the joint angles and velocities $q_t, \\dot{q_t}$, object pose $x_t$ and velocities $v_t, w_t$.\n\u2022 Shadow Hand: We test in-hand reorientation task of a cube using the 24-DoF Shadow Hand.\n\u2022 Allegro Hand: This is the same as the previous in-hand reorientation task but with the 16-DoF Allegro Hand."}, {"title": "5.2. Baselines", "content": "We test against state-of-the-art RL methods designed for the GPU-accelerated large-scale setting we consider in this paper. We compare against both on-policy [24] and off-policy [15] variants as well as vanilla PPO [27].\n\u2022 PPO (Proximal Policy Optimization) [27]: In our setting, we just increase the data throughput for PPO by increasing the batch size proportionately to the number of environments. In particular, we see over two orders of magnitude increase in the number of environments (from 128 to 24576).\n\u2022 Parallel Q-Learning [15] A parallelized version of DDPG with different mixed exploration i.e. varying exploration noise across environments to further aid exploration. We use this baseline to compare if off-policy methods can outperform on-policy methods when the data collection capacity is high.\n\u2022 DexPBT [24] A framework that combines population-based training with PPO. N Environments are divided into M groups, each containing environments. M separate policies are trained using PPO in each group of environments with different hyperparameters. At regular intervals, the worst-performing policies are replaced with the weights of best-performing policies and their hyperparameters are mutated randomly."}, {"title": "6. Results and Analysis", "content": "In the large-scale data setting, we are primarily concerned with optimality while sample-efficiency and wall-clock time are secondary concerns. This is because data is readily available\u2014one only needs to spin up more GPUs, what is really important is how well our agent performs in the downstream tasks. Indeed, this aligns with how practitioners use RL algorithms in practice [1, 3, 23], where agents are trained with lots of domain randomization in large simulations and the primary concern is how well the agent can adapt and learn in these environments since this directly translates to real-world performance.\n6.1. AllegroKuka tasks\nThe AllegroKuka tasks (Throw, Regrasping, Reorientation, Two Arms Reorientation) are hard due to large degrees of freedom. The environment also offers the possibility of many emergent strategies such as using the table to reorient the cube, or using gravity to reorient the cube. Therefore, a large amount of data is required to attain good performance on these tasks. Following Petrenko et al. [24] we use the number of successes as a performance metric on these tasks. Note that the DexPBT baseline directly optimizes for success by mutating the reward scales to achieve higher success rate, whereas our method can only optimize a fixed reward function. Despite this, we see that SAPG achieves a 12 - 66% higher success rate than DexPBT on regrasping, throw and reorientation. SAPG performs 66% better than PBT on the challenging reorientation task. SAPG fairs even better on the two-arm reorientation, obtaining more than twice the number of successes on average compared to PBT. Note that vanilla PPO and PQL are unable to learn any useful behaviors on these hard tasks.\n6.2. In-hand reorientation\nThe AllegroHand and ShadowHand reorientation tasks from Li et al. [15] are comparatively easier since they have lower degrees of freedom and the object doesn't move around much and remains inside the hand. On these tasks, we observe that PQL and PPO are able to make significant progress. In particular, we find that PQL is very sample-efficient because it is off-policy and utilizes past data for updates. However, we find that SAPG achieves higher asymptotic performance. This is because on-policy methods are better at latching onto high reward trajectories and do not have to wait several iterations for the Bellman backup to propagate back to initial states. As discussed previously, in large-scale settings in simulation, we are primarily concerned with asymptotic performance since we want to maximize the downstream performance of our agents (within a reasonable training time budget). We see that on AllegroHand, SAPG beats PQL by a 21% margin, while on the ShadowHand task it achieves comparable performance. On these tasks, both PBT and PPO generally perform worse. This is because PPO is not able to efficiently leverage the large batch size. PBT loses the benefit of its hyperparameter mutation because the environment is simpler and the default hyperparameters work well, so it roughly reduces to simple PPO in environments.\n6.3. Ablations\nThe core idea behind SAPG is to combine data from different policies instead of optimizing a single policy with an extremely large batch. In this section, we will analyze our specific design choices for how we combine data (choice of $\\pi_i$ and $\\mathcal{X}$ and $\\lambda$) and for how we enforce diversity among the data collected by the policies. In particular, we have the following variants\n\u2022 SAPG (with entropy coef) As discussed in sec. 5.2, here we add an entropy loss to the followers to encourage data diversity. We explore different choices for the scaling coefficient of this loss $\\sigma \\in \\{0, 0.005, 0.003\\}$.\n\u2022 SAPG (high off-policy ratio) In SAPG, when updating the leader, we subsample the off-policy data from the followers such that the off-policy dataset size matches the on-policy data. This is done because off-policy data is typically noisier and we do not want to drown out the gradient from on-policy data. In SAPG with a high off-policy ratio, we remove the subsampling step and instead see the impact of computing the gradient on the entire combined off-policy + on-policy dataset.\n\u2022 Ours (symmetric) In SAPG, we choose i = 1 to be the \"leader\" and the rest are \"followers\". Only the leader receives off-policy data while the followers use the standard on-policy loss. A natural alternative is where there are no privileged policies and each policy is updated with off-policy data from all others as discussed in sec. 4.2.\nWe observe that SAPG outperforms or achieves comparable performance to the entropy-regularized variant except in the Reorientation environment where the variant with coefficient 5e - 3 performs up to 16.5% better. Reorientation is one of the harder tasks out of the four AllegroKuka tasks and has a lot of scope for learning emergent strategies such as using the table to move the object around, etc. Explicit exploration might be useful in discovering these behaviors.\nThe variant of ours which uses all the off-policy data is significantly worse on the AllegroHand and ShadowHand tasks and marginally worse on Regrasping and Throw environments. It is more sample efficient than SAPG on Reorientation but achieves lower asymptotic performance. This could be because in the simple environments, additional data has marginal utility. In the harder AllegroKuka environments, it is beneficial to use all the data initially since it may contain optimal trajectories that would otherwise be missed. However, once an appreciable level of performance is achieved, it becomes better to subsample to prevent the noise in the off-policy update from drowning out the on-policy gradient.\nFinally, the symmetric variant of our method performs significantly worse across the board. This is possibly because using all the data to update each policy leads to them converging in behavior. If all the policies start executing the same actions, the benefit of data diversity is lost and SAPG reduces to vanilla PPO. Of course, there is a rich space of possible algorithms depending on particular choices of how data is aggregated and diversity is encouraged of which we have explored a small fraction.\n6.4. Diversity in exploration\nTo analyze why our method outperforms the baseline method, we conduct experiments comparing the diversity of states visited by each algorithm during training. We devise two metrics to measure the diversity of the state space and find that our method beats PPO in both metrics.\n\u2022 PCA - We compute the reconstruction error of a batch of states using k most significant components of PCA and plot this error as a function of k. In general, a set that has variation along fewer dimensions of space can be compressed with fewer principal vectors and will have lower reconstruction error. This metric therefore measures the extent to which the policy explores different dimensions of state space. Figure-7 contains the plots for this metric. We find that the rate of decrease in reconstruction error with an increase in components is the slowest for our method.\n\u2022 MLP - We train feedforward networks with small hidden layers on the task of input reconstruction on batches of environment states visited by our algorithm and PPO during training. The idea behind this is that if a batch of states has a more diverse data distribution then it should be harder to reconstruct the distribution using small hidden layers because high diversity implies that the distribution is less compressible. Thus, high training error on a batch of states is a strong indicator of diversity in the batch. As can be observed from the plots in Figure-8, we find that training error is consistently higher for our method compared to PPO across different hidden layer sizes."}, {"title": "7. Conclusion", "content": "In this work, we present a method to scale reinforcement learning to utilize large simulation capacity. We show how current algorithms obtain diminishing returns if we perform naive scaling by batch size and do not use the increased volume of data efficiently. Our method achieves state-of-the-art performance on hard simulation benchmarks."}]}