{"title": "A Polynomial-Time Algorithm for EFX Orientations of Chores", "authors": ["Kevin Hsu", "Valerie King"], "abstract": "This paper addresses the problem of finding EFX orientations of graphs of chores, in which each vertex corresponds to an agent, each edge corresponds to a chore, and a chore has zero marginal utility to an agent if its corresponding edge is not incident to the vertex corresponding to the agent. Recently, Zhou et al. (IJCAI, 2024) analyzed the complexity of deciding whether graphs containing a mixture of goods and chores admit EFX orientations, and conjectured that deciding whether graphs containing only chores admit EFX orientations is NP-complete. In this paper, we resolve this conjecture by exhibiting a polynomial-time algorithm that finds an EFX orientation of a graph containing only chores if one exists, even if the graph contains self-loops. Remarkably, our first result demonstrates a surprising separation between the case of goods and the case of chores, because deciding whether graphs containing only goods admit EFX orientations of goods was shown to be NP-complete by Christodoulou et al. (EC, 2023). In addition, we show the analogous decision problem for multi-graphs to be NP-complete.", "sections": [{"title": "1 Introduction", "content": "Consider the problem of dividing a set of items among a group of independent agents with the stipulation that each item must be given to exactly one agent and cannot be shared. This problem can be used to model a wide variety of settings, such as assigning office space in a building to employees, allocating classrooms to multiple simultaneous lectures, and even divorce settlements between spouses. The classical example of dividing a single good between two agents shows that it is not always possible to find an envy-free allocation, necessitating the search for alternative criteria of fairness.\nThe most prominent such criterion is envy-freeness up to any good (EFX) introduced by Caragiannis et al. [2019] and Gourv\u00e8s et al. [2014]. Essentially, because we cannot hope to achieve envy-freeness in general, we allow for an agent i to envy another agent j, as long as the envy can be alleviated by ignoring any one good allocated to j. The existence problem of EFX allocations has proven to be notoriously difficult and has even been referred to as \"fair division's most enigmatic question\" by Procaccia [2020]. Many attempts have been made toward this problem by limiting the types of instances. For example, EFX allocations of goods exist if the agents have identical utility functions or if the agents have identical ranking of the goods [Plaut and Roughgarden, 2020], if the agents have lexicographic utility functions [Hosseini et al., 2023], or if the number of agents is at most 3 [Chaudhury et al., 2020; Akrami et al., 2022].\nAnother possibility is to limit the number of agents who are interested in each item. The assumption that each item provides non-zero marginal utility to at most two agents leads to the graphical instances introduced by Christodoulou et al. [2023]. These instances can be represented by a graph G in the following way. Each agent is represented by a vertex, and each item is represented by an edge between the two agents for whom it possibly provides non-zero marginal utility. Thus, whenever an edge is not incident to a vertex, it provides zero marginal utility to the agent corresponding to that vertex. Because instances are represented as graphs, it is natural to ask whether EFX orientations exist, that is, whether it is possible to allocate each edge to one of its endpoints while satisfying the EFX condition. Unfortunately, it is NP-complete to decide whether EFX orientations exist for instances containing only goods [Christodoulou et al., 2023].\nThe recent work due to Zhou et al. [2024] explored the above problem in further detail, studying the complexity of determining whether EFX orientations exist when both goods and chores are present (i. e. the mixed manna setting). Under this setting, the original definition of EFX can be adapted in four different ways depending on whether a good is ignored in the envied agent's bundle (similar to the original definition of EFX) or a chore is ignored in the envious agent's bundle, and also depending on if the ignored item must have non-zero marginal utility. Zhou et al. [2024] analyzed the complexity of deciding whether EFX orientations and allocations exist for each of the four variants of EFX.\nTheir paper concludes with a brief discussion on the special case of instances containing only chores. Two different variants of EFX can be defined for such instances. Specifically, let \u03c0 be an allocation, \u03c0_i denote the bundle of agent i, and u_i denote the utility function of agent i. We say that \u03c0 is\n\u2022 EFX_ if for each pair of agents i \u2260 j such that i envies"}, {"title": "1.1 Our Contribution", "content": "In this paper, we resolve the conjecture made by Zhou et al. [2024] by giving a polynomial-time algorithm that decides the existence of an EFX_0 orientation of chores and outputs one if it exists. Our algorithm is also able to handle graphs with self-loops and is essentially based on reducing the problem of finding EFX_0 orientations to 2SAT, which can be solved in polynomial time [Aspvall et al., 1979]. Remarkably, our result stands in contrast with the case of goods, which is NP-complete [Christodoulou et al., 2023].\nTheorem 1. There exists a O(|V(G)|^2)-time algorithm that decides whether a graph G of chores admits an EFX_0 orientation and outputs one if it exists.\nIn contrast, we show that the analogous problem for multi-graphs is NP-complete.\nTheorem 2. Deciding whether a multigraph G of chores admits an EFX_0 orientation is NP-complete, even if G contains only two vertices and agents have additive utility functions."}, {"title": "1.2 Organization", "content": "We introduce the model in Section 2. Our algorithm for finding EFX orientations of graphs is given in Section 3 (Theorem 1). Finally, we prove our hardness result for multigraphs in Section 4 (Theorem 2)."}, {"title": "2 Preliminaries", "content": ""}, {"title": "2.1 The EFX\u2080 Orientation Problem", "content": "An instance of EFX_0-ORIENTATION is an ordered pair (G, u) where G = (V(G), E(G)) is a graph and u is a collection of |V(G)| utility functions u_i : P(E(G)) \u2192 R_{\u22640}. The graph G possibly contains self-loops. Each vertex corresponds to an agent and each edge corresponds to a chore. For each agent i, the utility function u_i represents its preferences by assigning a numerical value to each subset of the edges. In the case of a single edge e, we write u_i(e) in place of u_i({e}) for brevity. We further assume that whenever a vertex i is not incident to an edge e, the edge e has zero marginal utility to i, i. e. u_i(S \u222a {e}) = u_i(S) for any set S \u2286 E(G). In addition, we make the following two minimal assumptions on each utility function u_i:\n\u2022 u_i is monotone, i. e., u_i(S) \u2264 u_i(T) whenever T \u2286 S.\n\u2022 If u_i(e) = 0 for each e \u2208 S, then u_i(S) = 0.\nImportantly, our assumptions on utility functions are strictly more general than additivity.\nAn allocation \u03c0 = (\u03c0_1, \u03c0_2,..., \u03c0_{|V(G)|}) is an ordered collection of |V(G)| pairwise disjoint subsets of E(G) whose union is exactly E(G). For each i, the subset \u03c0_i is called the bundle of agent i. We are interested in a special kind of allocations called orientations, which are allocations that can be represented as a graph orientation O of G such that e \u2208 \u03c0_i if and only if e is directed toward i in O. We say an agent i strongly envies an agent j if there exists an edge e \u2208 \u03c0_i such that u_i(\u03c0_i \\ {e}) < u_i(\u03c0_j). An allocation is said to be envy-free up to any edge (chore) (EFX_0) if no agent strongly envies another. In other words, any envy i has for j can be alleviated by ignoring any edge e in the bundle of agent i.\nGiven an instance (G, u) of the above form, EFX_0-ORIENTATION asks whether G admits an EFX_0 orientation.\nWe are particularly interested in a special case of EFX_0-ORIENTATION in which every edge has a certain property. An edge e = {i,j} in a graph is said to be objective if u_i(e) = 0 if and only if u_j(e) = 0. In other words, either e has zero marginal utility for both of its endpoints, or e has strictly negative marginal utility for both of them. If every edge is objective, we say (G, u) is an objective instance of EFX_0-ORIENTATION. When considering such instances, we find it convenient to refer to edges with zero (resp. negative) marginal utility for both endpoints as dummy edges (resp. negative edges). In addition, we define a negative component of G to be a maximal vertex-induced subgraph K such that for any two vertices i, j of K, there exists a path in K between i and j that only contains negative edges. The negative components of G form a partition of V (G)."}, {"title": "2.2 Related Decision Problems", "content": "We define some relevant decision problems. Let H be a graph, P = {P_1, P_2, . . ., P_k} be a set of pairwise disjoint subsets of V(H), and D \u2286 V(H) be a subset of vertices. The set P is not necessarily a partition because not every vertex needs to be in P. We say a subset C \u2286 V(H) is a (P, D)-vertex cover of H if:\n\u2022 Each edge of H is incident to at least one vertex in C;\n\u2022 |C \u2229 P_e| \u2264 1 for each P_e \u2208 P; and\n\u2022 C \u2229 D = \u2205.\nEssentially, C is a vertex cover that contains at most one vertex from each P_i and no vertex in D.\nDefinition 1 (PD-VERTEX-COVER). Given a tuple (H, P, D) where H is a graph, P = {P_1, P_2, . . ., P_k } is a set of pairwise disjoint subsets of V(H), and D \u2286 V(H), PD-VERTEX-COVER asks whether there exists a (P, D)-vertex cover C of H.\nDefinition 2 (2SAT). The 2SAT problem is a special case of SAT in which each clause consists of one or two literals.\nThere exists an algorithm that decides 2SAT and outputs a satisfying assignment if one exists, with running time linear in the number of variables and clauses [Aspvall et al., 1979]."}, {"title": "3 EFX\u2080 Orientations of Graphs", "content": "In this section, we present our polynomial-time algorithm for EFX_0-ORIENTATION. Our algorithm is essentially the result of a reduction from EFX_0-ORIENTATION to 2SAT, and is composed of three nested routines, the outermost of which is the main algorithm FINDEFXORIENTATION.\nTo avoid forward referencing in the following subsections, we present the proofs of correctness of the algorithms in their nested order, starting with most deeply nested one."}, {"title": "3.1 The Subroutine FINDPDVERTEXCOVER", "content": "The subroutine FINDPDVERTEXCOVER (Algorithm 1) accepts an instance (H, P, D) of PD-VERTEX-COVER as input, and outputs a (P, D)-vertex cover C of H if one exists and false otherwise.\nRecall that in an instance (H, P, D) of PD-VERTEX-COVER, H is a graph, P = {P_1, P_2, ..., P_k} is a set of pairwise disjoint subsets of V(H), and D \u2286 V(H). The algorithm starts by constructing an instance \u03c6 of 2SAT on Lines 1-10, which contains a Boolean variable x_i for each vertex i of H and three types of clauses:\n\u2022 (type 1) the clause {x_i, x_j } for each edge e = {i, j} of H (possibly i = j),\n\u2022 (type 2) the clause {\\neg x_i, x_j } for each set P_e \u2208 P and each pair of distinct vertices i, j \u2208 P_e, and\n\u2022 (type 3) the clause {\\neg x_i} for each vertex i \u2208 D.\nThen, the algorithm determines whether \u03c6 admits a satisfying assignment f on Line 11. If so, the algorithm returns the set C := {i \u2208 V(H) : f(x_i) = true}. Otherwise, the algorithm returns false."}, {"title": "3.2 The Subroutine FINDEFXORIENTOBJ", "content": "The subroutine FINDEFXORIENTOBJ (Algorithm 2) takes as input an objective instance (G\u00b0, u\u00b0) of EFX_0-ORIENTATION and outputs an EFX_0 orientation of G\u00b0 if one exists and false otherwise. Recall that in an objective instance, all edges are objective, and we distinguish dummy edges that provide zero marginal utility to both endpoints and negative edges that provide negative marginal utility to both endpoints. Recall also that a negative component of G\u00b0 is a maximal vertex-induced subgraph K such that for any two vertices i, j of K, there exists a path in K between i and j that only contains negative edges.\nFINDEFXORIENTOBJ begins by using breadth-first search (BFS) to find the set K of negative components of G\u00b0 on Lines 1-7. It then constructs the instance (H, P, D) of PD-VERTEX-COVER on Lines 8-17 such that\n\u2022 H is the graph with the same vertex set as G\u00b0 and the set of dummy edges of G\u00b0;\n\u2022 P = {V(K) : K \u2208 K contains exactly |K| - 1 negative edges}; and\n\u2022 D is the set of vertices that belong to a negative component K of G\u00b0 containing exactly |K| negative edges.\nIn the case that G\u00b0 contains a negative component K with more than |K| negative edges, FINDEFXORIENTOBJ returns false. Otherwise, each negative component K contains exactly |K|-1 or |K| negative edges. Via a call to FINDPDVERTEXCOVER (Algorithm 1) on Line 18, the algorithm attempts to find a (P, D)-vertex cover C of H. If unsuccessful, it returns false. Otherwise, it uses C to construct an orientation \u03c0\u00b0 of G\u00b0 as follows.\nFirst, for each dummy edge e that is incident to a vertex i of C, the algorithm allocates e to i, with arbitrary tie-breaking when e is incident to two vertices of C (Lines 22-23). Then, the algorithm orients the negative edges of G\u00b0, one negative component K at a time as follows. If K has exactly |K| negative edges, then the algorithm orients them on Line 26 in a way that each vertex of K receives exactly one negative edge. This is possible because the |K| negative edges of K take the form of a spanning tree of K with an extra edge, so there is a unique cycle C of negative edges of K. By orienting C cyclically, any remaining unoriented negative edges of K form trees branching from C, so we can orient them in the direction away from C, ensuring each vertex of K receives exactly one negative edge.\nOtherwise, K has exactly |K|-1 negative edges. The algorithm proceeds to Lines 29\u201332 and chooses a vertex r of K to be one that has received a dummy edge in the previous step if such a vertex exists, or any arbitrary vertex of K if no vertex of K has received a dummy edge. Once r is chosen, the algorithm orients the |K| - 1 negative edges of K in the direction away from r. This causes these negative edges to form a spanning rooted tree of K rooted at r, ensuring that each vertex of K receives at most one negative edge. FINDEFXORIENTOBJ returns the resulting orientation \u03c0\u00b0 of G\u00b0.\nProposition 1. Let (G\u00b0, u\u00b0) be an objective instance of EFX_0-ORIENTATION. An orientation \u03c0\u00b0 of G\u00b0 is EFX_0 if and only for each vertex i, the orientation \u03c0\u00b0 contains a unique edge directed toward i or every edge directed toward i is a dummy edge.\nProof. Let \u03c0\u00b0 = (\u03c0_1, \u03c0_2,..., \u03c0_{|V(G\u00b0)|}) be an orientation of G\u00b0 and suppose that for each vertex i, the orientation \u03c0\u00b0 contains a unique edge directed toward i or every edge directed toward i is a dummy edge. If \u03c0\u00b0 contains a unique edge e directed toward i, then we have u_i(\u03c0_i \\ {e}) = u_i(\u2205) = 0 \u2265 u_i(\u03c0_j) for any agent j. Otherwise, every edge directed toward i is a dummy edge, so u_i(\u03c0_i) = 0 \u2265 u_i(\u03c0_j) for any j. Hence, no agent strongly envies another and \u03c0\u00b0 is EFX_0.\nConversely, suppose that for some vertex i, the orientation \u03c0\u00b0 contains two edges e, e' directed toward i and not every edge directed toward i is a dummy edge. Without loss of generality, assume u_i(e') < 0. Let j, j' denote the other endpoints of the edges e, e', respectively. Note that j \u2260 j' because G does not contain parallel edges. Also, u_i(\u03c0_j) = 0"}, {"title": "3.3 The Main Algorithm FINDEFXORIENTATION", "content": "FINDEFXORIENTATION accepts an instance (G, u) of EFX_0-ORIENTATION as input and outputs an EFX_0 orientation of G if one exists and false otherwise.\nIt first constructs an objective instance (G\u00b0, u\u00b0) of EFX_0-ORIENTATION by subdividing each non-objective edge of G in the for-loop on Lines 4-15. Specifically, for each non-objective edge e_{ij} = {i, j} of G, it first possibly exchanges the labels between i and j so as to ensure u_i(e_{ij}) = 0. It then subdivides e_{ij} by creating a new vertex k and two new edges e_{ik} = {i,k},e_{jk} = {j,k}, while defining the utilities of the new edges in G\u00b0 as shown in Figure 1, in which \u03b2 := u_j(e_{ij}). While iterating through the edges of G, the algorithm also constructs the set O of objective edges that were not subdivided, and the set S of ordered pairs (e_{ij}, e_{ik}) where e_{ij} is subdivided edge of G and e_{ik} is the resulting edge of G\u00b0 incident to i.\nThe algorithm then calls FINDEFXORIENTOBJ as a subroutine on Line 16, which attempts to find an EFX_0 orientation of G\u00b0. If none exists, the algorithm returns false on Line 18. Otherwise, the subroutine successfully finds an EFX_0 orientation \u03c0\u00b0 of G\u00b0. Using \u03c0\u00b0, the algorithm constructs an orientation \u03c0 of G on Lines 19-26 as follows. First, any edge e_{ij} of G that was not subdivided in the above step is an edge in both G and G\u00b0. We let \u03c0 orient every such edge in G in the same way as \u03c0\u00b0 orients them in G\u00b0.\nOtherwise, the edge e_{ij} of G was subdivided in the above step and corresponds to two fake edges e_{ik}, e_{jk} of G\u00b0. Recall that by possibly exchanging the labels of i and j in the subdivision of e_{ij} above (Line 7), we may assume u_i(e_{ik}) = u_i(e_{ij}) = 0. We let orient e_{ij} toward i in G if and only if \u03c0\u00b0 orients e_{ik} toward i in G\u00b0. At the end, the algorithm outputs the resulting orientation \u03c0 of G."}, {"title": "4 EFX\u2080 Orientations of Multigraphs", "content": "In this section, we turn our attention to multigraphs and consider the problem of deciding if a multigraph admits an EFX_0 orientation, which we call EFX_0-ORIENTATION-MULTIGRAPHS. Our proof relies on a reduction from the NP-complete problem PARTITION [KARP, 1972].\nTheorem 2. Deciding whether a multigraph G of chores admits an EFX_0 orientation is NP-complete, even if G contains only two vertices and agents have additive utility functions.\nProof. Let S = {s_1,s_2,...,s_n} be an instance of PARTITION. Construct the multigraph G on two vertices a, b as follows. For each s_i \u2208 S, we construct an edge e_i between a and b and set u_a(e_i) = u_b(e_i) = -s_i. In addition, we create two self-loops e_a, e_b at each of a, b, respectively, and set u_a(e_a) = 0 and u_b(e_b) = 0. Finally, we assume that the utility functions u_a, u_b are additive.\nWe claim that there exists a partition S = S_a \u222a S_b such that \\sum_{x\u2208S_a} x = \\sum_{x\u2208S_b} x if and only if G admits an EFX_0 orientation. Suppose S = S_a \u222a S_b is such a partition. Let \u03c0 = (\u03c0_a, \u03c0_b) be the orientation of G in which \u03c0_a = {e_a} \u222a {e_i : s_i \u2208 S_a} and \u03c0_b = {e_b} \u222a {e_i : s_i \u2208 S_b}. In other words, both self-loops e_a, e_b are directed toward their respective endpoints, and the edges between a and b are divided according to the partition S = S_a \u222a S_b. Since u_a and u_b are additive, we have u_a(\u03c0_a) = - \\sum_{x\u2208S_a} x = - \\sum_{x\u2208S_b} x = u_b(\u03c0_b), so \u03c0 is EFX_0."}]}