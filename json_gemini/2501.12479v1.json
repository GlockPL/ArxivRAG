{"title": "Degree-Based Logical Adjacency Checking (DBLAC): A Novel Heuristic for Vertex Coloring", "authors": ["Prashant Verma"], "abstract": "Degree Based Logical Adjacency Checking (DBLAC). An efficient coloring of graphs with unique logical AND operations. The logical AND operation shows More effective color assignment and fewer number of induced in the case of common edges between vertices. of colors used. In this work, we provide a detailed theoretical analysis of DBLAC's time and space complexity. It furthermore shows its effectiveness through prolonged experiments on standard benchmark graphs. We still compare with existing algorithms namely DSATUR, and Recursive Largest First (RLF). Second, we show how DBLAC achieves competitive results with respect to both the number of colors used and runtime. performance.\nKeywords: DSATUR Algorithm, RLF Algorithm, Graphs Theory, Chromatic, Graph Coloring. run- time efficiency, number, DIMACS Dataset, Optimization, Algorithm Performance, Vertex Coloring.", "sections": [{"title": "1 Introduction", "content": "The vertex coloring problem is a problem that assigns colors to the vertices of a graph so for every pair of adjacent vertices that share the same color. All vertices are the same color. Our goal is to reduce the number of colors used, called the chromatic number x(G). It is computationally intractable for large particles, this problem is actually NP hard. graphs. Sometimes, heuristic algorithms tried to find approximate solution efficiently. In this paper, we present a new heuristic algorithm, Degree Based Logical Adjacency Check. In particular, building on a degree based ordering (DBLAC), but adding a new logical AND operation. to improve performance. The logical AND operation finds edges common to vertices. more efficient handling of color assignment. In particular this approach is ideal for dense and irregular graphs. where traditional heuristics are often difficult."}, {"title": "2 Related Work", "content": "Vertex coloring problem has been extensively studied, and many heuristics have been designed. It is pro- posed to solve it efficiently. We categorize these algorithms broadly into Greedy Heuristics, Recursive Partitioning Methods and Metaheuristics methods. We discuss the most notable algorithms, below. Finally, I discuss their time complexities and their mathematical foundations."}, {"title": "2.1 Greedy Heuristics", "content": "The simplest and most widely used approaches for vertex coloring are greedy heuristics. First, they give the vertices one by one color and no two adjacent vertices should have the same color. The criterion under which to select the next vertex to color is fixed [1]."}, {"title": "2.1.1 Largest Degree First (LDF)", "content": "Vertices are ordered from smallest to largest in degree with degree being sorted using the Largest Degree First (LDF) Algorithm. colors them sequentially. Common intuition is that high degree vertices are more constrained, and therefore should be. First colored to minimize the number of colors needed [5]."}, {"title": "Mathematical Formulation", "content": "Let G = (V, E) be a graph with n vertices and m edges. The degree of a vertex v, denoted deg(v), is the number of edges incident to v. The LDF algorithm can be described as follows:\n1. Sort vertices in descending order of degree: V = {U1, U2,..., Un} where deg (v1) \u2265 deg(v2) \u2265 \u2265 deg(vn).\n2. For each vertex vi, assign the smallest available color not used by any of its neighbors."}, {"title": "Time Complexity", "content": "The time complexity of LDF is dominated by the sorting step, which takes O(nlogn), and the color assignment step, which takes O(n\u2206), where \u2206 is the maximum degree of the graph. Thus, the overall time complexity is:\nO(nlogn + n\u2206)\nIn the worst case, \u2206 = n \u2212 1, resulting in a time complexity of O(n\u00b2)."}, {"title": "2.1.2 DSATUR", "content": "DSATUR, is one of the best methods for coloring vertices in a very optimized way, which was in- troduced by Daniel Br\u00e9laz in 1979 [6]. DSATUR prioritizes vertices with maximum saturation degree, thus minimizing the number of colors needed to color the graph. For graphs with complex structures, particularly when the constraint is not known a priori, this approach performs well because it evolves with the coloring constraints during the execution."}, {"title": "Mathematical formulation", "content": "For a graph G = (V, E) with n vertices and m edges, let G be. In this case, the saturation degree of a vertex v, denoted sat(v), is the number of distinct colors used in its neighbors. The DSATUR algorithm can be described as follows:\n1. Additionally, all vertices are initialized with a saturation degree of 0.\n2. Select at each step the vertex v of maximum saturation degree. If the degrees of two vertices are the same, select the vertex with the highest degree.\n3. Assign the smallest non-used color by any of v's neighbors.\n4. Update the saturation degrees of its uncolored neighbors v.\n5. Repeat the process until all vertices are colored."}, {"title": "Time Complexity", "content": "The selection and color assignment steps dominate the time complexity of DSATUR. For each vertex, the algorithm must:\n\u2022 Find a vertex with the maximum saturation degree, which takes O(n) per step.\n\u2022 Assign a color to its neighbors, and update the saturation degree of each neighbor. Given a maximum degree of the graph \u2206, this step takes \u039f(\u0394) per step.\nSince there are n vertices, the overall time complexity is:\n\u039f(n\u00b2 + \u03b7\u0394)\nIn the worst case, the A will be n 1, so we have O(n\u00b2)."}, {"title": "2.2 Recursive Partitioning Methods", "content": "Recursive partitioning methods divide the graph into independent sets (subsets of vertices with no edges between them) and color each set separately."}, {"title": "2.2.1 Recursive Largest First (RLF)", "content": "The Recursive Largest First (RLF), for solving the NP hard graph coloring problem. The idea was put forward by mathematician Frank Leighton in 1979[3]. In the RLF algorithm a graph is iteratively (considered to be sub optimally) solved by applying specialized heuristic rules to search for closed inde- pendent sets. The RLF algorithm is capable of producing exact solutions to special classes of graphs, for example to vertex bipartite graphs, cycle graphs and wheel graphs, thanks to these heuristics. Its main power here is its ability to reduce problem size, efficiently, by finding and coloring the largest independent sets recursively. In particular it is often very effective when the graph in question is sparse, because it tends to reduce the number of colors required to a mere anecdote. Moreover, the RLF algorithm is also deterministic, meaning the same input will make it obtainable the same result."}, {"title": "Mathematical Formulation", "content": "Let G (V, E) be a graph. The RLF algorithm can be described as follows:\n1. While there are uncolored vertices:\n(a) Construct an independent set S by iteratively adding the vertex with the fewest neighbors in the remaining graph.\n(b) Assign a new color to all vertices in S.\n(c) Remove S from the graph."}, {"title": "Time Complexity", "content": "RLF takes O(n\u00b3) time, since for every iteration it takes O(n\u00b2) steps to build the independent set. There are up to n independent sets, and we aim to find an independent set efficiently."}, {"title": "2.3 Metaheuristics", "content": "Metaheuristics are high-level strategies that guide other heuristics to find approximate solutions. They are often used for complex or large-scale problems. They are particularly effective where most traditional algorithms or heuristics algorithms do not perform well enough due to vastness or the complexity of the search space."}, {"title": "2.3.1 Genetic Algorithms", "content": "Genetic algorithms (GAs) are inspired by natural selection and evolution. They maintain a population of candidate solutions and iteratively improve them using crossover, mutation, and selection operations."}, {"title": "Mathematical Formulation", "content": "Let P be a population of candidate colorings. The GA can be described as follows:\n1. Initialize P with random colorings.\n2. While the termination condition is not met:\n(a) Select parents from P based on fitness (e.g., number of colors used).\n(b) Generate offspring by applying crossover and mutation.\n(c) Replace the least fit individuals in P with the offspring."}, {"title": "Time Complexity", "content": "The time complexity of GAs depends on the population size, the number of gen- erations, and the complexity of the fitness function. In practice, GAs are computationally expensive and have a time complexity of O(kn\u00b2), where k is the number of generations."}, {"title": "2.4 Limitations of Existing Algorithms", "content": "While the above algorithms perform well in many cases, they have limitations:\n\u2022 LDF and DSATUR struggle with dense graphs, where the number of edges is close to  n(n-1).\n\u2022 RLF is computationally expensive and may not scale well to large graphs.\n\u2022 Metaheuristics like GAs are time-consuming and may not guarantee optimal solutions."}, {"title": "2.5 Our Contribution: DBLAC", "content": "Our proposed algorithm, Degree-Based Logical Adjacency Checking (DBLAC), addresses these limitations by combining degree-based ordering with a logical AND operation to identify common edges between vertices. This approach enables more efficient color assignment, particularly for dense and irregular graphs. The logical AND operation is a novel feature that distinguishes DBLAC from existing algorithms."}, {"title": "Mathematical Formulation", "content": "Let G (V, E) be a graph. The DBLAC algorithm can be described as follows:\n1. Order vertices in descending order of degree: V = {V1, V2, ..., Un}.\n2. For each vertex vi:\n(a) Assign the smallest available color not used by any of its neighbors.\n(b) Apply a logical AND operation to find common edges between vi and its neighbors.\n(c) Assign colors to common vertices based on adjacency constraints."}, {"title": "Time Complexity", "content": "The time complexity of DBLAC is O(n\u2206), where \u2206 is the maximum degree of the graph. This makes DBLAC more efficient than RLF and competitive with DSATUR and LDF."}, {"title": "3 Algorithm Description", "content": "Our algorithm, called Degree-Based Logical Adjacency Checking (DBLAC), works as follows:"}, {"title": "3.1 Theoretical Analysis", "content": ""}, {"title": "3.1.1 Time Complexity", "content": "The time complexity of DBLAC is dominated by the adjacency-checking and logical AND operations. For each vertex, we check the colors of its neighbors, which takes \u039f(\u0394) time, where A is the maximum degree of the graph. The logical AND operation also takes \u039f(\u0394) time. Since there are n vertices, the overall time complexity is:\n\u039f(\u03a0\u0394)\nIn the worst case, A = n 1, resulting in a time complexity of O(n\u00b2)."}, {"title": "3.1.2 Space Complexity", "content": "The space complexity is determined by the storage required for the graph and the color assignments. The adjacency list representation of the graph requires O(n+m) space, where m is the number of edges. The color assignments require O(n) space. Thus, the overall space complexity is:\nO(n + m)"}, {"title": "4 Application to Graph Problems", "content": "In this section, we apply DBLAC to three graph problems and demonstrate its effectiveness."}, {"title": "4.1 Problem 1: 5-Vertex Graph", "content": "Consider the graph shown in Figure 1.0 with five vertices. The vertices are ordered by degree as {U2, U1, U3, V4, V5}."}, {"title": "4.1.1 Solution", "content": "\u2022 Assign c\u2081 to v2 and c\u2082 to v1.\n\u2022 Check adjacency between v2 and 21. Since they are adjacent, they cannot share the same color.\n\u2022 Apply logical AND operation to find common edges between v2 and v\u2081, resulting in common vertices 03 and 25.\n\u2022 Assign c3 to 23 and 25.\n\u2022 Assign c2 to 24."}, {"title": "4.1.2 Final Coloring", "content": "{(V1, C2), (U2, C1), (V3, C3), (V4, C2), (U5, C3)}\nThe graph is x(3) Colors."}, {"title": "4.2 Problem 2: 6-Vertex Graph", "content": "Consider the graph shown in Figure 2.0 with six vertices. The vertices are ordered by degree as {f, a, d, c, e, b}."}, {"title": "4.2.1 Solution", "content": "\u2022 Assign c\u2081 to f and c\u2082 to a.\n\u2022 Check adjacency between f and a. Since they are adjacent, they cannot share the same color.\n\u2022 Apply logical AND operation to find common edges between f and a, resulting in common vertices {b, c, d, e}.\n\u2022 Assign c3 to d and c4 to c.\n\u2022 Assign c4 to e.\n\u2022 Assign c3 to b."}, {"title": "4.2.2 Final Coloring", "content": "{(a, c\u2082), (b, C3), (c, c\u2084), (d, c\u2083), (e, C4), (f, c\u2081)}\nThe graph is x(4) Colors."}, {"title": "4.3 Problem 3: 6-Vertex Graph with Higher Complexity", "content": "Consider the graph shown in Figure 3.0 with six vertices. The vertices are ordered by degree as {V5, V1, V2, V3, V4, V6 }."}, {"title": "4.3.1 Solution", "content": "\u2022 Assign c\u2081 to 25 and c\u2082 to v1.\n\u2022 Check adjacency between 25 and 21. Since they are adjacent, they cannot share the same color.\n\u2022 Apply logical AND operation to find common edges between 25 and v\u2081, resulting in a single common vertex v2.\n\u2022 Assign c3 to v2.\n\u2022 Assign c3 to 23 and 24.\n\u2022 Assign c\u2081 to v6."}, {"title": "4.3.2 Final Coloring", "content": "{(V1, C2), (V2, C3), (V3, C3), (V4, C2), (V5, C1), (V6, C1)}\nThe graph is x(3) Colors."}, {"title": "5 Experimental Evaluation", "content": "We evaluated the performance of DBLAC, DSATUR, and RLF on two types of datasets: (1) randomly generated graphs and (2) standard benchmark graphs from the DIMACS dataset. The evaluation metrics include the number of colors used and the runtime for each algorithm."}, {"title": "5.1 Performance Metrics", "content": "\u2022 Number of Colors: The total number of colors used to color the graph. A lower number indicates better performance.\n\u2022 Runtime: The time taken to compute the coloring, measured in seconds. A lower runtime indicates better efficiency."}, {"title": "5.2 Randomly Generated Graphs", "content": "We generated 100 random graphs using the Erd\u0151s-R\u00e9nyi model [2], each with 1500 vertices and an edge probability of 0.5. The results are summarized in Table 1 According to our observation and by Lewis (2021) in A Guide to Graph Coloring [4]: In general, DSATUR algorithms produce significantly better vertex colorings of random graphs than any simple greedy approaches. For example, in our experiments on a set of randomly generated graph instances, RLF did not have good chromatic quality (number"}, {"title": "5.3 Graph Comparison", "content": "To visualize the performance differences, we plotted the Number of chromatic color has been used by graph Number of Colors and Runtime Graph Time Complexity 12. Our method DBLAC consistently outperformed the others, achieving a better balance between selection of minimum number of colors and and time take to color."}, {"title": "5.3.1 Analysis of Random Graph Results", "content": "\u2022 Number of Colors: DBLAC uses fewer colors on average (19.50) compared to DSATUR (20.10) and RLF (20.20). This demonstrates that DBLAC is more effective in minimizing the number of colors.\n\u2022 Runtime: DBLAC is the fastest algorithm, with an average runtime of 0.0009 seconds. DSATUR is slightly slower (0.0019 seconds), while RLF is significantly slower (0.0081 seconds). This high- lights the computational efficiency of DBLAC."}, {"title": "5.4 Performance Evaluation of DBLAC on Benchmark Graphs", "content": "We present a detailed evaluation of the DBLAC algorithm against DSATUR and RLF on a set of benchmark graphs. The results are summarized in Table 2, which is rotated 90 degrees counterclockwise for better readability."}, {"title": "5.4.1 Analysis of Results", "content": "\u2022 Number of Colors: The DBLAC algorithm demonstrates competitive performance in terms of the number of colors used. By reducing the chromatic number by 1 or 2 in certain cases, DBLAC shows improved color efficiency.\n\u2022 Runtime Efficiency: DBLAC consistently outperforms both DSATUR and RLF in terms of runtime.  This highlights the scalability and efficiency of DBLAC for large-scale graph coloring problems.\n\u2022 Overall Performance: The results demonstrate that DBLAC is a robust algorithm that balances color efficiency and runtime performance. Thus, DBLAC emerges as a practical choice for graph coloring, particularly in scenarios where both speed and color efficiency are critical."}, {"title": "6 Conclusion", "content": "We have presented in this paper a heuristic algorithm to solve the vertex coloring problem, termed Degree Based Logical Adjacency Checking (DBLAC). We color graph vertices with as few colors as possible by combining our degree-based ordering with a new logical AND operation, and do so efficiently. In theoretical analysis, we prove that DBLAC is an O(n\u2206) time and O(n + m) space algorithm on large- scale graphs.\nExperimental evaluations were conducted on two types of datasets: (1) Graphs chosen from the DI- MACS dataset, which are standard benchmark graphs, and (2) randomly generated graphs. Our results show that DBLAC obtains fewer colors and faster runtime than DSATUR and RLF. Specifically:\n\u2022 DBLAC found, on randomly generated graphs of 100 vertices, an average of 19.50 colors in total, while DSATUR and RLF averaged 20.10 and 20.20 colors, respectively. In addition, DBLAC was significantly faster, taking an average of 0.0009 seconds versus 0.0019 seconds for DSATUR and 0.0081 seconds for RLF.\n\u2022 Results on DIMACS benchmark graphs demonstrate that DBLAC is comparable and, in some cases, better than DSATUR and RLF.For example, the le450_5a graph took on average 5 colors with DBLAC and 6 colors with RLF.\nThe DBLAC logical AND operation features two significant properties: first, it combines efficiently with traditional heuristics, and second, it allows for more efficient color assignment for dense and irregular graphs where traditional heuristics fail. Together with its low time and space complexity, DBLAC is a promising approach for applications such as scheduling, register allocation, and network design."}]}