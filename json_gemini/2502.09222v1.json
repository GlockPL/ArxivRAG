{"title": "ASP-driven User-interaction with Clinguin", "authors": ["Alexander Beiser", "Susana Hahn", "Torsten Schaub"], "abstract": "We present clinguin, a system for ASP-driven user interface design. Clinguin streamlines the development of user interfaces for ASP developers by letting them build interactive prototypes directly in ASP, eliminating the need for separate frontend languages. To this end, clinguin uses a few dedicated predicates to define user interfaces and the treatment of user-triggered events. This simple design greatly facilitates the specification of user interactions with an ASP system, in our case clingo.", "sections": [{"title": "Introduction", "content": "The growing popularity of Answer Set Programming (ASP; [13]) in both academia and industry necessitates the development of user-friendly graphical interfaces to cater to end users. This is especially critical for interactive applications where users engage in iterative feedback loops with ASP systems. Examples include timetabling or product configuration tools. This leads to challenges in frontend development and requires skills in areas beyond ASP development. In addition, custom solutions have a limited reach, as they cannot be easily adapted.\nClinguin addresses this challenge and streamlines User Interface (UI) development for ASP developers by letting them build interactive prototypes directly in ASP, eliminating the need for separate frontend languages. To this end, clinguin uses a few dedicated predicates to define UIs and the treatment of user-triggered events. This simple design greatly facilitates the specification of user interactions with an ASP system, in our case clingo [12]. Our approach shares similarities with the ASP-driven visualization system clingraph [10]. In fact, clinguin can be regarded as the interactive counterpart of clingraph, whose single-shot approach lacks any interaction capabilities.\nIn what follows, we rely on a basic acquaintance with ASP, the ASP system clingo [7], and some rudimentary Python knowledge. We explain specialized concepts as they are introduced throughout the text."}, {"title": "Architecture and Workflow of clinguin", "content": "Clinguin uses a client-server architecture, where communication occurs via the HTTP protocol (RESTful\u00b9). JSON is used for message content between client and server. The server leverages clingo (5.7) and calculates the information needed to build the UI; this is used by the client to render the corresponding UI and update it based on the user's interaction. The update is either handled directly at the client-side or sent back to the server for further processing, triggering a new interaction loop.\nFigure 1 illustrates the architecture and workflow of clinguin. It focuses on the key technical components: server, client, and user interface (UI). Furthermore, it shows how the UI is generated and how user interactions are handled within the system.\nIn what follows, we illustrate clinguin's approach with a detailed, step-by-step walkthrough using a simple running example about assigning people to seats where a cat person and a dog person cannot share the same table. The corresponding problem instance and encoding are given in Listings 1 and 2, respectively. We refer to them as the domain files among the input files; they are highlighted in pink in Figure 1.\nThe choice in Line 1 of Listing 2 generates possible assignments of a person p to a seat s. Each seat s is defined by a pair (t,c) of a numbered table t and chair c. Lines 3 to 6 constrain the assignment, ensuring that a person is assigned to exactly one seat where everyone at the table shares the same pet preference. Each of these integrity constraints is conditioned with an instance of cons/2 defined as facts in Lines 8 to 10. The first argument of cons/2 identifies the constraint violation, while the second argument provides the corresponding user-friendly explanation. Although the introduction of these atoms may appear unnecessary at this point, they will be used to identify constraint violations in Section 3.\nThe server is started with the domain and UI files as command-line arguments:\nclinguin server --domain-files ins.lp enc.lp --ui-files ui-tables.lp\nUsing the domain files, the server creates the clingo object domain-control (in purple in Figure 1), which employs multi-shot solving by default. The other input files, called ui-files and given in pink in Figure 1,\nare used to generate a single stable model composed of atoms defining the layout, style, and functionality of the interface, collectively forming the ui-state. To this end, another clingo object, ui-control in purple in Figure 1, is restarted on each update.\nUpon launching the client with \u2018clinguin client', it requests the UI state (or ui-state) from the server (see the GET arrow in Figure 1). Once received, the client utilizes a front-end language to render the corresponding user interface. We use Angular2 as front-end language with Bootstrap\u00b3 as a toolkit for customization. Subsequent user interactions with the UI (usually) generate new requests to the server, providing details about the selected operations. These operations are predefined by the server and allow users to interact with the domain-control in different ways. Examples include adding a user selection as an assumption to the solver, setting the value of an external atom, or obtaining the next solution4. Once the server completes the selected operations, it constructs a hierarchical JSON structure of the updated ui-state and returns it to the client for rendering.\nThe ui-state is defined by predicates elem/3, attr/3 and when/4, for specifying the UI's layout, style and functionality, respectively (see green box with header ui-state in Figure 1). The corresponding atoms are mapped into Python classes using clorm, a Python library that provides an object-relational mapping interface to clingo. An atom elem(X,T, X') defines an element X of type T inside element X'. Such UI elements are the visual representations of objects or features in an interface, such as a button, text field, dropdown menu, and more. The attributes of an element, such as position and style, are specified by attr(X,K,V), where X is an element, and K and V denote the attribute's name (key) and value, respectively.\nThe reactive behavior of the UI is defined by atoms of form when(X,E,A,P), which can be interpreted as expressing: \u201cWhen event E is triggered on element X, it is followed by an action A with arguments P\". An event refers to an action initiated by the user, such as clicking, double-clicking, or entering text. An action is a system response triggered by the UI event. This action must be one of the following:\n\u2022 a call to the server (POST operation), where P represents one or multiple server operations,\n\u2022 a local attribute update, where P is a triple (X', K, V) leading to an update of attribute K on element X' by V,\n\u2022 a local update to a context defined as a dictionary, where P is the key-value pair to update and keep as local memory.\nThe atoms constituting the ui-state are generated from the encodings provided as ui-files along with facts describing the domain-state (see green box with the identical header in Figure 1). The latter state provides valuable insights into the current state of the domain-control object, including the intersection and union of the stable models generated by the domain-control, a single stable model for focused exploration, and internal information encapsulated in atoms whose predicates typically start with _clinguin_. Collectively, these facts represent relevant information for generating the UI.\nLet us illustrate this with our example. Listing 3 shows the ui-file generating the UI snapshots in Figure 2. Line 1 creates a window element labeled w and places it inside the overarching root element. Line 2 adds an attribute to window w stating that its children elements form a row. Similarly, Line 4 creates a container tables and places it inside window w. This container groups all elements representing tables. Accordingly, Line 6 defines a container for each table table(T) with number T. The table numbers are\ndrawn from the instance using atoms with predicate seat/1 (as seen in Listing 1). Line 7 uses attribute order to order tables based on their number. Similarly, Line 8 sets the width of these elements.\nIn HTML, the class attribute specifies one or more class names for an element. These class names correspond to styles defined in a style sheet, which determines the visual properties of the element. Bootstrap provides a predefined set of classes that help ensure consistent styling across a user interface. As common in UI design, these classes draw from a custom color palette. For clinguin, we crafted this color palette with primary (blue) and secondary (purple) colors as well as special colors representing information, warnings and errors. Lines 9 to 12 set eight of such Bootstrap class names for each table element. This is done via clingo's pooling operation ';' to expand rules. In detail, the class names in Line 9 address the background color, opacity and rounded corners. Line 10 deals with the orientation of all elements in the container. And Line 11 addresses padding and margin.\nLines 14 to 16 create a label element with the table number as title in the first position of the table container. To facilitate this, clinguin provides several external Python functions, such as @concat for label assembly Line 16.\nSo far, we only used ASP to generate a set of facts capturing static aspects of a user interface. Next, we want to leverage ASP to present users with a well-defined set of choices for selection. To this end, we differentiate between necessary and possible selections in view of what is already chosen by the user. These selections can be captured via the intersection and union of the stable models of the domain files, while also incorporating the user's selections. A necessary selection belongs to all stable models, and a possible one to at least one. In technical terms, this is achieved by manipulating and reasoning with the ASP system clingo encapsulated within the domain-control object. Recall that the latter is\ninitialized with the domain files. User selections can alternatively be incorporated into the domain-control object in terms of assumptions, externals, or regular atoms (cf. [12]). To further include atoms belonging to the intersection and union of the stable models, we reify them via predicates _all/1 and _any/1, respectively, and add the resulting atoms to the current domain-state. This is accomplished by two consecutive invocations to the current domain-control object, once setting clingo option -enum-mode to cautious and then to brave. Although predicates _all/1 and _any/1 resemble epistemic operators, their usage is restricted to passing information from the domain to the UI side.\nNow, let us explore how clinguin manages this in our running example. Lines 18 to 21 define a dropdown_menu for each seat and add it to the corresponding table container. The heading text of each menu is defined with attribute selected. We use this attribute to indicate necessary selections in Line 21. Only if a person P is assigned the same seat S in all stable models, expressed by _all(assign(P,S)), its name is shown as the respective menu text. Similarly, Lines 23 to 25 define all possible seat selections by dropdown_menu_item[s] in terms of _any(assign(P,S)).\nLine 25 dictates the actions occurring when a user click[s] on an item within the dropdown menu. If so, a call action is initiated and transmitted to the server. In our case, we model user selections as assumptions. Accordingly, server operation add_assumption is invoked with arguments assign(p,s) and true, reflecting the user's selection of person p at seat s. This operation results in the addition of atom assign(p,s) to the domain-control object as a true assumption.6\nSemantically, this amounts to adding the integrity constraint \u2018:- not assign(p,s).' and thus forcing the domain encoding to infer assign(p,s). All this is reflected by the upper path from the UI to domain-control in Figure 1.\nThe second screenshot in Figure 2 shows that initially all persons are possible selections for the first seat at Table 1. Once Alexander's seat is chosen, clinguin adds the corresponding assumption to the domain-control object. This automatically leads to Susana's assignment to the second seat, since all resulting stable models agree on this. Moreover, all three seats at Table 2 have now only the single option Torsten left, since none of the remaining stable models seats Alexander or Susana at this table.\nFor further illustration, we now extend the functionality of our example by solution browsing. That is, we add Listing 4 to Listing 3 and continue the user interaction from Figure 2 in Figure 3. To begin with, Lines 1 to 3 create a menu_bar along with a title and an icon.7 Lines 5 to 8 add a button to the menu_bar to iterate through solutions. When the button is clicked, the server operation next_solution is called. This operation computes a new stable model for exploration and adds it to the domain-state.\nWhile the previous part of the UI encoding fixes static aspects of the user interface, we now turn to the dynamic part. Our design of solution browsing revolves around displaying the choices from the\""}, {"title": "Extensibility", "content": "Clinguin offers an open modular design that is easily extensible. This allows us to implement extensions without changing the overall workflow. On the server side, this is done by modifying the backend component, which provides a layer between the bare ASP solver and the user. To achieve this extensibility,\nwe abstract the responsibilities of backends into different key sections of clinguin's workflow that can be customized: the set of callable operations, the way the control object is handled (solving, grounding, model handling, etc.), the atoms included in the domain-state, the way the UI is updated, and the options passed when starting the server. Currently, clinguin offers a default backend using clingo, which implements all main functionalities for single- and multi-shot solving [8] via clingo's API. Additionally, it includes specialized backends for clingo[DL], a clingo extension with difference constraints [11], clingraph, a clingo extension with visualization capabilities [10], and last but not least an explanation backend, which we detail below. On the client side, the frontend component can be exchanged to accommodate different GUIs. Currently, clinguin offers the web-based frontend Angular, used in the paper at hand, and tkinter, the standard Python interface to the Tcl/Tk GUI toolkit. Alternative GUI frameworks are easily incorporated, mainly because the client-server communication of clinguin is standardized by a JSON representation."}, {"title": "Case study: A backend adding explanations", "content": "This section focuses on extending clinguin's backend to provide users with improved feedback when their choices lead to an unsatisfiable scenario. The first part involves pinpointing specific conflicts within the user's selections that impede finding a solution. The second one builds upon this by focusing on presenting error messages tailored to the specific reasons for unsatisfiability.\nWe start by revealing all options, including those not leading to any solution. This is done in Listing 6 by exclusively using features explained above. The encoding adds all infeasible options in Lines 1 to 6 and informs the user that they belong to no solution in Line 7 (ignoring Line 9 for now). The addition of dropdown-menu-item[s] relies on the input from the standard backend. Infeasible choices are indicated by red text. Note the use of negative literals with predicate _any to identify selections belonging to no stable model. The effect of this approach is illustrated in the second snapshot of Figure 5.\nOur first approach hinges on identifying user choices that prevent a solution. Here is where the explanation backend comes into play. Remember that we model user selections as assumptions. Modern\nASP solvers like clasp [3] or wasp [2] can pinpoint unsatisfiable sets of assumptions when solving an ASP program. We exploit this capability in clinguin's explanation backend by including instances of the special predicate _clinguin_mus/1 in the domain-state. The arguments of all such instances represent a minimal set of assumptions that, when combined, lead to an unsatisfiable scenario.\nClinguin's_clinguin_mus/1 predicate helps us pinpoint infeasible user choices. We leverage this predicate in Line 9 to highlight in red the dropdown_menu[s] of the assignments causing the issue (extending Lines 18 to 21 in Listing 3). Additionally, to only show the selection in menus associated with user choices, we modify Line 21 in Listing 3, and replace predicate_all with _clinguin_assume in the body of the rule:\nThis guarantees that the text in the dropdown menus reflects the user's selection, even if it leads to an unsatisfiable result. When an assumption causes an unsatisfiable scenario, the facts in the domain-state coming from the domain-control (including the stable model, _any, and _all) are retrieved from the last successful computation. Meanwhile, those indicating the state of unsatisfiability and selections (given by_clinguin_mus/1 and _clinguin_assume/2) are effectively updated. Therefore, in this extension handling unsatisfiable scenarios, using predicate _clinguin_assume instead of _all ensures the selection is accurately displayed.\nAn interaction using this UI feature is shown in Figure 5, ending in Option 1. As before, we start by selecting Alexander for the first seat at Table 1. However, unlike Figure 2\u20134, the second seat remains unassigned due to the code modification in Listing 3. Clicking on this reveals both Torsten and Alexander highlighted in red. This signifies that neither option leads to a valid solution. Now, imagine a curious user selects Torsten despite the red color, aiming to understand why this choice is infeasible. As a result, the dropdown menus of the specific assumptions causing the unsatisfiability are highlighted in red. In this simple example, it might only indicate a conflict with Alexander's previous assignment. However, in more complex scenarios, only a subset of assumptions would typically be highlighted, pinpointing the exact source of the infeasibility.\nThe interaction leading to Option 1 in Figure 5 is obtained by the following command:\nclinguin client-server --domain-files ins.lp enc.lp \\\n--ui-files ui-tables.lp ui-menu.lp ui-people.lp ui-explain.lp \\\n--backend Explanation Backend\nThis command adds ui-explain. 1p and the changed ui-tables. lp file to the UI files and moreover an additional parameter to indicate the use backend ExplanationBackend.\nOur second part of the extension aims at providing user-friendly explanations in natural language when their choices lead to dead ends. For instance, in our running example, Alexander and Torsten cannot be placed at the same table because they have conflicting pet preferences. Ideally, the UI should display an error message that clearly explains this specific reason whenever both are assigned to the same table. The key to generating these explanations lies in their connection to the domain files. Since explanations are specific to the problem being modeled, we leverage the concept of integrity constraints defined in those files. By tying unsatisfiability to the violation of these constraints, we can precraft corresponding explanations that pinpoint the exact reason behind the dead end.\nTo this end, we use the binary predicate cons/2 in Listing 2 to identify and trigger constraints. In essence, each integrity constraint is paired with a cons/2 instance that acts as a translator, converting the technical constraint violation into an understandable explanation for the user. In order to have these\natoms as part of our minimal set of assumptions, these backend extension performs a transformation of the domain files. This transformation will (internally) replace facts matching the predicate signature cons/2 by a choice, providing the option to activate or deactivate the corresponding constraint when searching for unsatisfiable assumptions. Then, we treat each instance of cons/2 as a true assumption, which keeps all original integrity constraints intact.\nNow that we understand how cons/2 instances link constraints to explanations, let us explore how these explanations are triggered within the system. Whenever a specific cons/2 instance ends up in an unsatisfiable set of atoms, it indicates that the constraint must be active to trigger the inconsistency, which can be interpreted as a violation of the corresponding constraint. This violation triggers the explanation associated with that cons/2 instance in the UI by opening a message box displaying the explanation. This is defined in Listing 7 for cons/2 instances belonging to the current set of assumptions held in the server's domain-state.\nFinally, we can engage the interaction leading to Option 2 in Figure 5 as follows:\nclinguin client-server --domain-files ins.lp enc.lp \\\n--ui-files ui-tables.lp ui-menu.lp ui-people.lp \\\nui-explain.lp ui-explain-msg.lp \\\n--backend Explanation Backend --assumption-signature cons, 2\nWe add ui-explain-msg.lp to the previous set of UI files, and indicate the spacial treatment of facts matching a predicate signature by using the command line option--assumption-signature in a generic way.\nWe now address the implementation details of this clinguin backend. The ExplanationBackend extends the available standard backend for clingo, viz ClingoBackend. In detail, it alters the setup to keep track of the internal representation of the assumptions, registers a new command line option assumption-signature, and adds (minimally) unsatisfiable sets of assumptions to the domain-state."}, {"title": "Related work", "content": "The creation of problem-specific interfaces has been a long standing challenge for declarative methods. A Prolog-based method using XML was investigated in [15]. [14] focus on automatic user interface generation with model-based UIs. This is extended with contextual information and ASP in [16]. In the context of non-interactive ASP visualizations, recent advancements have led to clingraph [10]. The need for interactivity in ASP was addressed in previous studies [9], and later incorporated into clingo's API with multi-shot capabilities [12], enabling continuous solving of logic programs that undergo frequent changes. Tools have also emerged to facilitate ASP program development, such as ASP Chef [1] for task pipelining, and various Integrated Development Environments [6, 4]. These tools align with advancements in related areas like argumentation [5]. In contrast to existing work, clinguin focuses on creating modern domain-specific interactive user interfaces in ASP."}, {"title": "Conclusion", "content": "We have presented clinguin, an easy yet expressive tool for creating user interfaces within ASP. This application relies on ASP features, like union and intersection of stable models, assumptions, and minimally unsatisfiable sets. A central idea is to reify these concepts and to keep them along with a stable model in focus as a set of atoms, which is then used by a UI encoding to generate a user interface and react to user events. Meanwhile, clinguin has become invaluable in our industrial applications since it greatly extends the rapid prototyping nature of ASP. Clinguin (version 2.0) is freely available as open-source software at https://github.com/potassco/clinguin; its documentation is obtained at https://clinguin.readthedocs.io. The distribution contains several substantial use-cases, illustrating the full power of clinguin."}]}