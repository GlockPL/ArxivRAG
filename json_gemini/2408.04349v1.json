{"title": "Optimal Layout-Aware CNOT Circuit Synthesis with Qubit Permutation", "authors": ["Irfansha Shaik", "Jaco van de Pol"], "abstract": "CNOT optimization plays a significant role in noise reduction for Quantum Circuits. Several heuristic and exact approaches exist for CNOT optimization. In this paper, we investigate more complicated variations of optimal synthesis by allowing qubit permutations and handling layout restrictions. We encode such problems into Planning, SAT, and QBF. We provide optimization for both CNOT gate count and circuit depth. For experimental evaluation, we consider standard T-gate optimized benchmarks and optimize CNOT sub-circuits. We show that allowing qubit permutations can further reduce up to 56% in CNOT count and 46% in circuit depth. In the case of optimally mapped circuits under layout restrictions, we observe a reduction up to 17% CNOT count and 19% CNOT depth.", "sections": [{"title": "Introduction", "content": "Quantum Computing promises speedup in solving computationally hard and classically intractable problems. Logical formulations of such problems are compiled to enable execution on quantum processors. The Quantum compilation pipeline broadly consists of two main stages, Circuit Synthesis and Layout Synthesis. Circuit Synthesis mainly focuses on the decomposition of abstract circuits to a target gate set. Layout Synthesis instead focuses on satisfying hardware restrictions. For instance, not all physical qubits interact with each other in some current quantum processors. Thus, quantum gates that act on 2 qubits can only be scheduled on adjacent physical qubits. In the current Noisy Intermediate Scale Quantum (NISQ) era, noise is inherent to quantum computers. Every execution of a gate can increase the error in the computation. For practical quantum computing, error reduction is of utmost importance. Optimization techniques are applied throughout the compilation pipeline. In particular, reducing gate count and circuit depth can directly impact the error rate.\nWhile an optimal synthesis for the whole compilation pipeline is ideal, it is an extremely hard problem. For instance, [23] proposes SMT-based synthesis under hardware connectivity restrictions and target gate set. From [23], it is clear that synthesis beyond 4 qubits is impractical. Essentially, to optimize a n qubit circuit one needs to consider its $2^n \\times 2^n$ unitary matrix. The alternative is to optimize error-prone gates like 1-qubit T-gates and 2-qubit CNOT-gates for error reduction. Several approaches are applied for T-gate optimization [2, 1] in tools like T-par\u00b9 and Feynman.2 While such tools reduce T-gate count and depth, they can significantly increase CNOT-gate count. As a result, CNOT optimization without changing the T-gate"}, {"title": "Preliminaries", "content": "In this paper, we focus on special circuits called CNOT circuits, which consist solely of 2-qubit CNOT gates (controlled-NOT). A CNOT gate takes two inputs, a control qubit with a and a target qubit with b, and outputs $a \\oplus b$ on the target qubit. For example, Table 1 shows a CNOT circuit with 6 CNOT gates.\nCNOT sub-circuits appear frequently in quantum circuits, since CNOT is the only binary gate in many quantum platforms. Optimizing such sub-circuits directly impacts the overall error. Every n-qubit CNOT circuit can be represented by a so-called parity matrix i.e., a"}, {"title": "CNOT circuit equivalence", "content": "For optimal synthesis, we first need to establish equivalence between CNOT circuits. In general, two quantum circuits are equivalent if their unitary matrices are the same. Intuitively, equivalent circuits have the same input-output behavior. Note that equivalent circuits can have different gate counts and circuit depths. The general idea for optimization is to compute an equivalent circuit with either a lower gate count or circuit depth.\nEvery parity matrix has a corresponding unitary matrix. For CNOT circuits, we can directly use the parity matrix representation for this equivalence relation. If two CNOT circuits have the same parity matrix, then they are strongly equivalent [3, 23].\nTwo CNOT circuits C, C' are strongly equivalent if and only if $M_C = M_{C'}$.\nFor example, consider the CNOT circuit in Table 1 with the final matrix in Table 2. Synthesizing optimal column operations to reach $M_C$ is equivalent to synthesizing an optimal circuit C'. One can synthesize the same parity matrix by using only three column additions on (q1, q0), (q3, q1), and (q1, q3). Thus, the resulting equivalent circuit as in Table 3 only has 3 CNOT gates (optimal) as instead of 6.\nWhile one can use strong equivalence for optimal synthesis, the definition is somewhat restrictive. The order of input qubits and output qubits is the same in the optimized circuit in Table 3. However, one could allow permutations of the output qubits within a circuit, as long as one keeps track of the final \"physical\" position of the \"logical\" output qubits. For example, Table 4 shows an equivalent circuit where the order of output qubits is changed. In CNOT circuits, the output qubit permutation simply corresponds to the permutation of columns in the parity matrix."}, {"title": "Restricted CNOT connections (R)", "content": "We also explore layout-aware CNOT optimization. In some quantum platforms, not all qubit pairs are connected thus restricting 2-qubit gate execution. One can only apply CNOT gates on adjacent pairs of qubits based on some coupling graph. Usually, Circuit Synthesis and Layout Synthesis are separated, leading to suboptimal results. For instance, most Layout Synthesis techniques do not take CNOT gate cancellation opportunities into account when transpiling.\nWe integrate these phases, by adapting our CNOT synthesis to respect connectivity constraints. Given a restricted set of CNOT connections, we only allow column additions that correspond to adjacent qubits when synthesizing the final matrix (or a permutation of it). We now obtain the minimal CNOT circuit that satisfies the restrictions.\nSuppose, we want to optimize our example circuit in Table 1, allowing CNOT gates only on qubit pairs (0, 1), (1, 2), and (2, 3). If we insist on strong equivalence, we need 8 CNOT gates (optimal) as shown in Table 6. Note that we need more than the original 6 CNOT gates, due to connectivity restrictions. Allowing weak equivalence requires only 5 CNOT gates (optimal) as shown in Table 7."}, {"title": "Metrics and relevant synthesis variants", "content": "We consider three metrics on quantum circuits in this paper, CNOT-gate count, depth, and CNOT depth. The CNOT count is simply the number of CNOT gates in a circuit. The depth of a circuit is the length of the longest path in the dependency graph of its gates, connected by direct input-output dependencies. The CNOT depth of a circuit is the largest number of CNOT gates on any dependency chain. For instance, the circuit in Table 6 has CNOT count 8, but its CNOT depth is only 7 (since the first two CNOT gates are applied in parallel). For CNOT circuits, depth and CNOT depth always coincide.\nFor CNOT and depth optimization, optimal synthesis is a computationally hard problem. Variants with CNOT restrictions have been proven to be NP-hard for both gate count and depth optimization [19] metrics. In fact, for synthesis with CNOT restrictions, even finding approximate solutions is NP-Hard [18]. We encode such hard problems in Classical Planning, SAT, and QBF. In particular, we are interested in 4 synthesis variants:\n\u2022 S: Synthesis with strong equivalence (and no restrictions).\n\u2022 W: Synthesis with weak equivalence (and no restrictions).\n\u2022 S+R: Synthesis with strong equivalence and CNOT restrictions.\n\u2022 W+R: Synthesis with weak equivalence and CNOT restrictions.\nNot all variants can be encoded efficiently in every solving technique. For instance, we found an efficient encoding of the W variant in SAT, but it seems more difficult in classical planning and QBF. So we encode selected variants for each technique:\n\u2022 Classical Planning: only S and S+R with CNOT gate optimization.\n\u2022 SAT: All 4 variations for both CNOT count and CNOT depth.\n\u2022 QBF: S and S+R for both CNOT count and depth optimization."}, {"title": "CNOT synthesis as planning", "content": "In this section, we first describe the encoding for the S+R variant in Classical Planning in PDDL. We encode the synthesis as a reachability problem, where nodes of a graph represent the state of the matrix and edges represent column additions. Given a circuit, we first compute its parity matrix which corresponds to the goal node. The shortest path from the initial node with the Identity matrix to the goal node corresponds to the optimal number of CNOT gates.\nAll our objects, which label rows and columns, are of type qubit. We use the following two predicates to represent the state:\n\u2022 (m ?r ?c - qubit): represents a matrix element with ?r row and ?c column parameters.\n\u2022 (connected ?a ?b - qubit): static predicate to represent connected qubit parameters ?a and ?b.\nTo apply a CNOT gate on two qubits, we encode the corresponding column addition as an action. In preconditions, we specify that a CNOT gate can be applied only on different qubits and the qubits must be connected. In effects, for each row, the element in the target column is flipped if the control column element is true. We use"}, {"title": "CNOT synthesis as SAT", "content": "Encoding in classical planning is elegant and easy to understand. However, classical planners are good at finding fast heuristic plans but face scalability issues for computing optimal plans. Since our synthesis problem is encoded as a bounded reachability problem, a SAT encoding for optimal synthesis is promising."}, {"title": "Gate optimal encoding", "content": "For CNOT gate optimality, we apply a standard one-hot reachability encoding. First, we define variables for matrices which represent the state at each time step. We represent the matrix element in row r and column c at time step t as $m_{r,c}^t$. At each time step, we apply a single column addition on some control and target columns. We represent the control column as $ctrl_i^t$ and the target column as $trg_i^t$ at time step t. For a plan length of k, we define k copies of action variables and k+1 copies of state variables.\nS+R synthesis The initial state corresponds to the Identity matrix. We encode it using Exactly-One (EO) constraints on row elements and unit clauses for diagonal elements.\n$\\bigwedge_{r=0}^{n-1} EO(m_{r,0}^0,...,m_{r,n-1}^0) \\wedge \\bigwedge_{q=0}^{n-1} m_{q,q}^0$ (1)\nFor each transition step, exactly one control and target column is chosen (see Equation 2). Given a coupling graph with a set of connected qubit pairs CP, we only allow corresponding column pairs (see Equation 3). For state updates, we encode constraints:\n\u2022 For every row, we update target column matrix variables based on control column matrix variables. If the control variable is:\ntrue, then the target variable is flipped (see Equation 4)\nfalse, then the target variable is propagated (see Equation 5)\n\u2022 All untouched column variables are propagated (see Equation 6).\nFor time steps t \u2208 {0,\u2026\u2026\u2026, k \u2212 1}, we specify:\n$EO(ctrl_0^t,..., ctrl_{n-1}^t) \\wedge EO(trg_0^t,..., trg_{n-1}^t)$ (2)\n$\\bigwedge_{i=0}^{n-1} \\bigwedge_{j=0}^{n-1} ({\u00acctrl_i^t \\lor \u00actrg_j^t \\vert (i, j) \\notin CP})$ (3)\n$\\bigwedge_{(i,j) \\in CP} \\bigwedge_{r=0}^{n-1} (ctrl_i^t \\land trg_j^t \\land m_{r,i}^t) \\Rightarrow (m_{r,j}^{t+1} = \u00acm_{r,j}^t)$ (4)\n$\\bigwedge_{(i,j) \\in CP} \\bigwedge_{r=0}^{n-1} (ctrl_i^t \\land trg_j^t \\land \u00acm_{r,i}^t) \\Rightarrow (m_{r,j}^{t+1} = m_{r,j}^t)$ (5)\n$\\bigwedge_{i=0}^{n-1} \\bigwedge_{r=0}^{n-1} \u00actrg_i^t \\Rightarrow (m_{r,i}^t = m_{r,i}^{t+1})$ (6)\nFor a given circuit C, we encode the goal state with the corresponding final matrix $M_C$. For every 1 in the matrix, we add positive unit clauses in the goal state matrix and negative ones for every 0 (see Equation 7). In synthesis variant S, all different qubit pairs are connected.\n$\\bigwedge_{i=0}^{n-1} \\bigwedge_{j=0}^{n-1} \\bigwedge_{M_C [i,j]=1} m_{i,j}^k \\qquad \\bigwedge_{i=0}^{n-1} \\bigwedge_{j=0}^{n-1} \\bigwedge_{M_C [i,j]=0} \u00acm_{i,j}^k$ (7)\n$W synthesis One can encode column permutation of goal matrix for weak equivalence. However, such a permutation would result in many clauses. Instead, we observe that every circuit with permuted output qubits has an equivalent circuit with permuted input qubits. An input-permuted circuit has swaps at the start instead of the end of the circuit. Removing initial swaps simply relabels CNOT gates and results in the permutation of output qubits. Note that such relabelling does not change the number of CNOTs in the circuit. For example, Table 8 shows an example circuit with initial swaps instead of the end as in Table 5. Identity matrix permutation can be encoded elegantly using exactly-one constraints on the time step 0 state variables. This can be achieved by dropping unit clauses in Equation 1 and adding exactly-one constraints on column variables. Essentially, we replace Equation 1 with Equation 8.\n$\\bigwedge_{r=0}^{n-1} EO(m_{r,0}^0,...,m_{r,n-1}^0) \\wedge \\bigwedge_{c=0}^{n-1} EO(m_{0,c}^0,..., m_{n-1,c}^0)$ (8)"}, {"title": "Depth optimal encoding with parallel plans", "content": "CNOT depth is another important metric in the optimization of quantum circuits. CNOTs acting on different qubits can be applied at the same depth. Depth-based synthesis can be encoded in SAT by allowing parallel CNOTs at each time step. The makespan of such an encoding corresponds to the depth of the synthesized circuit. We only discuss the S+R synthesis variant; the other 3 variants directly follow from the above gate-optimal encoding. Similar to the gate-optimal encoding, we define the same matrix variables to represent the state. Both the initial and goal constraints are exactly the same, i.e., Equations 1 and 7 stay the same. To allow parallel CNOT gates, we define one variable $cnot_{i,j}^t$ for each qubit pair (i, j) at time step t. To respect CNOT restrictions, we disable the CNOT variables on restricted pairs (see Equation 10). We also use target variables $trg_i^t$ as before for propagation of untouched column variables. So propagation constraints as in Equation 6 stay the same for depth optimal encoding, now Equation 16. Note that multiple target columns can be changed due to parallel CNOTs. We handle parallel CNOT operations by specifying (see Equations 11-15):\n\u2022 Atmost-One (AMO) CNOT gate is applied on a qubit.\n\u2022 Atleast-One (ALO) CNOT gate is applied at each time step. Only for efficiency, dropping them would not affect correctness.\n\u2022 Target column $trg_i^t$ is set to true iff some CNOT on (i, j) is true.\n\u2022 For every CNOT variable and every row, we update target column variables based on control column variables:\nif the control variable is true, then the target variable is flipped\nif the control variable is false, the target variable is propagated\nFor time steps t \u2208 {0,..., k \u2212 1}, we specify:\n$\\bigwedge_{i=0}^{n-1} \\bigwedge_{j=0}^{n-1} \\bigwedge_{p=0}^{n-1} \\bigwedge_{q=0}^{n-1} ({m_{i,p}^0 \\land m_{j,q}^0 \\Rightarrow \u00accnot_{i,j}^t \\lor \u00acctrl_i^t \\lor \u00actrg_j^t \\vert (i, j) \\notin CP})$ (9)\n$\\bigwedge_{i=0}^{n-1} \\bigwedge_{j=0}^{n-1} ({\u00accnot_{i,j}^t \\vert (i, j) \\notin CP})$ (10)\n$\\bigwedge_{q=0}^{n-1} AMO({cnot_{i,j}^t \\vert (i = q \\lor j = q \\land (i, j) \\in CP)})$ (11)\n$\\bigwedge_{q=0}^{n-1} ALO({cnot_{i,j}^t \\vert (i, j) \\in CP})$ (12)\n$\\bigwedge_{i} ((\\bigvee_{j=0}^{n-1} cnot_{i,j}^t) = trg_i^t)$ (13)\n$\\bigwedge_{(i,j) \\in CP} \\bigwedge_{r=0}^{n-1} (cnot_{i,j}^t \\land m_{r,i}^t) \\Rightarrow (m_{r,j}^{t+1} = \u00acm_{r,j}^t)$ (14)\n$\\bigwedge_{(i,j) \\in CP} \\bigwedge_{r=0}^{n-1} (cnot_{i,j}^t \\land \u00acm_{r,i}^t) \\Rightarrow (m_{r,j}^{t+1} = m_{r,j}^t)$ (15)\n$\\bigwedge_{i=0}^{n-1} \\bigwedge_{r=0}^{n-1} \u00actrg_i^t \\Rightarrow (m_{r,i}^t = m_{r,i}^{t+1})$ (16)"}, {"title": "CNOT synthesis as QBF", "content": "Even for the simplest synthesis variant S, the SAT encoding uses O($n^2$) variables and O($n^3$) clauses. For moderately large n the encoding sizes can get massive. In CNOT synthesis, the column updates are the same for every row. One can use universal quantification in QBF to capture this structure and generate a compact encoding. While QBF solvers are not as mature as SAT solvers, in some cases well-structured QBF encodings can help. In this section, we focus on the S+R synthesis variant for CNOT count optimization. The other variants (S for CNOT count and S, S+R for CNOT depth) follow directly. We drop W and W+R variants for QBF, as encoding column permutation symbolically is difficult.\nThe action variables, i.e., control and target variables are the same as in the SAT encoding. Instead of defining column matrix variables for each row, we define a symbolic row with universal variables. We use binary encoding for the universal variables, we define R as {$R_0$,..., $R_{[log(n)]-1}$}. For better propagation, we add one-hot encoding for symbolic row variables with existential variables $r_0$,..., $r_{n-1}$. The idea is to set the existential variables based on binary row variables. We can directly use existential row variables for state update constraints similar to our SAT encoding. We only need one set of column matrix variables to represent the complete matrix: $c_i$ represents the ith column variable (for the symbolic row R). We define the prefix of our QBF encoding as follows:\n$\\exists ctrl_0^0,\u2026\u2026,ctrl_{n-1}^{k-1}trg_0^0,\u2026\u2026,trg_{n-1}^{k-1}$ (17)\n$\\forall R  r_0^0,\u2026\u2026,r_{n-1}^{k-1}$ (18)\n$\\exists ctrl_0^k,\u2026\u2026,ctrl_{n-1}^{k-1}trg_0^k,\u2026\u2026,trg_{n-1}^{k-1}$ (19)\n$\\forall R  r_0^k,\u2026\u2026,r_{n-1}^{k-1}$ (20)\n$\\exists c_0,\u2026\u2026,c_{n-1}$ (21)\nFirst, we imply existential row variables from binary-encoded symbolic row variables. Exactly one existential row variable is true.\n$\\bigwedge_{i=0}^{n-1} (bin(R, i) \\Rightarrow r_i) \\land EO(r_0,..., r_{n-1})$ (22)"}, {"title": "Implementation and evaluation", "content": "We are mainly interested in evaluating the following aspects:\n\u2022 The quality improvement due to qubit permutation (W vs S).\n\u2022 The overhead of imposing connectivity restrictions (S+R, W+R).\n\u2022 The performance of the Planning, SAT, and QBF techniques.\nPeephole optimization To allow CNOT optimization in arbitrary circuits, we employ Peephole optimization using a standard slice-and-replace approach. Given a quantum circuit in QASM format, we extract the CNOT slices from the circuit's dependency DAG as follows: We start from the top, such that each slice has one maximal CNOT sub-circuit followed by an arbitrary number of non-CNOT gates. For each CNOT sub-circuit, we optimize its gate count or depth. Finally, we replace each CNOT sub-circuit with its optimal counterpart.\nOnce the slicing is fixed, the order in which slices are treated does not matter for S, S+R, and W variants. Furthermore, the optimal number of CNOTS is fixed for a given slicing. The W+R encoding cannot be used directly in our peephole optimization. Since a permutation in one slice can break CNOT connections in subsequent slices, the order of slice optimization matters. While solving slice-by-slice from top to bottom gives correct results, the final CNOT count might be sub-optimal, even for the given slicing. Hence, we do not apply peephole optimization with the W+R variant in this paper."}, {"title": "Experimental setup", "content": "Our tool Q-Synth v15 and v26 solve layout synthesis using classical planning and SAT solving, respectively. We extended Q-Synth"}, {"title": "Results and discussion", "content": "Table 9 shows the data on Experiment 1. Under \"CNOT optimization\", we report the CNOT count for Planning, SAT, and QBF. Here all three techniques with S synthesis performed similarly. While the CNOT reduction is the same, classical planning had 4 timeout slices whereas SAT and QBF based optimization had 3 timeout slices. Comparing S and W, we observe that SAT with W synthesis results in significantly more reduction (up to 55.8%). Since the T-par tool adds additional CNOT gates to route T gates for optimization [2], permuting qubits can avoid such extra CNOTS. SAT encoding with W optimally solved all slices, thus the reported results are optimal for the given circuit slicing."}, {"title": "Conclusion", "content": "In this paper, we considered optimal CNOT synthesis with two extensions, qubit permutation and layout restrictions. To our knowledge,"}]}