{"title": "Optimal Layout-Aware CNOT Circuit Synthesis with\nQubit Permutation", "authors": ["Irfansha Shaik", "Jaco van de Pol"], "abstract": "CNOT optimization plays a significant role in noise re-\nduction for Quantum Circuits. Several heuristic and exact approaches\nexist for CNOT optimization. In this paper, we investigate more com-\nplicated variations of optimal synthesis by allowing qubit permuta-\ntions and handling layout restrictions. We encode such problems into\nPlanning, SAT, and QBF. We provide optimization for both CNOT\ngate count and circuit depth. For experimental evaluation, we con-\nsider standard T-gate optimized benchmarks and optimize CNOT\nsub-circuits. We show that allowing qubit permutations can further\nreduce up to 56% in CNOT count and 46% in circuit depth. In the\ncase of optimally mapped circuits under layout restrictions, we ob-\nserve a reduction up to 17% CNOT count and 19% CNOT depth.", "sections": [{"title": "Introduction", "content": "Quantum Computing promises speedup in solving computationally\nhard and classically intractable problems. Logical formulations of\nsuch problems are compiled to enable execution on quantum pro-\ncessors. The Quantum compilation pipeline broadly consists of two\nmain stages, Circuit Synthesis and Layout Synthesis. Circuit Synthe-\nsis mainly focuses on the decomposition of abstract circuits to a tar-\nget gate set. Layout Synthesis instead focuses on satisfying hardware\nrestrictions. For instance, not all physical qubits interact with each\nother in some current quantum processors. Thus, quantum gates that\nact on 2 qubits can only be scheduled on adjacent physical qubits.\nIn the current Noisy Intermediate Scale Quantum (NISQ) era, noise\nis inherent to quantum computers. Every execution of a gate can in-\ncrease the error in the computation. For practical quantum comput-\ning, error reduction is of utmost importance. Optimization techniques\nare applied throughout the compilation pipeline. In particular, reduc-\ning gate count and circuit depth can directly impact the error rate.\nWhile an optimal synthesis for the whole compilation pipeline is\nideal, it is an extremely hard problem. For instance, [23] proposes\nSMT-based synthesis under hardware connectivity restrictions and\ntarget gate set. From [23], it is clear that synthesis beyond 4 qubits\nis impractical. Essentially, to optimize a n qubit circuit one needs to\nconsider its 2n \u00d7 2n unitary matrix. The alternative is to optimize\nerror-prone gates like 1-qubit T-gates and 2-qubit CNOT-gates for\nerror reduction. Several approaches are applied for T-gate optimiza-\ntion [2, 1] in tools like T-par\u00b9 and Feynman.2 While such tools reduce\nT-gate count and depth, they can significantly increase CNOT-gate\ncount. As a result, CNOT optimization without changing the T-gate"}, {"title": "Preliminaries", "content": ""}, {"title": "CNOT circuits", "content": "In this paper, we focus on special circuits called CNOT circuits,\nwhich consist solely of 2-qubit CNOT gates (controlled-NOT). A\nCNOT gate takes two inputs, a control qubit with a and a target qubit\nwith b, and outputs a \u2295 b on the target qubit.\nCNOT sub-circuits appear frequently in quantum circuits, since\nCNOT is the only binary gate in many quantum platforms. Optimiz-\ning such sub-circuits directly impacts the overall error. Every n-qubit\nCNOT circuit can be represented by a so-called parity matrix i.e., a"}, {"title": "Classical planning", "content": "Given a description of a world, finding a sequence of actions that\ntransform an initial state to some goal state is Automated Planning.\nIn Classical Planning [14], the actions are deterministic and there ex-\nists a single initial state. Any reachability encoding can be elegantly\nencoded in such a specification. The problem is specified using Do-\nmain and Problem files in the Planning Domain Definition Language\n(PDDL) [13]. A domain file defines the predicates that describe the\nworld and lists schematic actions that can change the world. A prob-\nlem file specifies the objects used, the initial state, and the goal state.\nOne can then use existing State-of-the-art domain-independent plan-\nners to solve problems. Layout Synthesis of Quantum circuits has\nbeen successfully encoded before in classical planning [31]."}, {"title": "Propositional satisfiability", "content": "Given a boolean formula, finding an assignment that makes the for-\nmula true is a propositional satisfiability (SAT) problem. In recent\nyears, many (NP-complete and NP-hard) problems have been suc-\ncessfully encoded and solved using SAT [5, 12]. Several synthesis-\nrelated problems in Quantum Computing have been encoded in\nSAT [29, 25, 21, 32]. Since we are interested in optimal solutions,\nSAT-based solving is a promising technique for proving optimality."}, {"title": "Quantified boolean formulas", "content": "Quantified Boolean Formula (QBF) Logic [4] is an extension of\npropositional logic with universal and existential quantifiers. One can\nencode a propositional formula in a more compact way taking ad-\nvantage of inherent structure. When propositional formulas get too"}, {"title": "Optimal CNOT synthesis", "content": "In this section, we discuss CNOT optimization and its variations with\nsynthesis. We will first establish different notions of equivalence be-\ntween CNOT circuits. Then we discuss layout-aware synthesis, in the\npresence of connectivity restrictions. Finally, we discuss the relevant\ncombinations of synthesis variants for the encodings in this paper. In\nsection 8, we present related work and compare it with our approach."}, {"title": "CNOT circuit equivalence", "content": "For optimal synthesis, we first need to establish equivalence between\nCNOT circuits. In general, two quantum circuits are equivalent if\ntheir unitary matrices are the same. Intuitively, equivalent circuits\nhave the same input-output behavior. Note that equivalent circuits\ncan have different gate counts and circuit depths. The general idea for\noptimization is to compute an equivalent circuit with either a lower\ngate count or circuit depth.\nEvery parity matrix has a corresponding\nunitary matrix. For CNOT circuits, we can directly use the parity ma-\ntrix representation for this equivalence relation. If two CNOT circuits\nhave the same parity matrix, then they are strongly equivalent [3, 23].\nTwo CNOT circuits $C, C'$ are strongly equivalent if\nand only if $M_C = M_{C'}$.\nFor example, consider the CNOT circuit in Table 1 with the final\nmatrix in Table 2. Synthesizing optimal column operations to reach\n$M_C$ is equivalent to synthesizing an optimal circuit $C'$. One can syn-\nthesize the same parity matrix by using only three column additions\non (q1, q0), (q3, q1), and (q1, q3). Thus, the resulting equivalent cir-\ncuit as in Table 3 only has 3 CNOT gates (optimal) as instead of 6."}, {"title": "Restricted CNOT connections (R)", "content": "We also explore layout-aware CNOT optimization. In some quantum\nplatforms, not all qubit pairs are connected thus restricting 2-qubit\ngate execution. One can only apply CNOT gates on adjacent pairs of\nqubits based on some coupling graph. Usually, Circuit Synthesis and\nLayout Synthesis are separated, leading to suboptimal results. For\ninstance, most Layout Synthesis techniques do not take CNOT gate\ncancellation opportunities into account when transpiling.\nWe integrate these phases, by adapting our CNOT synthesis to re-\nspect connectivity constraints. Given a restricted set of CNOT con-\nnections, we only allow column additions that correspond to adjacent\nqubits when synthesizing the final matrix (or a permutation of it). We\nnow obtain the minimal CNOT circuit that satisfies the restrictions.\nSuppose, we want to optimize our example circuit in Table 1, al-\nlowing CNOT gates only on qubit pairs (0, 1), (1, 2), and (2, 3). If\nwe insist on strong equivalence, we need 8 CNOT gates (optimal) as\nshown in Table 6. Note that we need more than the original 6 CNOT\ngates, due to connectivity restrictions. Allowing weak equivalence\nrequires only 5 CNOT gates (optimal) as shown in Table 7."}, {"title": "Metrics and relevant synthesis variants", "content": "We consider three metrics on quantum circuits in this paper, CNOT-\ngate count, depth, and CNOT depth. The CNOT count is simply the\nnumber of CNOT gates in a circuit. The depth of a circuit is the length\nof the longest path in the dependency graph of its gates, connected\nby direct input-output dependencies. The CNOT depth of a circuit is\nthe largest number of CNOT gates on any dependency chain. For in-\nstance, the circuit in Table 6 has CNOT count 8, but its CNOT depth\nis only 7 (since the first two CNOT gates are applied in parallel). For\nCNOT circuits, depth and CNOT depth always coincide.\nFor CNOT and depth optimization, optimal synthesis is a compu-\ntationally hard problem. Variants with CNOT restrictions have been\nproven to be NP-hard for both gate count and depth optimization [19]\nmetrics. In fact, for synthesis with CNOT restrictions, even finding\napproximate solutions is NP-Hard [18]. We encode such hard prob-\nlems in Classical Planning, SAT, and QBF. In particular, we are in-\nterested in 4 synthesis variants:\n\u2022 S: Synthesis with strong equivalence (and no restrictions).\n\u2022 W: Synthesis with weak equivalence (and no restrictions).\n\u2022 S+R: Synthesis with strong equivalence and CNOT restrictions.\n\u2022 W+R: Synthesis with weak equivalence and CNOT restrictions.\nNot all variants can be encoded efficiently in every solving technique.\nFor instance, we found an efficient encoding of the W variant in SAT,\nbut it seems more difficult in classical planning and QBF. So we en-\ncode selected variants for each technique:\n\u2022 Classical Planning: only S and S+R with CNOT gate optimization.\n\u2022 SAT: All 4 variations for both CNOT count and CNOT depth.\n\u2022 QBF: S and S+R for both CNOT count and depth optimization."}, {"title": "CNOT synthesis as planning", "content": "In this section, we first describe the encoding for the S+R variant in\nClassical Planning in PDDL. We encode the synthesis as a reachabil-\nity problem, where nodes of a graph represent the state of the matrix\nand edges represent column additions. Given a circuit, we first com-\npute its parity matrix which corresponds to the goal node. The short-\nest path from the initial node with the Identity matrix to the goal node\ncorresponds to the optimal number of CNOT gates.\nAll our objects, which label rows and columns, are of type qubit.\nWe use the following two predicates to represent the state:\n\u2022 (m ?r ?c - qubit): represents a matrix element with ?r row\nand ?c column parameters.\n\u2022 (connected ?a ?b - qubit): static predicate to repre-\nsent connected qubit parameters ?a and ?b.\nTo apply a CNOT gate on two qubits, we encode the correspond-\ning column addition as an action. In preconditions, we specify that\na CNOT gate can be applied only on different qubits and the qubits\nmust be connected. In effects, for each row, the element in the tar-\nget column is flipped if the control column element is true. We use"}, {"title": "CNOT synthesis as SAT", "content": "Encoding in classical planning is elegant and easy to understand.\nHowever, classical planners are good at finding fast heuristic plans\nbut face scalability issues for computing optimal plans. Since our\nsynthesis problem is encoded as a bounded reachability problem, a\nSAT encoding for optimal synthesis is promising."}, {"title": "Gate optimal encoding", "content": "For CNOT gate optimality, we apply a standard one-hot reachability\nencoding. First, we define variables for matrices which represent the\nstate at each time step. We represent the matrix element in row r and\ncolumn c at time step t as $m^t_{rc}$. At each time step, we apply a single\ncolumn addition on some control and target columns. We represent"}, {"title": "CNOT synthesis as QBF", "content": "Even for the simplest synthesis variant S, the SAT encoding uses\n$O(n^2)$ variables and $O(n^3)$ clauses. For moderately large n the en-\ncoding sizes can get massive. In CNOT synthesis, the column up-\ndates are the same for every row. One can use universal quantification\nin QBF to capture this structure and generate a compact encoding.\nWhile QBF solvers are not as mature as SAT solvers, in some cases\nwell-structured QBF encodings can help. In this section, we focus on\nthe S+R synthesis variant for CNOT count optimization. The other\nvariants (S for CNOT count and S, S+R for CNOT depth) follow di-\nrectly. We drop W and W+R variants for QBF, as encoding column\npermutation symbolically is difficult.\nThe action variables, i.e., control and target variables are the same\nas in the SAT encoding. Instead of defining column matrix vari-\nables for each row, we define a symbolic row with universal vari-\nables. We use binary encoding for the universal variables, we define\n$R$ as {$R_0,..., R_{[log(n)]-1}$}. For better propagation, we add one-\nhot encoding for symbolic row variables with existential variables\n{$r_0,..., r_{n-1}$}. The idea is to set the existential variables based on bi-\nnary row variables. We can directly use existential row variables for\nstate update constraints similar to our SAT encoding. We only need\none set of column matrix variables to represent the complete matrix:\n$c_i$ represents the ith column variable (for the symbolic row R).\nWe define the prefix of our QBF encoding as follows:"}, {"title": "Implementation and evaluation", "content": "We are mainly interested in evaluating the following aspects:\n\u2022 The quality improvement due to qubit permutation (W vs S).\n\u2022 The overhead of imposing connectivity restrictions (S+R, W+R).\n\u2022 The performance of the Planning, SAT, and QBF techniques.\nPeephole optimization To allow CNOT optimization in arbitrary\ncircuits, we employ Peephole optimization using a standard slice-\nand-replace approach. Given a quantum circuit in QASM format,\nwe extract the CNOT slices from the circuit's dependency DAG as\nfollows: We start from the top, such that each slice has one maximal\nCNOT sub-circuit followed by an arbitrary number of non-CNOT\ngates. For each CNOT sub-circuit, we optimize its gate count or\ndepth. Finally, we replace each CNOT sub-circuit with its optimal\ncounterpart.\nOnce the slicing is fixed, the order in which slices are treated does\nnot matter for S, S+R, and W variants. Furthermore, the optimal\nnumber of CNOTS is fixed for a given slicing. The W+R encoding\ncannot be used directly in our peephole optimization. Since a permu-\ntation in one slice can break CNOT connections in subsequent slices,\nthe order of slice optimization matters. While solving slice-by-slice\nfrom top to bottom gives correct results, the final CNOT count might\nbe sub-optimal, even for the given slicing. Hence, we do not apply\npeephole optimization with the W+R variant in this paper."}, {"title": "Experimental setup", "content": "Our tool Q-Synth v15 and v26 solve layout synthesis using classi-\ncal planning and SAT solving, respectively. We extended Q-Synth"}, {"title": "Results and discussion", "content": "Experiment 1 Table 9 shows the data on Experiment 1. Under\n\"CNOT optimization\", we report the CNOT count for Planning, SAT,\nand QBF. Here all three techniques with S synthesis performed sim-\nilarly. While the CNOT reduction is the same, classical planning had\n4 timeout slices whereas SAT and QBF based optimization had 3\ntimeout slices. Comparing S and W, we observe that SAT with W\nsynthesis results in significantly more reduction (up to 55.8%). Since\nthe T-par tool adds additional CNOT gates to route T gates for op-\ntimization [2], permuting qubits can avoid such extra CNOTS. SAT\nencoding with W optimally solved all slices, thus the reported results\nare optimal for the given circuit slicing.\nExperiment 2 To investigate the overhead of connectivity restric-\ntions, we take the W-optimized circuits from Experiment 1. We opti-\nmally map the circuits with Q-Synth v2 [32] onto the 14-qubit plat-\nform IBM Melbourne. Q-Synth v2 maps the circuits by inserting the\noptimal number of swaps. We then apply S+R optimization to the\nresult. Since the input circuits are already optimized with W, any re-\nduction in CNOT count or CNOT depth with S+R is significant.\nBoth W and S+R variants are practical for optimization: most in-\nstances are solved within a minute in our benchmark set. While we\ncannot apply peephole optimization with W+R, we optimized the in-\ndividual slices from experiment 2 with W+R. The W+R encoding\nperforms well. It optimally solves all slices and never takes more\nthan a minute for any slice.\nIn general, fd-ms (CP) is slower than using\nSAT and QBF solvers (Table 11). Overall it results in 5 timeout slices\ncompared to 3 for SAT and QBF. We also noticed that fd-ms uses\nmore memory (up to 6 GB) compared to the other two.\nNote that CP-based solving techniques are orthogonal to SAT and\nQBF. For instance, CP results in maximum CNOT depth reduction in\nExperiment 2 with the instance qft 4. Another advantage of the CP\napproach is being able to use fast heuristic planners. Just using any\nheuristic planner results in heuristic CNOT optimization. For large\ncircuits (with hundreds of qubits), such an approach is more feasible\nthan the SAT and QBF based approaches."}, {"title": "Related work", "content": "CNOT synthesis has been studied before, also in the context of qubit\npermutation and CNOT restrictions. In this section, we discuss some\nCNOT synthesis approaches that are close to our approach.\nSeveral techniques are applied for CNOT\nsynthesis such as Gaussian elimination [3], Steiner trees [20], rewrite\nrules [18], and asymptotically optimal algorithms [24, 20]. Optimal\nCNOT synthesis is mainly considered in a broader context i.e., in the\npresence of either T gates or RZ gates. Here instead of synthesis on\nnxn matrix, synthesis so-called phase polynomial is applied which\nalso keeps track of phase rotation by T gates. Synthesis is applied in\nsome polynomial representation using Steiner trees in [15], as SAT\nin [21], and as Answer Set Programming (ASP) in [27, 26]. Giving\nCNOT circuits without T or RZ gates as inputs for such encodings\nresults in S and S+R variant encodings.\nIn [7], authors proposed heuristic W and\nW+R variants based on the Syndrome Decoding Problem. The same\nauthors proposed greedy algorithms for W in DaCSynth, which we\ncompared with in this paper. Qubit permutations are applied in the\nTKET compiler [34], but only without CNOT restrictions. In all vari-\nations, allowing qubit permutations results in further reduction in"}, {"title": "Conclusion", "content": "In this paper, we considered optimal CNOT synthesis with two exten-\nsions, qubit permutation and layout restrictions. To our knowledge,"}]}