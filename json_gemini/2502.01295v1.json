{"title": "Common Foundations for SHACL, ShEx, and PG-Schema", "authors": ["Shqiponja Ahmetaj", "Iovka Boneva", "Jan Hidders", "Katja Hose", "Maxime Jakubowski", "Jose-Emilio Labra-Gayo", "Wim Martens", "Fabio Mogavero", "Filip Murlak", "Cem Okulmus", "Axel Polleres", "Ognjen Savkovi\u0107", "Mantas \u0160imkus", "Dominik Tomaszuk"], "abstract": "Graphs have emerged as an important foundation for a variety of applications, including capturing and reasoning over factual knowledge, semantic data integration, social networks, and providing factual knowledge for machine learning algorithms. To formalise certain properties of the data and to ensure data quality, there is a need to describe the schema of such graphs. Because of the breadth of applications and availability of different data models, such as RDF and property graphs, both the Semantic Web and the database community have independently developed graph schema languages: SHACL, ShEx, and PG-Schema. Each language has its unique approach to defining constraints and validating graph data, leaving potential users in the dark about their commonalities and differences. In this paper, we provide formal, concise definitions of the core components of each of these schema languages. We employ a uniform framework to facilitate a comprehensive comparison between the languages and identify a common set of functionalities, shedding light on both overlapping and distinctive features of the three languages.", "sections": [{"title": "1 Introduction", "content": "Driven by the unprecedented growth of interconnected data, graph-based data representations have emerged as an expressive and versatile framework for modelling and analysing connections in data sets [47]. This rapid growth however, has led to a proliferation of diverse approaches, each with its own identity and perspective.\nThe two most prominent graph data models are RDF (Resource Description Framework) [14] and Property Graphs [9]. In RDF, data is modelled as a collection of triples, each consisting of a subject, predicate, and object. Such triples naturally represent either edges in a directed labelled graph (where the predicates represent relationships between nodes), or attributes-value pairs of nodes. That is, objects can both be entities or atomic (literal) values. In contrast, Property Graphs model data as nodes and edges, where both can have labels and records attached, allowing for a flexible representation of attributes directly on the entities and relationships.\nSimilarly to the different data models, we are also seeing different approaches towards schema languages for graph-structured data. Traditionally, in the Semantic Web community, schema and constraint languages have been descriptive, focusing on flexibility to accommodate varying structures. However, there has been a growing need for more prescriptive schemas that focus on validation of data. At the same time, in the Database community, schemas have traditionally been prescriptive but, since the rise of semi-structured data, the demand for descriptive schemas has been growing. Thus, the philosophies of schemas in the two communities have been growing closer together.\nFor RDF, there are two main schema languages: SHACL (Shapes Constraint Language) [27], which is also a W3C recommendation, and ShEx (Shape Expressions) [44]. In the realm of Property Graphs, the current main approach is PG-Schema [2, 3]; it was developed with liaisons to the GQL and SQL/PGQ standardization committees and is currently being used as a basis for extending these standards. The development processes of these languages have been quite different. For SHACL and ShEx, the formal semantics were only introduced after their initial implementations, echoing the evolution of programming languages. Indeed, an analysis of SHACL's expressive power and associated decision problems appeared in the literature [6, 7, 34, 39-41] only after it was published as a W3C recommendation, leading up to a fully recursive variant of the language [1, 5, 12, 13, 40], whose semantics had been left undefined in the standard. A similar scenario occurred with ShEx, where formal analyses were only conducted in later phases [8, 50]. PG-Schema developed in the opposite direction. Here, a group of experts from industry and academia first defined the main ideas in a sequence of research papers [2, 3] and the implementation is expected to follow.\nSince these three languages have been developed in different communities, in the course of different processes, it is no surprise that they are quite different. SHACL, ShEx, and PG-Schema use an array of diverse approaches for defining how their components work, ranging from declarative (formulae that specify what to look for) to generative (expressions that generate the matching content), and even combinations thereof. The bottom line is that we are left with three approaches to express a \"schema for graph-structured data\" that are very different at first glance.\nAs a group of authors coming from both the Semantic Web and Database communities, we believe that there is a need for common understanding. While the functionalities of schemas and constraints used in the two communities largely overlap, it is a daunting task to understand the essence of languages, such as SHACL, ShEx, and PG-Schema. In this paper, we therefore aim to shed light on the common aspects and the differences between these three languages. We focus on non-recursive schemas, as neither PG-Schema nor standard SHACL support recursion and also in the academic community the discussion on the semantics of recursive SHACL has not reached consensus yet [1, 5, 12, 13, 38, 40].\nUsing a common framework, we provide crisp definitions of the main aspects of the languages. Since the languages operate on different data models, as a first step we introduce the Common Graph Data Model, a mathematical representation of data that canonically embeds both RDF graphs and Property Graphs (see Section 2, which also develops general common foundations). Precise abstractions of the languages themselves are presented in Sections 3 (SHACL), 4 (ShEx), and 5 (PG-Schema); in the Appendices we explain how and why we sometimes deviate from the original formalisms. Each of these sections contains examples to give readers an immediate intuition about what kinds of conditions each language can express. Then, in Section 6, we present the Common Graph Schema Language (CoGSL), which consists of functionalities shared by them all.\nCasting all three languages in a common framework has the immediate advantage that the reader can identify common functionalities based on the syntax only: on the one hand, we aim at giving the same semantics to schema language components that syntactically look the same, and on the other hand, we can provide examples of properties that distinguish the three languages using simple syntactic constructs that are not part of the common core. Aside from corner cases, properties expressed using constructs outside the common core are generally not expressible in all three languages. By providing an understanding of fundamental differences and similarities between the three schema languages, we hope to benefit both practitioners in choosing a schema language fitting their needs, and researchers in studying the complexity and expressiveness of schema languages."}, {"title": "2 Foundations", "content": "In this section we present some material that we will need in the subsequent sections, and define a data model that consists of common aspects of RDF and Property Graphs."}, {"title": "2.1 A Common Data Model", "content": "When developing a common framework for SHACL, ShEx, and PG-Schema, the first challenge is establishing a common data model, since SHACL and ShEx work on RDF, whereas PG-Schema works on Property Graphs. Rather than using a model that generalises both RDF and Property Graphs, we propose a simple model, called common graphs, which we obtained by asking what, fundamentally, are the common aspects of RDF and Property Graphs (Appendix A gives more details on the distilling of common graphs).\nLet us assume disjoint countable sets of nodes \\(N\\), values \\(V\\), predicates \\(P\\), and keys \\(K\\) (sometimes called properties).\nDEFINITION 1. A common graph is a pair \\(G = (E, \\rho)\\) where\n*   \\(E \\subseteq_{fin} N \\times P \\times N\\) is its set of edges (which carry predicates), and\n*   \\(\\rho: N \\times K \\rightarrow V\\) is a finite-domain partial function mapping node-key pairs to values.\nThe set of nodes of a common graph \\(G\\), written \\(Nodes(G)\\), consists of all elements of \\(N\\) that occur in \\(E\\) or in the domain of \\(\\rho\\). Similarly, \\(Keys(G)\\) is the subset of \\(K\\) that is used in \\(\\rho\\), and \\(Values(G)\\) is the subset of \\(V\\) that is used in \\(\\rho\\) (that is, the range of \\(\\rho\\)).\nExample 1. Consider Figure 1, containing a graph to store information about users who may have access to (possibly multiple) accounts in, e.g., a media streaming service. In this example, we have six nodes describing four persons (\\(u_1, ..., u_4\\)) and two accounts (\\(a_1, a_2\\)). As a common graph \\(G = (E, \\rho)\\), the nodes are \\(a_1, u_1\\), etc. Examples of edges in \\(E\\) are \\((u_2, hasAcccess, a_1)\\) and \\((u_3, invited, u_2)\\). Furthermore, we have \\(\\rho(u_2, email) = d@d.d\\) and \\(\\rho(a_1, card) = 1234\\).\nSo, \\(E\\) captures the arrows in the figure (labelled with predicates) and \\(\\rho\\) captures the key/value information for each node. Notice that a person may be the owner of an account, and may potentially have access to other accounts. This is captured using the predicates \\(ownsAccount\\) and \\(hasAcccess\\), respectively. In addition, the system implements an invitation functionality, where users may invite other people to join the platform. The previous invitations are recorded using the predicate invited. Both accounts and users may be privileged, which is stored via a Boolean value of the key privileged. We note that the presence of the key email (resp., of the key (credit) card) is associated with, and indeed identifies users (resp., accounts).\nIt is easy to see that every common graph is a property graph (as per the formal definition of property graphs [2]). A common graph can also be seen as a set of triples, as in RDF. Let\n\\[\\mathcal{E} = (N \\times P \\times N) \\cup (N \\times K \\times V).\\]\nThen, a common graph can be seen as a finite set \\(G \\subseteq \\mathcal{E}\\) such that for each \\(u \\in N\\) and \\(k \\in K\\) there is at most one \\(v \\in V\\) such that \\((u, k, v) \\in G\\). Indeed, a common graph \\((E, \\rho)\\) corresponds to\n\\[E \\cup \\{(u,k,v) \\mid \\rho(u, k) = v\\}.\\]\nWhen we write \\(\\rho(u, k) = v\\) we assume that \\(\\rho\\) is defined on \\((u, k)\\).\nThroughout the paper we see property graph \\(G\\) simultaneously as a pair \\((E, \\rho)\\) and as a set of triples from \\(\\mathcal{E}\\), switching between these perspectives depending on what is most convenient at a given moment."}, {"title": "2.2 Node Contents and Neighbourhoods", "content": "Let \\(R\\) be the set of all records, i.e., finite-domain partial functions \\(r: K \\rightarrow V\\). We write records as sets of pairs \\(\\{(k_1, w_1),... (k_n, w_n)\\} \\) where \\(k_1,..., k_n\\) are all different, meaning that \\(k_i\\) is mapped to \\(w_i\\).\nFor a common graph \\(G = (E, \\rho)\\) and node \\(v\\) in \\(G\\), by a slight abuse of notation we write \\(\\rho(v)\\) for the record \\(\\{(k, w) \\mid \\rho(v, k) = w\\}\\) that collects all key-value pairs associated with node \\(v\\) in \\(G\\). We call \\(\\rho(v)\\) the content of node \\(v\\) in \\(G\\). This is how PG-Schema interprets common graphs: it views key-value pairs in \\(\\rho(v)\\) as properties of the node \\(v\\), rather than independent, navigable objects in the graph. SHACL and ShEx, on the other hand, view common graphs as sets of triples and make little distinction between keys and predicates.\nThe following notion-when applied to a node-uniformly captures the local context of this node from that perspective: the content of the node and all edges incident with the node.\nDEFINITION 2 (NEIGHBOURHOOD). Given a common graph \\(G\\) and a node or value \\(v \\in N \\cup V\\), the neighbourhood of \\(v\\) in \\(G\\) is \\(Neigh_G(v) = \\{(u_1, p, u_2) \\in G \\mid u_1 = v \\text{ or } u_2 = v\\}\\).\nWhen \\(v \\in N\\), then \\(Neigh_G(v)\\) is a star-shaped graph where only the central node has non-empty content. When \\(v \\in V\\), then \\(Neigh_G(v)\\) consists of all the nodes in \\(G\\) that have some key with value \\(v\\), which is a common graph with no edges and a restricted function \\(\\rho\\)."}, {"title": "2.3 Value Types", "content": "We assume an enumerable set of value types \\(T\\). The reader should think of value types as integer, boolean, date, etc. Formally, for each value type \\(\\nu \\in T\\), we assume that there is a set \\([\\nu] \\subseteq V\\) of all values of that type and that each value \\(v \\in V\\) belongs to some type, i.e., there is at least one \\(\\nu \\in T\\) such that \\(v \\in [\\nu]\\). Finally, we assume that there is a type \\(any \\in T\\) such that \\([any] = V\\)."}, {"title": "2.4 Shapes and Schemas", "content": "We formulate all three schema languages using shapes, which are unary formulas describing the graph's structure around a focus node or a value. Shapes will be expressed in different formalisms, specific to the schema language; for each of these formalisms we will define when a focus node or value \\(v \\in N \\cup V\\) satisfies shape \\(\\varphi\\) in a common graph \\(G\\), written \\(G, v \\models \\varphi\\).\nInspired by ShEx shape maps, we abstract a schema \\(S\\) as a set of pairs \\((\\textit{sel}, \\varphi)\\), where \\(\\varphi\\) is a shape and \\(\\textit{sel}\\) is a selector. A selector is also a shape, but usually a very simple one, typically checking the presence of an incident edge with a given predicate, or a property with a given key. A graph \\(G\\) is valid w.r.t. \\(S\\), in symbols \\(G \\models S\\), if\n\\[\\text{G,v} \\models \\textit{sel} \\implies \\text{G,v} \\models \\varphi,\\]\nfor all \\(v \\in N \\cup V\\) and \\((\\textit{sel}, \\varphi) \\in S\\). That is, for each focus node or value satisfying the selector, the graph around it looks as specified by the shape. We call schemas \\(S\\) and \\(S'\\) equivalent if \\(G \\models S\\) iff \\(G \\models S'\\), for all \\(G\\). In what follows, we may use \\(\\textit{sel} \\Rightarrow \\varphi\\) to indicate a pair \\((\\textit{sel}, \\varphi)\\) from a schema \\(S\\).\nExample 2. We next describe some constraints one may want to express in the domain of Example 1.\n(C1) We may want the values associated to certain keys to belong to concrete datatypes, like strings or Boolean values. In our example, we want to state that the value of the key card is always an integer.\n(C2) We may expect the existence of a value associated to a key, an outgoing edge, or even a complex path for a given source node. For our example, we require that all owners of an account have an email address defined.\n(C3) We may want to express database-like uniqueness constraints. For instance, we may wish to ensure that the email address of an account owner uniquely identifies them.\n(C4) We may want to ensure that all paths of a certain kind end in nodes with some desired properties. For example, if an account is privileged, then all users that have access to it should also be privileged.\n(C5) We may want to put an upper bound on the number of nodes reached from a given node by certain paths. For instance, every user may have access to at most 5 accounts."}, {"title": "3 SHACL on common graphs", "content": "We first treat SHACL, because it is conceptually the simplest of the three languages. It is essentially a logic-some call it a description logic in disguise [6]. Our abstraction is inspired by [24]. We focus on the standard, non-recursive SHACL, leaving recursive extensions [1, 5, 13, 38, 40] for the future. Some features of SHACL are incompatible with common graphs, and are therefore omitted (see Appendix B).\nDEFINITION 3 (PATH EXPRESSION). A path expression is given by the following grammar:\n\\[\\pi ::= id \\mid q \\mid \\overline{\\pi} \\mid \\pi \\cdot \\pi \\mid \\pi \\cup \\pi \\mid \\pi^* .\\]\nwith \\(q \\in P \\cup K\\) and \\(id\\) the identity relation (or empty word).\nDEFINITION 4 (SHACL SHAPE). A SHACL shape \\(\\varphi\\) is given by the following grammar:\n\\documentclass{article}\n\\usepackage{amsmath}\n\\[\\varphi::= \\top \\mid \\text{test}(c) \\mid \\text{test}(v) \\mid \\text{closed}(Q) \\mid \\text{eq}(\\pi, p) \\mid\\nonumber\\]\n\\[\\text{disj}(\\pi,p) \\mid \\neg\\varphi \\mid \\varphi \\land \\varphi \\mid \\varphi \\lor \\varphi \\mid \\exists^{\\geq n} \\pi.\\varphi \\mid \\exists^{\\leq n} \\pi.\\varphi.\\]\nwith \\(c \\in V, v \\in T, Q \\subseteq_{fin} P \\cup K, p \\in P\\), and \\(n\\) a natural number. We may use \\(\\exists \\pi. \\varphi\\) as syntactic sugar for \\(\\exists^{\\geq 1} \\pi. \\varphi\\).\nDEFINITION 5 (SHACL SELECTOR). A SHACL selector sel is a SHACL shape of a restricted form, given by the following grammar:\n\\[\\text{sel} ::= \\exists q.\\top \\mid \\exists \\overline{q}.\\top \\mid \\text{test}(c) .\\]\nwith \\(q \\in P \\cup K\\), and \\(c \\in V\\).\nPutting it together, a SHACL Schema \\(S\\) is a finite set of pairs \\((\\textit{sel}, \\varphi)\\), where sel is a SHACL selector and \\(\\varphi\\) is a SHACL shape.\nTo define the semantics of SHACL schemas, we first define in Table 1 the semantics of a SHACL path expression on a graph \\(G\\) as a binary relation \\([\\pi]_G\\) over \\(N \\cup V\\). The semantics of SHACL shapes is defined in Table 2, which specifies when a node or value \\(v\\) satisfies a SHACL shape \\(\\varphi\\) w.r.t. a \\(G\\), written \\(G, v \\models \\varphi\\). Note that both \\([\\pi]_G\\) and \\(\\{v \\in N \\cup V \\mid G, v \\models \\varphi\\}\\) may be infinite: for example, \\([id]_G\\) is the identity relation over the infinite set \\(N \\cup V\\).\nThe semantics of SHACL schemas then follows Section 2.4. Importantly, SHACL selectors always select a finite subset of \\(N \\cup V\\): the selected nodes or values come either from the selector itself, in the case of \\(\\text{test}(c)\\), or from \\(G\\), in the remaining four cases. For example, \\(\\exists p.\\top\\) selects those nodes of \\(G\\) that have an outgoing \\(p\\)-edge in \\(G\\)-it is grounded to \\(G\\) in the second line of Table 1. In consequence, each pair \\((\\textit{sel}, \\varphi)\\) in a SHACL schema tests the inclusion of a finite set of nodes or values in a possibly infinite set.\nExample 3. For better readability we write \\(\\exists \\pi\\) instead of \\(\\exists^{\\geq 1} \\pi. \\top\\) (that is, we omit \\(\\top\\)) and \\(\\forall \\pi. \\varphi\\) instead of \\(\\exists^{\\leq 0} \\pi. \\neg\\varphi\\). Let us see how the constraints from Example 2 can be handled in SHACL. For (C1), we assume the value type int with the obvious meaning. The following SHACL constraints express the constraints (C1-C5):\n```latex\n\\begin{aligned}\n&\\text{card} \\Rightarrow \\text{test(int)} \\tag{C1} \\\\\n&\\exists \\text{ownsAccount} \\Rightarrow \\exists \\text{email} \\tag{C2} \\\\\n&\\exists \\text{email} \\Rightarrow \\exists^{\\leq 1} \\text{email} \\tag{C3} \\\\\n&(\\exists \\text{card} \\Rightarrow (\\overline{\\text{privileged}}.\\text{test(true)})) \\\\&\t\\lor (\\forall \\text{hasAcccess}. (\\exists \\overline{\\text{privileged}}.\\text{test(true)})) \\tag{C4} \\\\\n&\\exists \\text{email} \\Rightarrow \\exists^{\\leq 5} \\text{hasAcccess}. \\tag{C5}\n\\end{aligned}\n```\nConcerning constraint (C3), notice that by using inverse email edges, the constraint indeed states that the email addresses uniquely identify users.\nThe constructs \\(\\text{eq}(\\pi, p)\\) and \\(\\text{disj}(\\pi, p)\\) are unique to SHACL. Let us see them in use.\nExample 4. Using \\(\\text{eq}(\\pi,p)\\), we can say, for instance, that an owner of an account also has access to it:\n\\[\\exists \\text{ownsAccount} \\Rightarrow \\text{eq}(\\text{hasAcccess} \\cup \\text{ownsAccount}, \\text{hasAcccess}).\\]\nNote how we use \\(\\text{eq}\\) and \\(\\cup\\) to express that the existence of one path (ownsAccount) implies the existence of another path (hasAcccess) with the same endpoints.\nA key feature in SHACL that is not available in ShEx is the ability to use regular expressions to talk about complex paths. This provides a limited, still non-trivial, form of recursive navigation in the graph, even though the standard SHACL does not support recursive constraints (in contrast to standard ShEx).\nExample 5. Suppose that in Figure 1, we impose that for every node with a privileged key, either its value is false or, along inverse invited edges there is a unique, privileged \u201cancestor\", which has no further inverse invited edges. This is expressible as follows:\n```latex\n\\begin{aligned}\n&\\exists \\text{privileged} \\Rightarrow \\text{privileged}.\\text{ test (false)} \\\\\n&\\lor (\\exists^{\\leq 1} \\text{invited}^*.( \\exists \\text{privileged}. \\text{test(true)} \\land \\exists^{\\leq 0} \\text{invited}^*)) .\n\\end{aligned}\n```"}, {"title": "4 ShEx on common graphs", "content": "While SHACL is conceptually the simplest of the three languages, ShEx lies at the opposite end of the spectrum. It is an intricate,\nnested combination of a simple logic for shapes and a powerful formalism (triple expressions) for generating the allowed neighbourhoods. In this work we focus on non-recursive ShEx, where shapes and triple expressions can be nested multiple times, but cannot be recursive. This allows us to simplify the abstraction without compromising our primary goal of understanding the common features, as neither PG-Schema nor standard SHACL support such a general recursion mechanism. The abstraction of ShEx over common graphs is based on the treatment of ShEx on RDF triples [8]. Deviations from standard ShEx are discussed in Appendix C.\nDEFINITION 6 (SHAPES AND TRIPLE EXPRESSIONS). ShEx shapes \\(\\varphi\\) and closed triple expressions \\(e\\) are defined by the grammar\n```latex\n\\begin{aligned}\n&\\varphi::= \\text{test}(c) \\mid \\text{test}(v) \\mid \\{e ; op_-\\} \\mid \\{e ; op_+\\} \\mid \\varphi \\land \\varphi \\mid \\varphi \\lor \\varphi \\mid \\neg\\varphi. \\\\\n&e ::= \\varepsilon \\mid q.\\varphi \\mid \\overline{q}.\\varphi \\mid e;e \\mid e \\vert e \\mid e^* . \\\\\n&op_- := (\\overline{R})^* . \\\\\n&op_+ := (\\overline{R})^*;(\\neg Q)^* .\n\\end{aligned}\n```\nwhere \\(c \\in V, v \\in T, q \\in P \\cup K\\), and \\(R, Q \\subseteq_{fin} P \\cup K\\). We refer to expressions derived from \\(e; op_-\\) and \\(e ; op_+\\) as half-open and open triple expressions, respectively.\nThe notion of satisfaction for ShEx shapes and the semantics of triple expressions are defined by mutual recursion in Table 3 and Table 4. Triple expressions are used to specify neighbourhoods of nodes and values. They require to consider incoming and outgoing edges separately. For this purpose we decorate incoming edges with \\(\\overline{}\\). Formally, we introduce a fresh predicate \\(\\overline{p}\\) for each \\(p \\in P\\) and a fresh key \\(\\overline{k}\\) for each \\(k \\in K\\). We let \\(\\overline{P} = \\{\\overline{p} \\mid p \\in P\\}\\), \\(\\overline{K} = \\{\\overline{k} \\mid k \\in K\\}\\), \\(\\overline{\\mathcal{E}} = N \\times \\overline{P} \\times N \\cup V \\times \\overline{K} \\times N\\), and define \\(Neigh_h^{\\flat}(v) \\subseteq \\mathcal{E} \\cup \\overline{\\mathcal{E}}\\) as\n\\[\\{(v, p, v') \\mid (v, p, v') \\in G\\} \\cup \\{(v, \\overline{p}, v') \\mid (v', p, v) \\in G\\} .\\]\nCompared to \\(Neigh_G(v)\\), apart from flipping the incoming edges and marking them with \\(\\overline{}\\), we also represent each loop \\((v, p, v)\\) twice: once as an outgoing edge \\((v, p, v)\\) and once as an incoming edge \\((v, \\overline{p}, v)\\). In Table 4, we treat \\(\\neg Q\\) and \\(\\neg \\overline{R}\\) as triple expressions. So, the rule for \\(e^*\\) gives semantics to \\((\\neg Q)^*\\) and \\((\\neg \\overline{R})^*\\), and the rule for \\(e_1; e_2\\) gives semantics to open and half-open triple expressions. In Table 3, \\(f\\) is an open or half-open triple expression.\nClosed triple expressions \\(e\\) define neighbourhoods that use only a finite number of predicates and keys (also called closed in ShEx terminology) and cannot be directly used in shape expressions. Half-open triple expressions \\(e;(\\neg \\overline{R})^*\\) allow any incoming triples whose predicate or key is not in \\(R\\). Open triple expressions \\(e;(\\neg \\overline{R})^*;(\\neg Q)^*\\) additionally allow any outgoing triples whose predicate or key is not in \\(Q\\). Let \\(T = \\varepsilon;(\\neg \\emptyset)^* ; (\\neg \\emptyset)^*\\). Then \\(T\\) describes all possible neighbourhoods, and \\(\\{T\\}\\) is satisfied in every node and in every value of every graph.\nExample 6. The ShEx shape \\(\\{p.\\varphi_1; p.\\varphi_2; T\\}\\) specifies nodes with at least two different \\(p\\)-successors, one satisfying \\(\\varphi_1\\) and one satisfying \\(\\varphi_2\\). Note that this is different from SHACL shape \\(\\exists p.\\varphi_1 \\land \\exists p.\\varphi_2\\) which says that the node has a \\(p\\)-successor satisfying \\(\\varphi_1\\) and a \\(p\\)-successor satisfying \\(\\varphi_2\\), but they might not be different."}, {"title": "5 Shape-based PG-Schema", "content": "Shape-based PG-Schema is a non-recursive combination of a logic and two generative formalisms. It uses path expressions to specify paths (as in SHACL), and content types to specify node contents. Both path expressions and content types are then used in formulas defining shapes. Content types in PG-Schema play a role similar to triple expressions in ShEx, but they are only used for properties. Because all properties of a node must have different keys, they are much simpler than triple expressions (in fact, they can be translated into a fragment of SHACL). Unlike for SHACL and ShEx, the abstraction of shape-based PG-Schema departs significantly from the original design. Original PG-Schema uses queries written in an external query language, which is left unspecified aside from some basic assumptions about the expressive power. Here we use a specific query language (PG-path expressions). Importantly, up to the choice of the query language, the abstraction we present here faithfully captures the expressive power of the original PG-Schema. A detailed comparison can be found in Appendix D.\nDEFINITION 8 (CONTENT TYPE). A content type is an expression \\(c\\) of the form defined by the grammar\n\\[c = \\top \\mid \\{\\} \\mid \\{k:v\\} \\mid c \\& c \\mid c \\vert c.\\]\nwhere \\(k \\in K\\) and \\(v \\in T\\).\nRecall that \\(R\\) is the set of all records (finite-domain partial functions \\(r : K \\rightarrow V\\)). We write \\(r \\emptyset\\) for the empty record. The semantics of content types is defined in Table 5. Note that \\([c]\\) is independent from \\(G\\) and can be infinite.\nExample 11. We assume integers and strings are represented via int, str \\(\\in T\\). Suppose we want to create a content type for nodes that have a string value for the email key and optionally have an integer value for the card key. No other key-value pairs are allowed. We should then use \\(\\{\\text{ email: str}\\} \\& (\\{\\text{card: imt}\\} \\vert \\{\\})\\).\nDEFINITION 9 (PG-PATH EXPRESSIONS). A PG-path expression is an expression \\(\\pi\\) of the form defined by the grammar\n```latex\n\\begin{aligned}\n&\\pi::= \\tilde{\\pi} \\mid \\tilde{\\pi} \\cdot k \\mid \\overline{k}\\cdot\\tilde{\\pi} \\mid \\overline{k}\\cdot\\tilde{\\pi} \\cdot k'. \\\\\n&\\tilde{\\pi} ::= [k = c] \\mid \\neg[k = c] \\mid c \\mid \\neg c \\mid p \\mid \\neg P \\mid \\overline{\\tilde{\\pi}} \\mid \\tilde{\\pi}\\cdot \\tilde{\\pi} \\mid \\tilde{\\pi} \\cup \\tilde{\\pi} \\mid \\tilde{\\pi}^*.\n\\end{aligned}\n```\nwhere \\(k, k' \\in K\\), \\(c \\in V\\), \\(c\\) is a content type, \\(p \\in P\\), and \\(P \\subseteq_{fin} P\\). We use \\(\\text{k}, \\overline{k}\\), and \\(\\overline{k} k'\\) as short-hands for PG-path expressions \\(T \\cdot k\\), \\(\\overline{k} \\cdot T\\), and \\(\\overline{k} \\cdot T \\cdot k'\\), respectively.\nUnlike in SHACL, PG-path expressions cannot navigate freely through values. In the property graph world, this would correspond"}, {"title": "6 Common Graph Schema Language", "content": "We now present the Common Graph Schema Language (CoGSL)", "counting": "while SHACL and PG-Schema count nodes and values", "edges": "both must be closed at the same time.\nFinally", "grammar\n```latex\n\\begin{aligned}\n&\\varphi": "exists \\pi \\mid \\exists^{\\leq n"}, "pi_1 \\mid \\exists^{\\geq n}\\pi_1\\mid\\exists \\text{c} \\wedge \\neg\\overline{P}\\mid\\varphi \\land \\varphi. \\\\\n&c:= \\{\\} \\mid \\{k:v\\} \\mid c \\&c \\mid c \\vert c. \\\\\n&\\pi_0 ::= [k = c"]}