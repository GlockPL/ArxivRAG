{"title": "Process Trace Querying using Knowledge Graphs and Notation3", "authors": ["William Van Woensel"], "abstract": "In process mining, a log exploration step allows making sense\nof the event traces; e.g., identifying event patterns and illogical traces,\nand gaining insight into their variability. To support expressive log ex-\nploration, the event log can be converted into a Knowledge Graph (KG),\nwhich can then be queried using general-purpose languages. We explore\nthe creation of semantic KG using the Resource Description Framework\n(RDF) as a data model, combined with the general-purpose Notation3\n(N3) rule language for querying. We show how typical trace querying\nconstraints, inspired by the state of the art, can be implemented in N3.\nWe convert case- and object-centric event logs into a trace-based seman-\ntic KG; OCEL2 logs are hereby \"flattened\" into traces based on object\npaths through the KG. This solution offers (a) expressivity, as queries\ncan instantiate constraints in multiple ways and arbitrarily constrain at-\ntributes and relations (e.g., actors, resources); (b) flexibility, as OCEL2\nevent logs can be serialized as traces in arbitrary ways based on the KG;\nand (c) extensibility, as others can extend our library by leveraging the\nsame implementation patterns.", "sections": [{"title": "1 Introduction", "content": "In practice, process mining typically includes an intermediate exploration step\nbetween event log pre-processing and the actual process discovery, which aims\nto properly understand the event traces. For instance, in a healthcare-related\nmethodology for process diagnostics [14], it is part of log inspection; in the PM2\nmethodology, it is part of data processing [7]. This step may point out unex-\npected event patterns, which allow for more pointed questions to the process\nowner (e.g., on activity meanings); identify illogical traces that occur due to\npoor data quality; or help to gain insight into the variability of the event log,\ne.g., for separating them into distinct subsets for mining. Importantly, by better\nunderstanding the event log, one may avoid so-called spaghetti models [16] that\noften result from the blind application of process discovery on event logs.\nProcess mining tools can be used for this step, which typically offer some\ngraphical log exploration support (such as a variant explorer or variant querying"}, {"title": "2 Preliminaries", "content": ""}, {"title": "2.1 Case- and Object-Centric Event Logs", "content": "Case-Centric Event Logs (CCEL). A \"traditional\" CCEL [16], which is typ-\nically serialized using the Extensible Event Stream (XES) format [9], is defined\nas a tuple $L = (E, #, <)$, where the set of events $E \\subseteq U_{ev}$ (universe of events);\nmapping $\\# \\in E \\rightarrow U_{map}$ (universe of functions $U_{att} \\rightarrow U_{val}$), which is used\nto assign values to event attributes; and a total ordering $\u4eba\\subseteq E \\times E$ of events\nbased on their timestamps, where $e_k \u4eba e_l$ iff $\\#(e_k)(time) < #(e_r)(time)$.\nA trace groups all events that share the same chosen \"case\" (e.g., purchase,\nvisit), sorted ascending on their timestamp. We define a trace [16] as $\\sigma =<$"}, {"title": "2.2 Resource Description Framework (RDF) and Notation3 (N3)", "content": "RDF [5], the building block of the Semantic Web, describes information as\ntriples with subject, predicate and object terms. This gives rise to a graph struc-\nture, with subjects and objects as nodes and predicates as edges. Terms include\nURIs, which identify resources (entities); blank nodes, for resources lacking an\nidentifier; and literals (e.g., numbers, strings). An example RDF snippet:\nURIs are shown as qualified names (e.g., tr:activity) that include a namespace\n(tr) and localname (activity). Namespace definitions for tr and p2p are not\nshown for brevity. Semicolons \";\" can be used to group triples with the same\nsubject (e.g., p2p:event1). Blank nodes are shown as _:b<nr>.\nN3 [18] is a rule language for reasoning over and querying RDF. N3 rules are\nexpressed using triples with variables (e.g., \"?x\"), lists written using \"()\", and\ngraph terms using \"{}\" to group triples as rule heads and bodies. E.g., this rule\nwill infer that it is cloudy, since we assert that it is raining:\nRules can be either forward-chaining (using =>), meaning that inferences are\ndirectly materialized in the KG; or backward-chaining (using <=), meaning that\nthey can help to resolve queries or other rules (cfr. logic programming)."}, {"title": "3 Converting Event Logs into ELKG", "content": ""}, {"title": "3.1 Case-Centric Event Logs (CCEL)", "content": "We represent a CCEL as an RDF-based ELKG with the following sets of triples.\nWe write $(s, p, o)$ to represent an RDF triple. For a log entity such as a trace $\\sigma$,\nwe write $\\sigma_t$ for the corresponding RDF term. This term may be a URI, blank\nnode, or literal, depending on the entity."}, {"title": "3.2 Object-Centric Event Logs (OCEL2)", "content": "We represent an OCEL2 as an RDF-based ELKG with the following triples\n(focusing on the elements from Section 2.1), using the same notation as before:"}, {"title": "4 Querying Process Traces", "content": ""}, {"title": "4.1 Types of trace constraints", "content": "Taking inspiration from other trace querying languages [15], and languages for\nquerying process model repositories [13], we identified an initial set of trace con-\nstraints. We provide a summary of their semantics below in terms of matching\ntraces. We loosely group the constraints into two categories, namely activity\noccurrence, i.e., on the (non)-occurrence of activities in traces; and sequential\nrelations, i.e., on the temporal ordering between traces' events. For the activi-\ntyOccurs constraints, we also show its set-based (a-b) and cardinality-based (c)\nversions. Note that we use $e_a$ to represent an event $e$ with activity $a$.\nActivity Occurrence."}, {"title": "4.2 Implementing trace constraints in N3", "content": "We implemented the constraints from Section 4.1 in the N3 rule language. Trace\nqueries (Section 4.3) can refer to these rules to find particular traces. We note\nthat these implementation patterns, which may apply to other rule languages as\nwell, can be used to implement other constraints not yet considered here.\nActivity Occurrence. Below, we show the N3 rule for activityOccurs:"}, {"title": "4.3 Querying Entities using Rules and Other Constraints", "content": "Queries for finding traces, activities, or events from the event log can utilize\nthe backward-chaining rules from the prior section. E.g., this forward-chaining\nrule (\u2192), acting as a query, returns all traces where purchase requisitions were\ncreated but not approved (i.e., with activity \"Create Purchase Requisition\" but\nwithout \"Approve Purchase Requisition\"; a.k.a. \"maverick buying\"):\nN3, as a general-purpose rule language, offers the expressivity to instantiate\nconstraints in multiple ways. Here, by using the same variable ?t as subject,\nthe query will only return traces adhering to both constraints. For instance,\nthese identified traces, with events covering PR creation to final payment, can\nbe investigated to find the reasons and/or effects (e.g., duration, final cost) of\nmaverick buying. E.g., another example query (see online repo [17]) leverages\nthe total duration of extracted traces in ELKG, i.e., from PR to payment.\nA more comprehensive example for the sepsis use case, which leverages se-"}, {"title": "5 Preliminary Performance Evaluation", "content": "We conducted a preliminary performance evaluation on the well-known CCEL\nsepsis event log [11] with 1050 process traces; and the OCEL2 P2P simulated\ndataset with 14671 events, 10 event types, 9543 objects and 7 object types [12].\nExperiments were performed on a Macbook Pro with an Apple M1 Pro chip and\n32Gb memory. Performance results were obtained over an average of 5 runs. We\nused Python v.3.11.5 with pandas v.2.0.3, rdflib v.7.0.0, pm4py v.2.7.11.12, and\nthe eye [6] N3 reasoner v10.17.3 for executing N3 rules.\nConverting Event Logs into ELKG. Converting the sepsis CCEL into RDF\ntook around 3,9s on average. Converting the P2P OCEL2 into RDF took around\n10,5s on average. Extracting perspective-based traces led to an ELKGOCEL2 with\n927 traces; this step is currently not optimized and took around 2,7min.\nQuerying Process Traces. We executed a set of queries, each of which encap-\nsulating a single trace constraint, on the sepsis event log. Loading the ELKG\ninto the N3 reasoner took around 410ms on average; executing each query took\naround 42ms on average. The sepsis query with multiple constraints, shown in\nListing 1.9, took around 120ms on average.\nFor the P2P event log, we formulated a number of queries to identify \"special\nbehaviors\" as mentioned by the dataset authors [12], i.e., maverick buying (List-\ning 1.8), duplicate payments, and lengthy (approval) processes. Here, loading\nthe ELKGOCEL2 into the N3 reasoner took around 1240ms on average; execut-\ning each query took around 90ms on average.\nWe refer to our online repo [17] for all queries and results. We also provide a\nJupyter notebook for manually testing the conversion steps and queries."}, {"title": "6 Related Work", "content": "Most approaches for querying process traces [15,2,19] and process model reposi-\ntories [13,1] propose a separate domain-specific language [15,19,13,1]; while this\nmakes queries more concise and likely more performant, it comes at the cost of"}, {"title": "7 Conclusions and Future Work", "content": "This paper showed how different types of event logs, i.e., CCEL and OCEL2, can\nbe converted into a semantic trace-based ELKG. To obtain meaningful traces\nfrom an OCEL2, we can \"flatten\" the log based on an arbitrary perspective,\ndefined in terms of an object path through the ELKG. Within an ELKG, we\nshowed how occurrence and sequential relation constraints can be implemented\nin N3 in an expressive and extensible way. Regarding performance, converting\nthe logs into ELKG takes less than 10-11s, and is a one-time effort; however,\nextracting traces from ELKGOCEL2 is relatively slow, around 3 min for the P2P\nlog. For querying traces, while loading an ELKG into eye is a non-trivial task\n(around 400-1300ms), executing queries is more performative (under 125ms).\nThere remain many avenues for future work. We aim to optimize the extrac-\ntion of traces and loading/querying of ELKG. We will try out other OCEL2 to\nassess the utility of \"perspectives\" and how they are currently constructed. We\nare targeting more constraints (e.g., retrieving sequences of events [1]), and sup-\nport aggregate statistics (e.g., percentage of retrieved traces). We aim to make\nELKG from CCEL and OCEL2 more homogenous: e.g., in the sepsis dataset,\nattributes are associated with events; in an OCEL2 log, these attributes would\nlikely be represented using objects. Ideally, an ELKG would represent this data\nin the same way. Sequential relations are currently represented using predicates;\na more flexible and thus desirable alternative is reifying this relation, but cur-\nrently this drastically reduces performance. Finally, we aim to support partial\ntemporal ordering as opposed to the total ordering assumed in this paper."}]}