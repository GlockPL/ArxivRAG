{"title": "Towards a constructive framework for control theory", "authors": ["Pavel Osinenko"], "abstract": "This work presents a framework for control the- ory based on constructive analysis to account for discrepancy between mathematical results and their implementation in a computer, also referred to as computational uncertainty. In control engineering, the latter is usually either neglected or considered submerged into some other type of uncertainty, such as system noise, and addressed within robust control. However, even robust control methods may be compromised when the mathematical objects involved in the respective algorithms fail to exist in exact form and subsequently fail to satisfy the required properties. For instance, in general stabilization using a control Lyapunov function, computational uncertainty may distort stability certificates or even destabilize the system despite robustness of the stabilization routine with regards to system, actuator and measurement noise. In fact, battling numerical problems in practical implementation of controllers is common among control engineers. Such observations indicate that computational uncertainty should indeed be addressed explicitly in controller synthesis and system analysis. The major contribution here is a fairly general framework for proof techniques in analysis and synthesis of control systems based on constructive analysis which explicitly states that every com- putation be doable only up to a finite precision thus accounting for computational uncertainty. A series of previous works is over- viewed, including constructive system stability and stabi- lization, approximate optimal controls, eigenvalue problems, Caratheodory trajectories, measurable selectors. Additionally, a new constructive version of the Danskin's theorem, which is crucial in adversarial defense, is presented.", "sections": [{"title": "I. INTRODUCTION", "content": "As stated above, computational uncertainty in control oftentimes poses serious issues and should in general be differentiated from other types of uncertainty [1]. It may occur when certain idealized mathematical objects fail to exist in practice, such as exact optimizers. For instance, Sutherland et al. [2] recently showed loss of Lyapunov stability under non-uniqueness of optimal controls due to computational uncertainty in model-predictive control. A number of approaches in tackling computational uncertainty used computable analysis of Weihrauch [3], where each computation is required to terminate. For instance, Collins [4] suggested it as a general foundation of control theory. A similar proposal was made in [5] studying links between dy- namical systems and computability. In the context of planar dynamical systems, computability of basins of attraction was considered in [6]. Formal methods, such SMT (Satisfiability Modulo Theory) found applications to tackle the issue of computational uncertainty. Shoukry et al. [7] used SMT- solvers for state estimation of linear dynamic systems. Bessa et al. [8] used them for stability verification of uncertain linear systems. Another noticeable tool is the Coq proof assistant. Cohen and Rouhling [9] used it, particularly the Coqelicot library, for formalization of the LaSalle's principle."}, {"title": "II. THE FRAMEWORK", "content": "The foundation of the framework presented here is the constructive analysis of Bishop [16]. In this work, quite a bit of foundations was already tackled, but the field is actively developed \u2013 recent works offer extensive coverage of such subjects as stochastic processes [17] and abstract algebra [18]. A fresh presentation, close to program code, can be found in [19]. An interested reader may also take a look at this nice and easy-to-read recent explanation: [20].\nThe essence of constructive analysis is that everything must have a sound and finite computational content. In this regard, constructive analysis does not \u201csuppress\u201d computational un- certainty, but rather takes an explicit account thereof. For instance, a real-valued vector x = (x1,...,xn)T is treated as an algorithm that computes rational approximations {pi}i with a convergence certificate like \u2200i, j maxk=1,...,n |xk \u2212 pk| \u2264 1/i + 1/j. This is in contrast to the classical definition where no convergence information is required a vector is simply a tuple of equivalence classes of Cauchy sequences, not necessarily computable. In practice, we are always deal- ing with some xi depending on the computational device's precision. Sets are also treated with care in constructive analysis as there are plenty of examples which are computa- tionally problematic [21]. For instance, bounded sets are in general not necessarily totally bounded \u2013 to mean enclosing an algorithm that computes finite meshes approximating the said set. This goes as follows: a set X \u2286 Rn is called totally bounded if there is an algorithm that, for any \u025b, constructs a finite set {xi}Ni=1 of distinct points in X such that any x \u2208 X lies within an \u025b-ball centered at some xi. If a totally bounded set is complete, then it is called compact (notice, the related finite-mesh approximation algorithm is still encoded in the definition of the compact set!) The distance-to-set function ||x - A|| = infy\u2208A ||x - y|| is also not always finitely computable \u2013 those sets, whose function is, are called located.\nAnother example of encoding computational content is within the definition of a continuous function. A function f : Rn \u2192 Rm is a pair of algorithms: one computes rational approximations to f(x) from rational approxima- tions to x \u2208 R, and the second one, denoted wf and called modulus of continuity, satisfies the formula: \u2200\u025b > 0,c \u2208 Rn,r > 0,\u2200x,y \u2208 Br(c) ||x \u2212 y|| \u2264 w(\u03b5,c,r) \u21d2 ||f(x) - f(y)|| \u2264 \u03b5. Such a modulus of continuity is called to have the w-format. We will also use the \u00b5-format to mean \u2200x,y ||f(x) \u2212 f(y)|| \u2264 \u03bcf(||x \u2212 y||) with \u03bcf : R \u2192 R positive-definite. Constructively, these two formats are not equivalent, unlike classically. What makes a difference in working constructively is that attention should be paid to the objects or claims without a finite computational content. So is, e. g., convergent subsequence extraction (also called se- quential compactness argument) which caries no information whatsoever about how to actually do this extraction. Such arguments are commonly used in, e. g., optimal control which is discussed in more detail in Section III. Consequently, it is not constructively valid to claim existence of exact optimizers in general. Still, the most evident difference to the classical reasoning is undecidability of a = b vs. a \u2260 b for arbitrary real numbers a, b. Despite the said limitations, constructive analysis does offer a powerful apparatus for control engineer as long as a clear correspondence of pure mathematical objects and their computational realizations is concerned. This is supported, in particular, by the famous realizability interpretation [22] that states that every construc- tive existence claim is isomorphic to a finite algorithm."}, {"title": "III. OPTIMAL CONTROL AND STABILIZATION", "content": "We start with optimal control which is undoubtedly the central branch of control theory it is worth noting that reinforcement learning, one of the most vanguard methods of control for the time being, is based upon optimal control theory, dynamic programming in particular. In turn, central to optimal control is the variety of extremum value theorems for function spaces, which are used to show existence of optimal controls altogether, either as functions of time or state.\nIt is precisely the extremum value theorems (EVTs) that, in practice, suffer from computational uncertainty. The problem is that the most of the related proofs use a sequential compactness argument of the following kind: one constructs a bounded sequence of controls and then extracts a convergent subsequence from it. In practice, a naive iterative computation of optimizing controls often fails to converge, particularly due to possible non-uniqueness of optimal controls. Consequently, this non-uniqueness may pose formidable difficulties \u2013 recall, e. g., [2]. Therefore, constructively, we can only rely on approximately optimal controls in general as per:\nTheorem 1 (Constructive functional EVT [23]):\nConsider U, the space of all equi-Lipschitz and equi- bounded functions from a compact set X \u2286 Rn to Rm, and J, a uniformly continuous (cost) functional on U (\u201cequi\u201d here to mean having a common Lipschitz constant and a common bound, respectively). For any \u025b > 0, there exists a \u03ba\u2208 U such that J[\u03ba] \u2013 \u025b \u2264 infu J.\nProof: (Outline) Step 1: U is totally bounded. To effectively construct an approximate optimizer K, that de- livers an approximate optimal value of the cost functional Jup to a prescribed precision \u025b, we need first to ensure that U is totally bounded. It suffices to show that the subsets Y := {(\u03ba(x1),...,\u03ba(XN)) : \u03ba\u2208U} of RN with the product metric are totally bounded for any finite set X0 =\n{x1,...,xN} of distinct points in X. Then, we apply the constructive Arzela-Ascoli's lemma [16, p. 100] to conclude that U is totally bounded. To show Y is totally bounded for a fixed X0, let \u043a\u2208 U be arbitrary. Let K be the common bound on the functions in U in the sense of: \u2200\u03ba\u2208U ||\u043a|| \u2264 K. We construct, inductively over X0, for any prescribed precision \u03b4 > 0, a piece-wise linear function \u03ba0 so that \u03ba0 is within \u03b4 to \u03baat X0 and has the Lipschitz constant L \u2013 the common one for all the functions in U. The idea is to carefully choose a mesh Ko on BK - where K is the common bound on the functions in U in the sense of: \u2200\u03ba\u2208U ||\u043a|| \u2264 K so as to approximate \u043a by \u03ba0 up to the desired precision, while \u03ba0 takes values precisely at the nodes of the said mesh. After the values of 50 were determined on X0, we need to extend it to the whole space X. To do that, we apply the geometric construction known as the Brehm's extension theorem [24]. This theorem applies constructively provided that the points in X0 and Ko possess solely rational coordinates (which may always be assumed) whence all the involved geometric transformations are algebraic, i. e., they map points with algebraic coordinates to points with algebraic coordinates. The trick is to use Lemma 4.1 from [25, p. 8], which allows"}, {"title": "IV. DANSKIN'S THEOREM", "content": "In this section, we constructively study the famous Dan- skin's theorem, which is foundational in adversarial robust- ness [34] and is used in certain reinforcement learning methods [35]. The Danskin's theorem is closely related to the extremum value theorems and its classical proofs heavily use sequential compactness arguments. Here, we prove its constructive version using approximate optimizers. This poses the major difference to the classical theorem whose statement is based on exact optimizers. The idea of the proof is to work directly with the sets of approximate optimizers instead of resorting to sequential compactness.\nWe will use the following directional super-derivative (of a function \u03c8 : R\u2192Rin direction of a vector v) will be used: D+\u03c8(x) = lim sups\u21930 \u03c8(x+\u03b5\u03c5)-\u03c8(x)/\u03b5. By analogy, lim inf in the above will be used for the directional sub- derivative D\u2212\u03c8(x). If both coincide, the common limit is simply the directional derivative Du\u03c8(x).\nTheorem 2 (Constructive Danskin's theorem): Consider a continuously differentiable function \u03c6 :X \u00d7 \u0398 \u2192 R with X R\", compact \u0398 RP. Let \u03c8 : X \u2192 R be defined by \u03c8(x) = max\u03b8\u2208\u0398 \u03c6(x, \u03b8). Suppose E\u03b4(x) := {\u03b8 \u2208 \u0398 : |\u03c6(x,\u03b8) \u2013 \u03c8(x)| \u2264 \u03b4} \u2013 the sets of \u03b4-optimizers of \u03c8 at x are totally bounded for any x, \u03b4 > 0. Then, \u03c8 is continuous with the same modulus as \u03bc\u03c6 w. r. t. x and the directional derivative of it satisfies:\n\u2200x \u2200v \u2208 Rn \u2200\u03b4 > 0 D+\u03c8(x) = max\u03b8\u2208\u0395\u03b4(x) Du\u03c6(x, \u03b8), |Du\u03c8(x) \u2013 Du\u03c6(x, \u03b8\u03b4(x))| \u2264 \u03b4. \nProof: For the continuity part, let \u03bc\u03c6 be the continuity modulus of \u03c6 w. r. t. x to mean: \u2200\u03b8 \u2208 \u0398 |\u03c6(x, \u03b8) \u2013 \u03c6(y, \u03b8)| \u2264 \u03bc\u03c6(||x \u2212 y||). In particular, the latter holds with 0\u03b4(x), a \u03b4- optimizer for an arbitrary \u03b4 > 0, in place of 0. Observe that \u03c6(x, \u03b8\u03b4(x)) \u2013 \u03c6(y, \u03b8\u03b4(x)) \u2265 \u03c6(x, \u03b8\u03b4(x)) \u2013 max\u03b8\u2208\u0398 \u03c6(y, \u03b8). So, \u03c6(x, \u03b8\u03b4(x)) \u2013 max\u03b8\u2208\u0398 \u03c6(y, \u03b8) \u2264 \u03bc\u03c6(||x \u2212 y||). Now, us- ing a \u03b4-optimizer at y, we have: |\u03c8(x) \u2013 \u03c6(y, \u03b8\u03b4(y))| < \u03bc\u03c6(||x \u2212 y||) + \u03b4. Thus, \u03c8(x) -\u03c8(y) \u2264 \u03bc\u03c6(||x \u2212 y||) + \u03b4 + 2\u03b4, where the last two ds relate f(x),\u03c8(y) to their respective d-maximal values. Reversing the order of x, y and observ- ing that \u03b4 was arbitrary, it follows that |\u03c8(x) \u2013 \u03c8(y)| \u2264 \u03bc\u03c6(||x \u2212 y||) as required. Fix an x, \u03c5, \u03b4 > 0 and observe the following:\n\u03c8(x+\u03b5\u03c5)-\u03c8(x)/\u03b5 < \u03c6(x+\u03b5\u03c5,\u03b8\u03b4/2(x+\u03b5\u03c5))-\u03c8(x)/\u03b5 + \u03b4/\u03b5 for \u03b8\u03b4/2 (x + \u03b5\u03bd) \u2208 \u0395\u03b4/2(x+\u03b5\u03bd). Assume w. l. g. that \u025b \u2264 1 whence \u2200x \u2200\u03b4 > 0 E\u03b4(x) \u2286 E\u03b4(x) and, therefore, max\u03b8\u0395\u0395\u03b4/2(x+\u03b5\u03c5) \u03c6(x+\u03b5\u03c5,\u03b8)-\u03c8(x)/\u03b5 < max\u03b8\u0395\u0395\u03b4(x) \u03c6(x+\u03b5\u03c5,\u03b8)-\u03c8(x)/\u03b5 by the definition of maximum. Since is continuous, we can always pick \u03b5 small enough (possibly depending on x, v) that\""}, {"title": "V. SELECTOR THEOREMS", "content": "Selector theorems refer to extraction of ordinary functions (called selectors) out of set-valued functions and are ubiqui- tous in control engineering, especially in constructing system trajectories in cases when the right-hand side of the system description is time- or state-discontinuous. In particular, Fil- ippov solutions, which are often standard to describe system trajectories in such cases, e. g., in sliding mode systems [36], are constructed essentially using measurable selectors [37]. For a dynamical system described by a differential inclusion Dx \u2208 F(t,x(t)), x(0) = xo, where Fis a set-valued map, e. g., the Filippov map, trajectories can be constructed, under certain conditions on F, via iterations of the kind Xi+1(t) = xo + Savi(T) dr with vs being measurable selec- tors extracted from F(\u2022, xi(\u2022)). Selectors are also used in optimal control problems, including dynamic programming, viability theory, robust stabilization and related fields. Aubin [38] stressed that the selector theorems were not constructive and so there is no actual algorithm to compute selectors. It turns out that under certain conditions on the respective set- valued functions, continuous selectors can actually be found constructively [39, Chapter 4].\nRecently, we showed that extraction of measurable selec- tors could also be made constructive [40]. Whereas the full details can be found in the related work, let us outline the result in this section. First, fix a compact X \u2208 R and let a block be a not necessarily non-empty (closed) hyperrectangle with rational vertices in Rn. Let unions of blocks be called generalized blocks. For a generalized block B = U; Bi, if any block A \u2208 B is inside finitely many Bis, B is called locally finitely enumerable (or just finitely enumerable, if B is finite as a sequence). Notice, when dealing with B = U; Bi, we always assume the underlying sequence {Bi}i be available. If B is locally finitely enumerable and {Bi}i are disjoint, the generalized block is called proper. For a generalized block B = U; B; define a map \u03bc(B) \u2261 \u03a3\u2081\u03bc(Bi) where \u03bc(Bi) is the volume of the respective hyperrectangle (notice the map \u03bcgeneralizes the definition [27, Chapter 6], and thus is not treated as the classical Lebesque measure).\nWe say a sequence of generalized blocks E = {B}; is a representable domain in X if for any \u025b > 0, there exists another generalized block J with \u03bc(J) \u2264 \u025b s. t. \u03b8\u03b5 \u2208 J \\ dae and X \\ J \u2286 E, where dae is the generalized block which is the union of the boundaries of all Bis and A \u2208 B means (constructively) well-contained, i. e., \u2203\u5165 > 0 A + X \u2286 B. We will consider in the following measurable (single- and set-valued) functions whose domains are proper and representable. The idea behind representable domains is that they entail an algorithms which give an \u201carbitrarily thin", "inverse)": "A set-valued func- tion F: X \u2192 R with a domain UiBi is said to have representable inverse if for any finite sequence {ri}Ni<N and r > 0, Ui<N{x \u2208 X : ||ri \u2013 F(x)|| \u2264 r} is representable.\nDefinition 2 (Simple set-valued function): A set-valued function F: X \u2192 R with a domain UiBi whose values on"}, {"title": "VI. SYSTEM ANALYSIS", "content": "In this section, we briefly overview selected aspects of system analysis done constructively. First, regarding linear systems, as mentioned in Section II, the major difficulty has to do with exact eigenvectors, which consequently compli- cates various matrix decompositions ubiquitous in classical analyses. However, with the help of [25, Lemma 4.1], we can find approximate eigenvectors as per:\nTheorem 4 (Constructive eigen-decomposition [41]): Let A be a complex-valued n\u00d7n matrix with the characteristic polynomial XA(\u03bb). For any \u025b > 0, there exist a k \u2264 n linearly independent vectors \u00db1,... \u00fbk and complex numbers 1,... \u00c2m s. t. Vi = 1, . . . k || A\u00fbi \u2013 \u03bb\u03af\u00fbi || \u2264 \u03b5.\nA combination of Theorem 4 and certain perturbation bounds on matrix exponentials [42], [43], [44] then enables the eigenvalue criterion for stability. Now, we briefly tackle nonlinear systems and start with trajectory existence. To this end, consider the following (cf. Definition 3):\nDefinition 4 (Regular measurable function): A function f: X\u00d7R\u2192R", "R": "ith a domain X \u00d7 U\u00bfBi defined as \u2200x \u2208 X Vi Vt \u2208 Bi f(x,t) = a\u00b2(x,t),i \u2208 N with continuous a\u00b2: R\u2033 \u00d7 R \u2192 R is called regular.\nRespectively, let us call f Lipschitz-regular in x if a\u00b2 are Lipschitz in x. We have:\n= \nTheorem 5: Consider the initial value problem Dx = f(x,t), x(0) = x0 on a hyperrectangle X \u00d7 [0,T] with f being Lipschitz-regular. There exists a local unique solution in the extended sense, i. e., Dx satisfies the respective dif- ferential equation on a representable domain. Moreover, the solution depends on the initial condition uniformly continu- ously.\nThe proof of Theorem 5 essentially utilized the regularity of f to do the Picard iteration constructively. Regarding Lyapunov stability, the comparison principles of [45, The- orem 3.8] require certain modifications. First, call a function w: Rn \u2192 R strictly increasing (in norm) if there is a map \u03bd: Q\u2033 \u00d7 Qn \u2192 Q>os. t. \u2200x,y \u2208 Qn ||x|| < ||y|| \u21d2 w(y) \u2013 w(x) > v(x, y). With this at hand, we have:\n= \nTheorem 6 ([46]): Let X C Rn be compact and \u017c = f(x, t), x \u2208 X be a dynamical system with the equilibrium point xe = 0 and f Lipschitz-continuous in x. Suppose there exist positive-definite functions V, W1, W2, W3 : X \u00d7 R>0 \u2192 R, V continuously differentiable, W1, W2, W3 strictly increas- ing, w3 Lipschitz continuous, with the following properties:\n1) \u221at \u2265 0 \u2200x \u2208 X w1(x) \u2264 V(x, t) \u2264 w2(x) and there is \u00a7 > 0s.t.\u2200||x|| \u2265 ||y|| w2(x) -w2(y) \u2265 \u00a7(||x|| - ||y||);\n2) Vt \u2265 0 \u2200x \u2208 X V(x, t) < -w3(x).\nThen, xe = 0 is asymptotically stable for any xo in a set Xo X that depends only on the data f, V, W1, W2, W3."}, {"title": "VII. OVERVIEW OF CASE STUDIES", "content": "Application of constructive analysis to control theory was demonstrated in several case studies. First, regarding general stabilization, it was revealed, supporting the claims in the end of Section III, that computational uncertainty has a great impact on stabilization quality and it cannot in general simply be submerged into actuator, system or measurement uncertainty, as was shown in case studies with mobile robots [33]. Remarkably, effective computation of sampling time in practical sample-and-hold stabilization was enabled by constructive analysis under certain conditions on the involved CLF. So, for instance, in a case study of sliding-mode traction control [47], a practically satisfactory bound of 1 ms was achieved under the proposed effective computation using constructive analysis. Selector Theorem 3 was used in non-smooth backstepping for a mobile robot parking while reducing chattering compared to a baseline algorithm [40]. The work [41] applied constructive approximate eigenvectors in an LQR, also demonstrating high influence of computa- tional uncertainty. Theorem 6 was used to compute stability certificates via algorithms extracted from the proof in [46]."}, {"title": "VIII. CONCLUSION", "content": "Constructive analysis can be considered a suitable frame- work for control theory to perform mathematical analyses with explicit account for computational uncertainty. Not only does it enable the said analyses, it can also reveal computational weaknesses in classical results and enable new computational algorithms for control. This paper demon- strated a set of constructive results in control theory which supports potentials of the framework. As for the indicators of when the framework may be resorted to, we may list such arguments as sequential compactness, exact optimizers and existential proofs by contradiction (since they do not construct algorithms to find the related objects). Numeri- cal troubles with control algorithms may in turn serve as practical indicators for looking at the problem from the constructive standpoint."}]}