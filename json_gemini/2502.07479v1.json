{"title": "WebChecker: A Versatile EVL Plugin for Validating HTML Pages with Bootstrap Frameworks", "authors": ["Milind Cherukuri"], "abstract": "WebChecker is a plugin for Epsilon Validation Language (EVL), designed to validate both static and dynamic HTML pages utilizing frameworks like Bootstrap. By employing configurable EVL constraints, WebChecker enforces implicit rules governing HTML and CSS frameworks. The effectiveness of the plugin is demonstrated through its application on Bootstrap, the widely adopted HTML, CSS, and JavaScript framework. WebChecker comes with a set of EVL constraints to assess Bootstrap-based web pages. To substantiate the claims, I present an illustrative example featuring two solutions that effectively enforce implicit rules.", "sections": [{"title": "Introduction", "content": "In the current state of web development, many HTML and CSS frameworks come with implicit rules. Such frameworks include Bootstrap, Materialize [9], Foundation [11], and uikit [10]. These rules are developed for better use of such frameworks and best practices. Therefore, not following such rules impacts appearances and framework features. Most of these frameworks are built to be responsive to different screen sizes, such as large screens of personal computers and small screens of smart devices. To provide a consistent look and feel on all devices, it is important to follow such implicit rules.\nThe Accessible Rich Internet Applications (ARIA) [12] specification introduces a handful number of rules for web pages in order to make them accessible for users with disabilities through assistive technologies such as screen readers. Such assistive technologies require web pages to have certain attributes defined or enabled on HTML elements. Bootstrap, for example, provides default classes and ARIA attribute values throughout the framework for such technologies. Therefore, conforming to such rules makes web pages available to a greater audience.\nHowever, the caveat is to read the frameworks' documentation carefully to capture such constraints and rules. This could be quite tedious and expensive work. WebChecker is built to capture such rules so that users of this framework can easily check their web pages for conformance with such regulations. While WebChecker is built with HTML frameworks in mind, it could be easily used for web pages built without such frameworks. However, in this paper, I focus on the Bootstrap framework. Furthermore, WebChecker is able to check static and dynamic pages, which are generated by scripting languages such as PHP and JavaScript.\nThe rest of the paper is structured as follows: Section II explains the problem, the current state-of-the-art solution, and the limitations that motivated this project. In Section III, I explain the WebChecker plugin and show our solution to the problem. In"}, {"title": "Background and Motivation", "content": "Frameworks such as Bootstrap come with a handful number of implicit rules. While developing this project, I captured an initial 25 rules for the Bootstrap framework. These rules should be followed in order to use the framework properly. These rules are created by the developers of such frameworks and explained in the framework's documentation in a natural language. Users of such frameworks should carefully read the documentation in order to understand how to use the framework. This process can be quite long and tedious, expensive, and prone to errors.\nGiven a set of rules, currently, there is not a straightforward process to check if they are enforced against the HTML pages. At least, there is no easy way that requires minimum effort and very little code. After collecting the rules, the current solution flow is as follows: 1. Read and encode the HTML page. 2. Translate each rule into a method. 3. Check the rule against the HTML page. 4. Repeat 1-3 for every rule. For example, in Bootstrap, any content should be under a <div> element with class col, which should be under a <div> element with class row, which should be under another <div> element with class container. The HTML code sample is at Listing 1.1.\nTo enforce this rule, the current state-of-the-art solution is given in Listing 1.2. Since the plugin is written in Java, I chose it as our programming language of choice to implement this solution. However, any programming language can be used. Some of these might require more or less coding. Listing 1.2 shows that for enforcing the rule in Listing 1.1, the code can become lengthy and unreadable, which makes the logic confusing to reason about. It is also difficult to reuse and maintain this code since each rule has its own requirements and structure. Depending on the rules, it is likely to have more nested if statements. Furthermore, the solution is not configurable. That is, it is difficult"}, {"title": "WebChecker Plugin", "content": "Epsilon Validation Language (EVL) [2] is one of the languages of Epsilon [4], which is an Eclipse project that provides languages for model management such as model validation, model transformation, code generation, pattern matching, model merging, etc. In the context of WebChecker, a model is an HTML page or a section of the page. WebChecker implements an Epsilon Model Connectivity (EMC) layer that provides an interface, IModel, to capture the HTML model and EVL constraint file. The two main classes implemented by the plugin are WebCheckerModel and WebCheckerPropertyGetter While Epsilon provides the other classes. Figure 1 shows this relation. Furthermore, EVL users can use the features of WebChecker without setting up a new development workflow or installing new software."}, {"title": "WebChecker", "content": "The WebChecker flow, after collecting the constraints, is: 1) Write an EVL constraint. 2) Choose the HTML source (i.e., an HTML file, URL, or section of HTML). These two steps are modular and readable. Listing 1.4 is an example of an EVL file, which shows the solution for Listing 1.1.\nWebChecker follows the separation of concern\u00b9 principle with writing minimum code. In particular, there is an EVL source file and an HTML source, which could be an HTML file content or its URL. The EVL file that contains the constraints such as Listing 1.4 is run against the HTML source. Listing 1.3 shows this connection. Lines 10 and 11 of Listing 1.3 set the HTML and EVL source, respectively. Moreover, line 15 of Listing 1.3 shows how to handle errors returned from the EVL constraints. This way, the framework users and developers only need to focus on constraints that are not satisfied."}, {"title": "WebChecker EVL Structure", "content": "The WebChecker EVL structure follows the same EVL structure as in [2]. However, I will only explain the current syntax used by WebChecker."}, {"title": "Bootstrap Implicit Rules by WebChecker", "content": "WebChecker enforces an initial 25 rules for the Bootstrap framework. There are much more rules to be captured. Here, I only show and explain five randomly chosen implicit rules for the framework. For the complete list of laws enforced by the plugin please see the project's GitHub repository2. For brevity, I do not show the actual EVL syntax.\nScreenReaderButton: this constraint captures buttons with class close and validates if the <button> element has the aria-label attribute defined for assistive technologies.\nAlertLinkInDivAlert: this constraint captures <a> elements with class alert-link and validates if the parent element includes alert and alert-* classes. The asterisk (*) is a wild card such as alert-success or alert-danger etc.\nBtnGroupToggle: this constraint captures <div> elements with class btn-group-toggle and checks if its data-toggle attribute is defined and its value is equal to buttons.\nBadge ClassSiblingRelation: this constraint captures <span> elements with badge and badge-* classes and checks if either the previous sibling element or the next sibling element has a sr-only class. This is required for screen readers to know what the badge represents rather than what it looks like.\nImageInPictureWithImgClass: this constraint captures <img> elements whose parent is the <picture> element and checks if the <img> element has a img-* class. This is required since a <picture> element indicates that there is a picture in the tag."}, {"title": "Improvements over Current Solution", "content": "As shown from the example above, WebChecker is built to be easy, modular, readable, and configurable. These features address and solve most of the challenges developers face while using a program analyzer as studied by Microsoft researchers [6]."}, {"title": "Related Work", "content": "Bootlint [7] is a Bootstrap-specific linter for checking common HTML mistakes in web pages built in a vanilla way; that is, pages where default Bootstrap classes are used. Bootlint uses JavaScript to check for Bootstrap rule conformance, which is not configurable. The source code of Bootlint, which is in the bootlint.js\u00b3 file of the Bootlint project, is much lengthier than the code in Listing 2. This validates our points on the current limitations of the current solution, as explained above.\nPolicheck is Microsoft's internal tool that checks codes, comments, and content, including web pages. For example, it can check if a web page contains inappropriate content or if its style matches best practices and guidelines [6].\nESLint [8] is a static JavaScript analysis linting utility written in JavaScript to enforce coding styles through pluggable rules. With ESLint, developers can analyze JavaScript code by using default rules or creating new rules without running the JavaScript code. ESLint requires a configuration file in JavaScript Object Notation (JSON), YAML (YAML Ain't Markup Language), or JavaScript. Most importantly, the configuration file includes the source of the rule file, which is a JavaScript file that has the implementation of the rule. While ESLint is powerful and popular, the JavaScript code for each rule is not reusable."}, {"title": "Conclusion and Future Work", "content": "In this paper, I propose a new plugin for the Epsilon Validation Language with a concrete example. I identify the current solution developers use to check web pages for framework rule conformance and compare our solution with its improvements.\nI believe that with web pages being ubiquitous, there will be more frameworks with implicit rules and less detailed documentation. If developers of these frameworks have a tool such as WebChecker, they can write exhaustive lists without providing much documentation since EVL constraints are easily readable and close to natural language.\nFurther research on the topic includes extending WebChecker to support fixes when a constraint is not satisfied, evaluating other framework rules and capturing such implicit rules, providing WebChecker through popular text editors, validating web pages"}]}