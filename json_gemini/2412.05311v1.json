{"title": "DRC-Coder: Automated DRC Checker Code Generation\nUsing LLM Autonomous Agent", "authors": ["Chen-Chia Chang", "Chia-Tung Ho", "Yaguang Li", "Yiran Chen", "Haoxing Ren"], "abstract": "In the advanced technology nodes, the integrated design rule checker\n(DRC) is often utilized in place and route tools for fast optimization loops\nfor power-performance-area. Implementing integrated DRC checkers to\nmeet the standard of commercial DRC tools demands extensive human\nexpertise to interpret foundry specifications, analyze layouts, and debug\ncode iteratively. However, this labor-intensive process, requiring to be\nrepeated by every update of technology nodes, prolongs the turnaround\ntime of designing circuits.\nIn this paper, we present DRC-Coder, a multi-agent framework with\nvision capabilities for automated DRC code generation. By incorporating\nvision language models and large language models (LLM), DRC-Coder\ncan effectively process textual, visual, and layout information to perform\nrule interpretation and coding by two specialized LLMs. We also design\nan auto-evaluation function for LLMs to enable DRC code debugging.\nExperimental results show that targeting on a sub-3nm technology node\nfor a state-of-the-art standard cell layout tool, DRC-Coder achieves\nperfect F1 score 1.000 in generating DRC codes for meeting the standard\nof a commercial DRC tool, highly outperforming standard prompting\ntechniques (F1=0.631). DRC-Coder can generate code for each design\nrule within four minutes on average, which significantly accelerates\ntechnology advancement and reduces engineering costs.", "sections": [{"title": "1\nINTRODUCTION", "content": "In the era of advanced technology nodes, design rule checking (DRC)\nis a critical yet complex step in physical design due to the increasing\nnumber of design rules, more complex inter-layer design rules, and\nstrict patterning rules. Place and route (P&R) tools often require an\nintegrated DRC checker to ensure manufacturability and enable faster\noptimization loops for power-performance-area (PPA) than running\ncommercial DRC tools every iteration. Implementing an integrated DRC\nchecker typically takes experienced engineers several weeks, involving\nnumerous iterations of debugging to extract DRC rules from foundry\ndocuments and ensure the integrated checker meets the standards of\ncommercial DRC tools, as shown in Figure 1. Furthermore, this process"}, {"title": "2\nPRELIMINARIES", "content": "In this section, we first study the related works for LLM-agent frame-\nworks. Then, we introduce VLMs and its potential on explaining de-\nsign rule images and layouts. Finally, we introduce the grid-based DRC\nchecker used in the standard cell layout tool."}, {"title": "2.1 LLM-Agent Framework", "content": "LLM autonomous agents (LLM-agents) [8, 17, 18, 21] have emerged\nas powerful tools that enable LLM to make plans and execute exter-\nnal functions based on their reasoning processes. LLM-agents have\ndemonstrated their effectiveness in various domains. In online shop-\nping scenarios [20], LLM can base on user instruction to search, choose\nthe product on the website, and reason when to buy the product to\nsatisfy user requirements. In programming tasks [2], LLM-agents can\ngenerate code, compile and execute it, and iteratively debug based on\ncompiler and execution feedback. This ability to reason, act, and learn\nfrom feedback illustrates the enhanced problem-solving capabilities\nof LLM-agents. In chip designs, LLM-agents are also applied for tasks\nlike Verilog and layout clustering generation [6, 7], demonstrating their\npotential in specialized domains and hardware-related problems.\nHowever, existing frameworks only processes pure text representa-\ntions, which are not effective for interpreting circuit layouts and design\nrules. Therefore, having visual understanding capabilities in LLM-agent\nframeworks is essential. In addition, we should provide a domain-specific\nDRC code evaluation function to give meaningful feedback on the code\nperformance in detecting DRVs. This could help LLM to effectively avoid\nfalse positives and negatives of DRVs produced by the generated code."}, {"title": "2.2 DRC Interpretation Challenges & VLMs", "content": "Foundries specify each design rule through concise text description and\nvisual illustration that often imply complex spatial conditions. For exam-\nple, the description of rule M0.S.1 in Figure 1 has an image, presenting\nmultiple spacing scenarios S1A1, S1A2 for rules M0.S.1 & MO.S.2, and\na text with abbreviated term PRL. It needs interpretation to know that\nthe actual condition is: the horizontal space between metals in the Mo\nlayer must be > 1 when the parallel run length (PRL) \u2265 \u22121, where PRL\ncan be viewed as a vertical space.\nCircuit designers must also analyze commercial DRC tool reports\non layouts to uncover implicit conditions not explicitly stated in the\nfoundry description. Figure 1 reveals that the commercial tool further\nchecks for a boundary condition: the space between the x-boundary\nand metals must be > 1. The above example indicates the challenges of\naccurately analyzing foundry descriptions and commercial tool reports\nin DRC code generation."}, {"title": "2.3 Grid-based DRC Checker", "content": "In our evaluation, we use NVCell [15] as our target standard cell layout\ntool. NVCell employs a grid-based DRC checker to rapidly obtain layout\nperformance. For example, it can complete DRC for a cell with 22 devices\nin 0.05 seconds, while the commercial DRC tool takes 215 seconds. In"}, {"title": "3 DATA PREPARATION", "content": "To evaluate the generated DRC code, we create a dataset composing of\nstandard cell layouts and their DRC reports. The dataset preparation\nprocess has two steps: layout generation and DRC report preprocessing."}, {"title": "3.1 Layout Generation", "content": "We produce 207 different standard cell layouts using NVCell by mutating\nthe routing behaviors without DRC fixing. This approach ensures a wide\nrange of DRV scenarios for evaluation. These layouts are represented in\na grid format used in the grid-based DRC checker stated in Section 2.3."}, {"title": "3.2 DRC Report Preprocessing", "content": "The preprocessing stage converts physical coordinate-based DRC re-\nports from the commercial tool into a grid-based representation that\naligns with the output format of our grid-based DRC checker. The pre-\nprocessing involves the following steps:\n(1) Produce the DRC reports of layouts by running the commercial\nDRC tool. These reports use polygons to mark DRV locations in\nphysical coordinates."}, {"title": "4 DRC-CODER", "content": "Our approach, DRC-Coder, generates DRC code on a rule-by-rule ba-\nsis. To make DRC-Coder more applicable when facing new technology\nnode, our code generation is under a zero-shot setting, i.e., no example"}, {"title": "4.1 Prompting", "content": "Given the input design rule, this stage constructs a structured initial\nprompt, as illustrated in Figure 6, to the Planner. The components of\nthis prompt is split into the fix part and the design rule (DR) dependent\npart. The fix part contains: (1) A task definition for developing a Python\nfunction to identify DRVs in layout data. (2) The requirements that\nformally states the input and output format of the function. (3) A step-\nby-step guide that decomposes coding problem into subtasks for the\nPlanner and Programmer.\nThe DR dependent part has: (1) The target design rule description\nfrom foundry document. (2) Layout examples with metal information\nand corresponding DRV locations to provide concrete cases for analysis.\nNote that we randomly select two layout examples that has the target\nDRVs from our dataset to construct the prompt. Additionally, the DR\ndependent part is dynamically adjusted based on the target design rule."}, {"title": "4.2 Planner", "content": "Planner is an LLM agent focusing on interpreting foundry-provided\ndesign rule descriptions and layouts to generate corresponding design\nrule conditions in the grid domain. These foundry-provided descriptions"}, {"title": "Foundry Rule Analysis.", "content": "This function processes a specific question\nfrom Planner regarding DRVs. Then, a VLM is called to interpret design\nrule descriptions (combining text and images) in the foundry document\nand provides a answer to the input question. As shown in Figure 7,\nthe function analyzes the provided image, identifying target spacing\ndirections and generating a detailed response for DRC conditions for\neach spacing requirement. This automated interpretation helps Planner\nto understand complex design rules presented in multi-modal formats,\nfacilitating the translation of foundry specifications into precise and\ngrid-based conditions that can be used for DRC code generation."}, {"title": "Layout DRV Analysis.", "content": "This function takes two inputs: a question\nfrom Planner regarding design rules and layout, and a list of cell names\nindicating the layouts to be examined. It then utilizes a VLM (GPT-40)\nto interpret the specified layout images. The VLM identifies key ele-\nments such as metal regions and DRV locations within the provided\ngrid coordinates. As demonstrated in Figure 8, the function generates\na comprehensive response that addresses Planner's query, detailing"}, {"title": "4.3 Programmer", "content": "Programmer is an LLM agent responsible for translating the grid-based\ndesign rule conditions, produced by the Planner, into executable DRC\ncode. To understand the generated code performance, we design a tool\nfunction, DRC Code Evaluation. The example in Figure 11 shows the\ngenerated DRC code."}, {"title": "DRC Code Evaluation.", "content": "This function inputs the generated code and\noutputs the performance report of the code. In detail, this function ex-\necutes our generated code on cell layouts in the dataset and directly\ncompares the code output with the golden DRC reports of the commer-\ncial tool. The generated DRC code must correctly classify layout grids as\neither DRC-compliant or DRC-violating based on each design rule. The\ndataset of standard cell layouts used for evaluation is inherently imbal-\nanced, with DRC-violating grids being significantly less than compliant\nones. Thus, to evaluate performance, we measure Precision, Recall, and\nF1 score between the DRVs detected by the commercial tool and our\ngenerated code. These metrics are particularly suitable for imbalanced\ndatasets, focusing on the correct identification of the minority class\n(DRC-violating). Higher values in these metrics indicate better DRC\ncode. Note that we serve F1 score as our primary metric since it offers a\ncomprehensive view of effectiveness by balancing both precision and"}, {"title": "5\nEXPERIMENTAL RESULTS", "content": "In this section, we first detail the experiment setup. Then, we present\nthe evaluation results and an abalation study of DRC-Coder. Finally, we\nintroduce a detailed workflow of DRC-Coder."}, {"title": "5.1 Experiment Setup", "content": "Development platform. DRC-Coder is developed under Python lan-\nguage based on the multi-agent system development toolkit AutoGen [18].\nPlanner and Programmer agents, along with the VLMs embedded in\ntwo tool functions, are powered by GPT-40 [12] using the OpenAI API"}, {"title": "5.2 Results of DRC-Coder", "content": "The evaluation results are shown in Table 1. Our DRC-Coder using GPT-\n40 [12], employing a multi-agent architecture with vision capability,\nachieves perfect scores (1.000) in Precision, Recall, and F1 score for all\nseven design rules evaluated. This consistent performance across differ-\nent rule types highlights the robustness of our approach in interpreting\nand translating complex design rules into accurate DRC code.\nIn contrast, the standard prompting method shows unsatisfied perfor-\nmance across different design rules with an average F1 of 0.631. While\nit performs adequately for some rules, e.g., VIA1, it struggles with oth-\ners, particularly in terms of Recall and F1 scores. This inconsistency\nshows the limitations of conventional prompting when dealing with the\nintricate DRC."}, {"title": "5.3 Abalation Study", "content": "The abalation study results are shown in Table 2. This experiment can\nevaluate the performance contribution of the visual capability and the\nmulti-agent setting in DRC-Coder. Two variants of DRC-Coder demon-\nstrate improved performance over standard prompting (first column in\nTable 1) with 32.5% and 30.7% higher F1 score, respectively. However,\nthey fall short of the full DRC-Coder (second column in Table 1) in some\ndesign rules. These results indicate the importance of visual capability"}, {"title": "5.4 Case Study of DRC-Coder Workflow", "content": "This section presents a detailed case study of DRC-Coder's workflow\nfor generating and refining DRC code for design rule M0.S.1. Figure 11\nprovides a step-by-step visualization of this process.\nThe workflow begins with an initial prompt, which triggers the Plan-\nner agent to analyze the design rule using FoundryRuleAnalysis and\nLayoutDRVAnalysis tool functions (steps 1-2). These analyses provide\ninsights into the rule specifications and potential DRV conditions. Based\non this information, Planner summarizes the DRV analysis and gener-\nate a plan for writing the DRC code (step 3), including the boundary\nand spacing DRV checking. Then, Programmer implements the DRC\ncode (step 4) and call the DRCCodeEval tool (step 5) to get the code\nperformance and reveal areas for improvement.\nIn the next iteration of code generation, Planner develops a plan for\nrefinement (step 6), indicating how to modify the boundary rules and\nspacing conditions. This guides Programmer to make code adjustments\n(step 7). This iterative process continues, with each cycle improving the\ncode performance and decrease the false negatives and positives (steps\n8-10). Note that in step 8, there is no false negatives for the code. Finally,\nwhen the DRCCodeEval indicates the code is correct, Planner send the\nTERMINATE signal to end the code generation process.\nThis demonstration shows that Planner can generate effective plans\nfor modifying design rule conditions. Also, Programmer can follow the\nplan and combine its last generated code to generate an improved one."}, {"title": "6\nCONCLUSION", "content": "In this work, we introduce DRC-Coder, the first automated DRC code\ngeneration framework leveraging a multi-agent system with vision\ncapabilities. Our approach decomposes the DRC coding process into in-\nterpretation and programming tasks, utilizing two LLMs and integrating\nVLMs to effectively process multi-modal information including textual\ndescriptions, visual illustrations, and layout representations. In addition,\nwe develop three specialized tool functions for LLMs: foundry rule anal-\nsis, layout DRV analysis, and DRC code evaluation. These functions\nenable automated reasoning and debugging, significantly robustify the\ncode generation process.\nOur evaluation demonstrates that DRC-Coder significantly outper-\nforms standard prompting techniques, achieving perfect F1 scores of\n1.000 across all design rules considered in a standard cell layout tool\nfor a sub-3nm technology node. This indicates that the generated DRC\nchecker successfully replicates the report of the commercial tool, pro-\nviding signoff DRC to the layout tool. Moreover, DRC-Coder drastically\nreduces the coding time from days of manual effort an average of four\nminutes per design rule, highly accelerating technology migration and\nreducing engineering costs. Note that DRC-Coder can be generalized to\ngenerate codes using other programming language, e.g., C++, for more\nefficient DRC.\nLooking ahead, DRC-Coder can be extended to a wide range of DRC-\nrelated applications. For example, we can use our image analysis func-\ntions and include human interactive feedback in each Planner's re-\nsponse to realize a DRC-explanation chatbot. We also aim to extend our\nframework to other areas of physical design that require multi-modal\nreasoning. Finally, as DRC-Coder unlocks LLM's capability for a com-\nplex engineering task in EDA, we hope to stimulate future research on\ndeveloping LLM-agents in this field."}]}