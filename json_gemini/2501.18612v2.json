{"title": "Deeply Optimizing the SAT Solver for the IC3 Algorithm", "authors": ["Yuheng Su", "Qiusong Yang", "Yiwei Ci", "Yingcheng Li", "Tianjun Bu", "Ziyu Huang"], "abstract": "The IC3 algorithm, also known as PDR, is a SAT-based model checking algorithm that has significantly influenced the field in recent years due to its efficiency, scalability, and completeness. It utilizes SAT solvers to solve a series of SAT queries associated with relative induction. In this paper, we introduce several optimizations for the SAT solver in IC3 based on our observations of the unique characteristics of these SAT queries. By observing that SAT queries do not necessarily require decisions on all variables, we compute a subset of variables that need to be decided before each solving process while ensuring that the result remains unaffected. Additionally, noting that the overhead of binary heap operations in VSIDS is non-negligible, we replace the binary heap with buckets to achieve constant-time operations. Furthermore, we support temporary clauses without the need to allocate a new activation variable for each solving process, thereby eliminating the need to reset solvers. We developed a novel lightweight CDCL SAT solver, GipSAT, which integrates these optimizations. A comprehensive evaluation highlights the performance improvements achieved by GipSAT. Specifically, the GipSAT-based IC3 demonstrates an average speedup of 3.61 times in solving time compared to the IC3 implementation based on MiniSat.", "sections": [{"title": "1 Introduction", "content": "Model checking [16,17] is a powerful formal verification technique widely used in system design. Given a transition system and a property describing the desired system behavior, it can efficiently and automatically detect bugs or prove system correctness.\nRecent significant advancements in SAT solvers, particularly the introduction of the Conflict Driven Clause Learning algorithm (CDCL) [33], have led to breakthroughs in model checking through SAT-based algorithms. Among these,"}, {"title": "2 Preliminaries", "content": ""}, {"title": "2.1 Basics and Notations", "content": "We use notations such as x, y for Boolean variables, and X, Y for sets of Boolean variables. The terms x and \u00acx are referred to as literals. A cube is a conjunction of literals, while a clause is a disjunction of literals. A Boolean formula in Conjunctive Normal Form (CNF) is a conjunction of clauses. It is often convenient to treat a clause or a cube as a set of literals, and a CNF as a set of clauses. For instance, given a CNF formula F, a clause c, and a literal l, we write l \u2208 c to indicate that l occurs in c, and c\u2208 F to indicate that c occurs in F. A formula F implies another formula G, if every satisfying assignment of F satisfies G, denoted as F\u21d2 G. We use V(F) to represent the set of all variables appeared in formula F.\nA transition system, denoted as S, can be defined as a tuple (X, Y, I,T). Here, X and X' represent the sets of state variables for the current state and the next state, respectively, while Y represents the set of input variables. The Boolean formula I(X) represents the initial states, and T(X, Y, X') describes the transition relation. State s2 is a successor of state s1 if and only if (s1, s2) \u21d2 T. A safety property P(X) is a Boolean formula over X. A system S satisfies P if and only if all reachable states of S satisfy P.\nWithout loss of generality, circuits are commonly represented in the form of And-Inverter Graph (AIG) [26]. An AIG is a directed acyclic graph, which includes primary inputs/outputs and two input and-nodes with optional inverter marks on the fanin edges. The Cone of Influence (COI) of a node is the set of all nodes that could potentially influence its value, which can be obtained by recursively traversing its fanins. When T is derived from an AIG, X and Y correspond to the primary inputs, while X' corresponds to the primary outputs. It exhibits the functional characteristic where each next state variable is assigned by a function of current states and inputs, x' \u2194 fi(X,Y). Therefore, T is a conjunction of all assignment functions, \\Lambda x' \u2194 fi(X, Y). The transformation of an AIG to CNF typically involves Tseitin encoding [35], where each node in the AIG is mapped to a variable in the CNF."}, {"title": "2.2 Incremental CDCL SAT Solver", "content": "Conflict Driven Clause Learning (CDCL) [33] is a powerful and widely used algorithm that employs conflict analysis and clause learning techniques to efficiently solve SAT problems. Modern CDCL SAT solvers typically rely on the Variable State Independent Decaying Sum (VSIDS) branching heuristic [30]. It calculates a score for each variable and selects the variable with the highest score during decision. This is typically maintained by a binary heap [20]. An incremental SAT solver efficiently solves a series of related formulas and typically provides the following interfaces:\n*   `add_clause(clause)`: adds the clause to the solver.\n*   `solve(assumption)`: checks the satisfiability under the given assumption.\n*   `get_model()`: retrieves the variable assignments from the previous SAT call.\n*   `unsat_core()`: retrieves the unsatisfiable core from the assumptions of the previous UNSAT call."}, {"title": "2.3 IC3 Algorithm", "content": "IC3 is a SAT-based model checking algorithm that does not require unrolling the system [12]. It attempts to prove that S satisfies P by finding an inductive invariant INV(X) such that:\n*   I(X) \u21d2 INV(X)\n*   INV(X) \u2227T(X,Y, X') \u21d2 INV(X')\n*   INV(X) \u21d2 P(X)\nTo achieve this objective, it maintains a monotone CNF sequence Fo, F\u2081... Fk. Each frame Fi is a Boolean formula over X, which represents an over-approximation of the states reachable within i transition steps. Each clause cin Fi is called lemma and the index i is called level. IC3 maintains the following invariant:\n*   Fo = I\n*   Fi+1 \u2287 Fi\n*   Fi\u2227T \u21d2 Fi+1\n*   for all i <k, F; \u2192 P\nA lemma c is said to be inductive relative to Fi if, starting from states that satisfy both Fi and c, all states reached in a single transition satisfy c. This condition can be expressed as a SAT query sat(Fi^ c^T^\u00acc'). If this query is satisfiable, it indicates that c is not inductive relative to Fi, as we can find a counterexample where a state satisfying Fi\u2227c and transitions to a state that does not satisfy c. If lemma c is inductive relative to Fi, it can also be said that the cubec is blocked in Fi+1.\nAlgorithm 1 provides an overview of the IC3 algorithm. This algorithm incrementally constructs frames by iteratively performing the blocking phase and the propagation phase. During the blocking phase, the IC3 algorithm focuses on making Fk \u21d2 P. It iteratively get a cube c such that c\u21d2 \u00acP, and block it recursively. This process involves attempting to block the cube's predecessors if it cannot be blocked directly. It continues until the initial states cannot be blocked, indicating that \u00acP can be reached from the initial states in k transitions, which violates the property. In cases where a cube can be confirmed as blocked, IC3 proceeds to expand the set of blocked states through a process called generalization. This involves dropping literals and ensuring that the resulting clause"}, {"title": "3 Motivations", "content": ""}, {"title": "4 Optimizations", "content": ""}, {"title": "4.1 Decide and Propagate in Domain", "content": "Observation 1 shows that it is unnecessary to consider all variables when solving Qrelind. We analyze which variables need to be considered through the following theorems. Considering the formula Qrelind: sat(Fi^c^T^\u00acc'), we can analyze the subset of variables that need to be taken into account without affecting the satisfiability. To determine the satisfiability of Fi\u2227c, we only need to consider the variables that appear in this formula, which are V(Fi) UV(c). Similarly, for the satisfiability of T ^\u00acc', the values of the variables in c' are solely determined by the COI(c'). Therefore only the variables in COI(c') need to be considered. As a result, by considering only the variables in V(F\u2081) UV(c) UCOI(c'), we can determine the satisfiability of the formula Qrelind.\nWe refer to the set of variables that need to be considered during solving as the domain. For solving Qrelind, it is sufficient to use V(Fi) UV(c) U COI(c') as the domain, instead of all variables. This significantly reduces the number of variables that the SAT solver needs to decide and assign during BCP. We need to efficiently compute the domain before each solving process. For V(Fi), we maintain a data structure within the SAT solver that tracks and updates it whenever a new lemma is added. For V(c), we simply extract all the variables that appear in c. Finally, COI(c') is computed by recursively traversing the fanins of c'.\nAt the beginning of the solving process, we push all variables from the computed domain into the VSIDS decision-required set, ensuring that all domain variables will be decided. During BCP, if a clause includes a variable not in the current domain, we skip that clause and move on to the next one. This approach ensures that variables outside the domain are not assigned during BCP.\nIt can also be noticed that the difference between c' in every two adjacent Qgen is only one literal. This suggests that calculating COI(c') for every Qgen is unnecessary. Instead, We perform this calculation initially during generalization and upon successful drops, as depicted in Algorithm 2. We recalculate it upon successful drops because sometimes the unsat core can drop multiple variables at once compared to before."}, {"title": "4.2 VSIDS by Bucket", "content": "Observation 2 highlights that the overhead of VSIDS is non-negligible, and reducing this overhead could potentially enhance overall performance. Inspired by bucket sorting, we introduce a novel data structure for VSIDS, that enables both push and pop operations to be performed in constant time. We predefine a fixed number of buckets (defaulting to 15) and assign each variable to a specific bucket. This design ensures that variables in lower-numbered buckets have higher VSIDS scores than those in higher-numbered buckets.\nTo maintain this guarantee amid dynamic changes in variable scores, we utilize an interval heap for each bucket. The interval heap is a double-ended priority queue that can efficiently pop either the maximum or minimum value in logarithmic time [27]. Each bucket's interval heap stores all the variables belonging to that bucket, using their scores as the sorting criterion. When the score of variable v increases, the update function in Algorithm 3 is invoked. This function first locates the bucket b where v resides. Then, it checks whether the"}, {"title": "4.3 Without Resetting", "content": "Observation 3 indicates that the SAT solver requires periodic resets due to the activation variables. However, this process also results in the loss of all learned clauses and heuristic scores. The key to supporting temporary clauses is to identify and remove all learned clauses that are directly or indirectly derived from temporary clauses after each solving process. We establish the following theorem:\nTheorem 1. To solve Qrelind with a temporary clause c by utilizing the activation variable a, we consider the formula: sat(Fi\u2227 (c\u2228a) \u2227T \u2227 \u00acc' \u2227 \u00aca), where \u00acc'\u2227\u00aca serves as the temporary assumption. If a learned clause lc is derived from c\u2228a, then lc must contain the literal a.\nProof. In a CDCL solver, every learned clause is the result of a sequence of resolution steps [13,37]. We prove this theorem by mathematical induction. Initially, the only clause containing a is c\u2228a, and we assume that no clause contains the literal \u00aca. Any learned clause derived from c\u2228a is either a direct or indirect resolvent of c\u2228a. Since we assume that no clause contains \u00aca, a cannot be used as a pivot in resolution. Consequently, every resolution step involving c\u2228a must preserve the literal a, implying that all learned clauses derived from c\u2228a must contain a. Furthermore, clauses not derived from c\u2228a cannot contain either a or \u00aca, ensuring that our assumption remains valid throughout the process.\nTheorem 1 states that learned clauses derived from the temporary clause contain the activation variable. Therefore, if all learned clauses containing the activation variable are identified and removed after each solving process, the temporary clause can also be safely deleted."}, {"title": "5 Implementation", "content": "Instead of implementing these optimizations on an existing SAT solver, we developed a new lightweight CDCL-based SAT solver from scratch, called GipSAT. It is implemented in Rust, a modern programming language designed to offer both performance and safety.\nIn many current implementations of IC3 [1,6,9], a separate SAT solver is created for each frame. GipSAT is designed based on this assumption, as each GipSAT instance corresponds to a specific frame. Since GipSAT is specifically optimized for the IC3 algorithm, it requires more information than other regular SAT solvers, such as the transition relation and awareness of which clauses belong to a frame for computing and maintaining the domain. Consequently, its interface differs from that of regular SAT solvers. The interfaces provided by GipSAT are as follows:\n*   `new(model)`: Creates a new instance of GipSAT based on the provided transition system model. The transition relation T of model is represented in CNF format, with variable dependency information derived from AIG to compute the COI.\n*   `add_lemma(lemma)`: Adds the given lemma to the solver. GipSAT maintains the lemmas of each frame. The `add_clause` method has been replaced with this, as users only need to add lemmas after creating a GipSAT instance. A lemma is a clause that involves variables in X and has no dependent variables. Adding a clause with dependent variables could affect the correctness of domain maintenance. Therefore, only the `add_lemma` interface is provided.\n*   `solve(assumption, constraint, droot)`: Checks the satisfiability under the specified assumption and constraint within the domain COI(droot)UV(F), where F represents the lemmas maintained by GipSAT. Users should ensure that V(assumption) UV(constraint) \u2286 COI(droot) UV(F).\n*   `unsat_core()`: Retrieves the unsat core from the previous UNSAT call.\n*   `get_model()`: Retrieves the variable assignments from the previous SAT call.\n*   `set_domain(droot)`: Configures GipSAT to use V(F) U COI(droot) as the domain for subsequent solving processes, bypassing the need to recompute the domain before each solving step."}, {"title": "6 Evaluation", "content": ""}, {"title": "6.1 Experiment Setup", "content": "We integrated GipSAT into rIC3 [9], an implementation of the IC3 algorithm in Rust, which boasts competitive performance. We use the version based on Minisat. For comparison, we evaluated the performance of rIC3 with some state-of-the-art SAT solvers:\n*   Minisat 2.2.0 [7]: Minisat is a popular SAT solver that serves as the underlying framework for many other SAT solvers.\n*   CaDiCaL 2.1.2 [4]: CaDiCaL is a state-of-the-art SAT solver that has achieved high rankings in recent SAT Competitions [11].\n*   CryptoMinisat 5.11.21 [5]: CryptoMinisat was the winner of the incremental track in the 2020 SAT Competition (no incremental track has been held since 2020).\nWe also considered the IC3 implementations in state-of-the-art model checkers, such as ABC [1] and nuXmv 2.1.0 [8], using their default configurations.\nWe conducted all configurations using the full benchmark suite from the two most recent Hardware Model Checking Competitions (HWMCC'20 and HWMCC'24), totaling 635 cases (after removing duplicates) in AIGER format [2]. All experiments were performed under identical resource constraints (16GB memory and a 3600s time limit) on an AMD EPYC 7532 processor running at 2.4 GHz. To ensure the accuracy of the results, we verified the results across different checkers to ensure consistency. To ensure reproducibility, we have made the implementations of our experiments available at [3]."}, {"title": "6.2 Experimental Results", "content": "Table 2 and Fig. 4 present the summary of results and the number of cases solved over time by various configurations. The comparison shows that rIC3 performs well relative to state-of-the-art systems like ABC and nuXmv, making it a suitable choice as the experimental foundation. Notably, GipSAT solved 23 more cases than the best-performing regular solver, Minisat, greatly enhancing the capability of the IC3 algorithm."}, {"title": "6.3 Analysis", "content": "To better demonstrate the effectiveness of GipSAT, we measured the average solving time of queries using GipSAT and Minisat in rIC3, as described in Fig. 6. It is evident that, in the majority of cases, GipSAT demonstrates a significant reduction in solving time for queries when compared to Minisat. We also evaluated rIC3-GipSAT under different conditions: when it makes decisions and propagates in all variables instead of the domain (rIC3-GipSAT-av), when it utilizes a binary heap instead of buckets in VSIDS (rIC3-GipSAT-bh), and when it"}, {"title": "7 Related Work", "content": "Since the introduction of IC3 [12], numerous efforts have been dedicated to enhancing its performance. Most of these studies focus on the algorithm layer. For instance, [25] attempts to block counterexamples to generalization (CTG) to improve generalization. [36] proposes a variant of IC3 that integrates inter-"}, {"title": "8 Conclusion and Future Work", "content": "In this paper, we present GipSAT, a SAT solver specifically designed for the IC3 algorithm. GipSAT reduces the number of variables that need to be decided by precomputing the domain. It achieves constant-time operations by utilizing buckets in VSIDS. Moreover, it avoids resetting the solvers by eliminating the requirement for allocating an activation literal before each solving. The experimental results demonstrate that GipSAT significantly reduces the solving time of SAT queries posed by IC3, consequently leading to a substantial performance improvement compared to state-of-the-art regular SAT solvers. In the future, we will continue to optimize GipSAT and explore the possibility of designing an SMT solver for the word-level IC3 algorithm."}]}