{"title": "Set-Based Retrograde Analysis:\nPrecomputing the Solution to 24-card Bridge Double Dummy Deals", "authors": ["Isaac Stone", "Nathan R. Sturtevant", "Jonathan Schaeffer"], "abstract": "Retrograde analysis is used in game-playing programs to\nsolve states at the end of a game, working backwards toward\nthe start of the game. The algorithm iterates through and com-\nputes the perfect-play value for as many states as resources\nallow. We introduce setrograde analysis which achieves the\nsame results by operating on sets of states that have the same\ngame value. The algorithm is demonstrated by computing ex-\nact solutions for Bridge double dummy card-play. For deals\nwith 24 cards remaining to be played (1027 states, which can\nbe reduced to 1015 states using preexisting techniques), we\nstrongly solve all deals. The setrograde algorithm performs a\nfactor of 103 fewer search operations than a standard retro-\ngrade algorithm, producing a database with a factor of 104\nfewer entries. For applicable domains, this allows retrograde\nsearching to reach unprecedented search depths.", "sections": [{"title": "Introduction", "content": "Some of the early high-performance game-playing programs\nrelied on retrograde analysis and endgame databases for\nstrong play. The most notable example is Checkers, where\n39 trillion endgame positions, all those with 10 or fewer\npieces, were used as part of the CHINOOK program (Scha-\neffer et al. 1992), and for solving Checkers (Schaeffer et al.\n2007). Endgame databases are also used widely in Chess\nprograms (Chess 2024), as well as in many other games\n(e.g., for solving Awari (Romein and Bal 2003)).\nEndgame databases are most effective in games where\nthere are far fewer positions at the end of the game than else-\nwhere. As a result, they have not been applied in games that\ndo not have this property. For instance, Sturtevant (2003)\nnoted that in 3-player Chinese Checkers a winning arrange-\nment of a single player's pieces in the game has approx-\nimately 1023 possible permutations of the other player's\npieces, making it infeasible to store all the variations of even\na single winning configuration. While in Chinese Check-\ners each player has a unique endgame configuration (the\nother side's piece locations are irrelevant), in Go the lo-\ncations of both side's pieces in a terminal state are im-\nportant. Hence these games require significantly different\nanalysis (Berlekamp and Wolfe 1994). In a 4-player trick-\nbased card game such as Bridge, the last two tricks have\n(52) (50) (48) (46) = 1.9 \u00d7 1012 possible deals of the cards.\nHowever, there are only 16 ways for each deal to play out,\nmeaning it is trivial to solve but storing all states (as done in\nCheckers) is difficult.\nThese numbers suggest it might be impractical to build\nan effective endgame database for Bridge with, say, 6 tricks\nto play (1027 states). This statement is true under the as-\nsumption that every unique endgame state must be stored\nindependently. The contribution of this paper is to show how\nto avoid this assumption by representing endgame states as\nsets. This idea, along with other symmetry reduction tech-\nniques, makes it feasible to use retrograde search to compute\nall 24-card (6-trick) Bridge double-dummy (DD) endgames\nin a week on appropriate hardware using just 50GiB of stor-\nage, something that was historically hard to imagine.\nThis paper describes our set-based approach to endgame\ndatabases, making the following contributions.\n\u2022 We present a new set-based retrograde analysis algo-\nrithm, setrograde analysis, inspired by the ideas in Gins-\nberg's Partition Search (Ginsberg 1996). Whereas stan-\ndard retrograde analysis computes a value for every state,\nsetrograde analysis generalizes a state into a set where all\nmembers have the same game-theoretic value. The algo-\nrithm can skip over many of the states that are subsumed\nby the set. Replacing states with sets leads to a large de-\ngree of state-space compression, by mapping an expo-\nnentially growing state-space to a smaller set-space.\n\u2022 The algorithm is demonstrated using 24-card Bridge\ndeals. The set database contains 4 orders of magnitude\n(OOM) fewer sets than there are states in a traditionally\ngenerated database. The set database was constructed\nusing 3 OOM less computing resources than would be\nneeded for a traditional 24-card database. This enabled\nan 800 trillion state state-space to be solved in a week\nusing a single multi-core machine.\nThis work generalizes retrograde analysis, allowing it to\nhave more impact in applicable domains. In particular, the\nreduced computing and storage needs mean that endgame\ndatabase technology can be scaled to unprecedented levels."}, {"title": "Background and Related Work", "content": "Double-dummy problems are the perfect-information vari-\nant of Bridge card play. A deal of n cards (with n as a mul-\ntiple of 4) has an exact integer evaluation under perfect play,\nranging from 0 to \\frac{n}{4} \u2014 the number of tricks won."}, {"title": "Overview", "content": "Here we provide a high-level overview of a set-based ap-\nproach to retrograde analysis. The ideas are illustrated using\nexamples from Bridge."}, {"title": "State-Space Reduction", "content": "This section is specific to the game of Bridge, but is im-\nportant for illustrating the search-space reductions that are\npossible in Bridge and in set-based search.\nA 24-card (6 tricks) endgame database contains the solu-\ntion to all \\frac{(52)!}{(46)!(6)!} ways to distribute the\ncards from a standard deck. Additionally, there are 5 trump\nsuits to consider (clubs, diamonds, hearts, spades, and no\ntrump). Hence there are 5 \u00d7 1027 unique deals represented\nin the 24-card database.\nA well-known optimization used in card-game transposi-\ntion tables is to represent cards using relative ranks instead\nof absolute ranks (Haglund and Hein 2014). If there are 8\nspade cards in play, the lowest one is always represented\nas a 2, the next lowest as a 3, and so on. Thus, \\binom{13}{8} possi-\nble deals (1,287) are reduced to 1 representative deal. This\ndoes not affect card-play mechanics, but it reduces the num-\nber of 24-card states by roughly 12 OOM. Several minor\nsymmetry-related optimizations (not discussed here) can be\napplied to remove approximately one OOM, leaving 8\u00d71014\n(800 trillion) distinct states that must be evaluated and stored\nin a 24-card endgame database."}, {"title": "Set-Space Reduction", "content": "Retrograde analysis, shown in Alg. 1, works by iterating\nover all states at depth d (lines 3-4, 12-13), computing a\nstate's value based on the successor states at depth d - 1\n(line 5), and storing it into the database (line 7). Applying the\nsame approach to 24-card Bridge would require repeatedly\niterating over almost 1015 states (assuming the reductions\ngiven above), requiring storage of ~ 1015 bytes (depending\non possible compression approaches).\nOur set-based algorithm, setrograde analysis, generates\na database of consistent sets. We start with a simpler ver-\nsion of the algorithm, also shown in Alg 1, before refining\nour description into a more efficient version. As with ret-\nrograde analysis, the simpler implementation works by iter-\nating through all states at depth d (lines 3-4, 12-13). Each\nstate is queried in the database to see if it matches any of the\nsets that have already been computed (line 5). If such a set\nis found, the state's value is known and the algorithm moves\non to the next state. Otherwise, a search routine finds a con-\nsistent set containing the new state (line 9), and that set is\nadded to the database (line 10).\nWe highlight here some of the challenges in creating a fast\nsetrograde algorithm:\n1. Generalization. This additional routine (line 9) is per-\nformed at every state. The cost of this operation must be\nless than the cost of performing the retrograde operation\nfor each of the states encompassed by the set returned.\n2. Querying. It is more complex to look for a state in a\ndatabase of sets than to look for a state in a database\nof states (line 5). databaseLookup performs multiple\nqueries at each state. Without a fast and scalable imple-\nmentation, queries become a computational bottleneck.\n3. Iteration. Iterating over all members of a large state-space\nwill be expensive even if the cost per state is small. To\nscale computation, we must be able to iterate through\nthe set-space without considering each state in the (much\nlarger) state-space.\nEach of these are briefly described. Generalization and it-\neration are then illustrated using Bridge."}, {"title": "Example 1: Generalization in Bridge", "content": "In the following deal, East is on lead. North and South will\ntake 2 tricks with the two highest spades:\nTo generalize this deal we must produce candidate sets.\nHere we use the 8 candidates (a-h) shown in Fig. 2 that were\ngenerated by replacing one or more low-rank cards with x's.\nIt can quickly be verified that sets a-f contain only states in\nwhich North and South take 2 tricks. For example, consider\nverifying set f using minimax search. East, South, and West\neach have one legal move (play an x), after which North\nplays either the 9 or the 8, winning the trick. The resultant\nset using relative card ranks is:\nHaving taken one trick, North and South must take one\nmore trick in this resultant set. A search for this set in the\n4-card database returns a value of one trick for North and\nSouth. Therefore this candidate set is a valid generalization.\nNote that in general, the exact set being looked for may not\nbe in the database. Instead the overlap of several entries may\nbe equivalent to the set looked for. The value of the over-\nlapped sets would be the minimum of their values.\nSets g and h each contain at least one deal in which North\nand South take only one trick, for instance:\nConsider trying to verify the correctness of g. Similar to\nthe analysis of f above, East, South, and West again have one\nlegal move and North has 2. North can play an x in which\ncase North may fail to win the current trick. While a com-\nplex analysis can be performed when it is unclear which card\nwins a trick, it is sufficient here to note that in any case where\nNorth and South fail to win this trick, North and South will\nbe unable to take 2 total tricks. Therefore, if North plays an\nx on best play, set g must not be consistent. North therefore\nplays the 9, producing the following resultant set:\nNorth and South must take one more trick in this resul-\ntant set. Searching the 4-card database finds the following\nentry, which overlaps the set being looked for. Here North\nand South take 0 more tricks:\nThis means on North's action (the 9) set g is not con-\nsistent. Since North has no legal actions that leads to consis-", "content_extra": "tent resultant positions, set g is not consistent and cannot be\nadded to the database."}, {"title": "Example 2: Low-Cost Iteration in Bridge", "content": "To reduce computation, we skip over states that are mem-\nbers of the set just added to the database. We only solve and\ngeneralize independent states \u2014 states not yet represented\nin the database. Each time a set is added to the database, we\ngenerate one or more potential next-states. These states are\nconstructed by applying minor changes to the previous set\nthat give rise to states that are provably not represented by\nthat set. The next states are placed into an open list (as in the\nA* algorithm (Hart, Nilsson, and Raphael 1968)) for further\nconsideration. From the previous example, if we add to the\ndatabase the set:\nit would be redundant to evaluate any other state in which\nNorth holds 98. Therefore an independent state can be pro-\nduced efficiently by trading the 8 for one of the x cards.\nFor example, we could produce the following set (one of\nthree such possibilities):\nIf this set is consistent then it will be turned into a state by\nreplacing the x's with low values (one of 720 possibilities):\nThis new state goes onto the open list and eventually gets\ngeneralized using the process shown in Example 1. This\nprocess repeats until all deals in the state-space are repre-\nsented by a set in the database. Through this process, a set-", "content_extra": "rograde solver can consider far fewer states than it would"}, {"title": "Setrograde Analysis", "content": "Now we turn to a more complete description of setro-\ngrade analysis, identify further bottlenecks, and describe\nhow these are implemented efficiently.\nThese definitions are used to describe setrograde analysis:\n\u2022 D: maximum retrograde distance \u2014 in Bridge, number\nof tricks\n\u2022 d: retrograde distance d \u2208 1..D (that is, distance to ter-\nminal state)\n\u2022 Sd: all states at distance d (from terminal state)\n\u2022 Td: a set of sets of states such that all encapsulated states\nhave a retrograde distance d\nSetrograde analysis (Alg. 2) parallels its state-wise prede-\ncessor with three key modifications. First, a set Ta is main-\ntained to track solved states (which are not stored explicitly\nbut found in the union of all sets in Ta). Second, at each\niteration, a states \u2208 Sds & Ta is evaluated that is,\nstates that are already solved are not re-evaluated. While re-\nevaluation does not occur in the state-wise formulation, it\ncould occur in the set-wise formulation if the states were\nevaluated iteratively without validating independence. Fi-\nnally, each solved state is generalized to a consisistent set\nt. Set t is stored in the database instead of the individual\nstate.\nAlg. 3 provides the helper functions needed for Alg. 2.\nThe generalization process from a state to a consistent set\ncan be done in many ways. One method is a backup heuris-\ntic, such as the one used in most modern Double Dummy\nsolvers (Ginsberg 1996). The heuristic produces a single\nconsistent set t. This approach opts for simplicity, ignoring\ngenerality at each step and incurring a compounding per-\nformance penalty in both computation and storage. For our\nsetrograde solver, we use a generate-and-test approach. Mul-\ntiple candidate sets are produced, which may or may not\nbe consistent. Each is evaluated for consistency. Any met-\nric (for instance |t|) can be used to select which consistent\nset to add to the database.\nSetrograde analysis is not guaranteed to produce the\nsmallest possible database by any metric. The order in which\nstates are evaluated can affect which sets are added to the\ndatabase. The metric used to select which consistent candi-\ndate set is added to the database (or indeed whether mul-\ntiple sets are added) can affect the composition of the fi-\nnal database. Some metrics (including |t|) can result in ties,\nand the tiebreak can affect the composition and size of the\ndatabase. Anything that affects the size of the database may\nalso affect computation time since speed is positively corre-\nlated with the number of states that are evaluated and gen-\neralized. Future work might establish stronger performance\nguarantees or tighter bounds.\nThe lower bound on the number of sets required for a\ndatabase is based on an ideal set representation in which all\ndeals with the same game value are represented in a sin-\ngle set. In that case, we need exactly one set for each game\nvalue. In Bridge we partition the state-space based on the\ndistribution of suits between the four hands. Since each par-\ntition requires at least one database entry (some partitions\nevaluate to a single game value), the number of partitions\nprovides the tighter lower bound found in Table 1. This par-\ntitioning of both the state-space and set-space also makes\nour implementation embarrassingly parallelizable, as each\npartition can be solved independently."}, {"title": "Implementation in Bridge", "content": "This section briefly mentions some of the important Bridge\nimplementation details. Further information can be found in\nthe Technical Appendix.\nSet Representation: As discussed in the background sec-\ntion, and depicted in Fig. 1, representing sets of deals with\nlow cards unspecified is not a new idea. This representation,\nwith fixed cards and x's is used in most (if not all) implemen-\ntations of Partition Search. To reduce database size, we ex-\ntend this methodology, by representing each card using four\npositional bits \u2014 one bit per player - indicating whether\nor not each player may hold this card. This representation\nallows for AND-OR conditions that are not possible with a\nsimple x notation for low cards. We demonstrate the utility\nof this representation by example.\nIn each of the four sets in Fig. 3 (top), North and South can\ntake two tricks by playing the highest two cards, one on each\ntrick. Since the evaluation of each set is identical (North and\nSouth take two tricks on perfect play), the union of the four\nsets is itself a consistent set. The union could be expressed\nas (North holds the 9 OR South holds the 9) AND (North\nholds the 8 OR South holds the 8) AND (all lower cards\nare x's). Using 4 positional bits per-card (in North-South-", "content_extra": "East-West order) we can represent that statement compactly.\nThe 9 and 8 each have their bits set to true (1) corre-\nsponding to North and South holding those cards, and two\nbits false (0) corresponding to East and West set not holding\nthose cards, as illustrated in Fig. 3 (bottom). Our databases\nconsist of entries mapping from sets represented in this syn-\ntax to a bound on the number of tricks taken by each part-\nnership."}, {"title": "Experimental Results", "content": "Here we provide an analysis of setrograde analysis perfor-\nmance on Bridge database generation. The program is writ-\nten in Julia, and compiled in version 1.8 or higher using the\nLLVM compiler. All code is compatible with version 1.11.\nThe large databases were computed on a machine with 48\ncores, 187 GB of RAM, and 256 GB of swap using an In-\ntel(R) Xeon(R) Gold 6248R CPU @ 3.00GHz."}, {"title": "Validation", "content": "Extensive tests to verify the correctness and completeness of\nour databases were performed. The simplest approach is to\ncompute the retrograde analysis databases and then compare\nthe results with the setrograde data. Retrograde databases\nwere built through 16-card deals. Every state's value in these\ndatabases was in agreement with the corresponding setro-\ngrade result.\nBeyond 16 cards, exhaustive validation is no longer prac-\ntical. We rely instead on two methods for partially validating\nthe 20 and 24 databases. First, random subsets of the search\nspace were chosen and for each state the setrograde value\nwas compared to that of a standard minimax search. Second,\nthousands of double dummy problems were solved using a\nsearch-based solver with and without using the setrograde\ndatabases. The values returned in all the searches were iden-\ntical.\nOur results were validated to the extent that could reason-", "content_extra": "ably be done on the available compute resources. Positive\nresults have been achieved using every validation method\nwe could practically implement."}, {"title": "Performance of Setrograde Analysis", "content": "Table 1 shows one measure of setrograde's performance.\nUpper Bound is the number of states that a retrograde analy-"}, {"title": "Breakdown of 24-card performance gains", "content": "Setrograde analysis decreases both storage and computation\ncosts, rather than trading one for the other. To understand\nwhere the computation and storage costs are being reduced,\nwe can break down the performance of setrograde analysis.\nIn the 24-card case there are 8 \u00d7 1014 effective states. This is\nreduced to 2 \u00d7 1012 states added to the open list (generated)\nthroughout the database generation process \u2014 a reduction\nof 2.4 OOM. The open list never exceeds 1000 states. Of\nthe 2 \u00d7 1012 states placed on the open list, only 1 in 47 is\nindependent. The remaining 46 states are discarded using\n(cheap) duplicate detection techniques (\u2248 5% of total run-\ntime) leaving us with just 4.6 \u00d7 1010 states to evaluate and\ngeneralize.\nOver 90% of computation time is spent evaluating and\ngeneralizing the 4.6 \u00d7 1010 independent states. Each evalua-\ntion and generalization step results in adding a set to the final\ndatabase. A post-processing phase (compactEDB in Alg. 2)\nscans the database to identify sets that can be combined to\nform a single, more general set. This is a small additional\ncomputation cost that results in roughly cutting the final\ndatabase in half to 2.4 \u00d7 1010 sets.\nSetrograde's generalize step has no counterpart in retro-", "content_extra": "grade analysis \u2014 and it is expensive. On average, it increases\nthe cost of evaluating a state by a factor of 15 in our imple-\nmentation. This is a high price to pay but, of course, it leads\nto a 4 OOM reduction in the number of states considered for\n24 cards. Our generalize function might still be made less\nexpensive; we have not definitively determined the best way\nto maximize set generality and minimize computation costs."}, {"title": "Impact on Double-Dummy Search", "content": "Our long-term aim is to build a 52-card database that can be\nused directly in Bridge playing algorithms. In the short term,\nwe have performed experiments with a DD solver which\nshow that the 6-trick database can eliminate roughly 75%\nof the tree, and the 7-trick database (when available) will\npush this up to roughly 90%."}, {"title": "Conclusions", "content": "This paper introduces setrograde analysis, a generalization\nof retrograde analysis from states to sets. For applicable\ndomains, the algorithm can reduce the computational and\nstorage needs by orders of magnitude. Some games for\nwhich setrograde analysis will be beneficial include Chinese\nCheckers and Skat.\nFor the game of Bridge, endgame databases have not been\nbuilt because the massive search space and storage needs\nmade it seemingly impractical. Setrograde makes this pos-\nsible through 24 cards. The 28-card databases are currently\nbeing computed, and 32 card databases should be possible\nwith today's technology. The growth rate of the resource\nneeds seems to be rapidly decreasing with size, making\nit now possible to imagine solving the entire 52-card deal\nspace."}, {"title": "Technical Appendix", "content": "The technical appendix goes into the implementation details\nof our setrograde analysis Bridge program. For clarity, our\nexamples are limited to using one suit (spades). The gener-\nalization and iteration processes described in Alg. 3 are aug-\nmented with examples. A description of the tree structure\nused to store our databases is described."}, {"title": "Generalizing and Iterating in Bridge", "content": "Alg. 2 makes use of two functions that require careful im-\nplementation to scale well (nextIndependentState and\ngeneralizeToSet). A high-level version of these routines\ncan be found in Alg. 3. In this section we describe one im-\nplementation for each that performed well on 24-card deals.\nIn Alg. 2 we iterate sequentially through d \u2190 1..D. For\neach retrograde distance, we add states to the open list, eval-\nuate them, generalize them (if not a duplicate), and remove\nthem from the open list. For each non-duplicate state, the\ngeneralization process will result in 0 to 4 states being added\nto the open list. By greedily pulling states nearest the end of\nthe canonical ordering from the open list, we can minimize\nthe expansion of the open list. The open list's memory foot-\nprint is dominated by the disjoint segments of the database.\nIn the following, the iteration process is described in more\ndetail.\nTo enable fast iteration we define a canonical ordering of\nsuit permutations, 81...Sn such that any set that may be rep-\nresented using fixed ranks and x's will consist of contigu-\nous states in that ordering. To do that we define a process\nfor trading cards between hands where low cards permute\nbefore higher cards. To find the next state in the canonical\nordering from a set of states, the high cards are incremented\nby one permutation, and the x's are reverted to the first per-\nmutation.\nIn the generalization process, the lowest card in a suit can\nalways be marked as x. Therefore, anywhere from one to all\nof the cards in a suit could be x's. With at most 13 cards in\na suit, there are at most 13 configurations of x's in a suit on\nany deal. This is reflected in the binary search we described\nin Section 5 where initially one more than half of the cards\nin a state are marked as x. For each set considered, a query\nis made to the oracle (Alg. 3) to check whether the set is\nconsistent. If a set is consistent, we place a lower bound on\nthe number of x's we will have in our \"best\" set. When a\nset is inconsistent, we place an upper bound instead. This\nprocess is repeated until a tight bound is obtained, and the\nconsistent set with the most x's is added to the database.\nHere, we work through several examples. With 4 cards\nremaining, the canonically first deal is generated. The deal\nis evaluated (North and South take 1 trick), and generalize-\nToSet is called. In the following examples, a T (for True)\nindicates that a set is consistent, and F (False) that it is not.\nWe start by marking three cards as x. The lowest card is al-\nways an x, so the minimum is 1 and the maximum is 4. The\nmidpoint -2.5- rounds up to 3 (performance is marginally\nbetter when rounding up). When the initial oracle query re-\nturns True, we know the set is consistent, and that we will\nhave at least 3 x's. The oracle is queried again on a larger set\n(4 x's). On the larger set, the oracle returns False. We now\nhave a tight bound on the number of x's in the \"best\" con-\nsistent set. The \"best\" consistent set (tret in Alg. 3) is the\ndeal with 5 specified and all other cards x's. It is added\nto the database, and the next deal is generated. nextInde-", "content_extra": "pendentState permutes the high cards (just the 5 in this\ncase) and sets the low cards back to their first permutation.\nTo complete the 4-card database, we repeat the process on\nthe following 3 deals:\nresulting in the three consistent sets (middle) being added to\nthe database.\nThough we perform our computation on the fixed-rank\nrepresentation, entries are stored in the more expressive 4-\nbit format described in the paper. During the solution inser-\ntion process, or optionally in post-processing, sets are fur-\nther compacted, leveraging positional bits to combine sets.\nThe complete 4-card database contains the following 2 en-\ntries, representing the 24 deals with 4 cards remaining in a\nsingle suit:\nWith a complete database for 4-card deals, it is possible\nto generate the solutions to 8-card deals similarly. There are\n2,520 deals with 8 spades remaining, and East to play. These\nare compressed into 19 database entries.\nWe provide a diagram of the generalization process for the\ncannonical first 8-card state, similar to the 4-card example\nabove. We also show the next independent state (sNext).\nA binary search is done on the number of x's (start with 5\n(True), jump to 7 (False), and then back down to 6 (True).\nWe now have the maximal consistent state (by number of\nx's). It is then permuted (moving the 8 from the N hand to\nthe S hand in this case), and that set is then selected from\nthat set.\nOnce the 8-card database is complete, the process is\nrepeated to generate the 12-card database. The 12-card\ndatabase consists of 295 entries, representing 369,600 deals."}, {"title": "Storing Setrograde Databases", "content": "This section describes how the compact sets described in\nSec. 5 of the paper are stored to support fast-enough lookups\nwith low-enough memory overhead.\nThis representation is likely not the most compact format\npossible, nor provides the fastest possible lookups. At the\ntime of this writing, the program is computationally limited;\nour largest databases fit on consumer-grade thumb drives.\nTherefore, our attention has been on decreasing computa-\ntion costs. Database queries, while expensive due to fre-\nquency, are not (yet) dominating our computation, which is\nhow we choose to define \"fast-enough\". The implementa-\ntion described was chosen for its simplicity and empirical\nsuccess in supporting sufficiently fast queries and relatively\nsmall disk footprints.\nTo support fast look-ups and low-cost set operations, our\nsetrograde database uses a specialized shallow tree data\nstructure (implemented as an array, and depicted in Fig. 4).\nEach node in the database contains:\n\u2022 a 16-bit key, defining positional bits for 4 cards;\n\u2022\nan upper and lower bound (4 bits each) on the game value\nof states in the set (states being defined by the 16-bit keys\nof all parent nodes and the node itself; cards that are not\nspecified by a parent or the node itself are x's);\n\u2022 and a 32-bit sibling pointer.\nThe maximum tree depth is the same as the retrograde\ndepth, since 4 cards are defined at each level in the tree. Par-\nents often have many children (the storage cost of each par-\nent is split among its children) with the end effect that for\neach entry in the 24-card database, there are on average less\nthan 2 (64 bit) nodes. Additionally, not all leaf nodes are at\nthe maximum tree depth. x's are implicitly represented, re-", "content_extra": "ducing the number of nodes per entry.\nAn independent tree is stored for each distribution of suits\namong the four players. This makes it practical to store the\ndatabase in a compressed format, and expand only the por-\ntions of the database needed at any given point. Addition-\nally, by reducing average tree size (by a factor of the Lower\nBound in Table 1 \u2014 that is a factor of 2 \u00d7 106 in the case of\nthe 24 card database) we improve locality, and limit the cost\nof a query.\nSeveral other small optimizations (child pointers are im-\nplicit, to save space; sibling pointers are relative) provide\nmemory reductions and improve locality.\nA state can be queried by starting from the root of a tree,\nand comparing the state's 16-bit key (A state's key has ex-\nactly one bit turned on for each 4-bit card representation)\nwith a node's 16-bit key using a bit-wise AND operator. If\nthe bit-wise AND of the two keys is not equal to the state's\nkey, the state is not represented by the node. The lookup\nfollows the sibling pointers until a match is found. When a\nmatch is found, the bounds are checked, and if a child exists,\nthe search continues with the child.\nSimilar operations are used to look up sets, or given a set\nto find all dependent sets (sets sharing at least one state). Bit-\nwise operations are also used to find sets whose unions can\nbe represented as a single set.\nIt is likely that the data structure could benefit from ad-\nditional sorting, allowing for more direct access, however,\nthe benefits of this data structure when compared with other\nstructures we tried were crucial (and sufficient) for generat-\ning a 24-card database."}]}