{"title": "LiteEFG: An Efficient Python Library for Solving Extensive-form Games", "authors": ["Mingyang Liu", "Gabriele Farina", "Asuman Ozdaglar"], "abstract": "LiteEFG is an efficient library with easy-to-use Python bindings, which can solve multiplayer extensive-form games (EFGs). LiteEFG enables the user to express computation graphs in Python to define updates on the game tree structure. The graph is then executed by the C++ backend, leading to significant speedups compared to running the algorithm in Python. Moreover, in LiteEFG, the user needs to only specify the computation graph of the update rule in a decision node of the game, and LiteEFG will automatically distribute the update rule to each decision node and handle the structure of the imperfect-information game.", "sections": [{"title": "Introduction", "content": "The successes of reinforcement learning in solving various games, including Go (Silver et al., 2016, 2017), Atari (Mnih et al., 2013), and Dota2 (Berner et al., 2019), have increased interest in developing scalable approaches for finding equilibrium strategies in extensive-form games (EFGs). Compared to Markov games where the game state is fully observable, a big challenge in EFG is that decisions are made according to partial observation of the game state. It further results in additional hardness in computing the expected utility of taking an action, unlike Q-values in Markov games, since the expected utility depends on the distribution of hidden information. For instance, in Texas Hold'em, the utility of raising the bid depends not only on the private hands of the decision maker but also on those of her opponents, which are unknown when making the decision.\nThe recent interest in computation methods for solving EFGs also sparked activity in developing libraries for executing algorithms over the game tree. A popular library is OpenSpiel (Lanctot et al., 2019), which provides various game environments with an easy-to-use Python API for researchers to test their algorithms. However, the algorithms operating over OpenSpiel are usually very slow since they are executed via Python. This motivates the need to devise a library that incorporates both simple Python API and efficient backend execution, similar to how TensorFlow (Abadi et al., 2016) and PyTorch (Steiner et al., 2019) operate.\nTo address the challenge above, we propose LiteEFG, an open-source library with a simple Python API and an efficient C++ backend for solving EFGs, which is much faster than pure Python execution. With LiteEFG, researchers need to define the update-rule at a decision node in a similar way as defining neural networks with TensorFlow or Pytorch, then LiteEFG will automatically distribute that update-rule to each individual decision node and handle the relationship between different decision nodes automatically. Compared to OpenSpiel (Lanctot et al., 2019), LiteEFG is simpler and faster when solving tabular games (games that may fit into the computer memory). In experiments, the classical baseline, Counterfactual Regret Minimization (Zinkevich et al., 2007), implemented by LiteEFG is about 100x faster than that of OpenSpiel.\nIn LiteEFG, researchers only need to specify the computation graph of the algorithm via Python. Then, the computation graph will be executed via C++, which provides acceleration by several orders of magnitude. Moreover, due to the imperfect information of EFG, the game states and decision nodes no longer coincide, which complicates the implementation of the algorithm. To simplify the issue, LiteEFG will automatically aggregate the information from different game states belonging to the same decision node 1, so users only need to specify the update-rule for the decision node, without concerning with the aggregation process."}, {"title": "Preliminaries", "content": "In this section, we will introduce the preliminaries of EFGs. We use \\(\\Delta m := \\{x \\in [0,1]^m: \\sum_i x_i = 1\\}\\) to denote the m \u2212 1 dimensional probability simplex. For a discrete set C, we use |C| to denote its cardinality. For any real number x \u2208 R, \\([x]_+ := x \\cdot 1_{x>0}\\), which is x when x > 0 and 0 otherwise.\nBasics of extensive-form games. In an N-player EFG, we use [N] := {1,2, ..., N} to denote the set of all players. Optionally, a fictitious player\u2014called the chance player\u2014is introduced to model stochastic events, such as a random draw of cards or dice roll.\nThe game is a tree structure and we use H to denote the set of all nodes in the game. For each h \u2208 H, one of the players among {c} U [N], where c is the chance player, will take actions at h. We use p(h) to denote the player"}, {"title": "Tour: Implementation of Counterfactual Regret Minimization (CFR)", "content": "In this section, we will introduce how to use LiteEFG."}, {"title": "Basics of Computation Graph", "content": "LiteEFG is based on the computation graph, in which a vector is stored at each node and users need to define the relationships between graph nodes. For instance, node A equals node B plus node C. Then, every time the user updates the graph, the variables at each graph node will be updated according to the predefined relationship.\nIn LiteEFG, the user need to define the computation graph for an infoset first. Then, the graph will be copied to each infoset in Ui\u2208[N] Si. Therefore, all infosets share the same relationship between graph nodes, while the variables stored in the graph node of each infoset are independent.\nIn LiteEFG, the user can define a node by LiteEFG.function(...) with some function of LiteEFG\u00b3, such as LiteEFG.sum and LiteEFG. exp. In this case, LiteEFG will create a new node to store the outcome of the function and return that node. Alternatively, the user can update the variable at a node by x. inplace (LiteEFG.function(...)). In this case, LiteEFG will not create a new node. Instead, the outcome of the function will be stored at node x, and replace the original variable at x."}, {"title": "Construction of Computation Graph", "content": "In this section, we will introduce the construction of the computation graph for Counterfactual Regret Minimization (CFR) (Zinkevich et al., 2007), one of the most prominent algorithms for solving EFGs, with LiteEFG."}, {"title": "Visitation of Infosets", "content": "LiteEFG provides four types of graph nodes.\n\u2022 LiteEFG.backward(is_static=True): Static backward nodes. These nodes will be executed at initialization (ahead of the execution of any other nodes). To execute the static backward nodes, infosets will be visited in the reversed breadth-first order and the corresponding static backward nodes will be executed.\n\u2022 LiteEFG.forward(is_static=True): Static forward nodes. These nodes will be executed at initialization (ahead of the execution of any dynamic nodes, but after the static backward nodes). To execute the static backward nodes, infosets will be visited in the breadth-first order and the corresponding static forward nodes will be executed.\n\u2022 LiteEFG.backward(is_static=False): Dynamic backward nodes. These nodes will be executed every time the function LiteEFG.Environment.update is called. To execute the dynamic backward nodes, infosets will be visited in the reversed breadth-first order and the corresponding dynamic backward nodes will be executed.\n\u2022 LiteEFG.forward(is_static=False): Dynamic forward nodes. These nodes will be executed every time the function LiteEFG.Environment.update is called. To execute the dynamic backward nodes, infosets will be visited in the breadth-first order and the corresponding dynamic forward nodes will be executed."}, {"title": "Static Graph", "content": "The update-rule of CFR is as follows. For any player i \u2208 [N], an infoset s \u2208 Si, and action a \u2208 As, the update-rule at timestep t \u2208 {1,2, ..., T} is\n\nCF^{(t+1)}(s, a) = \\sum_{h \\in s} U_i(h) \\frac{\\pi^{(t+1)}(s \\rightarrow h)}{\\prod_{j \\in \\{c\\} \\cup [N]: j\\neq i} \\mu_j^{(t)}(h)} \\left(\\prod_{j \\in \\{c\\} \\cup [N]: j\\neq i} \\mu_j^{(t+1)}(h)\\right)  \\tag{3.1}\n\nR^{(t+1)}(s,a) = R^{(t)}(s,a) +  CF^{(t+1)}(s,a) - \\mathbb{E}_{a' \\sim \\pi^{(t+1)}(\\cdot | s)} [CF^{(t+1)}(s,a')]   \\tag{3.1}\n\\pi^{(t+2)}(a|s) = \\frac{\\Lambda[R^{(t+1)}(s,a)]_+}{\\sum_{a' \\in A_s} [R^{(t+1)}(s,a')]_+}, \\sum_{a' \\in A_s} [R^{(t+1)}(s,a')]_+ > 0\\\\\n\\pi^{(t+2)}(a|s) = \\frac{1}{|A_s|}, \\sum_{a' \\in A_s} [R^{(t+1)}(s,a')]_+ = 0\\\\\n\nFrom Equation (3.1), to update CFR, we need to maintain two variables in each infoset s, the strategy \u03c0i(\u00b7|s) \u2208 \u2206|As|, and the regret buffer R(s,\u00b7) \u2208 R|As|. In Figure 2, the green code block defines the static backward nodes of CFR algorithm. In line 7, we define expectation, which is the placeholder for \\(\\mathbb{E}_{a' \\sim \\pi^{(t+1)}(\\cdot | s)} [CF^{(t+1)}(s,a')]\\). We will discuss the necessity of such placeholder in Section 3.3.2. Line 8 and 9 initialize \u03c0i(\u00b7 | s) as uniform distribution over \u2206As and R(s,\u00b7) as zero vector individually. The vector at self.action_set_size is a scalar equivalent to |As| for each infoset s."}, {"title": "Dynamic Graph", "content": "In this section, we will focus on the red code block in Figure 2.\nLine 15. Line 15 displays the usage of LiteEFG.aggregate."}, {"title": "Loading the Game", "content": "LiteEFG is fully compatible with OpenSpiel, i.e. LiteEFG supports almost all games in OpenSpiel\u2074. Moreover, for games not implemented by OpenSpiel, users can write a game description text file alternatively and load it using LiteEFG.FileEnv. An example of the game file is illustrated in Figure 3, and the full example can be found in LiteEFG/game_instances/kuhn.game. At the beginning, the game file displays the parameters of the game, where the parameter num_players is necessary and other parameters are optional. The next several lines will include the node information, with an identifier node at the beginning of the line, and the node's name goes after it. For different types of nodes, the additional information should obey the following rules,"}, {"title": "Training", "content": "In line 19 and line 20 of Figure 4, we load the environment leduc_poker from OpenSpiel to LiteEFG. The traverse_type specifies how to traverse the game tree in each iteration. Currently, LiteEFG supports enumerating"}, {"title": "Evaluation", "content": "In line 28 of Figure 4, we print the exploitability of the strategy stored at graph node graph.strategy. \"avg-iterate\" indicates we want to measure that of the average-iterate strategy. LiteEFG.Environment.exploitability returns a vector v, where each element vi \u2265 0 indicates how much player i can improve her utility by deviating to other strategies while the strategies of other players remain fixed. The sum \u2211i\u2208[N] vi is the exploitability, which measures the distance to the Nash equilibrium. When the exploitability is zero, it implies that the current strategies of all players form a Nash equilibrium."}, {"title": "Debug", "content": "To debug the strategy, users can call LiteEFG.OpenSpielEnv.get_strategy to get a pandas. DataFrame as shown in Figure 5 to display the strategies.\nMoreover, the user can also interact with the strategy computed by the algorithm, by calling LiteEFG.OpenSpielEnv.interact."}, {"title": "Various Baselines", "content": "Though EFG is developing fast in recent years (Lee et al., 2021; Liu et al., 2023; Sokota et al., 2023), it is hard to make a fair comparison between different algorithms. The difficulty is mainly two-fold. Firstly, some algorithms are not open-sourced and algorithms in EFGs are sensitive to the hyper-parameters. Therefore, when re-implementing the baseline algorithms, researchers may not be able to achieve the same performance as the original paper with the same set of parameters. Moreover, sometimes researchers do not use OpenSpiel or even not using Python to implement their algorithms. Secondly, even though some algorithms are open-sourced (Sokota et al., 2023), they are highly inefficient since they are purely based on Python. As a result, it takes a lot of computation resources and time to make a fair comparison with previous results. Therefore, comprehensive and efficient baselines are important for the whole community, and LiteEFG provides a variety of baselines."}, {"title": "Benchmark", "content": "In this section, we will compare the performance of CFR over LiteEFG and OpenSpiel. All experiments are computed on Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz. We compare the performance of the baseline algorithm CFR (Zinkevich et al., 2007) and CFR+ (Tammelin et al., 2015) in four classical benchmark games, Liar's Dice, Leduc Poker (Southey et al., 2005), Kuhn Poker (Kuhn, 1950), and Dark Hex.\nWe can see that in Figure 7, LiteEFG provides over 100\u00d7 acceleration in both games, compared to OpenSpiel. In OpenSpiel, running CFR+ for 100,000 iterations takes about 8 hours in Leduc Poker, while it takes less than 10 minutes with LiteEFG. In the regime of learning in EFGs, the algorithms usually require extensive hyper-parameter search to enhance the performance (Lee et al., 2021; Liu et al., 2023; Sokota et al., 2023), which further enlarges the gap between LiteEFG and OpenSpiel."}, {"title": "Conclusion", "content": "In this paper, we propose the new computation framework LiteEFG for solving EFGs. It is more computationally efficient compared to previous work. Moreover, users can avoid handling the complex imperfect-information structure of EFGs by using LiteEFG, since the library will automatically process the data flow between decision nodes with imperfect information and real nodes in the game tree. Therefore, LiteEFG would benefit researchers by improving the efficiency of both implementation of the code and computation for algorithms in EFGs."}]}