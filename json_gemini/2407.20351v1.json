{"title": "LiteEFG: An Efficient Python Library for Solving\nExtensive-form Games", "authors": ["Mingyang Liu", "Gabriele Farina", "Asuman Ozdaglar"], "abstract": "LiteEFG is an efficient library with easy-to-use Python bindings, which can solve multiplayer extensive-\nform games (EFGs). LiteEFG enables the user to express computation graphs in Python to define\nupdates on the game tree structure. The graph is then executed by the C++ backend, leading to significant\nspeedups compared to running the algorithm in Python. Moreover, in LiteEFG, the user needs to only\nspecify the computation graph of the update rule in a decision node of the game, and LiteEFG will\nautomatically distribute the update rule to each decision node and handle the structure of the imperfect-\ninformation game.", "sections": [{"title": "Introduction", "content": "The successes of reinforcement learning in solving various games, including Go (Silver et al., 2016, 2017), Atari\n(Mnih et al., 2013), and Dota2 (Berner et al., 2019), have increased interest in developing scalable approaches for\nfinding equilibrium strategies in extensive-form games (EFGs). Compared to Markov games where the game state\nis fully observable, a big challenge in EFG is that decisions are made according to partial observation of the game\nstate. It further results in additional hardness in computing the expected utility of taking an action, unlike Q-values\nin Markov games, since the expected utility depends on the distribution of hidden information. For instance, in Texas\nHold'em, the utility of raising the bid depends not only on the private hands of the decision maker but also on those\nof her opponents, which are unknown when making the decision.\nThe recent interest in computation methods for solving EFGs also sparked activity in developing libraries for exe-\ncuting algorithms over the game tree. A popular library is OpenSpiel (Lanctot et al., 2019), which provides various\ngame environments with an easy-to-use Python API for researchers to test their algorithms. However, the algorithms\noperating over OpenSpiel are usually very slow since they are executed via Python. This motivates the need to de-\nvise a library that incorporates both simple Python API and efficient backend execution, similar to how TensorFlow\n(Abadi et al., 2016) and PyTorch (Steiner et al., 2019) operate.\nTo address the challenge above, we propose LiteEFG, an open-source library with a simple Python API and an effi-\ncient C++ backend for solving EFGs, which is much faster than pure Python execution. With LiteEFG, researchers\nneed to define the update-rule at a decision node in a similar way as defining neural networks with TensorFlow or\nPytorch, then LiteEFG will automatically distribute that update-rule to each individual decision node and handle the\nrelationship between different decision nodes automatically. Compared to OpenSpiel (Lanctot et al., 2019), LiteEFG\nis simpler and faster when solving tabular games (games that may fit into the computer memory). In experiments, the\nclassical baseline, Counterfactual Regret Minimization (Zinkevich et al., 2007), implemented by LiteEFG is about\n100x faster than that of OpenSpiel.\nIn LiteEFG, researchers only need to specify the computation graph of the algorithm via Python. Then, the compu-\ntation graph will be executed via C++, which provides acceleration by several orders of magnitude. Moreover, due\nto the imperfect information of EFG, the game states and decision nodes no longer coincide, which complicates the\nimplementation of the algorithm. To simplify the issue, LiteEFG will automatically aggregate the information from\ndifferent game states belonging to the same decision node 1, so users only need to specify the update-rule for the\ndecision node, without concerning with the aggregation process."}, {"title": "Preliminaries", "content": "In this section, we will introduce the preliminaries of EFGs. We use $ \\Delta^m := \\{x \\in [0,1]^m: \\sum_i x_i = 1\\} $ to denote\nthe m \u2212 1 dimensional probability simplex. For a discrete set C, we use |C| to denote its cardinality. For any real\nnumber x \u2208 R, $[x]_+ := x \\cdot 1_{x>0}$, which is x when x > 0 and 0 otherwise.\nBasics of extensive-form games. In an N-player EFG, we use [N] := {1,2, ..., N} to denote the set of all players.\nOptionally, a fictitious player\u2014called the chance player\u2014is introduced to model stochastic events, such as a random\ndraw of cards or dice roll.\nThe game is a tree structure and we use H to denote the set of all nodes in the game. For each h \u2208 H, one of the\nplayers among {c} U [N], where c is the chance player, will take actions at h. We use p(h) to denote the player"}, {"title": "Tour: Implementation of Counterfactual Regret Minimization (CFR)", "content": "In this section, we will introduce how to use LiteEFG."}, {"title": "Basics of Computation Graph", "content": "LiteEFG is based on the computation graph, in which a vector is stored at each node and users need to define the\nrelationships between graph nodes. For instance, node A equals node B plus node C. Then, every time the user\nupdates the graph, the variables at each graph node will be updated according to the predefined relationship.\nIn LiteEFG, the user need to define the computation graph for an infoset first. Then, the graph will be copied to each\ninfoset in $U_{i \\in [N]} S_i$. Therefore, all infosets share the same relationship between graph nodes, while the variables\nstored in the graph node of each infoset are independent.\nIn LiteEFG, the user can define a node by LiteEFG.function(...) with some function of LiteEFG\u00b3, such as\nLiteEFG.sum and LiteEFG. exp. In this case, LiteEFG will create a new node to store the outcome of the function\nand return that node. Alternatively, the user can update the variable at a node by x. inplace (LiteEFG.function(...)).\nIn this case, LiteEFG will not create a new node. Instead, the outcome of the function will be stored at node x, and\nreplace the original variable at x."}, {"title": "Construction of Computation Graph", "content": "In this section, we will introduce the construction of the computation graph for Counterfactual Regret Minimization\n(CFR) (Zinkevich et al., 2007), one of the most prominent algorithms for solving EFGs, with LiteEFG."}, {"title": "Visitation of Infosets", "content": "LiteEFG provides four types of graph nodes.\n\u2022 LiteEFG.backward(is_static=True): Static backward nodes. These nodes will be executed at initialization\n(ahead of the execution of any other nodes). To execute the static backward nodes, infosets will be visited in\nthe reversed breadth-first order and the corresponding static backward nodes will be executed.\n\u2022 LiteEFG.forward(is_static=True): Static forward nodes. These nodes will be executed at initialization\n(ahead of the execution of any dynamic nodes, but after the static backward nodes). To execute the static\nbackward nodes, infosets will be visited in the breadth-first order and the corresponding static forward nodes\nwill be executed.\n\u2022 LiteEFG.backward(is_static=False): Dynamic backward nodes. These nodes will be executed every time\nthe function LiteEFG.Environment.update is called. To execute the dynamic backward nodes, infosets will\nbe visited in the reversed breadth-first order and the corresponding dynamic backward nodes will be executed.\n\u2022 LiteEFG.forward(is_static=False): Dynamic forward nodes. These nodes will be executed every time\nthe function LiteEFG.Environment.update is called. To execute the dynamic backward nodes, infosets will\nbe visited in the breadth-first order and the corresponding dynamic forward nodes will be executed.\nThe order is also illustrated in Figure 1."}, {"title": "Static Graph", "content": "The update-rule of CFR is as follows. For any player i \u2208 [N], an infoset s \u2208 Si, and action a \u2208 As, the update-rule\nat timestep t \u2208 {1,2, ..., T} is\n$CF^{(t+1)}(s, a) = \\sum_{h \\in s} U_i(h) \\prod_{j \\in \\{c\\} \\cup [N]: j \\neq i} \\mu_{\\pi_j}^{(t+1)}({\\emptyset \\to h}) \\pi_i^{(t+1)}(a|s)$\n$R^{(t+1)}(s,a) = R^{(t)}(s,a) + [CF^{(t+1)}(s,a) - E_{a' \\sim \\pi_i^{(t+1)}(\\cdot | s)}[CF^{(t+1)}(s,a')] ]$\n$\\pi_i^{(t+2)}(a|s) = \\frac{[R^{(t+1)}(s,a)]_+}{\\sum_{a' \\in A_s}[R^{(t+1)}(s,a')]_+ } > 0$\n$\\sum_{a' \\in A_s}[R^{(t+1)}(s,a')]_+ = 0$\n(3.1)\nFrom Equation (3.1), to update CFR, we need to maintain two variables in each infoset s, the strategy $ \\pi_i(\\cdot|s) \\in\n\\Delta^{|A_s|}$, and the regret buffer R(s,\u00b7) \u2208 R|As|. In Figure 2, the green code block defines the static backward nodes of\nCFR algorithm. In line 7, we define expectation, which is the placeholder for $E_{a' \\sim \\pi_i^{(t+1)}(\\cdot | s)}[CF^{(t+1)}(s,a')]$.\nWe\nwill discuss the necessity of such placeholder in Section 3.3.2. Line 8 and 9 initialize $ \\pi_i(\\cdot | s)$ as uniform distribution\nover $ \\Delta^{A_s}$ and R(s,\u00b7) as zero vector individually. The vector at self.action_set_size is a scalar equivalent to\n|As| for each infoset s."}, {"title": "Dynamic Graph", "content": "In this section, we will focus on the red code block in Figure 2.\nLine 15. Line 15 displays the usage of LiteEFG.aggregate."}, {"title": "Loading the Game", "content": "LiteEFG is fully compatible with OpenSpiel, i.e. LiteEFG supports almost all games in OpenSpiel\u2074. Moreover, for\ngames not implemented by OpenSpiel, users can write a game description text file alternatively and load it using\nLiteEFG.FileEnv. An example of the game file is illustrated in Figure 3, and the full example can be found in\nLiteEFG/game_instances/kuhn.game. At the beginning, the game file displays the parameters of the game, where\nthe parameter num_players is necessary and other parameters are optional. The next several lines will include the\nnode information, with an identifier node at the beginning of the line, and the node's name goes after it. For different\ntypes of nodes, the additional information should obey the following rules,"}, {"title": "Training", "content": "In line 19 and line 20 of Figure 4, we load the environment leduc_poker from OpenSpiel to LiteEFG. The\ntraverse_type specifies how to traverse the game tree in each iteration. Currently, LiteEFG supports enumerating"}, {"title": "Evaluation", "content": "In line 28 of Figure 4, we print the exploitability of the strategy stored at graph node graph.strategy. \"avg-iterate\"\nindicates we want to measure that of the average-iterate strategy. LiteEFG.Environment.exploitability returns\na vector v, where each element vi \u2265 0 indicates how much player i can improve her utility by deviating to other\nstrategies while the strategies of other players remain fixed. The sum $ \\sum_{i \\in [N]} v_i$ is the exploitability, which measures\nthe distance to the Nash equilibrium. When the exploitability is zero, it implies that the current strategies of all\nplayers form a Nash equilibrium."}, {"title": "Debug", "content": "To debug the strategy, users can call LiteEFG.OpenSpielEnv.get_strategy to get a pandas. DataFrame as shown\nin Figure 5 to display the strategies.\nMoreover, the user can also interact with the strategy computed by the algorithm, by calling LiteEFG. OpenSpielEnv.interact.\nThe interaction is displayed in Figure 6."}, {"title": "Various Baselines", "content": "Though EFG is developing fast in recent years (Lee et al., 2021; Liu et al., 2023; Sokota et al., 2023), it is hard to\nmake a fair comparison between different algorithms. The difficulty is mainly two-fold. Firstly, some algorithms are\nnot open-sourced and algorithms in EFGs are sensitive to the hyper-parameters. Therefore, when re-implementing\nthe baseline algorithms, researchers may not be able to achieve the same performance as the original paper with\nthe same set of parameters. Moreover, sometimes researchers do not use OpenSpiel or even not using Python to\nimplement their algorithms. Secondly, even though some algorithms are open-sourced (Sokota et al., 2023), they are\nhighly inefficient since they are purely based on Python. As a result, it takes a lot of computation resources and time\nto make a fair comparison with previous results. Therefore, comprehensive and efficient baselines are important for\nthe whole community, and LiteEFG provides a variety of baselines. We list the baseline algorithms in Table 1."}, {"title": "Benchmark", "content": "In this section, we will compare the performance of CFR over LiteEFG and OpenSpiel. All experiments are com-\nputed on Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz. We compare the performance of the baseline\nalgorithm CFR (Zinkevich et al., 2007) and CFR+ (Tammelin et al., 2015) in four classical benchmark games, Liar's\nDice, Leduc Poker (Southey et al., 2005), Kuhn Poker (Kuhn, 1950), and Dark Hex. The results are shown in Fig-\nure 7. To make a fair comparison, we directly call the official C++ implementation of CFR / CFR+ in OpenSpiel by\nopen_spiel.python.algorithms.cfr._CFRSolver.\nWe can see that in Figure 7, LiteEFG provides over 100\u00d7 acceleration in both games, compared to OpenSpiel. In\nOpenSpiel, running CFR+ for 100,000 iterations takes about 8 hours in Leduc Poker, while it takes less than 10\nminutes with LiteEFG. In the regime of learning in EFGs, the algorithms usually require extensive hyper-parameter\nsearch to enhance the performance (Lee et al., 2021; Liu et al., 2023; Sokota et al., 2023), which further enlarges the\ngap between LiteEFG and OpenSpiel."}, {"title": "Conclusion", "content": "In this paper, we propose the new computation framework LiteEFG for solving EFGs. It is more computationally ef-\nficient compared to previous work. Moreover, users can avoid handling the complex imperfect-information structure\nof EFGs by using LiteEFG, since the library will automatically process the data flow between decision nodes with\nimperfect information and real nodes in the game tree. Therefore, LiteEFG would benefit researchers by improving\nthe efficiency of both implementation of the code and computation for algorithms in EFGs."}]}