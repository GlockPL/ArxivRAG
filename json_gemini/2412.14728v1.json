{"title": "LTLf Synthesis Under Unreliable Input (Extended Preprint)*", "authors": ["Christian Hagemeier", "Giuseppe De Giacomo", "Mose Y. Vardi"], "abstract": "We study the problem of realizing strategies for an LTLf goal specification while ensuring that at least an LTL\u0192 backup specification is satisfied in case of unreliability of certain input variables. We formally define the problem and characterize its worst-case complexity as 2EXPTIME-complete, like standard LTL\u0192 synthesis. Then we devise three different solution techniques: one based on direct automata manipulation, which is 2EXPTIME, one disregarding unreliable input variables by adopting a belief construction, which is 3EX-PTIME, and one leveraging second-order quantified LTLf (QLTLf), which is 2EXPTIME and allows for a direct encoding into monadic second-order logic, which in turn is worst-case nonelementary. We prove their correctness and evaluate them against each other empirically. Interestingly, theoretical worst-case bounds do not translate into observed performance; the MSO technique performs best, followed by belief construction and direct automata manipulation. As a byproduct of our study, we provide a general synthesis procedure for arbitrary QLTLf specifications.", "sections": [{"title": "1 Introduction", "content": "One of the key challenges in Artificial Intelligence is to equip intelligent agents with the autonomous capability to deliberate and execute complex courses of action to accomplish desired tasks, see, e.g., the work on reasoning about action (Reiter 2001) and on planning (Ghallab, Nau, and Traverso 2016).\nThe problem we study is related to reactive synthesis in Formal Methods (Pnueli and Rosner 1989; Finkbeiner 2016; Ehlers et al. 2017), which shares deep similarities with planning in fully observable nondeterministic domains (FOND, strong plans (Cimatti, Roveri, and Traverso 1998; Geffner and Bonet 2013)). A reactive synthesis setting is characterized by (boolean) variables, partitioned into input and output variables, changing over time. We have two entities acting in this setting: the environment that controls the input variables (or fluents, in planning terminology), and the agent who controls the output variables (or actions, in planning terminology). Given a specification, the agent has to find a strategy (or plan in planning terms) to choose its outputs to fulfil the specification by suitably reacting to the inputs chosen (possibly adversarially) by the environment.\nIn Formal Methods, the most common specification formalism is Linear Temporal Logic (LTL) (Pnueli 1977). In AI, a finite trace variant of LTL (LTLf) is popular (Gabbay et al. 1980; Baier and Mcilraith 2006; De Giacomo and Vardi 2013; De Giacomo and Rubin 2018). The interest in finite traces is due to the observation that, typically, intelligent agents are not dedicated to a single task (specification) all their lives but are supposed to accomplish one task after another. In this paper, we will focus on LTLf as a specification language.\nNote that in reactive synthesis, at any point, the agent observes the current input and, based on its value (along with previous input values), decides how to react by choosing an appropriate output towards satisfying the specification. Interestingly, machine-learning techniques are bringing about notable advancements in sensing technologies (i.e., generation of input), as showcased by the success of vision and autonomous driving techniques. However, machine-learning techniques are typically data-oriented and hence have a statistical nature that may generate occasional unreliability of the input produced. Consider a surgical robot that uses machine-learning models to interpret sensory data and guide its actions with precision during complex medical procedures. Due to the inherent imprecision of the input models, it may misinterpret a critical piece of data regarding the patient's anatomy (for instance, the robot might incorrectly identify a blood vessel as a different tissue type due to subtle variances in the imaging data that were not accounted for in the training phase of the AI model). This misinterpretation can lead the robot to make an inaccurate incision, potentially causing unintended harm to the patient.\nIn this paper, we study how to address such potential unreliability in the values of input variables in reactive synthesis. One way to address this unreliability is to disregard the unreliable input completely and not consider it in choosing the next output (Bloem et al. 2019). This is related to planning/synthesis under partial observability (Rintanen 2004; De Giacomo and Vardi 2016; Kupferman and Vardi 2000; Ehlers and Topcu 2015). However, this might be too radical and could drastically reduce the agent's ability to operate, considering that the unreliability we are considering is only occasional. Our objective instead is to ensure that the system maintains functionality and adheres to critical specifications, despite uncertain and unreliable inputs. If the uncertainty is quantifiable, we could rely on probabilities turning to MDPs (Baier and Katoen 2008; Geffner and Bonet 2013) or Stochastic Games (Kwiatkowska 2016). Yet, as stated in a report by the White House, \"software does not necessarily conform neatly to probabilistic distributions, making it difficult to apply statistical models or predictions commonly used in other scientific disciplines\" (Office of the National Cyber Director 2024). Here we aim at exploring a novel synthesis method to manage the potential unreliability of input variables obtained without relying on probabilities.\nThe crux of our approach is not to give up on using input variables that might be unreliable but to complement them with the guarantee that even when they behave badly, some safeguard conditions are maintained. Specifically, we consider two models simultaneously, a brave model where all input variables are considered reliable (as usual in synthesis), and a cautious one where unreliable input is projected out and discarded (De Giacomo and Vardi 2016). Using these two models, we devise a strategy that simultaneously fulfils the task objectives completely if the input variables behave correctly and maintains certain fallback conditions even if the unreliable input variables behave wrongly.\nOur contributions are the following:\n\u2022 A formalization of LTLf synthesis under unreliable input, which follows the framework described above.\n\u2022 The computational characterization of the problem in terms of worst-case complexity as 2EX\u0420\u0422\u0406\u041c\u0415-complete, as standard LTL\u0192 synthesis.\n\u2022 Three provably correct synthesis techniques, one based on a direct method, one based on a belief construction and one based on solving synthesis for QLTL\u0192 formulas, where QLTLf, second-order quantified LTLf, is the finite trace variant of QLTL (Sistla, Vardi, and Wolper 1985; Calvanese, Giacomo, and Vardi 2002).\n\u2022 The three techniques have different complexities: the direct one is 2EXPTIME, the one based on a belief construction is 3EXPTIME, and one based QLTLf is 2EXPTIME, but also admits a direct encoding in monadic second-order logic over finite sequences (MSO), which is non-elementary.\n\u2022 An experimental assessment of the three synthesis techniques. Interestingly, the theoretical worst-case bounds do not translate into observed performance; the MSO technique performs best, followed by belief construction and direct automata manipulation.1\nAs a side result, we present a synthesis technique for arbitrary QLTLf specifications."}, {"title": "2 Preliminaries", "content": "Definition 1. The language of LTL\u0192 is defined by\n$\\varphi := A | \\neg \\varphi | \\varphi \\land \\psi | o\\varphi |\\varphi U \\psi$\nwith $A \\in P$, where $P$ is a set of propositional variables.\nOther modalities, like Weak Next (${\\bigcirc} := \\neg o \\neg \\varphi$), Eventually ($\\Diamond \\varphi$), and Always ($\\Box \\varphi$), can be defined.\nDefinition 2 (LTLf semantics). Given a trace $t \\in (2^P)^+$, the satisfaction relation $t, i \\models \\varphi$ is defined inductively for $1 \\leq i \\leq length(t) = last$:\n\u2022 $t, i \\models A$ iff $A \\in t(i)$\n\u2022 $t, i \\models \\neg\\varphi$ iff $t, i \\not\\models \\varphi$\n\u2022 $t, i \\models \\varphi \\land \\psi$ iff $t, i \\models \\varphi$ and $t, i \\models \\psi$\n\u2022 $t, i \\models o\\varphi$ iff $i < last$ and $t, i + 1 \\models \\varphi$\n\u2022 $t, i \\models \\varphi U \\psi$ iff for some $j$ with $i \\leq j \\leq last$ we have $t, j \\models \\psi$ and for all $k$ with $i \\leq k < j$ we have $t, k\\models\\varphi$.\nWe say that a trace satisfies an LTLf-formula, written as $t \\models \\varphi$, iff $t, 1 \\models \\varphi$.\nSynthesis under full observability. Classical LTLf synthesis refers to a game between an agent and the environment. Both control a subset of the variables of an LTLf-formula $\\varphi$, which the agent tries to satisfy.\nAn agent's strategy is a function $\\sigma : (2^X)^* \\rightarrow 2^Y$. The strategy $\\sigma$ realizes a formula if, for any infinite sequence $X = (X_0, X_1, . . . ) \\in (2^X)^\\omega$, there exists a k$\\in$ N such that the finite trace $t = ((X_o, Y_o), . . ., (X_k, Y_k))$ satisfies $\\varphi$ (i.e. $t \\models \\varphi$), where $Y_i = \\sigma(X_0, . . ., X_{i-1})$.\nDFA Games. The standard technique for solving LTLf synthesis works by reducing it to solving a reachability game on a DFA (De Giacomo and Vardi 2013). A DFA game is also played between two players, the agent and the environment. They have corresponding sets of boolean variables X, Y. The specification of a game is given by a DFA $G = (2^{X \\cup Y}, S, s_0, \\delta, F)$ where $2^{X \\cup Y}$ is the alphabet, S the set of states, the initial state $s_0$, total transition function $\\delta : S \\times 2^{X \\cup Y} \\rightarrow S$ and the set of final states $F \\subseteq S$. A play on a DFA game is a sequence $p = ((s_{0,0}, X_0 \\cup Y_0), (s_{i,1}, X_1 \\cup Y_1), ...) \\in (S \\times 2^{X \\cup Y})^+ $ with $s_{i,j+1} = \\delta(s_{i,j}, X_i \\cup Y_i)$. Such a play is winning if it ends in a final state. We say that a player has a winning strategy in a DFA game if they can choose the variables in a way that guarantees to end up in a final state regardless of how the other player responds."}, {"title": "3 LTLf Synthesis under Unreliable Input", "content": "Before formalizing the problem, we introduce some additional notation. The projection function $proj_V(t)$ removes all variables in $V$ from a trace t over propositional variables P. The expansion function $exp_V(t)$ takes a trace t over variables P (with $V \\cap P = \\emptyset$) and returns all traces t' by setting variables in V in every possible way at all instants of t. For traces t and t', $t \\sim_{-V} t'$ means $t \\in exp_V(proj_V(t'))$. Slightly abusing notation, we use the same syntax to denote two subsets of P being equal up to elements of V. We model uncertainty about the environment by assuming the agent cannot rely on the readings of certain environment variables; thus, we require that after any changes in these readings still satisfy a backup condition; this leads to the following formalization:\nDefinition 3 (LTLf synthesis under unreliable input). Given LTLf-formulas $\\varphi_m$, $\\varphi_b$ over variables $X \\cup Y$, called respectively the main and backup specification, and a partitioning $X = X_{rel} \\cup X_{unr}$ of the input variables into reliable and unreliable ones respectively, solving LTLf synthesis under unreliable input amounts to finding a strategy $\\sigma: (2^{X})^* \\rightarrow 2^Y$ such that for any infinite sequence of variables $X = (X_0, X_1,...) \\in (2^X)^\\omega$ there is an index k $\\in$ N such that\n1. The finite trace $t = ((X_o, Y_o), ..., (X_k, Y_k))$ with $Y_i = \\sigma(X_0, ..., X_{i-1})$ satisfies $\\varphi_m$, i.e., $t \\models \\varphi_m$,\n2. and every t' with $t' \\sim_{-X_{unr}} t$ satisfies $\\varphi_b$, \u0456.\u0435., $t' \\models \\varphi_b$.\nOur problem extends standard LTLf synthesis by using $\\varphi_b$ as a backup formula and $X_{unr} = \\emptyset$. Since LTLf synthesis is 2EXPTIME-complete (De Giacomo and Vardi 2013), our problem is 2EXPTIME-hard. We later show a matching upper bound (see Theorem 10).\nThe problem is also related, however distinct, to LTLf synthesis under partial observability (De Giacomo and Vardi 2016). If the main specification goal is trivial (i.e. setting $\\varphi_m := \\top$), our problem degenerates into LTLf synthesis under partial observability.\nLet us illustrate the problem with some examples, which are designed such that by suitably choosing parameters, realizability can be controlled. The full descriptions and formulas can be found in Appendices B to D, respectively."}, {"title": "4 Technique 1: Direct Automata", "content": "Recall that we can essentially view the problem as the agent having to satisfy two goals in the brave and cautious arena simultaneously. This suggests combining an arena for the main goal under full observability with an arena for the backup goal under partial observability. We first describe the construction before showing correctness. It has three main ingredients: an automaton recognizing the main formula, one for the backup formula under partial observability and the correct combination of these, the synchronous product.\nDefinition 7 (Synchronous Product of DFAs). Given two DFAS $G_i = (2^{X} \\times 2^{Y}, S_i, s_{0,i}, \\delta_i, F_i)$ (for i$\\in$ {1,2}, and defined over the same alphabet), we define their synchronous product as $G_1 \\otimes G_2 = (2^{X} \\times 2^{Y}, S_1 \\times S_2, (s_{0,1}, s_{0,2}), \\delta', F')$, where $\\delta'((s_1,s_2), \\sigma) = (\\delta_1(s_1, \\sigma), \\delta_2(s_2, \\sigma))$ and $F' = F_1 \\times F_2$.\nLet us now describe the construction of the automaton for the backup formula under partial observability:\n\u2022 First, we create an NFA for the complement of the formula, i.e. $A_{\\neg \\varphi}$.\n\u2022 Next, we existentially abstract over the unreliable inputs $U_1,...,U_n$, yielding an NFA $(A_{\\neg \\varphi})_{\\exists U_1,...,U_n}$, which we formally define in Definition 8.\n\u2022 Lastly, we determinize the NFA using subset construction. We then complement the final DFA obtaining our final automaton $\\mathcal{D}((A_{\\neg \\varphi})_{\\exists U_1,...,U_n})$.\nFormally, we can define the existential abstraction:\nDefinition 8. Given an NFA $N = (2^{X \\times 2^{Y}}, S, \\delta, s_0, F)$, we define the existentially abstracted NFA $N_{U_1,...,U_n} = (2^{X \\times 2^{Y}}, S, \\delta', s_0, F)$ by setting\n$\\delta'(s, (X, Y)) = \\{s' | \\exists X'.X \\sim_{-U_1,...,U_n} X' \\land s' \\in \\delta(s, (X', Y))\\}$.\nTheorem 9. Solving synthesis for the synchronous product of the LTLf-automaton for $\\varphi_m$, $A_{\\varphi_m}$, and the automaton $\\mathcal{D}((A_{\\neg \\varphi})_{\\exists U_1,...,U_n})$ solves synthesis under unreliable input.\nTheorem 10. The outlined technique has worst-case complexity of 2EXPTIME.\nProof. Constructing the DFAs for $\\varphi_m$ is 2EXPTIME; the NFA for $\\varphi_b$ is EXPTIME. Determinizing the NFA after projection adds another exponential. Synchronous product and reachability game are polynomial."}, {"title": "5 Technique 2: Belief-States", "content": "De Giacomo and Vardi (2016) also investigate a second technique for generating an automaton to solve the game under partial observability, namely the belief-state construction, that we can basically use as an alternative to constructing an automaton for the backup formula under partial observability, keeping the other steps identical.\nDefinition 12 (Belief State DFA Game). Given a DFA game $A = (2^{X \\cup Y}, S, s_0, F)$ with input variables partitioned into $X = X_{rel} \\cup X_{unr}$, we define the belief-state game $G_{rel} = (2^{X \\cup Y}, B, B_0, \\delta, F)$ as follows: $B = 2^S$ (the power set of states), $B_0 = \\{s_0\\}$ (the initial state lifted to the power set), $\\delta : B \\times 2^{X \\cup Y} \\rightarrow B$ defined by\n$\\delta(B, (X \\cup Y)) = \\{s' | \\exists s \\in B \\exists X'.X \\sim_{-X_{unr}} X' \\land \\delta(s, (X' \\cup Y)) = s'\\}$,\nand $F = 2^F$ (the final states of the game).\nWith this definition, we can show correctness and characterize the complexity.\nTheorem 13. Solving synthesis for the synchronous product of the LTLf-automaton for $\\varphi_m$, $A_{\\varphi_m}$, and the belief-state automaton $G_{rel}$ solves synthesis under unreliable input.\nTheorem 14. Solving synthesis with backup using the belief-state construction yields a 3EXPTIME algorithm.\nProof. This follows from the fact that constructing the belief-state automaton takes 3EXPTIME (construction of the DFA from the formula takes 2EXPTIME, then the belief-state construction costs another exponential); generating the DFA for the main formula takes 2EXPTIME, the other steps are polynomial.\nThe belief state construction can also be implemented symbolically efficiently, similar to the subset construction for the direct approach (Tabajara and Vardi 2020)."}, {"title": "6 Quantified LTLf Synthesis", "content": "Our third technique builds on translating the problem into synhesis for QLTLf, which is a variant of QLTL, that similarly adds second-order quantification over propositional variables to LTLf. In this section, we present a general algorithm for QLTLf synthesis. We then cast synthesis under unreliable input as a special case of this problem and show that for such formulas, the general algorithm matches the 2EXPTIME bound. A QLTLf formula is given by the following grammar (X denotes a second-order variable):2\n$\\varphi := X | \\neg \\varphi | \\varphi \\land \\psi | o\\varphi |\\varphi U \\psi | \\exists X.\\varphi$\nThe satisfaction relation for QLTL\u0192 is defined as for LTLf, with an additional clause for the second-order quantifier:\n$t, i \\models \\exists X.\\varphi := \\exists t'.t \\sim_{-X} t' \\land t', i \\models \\varphi$\nUniversal quantification in QLTL\u0192 is defined as $\\forall X.\\varphi := \\neg \\exists X.\\neg \\varphi$; other modalities are defined as in LTLf. More informally, the existential quantifier '$\\exists x.$' in QLTLf states that there is at least a way to modify where in the trace a variable x holds, thereby making the formula true. A formula is in prenex normal form (PNF) if it is of the form $Q_1 X_1. Q_2 X_2.... Q_n X_n .\\varphi$ where $\\varphi$ is an LTLf-formula and $Q_i \\in {\\forall, \\exists\\}$. Any formula can be polytime-transformed into PNF, similar to QLTL (Piribauer et al. 2021). The alternation count of a formula in PNF is the number of indices i s.t. $Q_i \\neq Q_{i+1}$.\nTheorem 15. Synthesis for a QLTLf-formula $\\psi$ with k alternations can be solved in (k + 2)-EXPTIME.\nTheorem 16. A strategy $\\sigma$ realizes the instance of LTLf synthesis under unreliable input with $X_{unr} = \\{U_1,..., U_n\\}$ iff it realizes synthesis for the QLTLf formula $\\varphi_m \\land \\forall U_1....\\forall U_n.\\varphi_b$.\nTheorem 17. Solving LTLf synthesis under unreliable input by translating into QLTLf has complexity 2EXPTIME."}, {"title": "7 Technique 3: MSO Encoding", "content": "Exploiting Theorem 16 we now propose a third solution technique for LTLf synthesis under unreliable input. Specifically, we start from the QLTLf specification $\\varphi_m \\land \\forall U_1....\\forall U_n.\\varphi_b$ translate it into monadic second-order logic (MSO), and then use MONA to obtain the DFA corresponding to the original specification (for synthesis under unreliable input). Then we can solve the DFA game, just like in standard LTLf synthesis. In fact, this approach also works for synthesis of arbitrary QLTLf formulas.\nFormulas of MSO are given by the following grammar (x, y denote first-order variables, and X denotes a second-order variable):\n$\\varphi := X (x) | x < y | (\\varphi \\land \\psi) | \\neg \\varphi | \\exists x.\\varphi | \\exists X.\\varphi$.\nWe then consider monadic structures as interpretations that correspond to traces. We use the notation $t, [x/i] \\models \\varphi$ to denote that this interpretation of second-order variables (details in Appendix A), with assigning i to the FO-variable x satisfies $\\varphi$. We can then give a translation and show its correctness:\nDefinition 18. We define a translation mso from QLTLf to MSO by setting (we use standard abbreviations for succ(x, y), $x \\leq y$, and $x \\leq last$):\n$\\begin{array}{lll}\nmso(X, x) & := & X(x) \\\\\nmso(\\neg \\varphi, x) & := & \\neg mso(\\varphi,x) \\\\\nmso(\\varphi \\land \\psi, x) & := & mso(\\varphi, x) \\land mso(\\psi, x) \\\\\nmso(\u039f\\varphi, x) & := & \\exists y.succ(x, y) / mso(\\varphi, y) \\\\\nmso(\\varphi U \\psi, x) & := & \\exists y.(x \\leq y \\leq last) \\land mso(\\psi, y) \\\\\n& & \\land \\forall z.(x < z < y \\rightarrow mso(\\varphi, z)) \\\\\nmso(\\exists X.\\varphi, x) & := & \\exists X.mso(\\varphi, x)\\n\\end{array}$\nTheorem 19. For any closed QLTLf formula $\\varphi$ and finite trace t, $t, i \\models \\varphi$ iff $t, [x/i] \\models mso(\\varphi,x)$.\nThis translation gives us the following technique to solve synthesis for a QLTL\u0192 formula. Once we have translated the formula to MSO, we can use MONA to obtain the DFA and then play the DFA game to solve synthesis.\nTheorem 20. The technique for QLTLf synthesis is correct.\nTheorem 21. The technique to solve synthesis under unreliable input with LTLf main specification $\\varphi_m$ and LTLf backup specification $\\varphi_b$, based on synthesis for the QLTLf formula $\\psi = \\varphi_m \\land \\forall U_1....\\forall U_n.\\varphi_b$, is correct."}]}