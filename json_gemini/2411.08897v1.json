{"title": "A Reply to \"Is Complexity An Illusion?\"", "authors": ["Gabriel Simmons"], "abstract": "The paper \"Is Complexity an Illusion?\" (Bennett, 2024) provides a formalism for complexity, learning, inference, and generalization, and introduces a formal definition for a \"policy\". This reply shows that correct policies do not exist for a simple task of supervised multi-class classification, via mathematical proof and exhaustive search. Implications of this result are discussed, as well as possible responses and amendments to the theory.", "sections": [{"title": "In appreciation:", "content": "The paper \"Is Complexity an Illusion?\u201d (Bennett, 2024) provides a formalism to talk about complexity, learning, inference, and generalization, among other things. These concepts are all at the heart of the field of artificial intelligence. The paper offers an exciting perspective on abstraction, namely that the notion of complexity is relative to the choice of an abstraction layer. As a result, (absolute, observerindependent) complexity is an illusion. The paper also claims to show that in choosing a proxy, one should seek to maximize policy weakness rather than minimizing complexity\u00b9. As I understand it, this paper extends and challenges the discourse around AIXI and Legg-Hutter intelligence (Legg & Hutter, 2007), (Hutter, 2005; Leike & Hutter, 2015), familiar concepts to those interested in AGI theory. Bennett questions the centrality of \u201ccomplexity\u201d and provides insight as to why Occam's Razor holds true so much of the time, despite there being no clear justification for why this should be so."}, {"title": "Correct policies may not exist for simple tasks", "content": "Criticism: The criticism presented here is that simple tasks may be constructed for which no correct policies exist. This is shown through an enumeration of the possible policies in the next section. I also provide a Python program that iterates over all possible policies to prove the claim exhaustively.\nWhy does this matter?: Many of the exciting claims of Bennett's paper are about policies and how to find them. While the theory is abstract, I am optimistic that it has implications for practical Al systems. I would hope that \"policies\u201d in the abstract sense bear some resemblance to \u201cpolicies\u201d in commonplace Al systems like reinforcement learning agents or supervised classifiers. Likewise for tasks - I would hope that the theory could be used to reason about commonplace tasks like image classification or game playing.\nI believe that the example presented in this reply is isomorphic to a very simple task with the following form:"}, {"title": "Definitions", "content": "I refer the reader to (Bennett 2024) Section 2 (\"The Formalism\") for definitions of the following terms: state, environment, declarative program, fact, vocabulary, formal language, statement, completion, extension of a statement, extension of a set of statements, task, policy, and correct policy.\nIn brief (all definitions from Bennett 2024):\n\u2022 A set \u03a6 is assumed, whose elements are called states.\n\u2022 f \u2286 \u03a6 is a declarative program. A declarative program is set of states.\n\u2022 P = PP\u03a6 is the set of all possible declarative programs, the power set of \u03a6.\n\u2022 A subset v \u2286 P is a vocabulary.\n\u2022 A vocabulary implies a formal language \\(L_{v}\\) = {l \u2286 v : \u2229 l \u2260 \u2205}, whose members l \u2208 \\(L_{v}\\) are called statements.\n\u2022 A completion of a statement x is any statement y such that x \u2286 y.\n\u2022 The extension of a statement is the set of all completions. For statement x in \\(L_{v}\\), its extension \\(E_{x}\\) = {y \u2208 \\(L_{v}\\) : x \u2286 y}\n\u2022 The extension of a set of statements X \u2286 \\(L_{v}\\) is \\(E_{X}\\) = Ux\u2208X \\(E_{x}\\), the union of the extensions of the statements in X.\n\u2022 A v-task (hereafter, \u201ctask\u201d) \u03b1 is a pair \u3008\\(I_{\u03b1}\\), \\(O_{\u03b1}\\)\u3009 where \\(I_{\u03b1}\\) \u2286 \\(L_{v}\\) are the inputs and \\(O_{\u03b1}\\) \u2286 \\(E_{v}\\) are the correct outputs.\n\u2022 A policy is a statement in \\(L_{v}\\).\n\u2022 A policy \u03c0 is a correct policy for task \u03b1 (written \u03c0\u2208 \\(\u03a0_{\u03b1}\\)) if and only if \\(E_{I_{\u03b1}}\\) \u2229 \\(E_{\u03c0}\\) = \\(O_{\u03b1}\\)."}, {"title": "Result", "content": "I will now present a simple task for which no correct policy exists.\nConsider an environment with 5 states.\nRecall that a declarative program is a set of states. The notation \"01111\" is used to denote a program that returns true in all states except state 1. The notation \"10111\" is used to denote a program that returns true in all states except state 2, and so on.\nConsider the following four declarative programs:\nf\u2081 = 01111   f\u2082 = 10111\nf\u2083 = 11011   f\u2084 = 11101\nWe could use an alternative notation like the below:"}, {"title": null, "content": "Consider the following task a:\n\\(I_{\u03b1}\\) = {{f1}, {{2}}\n\\(O_{\u03b1}\\) = {{f1, \u00a33}, {f2, f4}}\nClaim: No correct policy exists for the task a above.\nProof: This can be done by considering all policies. Recall that a policy is a statement in the vocabulary, and the set of all statements is the power set of the vocabulary.\nThere are 24 = 16 possible statements in the language \\(L_{v}\\), one of which is the empty set. These are the set of possible policies.\nWe can write down the extension of the inputs:\n\\(E_{I_{\u03b1}}\\) = \\(E_{{fi}}\\) U \\(E_{{f2}}\\)\n= {{f\u2081}, {f2}, {f1, f2}, {f1, \u00a33}, {f1, \u00a34}, {\u00a32, \u00a33}, {\u00a32, \u00a34},\n{f1, f2, 3}, {f1, 3, 4}, {f1, f2, f4}, {\u00a32, 3, 4}, {f1, f2, 3, 4}}\nTo check if a policy is correct, we are interested in determining if \\(E_{I_{\u03b1}}\\) \u2229 \\(E_{\u03c0}\\) = \\(O_{\u03b1}\\). The extension of a policy is the set of statements in the language for which the policy is a subset. Since we know we will take an intersection with \\(E_{I_{\u03b1}}\\), we can ignore statements not appearing in \\(E_{I_{\u03b1}}\\). In other words, we can view the policy as selecting from the set of statements in \\(E_{I_{\u03b1}}\\). This selection must equal \\(O_{\u03b1}\\) for the policy to be correct.\nAt this point we can observe that a correct policy for a cannot contain more than 2 elements. All statements in the extension of a policy with 3 or more elements will themselves have 3 or more elements, since the extension of a statement is the set of all its completions. Since our set of correct outputs consists of statements of length 2, a policy with 3 or more elements cannot select statements in \\(O_{\u03b1}\\). So we must only consider policies of length 0, 1, or 2 as candidates for correct policies. We proceed to check each case.\nFor the length 0 case with \u03c0 = 0, \\(E_{I_{\u03b1}}\\) \u2229 \\(E_{\u03c0}\\) = \\(E_{I_{\u03b1}}\\) \u2229 \\(L_{v}\\) = \\(E_{I_{\u03b1}}\\). See Appendix 3. Since \\(O_{\u03b1}\\) \u2286 \\(E_{I_{\u03b1}}\\) (the outputs are strictly a subset of the extension of the inputs), \\(E_{I_{\u03b1}}\\) \u2260 \\(O_{\u03b1}\\). So \u03c0 = \u00d8 is not a correct policy. (It may be surprising that empty policies do belong to \\(L_{v}\\), for any choice of v. See Appendix 2.)\nNext we consider an example of the length 1 case. For \u03c0= {f\u2081}, the pol- icy overlaps with \\(E_{I_{\u03b1}}\\) on those entries containing f\u2081, namely \\(E_{I_{\u03b1}}\\) \u2229 \\(E_{\u03c0}\\) = {1}, {f1, f2}, {\u00a31, f3}, {f1, \u00a34}, {f1, f2, \u00a33}, {\u00a31, f3, \u00a34}, {f1, f2, \u00a34}, {f1, f2, \u00a33, f4}. This is not equal to \\(O_{\u03b1}\\), so \u03c0is not a correct policy.\nLikewise, \u03c0 = {f2} selects 8 statements from \\(E_{I_{\u03b1}}\\), \u03c0 = {f3} selects 6 statements, and \u3160 = {f4} selects 6 statements. None of these policies are correct, since \\(O_{\u03b1}\\) consists of only 2 statements.\nThis leaves only the length 2 case. For the length 2 case, there are 6 possible policies to consider. Each of these length-2 policies has a length-3 completion in its extension that is also found in \\(E_{I_{\u03b1}}\\). Since \\(O_{\u03b1}\\) does not contain any length-3 statements, the intersection \\(E_{I_{\u03b1}}\\) \u2229 \\(E_{\u03c0}\\) cannot be equal to \\(O_{\u03b1}\\) in any of the 6 cases.\nAs the correct policy must have length 0, 1, or 2, and no correct policy exists among these, no correct policy exists for the task a."}, {"title": "Discussion", "content": "Relevance to real-world tasks\nFirst, I would like to explain the isomorphism between the colored box task on the first page, and the task a used in the proof. My hope in this section is that readers who view the task a in the proof above as contrived will see it as a natural way to represent a common machine learning task.\nLet f\u2081 denote something like \u201cthe box is actually red\u201d, or \u201ca camera recorded high signal intensity in its red channel\u201d. Let f2 denote something like \u201ca typical human would think the image is red\u201d. Similar logic applies for f2 (the box is actually blue), and f\u2081 (a typical human would think the image is blue). My rationale for choosing this task is that it is a simplied version of the task that an image classifier performs. That is, mapping low-level information about pixels to higher-level concepts like \u201cred\" and \"blue\"3. The colored box task can be seen as an extremely simplified case with a single pixel.\nIn the example task a, there are some declarative programs that serve as \u201clabels\u201d. These are the programs only appearing in \\(O_{\u03b1}\\) and not in \\(I_{\u03b1}\\). Likewise there are some programs that serve as \u201cfeatures\u201d - these are the programs appearing in \\(I_{\u03b1}\\). I have adopted a convention where the task inputs are \"labeled\" by appending a \u201clabel program\" (f3 or f\u2081) in the example to the set of features to obtain the output. To me this seems the most natural way to represent a classification problem.\nPossible responses\nReaders might respond that the task setup is not the correct, conventional, or expected way that Bennett's framework would be applied. Bennett's work is recent, so I imagine a convention has not yet been established. Part of my aim in writing this reply is to encourage work in this direction.\nReaders might contend that the example is too simple. One could argue that it is too much of a simplification to use only 1 program for each input \u2013 typical machine learning problems use tens, hundreds, or thousands of features. I would argue in response that a framework that can handle such complex problems should also be able to handle simpler ones, and conjecture (without having verified this) that the results would hold even if f\u2081 and f\u2082 were replaced with larger sets of programs.\nImplications for the theory\nAs it stands, it seems difficult to represent multi-class classification tasks, or any tasks requiring conditional behavior in Bennett's framework. It is straightforward to train a machine learning classifier to represent a policy like \u201clabel all images that contain wheels as car, unless there are also train tracks, in which case the correct label is train\u201d. It seems natural that \u201cimage-is-a-car\u201d and \u201cimage-is-a-train\u201d should be part of the vocabulary, and that the policy should be able to select from these. But since the policy is a statement, it can include only one of these \"label\u201d facts. Including both would not allow the policy to select from correct outputs with only one of these labels.\nPerhaps it makes sense to view a \u201ctask\u201d in Bennett's framework as a binary classification task. Machine learning practitioners are aware that a multi-class classification task can be decomposed into a series of binary classification tasks. In this case, perhaps a \u201cpolicy\" for the multiclass task would be better represented by a set of statements, each one performing a binary classification. The definition for inference from Bennett's paper would need almost no adjustment, since the \u201cextension\u201d operation accommodates both statements and sets of statements.\nPerhaps my intuition that labels can be represented as programs is false - perhaps there should not be an \"image-is-a-train\u201d fact. In this case, it seems important for the theory to provide an alternative way to represent \"labels\" in the practical machine learning sense."}, {"title": "Appendix 1", "content": "This Python program exhaustively checks all non-empty policies for correctness with respect to the task a. Empty policies can be included in \\(L_{v}\\) (see Appendix 2), but are not checked here since it is trivial to show that the empty policy is not a correct policy (see \u201cResult\u201d section).\nfrom itertools import chain, combinations\nfrom pprint import pprint\nfrom typing import Collection\nshow_work = True # set to True to see the work for each policy\ndef powerset(iterable):\n# https://stackoverflow.com/questions/1482308/how-to-get-all-subsets-of-a-set-powerset\n# modified so that the empty set is not included\n# this is a convenience. The empty set _is_ included in languages L_v in general, # but is trivially not a correct policy and makes the programming less convenient\n\"powerset([1,2,3]) --> (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\ns = list(iterable)\nreturn [\nfrozenset(x)\nfor x in chain.from_iterable (combinations(s, r) for r in range(0, len(s) + 1))\n]\ndef print_statement(statement: frozenset):\npprint(sorted (statement, key=len))\nassert bool(int(\"0\")) == False\nassert bool(int(\"1\")) == True\ndef non_null_intersection(programs: Collection [str]) -> bool:\nif len(programs) == 0:\nreturn False\nlength_to_check = max(map(len, programs))\nfor i in range(length_to_check):\nif all(bool(int(p[i])) for p in programs):\nreturn True\nreturn False\nassert non_null_intersection([\"01\", \"11\"])\nassert not non_null_intersection ([\"01\", \"10\"])\nassert non_null_intersection([\"011\", \"111\"])\nassert not non_null_intersection([\"011\", \"100\"])\ndef extension_of_statement(statement: frozenset, L_v: frozenset) -> frozenset:\nif statement not in L_v:\nraise ValueError\nreturn frozenset({y for y in L_v if statement.issubset(y)})\ndef extension_of_set_of_statements(\nstatements: frozenset [frozenset], L_v: frozenset\n) -> frozenset:\nreturn frozenset(\nchain.from_iterable(extension_of_statement(s, L_v) for s in statements)\n)\n# Let there be 5 states\n# A declarative program is a set of states\n# The set of all possible programs is the power set of the set of all states\n# We are allowed to take a subset of all possible programs to form a vocabulary.\n# let us take the following subset of programs:\n# We can identify four programs with non-null intersection\nf_1 = \"01111\" # program f_1 includes all states except state 1\nf_2 = \"10111\" # program f_2 includes all states except state 2\nf_3 = \"11011\" # program f_3 includes all states except state 3\nf_4 = \"11101\" # program f_4 includes all states except state 4\n# all programs f_1, f_2, f_3, f_4 include state 5\n# In this string notation, a program includes state i if the i-th character is 1, # and excludes it if the i-th character is 0\nv = {\nf_1,\nf_2,\nf_3,\nf_4,\n}\nif show_work:\nprint(\"v:\")\npprint(v)\nprint(\"\")\nassert non_null_intersection({f_1, f_2, f_3, f_4})\n# From our vocabulary, we define a formal language - this is the set of all # sets of facts that are realized by the environment, meaning there is at least one state # that is shared by all programs in the set\nL_v = frozenset({l for l in powerset (v) if non_null_intersection(l)})\nif show_work:\nprint(\"L_v:\")\nprint_statement (L_v)\nprint(\"\")\n# now we can test the extension of a statement, and extension of a set of statements:"}, {"title": null, "content": "statement1 = frozenset({f_1, f_2})\nassert extension_of_statement(statement1, L_v) == frozenset(\n{\nfrozenset({f_1, f_2}),\nfrozenset({f_1, f_2, f_3}),\nfrozenset({f_1, f_2, f_4}),\nfrozenset({f_1, f2, f_3, f_4}),\n}\n)\nstatement2 = frozenset({f_2, f_3})\nassert extension_of_statement(statement2, L_v) == frozenset(\n{\nfrozenset({f_2, f_3}),\nfrozenset({f_2, f_3, f_1}),\nfrozenset({f_2, f_3, f_4}),\nfrozenset({f_2, f_3, f_1, f_4}),\n}\n)\nassert (\nextension_of_set_of_statements (frozenset({statement1, statement2}), L_v)\n== extension_of_statement(statement1, L_v).union(\nextension_of_statement(statement2, L_v)\n)\n== frozenset(\n{\nfrozenset({f_1, f_2}),\nfrozenset({f_1, f_2, f_3}),\nfrozenset({f_1, f_2, f_4}),\nfrozenset({f_1, f_2, f_3, f_4}),\nfrozenset({f_2, f_3}),\nfrozenset({f_2, f_3, f_1}),\nfrozenset({f_2, f_3, f_4}),\nfrozenset({f_2, f_3, f_1, f_4}),\n}\n)\n# For programming convenience, this script ignores the empty set.\nassert len(powerset (v)) == 2 ** len(v) == 16\nassert len (L_v) == 15\n# Now we will show that no correct policy exists for a simple task that is compatible with Definition 3 from Bennett 2024\n# we can construct a task as follows, # where I_alpha is the set of task inputs, # and 0_alpha is the set of correct outputs:\nI_alpha = frozenset(\n{\nfrozenset({f_1}),\nfrozenset({f_2}),\n}\n# frozenset is used to make the inner sets hashable, so the larger set 0 can be defined\n0_alpha = frozenset(\n{\nfrozenset({f_1, f_3}),\nfrozenset({f_2, f_4}),\n}\n)\n# This task satisfies the requirements in Defintion 3, namely that # I is a proper subset of L_v\nassert I_alpha.issubset (L_v) and I_alpha != L_v\n# - 0_alpha is a subset of the extension of I_alpha\nassert 0_alpha.issubset (\nextension_of_set_of_statements (I_alpha, L_v)\n) and 0_alpha != extension_of_set_of_statements (I_alpha, L_v)\n# Is there a correct policy for the task alpha>? # According to the paper, a policy pi is correct if (E_i sect E_pi) = 0_alpha\n# A policy is a statement pi in L_v # Let's iterate over all possible policies\ncorrect_policy_exists = False\nfor i, policy in enumerate (L_v):\npolicy_extension = extension_of_statement(policy, L_v) # E_pi\ninput_extension = extension_of_set_of_statements (I_alpha, L_v) # E_i\nintersection_of_extensions = policy_extension.intersection(input_extension)\nif show_work:\nprint(f\"\\n----------- policy :------------\")\nprint(f\"policy {i}:\")\nprint_statement(policy)\nprint(f\"\\npolicy {i} extension:\")\nprint_statement (policy_extension)\nprint(f\"\\ninput extension:\")\nprint_statement(input_extension)\nprint(f\"\\nintersection of extensions:\")\nprint_statement(intersection_of_extensions)\nprint(f\"\\n0_alpha:\")\nprint_statement (0_alpha)\nif intersection_of_extensions == 0_alpha:\nprint(\"correct policy\")\ncorrect_policy_exists = True\nprint(f\"correct policy is policy {i}:\")\nprint_statement (policy)\nprint(\"\\nAll policies checked\")\nif not correct_policy_exists:\nprint(\"no correct policy exists\")"}, {"title": "Appendix 2", "content": "Claim: Given some set of states \u03a6, for any vocabulary v \u2286 \u0420\u0424, \u00d8 \u2208 Lv.\nProof:\nWe know that L\u2081 = {l \u2286 v : \u2229 l \u2260 ()} (definition of a formal language, Bennett).\nThus \u2208 L iff \u00d8 \u2286 v and \u2229 \u00d8 \u2260 0.\nFor any choice of v, \u00d8 \u2286 v is true. The empty set is a subset of all sets.\nWhen is the empty set of subsets of some set X, \u2229 (0) = X56. In our case \u00d8 is the empty set of declarative programs, the programs being subsets of \u03a6. Thus for any choice of v, \u2229 ) = \u03a6 \u2260 0 is true.\nThus\u2208 L is true for all v."}, {"title": "Appendix 3", "content": "Claim: For some set of states \u03a6, for any vocabulary v \u2286 P\u03a6, \u0395\u00f8 = Lv.\nProof:\nE = {y \u2208 L: x \u2286 y} (definition of extension, Bennett)\nE\u2081 = {y \u2208 L\u2082 : \u00d8 \u2286 y}\n\u00d8 C y for all y \u2208 L\u300f(the empty set is a subset of all sets)\nE\u2081 = {y \u2208 L} = Lv"}]}