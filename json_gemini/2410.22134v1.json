{"title": "PROMOE: Fast MoE-based LLM Serving using Proactive Caching", "authors": ["Xiaoniu Song", "Zihang Zhong", "Rong Chen"], "abstract": "The promising applications of large language models are often constrained by the limited GPU memory capacity available on edge devices. Mixture-of-Experts (MoE) models help mitigate this issue by activating only a subset of the model's parameters during computation, allowing the unused parameters to be offloaded to host memory and reducing overall GPU memory demand. However, existing cache-based offloading solutions handle cache misses reactively and significantly impact system performance. In this paper, we propose PROMOE, a novel proactive caching system that leverages intermediate model results to predict subsequent parameter usage. By proactively fetching experts in advance, PROMOE removes the loading time from the critical path and diminishes the performance overhead of offloading. Our evaluations demonstrate that PROMOE achieves an average speedup of 2.13\u00d7 and 2.84\u00d7 in the prefill and decode stages respectively, compared to existing offloading solutions.", "sections": [{"title": "Introduction", "content": "Large language models (LLMs) have transformed fields such as natural language processing and content generation and decision support [10, 29, 38, 43, 51]. While traditionally deployed in data centers with high-end GPUs, there's growing interest in running LLMs on consumer-grade platforms for better privacy and speed [12, 41, 49]. However, this faces significant challenges due to memory constraints. The substantial memory needs of LLMs (hundreds of GBs) [29, 43, 51] often surpass consumer-grade GPU capacities (dozen GBs). This memory constraint causes major performance issues, hindering efficiency and adoption of LLMs on personal computers.\nMixture-of-Experts (MoE) [15, 17, 27, 28, 48] offers an opportunity to address GPU memory constraints for LLMs by dividing the model into multiple experts, activating only a few during inference. This allows offloading most expert parameters to host memory, loading only necessary ones into GPU memory. Although this significantly reduces GPU memory requirements, Expert offloading also introduces severe performance degradation up to 8.9\u00d7 [30] due to limited PCIe bandwidth between host and GPU memory (32GB/s unidirectional on PCIe 4.0).\nResearchers have recently proposed caching frequently-accessed expert parameters in GPU memory to minimize offloading cost [18]. However, caching handles missing experts in a reactive manner. Specifically, the miss is triggered passively when an expert is accessed in inference, leaving the expensive expert loading on the critical path (see Figure 1). For example, when caching 50% of experts in deepseek-moe [4] model, the time spent on loading missing experts occupies over 60% of the total inference time. Moreover, the inherent low skewness and poor locality of expert access patterns in MoE models, especially for modern decoder-only architectures, significantly limit the improvement that can be brought by finding better cache policies.\nIn this paper, we propose PROMOE, a novel system addressing performance challenges associated with offloading in MoE-based LLMs through proactive caching, as shown in Figure 1. By actively predicting which experts will be needed and prefetching their parameters into expert cache in GPU memory, the time of fetching missing experts can be taken off from critical path, allowing for better overlap with computation and enhancing overall performance and GPU utilization.\nTo achieve effective proactive caching, PROMOE needs to answer two questions. First, due to the dynamic nature of MoE models, PROMOE necessitates a predictive approach for prefetching. To judge the quality of a prediction method, PROMOE proposes a GOODPRED metric that considers both the accuracy and lead time of prediction. To achieve high GOODPRED, PROMOE introduces a learned predictor to prefetch experts in a sliding-window approach. The learned predictor utilizes historical information to make accurate predictions of expert selections across multiple layers in advance, achieving high GOODPRED to ensure prefetching completes in time.\nSecond, the prefetch and inference process may interfere with each other, resulting in low utilization of GPU, cache, and bandwidth for prefetching. PROMOE needs to carefully coordinate the execution of prefetching and inference to mitigate the interference. We observe that the required experts for each layer are known all at once. This leaves us"}, {"title": "Background", "content": "Large Language Models (LLMs) perform inference in two stages: prefill and decode, as shown in Figure 2(a). During the prefill stage, the model processes the user's input prompt in a single iteration. The tokens in the prompt are processed in parallel by the model, and the first token of the response is generated at the end of the iteration. In the decode stage, each iteration processes only one token generated from the previous iteration and generates the next token. These tokens are sequentially fed into the model and eventually concatenated to form the complete response. Due to the differences in the scale of computations between the two stages of LLM inference, their performance is typically measured separately. The performance of the prefill stage is usually quantified by the Time to First Token (TTFT), which represents the duration users wait for the LLM to process the prompt before beginning to generate output. For the decode stage, performance is commonly measured by the rate at which the LLM generates tokens, expressed as either Tokens Per Second (TPS) or Time Per Output Token (TPOT).\nLarge Language Models (LLMs) consist of a series of transformer layers. Each layer contains a self-attention block (self-attn) and a feed-forward network (FFN), as illustrated in Figure 2(b). These components process input hidden states, add the results back to the input, and pass them to the next layer. Due to layer normalization, the outputs are numerically smaller than their inputs, causing a slow change in hidden states across layers [33, 36]. Typically, the cosine similarity between hidden states of adjacent layers is around 90% on average.\nThe Mixture-of-Experts (MoE) architecture enhances LLMs by expanding the FFN into multiple experts, as shown in Figure 2(c). This approach increases the model's parameters while reducing overall computation, as only a subset of experts is activated during each forward pass. Specifically, each MoE block consists of a gate function and multiple experts. The gate function prioritizes experts, selecting which ones should process the current token. Each expert is structurally similar to the original FFN but with fewer parameters. The MoE block's output is a weighted average of the outputs from all activated experts.\nIn MoE-based LLMs, expert selection occurs independently for each token, as shown in Table 1. When processing multiple tokens simultaneously (e.g., processing prompts or batching multiple requests), a larger portion of experts is activated, ranging from over 50% to nearly 100%, depending on the number of tokens."}, {"title": "Caching MoE-based LLMs", "content": "In MoE-based LLMs, each token only utilizes a subset of experts. The majority of experts can be offloaded to CPU memory, with only the necessary experts loaded into GPU memory. This allows MoE-based LLMs to run on consumer-grade hardware that has limited GPU memory. However, due to the limited PCIe bandwidth, directly offloading parameters to CPU memory results in high latency and low GPU utilization. For example, when running the DS-1 model with 50% experts offloaded to CPU memory, the TPOT is 67.9ms, while fetching experts from host memory takes 58.1ms, which accounts for 85.6% of the total time. Each output token requires 2.67GiB of expert parameters in fp16 precision, where 1.33GiB needs to be transferred from CPU memory to GPU memory due to offloading. The achieved bandwidth is 23 GB/s, which matches the achievable bandwidth (23.9GB/s in our bandwidth test) from host to GPU of PCIe 4.0x8.\nTo mitigate the performance issues caused by offloading, the traditional method is to cache frequently accessed experts on the GPU. A common approach is to use LRU (Least Recently Used) or static caching to store these frequently accessed experts in GPU memory. For instance, Mixtral-offloading [18] implements an LRU cache for the Mixtral model. Another example is CUDA's Unified Memory (UM) that leverages a paging mechanism to transfer data between GPU and CPU on-demand.\nThe major issue of caching in MoE is its reactive nature when handling cache misses. When the inference process encounters an expert missing in GPU memory, the computation is blocked until the expert is fetched from host memory. This leaves high latency overhead in the critical path of inference. We evaluated the performance of LRU caching in transformers [44] with DS-1 (fp16) model and llama.cpp [22] with QW-2 (int4) model. Figure 3 and Figure 4 show the inference latency and the time breakdown of both prefill and decode stages. For the DS-1 model, caching 50% of experts still leads to 60.4% blocking time on the critical path during the decode stage. The blocking time on the prefill stage is more severe, since more experts are accessed, leaving 82.7% blocking time on the critical path. As for llama.cpp, which conducts faster inference by removing the overhead of Python interpreter, the ratio of blocking time is even higher. Caching 50% of"}, {"title": "Overview of PROMOE", "content": "This paper presents PROMOE, a system that achieves low-latency MoE-based LLM inference on consumer-grade platforms. PROMOE notices the reactive nature of existing solutions that passively trigger data transfers on the critical path of inference and cause high latency. To address this issue, PROMOE adopts a proactive caching approach. Proactive caching doesn't aim to reduce data transfers between CPU and GPU directly. Instead, it moves data transfers out of the critical path, allowing them to overlap with inference.\nThe architecture of PROMOE is illustrated in Figure 6. PROMOE consists of two main components: the predictor and prefetcher. The predictor periodically predicts the selection of experts. Based on these predictions, the prefetcher preloads experts into the GPU cache. During inference, the LLM inference engine accesses experts in the cache and triggers misses for absent experts. Compared to existing solutions, most expert data transfers in PROMOE occur outside the critical path of inference, reducing latency and improving GPU utilization.\nTo achieve effective proactive caching, PROMOE needs to answer the questions of \u201cwhat to prefetch\u201d and \u201chow to prefetch\" as mentioned in \u00a71. PROMOE's predictor tackles the first question by making good predictions. To define a good prediction, PROMOE proposes a GOODPRED metric that takes both the accuracy and lead time of prediction into consideration. Based on this metric, PROMOE introduces a learned predictor to prefetch experts in a sliding-window manner. The learned predictor utilizes historical information to make accurate predictions of expert selections across multiple layers in advance, allowing prefetch to complete in time.\nPROMOE's prefetcher addresses the second question by carefully coordinating prefetching and inference processes. Naive prefetching can cause interference between these processes, leading to suboptimal performance. PROMOE leverages the observation that the choice of experts for each layer becomes available all at once after the gating function. Based on this insight, PROMOE proposes three key techniques to coordinate prefetching and inference, improving their overlap: chunked prefetch, early preemption, and reordered inference. These techniques work in concert to minimize interference and maximize overlap between prefetching and inference, thereby reducing inference latency."}, {"title": "Goodpred and Learning-based Predictor", "content": "The dynamic nature of MoE models requires PROMOE to deploy a predictor to make approximate predictions of experts for prefetching. To support sufficient prefetching, there are two key requirements for the predictor: accuracy and lead time. In this section, we first define a key metric GOODPRED that combines these two aspects to measure how well a predictor performs. Then we introduce PROMOE's learned predictor and describe how it achieves high GOODPRED."}, {"title": "Key Metric for Predictor", "content": "A good predictor requires both high accuracy and lead time. High accuracy ensures correct experts are prefetched, while lead time allows prefetch to start earlier, providing more opportunity for prefetching to complete in time. These two aspects must be satisfied simultaneously to achieve a good predictor. An accurate predictor with low lead time cannot fetch experts in time, while a predictor with high lead time but low accuracy makes little progress in prefetching."}, {"title": "Existing Approaches", "content": "There are two representative methods for predicting the experts. However, both methods fail to achieve high GOODPRED, as they suffer from either low ACCURACY or FETCHRATE.\nRecent works [28, 46] suggested a token-based method that predicts the usage of experts based on the input token. These works indicate that the selection of experts in one iteration is highly related to the input token id. An intuitive explanation is that LLMs convert input token id to an embedding vector using a fixed mapping, and the computation of one iteration in LLM can be viewed as a process that gradually adds context information to the embedding. Therefore, the input token id can be used to predict the selection of experts of all layers in this iteration. Specifically, in the offline stage, a trace of input token ids and the selected experts is collected. During online inference, the predictor predicts the experts of one iteration by finding the most frequently used experts in the trace according to the input token id.\nThis prediction method enables an iteration-wise prefetch manner, as illustrated in Figure 7(a). The iteration-wise prefetch manner fixes a maximum predict distance k = i and provides high FETCHRATE\u00a1(k), since all prediction results are made before the iteration starts, leaving sufficient time for prefetching. However, the token-based prediction method suffers from low ACCURACY. We show the prediction accuracy of each layer in DS-2 model in Figure 8(a). On average, the token-based prediction accuracy is only 54%. This low accuracy is because the input token id lacks the context information of the entire sequence, which changes the embedding vector and the output of gate function during the iteration. As the iteration progresses to later layers, the accuracy slowly drops to less than 50%. Though the token-based prediction method provides high FETCHRATE by enabling iteration-wise prefetching, the low ACCURACY makes almost half of the prefetching useless, resulting in a low GOODPRED.\nAnother recent system [18] proposed a skip-based prediction method. It creates a skip connection that sends the input of i-th layer's MoE gate directly to the MoE gate in i + 1-th layer, thereby predicting the experts of i + 1-th layer at the time of i-th layer. This approach takes advantage of the high similarity between inputs across different layers in LLMs [33, 36]. For example, in the DS-2 model, the cosine similarity between consecutive layers' inputs is 91.7%. Therefore, passing the input of i-th layer to the i + 1-th layer's gate is likely to produce correct predictions.\nThis prediction method forms a layer-wise prefetch manner, as illustrated in Figure 7(b). As the prediction is conducted in a per-layer manner, it provides high ACCURACY;(k) of 90.5% on average. However, the layer-wise prefetch suffers from low FETCHRATE;(k) by fixing k = 1. This method can only predict the experts for one layer ahead, leaving less chance for prefetching to complete in time. Therefore, the skip-based prediction also results in a low GOODPRED."}, {"title": "Sliding-window Prefetching", "content": "To improve GOODPRED\u00bf(k), an intuitive idea is to conduct skip-based prediction with increased k. This forms a sliding-window prefetching, as illustrated in Figure 7(c). As shown in the figure, the input from i-th layer is used to directly predict the experts for i + k-th layer. Given larger k, there will be more chances that the prefetch can complete in time, providing higher FETCHRATE;(k).\nHowever, the major issue of skip-based prediction across multiple layers is that ACCURACY\u00bf(k) decreases rapidly as k increases. We show the prediction accuracy of model DS-2 as the window k increases in Figure 8(a). As k increases from 1 to 8, the average ACCURACY\u00a1 (k) across all layers decreases from 90.5% to 54.5%. As k further increases, the accuracy of skip-based prediction becomes even worse than token-based prediction, as shown in Figure 8(b). The reason behind this is that the similarity between inputs across different layers drops rapidly as k increases (58.5% at k = 8 for DS-2 model). In practice, we also find several cases that lead to a sharper decrease of skip-based prediction's accuracy. We show two cases in Figure 9, where the accuracy quickly drops to less than 30% in layer 16, and is quite unstable in layer 27. This is because in QW-2 model, the gate produces minor differences in priority when selecting experts. Therefore, the skip-based prediction is more likely to produce a priority of experts that is different from the correct one. This sharp drop of ACCURACY;(k) significantly impacts the GOODPRED, leaving no improvement on the amount of correct experts that can be prefetched in time as k increases."}, {"title": "Learning-based Predictor", "content": "PROMOE achieves high GOODPRED by proposing a learned predictor to maintain ACCURACY in sliding-window prefetching. The main idea is to collect historical traces of layer inputs and expert selections across layers, and memorize the correlation between them. Then the predictor utilizes these correlations to conduct prediction. Compared to the skip-based prediction that relies on the similarity of inputs that drops rapidly as k increases, the learned predictor can maintain high ACCURACY;(k) under large k with the assistance of historical information, achieving high GOODPRED;(k) in conjunction with FETCHRATE;(k).\nTo leverage those historical informations, PROMOE's learned predictor uses a small neural network to learn the correlation between layer inputs and expert selections. Small neural networks like MLP has been well-applied and validated in various scenarios of system research [24, 31, 36, 41]. It can learn complex correlations and conduct fast prediction that is hard for traditional heuristic methods to achieve. The advantage of neural networks-based method comes with the cost of long training time. In the scenario of serving LLMs, the offline training is a one-time-task for one LLM and is negligible comparing to the long pre-training time of LLMs [29].\nThe learned predictor in PROMOE operates in two phases: offline training and online prediction. In the offline phase, PROMOE first defines a set of predictors. To conduct sliding-window prefetching with window size k in a n layer model, PROMOE creates n predictors. The i-th predictor is responsible for predicting the output of layer i's gate using input of layer i - k's gate. To collect the training data, PROMOE runs LLM inference for multiple iterations, with input and output of each layer's gate collected. Then PROMOE trains these predictors using the collected traces.\nDuring the online inference, the input of gate in each layer is collected and fed into the corresponding predictor(s) to conduct prediction. The output of prediction, similar to a gate's output, is the prefetch priority of experts in one layer. Based on the prediction output, the predictor picks the same amount of experts that the model would activate for one token (e.g. 6 for DS-1 model in Table 1), and hands over these experts to the prefetcher for prefetching.\nTo minimize the impact of the prediction process on the overall inference latency, PROMOE executes the predictor on the CPU to overlap with the LLM inference. In practice, each layer's predictor in PROMOE is implemented as a two-layer MLP with a parameter size of approximately 2M. When performing inference on the CPU, the latency of a single predictor is about 200us. This latency is negligible compared to the per-layer computation time of LLMs, which is on the order of milliseconds. Since the CPU-based prediction process can run in parallel with the LLM inference on GPU, it does not introduce latency overhead to the overall inference. The training of learned predictor and collection of training data takes less than 1 2 hours on a single GPU. This is a one-time offline task and can be parallelized across multiple GPUs. Comparing to the long pre-training time of LLMs, we consider this time cost acceptable.\nThe prediction accuracy of PROMOE's learned predictor is also included in Figure 8 and Figure 9. To conduct a fair comparison of GOODPRED; (k) of different prediction methods, we compare different prediction methods under the same k, which produces the same FETCHRATE\u00a1(k), leaving only ACCURACY(k) as the variable. Figure 8(a) shows the accuracy of different layer i under a fixed set of k \u2208 {1, 2, 4, 8}. Figure 8(b) and Figure 9 fix target layer i and compare the accuracy as k changes. As shown in the figures, the learned predictor maintains a higher accuracy even under high k, providing high GOODPRED\u012f (k) to support PROMOE's prefetch effectively."}, {"title": "Coordination of Prefetching and Inference", "content": "The prefetcher in PROMOE is responsible for fetching experts into the GPU cache based on prediction results. It consists of a worker thread and a task queue. The worker thread retrieves prefetch tasks from the queue and copies the corresponding experts to the GPU's expert cache. The task queue maintains two priority levels: low-priority speculative prefetch tasks provided by the predictor, and high-priority precise prefetch tasks triggered by cache misses during LLM inference. The worker thread always prioritizes the execution of high-priority tasks over low-priority ones.\nTo further coordinate the prefetching process with LLM inference, PROMOE introduces a series of optimizations to reduce the interference of prefetching on inference, as illustrated in Figure 10."}, {"title": "Chunked Prefetch", "content": "When adding high-priority prefetch tasks to the queue, there is usually an ongoing fetching of expert parameters from CPU to GPU. This fetching may originate from an incomplete prefetch task of the current layer, or from a prefetch task of subsequent layers that has already begun. Due to the limitations of CUDA's asynchronous copy mechanism, an ongoing copy operation cannot be preempted mid-way. Consequently, high-priority prefetch tasks must wait for the current copy operation to complete before they can start. This delay in starting high-priority prefetch tasks introduces unnecessary latency to the critical path.\nTo address this issue, PROMOE introduces chunk-based prefetch. The key idea is to split the parameters of each expert into multiple chunks. When prefetcher receives predicted experts from predictor, it splits the parameters of each expert into multiple chunks and adds them to the prefetch queue as low-priority tasks. Each task represents a chunk of an expert's parameters, rather than the entire expert. Therefore, the worker thread schedules low-priority tasks at a smaller granularity. When a high-priority prefetch task arrives, the worker thread can quickly switch to the high-priority task with a maximum delay of one chunk.\nFigure 10 shows an example of chunked prefetch. The cache miss of expert 2 is triggered after the execution of expert 1. Since prefetcher is already working on a low-priority task, it has to wait until it completes before starting to handle the high-priority task of expert 2. With chunk-based prefetch, the low-priority task is broken into 3 chunks. The cache miss is triggered when the prefetcher is working on the second chunk, and the high-priority task of expert 2 can start immediately after the second chunk is completed. In practice, we found that experts in MoE models all have the same structure, consisting of three linear layers. Therefore, PROMOE naturally splits each expert into three chunks, corresponding to the three linear layers. By implementing chunked prefetch, PROMOE reduces the delay in starting high-priority prefetch tasks, further improving the critical path latency."}, {"title": "Early Preemption", "content": "Even though PROMOE's predictor strives to maximize prediction accuracy, mispredictions are still inevitable. This results in required experts not being present in the GPU cache, triggering on-demand copying of missing experts on the critical path. Traditionally, these misses are only detected and handled when the corresponding expert is accessed during inference. This approach causes the inference process to be blocked while waiting for the missing expert parameters to be copied from CPU memory to GPU, leading to under-utilization of GPU. Consequently, this introduces high fetch latency on the critical path of inference execution.\nTo address this issue, PROMOE proposes an optimization of early preemption. We made a key observation that in MoE models, the set of experts required for the current layer is determined all at once when the gate operation completes. Instead of triggering a cache miss when each individual expert is accessed, the system can preempt the prefetch queue in advance when it knows which experts will be used after the gate operation. Thereby, the prefetch of missing experts can be initiated much earlier and overlap with the computation of the current layer. Figure 10 shows an example of early preemption. With early preemption, the miss of expert 2 is triggered right after the gate operation, rather than after expert 1's computation. Therefore, the high-priority task of expert 2 gets scheduled by prefetcher before the second chunk of the low-priority task.\nIn practice, PROMOE implements early preemption by inserting a hook at the end of the gate function to obtain the list of required experts in advance. These experts are then added to the prefetch queue as high-priority precise prefetch tasks, ensuring that the prefetch thread prioritizes these tasks. During this process, there may still be some low-priority speculative prefetch tasks for the same layer in the queue that are not yet complete. Since the system already has the accurate list of required experts, these low-priority tasks can be discarded. The prefetch thread simply clears any remaining low-priority speculative prefetch tasks with the same layer, thereby achieving preemption.\nDuring inference, when encountering an expert not in the cache, PROMOE no longer triggers a miss but instead waits for the corresponding prefetch task to complete. This approach allows for earlier initiation of accurate prefetching, increasing the overlap between prefetching and computation, and ultimately reducing latency on the critical path."}, {"title": "Reordered Inference", "content": "In the inference process of LLMs, existing frameworks typically execute computations for different experts in the order of their IDs. This computation order fails to fully utilize the cache status of experts, leading to unnecessary blocking and potential cache thrashing. Consider the example in Figure 10, where experts 1, 4, 5 are cached, and expert 2 is missing. Since the computation goes by the order of expert ID, experts 4, 5 have to wait for the prefetch of expert 2 to complete before they can start. Therefore, the GPU is underutilized while waiting for the prefetch of expert 2, even though experts 4, 5 are already prefetched. More critically, the prefetch of a missing expert might evict other soon-to-be-accessed experts, causing cache thrashing. This issue is particularly severe when accessing a large number of experts sequentially, such as during the prefill stage of inference.\nTo address this issue, PROMOE proposes reordered inference, which changes the computation order of experts in a cache-aware manner. We observe that in MoE models, the computation order of experts is interchangeable. There is no dependency between the computations of different experts, as their outputs are simply added together. This property allows us to adjust the computation order of experts based on their cache and prefetch status, making the inference process cache-friendly.\nSpecifically, after the gate operation completes, PROMOE adjusts the computation order accordingly. Experts already in the cache are prioritized, followed by the experts currently being prefetched (if any), while experts whose prefetch has not yet begun are ordered last. Consider the example in Figure 10. As the gate produces 1, 2, 4, 5, where expert 2 is missing, PROMOE changes the computation order of experts to 1, 4, 5, 2. Therefore, the prefetching of expert 2 can be overlapped with the computation of experts 4, 5, which further reduces the impact of prefetching on the critical path.\nIn practice, the reordering process occurs simultaneously with early preemption. After obtaining the list of experts to be accessed, PROMOE first reorders the experts as described above. Experts whose prefetching is not yet complete are handled by early preemption and added to the prefetch queue as high-priority tasks. The entire reordered expert sequence will then be returned to the inference framework for execution. This approach ensures that for experts with incomplete prefetches, both the prefetch threads and inference threads process them in the same order, further establishing a pipeline between computation and prefetching."}, {"title": "Implementation", "content": "PROMOE is implemented as an extension to LLM frameworks, with 6600 lines of C++ code. We integrated PROMOE into transformers and llama.cpp, two popular LLM frameworks. To integrate PROMOE into existing LLM frameworks, we added hooks for capturing MoE layer input logits and re-ordering experts, while also implementing a dependency mechanism to ensure efficient prefetching and computation. PROMOE also takes over the memory management for expert parameters. We did not integrate PROMOE with frameworks like vLLM and TGI due to their focus on batched inference for data centers and poor support for quantized MoE at the time of submission."}, {"title": "Evaluation", "content": "The evaluation is conducted on a PC with an NVIDIA RTX 4090 GPU (24GB GDDR6X). The PC is equipped with an Intel i9-14900K CPU and 64GB host DRAM. The GPU is connected to the CPU through PCIe 4.0 with a unidirectional bandwidth of 32GB/s.\nWe evaluated on a wide range of MoE-based LLMs, as listed in Table 1. By default, we evaluate DS-1, DS-2 and QW-1 at FP16 precision, and QW-2 and Mixt at INT4 precision. We also include a separate evaluation that controls the parameter size from FP16 to INT4 to study its impact on the performance. We use the shareGPT dataset [3], which includes user interactions with ChatGPT and is the most representative example of real LLM services.\nOur evaluation uses two popular codebases: Hugging Face transformers [23, 44] and llama.cpp [22]. Transformers supports widest range of models and is easy to deploy, but lacks optimal inference performance. We improved the efficiency of MoE block by reducing CPU-GPU synchronization. Llama.cpp, written in C++, provides state-of-the-art inference performance by eliminating Python interpreter overhead.\nBoth systems offer offloading baselines: transformers offloads only parameters to CPU (named TO), while llama.cpp offloads both parameters and computations (named LO). We enhanced TO with pinned memory and asynchronous copies. We integrated PROMOE into both codebases and added three baselines: Unified Memory (UM), Static cache and LRU cache. These baselines and PROMOE only handles expert parameters, while non-expert parameters always reside on GPU. The UM baseline is optimized using cudaMemAdvise to allow instant page invalidation without the cost of swapping pages back to CPU memory. The Static baseline caches a fixed set of expert and uses two additional expert buffers to load missing experts.\nWe measure the performance of PROMOE and baselines in prefill and decode stages separately. The performance of prefill stage is measured by TTFT (Time To First Token), reflecting the latency that the system takes to process user's prompt. The performance of decode stage is measured by TPS (Tokens Per Second) and TPOT (Time Per Output Token), measuring the throughput and latency of the decode stage. We mainly report TPS as it's more intuitive, and switch to TPOT when conducting breakdown analysis."}, {"title": "Overall Performance", "content": "Figure 11 shows the overall performance of prefill and decode stages in the transformers codebase. In prefill stage, PROMOE outperforms static and LRU baselines by 1.52\u00d7 and 2.32\u00d7 on average. The improvement of PROMOE mainly comes from its prefetching technique that maximizes the overlap of loading parameters and computing. When comparing PROMOE with LRU, the higher improvement comes from the cache thrashing that LRU causes, as we mentioned in Section 5.3. In prefill stage, almost all experts are accessed, since each token in the prompt usually requires a different set of experts. As the experts are accessed in the order of their IDs, LRU evicts an already cached expert with a higher ID, since it's accessing a missing expert with a smaller ID first. The static cache avoids thrashing by fixing its cache set, while PROMOE reorders experts to avoid thrashing and further reduces the blocking time caused by missing experts on the critical path.\nIn decode stage, PROMOE outperforms static and LRU baselines by 1.52\u00d7 and 1.33\u00d7 on average. LRU outperforms static cache in decode stage, since cache thrashing happens much less in decode stage, and there's still a slight reuse of experts across iterations. PROMOE outperforms these baselines by taking most copies of missing experts off the critical path through prefetching.\nThe TO (UM) baseline consistently performs worse than Static (LRU) baseline. This is because our Static and LRU baselines can be viewed as better implementations of static and dynamic cache, respectively. In static cache, the TO baseline also offloads non-expert parameters to CPU, while the Static baseline only offloads parameters of experts. In dynamic cache, the UM baseline fetches parameters at the granularity of page, which amplifies the amount of transferred data compared to the LRU baseline. In follow-up experiments, we mainly focus on the comparison between static, LRU and PROMOE.\nFigure 12 shows the overall performance in the llama.cpp codebase. PROMOE outperforms static and LRU baselines by 1.36x and 2.12\u00d7 on average in the prefill stage, and by 1.49\u00d7 and 1.09\u00d7 on average in the decode stage, respectively. The improvement in llama.cpp codebase follows the same trend as that in transformers. However, the improvement is less than that in transformers. This is because the llama.cpp codebase removes the overhead of Python interpreter during inference, leaving less opportunity for PROMOE to prefetch experts.\nThe UM baseline consistently performs worse than LRU baseline as expected. The LO baseline in llama.cpp offloads both parameters and computations to CPU. In most cases, it's slower than the static baseline. However, when evaluating with Mixt model, the LO baseline is significantly faster, and even outperforms PROMOE at decode stage. This is because the Mixt model activates a larger ratio of experts (25%) for each token, making the cost of fetching parameters to GPU much higher than directly computing them on CPU. We believe this does not affect the importance of our work, since most recently released MoE-based LLMs activate a small ratio of experts (10% on average), and the TO baseline is much slower in all other cases."}, {"title": "Ablation Study", "content": "Figure 13 shows the performance in the transformers codebase with different optimizations in PROMOE enabled, starting from the LRU baseline. In prefill stage, simply enabling prefetching brings little improvement, even degrading the performance. This is because almost all experts are accessed, while prefetching alone simply replaces the cache set. Moreover, naive prefetching delays the handling of missing experts. The early-preemption and reordered-inference techniques bring most of the improvement, with 1.27\u00d7 and 2.29\u00d7 speedup compared to the base, respectively. As for the decode stage, each technique gradually improves the performance, achieving a 1.37\u00d7 improvement in the end compared to the base. Figure 14 shows the same ablation study in the llama.cpp codebase. The trend is similar to that in transformers codebase, except that the improvement in prefill stage is mostly brought by the reordered-inference technique."}, {"title": "Impact of Cache Rate", "content": "We also study how the cache rate affects the performance of PROMOE. Figure 15 and Figure 16 show the performance of prefill and decode stages of"}]}