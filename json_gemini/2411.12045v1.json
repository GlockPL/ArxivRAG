{"title": "Fingerprinting and Tracing Shadows: The Development and Impact of Browser Fingerprinting on Digital Privacy", "authors": ["Alexander Lawall"], "abstract": "Browser fingerprinting is a growing technique for identifying and tracking users online without traditional methods like cookies. This paper gives an overview by examining the various fingerprinting techniques and analyzes the entropy and uniqueness of the collected data. The analysis highlights that browser fingerprinting poses a complex challenge from both technical and privacy perspectives, as users often have no control over the collection and use of their data. In addition, it raises significant privacy concerns as users are often tracked without their knowledge or consent.", "sections": [{"title": "I. INTRODUCTION", "content": "In the increasingly digitized world, the issues of online privacy and data security are becoming more complex. Particularly in tracking \u2013 monitoring users and their devices across different web servers browser fingerprinting has emerged as an effective technique for creating detailed user profiles. Unlike the storage of information via cookies, which requires explicit user consent as mandated by the European General Data Protection Regulations (GDPR) guidelines, fingerprinting does not require such consent. A browser fingerprint can be generated in the background without any obvious signs to the end user, leaving them unaware of whether and to what extent they are being tracked.\nIt is possible to manipulate a device locally to alter its fingerprint. This is often not feasible for all users, unlike deleting cookies. This invisible threat is not apparent to the general public and raises significant privacy concerns, as individuals can be tracked unnoticed. These profiles can contain private information, depending on the server operators, including age group, ethnic origin, social circles, and interests of the affected person.\nBrowser fingerprinting poses a threat to the privacy of the general public. Contrary to being a threat, it is an opportunity to provide valuable information to enhance the authentication mechanisms. Both perspectives are explored throughout this paper. The focus will be on the various techniques of fingerprinting to understand how accurate and detailed user profiles can be created. The main research questions that this paper seeks to answer are:\nRQ1 \"What methods are used in browser fingerprinting and what user data are collected in the process?\"\nRQ2 \"How has the development of browser fingerprinting as a user identification method influenced user privacy and data protection in the digital space?\"\nThe paper is structured as follows: Section I introduces browser fingerprinting and its privacy implications. In Section II, the theoretical background explains how fingerprinting works and its legal challenges. Section III outlines techniques like HTTP Headers, Canvas, and WebGL Fingerprinting. Section IV examines the impact of fingerprinting on privacy and the regulatory landscape. Section V concludes with a summary of the findings, emphasizing the need for stronger privacy measures and further research on countermeasures."}, {"title": "II. THEORETICAL BACKGROUND", "content": "Browser fingerprinting refers to collecting characteristic information that the browser directly or indirectly reveals about itself. Often used to track users, this technology has also found applications in IT security, such as fraud detection. Unlike tracking methods like cookies, browser fingerprinting does not require storing data on the user's computer, allowing the process to occur secretly and without consent [1, p. 1]. Consequently, creating a new identity, similar to deleting cookies, is not easily achievable, and GDPR privacy laws often provide little protection. Unlike cookie tracking, browser fingerprinting is not explicitly mentioned in the GDPR. It should fall under the collection of identifiable information but website operators frequently claim \u201clegitimate interest\", enabling such data collection without the user's consent [2].\nActive transmission of data is not required for browser fingerprinting, as loading a webpage can transmit various pieces of information, such as the user's preferred language, within the HTTP headers. This passive data collection provides only a limited amount of information, so it is often supplemented with active data collection methods. An active approach typically employs JavaScript to interface with the browser and gather information, such as screen resolution, installed add-ons, and graphics card data, merging them into a unique fingerprint [3, pp. 1, 3].\nSimilar to human fingerprints, browser fingerprinting relies on the uniqueness of browser characteristics, which typically do not change significantly with regular use. This allows for accurate user identification over extended periods [3, p. 2]. However, not all collected data points are equally unique or stable, necessitating careful selection of information to achieve accurate results. The fingerprinting algorithm combines both passively and actively collected data into a unique string. Depending on the operator's goals, adjustments can be made;"}, {"title": "III. METHODS OF BROWSER FINGERPRINTING", "content": "In the context of browser fingerprinting techniques, the methods of data collection are varied and comprehensive. Therefore, specific properties and criteria are used to select techniques. The following sections will encompass the explanation of the techniques in terms of their functionality and their applications will be discussed to provide a detailed understanding of their use. An evaluation based on the advantages and disadvantages of each technique is also included to weigh their effectiveness and potential risks. Given the ever-increasing number of techniques, only the most commonly used, established, or novel methods will be presented here."}, {"title": "\u0391. HTTP Header Attributes", "content": "The HTTP request header is a part of every HTTP request exchanged between a client (web browser) and a server, transmitting various functional and compatibility-related information [10]. Although individual attributes are not unique, they can be combined to distinguish a client. This explanation is based on HTTP version 1.1, with HTTP/2 maintaining most attributes within a modified header frame [11].\nHTTP request headers include attributes that differ by browser and version. Effective fingerprinting requires selecting attributes that remain consistent over time. Reliable fields include User-Agent, Accept, Content-Encoding, and Content-Language, which provide valuable identification information [4, p. 5] [12, p. 880]. The User-Agent, despite lacking standardization, offers high uniqueness due to its detailed browser and OS information [13].\nThe main advantage of using HTTP headers is their passive information collection, which occurs automatically with each request. This method is efficient, unobtrusive, and compatible with most web servers, processing data on the server side without a noticeable impact on the client.\nHTTP header information is limited, as most attributes provide minimal details. The User-Agent, while informative, can be easily altered by browser extensions, reducing its reliability (i.e. User-Agent Switcher for Chrome). Furthermore, using such technologies without consent can violate GDPR regulations, necessitating legal review before implementation [14]."}, {"title": "B. Enumeration of Browser Plugins", "content": "Browser plugins, whether pre-installed or user-added, have been a method for recognizing systems, along with font detection. Most browser features are indirectly modified, except for extensions. The demand for accurate enumeration of these extensions is high [12, pp. 878-880].\nMany information-rich plugins, like Flash, have disappeared over the years. Since 2016, most browsers, including Firefox, no longer support the Netscape Plugin Application Programming Interface (NPAPI) plugin interface, leading to the navigator.plugins object in modern browsers showing only standard plugins like PDF viewers [15]. This limitation reduces the impact of plugins on fingerprinting but still allows differentiation between systems and browsers. The direct detection of user-installed add-ons is not possible, limiting the data's significance [12, pp. 886-887]. However, new methods to enumerate extensions have emerged. Chromium-based browsers can access extension settings via a local URL. A GitHub project exploits this to check for over 1,000 extensions by requesting internal resources and checking the status"}, {"title": "C. Canvas Fingerprinting", "content": "Canvas fingerprinting involves generating a digital fingerprint using the Canvas element introduced in HTML5. It utilizes the Canvas API to draw a hidden 2D graphic in the background. Variations in how different browsers and devices handle this image due to differences in hardware acceleration, installed fonts, and graphic libraries result in a highly stable and unique fingerprint [1, pp. 1-3].\nA script embedded in a webpage adds an invisible Canvas element that draws a predetermined 2D graphic in the background. Text can also be drawn using the Canvas context, employing various fonts and sizes. WebFonts enable dynamic loading of fonts from the internet, allowing specific fonts to be chosen to test for uniqueness in font rendering. The resulting image data can be extracted using functions like getImageData and toDataURL, which can then be hashed to form a fingerprint, typically using a hashing algorithm. This hash is sent via a web request to a server for processing and storage. Besides storing the fingerprint for later identification, another application method involves comparing the fingerprint with an extensive database of known fingerprints and corresponding system configurations, enabling reliable system profiling [1, pp. 2-4].\nMowery and Shacham demonstrated that implementing Canvas fingerprinting is straightforward, requiring minimal lines of client-side code. It leverages basic JavaScript functions and can be deployed across all major web applications. The fingerprinting process is discrete for users and challenging to block because Canvas operations are common in web applications, making it difficult to distinguish normal operations from fingerprinting scripts. The simplicity of fingerprint creation enables high speed, stability, uniqueness, and entropy, making it particularly valuable for real-time tracking applications [1, pp. 1-5].\nChanges in browser environments, such as updates or graphic settings, can affect the stability of the fingerprint. Variability in hardware and software configurations can lead to inconsistencies. As an active technique, executing code on the client side is necessary, posing risks of detection and potential blockage by blocklists targeting known fingerprinting scripts [1, pp. 3-7]. While imperceptible to users, the limited interfaces to retrieve generated Canvas data can"}, {"title": "D. WebGL Fingerprinting", "content": "WebGL fingerprinting is a technique utilizing the WebGL JavaScript API, based on OpenGL ES 2.0, allowing web applications to render both 2D and 3D graphics with high performance by directly accessing the GPU [20]. Unlike Canvas fingerprinting, which focuses on 2D graphics and identifies software differences mainly through fonts and graphic libraries, WebGL fingerprinting provides deeper and more precise detection capabilities. It captures unique hardware information, particularly details about the graphics processor, distinguishing it significantly from Canvas fingerprinting and broadening its application for tracking purposes [1, p. 4].\nWebGL fingerprinting uses a Canvas element to access the API. Similar to Canvas fingerprinting, it creates an invisible element performing 3D operations in the background to collect data without user interaction. A straightforward application involves accessing specific variables, such as UNMASKED_VENDOR_WEBGL and UNMASKED_RENDERER_WEBGL, using the getParameter function in the WebGL context. These variables provide information about the graphics hardware manufacturer (Vendor) and model (Renderer). For example, a Vendor entry like \"Intel\" indicates an integrated graphics unit, while \u201cNvidia\" combined with \"GeForce GTX 970\" as Renderer indicates a dedicated graphics card. These details can reveal insights into the system being used [21, p. 17]. Privacy concerns have led browsers like Apple's WebKit to provide generic information instead of specific data to protect user privacy. Since 2020, WebKit has masked Vendor and Renderer information, as well as shading language details [22]. Firefox similarly groups graphics processor models into categories instead of displaying specific models. In practice, this means that a Nvidia card from the 900 series onward, for example, is reported as \u201cGeForce GTX 980\u201d. In summary, research investigating hardware fingerprinting using HTML5 demonstrated the capability to identify devices based on GPU performance. It utilizes the graphics processor's clock frequency and clock skew to render complex 3D graphics, measuring GPU performance based on the number of frames rendered within a period, providing insights into the GPU's frequency and core count [23, pp. 3-4].\nAs demonstrated by Cao et al., WebGL can offer high uniqueness and stability [24]. Its direct interface with the system ensures consistency across browsers, making it challenging for users to evade identification through simple browser changes or reinstalls. Despite changes to enhance WebGL's resistance to fingerprinting, it reliably identifies"}, {"title": "E. Audio Fingerprinting", "content": "The Web Audio API is a JavaScript interface for processing and synthesizing audio signals in the web browsers, part of the HTML5 standard. It can identify systems through manufacturing differences in audio hardware. Methods analyze signal processing characteristics, hardware differences, and system responses to specific audio signals for fingerprinting [27, pp. 1107-1109].\nAudio fingerprinting involves various acoustic measurements to create a unique device fingerprint. It requires an AudioContext linking an AudioBuffer, Oscillator, and Compressor. The AudioBuffer represents a small audio segment, while the Oscillator generates a waveform at a defined frequency. The Compressor manipulates the audio signal. The unique waveform generated and manipulated reflects system characteristics, allowing a unique fingerprint to be created using a hash function on the final waveform. This method, known as \"Dynamic Compressor (DC)\", is highly stable, producing the same fingerprint for the user each time using a reliable hash function [27, pp. 1109-1111].\nAnother method is the \"Fast Fourier Transform\" (FFT), converting audio signals from the time domain to the frequency domain. It measures hardware implementation differences to identify characteristics. FFT is less stable than DC, often requiring multiple attempts for consistent results. DC and FFT are often used together for more reliable outcomes [27, pp. 1111-1114]. Researchers compared the techniques, including custom-designed ones, alongside DC and FFT. These included creating \"Custom Signals\u201d, \u201cMerged Signals\", and analyzing generated AM and FM waves. All techniques showed good stability, averaging two to four attempts for fingerprint matching [28, pp. 3-5].\nThe generated fingerprints are highly stable and can differentiate systems based on their properties.\""}, {"title": "F. Font Fingerprinting", "content": "Font fingerprinting is a browser fingerprinting technique that identifies devices by recognizing installed fonts. This method creates unique digital fingerprints by combining fonts with other data points, which can be used for tracking and identification purposes [29, p. 314].\nAfter the end of Adobe Flash, a new method for font recognition was needed. JavaScript uses a fallback mechanism to recognize fonts by comparing the dimensions of texts in specific fonts with expected values. Invisible div elements and the canvas element are used to identify installed fonts [29, p. 311] [30, p. 12]. The experimental Local Font Access API requires user consent and is therefore not suitable for fingerprinting [31].\nFont recognition offers high entropy and stability since fonts are rarely changed. This allows the identification of the operating system and installed software packages like Office or Photoshop [3, p. 7].\nWithout Flash, font recognition is done through \"brute-force\u201d methods, reducing accuracy if unknown fonts are installed. Similar fonts can lead to false positives. Extensions and adjustments, such as those in Apple's WebKit, can manipulate or restrict recognition [24, p. 10] [29, p. 311]."}, {"title": "G. Screen Fingerprinting", "content": "Screen fingerprinting identifies a device by analyzing various screen-related characteristics, including screen resolution, pixel depth, color depth, and browser window size. This method leverages the uniqueness of screen configurations and browser modifications, which can create rare resolution combinations [32, p. 20].\nJavaScript provides attributes for screen and browser window characteristics through the window.screen object, offering details like color depth (colorDepth), screen orientation (screenOrientation), and screen dimensions (screenHeight, screenWidth). Values, such as window.innerWidth and window.innerHeight, determine the browser window's inner area, which can be altered by toolbars or bookmark bars [24, p. 3].\nScreen and window resolution information typically have high entropy, making them useful for stabilizing fingerprints when combined with other techniques. This method is particularly effective for distinguishing between"}, {"title": "H. WebRTC Fingerprinting", "content": "WebRTC is a standard and accessible JavaScript interface available in most browsers. It facilitates real-time communication over stateless HTTP by establishing direct connections between participants, allowing the extraction of local network adapter information. This can reveal private and public IP addresses, which can be used for fingerprinting or identifying users behind proxies or VPNs [30, p. 12]. It also provides information about connected devices, such as microphones, webcams, and speakers.\nUnlike other browser mechanisms like camera or microphone access, establishing a WebRTC connection requires no permissions or user notifications. After connecting to the target computer via a Session Traversal Utilities for NAT (STUN) server, IP addresses can be read from the RTCPeerConnection object as iceCandidates [33, p. 667]. This data can be used for fingerprinting, and WebRTC can further enumerate the local network to build a unique profile of the target's environment. It can also read all local adapter addresses, including those for VPNs and virtual machines [33, p. 667-668]. The DetectRTC project [34] demonstrates WebRTC's capabilities, highlighting information about microphones, webcams, and speakers. While exact device names require permissions, WebRTC can read Media Device IDs, which can contribute to unique fingerprints.\nExtracting private and public IPs provides deep insights, especially for identifying targets behind VPNs or proxies. No other technique can silently reveal addresses behind Network Address Translation (NAT) [35, p. 273]. The collected data is highly unique; a study with 80 devices found over 97% uniqueness using only WebRTC [33, p. 668].\nWebRTC might be disabled in the target browser, or extensions might block its usage without user consent. Accessing Media Device IDs requires permission, alerting users to potential background activities, making it unsuitable for stealth operations. Additionally, WebRTC relies on STUN servers, either self-hosted or third-party, adding dependency considerations for its use."}, {"title": "I. CSS Fingerprinting", "content": "Different to the active fingerprinting techniques using JavaScript, CSS fingerprinting is a passive method. CSS is a stylesheet language primarily used to enhance the presentation of HTML elements. Over time, the CSS specification has expanded to include selectors and filters, enabling limited dynamic selections, which this technique leverages [36, p. 10].\nUntil 2010, the :visited selector could identify if a website had been visited by changing the link color, detectable via JavaScript. After this was patched, researchers explored time-based methods to read user history, but these required JavaScript and were impractical [37, p. 4]. In 2015, Takei et al. introduced a JavaScript-free method using CSS properties and multiple @media queries to fetch URLs based on defined rules. The server could then identify system properties like screen dimensions, resolution, touchscreen presence, installed fonts, browser, and OS from the requesting IP address and URL parameters [38, p. 3-5]. A current GitHub project demonstrates this method's practical capabilities [39].\nCSS fingerprinting's independence from JavaScript allows it to identify even cautious users who block JavaScript or use extensions like NoScript. This technique can even detect if JavaScript is disabled via noscript tags [38, p. 2]. Due to its limited use and lesser-known status, no effective user solutions currently exist to prevent it.\nTakei et al.'s method provides limited data, which, without JavaScript, can only be supplemented by techniques like header analysis. Oliver Brotchie notes in his project repository that the method is not currently scalable, as each request requires over 1MB of CSS files to be downloaded. However, he warns that upcoming CSS Values 4 implementation could reduce download sizes significantly, making the method more practical. Additionally, font recognition relies on brute-forcing, which can be noticeable in network traffic."}, {"title": "J. Additional JavaScript Attributes", "content": "Most of the previously discussed techniques actively use JavaScript to extract information from various interfaces. Additional possibilities are briefly mentioned here to provide a more comprehensive picture. Since these techniques share many characteristics with other JavaScript-based methods, listing their pros and cons is omitted.\nThe navigator object in browsers provides information, such as DoNotTrack status, user agent details, platform, languages, cookies usage, granted and available permissions, and time zone [29, p. 9]. JavaScript implementation varies between browsers and versions, and Mowery et al. demonstrated that these differences are measurable and can indicate the software and hardware used [1].\nAdditionally, there are differences in the availability and execution of functions, which offers an alternative way to detect user agents if manipulated by extensions. Another technique that caused concern among Tor users is the use of the getClientRects function to obtain precise DOM element data, even with Canvas disabled. These factors can vary based on implementation, font sizes, and screen resolutions, enabling identification in the otherwise anonymous browser [40]. This"}, {"title": "K. Advanced Techniques Using Machine Learning", "content": "Most active techniques discussed so far use JavaScript to gather hardware and software information. They rely on unique data combinations based on implementation quirks or directly available information. Newer methods often employ \u201cside-channels\u201d, capturing additional data by observing behavioral differences during various operations within the execution environment. Methods like plugin enumeration (cf. Section III-B), font fingerprinting (cf. Section III-F), and CSS fingerprinting (cf. Section III-I) use this approach in simple forms by testing known combinations to gain indirect information. These side-channel methods can be implemented with minimal effort but can also be used in more sophisticated ways with machine learning to gather otherwise unobtainable information [42, p. 1].\nWang et al. explored using cache usage, memory consumption, and CPU activity to identify visited websites. Previously, CSS selectors were used to reveal browsing history, posing significant privacy risks and leading to prompt fixes. Side-channel techniques employ various tricks to analyze system behavior more accurately. Complex calculations stress the hardware in the background, and machine learning models categorize the results with expected values from known sites. Tests showed 80-90% accuracy in identifying websites [42, p. 3-5]. Further research is needed, but implementations using WebAssembly [43] and the Performance API [44] are conceivable.\nThis method is invisible to the user and provides insightful information not available through conventional means. Currently, there are no methods to protect users from such techniques [42, pp. 1-3].\nWhile previous techniques aimed to identify a user over time, this method could offer dangerous insights into the person's behavior behind the screen. However, the technique is still in its initial stage and remains a theoretical approach not yet tested in the real world. It is unlikely to be reliably used by actors in the near future [42, p. 6]."}, {"title": "IV. DISCUSSION", "content": "Browser fingerprinting can be used positively for security, as shown by technologies like BrFast and private, passive user recognition methods. However, there's a risk of misuse, especially in advertising. Personalized ads significantly impact Generation Z, who discover products primarily through social media. The advertising industry, driven by creating accurate user profiles, heavily invests in digital advertising, with data-driven ads accounting for 60-70% of digital ad revenue in Germany. Traditionally, data collection relied on cookies, but users developed ways to avoid tracking, such as deleting cookies or using incognito mode. Unlike cookies, browser fingerprints are collected in the background and are not easily altered. GDPR regulations mandate user consent for data collection, but enforcement is inconsistent, and compliance with fingerprinting guidelines remains unclear, even with new laws like Germany's TTDSG [45].\nOnline tracking is ubiquitous, affecting nearly all user groups. A 2016 study of the top 1 million websites revealed extensive tracking, with services like Google and Facebook present on over 10% of sites. Post-GDPR, fingerprinting scripts increased to 68.8% of the top 10,000 sites. A study with 234 participants found that demographics like age, gender, education, IT background, and privacy awareness influenced trackability, with men and those with higher education being less trackable. Despite understanding fingerprinting, many participants believed they could protect themselves from it. The AmIUnique study, with over 100,000 fingerprints, indicated a bias towards more privacy-aware internet users. Current research from Friedrich-Alexander-University shows that most study participants are male and well-educated, suggesting that while almost everyone is affected by browser fingerprinting, only a small, informed group actively researches and understands it [46].\nBrowser fingerprinting, as explored through various methods in this paper, represents a comprehensive and evolving threat to digital privacy. Each fingerprinting technique, from HTTP Header Attributes to more sophisticated approaches like Canvas and WebGL Fingerprinting, offers unique data points, but their power lies in their combinatorial use. While individual methods may not be highly unique or stable, their integration enables more persistent and accurate user identification across devices and browsers. Techniques like WebRTC and Font Fingerprinting complement traditional methods by exposing additional layers of system and network data. Furthermore, the advancement of machine learning-based fingerprinting is pushing the boundaries of tracking, allowing for the analysis of side-channel behaviors, such as CPU or memory usage. This convergence of methods creates a powerful, multi-dimensional profiling system that is increasingly resistant to countermeasures, challenging both privacy"}, {"title": "V. CONCLUSION", "content": "This contribution has examined browser fingerprinting, a growing technique in online tracking. It has demonstrated that browser fingerprinting is a sophisticated method for identifying and tracking users online without traditional methods like cookies.\nThe analysis highlighted that browser fingerprinting poses a complex challenge from both technical and privacy perspectives. While it provides companies and advertisers with detailed insights into user behavior for targeted advertising, it raises significant privacy concerns as users are often tracked without their knowledge or consent. Despite stricter privacy laws like the GDPR in the EU, browser fingerprinting remains a grey area. Anti-fingerprinting techniques are limited and continually evolving to keep up with new tracking methods. In conclusion, browser fingerprinting plays and will continue to play a significant role in the digital landscape. Both users and regulatory bodies must increase awareness of browser fingerprinting practices and their implications."}, {"title": "B. Implications for Practice", "content": "Consent and Cookies: Always accept only the necessary cookies in cookie banners and regularly delete cookies to hinder tracking and fingerprinting. This is particularly important for news sites, which often misuse collected data without user consent.\nBlending in with the Masses: Reducing APIs and data sources for fingerprinting can ironically make users more identifiable [47]. Thus, widely adopted browsers and protection mechanisms should be used to stay less conspicuous.\nBrowser Choice: Choose browsers with robust privacy protections. On iOS, Safari is recommended due to its advanced tracking protection and large user base [48]. For Android, the Mull browser is highly rated for fingerprinting protection, while Brave is a good, widely-used alternative. On desktops, Brave, Librewolf, and Mullvad browsers are recommended for their privacy features and user bases [49].\nBrowser Extensions: Limit the use of browser extensions, as they can become sources of unique information. While some extensions block known trackers or modify API outputs, these protections are often already built into recommended browsers like Brave and Librewolf [18] [47]."}, {"title": "C. Future Research", "content": "Future research in browser fingerprinting should focus on several key areas. First, countermeasures and defense mechanisms need to be explored further, especially in mitigating the newer techniques that leverage machine learning and side-channel attacks. These advanced methods can bypass traditional privacy safeguards, such as disabling JavaScript or using incognito modes, making the development of more robust anti-fingerprinting technologies imperative. Additionally, research should explore the ethics and regulatory frameworks surrounding fingerprinting, examining how existing privacy and data protection laws like GDPR can be adapted to better address fingerprinting practices. Another promising direction"}]}