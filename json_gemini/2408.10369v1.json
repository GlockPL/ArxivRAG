{"title": "Boolean Matrix Logic Programming", "authors": ["Lun Ai", "Stephen H. Muggleton"], "abstract": "We describe a datalog query evaluation approach based on efficient and composable boolean matrix manipulation modules. We first define an overarching problem, Boolean Matrix Logic Programming (BMLP), which uses boolean matrices as an alternative computation to evaluate datalog programs. We develop two novel BMLP modules for bottom-up inferences on linear dyadic recursive datalog programs, and show how additional modules can extend this capability to compute both linear and non-linear recursive datalog programs of arity two. Our empirical results demonstrate that these modules outperform general-purpose and specialised systems by factors of 30x and 9x, respectively, when evaluating large programs with millions of facts. This boolean matrix approach significantly enhances the efficiency of datalog querying to support logic programming techniques.", "sections": [{"title": "Introduction", "content": "A great body of work (Ceri, Gottlob, and Tanca 1989; Afrati, Gergatsoulis, and Toni 2003; Cropper et al. 2021; Sato, Inoue, and Sakama 2018; Evans and Grefenstette 2018; Gupta, Cheng, and Ludascher 2019) has focused on datalog programs as specifications of first-order logic in AI and an essential language for querying knowledge bases. Traditional datalog query evaluations primarily concentrate on symbolic computations. However, matrix operations have been shown to provide high-performance datalog query evaluations (Sato 2017b). As shown in Figure 1, boolean matrix logic programming could allow AI developers to combine efficient operations to evaluate complex datalog programs in reasoning about perceptions (Dai et al. 2018; Evans and Grefenstette 2018), inductive and abductive learning (Muggleton, Lin, and Tamaddoni-Nezhad 2015; Dai and Muggleton 2021; Sato, Inoue, and Sakama 2018).\nMany studies (Nickel, Tresp, and Kriegel 2011; Grefenstette 2013; Rockt\u00e4schel and Riedel 2017; Yang, Yang, and Cohen 2017; Sato 2017a) have explored first-order logic program evaluation in tensor spaces. Despite the compatibility with off-the-shelf tensor frameworks, embedding recursive datalog programs has been difficult for tensor techniques. Bounded-depth queries of linear recursive datalog programs have been approximated (Cohen, Yang, and Mazaitis 2020) but it is known that determining the boundedness is undecidable (Gaifman et al. 1993). Rewriting linear datalog programs in linear tensor algebra has only been possible for dyadic programs where every variable in a clause appears exactly in two literals (Sato 2017b). Exact arithmetic solutions for multilinear datalog programs cannot be effectively computed and are not composable. In contrast, boolean matrix operations provide the correctness guarantee and modularisation in evaluating datalog programs.\nIn this paper, we explore an alternative logic programming approach to datalog query answering based on boolean matrices. To start, we propose Boolean Matrix Logic Programming (BMLP) as a general query answering problem with boolean matrices. We focus on datalog programs where clauses contain predicates of arity at most two (P\u2081 as an example program). Arity-two datalog programs extended with predicates that encode function input-output pairs have Universal Turning Machine expressivity (T\u00e4rnlund 1977). The BMLP problem is the first formalisation of this kind as a broad logic programming task. Theoretically, we prove BMLP modules can be combined to evaluate arity-two linear and non-linear recursive datalog programs. To showcase composability, we evaluate a non-linear program by combining a BMLP module with boolean matrix operations and explain how BMLP modules relate to second-order datalog programs. Implementation-wise, we created two BMLP modules for programs having the same form as P1, repeated matrix squaring (BMLP-RMS) and selective matrix product (BMLP-SMP). These two BMLP modules have been written in the general-purpose Prolog system SWI-Prolog to enable accessibility and reusability. The runtime of these BMLP modules has been studied both theoretically and empirically.\nNovelty, impact and contributions:\n\u2022 We define the Boolean Matrix Logic Programming (BMLP) problem.\n\u2022 We introduce two BMLP modules, BMLP-RMS and BMLP-SMP, based on boolean matrix operations, with implementations in SWI-Prolog.\n\u2022 We theoretically prove the composability of linear BMLP modules for multilinear programs based on closed semiring and relational algebra.\n\u2022 We empirically show that BMLP-SMP and BMLP-RMS significantly outperform state-of-the-art datalog engine Souffle (Scholz et al. 2016), ASP solver Clingo (Gebser et al. 2014), general-purpose Prolog systems B-Prolog (Zhou 2012) and SWI-Prolog (Wielemaker et al. 2012) in runtime efficiency."}, {"title": "Related work", "content": "Bottom-up datalog evaluation. Most approaches (Vieille 1986; Ceri, Gottlob, and Tanca 1989; Beeri and Ramakrishnan 1991; Afrati, Gergatsoulis, and Toni 2003; Tekle and Liu 2011; Scholz et al. 2016; Hu, Motik, and Horrocks 2022) employed traditional symbol manipulations. Obtaining the least model of graph-like datalog programs can be reduced to computing the transitive closure of boolean matrices (Peirce 1932; Copilowish 1948). Fischer and Meyer (1971) studied a logarithmic divide-and-conquer computation technique by viewing relational databases as graphs and showed a significant computational improvement over direct concatenation of matrix operators. A similar approach was explored by Ioannidis (1986) for computing the fixpoint of recursive Horn clauses. Compared with traditional Inductive Logic Programming (ILP) (Muggleton 1991) which searches for generalisable rules symbolically, Muggleton (2023) employed the logarithmic technique in the DeepLog ILP system. It constructs the bottom clause iteratively through repeated squaring of boolean matrices.\nDatalog evaluation in tensor space. Grefenstette (2013) developed a tensors-based calculus to represent truth values of domain entities, logical relations and operators for first-order logic but this did not treat the quantifiers in datalog programs. Nickel et al. (2011) represented semantic webs' binary relations in bilinear form and truth values of ground atoms as tensors. Rocktaschel et al. (2015) computed the inner product between one-hot vectors encoding entity pairs and binary relations for the truth values. Unlike our approach, they only approximated linear datalog queries and did not model recursions. As previously mentioned, Sato (2017a; 2017b) showed that a subset of linear recursive datalog programs with arity two can be embedded in tensor space as linear algebraic equations. Sato et al. (2018) established a linear algebra abduction framework based on this approach. Here, in contrast to BMLP, arithmetic solutions of algebraic systems do not apply non-linear datalog programs and require all-in-one-piece implementations.\nFirst-order rule learning with tensors. While a substantial body of work explored rule learning using tensors, most only approximated first-order inference. Neural-symbolic methods (Rockt\u00e4schel and Riedel 2017; Yang, Yang, and Cohen 2017) approximated first-order datalog queries through differentiable unification operators to construct neural networks. In a similar approach, Cohen et al. (2020) used beliefs propagation for bounded-depth probabilistic inferences in stochastic logic programs using off-the-shelf deep learning frameworks. Others only applied tensors to induction but not for query answering. The SILP framework developed by Evans and Grefenstette (2018) utilises program templates to invent predicates and perform gradient descent in binary neural networks to optimise weights of candidate rules. Dai and Muggleton (2021) combined ILP with neural networks to extract probabilistic facts from sub-symbolic data and search for first-order theories based on second-order program templates."}, {"title": "Background", "content": "A variable is a character string beginning with an uppercase letter. A predicate or constant is a character string starting with a lowercase letter. A Horn clause is a disjunctive clause with at most one positive literal. We consider a term to be either a constant or a variable. A definite clause is a Horn clause with one positive literal. A query is a user-posted Horn clause without a positive literal. A fact is a definite clause with only a positive literal and no variables. A first-order definite clause has the form, $A_0 \\leftarrow A_1, ..., A_n$ and $A_0$ is the head and each $A_i$ is a body literal. $A_i = r_i (X_1, ..., X_k)$ has arity k and $r_i$ is a predicate symbol applied to a tuple of terms $x_j$. A second-order definite clause contains second-order variables that can be bound to predicate symbols. A definite clause is range-restricted if every variable in $A_0$ appears among variables in $A_k$ for $1 \\leq k \\leq n$. All non-range-restricted definite clauses have equivalent range-restricted forms (Ioannidis and Wong 1991). We refer to a definite clause as a clause.\nA recursive clause has a predicate in its body that also appears in the head of some clause. A linear recursive clause (e.g. the second clause in P\u2081) has at most one predicate in its body that appears in the head of some clause (Ioannidis and Wong 1991). A datalog program is a set of definite clauses without function symbols. A recursive datalog program has a recursive clause. A linear datalog program (e.g. P\u2081) only contains linear clauses. This definition differs from piecewise linear programs (Bancilhon and Ramakrishnan 1986) which can be decomposed into multiple linear programs. H datalog programs (Muggleton, Lin, and Tamaddoni-Nezhad 2015; Cropper and Tourret 2020) contain predicates of arity at most two and at most n literals in the body of each clause. A clause \u03b1 entailed by a program P is written as P |= \u03b1. The least model is the minimal set containing all facts that are entailed by P."}, {"title": "Boolean matrix logic programming", "content": "In contrast to traditional logical inferences that manipulate symbols, BMLP emphasises programming boolean matrix operators. As we will explain in the rest of the paper, combining modules facilitates diverse architectures for efficient first-order query answering in datalog programs. In addition, each BMLP module corresponds to a second-order datalog program, which provides an alternative perspective of Inductive Logic Programming. We present an example of the boolean matrix encoding and implementations of two BMLP modules."}, {"title": "Problem definition", "content": "Definition 1 (BMLP problem). Let P be a $H_2$ datalog program containing a set of clauses with predicate symbol r. The goal of Boolean Matrix Logic Programming (BMLP) is to output a boolean matrix R encoded in datalog such that $(R)_{ij} = 1$ if P |= r(ci, cj) for constants ci, cj and $(R)_{ij} = 0$ otherwise.\nBoolean Matrix Logic Programming (BMLP) is general for monadic predicates which can be expressed via dyadic predicates by repeating the single argument. Stored higher-arity predicates are expressible via multiple binary predicates. An arbitrary predicate representing input-output pairs of a computation can be mapped to composite constants such as c1-c2. A subset of $H_2$ programs, namely the $H_3$ program class (Muggleton, Lin, and Tamaddoni-Nezhad 2015), has the same expressiveness as a Universal Turing Machine if it is extended with predicates that represent function input-output pairs (T\u00e4rnlund 1977). We can encode the least model as a boolean matrix by considering a bijective mapping from composite constants to a subset of natural numbers. We assume matrices are stored in a database or can be derived directly from non-recursive clauses. Handling dynamic addition and deletion of facts is discussed as future work."}, {"title": "Boolean matrix representation", "content": "A bijective function maps constants in a datalog program P to a subset of natural numbers $N_0$. Mapped constants are totally ordered by the \"<\" relation so each constant is uniquely identified. We encode a boolean matrix R in datalog to express a clause r. Every matrix row $(R)_{i,*}$ is a fact v(i, bi) and $b_i$ is denoted by a binary code such that the j-th bit $(b_i)_j$ is 1 if P |= r(ci, cj) and 0 otherwise.\nExample 1. Consider P\u2081 in Section 1. A boolean matrix R is created from {edge(a,b), edge(b, c)} U P1. Constants {a,b,c} are mapped to row and column indices {0,1,2}. The v facts on the right represent rows in R.\nWhen $c_i$ and $c_j$ ($0 \\leq i, j < n$) come from the same set of constants, a boolean matrix created this way is an n x n square matrix and an operator with the same domain and range. Vectors are treated as single-row matrices."}, {"title": "BMLP modules", "content": "From a high level, each BMLP module aims to map one set of facts to another set via multiple boolean matrix operations. $2^{\\mathcal{C}}$ denotes the set of all derivable k-arity facts in a datalog program P.\nDefinition 2 (BMLP module). A BMLP module is an operator f : $2^{\\mathcal{C}_1} \\rightarrow 2^{\\mathcal{C}_2}$ where C is encoded by boolean matrices.\nLet r\u2081 be a stored or directly derivable non-recursive predicate. r2 is a recursive predicate that depends on r\u2081. BMLP-SMP and BMLP-RMS (Figure 2) evaluate queries for the following linear recursive $H_2$ datalog program $P_2$:\nr2(X, Y) \u2190 r\u2081(X,Y).\nr2(X, Y) \u2190 r\u2081(X, Z), r2(Z, Y).\nBoolean matrices R\u2081 and R2 encode r\u2081 and r2. BMLP-RMS evaluates all derivable groundings of r2, while the BMLP-SMP module only finds derivable facts from a partially grounded query r2(c, Y) given some constant c."}, {"title": "BMLP composability", "content": "Multiple BMLP modules can be combined by computing, storing and reusing the output of modules. The simplest modules compute linear $H_2$ datalog programs.\nDefinition 3 (Linear BMLP modules). A BMLP module is called linear if it computes a linear $H_2$ datalog program.\nBMLP-RMS and BMLP-SMP are linear modules by construction. Recall the relational operator in the set S, namely cross product, selection and projection. Boolean matrix operations in BMLP-RMS and BMLP-SMP have equivalent relation operators. Boolean matrix multiplications and additions can be viewed as cross products with projections and selections.\nTheorem 1. Every linear $H_2^n$ datalog program can be computed by some composition of linear BMLP modules.\nProof. Every linear datalog program with range-restricted or non-range-restricted clauses can be computed by concatenations or unions of linear relational operators from S (Ioannidis and Wong 1991). A BMLP module corresponding to linear binary relation operators is linear by Definition 3. Owing to the closed semiring of linear relational operators, the concatenation or union of linear BMLP modules is also linear.\nWe then prove the composibility of linear BMLP modules for multilinear recursive datalog programs. A clause with m recursive predicates is m-linear if fixing a subset of m \u2212 1 predicates as non-recursive would make this clause linear.\nTheorem 2. Every m-linear $H_2^n$ datalog program is computable by some composition of linear BMLP modules.\nProof. This follows from Theorem 1. A m-linear recursive datalog program contains m-linear clauses and can be reduced to m \u2212 1 bilinear clauses (Ioannidis and Wong 1991). Every bilinear clause (m = 2) can be evaluated by interleaving computation of linear programs with respect to some partial ordering on the predicates (Tarski 1955)."}, {"title": "Implementation", "content": "BMLP-SMP and BMLP-RMS modules are implemented in general-purpose Prolog system SWI-Prolog to accommodate accessibility and reusability for other architectures. Boolean matrix addition, multiplication, transpose and negation are implemented based on boolean operations in SWI-Prolog. In SWI-Prolog, all binary codes are written compactly as equivalent decimal integers whose length can be flexibly extended. BMLP does not exclude infinite domains theoretically but practically machines have finite memory so we limit our implementations to finite-size relations. Matrices are treated as compiled predicates in SWI-Prolog and can be re-consulted if they have changed. Modules store intermediate computation results to be reused. This saves computation resources but would trade off storage.\nBMLP-RMS uses addition and multiplication to compute the transitive closure in Equation (4) via Algorithm 1."}, {"title": "Conclusion and future work", "content": "We utilised boolean matrices encoding of datalog and proposed Boolean Matrix Logic Programming (BMLP) as an overarching logic programming problem. Two composable BMLP modules, BMLP-RMS and BMLP-SMP, are implemented to evaluate linear recursive datalog programs. Theoretically, we showed a combination of BMLP modules can evaluate linear and non-linear dyadic datalog programs. BMLP modules can also be applied to invent predicates. Our results empirically showed that BMLP modules are significantly faster than state-of-the-art general and special-purpose systems for evaluating large programs with millions of facts.\nLimitation and future work: BMLP modules do not perform as well on sparse matrices, so we will focus on computation improvements in the future. To the best of our knowledge, no bilinearisation framework of multilinear programs exists that uses boolean matrices. This gap could be filled to systematically create non-linear BMLP architectures. Modules that consider dynamic databases would be more robust. Related work has not explored matrix operations (Hu, Motik, and Horrocks 2022). The DeepLog system (Muggleton 2023) showed the feasibility of involving boolean matrices to represent $H_2$ second-order programs for inductive learning. The correlation between BMLP composability and learning complexity could be investigated. Computing matrices on GPUs (Valizadeh and Berger 2023) could further improve query evaluation runtime to facilitate inductive learning."}, {"title": "Appendix", "content": "Notation\nWe refer to a subset of the SWI-Prolog predicate description notations (Fruehwirth, Wielemaker, and De Koninck 2024). A mode indicator precedes every argument description. For instance, the sort(+List, \u2013 Sorted) indicator says this method takes a List and returns it Sorted. An argument mode indicator shows the intended use of the argument and output for a predicate. An argument preceded by \"+\" means at call time, it must be instantiated to a term. Arguments preceded by \u201c-\u201d are output arguments. All arguments should respect certain typing specifications.\nB\nBMLP source code and examples\nWe refer readers to the GitHub repository for the complete implementation of BMLP methods and modules. For showcasing, we use the datalog program ex.pl with facts in Example 1 in Section 4.2. The monadic node predicate describes the type of constants:\nnode (a). node(b). node(c).\nedge(a,b). edge(b,c).\nB.1 Initialisation and compilation\nBMLP modules need to be initialised to a folder to save intermediate computation results and the default folder is \"BMLP/temp/\". If a database has not been encoded as a boolean matrix, it can be compiled via the compile(+String,+DB,-Matrix) method. The string input is the path to a *.pl file. Target relation and entity types in this file need to be defined by the db term. In this case, it contains the name of the dyadic predicate edge, and the type of constants node."}]}