{"title": "SEMI-STRONGLY SOLVED: A NEW DEFINITION LEADING\nCOMPUTER TO PERFECT GAMEPLAY", "authors": ["Hiroki Takizawa"], "abstract": "Solving combinatorial games has been a classic research topic in artificial intelligence because\nsolutions can offer essential information to improve gameplay. Several definitions exist for 'solving\nthe game,' but they are markedly different regarding computational cost and the detail of insights\nderived. In this study, we introduce a novel definition called \u2018semi-strongly solved' and propose an\nalgorithm to achieve this type of solution efficiently. This new definition addresses existing gaps\nbecause of its intermediate computational cost and the quality of the solution. To demonstrate the\npotential of our approach, we derive the theoretical computational complexity of our algorithm under\na simple condition, and apply it to semi-strongly solve the game of 6x6 Othello. This study raises\nmany new research goals in this research area.", "sections": [{"title": "Introduction", "content": "Combinatorial games like chess have remained one of the leading research subjects in computer science, especially in\nthe field of artificial intelligence (AI). The historical association between the ability to play combinatorial games and\nhuman intelligence [1] has driven significant interest in studying these games. Many non-trivial combinatorial games,\nincluding Connect Four [2], Nine Men's Morris [3], and Checkers [4], have already been solved. Research on solving\ngames is related to making computers play games well but differs in some points.\n\nThere are multiple definitions of game-solving. At least three definitions are known [2]. The most fundamental category\nis known as ultra-weakly solved games. In this type, we obtain the game-theoretic value of the starting position, but\nwe do not have a concrete winning strategy. For example, it is known through proof by contradiction that in the game\nof Hex, the first player has a winning strategy regardless of the board size. Moving on, in weakly solved games, we\nnot only know the game-theoretic value of the initial position but also have a strategy for both players to reach this\nvalue from the starting point using reasonable computational resources. At an even more detailed level, we encounter\nstrongly solved games, where the outcomes are determined for every possible position that may arise during the game.\n\nThe definitions of solving games can be viewed from the perspective of the perfection of the gameplay of AI. An\nultra-weak solution provides no insights into playing. A weak solution enables AI to achieve the game-theoretic\nvalue from the initial position but does not guarantee the ability to capitalize on the opponent's mistakes. A weak\nsolution cannot guarantee a 'perfect' play in a certain sense. On the other hand, a strong solution ensures that the\nAI can accurately capitalize on the opponent's mistakes in an arbitrary position that is reachable from the initial\nposition. However, since a strong solution requires solving all possible positions, achieving this for large games is often\nintractable.\n\nThere is a considerable and challenging gap between weak and strong solving in terms of difficulty. In the game of\n6x6 Othello, for example, the game-theoretic value of the initial position (the first player loses by four points) can be\ndetermined within a few minutes to a few hours using the alpha-beta pruning algorithm [5, 6] equipped with practical\nmove-ordering. In other words, modern, inexpensive computers can quickly achieve ultra-weakly and weakly solving.\nHowever, since the alpha-beta pruning has the same worst-case computational complexity as exhaustive search and"}, {"title": "Methods", "content": "In this study, we propose a class called \u2018semi-strongly solved,' where the game-theoretic value can be determined for all\nreachable board positions, assuming that at least one of the two players is AI. This class guarantees that the AI gameplay\nwill appear perfect from the human opponent's perspective. Furthermore, the proposed method can significantly reduce\nthe computational cost of solving the game compared to strong solving by not providing guarantees for board positions\nthat can only be reached if both human players make a mistake during play. To the best of our knowledge, this proposal\nis novel in this research.\n\nFurthermore, in this study, we propose the \u2018reopening alpha-beta' algorithm as a pruning method to achieve semi-strong\nsolving efficiently. Under simple assumptions about the nature of the game, we derive that the computational complexity\nof the proposed algorithm is O(db), where d is the depth of game-tree and b is branching factor (number of legal\nmoves). To demonstrate the usefulness of the proposed method, we semi-strongly solved the game of 6x6 Othello.\nWe showed that semi-strong solving requires considering far fewer positions than strong solving and, therefore, can\nbe computed at a significantly lower cost. The programs for reproducing the experiments is available on GitHub\n(https://github.com/eukaryo/reopening-alphabeta-experiment )."}, {"title": "Definition of Semi-Strongly Solved", "content": "The definition of 'semi-strongly solved' is that all of the following conditions are satisfied:\n\n1.  Assume that at least one of the players is an AI, which always makes the best move.\n2.  Assume that at most one of the players is a human who may make any possible move.\n3.  Under the above assumptions, the game-theoretic values are determined for all positions that are reachable for\n    AI or humans under reasonable resources.\n\nIn this context, \"game-theoretic values are determined\" ideally means that game-theoretic values of all non-trivial\npositions are stored, and they can be obtained simply by calculating the storage address from the position information\nand reading it. Under these conditions, the corresponding optimal move can always be found through a depth-one\nmini-max search.\n\nIn practice, there are games like Othello where, despite many endgame positions, the number of moves remains until\nthe end is fixed, and the endgame search always completes quickly. For such games, it is reasonable to adopt a method\nthat does not store game-theoretic values of endgames but computes them as needed."}, {"title": "Reopening Alpha-Beta Algorithm", "content": "Below, we described the proposed algorithm to achieve semi-strong solving. The algorithm is called the \u2018reopening\nalpha-beta' algorithm. The notation is as follows: Let D be the depth of the game tree. The initial position is at depth\nD = 1, and positions where d = D are terminal nodes. Any position with d < D is an internal node of the game tree,\nand we assume that the branching factor (i.e., the number of legal moves) is always b (where b \u2265 2).\n\nAdditionally, for simplicity, we assume there are no transpositions (i.e., reaching the same board position via different\nsequences of moves) or repetitions (i.e., returning to a previous board position via some sequence of moves). We assume\nthat move-ordering is optimal. We also assume that any two distinct terminal positions have different game-theoretic\nvalues."}, {"title": "Kinds and Generation Rules of Nodes", "content": "The types of search nodes in the reopening alpha-beta algorithm and their generation rules are described below. The\nfirst child is always the best move based on the assumption that move-ordering is optimal.\n\n1.  P-node: The initial position is a P-node. The first child of a P-node is a P-node, while all subsequent children\n    are A'-nodes. 'P' is derived from the initial letter of Principal Variation and corresponds to Knuth's Type-1\n    Node [5].\n2.  A'-Node: The first child of an A'-node is a P'-node, and all subsequent children are C nodes.\n3.  P'-Node: All children of a P'-node are A'-nodes."}, {"title": "Intuitive Explanation of Each Nodes", "content": "Except for the root node, Every P-Node corresponds to (one of) the best move(s) of their parent node. All P-Nodes\nconstitute a principal variation. Assuming that only P-Nodes are visited when both players are AI and consistently make\nthe best moves from the initial position does not compromise generality. We adopt this assumption in the following\nexplanation.\n\nIn Fig. 1, the purple nodes (P-Nodes) represent nodes both humans and AI can visit. Based on the assumption above, if\nboth players are AI, moves leading to P-Nodes will continuously be selected. However, the converse does not hold.\nEven if moves leading to P-Nodes are consistently selected, the possibility that one of the players is human is not ruled\nout. As a result, it is unclear whether the turn is human or AI while the game is at a P-Node. Therefore, the best move\nof the P-Node and its game-theoretic value must be determined."}, {"title": "Complexity Analysis", "content": "Below, we determine the total number of nodes at depth d under the assumptions above.\n\nHenceforth, the total number of nodes of type Y \u2208 {P, A', P', C, A} at depth x will be denoted as N(Y, x).\n\nFirst, when the total number of each node is expressed in the form of a system of recurrence relations, it can be written\nas follows.\n\n\u2022   P-Node: It is clear that for any d \u2208 [1, D], we have: N(P, d) = 1.\n\u2022   A'-Node: When d = 1, N(A', 1) = 0. When d > 1, N(A', d) = (b \u2212 1)N(P, d \u2013 1) + bN(P', d \u2212 1).\n\u2022   P'-Node: When d = 1, N(P', 1) = 0. When d > 1, N(P', d) = N(A', d \u2212 1).\n\u2022   C-Node: When d = 1, N(C, 1) = 0. When d > 1, N(C', d) = (b \u2212 1)N(A', d \u2212 1) + bN(A, d \u2212 1).\n\u2022   A-Node: When d = 1, N(A, 1) = 0. When d > 1, N(A, d) = N(C, d \u2013 1).\n\nContinuing, we determine the general terms. They are as follows.\n\n\u2022   P-Node: N(P, d) = 1\n\u2022   A'-Node: N(A', d) = b^{\\lfloor \\frac{d}{2} \\rfloor} - 1\n\u2022   P'-Node: N(P', d) = b^{\\lfloor \\frac{d}{2} \\rfloor} - 1\n\u2022   C-Node: N(C, d) = \\frac{b}{b-1} \\lfloor \\frac{d}{2} \\rfloor b^{\\lfloor \\frac{d-1}{2} \\rfloor} - \\frac{b}{b-1} b^{\\lfloor \\frac{d-1}{2} \\rfloor} + 1\n\u2022   A-Node: N(A,d) = \\frac{b}{b-1} \\lfloor \\frac{d}{2} \\rfloor b^{\\lfloor \\frac{d-1}{2} \\rfloor} = \\frac{b}{b-1} b^{\\lfloor \\frac{d-1}{2} \\rfloor} + 1\n\nOverall computational complexity of reopening alpha-beta algorithm is the summation of above terms. Therefore, it is\nO(db)."}, {"title": "Algorithm Description", "content": "Algorithm 2 implements reopening alpha-beta algorithm with principal variation search (also referred to as negascout\n[8, 9]), which is a variant of alpha-beta algorithm. It uses algorithm 1, which implements the rules described in section\n2.2.1. When visiting any P-node or A'-node, reopen the alpha-beta window to [-\u221e, +\u221e] to identify the best move."}, {"title": "Transposition Table", "content": "The transposition table [10] is not used in Algorithm 2. If a node has already been searched for a different type of node\nthan the type to be searched for, and the information is found in the transposition table, whether the search for that node\ncan be omitted depends on the node type."}, {"title": "Experimental Settings", "content": "This study primarily aims to introduce semi-strong solving and propose the reopening alpha-beta algorithm, as detailed\nin this section. To demonstrate its effectiveness, we semi-strongly solved the game of 6x6 Othello. Details on the rules\nof Othello are provided in section 2.4.1."}, {"title": "The Rules of the game of Othello", "content": "1.  The game is played on an NxN grid between two players, one using black discs and the other using white discs.\n    (Usually played with 8x8, but for this experiment, 6x6 was used.)\n2.  The game begins with two black and two white discs placed in the center of the board, arranged in a 2x2\n    square with opposing colors diagonal to each other.\n3.  Players alternate turns by placing a disc on an empty square on the board, with black making the first move.\n4.  When a disc is placed, any of the opponent's discs in a straight line (horizontal, vertical, or diagonal) between\n    the newly placed disc and another disc of the same color are flipped to the player's color.\n5.  A legal move must flip at least one of the opponent's discs.\n6.  If a player has no legal moves, they pass their turn to the other player.\n7.  The game ends when neither player can make a move.\n8.  At the end of the game, the player with the most discs of their color on the board wins.\n9.  The score is determined by the difference in the number of discs. If empty squares remain, their number is\n    added to the winner's score.\n10. If both players have the same number of discs at the end, the game is a draw."}, {"title": "Materials", "content": "To perform following experiments, a PC equipped with Ryzen 5950X CPU and 128GM DRAM was used. Three\n16TB-HDDs under ZFS filesystem (transparent compression using LZ4 is enabled) were used as a storage."}, {"title": "Experimental Results", "content": "To demonstrate the usefulness of the proposed reopening alpha-beta algorithm, we analyzed the game of 6x6 Othello.\nIt was explored in three ways: solved by conventional alpha-beta, solved by proposed reopening alpha-beta, and\ntried solving by full search with width-first search. We counted the number of visited unique nodes. An optimal\nmove-ordering was performed. The number of visited nodes is shown in table 3. Only positions with legal move(s)\nwere enumerated. The colors of the turn side were not distinguished; they were considered an identical position.\n\nAccording to table 3, semi-strong solving by the proposed method visited about 32 times more nodes than weak\nsolving. The ratio is coincidentally very close to that calculated from the theoretical computational complexity of the\nproposed and existing methods (i.e., search depth, 32 in this game). We also attempted to determine the total number of\nrule-reachable phases in this game. Still, due to the limited storage space available, we only counted up to the game's\nmidpoint (i.e., the positions in which up to 25 discs are on the board). Nevertheless, we found that more than 100 times\nas many games were reachable compared to the visited positions by the semi-strong solving."}, {"title": "Discussion", "content": "Based on the above results, we have demonstrated that the proposed algorithm works effectively for a specific game.\nOur experimental focus was primarily on the game of 6x6 Othello; however, extending semi-strong solving to multiple\nindividual games was beyond the scope of this study. Similar to weakly solved games, computational costs for achieving\nsemi-strongly solved games can vary significantly. Game characteristics and the efficiency of move-ordering would\naffect these variations.\n\nDespite this limitation, our experimental results indicate the promising potential of semi-strong solving and the proposed\nalgorithm when applied to individual games. Future research will explore the application of our method to a broader\nrange of games and explore optimization techniques to reduce computational costs."}, {"title": "Algorithm Description", "content": "1:  if k is \"P\" or k is \"A'\":\n2:  \u03b1\u2190-\u221e\n3:  \u03b2\u2190+\u221e\n4:  M\u2190 all legal moves in p\n5:  Sort M in descending order of promise. (i.e., move-ordering)\n6:  for each m\u2208 M:\n7:  p' \u2190 the position after applying the move m to p\n8:  if it is the first iteration: (i.e., m is the most promising):\n9:  score \u2190 -search(p', -\u03b2, -a, get_child_node_kind(k, True))\n10: else:\n11: score \u2190 -search(p', -\u03b1 \u2013 1, -a, get_child_node_kind(k, False))\n12: if a < score < \u03b2:\n13: a \u2190 score\n14: score \u2190 -search(p', -\u03b2, -a, get_child_node_kind(k, True))\n15: a\u2190 max(a, score)\n16: if a \u2265 \u03b2:\n17: return a (perform the beta-cutoff)\n18: return a"}]}