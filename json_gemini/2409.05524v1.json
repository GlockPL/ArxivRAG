{"title": "An Encoding of Argumentation Problems Using Quadratic Unconstrained Binary Optimization", "authors": ["Marco Baioletti", "Francesco Santini"], "abstract": "In this paper, we develop a way to encode several NP-Complete problems in Abstract Argumentation to Quadratic Unconstrained Binary Optimization (QUBO) problems. In this form, a solution for a QUBO problem involves minimizing a quadratic function over binary variables (0/1), where the coefficients can be represented by a symmetric square matrix (or an equivalent upper triangular version). With the QUBO formulation, exploiting new computing architectures, such as Quantum and Digital Annealers, is possible. A more conventional approach consists of developing approximate solvers, which, in this case, are used to tackle the intrinsic complexity. We performed tests to prove the correctness and applicability of classical problems in Argumentation and enforcement of argument sets. We compared our approach to two other approximate solvers in the literature during tests. In the final experimentation, we used a Simulated Annealing algorithm on a local machine. Also, we tested a Quantum Annealer from the D-Wave Ocean SDK and the Leap\u2122 Quantum Cloud Service.", "sections": [{"title": "1 Introduction", "content": "Computational Argumentation is an interdisciplinary field that combines concepts from Artificial Intelligence, Logic, Philosophy, and Cognitive Science to study and develop systems that can model, analyze, and generate arguments [1, 2].\nA good share of the research on the subject of Argumentation [3-5] is based on the theory initiated by Dung in 1995 [6]. There, an Abstract Argumentation Framework (hereafter AF for short) can be visually represented as a directed graph, formally a tuple $F = (A, \\rightarrow)$: nodes point to arguments (the set $A$), and edges (the set $\\rightarrow$) represent a directed \"attack\" relation between two arguments (i.e., $\\rightarrow$: $A \\times A$), in which an argument rebuts another argument. Given such a network, an analysis of which set(s) of arguments can be collectively accepted leads to the definition of semantics. Semantics declaratively rule which coherent sets of arguments can be acceptable for an agent participating in a debate; these sets of arguments are named extensions. Extensions are based on two fundamental concepts: conflict-freeness (an extension cannot contain two arguments in conflict), and admissibility: a set of arguments is admissible if any of its arguments counter-attacks each attacker of its elements, that is, a set \"defends\" all its arguments. For example, a preferred extension is the maximal element (concerning set-theoretical inclusion) among all the possible admissible sets in an AF. Strengthening the basic requirements enforced by admissibility yields complete semantics [7]: admissibility refers to the ability to provide reasons for accepting or rejecting arguments but allows individuals to abstain from deciding on any argument. Complete semantics requires individuals to abstain only when there are no convincing reasons to do otherwise. Maximizing the number of arguments accepted is a concept captured by preferred semantics, while in the stable semantics, every argument that is not accepted is rejected [7].\nIn the AF-based model proposed by [6], arguments have no internal structure. Consequently, they are not composed of premises and claims, as it happens instead when Argumentation is studied at lower levels of abstraction. Moreover, the attack relationship also represents a generic notion of conflict and is not connected to any form of logical negation. As an example of debate, two conflicting arguments could be a: \u201cI should buy an electric car because it is environmentally friendly\" and b: \u201cElectric cars are not so environmentally friendly if the power used to recharge them comes from fossils\", and in this case, b \u2192 a.\nThe paper's second major characteristic involves Quadratic Unconstrained Binary Optimization problems (QUBO), which correspond to a mathematical formulation that encompasses a wide range of critical Combinatorial Optimization problems: QUBO has been surveyed in [8, 9], and the first work dates back to 1960 [10]. A solution to a QUBO problem consists of minimizing a quadratic function over binary variables (that is, 0/1), whose coefficients can be represented with a symmetric square matrix or in an equivalent upper triangular form achieved without loss of generality. QUBO problems are NP-Complete: for this reason, a vast literature is dedicated to approximate solvers based on heuristics or metaheuristics, such as simulated annealing approaches (SA), tabu-serch, genetic algorithms or evolutionary computing [8]. There are also exact methods capable of solving QUBO problems with 100-500 variables [8].\nQUBO is also the mathematical model accepted by quantum and digital annealers. Hence, a QUBO formulation of an optimization problem is important because it allows the use of these new alternative computing devices.\nIn this paper, we propose an encoding to QUBO of some classical problems in Argumentation, such as:"}, {"title": "2 Background", "content": "This section presents the fundamental background concept necessary to understand the rest of this work. Section 2.1 describes Argumentation [6] by first introducing fundamental notions such as AFs, semantics, and related problems to be solved and then presenting an extension of such problems to enforce extensions. Section 2.2 comments on QUBO problems and their solutions."}, {"title": "2.1 Problems in Abstract Argumentation Frameworks", "content": "An Abstract Argumentation Framework (AF, for short) [6] is a tuple $F = (A, \\rightarrow)$ where $A$ is a set of arguments and $\\rightarrow$ is a relation $\\rightarrow \\subseteq A \\times A$. For two arguments $a, b \\in A$, the relation $a \\rightarrow b$ means that argument $a$ attacks argument $b$. An argument $a \\in A$ is defended by $S \\subseteq A$ (in $F$) if for each $b \\in A$, such that $b \\rightarrow a$, there is some $c \\in S$ such that $c\\rightarrow b$. A set $E \\subseteq A$ is conflict-free (cf in $F$) if and only if there is no $a,b \\in E$ with $a \\rightarrow b$. $E$ is admissible (ad in $F$) if and only if it is conflict-free and if each $a \\in E$ is defended by $E$. Finally, the range of $E$ in $F$, i.e., $\\overline{E}$, collects the same $E$ and the set of arguments attacked by $E$ is\n$\\overline{E} = E \\cup \\{ a \\in A \\mid \\exists b \\in E : b \\rightarrow a \\}.\n$A directed graph can straightforwardly represent an AF: an example with five arguments is given in Figure 1: $F = (\\{a,b,c,d,e\\}, \\{a \\rightarrow b,c \\rightarrow b,c \\rightarrow d,d \\rightarrow c,d \\rightarrow e\\})$.\nThe collective acceptability of arguments depends on the definition of different semantics. Semantics determine sets of jointly acceptable arguments, i.e., sets of arguments called extensions, by mapping each $F = (A, \\rightarrow)$ to a set $\\sigma(F) \\subseteq 2^A$, where $2^A$ is the power-set of A, and $\\sigma$ parametrically stands for any of the considered semantics.\nFour semantics were proposed by Dung in his seminal paper [6], namely the complete (co), preferred (pr), stable (st), and grounded (gr) semantics. Succesive works defined the semi-stable (sst) [16], the stage (stg) [17], the ideal (id) [18], and finally the eager (eg) [19] semantics. Given $F = (A, \\rightarrow)$ and a set $E \\subseteq A$, we report the definition of all these semantics:\n*   $E \\in co(F)$ iff $E$ is admissible in $F$ and if $a \\in A$ is defended by $E$ in $F$ then $a \\in E$,\n*   $E \\in pr(F)$ iff $E \\in co(F)$ and there is no $E' \\in co(F)$ s.t. $E' \\supset E$,\n*   $E \\in sst(F)$ iff $E \\in co(F)$ and there is no $E' \\in co(F)$ s.t. $\\overline{E'} \\supset \\overline{E}$,\n*   $E\\in st(F)$ iff $E \\in co(F)$ and $\\overline{E} = A$,\n*   $E \\in stg(F)$ iff $E$ is conflict-free in $F$ and there is no $E'$ that is conflict-free in $F$ s.t. $\\overline{E'} \\supset \\overline{E}$,\n*   $E \\in gr(F)$ iff $E \\in co(F)$ and there is no $E' \\in co(F)$ s.t. $E' \\subset E$,\n*   $E \\in id(F)$ if and only if $E$ is admissible, $E\\subseteq \\cap pr(F)$ and there is no admissible $E' \\subset \\cap pr(F)$ s.t. $E'\\supset E$;\n*   $E\\in eg(F)$ if and only if $E$ is admissible, $E \\subseteq \\cap sst(F)$ and there is no admissible $E' \\subseteq \\cap sst(F)$ s.t. $E' \\supset E$.\nWe now report below the definition of six well-known problems in Argumentation, all of which are decision ones (yes/no answer):\n*   Credulous acceptance DC-$\\sigma$: given $F = (A,\\rightarrow)$ and an argument $a \\in A$, is $a$ contained in some $E \\in \\sigma(F)$?\n*   Skeptical acceptance DS-$\\sigma$: given $F = (A,\\rightarrow)$ and an argument $a \\in A$, is $a$ contained in all $E\\in \\sigma(F)$?\n*   Verification of an extension VER-$\\sigma$: given $F = (A, \\rightarrow)$ and a set of arguments $E \\subseteq A$, is $E \\in \\sigma(F)$?\n*   Existence of an extension EX-$\\sigma$: given $F = (A, \\rightarrow)$, is $\\sigma(F) \\neq \\emptyset$?\n*   Existence of non-empty extension NE-$\\sigma$: given $F = (A, \\rightarrow)$, does there exist $E \\neq \\emptyset$ such that $E \\in \\sigma(F)$?\n*   Uniqueness of the solution UN-$\\sigma$: given $F = (A, \\rightarrow)$, is $\\sigma(F) = \\{E\\}$?"}, {"title": "2.1.1 Extension Enforcement Problems", "content": "In a multi-agent system, AFs are used to represent and reason about different schemes of dialogues (e.g., persuasion- or negotiation-oriented dialogues). Regardless of the subject, it is crucial to understand the dynamics of debates and, consequently, AFs and how to update them in response to new information. This problem has been studied for the first time in [29, 30]: these works enforce a set of arguments by adding new arguments and some attacks between such new arguments; attacks need to satisfy some constraints, for example, in a strong expansion [29], no new attack is directed from a former argument to a new one. However, no change to $\\rightarrow$ only is allowed in such papers.\nAlong the same line of research, the work in [31] presents the task of extension enforcement: the authors consider the objective to change the attack relationship $\\rightarrow$ of a framework $F = (A, \\rightarrow)$ such that a given set $T \\subseteq A$ becomes (a subset of) an extension under a given semantics $\\sigma$. In this case, the enforcement is argument-fixed since only the attack relationship can be modified by adding or removing arguments. This form of enforcement is generally characterized by two distinct levels of requirements: Strict enforcement is satisfied if $T$ is precisely a $\\sigma$-extension. In contrast, in non-strict enforcement $T$ is only required to be a subset of a $\\sigma$-extension. Enforcement operators are helpful in many scenarios, particularly when multiple agents are involved in heated debates. In such debates, new arguments often challenge previously accepted extensions, and an agent may feel compelled to develop new arguments to support their preferred view. However, in numerous other situations, no new argument can be used to explain the change, and thus, differently from [29, 30], only the attack relationship can be modified.\nWhen considering the Hamming distance of the changes, i.e., $| \\rightarrow \\triangle \\rightarrow' | = | \\rightarrow \\backslash \\rightarrow'| + |\\rightarrow' \\backslash \\rightarrow|$, in [31] the authors impose a threshold $| \\rightarrow \\triangle \\rightarrow' | \\leq k$ as a further parameter of these problems. The complexity of some of these problems is reported in Table 2: Even in this case, some problems are characterized by NP-Completeness and are consequently predisposed to be solved in a QUBO format.\nIn this paper, as proposed in [11], we look at the problem from an optimization point of view by minimizing the number of modifications (i.e., addition and removal of attacks) needed on an AF to make a set of arguments (or a subset) satisfy a given semantics on the modified AF:"}, {"title": "Definition 1 (Extension enforcement [11]).", "content": "Given a framework $F = (A, \\rightarrow)$, a set of arguments $T \\subseteq A$, and a semantics $\\sigma$, strict extension enforcement is an optimization problem where the goal is to find $F^* = (A, \\rightarrow^*)$ s.t.:\n$\\rightarrow^* \\in \\mathop{\\rm argmin}_{\\rightarrow' \\in enfs_t(F,T,\\sigma)} |\\rightarrow \\triangle \\rightarrow'|$\nwhere $enfs_t(F,T,\\sigma) = \\{ \\rightarrow' \\mid F' = (A,\\rightarrow'),T \\in \\sigma(F') \\}$ is the strict enforcement relation: $T \\in \\sigma(F^*)$. Similarly, we can define the same problem by considering non-strict enforcements (by defining $enfns_t(F,T, \\sigma) = \\{ \\rightarrow' \\mid F' = (A, \\rightarrow'),T \\subseteq (E\\in \\sigma(F'))\\} )$.\nIf we still consider the framework $F$ in Figure 1, we have for example that if we want to strictly enforce $T = \\{a,e\\}$ as a complete extension, the solution corresponds to $\\{a \\rightarrow b,c \\rightarrow b,c \\rightarrow d,d \\rightarrow c, \\}$: it is enough to remove $d \\rightarrow e$ from the attacks."}, {"title": "2.2 Quantum Annealing and QUBO", "content": "Quantum Annealing is a procedure [32] that employs a quantum computing device to solve optimization problems formulated in terms of finding a configuration of minimum energy.\nIt is based on the Quantum Adiabatic Theorem and it employs quantum tunneling effects to produce optimal or near/optimal solutions of a discrete optimization problem.\nThe process starts with an initial function $o_s$, for which the solution that minimizes the energy is easy to find, and slowly transitions to the final function $o_f$, which corresponds to the function to be optimized. If the transition is enough slow, the Quantum Adiabatic Theorem guarantees that the solution with the minimum energy adapts to the change of the objective function.\nD-Wave produces a series of quantum annealers, which are computing devices implementing the quantum annealing algorithm. In particular, the most advanced machines are able to handle problems with thousands of variables.\nQuantum annealers can be \"programmed\" by describing the problems as Quadratic Unconstrained Binary Optimization (in short, QUBO) or as Ising models [33].\nIn this paper, we employ the QUBO formalism. It is expressive enough to encode several optimization problems formulated in various application domains [34].\nQUBO has been intensively investigated and is used to characterize and solve a wide range of optimization problems: for example, it encompasses SAT Problems, Constraint Satisfaction Problems, Maximum Cut Problems, Graph Coloring Problems, Maximum Clique Problems, General 0/1 Programming Problems, and many more [35]. Moreover, QUBO embeddings exist for Support Vector Machines, Clustering algorithms, and Markov Random Fields [36]."}, {"title": "In a QUBO problem,", "content": "n binary variables $x_1,...,x_n$ and an $n \\times n$ upper-triangular matrix $Q$ are used to formulate the task, which involves minimizing (or maximizing) the function\n$f(x) = \\sum_{i=1}^n Q_{i,i} x_i + \\mathop{\\acute{E}}_{i<j}^n Q_{i,j} x_i x_j$\nThe diagonal terms $Q_{ii}$ are the linear coefficients, and the non-zero off-diagonal terms $Q_{i,j}$ are the quadratic coefficients. This can be expressed more concisely as\n$\\min_{x \\in \\{0,1\\}^n} x^T Qx$\nwhere $x^T$ denotes the transpose of the vector $x$. The square matrix of coefficients can be organized in a symmetric way, where for all $i, j$ except $i = j$, $Q_{i,j}$ is replaced by $(Q_{i,j} + Q_{j,i})/2$, or, as stated before, in an upper-diagonal form where for all $i, j$ s.t. $i > j$, $Q_{i,j}$ is replaced by $Q_{i,j} + Q_{j,i}$ and then all $Q_{i,j}$ are replaced by 0 for $j < i$.\nThe formulation of a discrete constrained optimization problem as QUBO requires the following steps: i) find a binary representation for the solutions, and ii) define a penalization function that penalizes unfeasible solutions (i.e., violating a constraint).\nExcept for the 0/1 limitations on the decision variables, QUBO is an unconstrained model in which the Q matrix contains all the problem data. Due to these features, the QUBO model presents an innovative perspective on classically limited representations and is especially appealing as a modeling framework for combinatorial optimization issues. Rather than applying constraints in the conventional sense, classical constrained models can be successfully reformulated as QUBO models by inserting quadratic penalties into the objective function. Minimization problems are enhanced by applying penalties to produce an augmented objective function, which must be minimized. The augmented objective function becomes equivalent to the original function if the penalty terms are reduced to zero.\nWhen optimizing a problem with constraints, choosing a penalty that is too small can result in unfeasible solutions. However, selecting a large penalty value to enforce the constraints can cause difficulties for the optimization algorithm in finding feasible solutions. This approach can also lead to other issues, such as sensitivity to penalty values, increased computational efforts during optimization, and instability during the solver's iterations. For this reason, a sensitive amount of literature has been produced to find good coefficients [37, 38], or techniques to model classical constraints into a function, e.g., a logical and constraint between $x_1$ and $x_2$ as a multiplication $x_1 x_2$.\nThe literature discussing precise approaches for QUBO using conventional computers consists of various algorithms [34], all of which share the characteristic that, if given enough time and memory, they end with a globally optimal solution. Most of these techniques use a standard branch-and-bound tree search, although alternative methods are also available.\nFor example, in [39], a QUBO solution is based on the inherent geometric properties of the minimum circumscribed sphere that contains the ellipsoidal contour of the objective function, while in [40], the authors adopt Lagrangean decompositions.\nMany research papers have been published in recent years due to the NP-hardness and potential applications of QUBO. These papers describe various heuristic approaches to quickly find high-quality solutions for medium- to large-sized problem cases. Although some of these techniques are simple enough to be called heuristics, the most effective are meta-heuristic processes that use compound strategies that are more advanced than those found"}, {"title": "2.3 Simulated Annealing", "content": "Simulated Annealing (SA) is a probabilistic optimization algorithm inspired by the process of annealing in metallurgy, where a material is heated and then slowly cooled to reach a low-energy state [44]. Three main steps characterize the algorithm: i) initialization, ii) temperature initialization, and iii) iteration.\nWith initialization, the algorithm starts with an initial solution to the optimization problem; this solution can be generated randomly or by using some heuristic method. In temperature initialization, an initial temperature T is set; T determines the probability of initially accepting worse solutions. The temperature gradually decreases over time. During the iteration phase, the algorithm repeats until a stopping criterion is met (e.g., a maximum number of iterations or when the temperature drops below a certain threshold).\nDuring iteration, the first step usually consists of perturbing the current solution to generate a neighboring solution; this perturbation can involve minor changes to the current solution. Afterward, the algorithm calculates the corresponding change $\\Delta(Energy)$ in the value of the objective function between the current solution and the neighboring solution. If $\\Delta(Energy)$ is negative (i.e., the neighboring solution is better), the algorithm accepts the neighboring solution. Otherwise, the algorithm accepts the neighboring solution with a probability determined by a temperature-dependent acceptance probability function. This allows the algorithm to escape local minima and explore the solution space more effectively. In the final step of the iteration phase, the algorithm updates the current solution if the neighboring solution is accepted, and it decreases the temperature according to a cooling schedule, which controls the rate at which the temperature decreases. The cooling schedule can be linear, exponential, or follow other schemes. The algorithm stops when the stopping criterion is met, and the best solution found during the iterations is finally returned.\nSimulated Annealing allows the algorithm to explore the solution space by initially accepting worse solutions with a certain probability, which gradually decreases as the temperature decreases. This property enables the algorithm to escape local optima and potentially find better solutions. The cooling schedule balances exploration and exploitation, determining how quickly the algorithm converges to an optimal solution."}, {"title": "3 Encoding", "content": "This section presents a QUBO encoding of some Argumentation problems in Section 2. In Section 3.1, we focus on all the NP-Complete cases shown in Table 1 because solving QUBO is NP-Complete in turn. More specifically, the encoded problems are DC-$\\sigma$, EX-$\\sigma$, and NE-$\\sigma$, while the considered semantics are $\\sigma = \\{ad, co, pr, st, sst\\}$.\nAfter that, in Section 3.2, we formulate an encoding for extension enforcement problems as introduced in Section 2.1.1; in particular, we focus on all NP-Complete problems regarding strict enforcement in Table 2 (i.e., with complete and grounded semantics)."}, {"title": "3.1 Encoding Extension-based Semantics Problems", "content": "The encoding of problems in Argumentation uses a set of n binary variables $x_1,...,x_n$ associated with the arguments $\\{a_1,..., a_n\\}$ in A. The variables $x_1,...,x_n$ represent a subset E of A: $a_i \\in E$ if and only if $x_i = 1$. We denote by $x$ the tuple of variables $(x_1,...,x_n)$ and by $x \\in \\{0,1\\}^n$ a vector of possible values for $x_1, ..., x_n$. Each semantics $\\sigma$ will be associated with a quadratic penalty function $P_{\\sigma}$ such that $P_{\\sigma}$ assumes its minimum value in $x$ if and only if the corresponding set $E = \\{a_i \\in A : x_i = 1\\}$ is an extension valid for $\\sigma$.\nMost of the argumentation semantics require admissible sets. Hence, we define a penalty function $P_{adm}$ that enforces this property, which is the sum of 4 terms. The first term forces the set E to be conflict-free:\n$P_{cf} = \\sum_{i\\rightarrow j} x_i x_j\n$(1)\nThe value of $P_{cf}$ corresponds to the number of internal attacks in E, and its value is 0 if and only if E is conflict-free.\nThe constraints to model the notion of defense are more complicated and require some sets of additional variables. The first set contains the variables $t_1,...,t_n$, denoting which arguments are attacked by E: $t_i = 1$ if and only if some argument of $E$ attacks $a_i$.\nThe variables $d_1,...,d_n$ of the second set denote which arguments are defended by E: $d_i = 1$ if and only if $a_i$ is defended (from all possible attacks) by some arguments of E. For each argument $a_i$, the penalty function $P_i$ forces $t_i$ to be 1 if and only if $a_i$ is attacked by E, i.e., $t_i = \\bigvee_{j\\rightarrow i} x_j$.\nThe function\n$OR(z,x,y) = z + x + y + xy - 2z(x+y)\n$(2)\nis used to express the constraint that the binary variable $z$ is the disjunction $z = (x or y)$ of the binary variables x, y as a quadratic function, as shown in [45].\nEach penalty function $P_i$ requires $\\max\\{h_i - 2,0\\}$ auxiliary variables, where $h_i$ is the number of attackers of $a_i$. Of course, if $h_i \\leq 2$, no additional variable is required. More details can be found in [14].\nThe other penalty function $P_j$ forces $d_i$ to be 1 if and only if $a_i$ is defended by E, i.e., $d_i = \\bigwedge_{j\\rightarrow i} t_j$. The term is encoded by means of the function [45]\n$AND(z,x,y) = 3z + xy - 2z(x+y)\n$(3)\nwhich expresses the conjunction $z = (x and y)$ of binary variables x, y as a quadratic function. In addition, $P_j$ requires $\\max\\{h_i - 2,0\\}$ auxiliary variables. The final term\n$P_{def} = \\sum_{i=1}^n x_i (1 - d_i)\n$(4)\nforces each argument in E to be defended by E. Summing up, the penalty function for admissible sets is\n$P_{adm} = P_{cf} + \\sum_{i=1}^n P_i + \\sum_{i=1}^n P_j + P_{def}\n$(5)\nIt is easy to prove that the minimum value of $P_{adm}$ is 0, and the related values for x correspond to admissible sets."}, {"title": "3.1 Encoding Extension-based Semantics Problems", "content": "It is important to note that the total number of binary variables needed for $P_{adm}$ is\n$N = 3n + 2 \\sum_{i=1}^n \\max(h_i - 2,0).\n$Note that if $h = \\max(h_i)$, then $N = O(nh)$. For the complete semantics, we need to add an additional term to $P_{adm}$ which forces all the arguments defended by E to be elements of E:\n$P_{co} = P_{adm} + \\sum_{i=1}^n (1 - x_i)d_i\n$(6)\nConcerning the preferred semantics, since the problem of verifying whether a set E belongs to pr is coNP-Complete, it is unlikely to find a formulation of this semantics in QUBO with a polynomial number of binary variables.\nHowever, it is possible to find preferred extensions of maximum cardinality with QUBO by minimizing the combination of the penalty function $P_{co}$ and a term that corresponds to $|E^C|$, i.e., the size of the complementary of E:\n$P_{pr} = \\sum_{i=1}^n (1 - x_i) + (n+1) \\cdot P_{co}\n$(7)\nIt is easy to see that the minimum value of $P_{pr}$ is $s \\leq n$, and the related values for x correspond to complete sets with maximum cardinality s. On the other hand, any combination of values x such that $P_{pr}$ is greater than n corresponds to a set of arguments that is not complete. It is essential to understand that the extensions found with this method can only be a subset of all pr extensions.\nThe considerations about the semi-stable semantics are similar to the preferred semantics because of coNP-Completeness of the verification problem. Again, it is possible to find a semi-stable extension of maximum cardinality by minimizing the following objective function:\n$P_{sst} = \\sum_{i=1}^n (1 - t_i) + (n+1) P_{co}\n$(8)\nwhere the additional term corresponding to the number of arguments not attacked is added to $P_{co}$. Hence, the minimum value of $P_{sst}$ is $s < n$, and the related values of x correspond to complete sets where the number of arguments not attacked is s. Even in this case, the method is not complete because it cannot find semi-stable extensions whose cardinality is less than s.\nFinally, the encoding of the stable semantics is obtained by adding an additional term to $P_{co}$ which forces all the arguments not belonging to E to be attacked by E:\n$P_{st} = P_{co} + \\sum_{i=1}^n (1 - x_i)(1 - t_i)\n$(9)\nIt is straightforward to prove that the minimum value of $P_{st}$ is 0 if and only if the corresponding E belongs to st. Hence, this encoding can solve the task EX-st.\nTo express that E is not empty (that is, solving task NE) in a given semantics $\\sigma$, it is sufficient to add to the corresponding penalty function $P_{\\sigma}$ a term which enforces the constraint"}, {"title": "3.1 Encoding Extension-based Semantics Problems", "content": "$\\bigvee_{i=1}^n x_i = 1.\n$In general, the minimum value of $P_{\\sigma} + P_{ne}$ is 0 if and only if E is not empty.\n(10)\nThis task can also be solved for pr and for sst semantics using QUBO because, although there are no complete encodings for pr and for sst, the existence of a non-empty extension for these semantics is reduced to the same problem for ad semantics [20].\nIt is important to notice that the number of binary variables needed to solve the task NE increases to\n$N + n - 2 = 4n - 2 + 2 \\sum_{i=1}^n \\max(h_i - 2,0)\n$because the term (10) requires n - 2 additional variables.\nTo express that a given argument $a_i$ must appear in E (i.e., the DC task), it is sufficient to force $x_i$ to be 1 and propagate this setting in all encodings, thus obtaining a simplified quadratic function, with a reduced number of binary variables. It is easy to see that the minimum value of this function is 0 if and only if $a_i$ is credulously accepted.\nFurthermore, QUBO can solve the credulous acceptance for pr because this problem is equivalent to checking the credulous acceptance in admissible sets [20]. In Section 4.1, we will use such an encoding during tests.\nFinally, it is possible to use QUBO to solve the negative formulation of the skeptical acceptance (the task), i.e., to verify that a given argument $a_i$ is not contained in all $E \\in \\sigma(F)$. It is sufficient to replace $x_i$ with 0 and propagate this setting in the encoding of $\\sigma$. It is easy to see that the minimum value of this function is 0 if and only if $a_i$ is not skeptically accepted.\nTo clarify the presented encoding, we introduce Example 1 where DC-co and DC-st problems are presented.\nTaking into account the framework in Figure 1, we denote the arguments with the indices $a_1 = a, a_2 = b, a_3 = c, a_4 = d$, and $a_5 = e$.\nIn the first step, we obtain $P_{cf} = x_1 x_2 + x_2 x_3 + x_3 x_4 + x_4 x_5$. The defense encoding does not need any auxiliary variables other than $t_i$ and $d_i$ because each argument has at most two attackers. The variables $t_i$ are constrained as\n$t_1 = 0, t_2 = x_1 \\lor x_3, t_3 = x_4, t_4 = x_3, t_5 = x_4.\n$Therefore the only penalty term in $P_{adm}$ is related to $t_2$. After some simplification, the variables $d_i$ are constrained as\n$d_1 = 1, d_2 = 0, d_3 = x_3, d_4 = x_4, d_5 = x_3.\n$The penalty function $P_{def} = x_1 (1 - d_1) + x_2 (1 - d_2) + x_3 (1 - d_3) + x_4 (1 - d_4) + x_5 (1 - d_5)$ is simply $P_{def} = x_2 + x_5 (1 - x_3)$ because, for any binary variable $x_i$, the term $x_i (1 - x_i)$ reduces to 0. Therefore,\n$P_{adm} = x_1 x_2 + x_2 x_3 + x_3 x_4 + x_4 x_5 + x_2 + x_5 (1 - x_3)\n$(11)\nNote the term about $t_2$ (i.e., $OR(t_2, x_1, x_3)$) can be ignored because $t_2$ does not appear in the rest of the formula. The penalty function"}, {"title": "3.1 Encoding Extension-based Semantics Problems", "content": "$P_{co"}, "P_{adm} + (1 - x_1)d_1 + (1 - x_2)d_2 + (1 - x_3)d_3 + (1 - x_4)d_4 + (1 - x_5)d_5\n$reduces to\n$P_{co} = x_1 x_2 + x_2 x_3 + x_3 x_4 + x_4 x_5 + x_2 + x_5 + x_3 - 2x_3 x_5 + 1 - x_1\n$(12)\nThis function is the starting point for solving the task DC-co:, given any argument $a_i$, it is sufficient to set $x_i$ to 1, simplify $P_{co}$, and minimize it. Regarding the st semantics, the objective function is\n$P_{st} = P_{co} + (1 - x_1)(1 - t_1) + (1 - x_2)(1 - t_2) + 2(1 - x_3)(1 - x_4) + (1 - x_5)(1 - x_4)\n$(13)\nwhich finally reduces to\n$P_{st} = x_1 x_2 + x_2 x_3 + 3x_3 x_4 + 2x_4 x_5 - x_3 - 3x_4 - 2x_3 x_5 + 2(1 - x_1) - t_2 + x_2 t_2 + x_4 x_5 + 5 + AND(t_2, x_1"]}