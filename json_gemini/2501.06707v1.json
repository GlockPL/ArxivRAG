{"title": "ELIZA Reanimated: The world's first chatbot\nrestored on the world's first time sharing system", "authors": ["Rupert Lane", "Anthony Hay", "Arthur Schwarz", "David M. Berry", "Jeff Shrager"], "abstract": "ELIZA, created by Joseph Weizenbaum at MIT in the early 1960s, is\nusually considered the world's first chatbot. It was developed in MAD-\nSLIP on MIT's CTSS, the world's first time-sharing system, on an IBM\n7094. We discovered an original ELIZA printout in Prof. Weizenbaum's\narchives at MIT, including an early version of the famous DOCTOR script,\na nearly complete version of the MAD-SLIP code, and various support\nfunctions in MAD and FAP. Here we describe the reanimation of this\noriginal ELIZA on a restored CTSS, itself running on an emulated IBM\n7094. The entire stack is open source, so that any user of a unix-like OS\ncan run the world's first chatbot on the world's first time-sharing system.\n\n\"We can only see a short distance ahead, but we can see plenty there that\nneeds to be done.\u201d (The last line of Turing's 1950 MIND paper [34])", "sections": [{"title": "ELIZA's Ancestry", "content": "If Alan Turing was Al's founding father, Ada Lovelace may well have been\nits founding mother. Over a century before Turning famously proposed using\nthe Imitation Game to determine whether a computer is intelligent [34], Lady\nLovelace described the potential of Charles Babbage's Analytical Engine to \"act\nupon other things besides number, were objects found whose mutual fundamen-\ntal relations could be expressed by those of the abstract science of operations,\nand which should be also susceptible of adaptations to the action of the operat-\ning notation and mechanism of the engine.\" [27] She gives the example of music:\n\n\"Supposing, for instance, that the fundamental relations of pitched sounds in\nthe science of harmony and of musical composition were susceptible of such\nexpression and adaptations, the engine might compose elaborate and scientific\npieces of music of any degree of complexity or extent.\"\n\nAda's prescient insight that machines could act upon entities besides num-\nbers foreshadowed symbolic computing which, in the 1950s, a mere moment\nafter Turing's famous paper, arose, and remains today, one of the foundations\nof artificial intelligence [28]. Symbolic computing, along with list processing, has\nseen application in every domain, particularly in Natural Language Processing\n(NLP), the linage that begat chatbots, of which Joseph Weizenbaum's ELIZA\nis considered the earliest exemplar [36]."}, {"title": "ELIZA's Descendancy", "content": "Weizenbaum foresaw that \"[t] here is a danger [...] that the example [ELIZA]\nwill run away with what it is supposed to illustrate\" [36, p. 43]. Indeed, it did!\nThrough interesting and complex criss-crossing histories, described in detail\nin [35], Danny Bobrow, a recent MIT AI graduate who headed up BBN's AI\nprogram, brought McCarthy, and thus Lisp, to BBN, where Bernie Cosell was\nexposed to it. Shortly after the MAD-SLIP ELIZA appeared in CACM, Cosell\nwrote a near-clone of it in Lisp [31].\nShortly after Cosell wrote his Lisp ELIZA, BBN became the leading technical\ncontractor for the nascent ARPAnet, which of course begat the Internet and\nthence The Web. BBN built the ARPAnet's core hardware and software [9].\nOnce the ARPANet was up, with BBN as one of the founding sites, Cosell's\nLisp ELIZA diffused rapidly through that network and across the soon-to-be\nLisp-centered world of academic AI. As a result, Cosell's Lisp ELIZA rapidly\nbecame the dominant strain, and Weizenbaum's MAD-SLIP version, invisible\nto the ARPAnet, was left to history.\nCosell reports:\n\n\"When I was working on the PDP-1 time-sharing system [...] I thought I\nwould learn Lisp. That spring, Joe Weizenbaum had written an article for\nCommunications of the ACM on ELIZA. I thought that was way cool. [...]\nHe described how ELIZA works and I said, 'I bet I could write something\nto do that.' And so I started writing a Lisp program on [the] PDP-1\nsystem at BBN.\" [31, p. 540] He continues, \"I wrote that program and got"}, {"title": "ELIZA Rediscovered", "content": "MAD was soon replaced by other ALGOL-like languages, and Lisp's widespread\nadoption eclipsed SLIP. Few aside from a tiny cadre of AI historians concerned\nthemselves with the whereabouts of the original ELIZA code until 2021 when\nJeff Shrager - the author of the 1973/1977 BASIC ELIZA - and MIT archivist\nMyles Crowley found what appeared to be a complete copy of the source among\nWeizenbaum's papers [15]. Shrager contacted the Weizenbaum estate who\ngranted permission to open source the code [16]. In a CoRecursive podcast of\nJuly 2022 Shrager recounts the moment of discovery:\n\n\"[Myles and I] pulled the box [labeled ...] 'computer conversations, box\neight'. [I said ...] we're looking for some code [...]. We opened [...] Folder\none, box eight, and [...] there's ELIZA, there's [some version printed out\nof] the original ELIZA with the [...] almost exact doctor script. [...] We\n[also] found many conversations with ELIZA that nobody had ever seen\nbefore, many of them hand edited by Weizenbaum.\" [17]\n\nShrager (at that time, and in a later exploration of the archives undertaken\nby Shrager and David Berry) also found relevant underlying code, including crit-\nical parts of MAD-SLIP, written in both MAD and FAP, the 'Fortran Assembler\nLanguage'."}, {"title": "ELIZA Analyzed", "content": "Simply reading the MAD-SLIP code revealed that there were several function-\nalities described in the 1966 paper that were not in the found version:\n\n\u2022 The preliminary transformation PRE reassembly pattern is not implemented,\nfor example:\n\n(I'M = YOU'RE ((O YOU'RE O)\n(PRE (YOU ARE 3) (=I))))\n\n\u2022 Neither the keyword stack nor the NEWKEY reassembly rule are supported,\nfor example:\n\n(DREAMT 4 ((O YOU DREAMT 0)\n(REALLY, 4)\n(HAVE YOU EVER FANTASIED 4 WHILE YOU WERE AWAKE)"}, {"title": "ELIZA Reanimated", "content": "Reanimating ELIZA from the discovered code may have been the best route\nto proving that we had a \"real\" ELIZA in our hands, but it was not simple!\nIt required numerous steps of code cleaning and completion, emulator stack\ninstallation and debugging, non-trivial debugging of the found code itself, and\neven writing some entirely new functions that were not found in the archives or\nin the available MAD and SLIP implementations.\nRupert Lane (RL), an aficionado of early operating systems, had been work-\ning with MTS (The Michigan Time Sharing system, which has MAD and SLIP\nimplementations). David Berry (DB) ask him to think about bringing up the\noriginal ELIZA. After some discussion with the rest of the team we realized that\nit would be simpler to bring up the original ELIZA in its original environment\nof CTSS on the 7094."}, {"title": "CTSS on the 7094", "content": "MIT'S CTSS, first introduced in 1963 at MIT, was the first multi-user time\nsharing system [7]. It brought many innovations such as a disk filing system,\nreal time communication with users via typewriter terminals, and the ability to\ndevelop programs interactively without waiting hours or days for batch execu-\ntion. It would have been impossible for Weizenbaum to develop ELIZA without\nsuch a system.\nCTSS ran on the IBM 7094, an early transistorized computer with only 32k\nof user memory, a 36 bit word length, and a clock speed of around 450kHz. At\nthat time a 7094 cost $2.9 million (equivalent to $23 million in 2023), and MIT\nheavily modified it, including adding a second 32k memory bank for system\nsoftware. CTSS could support around 30 simultaneous users and was in use at\nMIT until the early 1970s.\nAn emulator for the 7094 was written by David Pitts, based on work by\nPaul Pierce, and a working version of CTSS was brought up on that machine\nby David in the early 2000s [18]."}, {"title": "Restoring the Code", "content": "The combination of MAD and SLIP that constitutes the ELIZA stack is around\n2600 lines of mostly un-commented MAD and FAP code. Getting this into\nmachine readable format was non-trivial; it did not OCR well, so Anthony\nHay (AH) and Art Scwartz (AS) manually transcribed most of it. AH had\npreviously done a careful analysis of the algorithm and script as described in\nthe original 1966 paper, and wrote a C++ version of ELIZA that is, so far\nas we know, the best clone of the original [19]. AS has worked with SLIP for\nmany years and is the author of the GNU SLIP library [20]. Their expertise\nwas invaluable in navigating the code.\nRL fed each file into the compiler on the virtual CTSS system, which helped\nhunt down typos and let us understand the structure of the code. Some of the\nunique challenges of working with this code included:\n\n\u2022 CTSS uses 6 bit BCD character encoding, packing six characters into a\n36 bit word. (This was before bytes or ASCII were invented!)\n\n\u2022 The MAD language uses long keywords like WHENEVER, but allows the\nprogrammer to abbreviate them to things like W'R. Although understand-\nable in the era of punch cards, this makes the code difficult to read (and\nOCR).\n\n\u2022 Source code was often created on punch cards at that time, so column\nlayout is important. For example, to enter lines longer than 78 characters,\none punched a 1 in column 11 of the continuation card."}, {"title": "Missing Functions and other Minor Issues", "content": "As we got each piece compiled, we realized that several functions were missing:\n\n\u2022 BCDIT, used in function FRBCD, appears to be converting a binary number\n(the rightmost 18 bits according to the multiplication of K) to a string of\nBCD. We replaced this with the CTSS library routine DELBC.\n\n\u2022 INLST is used in XMATCH and ASSMBL, two of the most critical ELIZA\nfunctions. It appears in the Fortran implementations of SLIP, and seems\nto take the cells of the first parameter and add them to the left of the list\ncells of the second parameter, so we wrote our own in MAD.\n\n\u2022 The LETTER function was not in either the MAD or SLIP documentation,\nwas not in the archive code, and google was not helpful. Inference from\nthe calling code suggested that it classified characters in a word into one of\n14 categories (An equal sign ('=') returns 1, a comma (',') return 13, the\ndigits '0'-'9' return 12, etc.) We wrote this function ourselves, in MAD.\n\n\u2022 We had FAP code for KGETBL that returned the desired entry in the right\nhand 6 bits but padded the remaining positions with spaces, so we masked\nthese off.\n\n\u2022 The MAD compiler on CTSS seems not to support $$ in string constants\nto mean emit a single $. The 1963 MAD manual confirms this, saying\nthere is no clean way to put a $ in a string [8, p. 20], but suggests this\nsomewhat bizarre workaround: TEST=-$=$ will set TEST to \"$ \"\n\n\u2022 Some initialization of common data areas appeared to be missing, causing\nthe loader to fail. We added code to ELIZA. MAD to initialize the public\nlist W(1): LIST.(W(1))"}, {"title": "It's Alive!", "content": "RL built a test environment where changes could be rapidly tested. We were\neventually able to produce an executable, and on Saturday, December 21st, 2024\nat 10:54(PDT), Rupert announced to the rest of the team:\n\nI'm happy to announce that ELIZA is now running again on CTSS!\n\nr eliza\nW 1835.0\nEXECUTION.\nWHICH SCRIPT DO YOU WISH TO PLAY\n200\nHOW DO YOU DO PLEASE TELL ME YOUR PROBLEM\nINPUT\nMen are all alike.\nIN WHAT WAY\n\nAfter all this effort, the reanimated ELIZA, not having run for over 60 years\nwas able to carry on complete conversations."}, {"title": "Doctor Under the Knife", "content": "There was still one problem standing between us and the goal of demonstrating\nthat ELIZA actually worked. ELIZA uses a script containing the language\nrules that determine its personality. The most famous of these is, of course, the\n\"DOCTOR\" script which leads ELIZA to interact what seems to be a caricature\nof a Rogerian therapist. Weizenbaum chose this persona because he needed a\ncontext where ignorance would not destroy the illusion of understanding (\"For\nexample, in the psychiatric interview the psychiatrist says, tell me about the\nfishing fleet in San Francisco. One doesn't say, \"Look, he's a smart man-how\ncome he doesn't know about the fishing fleet in San Francisco?\" What he really\nwants to hear is what the patient has to say about it.\u201d[26, pp. 251-253])\n\nThe code that we discovered in Weizenbaum's archives the code that we\nare running here - had two early versions of the Doctor script attached (literally,"}, {"title": "Lady Ada's Revenge", "content": "Running this early ELIZA proved that it in fact worked, and that it is very\nclose to the ELIZA published in the 1966 CACM paper! However, running the\nactual program also led us to discover a significant bug that would have been\nvery difficult to find by mere inspection of the code. To wit, this version of\nELIZA does not handle numerical inputs correctly. More specifically, it will\ncrash if given numeric input such as \"you are 999 today\". One could say that"}, {"title": "The Rain in Spain", "content": "In his 1966 paper, Joseph Weizenbaum wrote mysteriously about being able to\n\"teach\" ELIZA:\n\n\"Its name was chosen to emphasize that it may be incrementally improved\nby its users, since its language abilities may be continually improved by\na \"teacher\". Like the Eliza of Pygmalion fame, it can be made to appear\neven more civilized[...].\" [36]\n\nWe say \"mysteriously\" because one would think that, being the raison d'etre\nof the program's name, there would be significant discussion of this topic in\nthe paper. However, this is the only mention of this capability anywhere in\nWeizenbaum's writings. Interestingly, the code we discovered and reanimated\ncontained the complete functionality for this \"teacher\" mode, including func-\ntionality for editing and saving the script.\nTyping '+' to ELIZA takes it out of conversation mode and into \"teaching\"\nmode. ELIZA responds with PLEASE INSTRUCT ME and waits for the user to\nenter any of seven commands: ADD <keyword>(<transformation rule>) adds\nthe given transformation rule to an existing keyword rule; APPEND <key-\nword>(<existing reassembly rule>) (<new reassembly rule>) appends the new\nreassembly rule to the transformation rule with the existing reassembly rule\nin the given keyword; SUBST <keyword>(<existing reassembly rule>) (<new\nreassembly rule>) replaces the existing reassembly rule with the new one in\nthe given keyword; TYPE <keyword>displays the script rule for the given key-\nword; DISPLA displays the rules for all keywords as well as the MEMORY rules;\nRANK <keyword><n>allows the user to set the precedence for a keyword; and\nSTART returns ELIZA to the conversation mode. Furthermore, a special \"star\"\n('*') command allows the teacher to add a rule more succinctly, without having\nto go into teaching mode.\n\nThe Appendix contains a complete teaching interaction with our reanimated\nELIZA.\nOnce the script has been edited it is useful to save it. Giving no input (just\npressing ENTER at the INPUT prompt) will cause ELIZA to ask for a pseudo-\ntape number to write its rules to. Entering 0 (or giving no input at all) lead\nit to print the script to the console, and entering a number, say 130, will write\nto disk file:.TAPE.130. The output is a well-formed S-expressions, but with\ndifferent spacing than we usually see in external scripts that have been edited"}, {"title": "ELIZA's Final Analysis", "content": "While simple by today's standards, ELIZA was groundbreaking for its time,\nbringing to life the concept mere science fiction to that point of conversation\nwith a computer, and igniting a fire (for better or worse) under AI. ELIZA had\na significant, if unintended and somewhat indirect, impact on AI. It was the\nfirst program to directly embody Turing's test and brought into reality what\nwas to that point (and to a large extent, thereafter as well, until perhaps even\na couple of years ago) the idea that you could have an actual conversation\nwith a computer. It showed, in part, in its overt stupidity that you may not\nhave to actually solve intelligence to obtain artificial intelligence up to that\npoint, and up to the spectacular and unexpected apparent intelligence of LLMs\npeople were trying to model how people thought and code those processes into\ncomputers. There were almost certainly other indirect impacts from ELIZA; it\nis embedded in the AI psyche.\nWhile we can't put ourselves in the shoes of someone living in 1966, it is\nfascinating to experience a conversation with the original ELIZA, even if it\nbreaks on occasion. If the code we discovered didn't work at all it would be\nvery disappointing and we'd be trying to figure out why.\nWe have have struggled with whether to repair the problem with inputting\nnumbers. Our feeling is that running the original code feels good and authentic.\nFinding bugs in it only adds to the authenticity. Any changes or bug fixes we\nmake detract from that, except minor interventions necessary to get the code\nrunning so people can run at all. Put in more academic terms, it is important\nthat programs discovered in archaeological research of this sort retain as much\nof their exact nature as possible. It is true that we needed to make repairs at\nthe margin in order to get the discovered code running, but as was mentioned,\nthe running code is 96% exactly what was discovered, and what was changed is\nclearly documented, but there were no changes made to the core code as would\nbe required to repair the number problem.\nOf course, we continue to search various archives for later, or even earlier,\nversions of Eliza, and we would appreciate it if any readers of this paper who\nmay have access to archives that may potentially contain versions of Eliza would\nmake contact with us."}, {"title": "DIY ELIZA", "content": "Here is a video of the reanimated ELIZA holding the conversation from the\n1966 CACM paper: [21]. You can download and build CTSS and ELIZA to run\non your own computer here: [22]. This has been tested on various Linux and\nMacOS versions, but we've noticed some issues with different versions, so your\nmileage may vary. If you get it working on your machine and find that you have\nto change something, let us know. (Or fork the repo and send us a pull request!)\nReport discoveries, issues (or even better, fixes!) to rupert@timereshared.com."}]}