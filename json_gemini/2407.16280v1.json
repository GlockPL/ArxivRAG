{"title": "Efficient Detection of Commutative Factors in Factor Graphs", "authors": ["Malte Luttermann", "Johann Machemer", "Marcel Gehrke"], "abstract": "Lifted probabilistic inference exploits symmetries in probabilistic graphical models to allow for tractable probabilistic inference with respect to domain sizes. To exploit symmetries in, e.g., factor graphs, it is crucial to identify commutative factors, i.e., factors having symmetries within themselves due to their arguments being exchangeable. The current state of the art to check whether a factor is commutative with respect to a subset of its arguments iterates over all possible subsets of the factor's arguments, i.e., O(2n) iterations for a factor with n arguments in the worst case. In this paper, we efficiently solve the problem of detecting commutative factors in a factor graph. In particular, we introduce the detection of commutative factors (DECOR) algorithm, which allows us to drastically reduce the computational effort for checking whether a factor is commutative in practice. We prove that DECOR efficiently identifies restrictions to drastically reduce the number of required iterations and validate the efficiency of DECOR in our empirical evaluation.", "sections": [{"title": "1. Introduction", "content": "Probabilistic graphical models provide a well-founded formalism to reason under uncertainty and compactly encode a full joint probability distribution as a product of factors. A fundamental task using probabilistic graphical models is to perform probabilistic inference, that is, to compute marginal distributions of random variables (randvars) given observations for other randvars. In general, however, probabilistic inference scales exponentially with the number of randvars in a propositional probabilistic model such as a Bayesian network, a Markov network, or a factor graph (FG) in the worst case. To allow for tractable probabilistic inference (e.g., probabilistic inference requiring polynomial time) with respect to domain sizes of logical variables, lifted inference algorithms exploit symmetries in a probabilistic graphical model by using a representative of indistinguishable individuals for computations (Niepert and Van den Broeck, 2014). Performing lifted inference, however, requires a lifted representation of the probabilistic graphical model, which encodes equivalent semantics to the original propositional probabilistic model. In particular, it is necessary to detect symmetries in the propositional model to construct the lifted representation. Commutative factors, i.e., factors that map to the same potential value regardless of the order of a subset of their arguments, play a crucial role when detecting symmetries in an FG and constructing a lifted representation of the FG. To detect commutative factors, the current state-of-the-art algorithm iterates over all possible subsets of a factor. In this paper, we show that the search can be guided significantly more efficient and thereby we solve the problem of efficiently detecting commutative factors in an FG."}, {"title": "Previous work.", "content": "In probabilistic inference, lifting exploits symmetries in a probabilistic model, allowing to carry out query answering more efficiently while maintaining exact answers (Niepert and Van den Broeck, 2014). First introduced by Poole (2003), parametric factor graphs (PFGs) provide a lifted representation by combining first-order logic with probabilistic models, which can be utilised by lifted variable elimination as a lifted inference algorithm operating on PFGs. After the introduction of lifted variable elimination (LVE) by Poole (2003), LVE has steadily been refined by many researchers (De Salvo Braz et al., 2005, 2006; Milch et al., 2008; Kisy\u0144ski and Poole, 2009; Taghipour et al., 2013; Braun and M\u00f6ller, 2018). To perform lifted probabilistic inference, the lifted representation (e.g., the PFG) has to be constructed first. Currently, the state-of-the-art algorithm to construct a PFG from a given FG is the advanced colour passing (ACP) algorithm (Luttermann et al., 2024a), which is a refinement of the colour passing (CP) algorithm (Kersting et al., 2009; Ahmadi et al., 2013) and is able to construct a PFG entailing equivalent semantics as the initially given FG. The CP algorithm builds on work by Singla and Domingos (2008) and incorporates a colour passing procedure to detect symmetries in a graph similar to the Weisfeiler-Leman algorithm (Weisfeiler and Leman, 1968), which is commonly used to test for graph isomorphism. ACP employs a slightly refined colour passing procedure and during the course of the algorithm, ACP checks for every factor in the given FG whether the factor is commutative with respect to a subset of its arguments to determine the outgoing messages of the factor for the colour passing procedure. The check for commutativity is implemented by iterating over all possible subsets of the factor's arguments, which results in O(2n) iterations for a factor with n arguments in the worst case."}, {"title": "Our contributions.", "content": "In this paper, we efficiently solve the problem of detecting commutative factors in an FG, thereby speeding up the construction of an equivalent lifted representation for a given FG. More specifically, we show how so-called buckets can be used to restrict the possible candidates of subsets that have to be considered when checking whether a factor is commutative that is, which of its arguments are exchangeable. The idea is that within these buckets, only a subset of potentials from the original factor has to be considered. Further, argument(s), which produce certain potential(s) can be identified. Thereby, the search space can be drastically reduced. We prove that using buckets, the run time complexity is drastically reduced for many practical settings, making the check for commutativity feasible in practice. Afterwards, we gather the theoretical insights and propose the detection of commutative factors (DECOR) algorithm, which applies the theoretical insights to efficiently detect commutative factors in an FG. In addition to our theoretical results, we validate the efficiency of DECOR in our empirical evaluation."}, {"title": "Structure of this paper.", "content": "The remainder of this paper is structured as follows. We first introduce necessary background information and notations. In particular, we define FGs as well as the notion of commutative factors and provide background information on the ACP algorithm. Afterwards, we formally define the concept of a bucket and present our theoretical results, showing how buckets can be used to efficiently restrict possible candidates of subsets that have to be considered when searching for exchangeable arguments of a factor. We then introduce the DECOR algorithm, which applies the theoretical insights to efficiently detect commutative factors in an FG. Before we conclude, we provide the results of our experimental evaluation, verifying the practical efficiency of DECOR."}, {"title": "2. Preliminaries", "content": "We first introduce FGs as undirected propositional probabilistic models and afterwards define commutative factors formally. An FG compactly encodes a full joint probability distribution between randvars, where the full joint probability distribution is represented as a product of factors (Frey et al., 1997; Kschischang et al., 2001).\nDefinition 1 (Factor Graph, Kschischang et al., 2001) An FG G = (V,E) is an undirected bipartite graph consisting of a node set V = R \u222a \u03a6, where R = {R1, ..., Rn} is a set of variable nodes (randvars) and \u03a6 = {\u04441, ..., \u0444m} is a set of factor nodes (functions), as well as a set of edges E \u2286 R \u00d7 \u03a6. The term range(Ri) denotes the possible values of a randvar Ri. There is an edge between a variable node Ri and a factor node $j in E if Ri appears in the argument list of $j. A factor is a function that maps its arguments to a positive real number, called potential. The semantics of G is given by\n$$P_G = \\frac{1}{Z} \\prod_{j=1}^m \\phi_j(A_j)$$\nwith Z being the normalisation constant and Aj denoting the randvars connected to \u0444j.\nExample 1 Figure 1 displays a toy example for an FG consisting of two randvars R\u2081 and R2 as well as one factor (R1, R2). Both R\u2081 and R2 are Boolean, that is, range(R1) = range(R2) = {true, false}. The input-output pairs of $ are specified in the table on the right. Note that, in this specific example, it holds that $(true, false) = $(false, true) = 42.\nLifted inference algorithms exploit symmetries in an FG by operating on lifted representations (e.g., PFGs), which consist of parameterised randvars and parametric factors, representing sets of randvars and factors, respectively (Poole, 2003). Symmetries in FGs are highly relevant in many real world domains such as an epidemic domain, where each person influences the probability of an epidemic in the same way\u2014because the probability of having an epidemic depends on the number of sick people and not on individual people being sick. The probability for an epidemic is the same if there are three sick people and the remaining people in the universe are not sick, independent of whether alice, bob, and eve or charlie, dave, and fred are sick. Analogously, for movies the popularity of an actor influences the success of a movie in the same way for each actor being part of the movie."}, {"title": "Definition 2 (Commutative Factor, Luttermann et al., 2024a)", "content": "Let (R1,..., Rn) denote a factor. We say that $ is commutative with respect to S \u2286 {R1,..., Rn} if for all events r1,...,rn \u2208 \u00d7i=1range(Ri) it holds that $(r1,...,rn) = $(r\u03c0(1),..., \u03b3\u03c0(n)) for all permutations \u03c0 of {1,...,n} with \u03c0(i) = i for all Ri \u2209 S. If $ is commutative with respect to S, we say that all arguments in S are commutative arguments of $.\nExample 2 Consider again the factor $(R1, R2) depicted in Fig. 1. Since it holds that (true, false) = $(false, true) = 42, \u0444 is commutative with respect to {R1, R2}.\nBy definition, every factor is commutative with respect to any singleton subset of its arguments independent of the factor's potential mappings. Note that, in practice, we are only interested in factors that are commutative with respect to a subset S of their arguments where |S| > 1 because our intention is to group indistinguishable arguments (and grouping a single element does not yield any benefit). Since all arguments in S are candidates to be grouped together, the task we solve in this paper is to compute a subset S of a factor's arguments of maximum size such that the factor is commutative with respect to S. In many practical settings, factors are commutative with respect to a subset of their arguments, for example if individuals are indistinguishable and only the number of individuals having a certain property is of interest (as in an epidemic domain where the number of persons being sick determines the probability of an epidemic while it does not matter which specific persons are sick, and so on). We next show how commutative factors can efficiently be detected in an FG, which is crucial to exploit symmetries in the FG for lifted inference."}, {"title": "3. Efficient Detection of Commutative Factors Using Buckets", "content": "Detecting commutative factors is a fundamental part of lifted model construction. The current state of the art, however, applies a rather \"naive\" approach to compute a subset of commutative arguments of maximum size. In particular, computing a maximum sized subset of commutative arguments of a factor $ is currently implemented by iterating over all possible subsets of $'s arguments in order of descending size of the subsets. That is, for a factor (R1,..., Rn), it is first checked whether o is commutative with respect to all of its n arguments, then it is checked whether o is commutative with respect to any subset consisting of n 1 arguments, and so on. In the worst case, the algorithm needs O(2n) iterations to compute a maximum sized subset of commutative arguments. Even though we have to consider O(2n) subsets in the worst case, we are able to drastically prune the search space in many practical settings, as we show next. The idea is that we can partition the potential values a factor maps its arguments to into so-called buckets, which allow us to restrict the space of possible candidate subsets and thereby heavily reduce the number of necessary iterations. A bucket counts the occurrences of specific range values in an assignment for a subset of a factor's arguments. Consequently, each bucket may contain multiple potential values and every potential value is part of exactly one bucket.\nDefinition 3 (Bucket, Luttermann et al., 2024b) Let \u00a2(R1,...,Rn) denote a factor and let S \u2286 {R1,..., Rn} denote a subset of p's arguments such that range(Ri) = range(Rj) holds for all Ri, Rj \u2208 S. Further, let V denote the range of the elements in S (identical for all Ri \u2208 S). Then, a bucket b entailed by S is a set of tuples {(vi, Ni)}=1, Vi \u2208 V, ni \u2208 N, and \u2211ini = |S|, such that ni specifies the number of occurrences of value vi in an assignment for all randvars in S. A shorthand notation for {(vi, ni)}=1 is [n1,..., nv|]. In abuse of notation, we denote by $(b) the multiset of potentials the assignments represented by b are mapped to by \u0444. The set of all buckets entailed by \u00f3 is denoted as B(\u03c6).\nExample 3 Consider the factor \u222e(R1, R2, R3) depicted in Table 1 and let S = {R1, R2, R3} with range(R1) = range(R2) = range(R3) = {true,false}. Then, S entails the four buckets {(true, 3), (false, 0)}, {(true, 2), (false, 1)}, {(true, 1), (false, 2)}, and {(true, 0), (false, 3)} (or [3,0], [2, 1], [1,2], and [0,3], respectively, in shorthand notation). Following the mappings given in the table from Table 1, it holds that $([3,0]) = (41), \u03c6([2,1]) = (62,Y2,44), \u03c6([1,2]) = (93, 45, 45), and \u00a2([0,3]) = (46).\nBuckets allow us to restrict the candidates of arguments that are possibly commutative (exchangeable) and hence might be grouped. The idea is that commutative arguments can be replaced by a bucket that counts over their range values instead of listing each of the arguments separately. In particular, each combination of bucket for the commutative arguments and fixed values for the remaining arguments must be mapped to the same potential value, as illustrated in the upcoming example.\nExample 4 Take a look at Table 2, which contains a compressed representation of the factor & from Table 1. Originally, & maps each combination of bucket for R2 and R3 and fixed values for R\u2081 to the same potential value, e.g., R\u2081 = true, R2 = true, R3 = false and R\u2081 = true, R2 = false, R3 = true (that is, the combination of value true for R\u2081 and bucket [1, 1] for R2 and R3) are mapped to the same potential value 42. Consequently, these two assignments can be represented by a single assignment (true, [1,1]) in the compressed representation shown in Table 2. In general, it is possible to compress all commutative arguments in a factor by replacing them by a so-called counting randvar, which uses buckets as a representation. In this particular example, & is commutative with respect to S = {R2, R3} and thus, we are able to group R2 and R3 together.\nGrouping commutative arguments does not alter the semantics of the factor and at the same time reduces the size of the table that has to be stored to encode the input-output mappings of the factor as well as the inference time. To obtain the maximum possible compression, we therefore aim to compute a maximum sized subset of commutative arguments.\nA crucial observation to efficiently compute a maximum sized subset of commutative arguments is that the buckets of the initially given factor must contain duplicate potential values as a necessary condition for arguments to be able to commutative. In particular, groups of identical potential values within a bucket directly restrict the possible candidates of commutative arguments, as we show next.\nTheorem 4 Let (R1,..., Rn) be a factor and let b \u2208 B(\u03c6) with |\u00a2(b)| > 1 be a bucket entailed by \u222e. Further, let G = {61,...,6e} with |G| > 2 denote an arbitrary maximal set of identical potential values in $(b) and let (r1,...,r),..., (r\u2081, ..., rn) denote all assignments corresponding to the potential values in G. Then, a subset S \u2286 {R1,..., Rn} with |S| >2 such that is commutative with respect to S is obtained by computing the element-wise intersection (r1,..., rm) \u2229 (ri, ..., rn) and adding all arguments Ri to S for which it holds that {r}}n...n{r} = (). Here, the element-wise intersection of two assignments (x1,..., X\u2113) and (y1,..., Ye) contains the value xi at position i if xi = Yi, otherwise position i equals \u00d8.\nProof It holds that $(r1,...,r) = 41,..., $(r\u2081, ..., rh) = ye and 41 = ... = \u03c6e. Moreover, let S \u2286 {R1, ..., Rn} denote any subset of commutative arguments such that |S| > 2. Recall that according to Def. 2, for all events r\u2081,...,rn \u2208 \u00d7i=1range(Ri) it holds that $(r1,...,rn) = $(r\u03c0(1),\u00b7\u00b7\u00b7,\u03b3\u03c0(n)) for all permutations \u03c0of {1,..., n} with \u03c0(i) = i for all Ri \u2209 S. Thus, the positions of all arguments which are not in S are fixed in all permutations. Consequently, the element-wise intersection of the assignments yields non-empty sets for all positions belonging to arguments not in S because these assignments contain identical assigned values at those positions. At the same time, as we consider only buckets with at least two elements, all assignments contain at least two distinct assigned values because all assignments that contain only a single value are those that map to a bucket containing a single element. We further consider all assignments (r\u03c0(1),\u2026\u2026\u2026,\u03c0(n)) for all permutations \u03c0of {1, ..., n} and therefore, there are at least two different assigned values for all positions belonging to arguments in S, yielding an empty set when computing the element-wise intersection of the assignments for a position of any argument in S. \u25a0\nTheorem 4 tells us that candidate subsets of commutative arguments can be found by first identifying groups of identical potential values within a bucket and then computing the element-wise intersection of the assignments corresponding to these potential values. The following example illustrates how Thm. 4 can be applied to identify commutative arguments.\nExample 5 Consider again the factor $(R1, R2, R3) depicted in Table 1. For the sake of the example, let us take a look at the bucket [2,1]. We have two groups of identical values, namely G\u2081 = {42,42} and G2 = {64}. Since G2 contains only a single potential value, there are no candidates of commutative arguments induced by G2. However, G\u2081 contains the potential value 42 two times and the corresponding assignments are (true, true, false) and (true, false, true). The element-wise intersection of those assignments is then given by (true, true, false) \u2229 (true, false, true) = (true, \u00d8, \u00d8). As the element-wise intersection is empty at positions two and three, the set {R2, R3} is a possible subset of commutative arguments.\nBy looking for maximal sets G of identical potential values, we ensure that we actually find maximum sized candidate subsets of commutative arguments. Moreover, the number of positions having an empty element-wise intersection directly corresponds to the size of every candidate subset S, that is, the number of positions having an empty element-wise intersection is equal to |S|. As all permutations of these |S| positions are mapped to the same potential value, we know that if there is a subset of commutative arguments of size |S|, there must be at least |S| duplicate potential values in every bucket of size at least two.\nCorollary 5 Let (R1,..., Rn) be a factor and let S \u2286 {R1,..., Rn} be a subset of arguments such that \u00f3 is commutative with respect to S. Then, in every bucket b \u2208 B(\u03c6) with |$(b)| > 1, there exists a potential value y that occurs at least |S| times in \u03c6(b).\nExample 6 Consider again the factor $(R1, R2, R3), which is commutative with respect to S = {R2, R3}, depicted in Table 1. Therefore, \u0444 must map the buckets [2,1] and [1,2] (the only buckets that are mapped to at least two elements by $) to at least |S| = 2 identical potential values. Here, 42 occurs twice in $([2,1]) and 45 occurs twice in $([1,2]).\nAs we know for every bucket b containing more than one element that there must exist a potential occurring at least |S| times in b to allow for a subset S of commutative arguments to exist, we also know that there cannot be more commutative arguments than the minimum number of duplicate potential values over all buckets containing more than one element.\nCorollary 6 Let (R1,..., Rn) denote a factor. Then, the size of any subset of commutative arguments of $ is upper-bounded by\n$$min_{b \\in \\{b | b \\in B(\\phi) \\land |\\phi(b)|>1\\}} max_{\\phi \\in \\phi(b)} count(\\phi(b), \\phi)$$\nwhere count($(b), \u03c6) denotes the number of occurrences of potential y in \u03c6(b).\nExample 7 The factor $(R1, R2, R3) given in Table 1 maps [2,1] to \u300842, 42, 44) and [1,2] to (43, 45, 45) and thus, the upper bound for the size of any subset of commutative arguments of \u00f3 is two because \u0444 maps the buckets [2,1] and [1,2] to two identical potential values each.\nThe bounds implied by Cors. 5 and 6 show that the number of possible candidate subsets of commutative arguments can be heavily reduced in many practical settings. In particular, we are now able to exploit the insights from Thm. 4 as well as Cors. 5 and 6 to drastically restrict the search space of possible candidate subsets of commutative arguments, thereby avoiding the naive iteration over all O(2\") subsets of a factor's arguments and thus making the check for commutativity feasible in practice.\nWe next incorporate our theoretical findings into a practical algorithm, called DECOR, to efficiently compute subsets of commutative arguments of maximum size in practice.\""}, {"title": "4. The DECOR Algorithm", "content": "We are now ready to gather the theoretical results to obtain the DECOR algorithm, which efficiently computes a maximum sized subset of commutative arguments of a given factor. Algorithm 1 presents the whole DECOR algorithm, which undertakes the following steps on a given input factor (R1, ..., Rn) to compute subsets of commutative arguments.\nFirst, DECOR initialises a set C of possible candidate subsets of commutative arguments, which contains the whole argument list of $ at the beginning. DECOR then iterates over all buckets entailed by \u0444, where all buckets containing only a single element are skipped because they do not restrict the search space. DECOR then partitions the values in every bucket into maximal groups G1,..., Ge of identical potential values, where each group must contain at least two identical potential values as we are only interested in subsets of commutative arguments of size at least two. If no such group is found, DECOR returns an empty set as there are no candidates for a subset of commutative arguments of size at least two. Afterwards, DECOR applies the insights from Thm. 4 and iterates over all groups of identical potential values to compute the element-wise intersection of the assignments corresponding to the potential values within a group. For every group Gi of identical potential values, DECOR then builds a set Ci containing all arguments whose position in the element-wise intersection over their corresponding assignments is empty. DECOR then adds the set Ci of arguments that are commutative according to the current bucket to the set C' of candidate subsets for the current bucket if Ci is not subsumed by any other candidate subset in C'. Thereafter, as each bucket further restricts the search space for possible commutative arguments, DECOR computes the intersection of all candidate subsets collected so far in C and all candidate subsets of the current bucket in C'. DECOR keeps all candidate subsets of size at least two after the intersection that are not already subsumed by another candidate subset after the intersection. In case there are no candidate subsets of size at least two left after considering a specific bucket, DECOR returns an empty set as a result. Finally, if there are still candidate subsets left after iterating over all buckets of size at least two, DECOR returns the set of all candidate subsets of commutative arguments of maximum size. A maximum sized subset of commutative arguments can then be obtained by selecting any candidate subset in C that contains the most elements.\nNote that DECOR returns all candidate subsets of commutative arguments that are not subsumed by another candidate subset and could be replaced by a so-called counting randvar in the lifted representation of the factor. As we aim for the most compression possible, we are mostly interested in the maximum sized subset of commutative arguments. However, it might be conceivable that there are settings in which counting over two or more candidate subsets of commutative arguments yields a higher compression than counting over a single maximum sized subset. We therefore keep DECOR as a general algorithm that is able to return all candidate subsets of commutative arguments that are not subsumed by another candidate subset and leave the decision of which subset(s) to choose to the user.\nExample 8 Let us take a look at how DECOR computes a maximum sized subset of commutative arguments for the factor $(R1, R2, R3) from Table 1. Initially, DECOR starts with the set C = {{R1, R2, R3}}. After skipping the bucket [3,0], DECOR finds the group G\u2081 = {42,42} for the bucket [2,1]. Other groups contain less than two elements and are thus ignored. DECOR then computes the element-wise intersection of the assignments corresponding to the potential values in G1, which is given by (true, true, false) \u2229 (true, false, true) = (true, 0, 0). As the element-wise intersection is empty at positions two and three, DECOR adds the set Ci = {R2, R3} to the set C' of candidate subsets for the bucket [2, 1]. Afterwards, DECOR computes the intersection of {R1, R2, R3} (as C = {{R1, R2, R3}}) and {R2, R3} (as C' = {{R2, R3}}), which yields C\u2229 = {{R2, R3}} and thus also C = {{R2, R3}} for the next iteration. DECOR next finds the group G\u2081 = {45,45} for the bucket [1,2] and computes the element-wise intersection of the assignments corresponding to the potential values in G1, which is given by (false, true, false) \u2229 (false, false, true) = (false, 0,0). Again, positions two and three are empty and thus, DECOR adds the set Ci = {R2, R3} to the set C' of candidate subsets for the bucket [1,2]. Thereafter, DECOR computes the intersection of {R2, R3} (as C = {{R2, R3}}) and {R2, R3} (as C' = {{R2, R3}}), which yields C = C\u2229 = {{R2, R3}}. Finally, as the next bucket [0,3] is skipped again and there are no other buckets left, DECOR returns the set {{R2, R3}} containing a single candidate subset of commutative arguments, which is at the same time a maximum sized subset.\nWe remark that the number of candidate subsets considered by DECOR now directly depends on the number of groups of identical potential values in the buckets of the factor. In most practical settings, potential values are not identical unless the factor is commutative with respect to a subset of its arguments. Therefore, DECOR heavily restricts the search space for possible candidate subsets of commutative arguments in most practical settings.\nRecall that the \u201cnaive\u201d algorithm iterates over O(2n) subsets of arguments and then has to consider all |R|\" (where R denotes the range of the arguments and n is the total number of arguments) potential values in the table of potential mappings during each iteration to check whether a subset of arguments is commutative. While DECOR also has to consider all |R|\" potential values during the course of the algorithm (in fact, every algorithm searching for commutative arguments has to take a look at every potential value at least once), DECOR considers every potential value just twice (in Lines 5 and 10).\nTheorem 7 Let (R1,..., Rn) denote a factor and let R = range(R\u2081) = . = range(Rn). The worst-case time complexity of the \u201cnaive\u201d algorithm to compute a maximum sized subset of commutative arguments is in O(2n \u00b7 |R|n\u00b7n).\nProof The \"naive\" algorithm iterates over all subsets of p's arguments and then iterates for every subset over all buckets induced by that subset to check whether each bucket is mapped to a unique potential value by 6. \u03a4\u03bf compute the buckets, all n positions in all Rn assignments are considered. The iteration over all values in the buckets requires time O(|R|", "naive": "lgorithm iterates over O(2n) subsets of arguments and thus has a complexity of O(2n \u00b7 |R|n\u00b7n).\nTheorem 8 Let \u00a2(R1,..., Rn) denote a factor and let R = range(R1) = . = range(Rn). The expected worst-case time complexity of the DECOR algorithm to compute a maximum sized subset of commutative arguments is in O(|B($)|\u00b7k. (n/2) +|R|n\u00b7n), where k denotes the maximum number of potential values within a bucket entailed by \u0444.\nProof The partitioning of $(b) into maximal groups of identical potential values (Line 5) requires time linear in the number of potential values in the bucket b and as all |R|n potential values are looked at exactly once over all buckets, the partitioning requires time O(|R|n) in total for all buckets. DECOR finds at most [|R|n/2] groups of identical potential values (if every group contains exactly two identical potential values) over all buckets. The loop in Line 9 thus needs O(|R|", "are": "In case the model is highly symmetric, symmetries within a factor are expected to be over larger sets. Thus, DECOR has just few sets to consider. In case there are hardly any symmetries within a factor and the model itself, DECOR has to check few small candidate sets and might even end up with an empty candidate set after few buckets.\nFinally, before we demonstrate the practical efficiency of DECOR in our experimental evaluation, we remark that DECOR can handle factors with arguments having arbitrary ranges. During the course of this paper, we consider identical ranges of all arguments for brevity, however, it is possible to apply DECOR to factors with arguments having various ranges R1,..., Rk by considering the buckets for all arguments with range Ri separately for all i \u2208 {1, ..., k} as only arguments having the same range can be commutative at all."}, {"title": "5. Experiments", "content": "In addition to our theoretical results, we conduct an experimental evaluation of DECOR to assess its performance in practice. We compare the run times of DECOR to the \"naive\" approach, i.e., iterating over all possible subsets of a factor's arguments in order of descending size of the subsets."}, {"title": "6. Conclusion", "content": "We present the DECOR algorithm to efficiently detect commutative factors in FGs. DECOR makes use of buckets to significantly restrict the search space and thereby efficiently handles factors even with a large number of arguments where previous algorithms fail to compute a solution within a timeout. We prove that the number of subsets to check for commutative arguments is upper-bounded depending on the number of duplicate potential values in the buckets. By exploiting this upper bound, DECOR drastically reduces the number of subsets to check for commutative arguments compared to previous algorithms, which iterate over O(2n) subsets for a factor with n arguments in the worst case. Additionally, DECOR returns all candidate subsets of commutative arguments that are not subsumed by another candidate subset, allowing to compress the model even further. Overall, DECOR drastically increases the efficiency to identify commutative factors and further reduces the model."}, {"title": "Appendix A. Formal Description of the Advanced Colour Passing Algorithm", "content": "The advanced colour passing (ACP) algorithm introduced by Luttermann et al. (2024a) builds on the colour passing algorithm (Kersting et al., 2009; Ahmadi et al., 2013) and solves the problem of constructing a lifted representation\u2014more specifically, a so-called parametric factor graph (PFG)\u2014from a given factor graph (FG). The idea of ACP is to first find symmetries in a propositional FG and then group together symmetric subgraphs. ACP looks for symmetries based on potentials of factors, on ranges and evidence of random variables (randvars), as well as on the graph structure by passing around colours. Algorithm 2 provides a formal description of the ACP algorithm, which proceeds as follows."}, {"title": "Appendix B. Additional Experimental Results", "content": "In addition to the experimental results provided in Sec. 5", "naive\" algorithm to the run times of detection of commutative factors (DECOR) algorithm on factors with n \u2208 {2,```json\n{\n  ": "itle", "Efficient Detection of Commutative Factors in Factor Graphs": "authors\": [\n    \"Malte Luttermann", "Johann Machemer": "Marcel Gehrke", "abstract": "Lifted probabilistic inference exploits symmetries in probabilistic graphical models to allow for tractable probabilistic inference with respect to domain sizes. To exploit symmetries in, e.g., factor graphs, it is crucial to identify commutative factors, i.e., factors having symmetries within themselves due to their arguments being exchangeable. The current state of the art to check whether a factor is commutative with respect to a subset of its arguments iterates over all possible subsets of the factor's arguments, i.e., O(2n) iterations for a factor with n arguments in the worst case. In this paper, we efficiently solve the problem of detecting commutative factors in a factor graph. In particular, we introduce the detection of commutative factors (DECOR) algorithm, which allows us to drastically reduce the computational effort for checking whether a factor is commutative in practice. We prove that DECOR efficiently identifies restrictions to drastically reduce the number of required iterations and validate the efficiency of DECOR in our empirical evaluation.", "sections": [{"title": "1. Introduction", "content": "Probabilistic graphical models provide a well-founded formalism to reason under uncertainty and compactly encode a full joint probability distribution as a product of factors. A fundamental task using probabilistic graphical models is to perform probabilistic inference, that is, to compute marginal distributions of random variables (randvars) given observations for other randvars. In general, however, probabilistic inference scales exponentially with the number of randvars in a propositional probabilistic model such as a Bayesian network, a Markov network, or a factor graph (FG) in the worst case. To allow for tractable probabilistic inference (e.g., probabilistic inference requiring polynomial time) with respect to domain sizes of logical variables, lifted inference algorithms exploit symmetries in a probabilistic graphical model by using a representative of indistinguishable individuals for computations (Niepert and Van den Broeck, 2014). Performing lifted inference, however, requires a lifted representation of the probabilistic graphical model, which encodes equivalent semantics to the original propositional probabilistic model. In particular, it is necessary to detect symmetries in the propositional model to construct the lifted representation. Commutative factors, i.e., factors that map to the same potential value regardless of the order of a subset of their arguments, play a crucial role when detecting symmetries in an FG and constructing a lifted representation of the FG. To detect commutative factors, the current state-of-the-art algorithm iterates over all possible subsets of a factor. In this paper, we show that the search can be guided significantly more efficient and thereby we solve the problem of efficiently detecting commutative factors in an FG."}, {"title": "Previous work.", "content": "In probabilistic inference, lifting exploits symmetries in a probabilistic model, allowing to carry out query answering more efficiently while maintaining exact answers (Niepert and Van den Broeck, 2014). First introduced by Poole (2003), parametric factor graphs (PFGs) provide a lifted representation by combining first-order logic with probabilistic models, which can be utilised by lifted variable elimination as a lifted inference algorithm operating on PFGs. After the introduction of lifted variable elimination (LVE) by Poole (2003), LVE has steadily been refined by many researchers (De Salvo Braz et al., 2005, 2006; Milch et al., 2008; Kisy\u0144ski and Poole, 2009; Taghipour et al., 2013; Braun and M\u00f6ller, 2018). To perform lifted probabilistic inference, the lifted representation (e.g., the PFG) has to be constructed first. Currently, the state-of-the-art algorithm to construct a PFG from a given FG is the advanced colour passing (ACP) algorithm (Luttermann et al., 2024a), which is a refinement of the colour passing (CP) algorithm (Kersting et al., 2009; Ahmadi et al., 2013) and is able to construct a PFG entailing equivalent semantics as the initially given FG. The CP algorithm builds on work by Singla and Domingos (2008) and incorporates a colour passing procedure to detect symmetries in a graph similar to the Weisfeiler-Leman algorithm (Weisfeiler and Leman, 1968), which is commonly used to test for graph isomorphism. ACP employs a slightly refined colour passing procedure and during the course of the algorithm, ACP checks for every factor in the given FG whether the factor is commutative with respect to a subset of its arguments to determine the outgoing messages of the factor for the colour passing procedure. The check for commutativity is implemented by iterating over all possible subsets of the factor's arguments, which results in O(2n) iterations for a factor with n arguments in the worst case."}, {"title": "Our contributions.", "content": "In this paper, we efficiently solve the problem of detecting commutative factors in an FG, thereby speeding up the construction of an equivalent lifted representation for a given FG. More specifically, we show how so-called buckets can be used to restrict the possible candidates of subsets that have to be considered when checking whether a factor is commutative that is, which of its arguments are exchangeable. The idea is that within these buckets, only a subset of potentials from the original factor has to be considered. Further, argument(s), which produce certain potential(s) can be identified. Thereby, the search space can be drastically reduced. We prove that using buckets, the run time complexity is drastically reduced for many practical settings, making the check for commutativity feasible in practice. Afterwards, we gather the theoretical insights and propose the detection of commutative factors (DECOR) algorithm, which applies the theoretical insights to efficiently detect commutative factors in an FG. In addition to our theoretical results, we validate the efficiency of DECOR in our empirical evaluation."}, {"title": "Structure of this paper.", "content": "The remainder of this paper is structured as follows. We first introduce necessary background information and notations. In particular, we define FGs as well as the notion of commutative factors and provide background information on the ACP algorithm. Afterwards, we formally define the concept of a bucket and present our theoretical results, showing how buckets can be used to efficiently restrict possible candidates of subsets that have to be considered when searching for exchangeable arguments of a factor. We then introduce the DECOR algorithm, which applies the theoretical insights to efficiently detect commutative factors in an FG. Before we conclude, we provide the results of our experimental evaluation, verifying the practical efficiency of DECOR."}, {"title": "2. Preliminaries", "content": "We first introduce FGs as undirected propositional probabilistic models and afterwards define commutative factors formally. An FG compactly encodes a full joint probability distribution between randvars, where the full joint probability distribution is represented as a product of factors (Frey et al., 1997; Kschischang et al., 2001).\nDefinition 1 (Factor Graph, Kschischang et al., 2001) An FG G = (V,E) is an undirected bipartite graph consisting of a node set V = R \u222a \u03a6, where R = {R1, ..., Rn} is a set of variable nodes (randvars) and \u03a6 = {\u04441, ..., \u0444m} is a set of factor nodes (functions), as well as a set of edges E \u2286 R \u00d7 \u03a6. The term range(Ri) denotes the possible values of a randvar Ri. There is an edge between a variable node Ri and a factor node $j in E if Ri appears in the argument list of $j. A factor is a function that maps its arguments to a positive real number, called potential. The semantics of G is given by\n$$P_G = \\frac{1}{Z} \\prod_{j=1}^m \\phi_j(A_j)$$\nwith Z being the normalisation constant and Aj denoting the randvars connected to \u0444j.\nExample 1 Figure 1 displays a toy example for an FG consisting of two randvars R\u2081 and R2 as well as one factor (R1, R2). Both R\u2081 and R2 are Boolean, that is, range(R1) = range(R2) = {true, false}. The input-output pairs of $ are specified in the table on the right. Note that, in this specific example, it holds that $(true, false) = $(false, true) = 42.\nLifted inference algorithms exploit symmetries in an FG by operating on lifted representations (e.g., PFGs), which consist of parameterised randvars and parametric factors, representing sets of randvars and factors, respectively (Poole, 2003). Symmetries in FGs are highly relevant in many real world domains such as an epidemic domain, where each person influences the probability of an epidemic in the same way\u2014because the probability of having an epidemic depends on the number of sick people and not on individual people being sick. The probability for an epidemic is the same if there are three sick people and the remaining people in the universe are not sick, independent of whether alice, bob, and eve or charlie, dave, and fred are sick. Analogously, for movies the popularity of an actor influences the success of a movie in the same way for each actor being part of the movie."}, {"title": "Definition 2 (Commutative Factor, Luttermann et al., 2024a)", "content": "Let (R1,..., Rn) denote a factor. We say that $ is commutative with respect to S \u2286 {R1,..., Rn} if for all events r1,...,rn \u2208 \u00d7i=1range(Ri) it holds that $(r1,...,rn) = $(r\u03c0(1),..., \u03b3\u03c0(n)) for all permutations \u03c0 of {1,...,n} with \u03c0(i) = i for all Ri \u2209 S. If $ is commutative with respect to S, we say that all arguments in S are commutative arguments of $.\nExample 2 Consider again the factor $(R1, R2) depicted in Fig. 1. Since it holds that (true, false) = $(false, true) = 42, \u0444 is commutative with respect to {R1, R2}.\nBy definition, every factor is commutative with respect to any singleton subset of its arguments independent of the factor's potential mappings. Note that, in practice, we are only interested in factors that are commutative with respect to a subset S of their arguments where |S| > 1 because our intention is to group indistinguishable arguments (and grouping a single element does not yield any benefit). Since all arguments in S are candidates to be grouped together, the task we solve in this paper is to compute a subset S of a factor's arguments of maximum size such that the factor is commutative with respect to S. In many practical settings, factors are commutative with respect to a subset of their arguments, for example if individuals are indistinguishable and only the number of individuals having a certain property is of interest (as in an epidemic domain where the number of persons being sick determines the probability of an epidemic while it does not matter which specific persons are sick, and so on). We next show how commutative factors can efficiently be detected in an FG, which is crucial to exploit symmetries in the FG for lifted inference."}, {"title": "3. Efficient Detection of Commutative Factors Using Buckets", "content": "Detecting commutative factors is a fundamental part of lifted model construction. The current state of the art, however, applies a rather \"naive\" approach to compute a subset of commutative arguments of maximum size. In particular, computing a maximum sized subset of commutative arguments of a factor $ is currently implemented by iterating over all possible subsets of $'s arguments in order of descending size of the subsets. That is, for a factor (R1,..., Rn), it is first checked whether o is commutative with respect to all of its n arguments, then it is checked whether o is commutative with respect to any subset consisting of n 1 arguments, and so on. In the worst case, the algorithm needs O(2n) iterations to compute a maximum sized subset of commutative arguments. Even though we have to consider O(2n) subsets in the worst case, we are able to drastically prune the search space in many practical settings, as we show next. The idea is that we can partition the potential values a factor maps its arguments to into so-called buckets, which allow us to restrict the space of possible candidate subsets and thereby heavily reduce the number of necessary iterations. A bucket counts the occurrences of specific range values in an assignment for a subset of a factor's arguments. Consequently, each bucket may contain multiple potential values and every potential value is part of exactly one bucket.\nDefinition 3 (Bucket, Luttermann et al., 2024b) Let \u00a2(R1,...,Rn) denote a factor and let S \u2286 {R1,..., Rn} denote a subset of p's arguments such that range(Ri) = range(Rj) holds for all Ri, Rj \u2208 S. Further, let V denote the range of the elements in S (identical for all Ri \u2208 S). Then, a bucket b entailed by S is a set of tuples {(vi, Ni)}=1, Vi \u2208 V, ni \u2208 N, and \u2211ini = |S|, such that ni specifies the number of occurrences of value vi in an assignment for all randvars in S. A shorthand notation for {(vi, ni)}=1 is [n1,..., nv|]. In abuse of notation, we denote by $(b) the multiset of potentials the assignments represented by b are mapped to by \u0444. The set of all buckets entailed by \u00f3 is denoted as B(\u03c6).\nExample 3 Consider the factor \u222e(R1, R2, R3) depicted in Table 1 and let S = {R1, R2, R3} with range(R1) = range(R2) = range(R3) = {true,false}. Then, S entails the four buckets {(true, 3), (false, 0)}, {(true, 2), (false, 1)}, {(true, 1), (false, 2)}, and {(true, 0), (false, 3)} (or [3,0], [2, 1], [1,2], and [0,3], respectively, in shorthand notation). Following the mappings given in the table from Table 1, it holds that $([3,0]) = (41), \u03c6([2,1]) = (62,Y2,44), \u03c6([1,2]) = (93, 45, 45), and \u00a2([0,3]) = (46).\nBuckets allow us to restrict the candidates of arguments that are possibly commutative (exchangeable) and hence might be grouped. The idea is that commutative arguments can be replaced by a bucket that counts over their range values instead of listing each of the arguments separately. In particular, each combination of bucket for the commutative arguments and fixed values for the remaining arguments must be mapped to the same potential value, as illustrated in the upcoming example.\nExample 4 Take a look at Table 2, which contains a compressed representation of the factor & from Table 1. Originally, & maps each combination of bucket for R2 and R3 and fixed values for R\u2081 to the same potential value, e.g., R\u2081 = true, R2 = true, R3 = false and R\u2081 = true, R2 = false, R3 = true (that is, the combination of value true for R\u2081 and bucket [1, 1] for R2 and R3) are mapped to the same potential value 42. Consequently, these two assignments can be represented by a single assignment (true, [1,1]) in the compressed representation shown in Table 2. In general, it is possible to compress all commutative arguments in a factor by replacing them by a so-called counting randvar, which uses buckets as a representation. In this particular example, & is commutative with respect to S = {R2, R3} and thus, we are able to group R2 and R3 together.\nGrouping commutative arguments does not alter the semantics of the factor and at the same time reduces the size of the table that has to be stored to encode the input-output mappings of the factor as well as the inference time. To obtain the maximum possible compression, we therefore aim to compute a maximum sized subset of commutative arguments.\nA crucial observation to efficiently compute a maximum sized subset of commutative arguments is that the buckets of the initially given factor must contain duplicate potential values as a necessary condition for arguments to be able to commutative. In particular, groups of identical potential values within a bucket directly restrict the possible candidates of commutative arguments, as we show next.\nTheorem 4 Let (R1,..., Rn) be a factor and let b \u2208 B(\u03c6) with |\u00a2(b)| > 1 be a bucket entailed by \u222e. Further, let G = {61,...,6e} with |G| > 2 denote an arbitrary maximal set of identical potential values in $(b) and let (r1,...,r),..., (r\u2081, ..., rn) denote all assignments corresponding to the potential values in G. Then, a subset S \u2286 {R1,..., Rn} with |S| >2 such that is commutative with respect to S is obtained by computing the element-wise intersection (r1,..., rm) \u2229 (ri, ..., rn) and adding all arguments Ri to S for which it holds that {r}}n...n{r} = (). Here, the element-wise intersection of two assignments (x1,..., X\u2113) and (y1,..., Ye) contains the value xi at position i if xi = Yi, otherwise position i equals \u00d8.\nProof It holds that $(r1,...,r) = 41,..., $(r\u2081, ..., rh) = ye and 41 = ... = \u03c6e. Moreover, let S \u2286 {R1, ..., Rn} denote any subset of commutative arguments such that |S| > 2. Recall that according to Def. 2, for all events r\u2081,...,rn \u2208 \u00d7i=1range(Ri) it holds that $(r1,...,rn) = $(r\u03c0(1),\u00b7\u00b7\u00b7,\u03b3\u03c0(n)) for all permutations \u03c0of {1,..., n} with \u03c0(i) = i for all Ri \u2209 S. Thus, the positions of all arguments which are not in S are fixed in all permutations. Consequently, the element-wise intersection of the assignments yields non-empty sets for all positions belonging to arguments not in S because these assignments contain identical assigned values at those positions. At the same time, as we consider only buckets with at least two elements, all assignments contain at least two distinct assigned values because all assignments that contain only a single value are those that map to a bucket containing a single element. We further consider all assignments (r\u03c0(1),\u2026\u2026\u2026,\u03c0(n)) for all permutations \u03c0of {1, ..., n} and therefore, there are at least two different assigned values for all positions belonging to arguments in S, yielding an empty set when computing the element-wise intersection of the assignments for a position of any argument in S. \u25a0\nTheorem 4 tells us that candidate subsets of commutative arguments can be found by first identifying groups of identical potential values within a bucket and then computing the element-wise intersection of the assignments corresponding to these potential values. The following example illustrates how Thm. 4 can be applied to identify commutative arguments.\nExample 5 Consider again the factor $(R1, R2, R3) depicted in Table 1. For the sake of the example, let us take a look at the bucket [2,1]. We have two groups of identical values, namely G\u2081 = {42,42} and G2 = {64}. Since G2 contains only a single potential value, there are no candidates of commutative arguments induced by G2. However, G\u2081 contains the potential value 42 two times and the corresponding assignments are (true, true, false) and (true, false, true). The element-wise intersection of those assignments is then given by (true, true, false) \u2229 (true, false, true) = (true, \u00d8, \u00d8). As the element-wise intersection is empty at positions two and three, the set {R2, R3} is a possible subset of commutative arguments.\nBy looking for maximal sets G of identical potential values, we ensure that we actually find maximum sized candidate subsets of commutative arguments. Moreover, the number of positions having an empty element-wise intersection directly corresponds to the size of every candidate subset S, that is, the number of positions having an empty element-wise intersection is equal to |S|. As all permutations of these |S| positions are mapped to the same potential value, we know that if there is a subset of commutative arguments of size |S|, there must be at least |S| duplicate potential values in every bucket of size at least two.\nCorollary 5 Let (R1,..., Rn) be a factor and let S \u2286 {R1,..., Rn} be a subset of arguments such that \u00f3 is commutative with respect to S. Then, in every bucket b \u2208 B(\u03c6) with |$(b)| > 1, there exists a potential value y that occurs at least |S| times in \u03c6(b).\nExample 6 Consider again the factor $(R1, R2, R3), which is commutative with respect to S = {R2, R3}, depicted in Table 1. Therefore, \u0444 must map the buckets [2,1] and [1,2] (the only buckets that are mapped to at least two elements by $) to at least |S| = 2 identical potential values. Here, 42 occurs twice in $([2,1]) and 45 occurs twice in $([1,2]).\nAs we know for every bucket b containing more than one element that there must exist a potential occurring at least |S| times in b to allow for a subset S of commutative arguments to exist, we also know that there cannot be more commutative arguments than the minimum number of duplicate potential values over all buckets containing more than one element.\nCorollary 6 Let (R1,..., Rn) denote a factor. Then, the size of any subset of commutative arguments of $ is upper-bounded by\n$$min_{b \\in \\{b | b \\in B(\\phi) \\land |\\phi(b)|>1\\}} max_{\\phi \\in \\phi(b)} count(\\phi(b), \\phi)$$\nwhere count($(b), \u03c6) denotes the number of occurrences of potential y in \u03c6(b).\nExample 7 The factor $(R1, R2, R3) given in Table 1 maps [2,1] to \u300842, 42, 44) and [1,2] to (43, 45, 45) and thus, the upper bound for the size of any subset of commutative arguments of \u00f3 is two because \u0444 maps the buckets [2,1] and [1,2] to two identical potential values each.\nThe bounds implied by Cors. 5 and 6 show that the number of possible candidate subsets of commutative arguments can be heavily reduced in many practical settings. In particular, we are now able to exploit the insights from Thm. 4 as well as Cors. 5 and 6 to drastically restrict the search space of possible candidate subsets of commutative arguments, thereby avoiding the naive iteration over all O(2\") subsets of a factor's arguments and thus making the check for commutativity feasible in practice.\nWe next incorporate our theoretical findings into a practical algorithm, called DECOR, to efficiently compute subsets of commutative arguments of maximum size in practice.\""}, {"title": "4. The DECOR Algorithm", "content": "We are now ready to gather the theoretical results to obtain the DECOR algorithm, which efficiently computes a maximum sized subset of commutative arguments of a given factor. Algorithm 1 presents the whole DECOR algorithm, which undertakes the following steps on a given input factor (R1, ..., Rn) to compute subsets of commutative arguments.\nFirst, DECOR initialises a set C of possible candidate subsets of commutative arguments, which contains the whole argument list of $ at the beginning. DECOR then iterates over all buckets entailed by \u0444, where all buckets containing only a single element are skipped because they do not restrict the search space. DECOR then partitions the values in every bucket into maximal groups G1,..., Ge of identical potential values, where each group must contain at least two identical potential values as we are only interested in subsets of commutative arguments of size at least two. If no such group is found, DECOR returns an empty set as there are no candidates for a subset of commutative arguments of size at least two. Afterwards, DECOR applies the insights from Thm. 4 and iterates over all groups of identical potential values to compute the element-wise intersection of the assignments corresponding to the potential values within a group. For every group Gi of identical potential values, DECOR then builds a set Ci containing all arguments whose position in the element-wise intersection over their corresponding assignments is empty. DECOR then adds the set Ci of arguments that are commutative according to the current bucket to the set C' of candidate subsets for the current bucket if Ci is not subsumed by any other candidate subset in C'. Thereafter, as each bucket further restricts the search space for possible commutative arguments, DECOR computes the intersection of all candidate subsets collected so far in C and all candidate subsets of the current bucket in C'. DECOR keeps all candidate subsets of size at least two after the intersection that are not already subsumed by another candidate subset after the intersection. In case there are no candidate subsets of size at least two left after considering a specific bucket, DECOR returns an empty set as a result. Finally, if there are still candidate subsets left after iterating over all buckets of size at least two, DECOR returns the set of all candidate subsets of commutative arguments of maximum size. A maximum sized subset of commutative arguments can then be obtained by selecting any candidate subset in C that contains the most elements.\nNote that DECOR returns all candidate subsets of commutative arguments that are not subsumed by another candidate subset and could be replaced by a so-called counting randvar in the lifted representation of the factor. As we aim for the most compression possible, we are mostly interested in the maximum sized subset of commutative arguments. However, it might be conceivable that there are settings in which counting over two or more candidate subsets of commutative arguments yields a higher compression than counting over a single maximum sized subset. We therefore keep DECOR as a general algorithm that is able to return all candidate subsets of commutative arguments that are not subsumed by another candidate subset and leave the decision of which subset(s) to choose to the user.\nExample 8 Let us take a look at how DECOR computes a maximum sized subset of commutative arguments for the factor $(R1, R2, R3) from Table 1. Initially, DECOR starts with the set C = {{R1, R2, R3}}. After skipping the bucket [3,0], DECOR finds the group G\u2081 = {42,42} for the bucket [2,1]. Other groups contain less than two elements and are thus ignored. DECOR then computes the element-wise intersection of the assignments corresponding to the potential values in G1, which is given by (true, true, false) \u2229 (true, false, true) = (true, 0, 0). As the element-wise intersection is empty at positions two and three, DECOR adds the set Ci = {R2, R3} to the set C' of candidate subsets for the bucket [2, 1]. Afterwards, DECOR computes the intersection of {R1, R2, R3} (as C = {{R1, R2, R3}}) and {R2, R3} (as C' = {{R2, R3}}), which yields C\u2229 = {{R2, R3}} and thus also C = {{R2, R3}} for the next iteration. DECOR next finds the group G\u2081 = {45,45} for the bucket [1,2] and computes the element-wise intersection of the assignments corresponding to the potential values in G1, which is given by (false, true, false) \u2229 (false, false, true) = (false, 0,0). Again, positions two and three are empty and thus, DECOR adds the set Ci = {R2, R3} to the set C' of candidate subsets for the bucket [1,2]. Thereafter, DECOR computes the intersection of {R2, R3} (as C = {{R2, R3}}) and {R2, R3} (as C' = {{R2, R3}}), which yields C = C\u2229 = {{R2, R3}}. Finally, as the next bucket [0,3] is skipped again and there are no other buckets left, DECOR returns the set {{R2, R3}} containing a single candidate subset of commutative arguments, which is at the same time a maximum sized subset.\nWe remark that the number of candidate subsets considered by DECOR now directly depends on the number of groups of identical potential values in the buckets of the factor. In most practical settings, potential values are not identical unless the factor is commutative with respect to a subset of its arguments. Therefore, DECOR heavily restricts the search space for possible candidate subsets of commutative arguments in most practical settings.\nRecall that the \u201cnaive\u201d algorithm iterates over O(2n) subsets of arguments and then has to consider all |R|\" (where R denotes the range of the arguments and n is the total number of arguments) potential values in the table of potential mappings during each iteration to check whether a subset of arguments is commutative. While DECOR also has to consider all |R|\" potential values during the course of the algorithm (in fact, every algorithm searching for commutative arguments has to take a look at every potential value at least once), DECOR considers every potential value just twice (in Lines 5 and 10).\nTheorem 7 Let (R1,..., Rn) denote a factor and let R = range(R\u2081) = . = range(Rn). The worst-case time complexity of the \u201cnaive\u201d algorithm to compute a maximum sized subset of commutative arguments is in O(2n \u00b7 |R|n\u00b7n).\nProof The \"naive\" algorithm iterates over all subsets of p's arguments and then iterates for every subset over all buckets induced by that subset to check whether each bucket is mapped to a unique potential value by 6. \u03a4\u03bf compute the buckets, all n positions in all Rn assignments are considered. The iteration over all values in the buckets requires time O(|R|", "naive": "lgorithm iterates over O(2n) subsets of arguments and thus has a complexity of O(2n \u00b7 |R|n\u00b7n).\nTheorem 8 Let \u00a2(R1,..., Rn) denote a factor and let R = range(R1) = . = range(Rn). The expected worst-case time complexity of the DECOR algorithm to compute a maximum sized subset of commutative arguments is in O(|B($)|\u00b7k. (n/2) +|R|n\u00b7n), where k denotes the maximum number of potential values within a bucket entailed by \u0444.\nProof The partitioning of $(b) into maximal groups of identical potential values (Line 5) requires time linear in the number of potential values in the bucket b and as all |R|n potential values are looked at exactly once over all buckets, the partitioning requires time O(|R|n) in total for all buckets. DECOR finds at most [|R|n/2] groups of identical potential values (if every group contains exactly two identical potential values) over all buckets. The loop in Line 9 thus needs O(|R|", "are": "In case the model is highly symmetric, symmetries within a factor are expected to be over larger sets. Thus, DECOR has just few sets to consider. In case there are hardly any symmetries within a factor and the model itself, DECOR has to check few small candidate sets and might even end up with an empty candidate set after few buckets.\nFinally, before we demonstrate the practical efficiency of DECOR in our experimental evaluation, we remark that DECOR can handle factors with arguments having arbitrary ranges. During the course of this paper, we consider identical ranges of all arguments for brevity, however, it is possible to apply DECOR to factors with arguments having various ranges R1,..., Rk by considering the buckets for all arguments with range Ri separately for all i \u2208 {1, ..., k} as only arguments having the same range can be commutative at all."}, {"title": "5. Experiments", "content": "In addition to our theoretical results, we conduct an experimental evaluation of DECOR to assess its performance in practice. We compare the run times of DECOR to the \"naive\" approach, i.e., iterating over all possible subsets of a factor's arguments in order of descending size of the subsets."}, {"title": "6. Conclusion", "content": "We present the DECOR algorithm to efficiently detect commutative factors in FGs. DECOR makes use of buckets to significantly restrict the search space and thereby efficiently handles factors even with a large number of arguments where previous algorithms fail to compute a solution within a timeout. We prove that the number of subsets to check for commutative arguments is upper-bounded depending on the number of duplicate potential values in the buckets. By exploiting this upper bound, DECOR drastically reduces the number of subsets to check for commutative arguments compared to previous algorithms, which iterate over O(2n) subsets for a factor with n arguments in the worst case. Additionally, DECOR returns all candidate subsets of commutative arguments that are not subsumed by another candidate subset, allowing to compress the model even further. Overall, DECOR drastically increases the efficiency to identify commutative factors and further reduces the model."}, {"title": "Appendix A. Formal Description of the Advanced Colour Passing Algorithm", "content": "The advanced colour passing (ACP) algorithm introduced by Luttermann et al. (2024a) builds on the colour passing algorithm (Kersting et al., 2009; Ahmadi et al., 2013) and solves the problem of constructing a lifted representation\u2014more specifically, a so-called parametric factor graph (PFG)\u2014from a given factor graph (FG). The idea of ACP is to first find symmetries in a propositional FG and then group together symmetric subgraphs. ACP looks for symmetries based on potentials of factors, on ranges and evidence of random variables (randvars), as well as on the graph structure by passing around colours. Algorithm 2 provides a formal description of the ACP algorithm, which proceeds as follows."}, {"title": "Appendix B. Additional Experimental Results", "content": "In addition to the experimental results provided in Sec. 5, we provide further experimental results for individual scenarios in this section. In particular, the plot given in Fig. 2 displays average run times over multiple runs for different choices of the number of commutative arguments k. We now showcase separate plots for each of the choices of the number of commutative arguments k to highlight the influence of k on the performance on the algorithms. Again, we compare the run times of the \"naive\" algorithm to the run times of detection of commutative factors (DECOR) algorithm on factors with n \u2208 {2"}]}]}