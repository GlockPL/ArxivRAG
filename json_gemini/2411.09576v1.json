{"title": "Automating Reformulation of Essence Specifications via Graph Rewriting", "authors": ["Ian Miguel", "Andr\u00e1s Z. Salamon", "Christopher Stone"], "abstract": "Formulating an effective constraint model of a parameterised problem class is crucial to the efficiency with which instances of the class can subsequently be solved. It is difficult to know beforehand which of a set of candidate models will perform best in practice. This paper presents a system that employs graph rewriting to reformulate an input model for improved performance automatically. By situating our work in the ESSENCE abstract constraint specification language, we can use the structure in its high level variable types to trigger rewrites directly. We implement our system via rewrite rules expressed in the Graph Programs 2 language, applied to the abstract syntax tree of an input specification. We show how to automatically translate the solution of the reformulated problem into a solution of the original problem for verification and presentation. We demonstrate the efficacy of our system with a detailed case study.", "sections": [{"title": "1 Introduction", "content": "Formulating an effective constraint model of a problem of interest is crucial to the efficiency with which the problem can subsequently be solved [6]. It is difficult to know beforehand which of a set of candidate models will perform best in practice. In this paper we present our work in progress on a system that reformulates an input model to improve performance automatically. It differs from some earlier work on automated model reformulation, such as CGRASS [8], Tailor [9], the work of Bessiere et al. [2] to learn implied global constraints, or Savile Row [16], in that it reformulates a model of a parameterised problem class rather than individual problem instances. This has the advantage that the effort made to reformulate the model is amortised over all the instances of the class that are to be solved, rather than having to be paid back during the solution of a single instance. Furthermore, by implementing reformulation as forward-chaining sound rewrite rules, we avoid the need for external verification in existing class-based reformulation [5, 4, 14]. Here we build on our previous proposal for a system [15], demonstrating how to apply graph transformation techniques [21] to achieve automated rewriting of ESSENCE specifications.\nIn contrast to recent work by Leo et al. [13], who reformulate a low level model of a problem class, we situate our work in the ESSENCE abstract constraint specification language [7]. The advantage of this approach is that the structure apparent in a concise abstract specification can be used to trigger and guide reformulation. For example, Listing 1 presents the k-fold colouring problem we will use in our case study. Here the single abstract decision variable is a binary relation. Having that information directly in the variable type, as"}, {"title": "2 Automating Reformulation of Essence Specifications via Graph Rewriting", "content": "opposed to reconstructing it from a constraint model-level representation likely composed of a constrained matrix of more primitive decision variables, is a significant aid to reformulation. Furthermore, a single reformulated specification can be refined into a variety of both models and solving paradigms, allowing us to gain a fuller picture of performance. We implement our system via rewrite rules expressed in the Graph Programs 2 language [3, 18], applied to the abstract syntax tree of an input specification. Given the small size of ESSENCE specifications and the efficiency of the GP2 system in applying graph rewriting rules, the rewriting process has negligible cost. When the type of the decision variable is transformed, the solution must be converted to the original type for verification and presentation to the user. A constraint solver can be employed to solve the solution re-assignment specification straightforwardly. We demonstrate this process even in the case of the nested types supported by ESSENCE.\nOur work makes the following primary contributions:\nAutomated class-level model reformulation via a library of graph transformation rewrite rules.\nInverse rewriting of solutions for presentation and verification.\nA case study using k-fold graph colouring."}, {"title": "3 Reformulating Essence specifications for performance", "content": "The ESSENCE language allows problems to be expressed concisely using high level types such as sets, multisets, functions, relations, and partitions, which may be nested sets of functions, multisets of relations, etc. ESSENCE specifications are typically solved by a process of refinement via the CONJURE tool [1], where the high level types are transformed into collections of more primitive variables, such as matrices of integers, in the solver-independent ESSENCE PRIME language [17]. The SAVILE ROW tool [16] further transforms a model in ESSENCE PRIME into input suitable for a particular constraint, SAT, or SMT solver.\nThis complex chain of refinement and transformation is sensitive to the ESSENCE specific-ation with which it starts, and so an initial specification may not always lead to optimal solving performance. Therefore, reformulating the specification becomes necessary to improve the efficiency of the solving process. This is often where modellers, through their expertise, can obtain the largest gains in efficiency [20]. One of our objectives is to help automate the application of reformulation rules, sourcing them both from expert modellers or those found via other search methods and building a library of rewriting rules. An advantage"}, {"title": "4 Automating Reformulation of Essence Specifications via Graph Rewriting", "content": "of reformulating ESSENCE is that even a small change can produce a marked change once refinement and parameter substitution has taken place.\nThe gains provided by reformulations are not only limited to faster solving time but, crucially, can lead to smaller memory footprints across the subsequent refinement steps. In some cases this allows problems to be solved that in their original form may not be able to reach the solver or that could crash during solving.\nIn practice, a specification written in ESSENCE is turned into GP2 form by a series of conversions and translations by following the shortest path in a conversion graph pictured in Figure 1. We extend our previous work [21], which contains formal definitions for each intermediate form, by adding a different representation of the AST once in GP2 form. In our approach, instead of compounding symbols and their grammatical information into the labels of the GP2 nodes, we add an extra branch to each node separating the two. Once in GP2 form, any of the available precompiled rules can be applied to the AST of the ESSENCE specification. In this particular study, we are interested in a rewrite rule designed to showcase the potential of high-level reformulations making use of relaxation, auxiliary domains, type nesting and constraint rewrites. A fragment of our rule set can be seen in Listing 2, where the left-hand side of the rule is designed to match the portion of the AST in which a relation is declared. The rule takes three parameters, specName, decisionVariableName and findPos, two strings and an integer, respectively, capturing the fact that the labels on those nodes can be any value and can be reused during the rewriting step. Labels in quotes such as \"find\" and \"relation\" must be matched exactly. Nodes in the interface are nodes that will be preserved. In this case, all the nodes are preserved, and only one label is changed by attaching the flag # red that will trigger subsequent rules."}, {"title": "4 Case Study: k-fold fractional graph colouring", "content": "In order to demonstrate our reformulation system in operation we present a case study with fractional graph colouring, which is a generalisation of the graph colouring problem where multiple distinct colours are assigned to each vertex of a graph such that pairs of neighbouring vertices have no colours in common. In the literature it can be found under various different names: Graph Multicoloring Problem, Generalised Graph Colouring Problem, k-Fold Graph Colouring, Fractional Graph Colouring, or Fractional Vertex Colouring. It has been used in the past to showcase constraint programming techniques [10, 19] and it is commonly found in the context of scheduling applications [12]. We will refer to the integer value k in k-fold as the number of colours each node must be assigned, and we will refer to the number of colours available explicitly."}, {"title": "I. Miguel and A. Z. Salamon and C. Stone", "content": "In our case study we take as the input specification that is shown in Listing 1, which employs a binary relation to encode the graph and a binary relation for the decision variable linking each node with the colours assigned to it. This is a natural choice as graphs are commonly modelled using relations, and more than one colour has to be mapped to each node. Two constraints enforce that adjacent vertices do not share the same colour and that the correct number of colours is assigned to each vertex (via a common pseudo-Boolean counting pattern).\nFrom this initial specification, it is possible to activate a sequence of rewriting rules that reformulate the specification with the objective of improving its performance. It can be noted that the number of colours necessary for each vertex is the same for all vertices, the colours assigned to each vertex could be expressed as a set of fixed size, eliminating the need for the counting constraint. This means that one rewrite of the rule should be able to introduce auxiliary domains and another eliminate a constraint. It follows that the decision variable be could turned into a total function that maps each vertex to a set of colours, further removing the need for a quantification, as referring to a set allows referring to all the colours of a specific node in one simpler statement. This requires a rewrite that turns the relation into a function and modifies the existing constraint.\nThe graph transformation rules proceed as follows:\n1. A rewrite rule matches a decision variable of arbitrary name and relation type, that is also mentioned in a quantification with a counting pattern, plus a second relation where the binary relation is over the same object (which is common for graphs) and a quantification over it. Occurrences of the decision variable colouring are bold blue in Figure 3.\n2. The rule tags the decision type's node, the head of the subtree of the constraint to be eliminated and the inner quantification of the colour that checks that adjacent vertices do not have the same colours. The tagged nodes are highlighted in red in Figure 3.\n3. Then, an additional rule propagates the tags in each subtree.\n4. Then, a rule is applied until possible to match each pair of tagged nodes; the deeper of the two is removed, and so is the edge between them. This is to avoid deleting a node while leaving a dangling edge.\n5. The remaining tagged nodes are used to glue in the desired subtrees, while removing the single node's tags. Three rules match the specific tagged nodes and add the auxiliary domain, the new decision variable and the reformulated constraint.\n6. The remaining tagged nodes are removed, together with their parent edge."}, {"title": "I. Miguel and A. Z. Salamon and C. Stone", "content": "This procedure adds an auxiliary domain of type set that will host the colours, a new decision variable of type function mapping the left-hand side of the relation to the auxiliary set, and shrinks the constraints to simply require an empty intersection of two sets. The final product can be seen in Listing 3."}, {"title": "4.1 Empirical evaluation of the reformulation", "content": "In order to test the performance of the reformulated abstract specification we have developed an instance generator that produces input parameters; this uses a simple grid search spanning a range of values for n nodes and e edges for the graph to be coloured, c colours available and cpn colours per nodes enforced. Values. n: 10-40, step size 10. e: n\u00b2 * 20% - 80%, step size 5%. cpn: 2-5, step size 1. c: cpn*4-6, step size 1.\nEach instance is solved using both models and the results are plotted in Figure 4.\nOur system can also translate graphs from the Python library NetworkX into ESSENCE relations, which allows the conversion of any of its library of graphs into instances by supplying the c and cpn parameters. A small selection of iconic graphs has been used for additional testing, such as obtaining the 5-fold colouring of the dodecahedral graph in Figure 3."}, {"title": "5 Converting solutions to their original type", "content": "When a reformulation changes the type of a decision variable, the solution produced by the solver will be of the transformed type. To verify that the solution of the reformulated specification is, in fact, a solution to the original problem, we must convert it back to its original type. To achieve this, we create a converter based on an ESSENCE specification, which requires the solution of the reformulated problem as a parameter. The converter (illustrated in Listing 4) includes all the variables declared in the original specification, along with all of its parameters. Additionally, it must have a decision variable with exactly the same name as the original specification, and a constraint mapping assignments of the new type to the old type. Solving this parameterised specification produces a solution that follows the structure of the original type that can be checked using CONJURE with the -validate-solution option.\nWe timed the conversion of all the solutions obtained by solving the instances produced in the previous section. The worst-performing conversion took 0.56 seconds, with an overall average of 0.459 seconds. This overhead is significant only for the smallest instances."}, {"title": "6 Conclusion", "content": "In this paper we have demonstrated an automated system for the reformulation of ESSENCE specifications. Our system, implemented in the Graph Programs 2 language, reformulates specifications of parameterised problem classes, giving the key advantage of reformulation effort being amortised over the set of instances from the class to be solved. High-level ESSENCE specifications are concise and highly structured, aiding rewriting. Furthermore, they are not tied to any particular solving paradigm, hence specification reformulations may be tested against a variety of modelling and solving choices.\nFuture work. Thanks to this foundational work, we have created the basis necessary to develop a system where the rewrite rules are produced automatically, or semi-automatically, starting from pairs of specifications that express possible reformulations. Automating the creation of rewrite rules would not only free the developer from the need to write GP2 programs but also collect rewrites from past specifications that have been refined over time in order to populate a rewriting library by distilling previous expert knowledge sitting idle in existing catalogues and literature. Another enticing future direction is the production of rewrite rules using search methods, which could be applied to any arbitrary specification. The aim would be to produce reformulations that improve the current model under consideration and are reusable."}]}