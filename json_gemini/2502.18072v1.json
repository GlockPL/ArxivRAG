{"title": "MRBTP: Efficient Multi-Robot Behavior Tree Planning and Collaboration", "authors": ["Yishuai Cai", "Xinglin Chen", "Zhongxuan Cai", "Yunxin Mao", "Minglong Li", "Wenjing Yang", "Ji Wang"], "abstract": "Multi-robot task planning and collaboration are critical challenges in robotics. While Behavior Trees (BTs) have been established as a popular control architecture and are plannable for a single robot, the development of effective multi-robot BT planning algorithms remains challenging due to the complexity of coordinating diverse action spaces. We propose the Multi-Robot Behavior Tree Planning (MRBTP) algorithm, with theoretical guarantees of both soundness and completeness. MRBTP features cross-tree expansion to coordinate heterogeneous actions across different BTs to achieve the team's goal. For homogeneous actions, we retain backup structures among BTs to ensure robustness and prevent redundant execution through intention sharing. While MRBTP is capable of generating BTs for both homogeneous and heterogeneous robot teams, its efficiency can be further improved. We then propose an optional plugin for MRBTP when Large Language Models (LLMs) are available to reason goal-related actions for each robot. These relevant actions can be pre-planned to form long-horizon subtrees, significantly enhancing the planning speed and collaboration efficiency of MRBTP. We evaluate our algorithm in warehouse management and everyday service scenarios. Results demonstrate MRBTP's robustness and execution efficiency under varying settings, as well as the ability of the pre-trained LLM to generate effective task-specific subtrees for MRBTP.", "sections": [{"title": "Introduction", "content": "Multi-robot systems (MRS) that involve robots with diverse capabilities offer the potential for improved performance and fault tolerance compared to single-robot solutions (Colledanchise et al. 2016). Developing an autonomous MRS requires an efficient and robust control architecture, along with methods to adapt them for specific tasks. Behavior Trees (BTs) have emerged as a popular control architecture due to their modularity, interpretability, reactivity, and robustness, making them well-suited for both single- and multi-robot systems (Heppner et al. 2024; Heppnerl et al. 2023; Neupane and Goodrich 2019; Colledanchise et al. 2016). As the potential of BTs gains more attention, various methods for automatically generating BTs have been proposed, including evolutionary computing (Neupane and Goodrich 2019; Colledanchise, Parasuraman, and \u00d6gren 2019), reinforcement learning (Banerjee 2018; Pereira and Engel 2015), and BT synthesis (Tadewos, Newaz, and Karimoddini 2022; Neupane and Goodrich 2023). Among these methods, BT planning (Chen et al. 2024a,b; Cai et al. 2021; Colledanchise, Almeida, and Ogren 2019) has advantages in leveraging interpretable action models and producing reliable BTs to achieve goals, which make it a promising approach to generate BTs for autonomous robot systems.\nHowever, current BT planning focuses primarily on a single robot, and the development of effective multi-robot BT planning algorithms remains challenging. The challenges mainly arise from two aspects:\n\u2022 For heterogeneous actions, how to coordinate them across different BTs to accomplish the team's goal.\n\u2022 For homogeneous actions, how to use them to improve fault tolerance without redundant execution.\nIn this paper, we propose Multi-Robot Behavior Tree Planning (MRBTP), the first sound and complete algorithm for generating reliable and robust BTs for MRS. MRBTP addresses the above challenges as follows:\n\u2022 We employ cross-tree expansion, where the condition expanded in one BT will be further expanded by all BTs. This means one robot may take an action to satisfy another's precondition, enabling multi-tree collaboration.\n\u2022 We allow backup structures to be expanded by robots with homogeneous actions to ensure fault tolerance, while using intention sharing to avoid redundant execution. During execution, each robot broadcasts its current action so that others can predict its effects and avoid performing actions with the same effects.\nAs shown in Figure 1, in an everyday service scenario, the team's goal is to prepare a Salad. The humanoid robot can perform the action Make (Fruit,Salad), if the precondition Has (Fruit) is satisfied. Although it cannot do Unload (Fruit,Package), it can push Has (Fruit) to the planning queue, and another quadruped robot will expand this action through cross-tree expansion, enabling multi-tree coordination.\nIn another case where In (Salad, Refrigerator) is satisfied, and both robots can do Open (Refrigerator) and Get (Salad). In this case, MRBTP will expand the same structure in both trees to ensure failure tolerance. If both robots are available, the humanoid robot with higher priority will do Open (Refrigerator) and share its intention. The quadruped robot will then assume IsOpen (Refrigerator) is true and walk to the Refrigerator, waiting to do Get (Salad, Refrigerator) as long as the Refrigerator is truly open. The intention sharing ensures parallelization and improves execution efficiency of the robot team.\nAlthough MRBTP is a domain-independent algorithm, it is possible to enhance the planning and execution efficiency if Large Language Models (LLMs) are available for domain-dependent reasoning. Therefore, we further propose an optional plugin named subtree pre-planning. Assuming the LLM can reason some useful actions for each robot according to its capabilities, we can use these actions to plan useful subtree structures quickly before the long-horizon planning process. These subtrees can not only increase the planning speed, but can also decrease the communication expenses during execution. Experiments in warehouse management and everyday service scenarios demonstrate MRBTP's robustness and execution efficiency under varying settings, as well as the ability of pre-trained LLMs to generate effective task-specific subtrees for MRBTP."}, {"title": "Background", "content": "Behavior Tree. A BT is a directed rooted tree where the execution nodes interact with the environment and the control flow nodes handle the triggering logic of their children(Colledanchise and \u00d6gren 2018). At each time step, the BT initiates a tick that goes through control nodes, determining the action that the robot will execute according to the environmental state. This paper mainly focuses on four typical BT nodes:\n\u2022 Condition An execution node that checks whether the environment state satisfies the specified condition, returning either success or failure accordingly.\n\u2022 Action An execution node that controls the robot to perform an action, returning success, failure, running depending upon the outcome of execution.\n\u2022 Sequence: A control flow node that only returns success if all its children succeed. Otherwise, it ticks its children from left to right, and the first child to return failure or running will determine its return status.\n\u2022 Fallback?: A control flow node with logic opposite to the sequence node. It returns failure only if all of its children fail. If not, the first occurrence of success or running during ticking becomes its return status.\nBT Planning. In BT planning for a single robot (Cai et al. 2021), we represent a BT as a three-tuple $T =< f,r, \u2206t >$. $f: 2^n \u2192 2^n$ is its effect on the environment state, At is the time step, and $r : 2^n \u2192 {S, R, F}$ partitions states into three regions, where T returns success, running, failure, respectively.\nThen the BT planning problem can be described as: < S, L, A, M, So, g >, where S is the finite set of environment states, L is the finite set of literals that form states, A is the finite set of actions, M is the action model, so is the initial state, g is the goal condition.\nA condition c in BT is usually a subset of a state s. If $c \u2286 s$, it is said condition c holds in that state s. The state transition affected by action a \u2208 A can be defined as a triplet M(a) =< pre(a), add(a),del(a) >, comprising the precondition, add effects, and delete effects of the action. If a is finished after k time step, the subsequent state st' will be:\n$St' = f_a(St) = St \u222a add(a) \\ del(a),t' = t + k$ (1)\nProblem Formulation\nWe first extend the BT representation from a single robot to a multi-robot system.\nDefinition 1 (Multi-BT System). A n-robot BT system is a four-tuple $(\\Phi, f_\u03b8, r_\u03b8, \u2206t)$, where $\\Phi = {T_i}_{i=1}^{n}$ is the set of BTs, $f_\u03b8: S \u2192 S$ is the team state transition function, At is the team time step, $r_\u03b8 : S \u2194 { S, R, F }$ is the team region partition.\nDue to variability in hardware performance, we allow each robot's BT to have a different response frequency, with At representing the common minimum response interval. The state transition can be calculated as follows:\n$S_{t+to} = f_\u03b8(St) = S_t \u222a \u222a (add(a_i) \\del(a_i))$ (2)\nwhere ai is the action of robot i in time t. If robot i does not have an action or its action is running, we let add(ai) =\ndel(ai) = \u00d8.\nThe team region partition can be calculated as follows:\n$r_0(s) = \\begin{cases}\nR \\text{if} i, r_i(s) = R\\\\S \\text{if} \\forall i, r_i(s) \\neq R \\text{and} \\exists i, r_i(s) = S\\\\F \\text{if} \\forall i, r_i(s) = F\n\\end{cases}$ (3)\nThe status of I is R if any BT is still running, S if some BT returns success and no one is running, and F if all BT fails."}, {"title": "Methods", "content": "We first detail MRBTP, analyzing its soundness, completeness, and computational complexity. Then, we demonstrate how intention sharing functions among BTs during execution. Finally, we introduce the optional plugin, subtree pre-planning, to further enhance efficiency.\nMulti-Robot Behavior Tree Planning\nOne-Step Cross-Tree Expansion Algorithm 1 gives the pseudocode of one-step cross-tree expansion for one robot. Given its current BT T, action space A and the condition to expand c (line 1), the function returns an expanded BT T along with the newly expanded condition set Cnew (line 15). Similar to one-step expansion for a single robot (Cai et al. 2021), the expansion begins with Tnew = c and Cnew = \u00d8 (line 2-3). Then we go through the action space A to find all premise actions that can lead to c (line 4-5). For each premise action a, we calculate its corresponding precondition ca (line 6), form a sequence structure Ta (line 7), and add Ta to the tail of the root fallback node of Tnew (line 8). Now Tnew can achieve e using these expanded actions if their precondition are met. We store these preconditions in Cnew (line 9).\nIf Tnew is expanded (line 10), we need to decide where in T to place it. There are two cases: (1) c is in T, which means it was previously expanded by T itself. So we replace c with Tnew in T just like in single-robot BT expansion (line 11-12); (2) c is not in T, which means it was expanded by other BTs. To allow this BT to take actions to fulfill c, we add it to the tail of the root fallback node of T (line 13-14).\nProposition 1. Given T is FTS from R to g, if T is expanded by Algorithm 1 to T' given c, c is in T and Cnew \u2260 0, then T' is FTS from R' = RU {s \u2208 S|Ca \u2286 s, Ca \u2208 Cnew} to g.\nProposition 2. If T is expanded by Algorithm 1 to T' given c, c is not in T and Cnew \u2260 \u00d8, then T' is FTS from Snew = {s \u2208 S| Ca \u2286 s, Ca \u2208 Cnew} to c.\nThe above two propositions state the changes in the ROA after one-step cross-tree expansion. If c is in T (Proposition 1), the ROA of T will be expanded by Cnew to achieve g. If c is not in T (Proposition 2), then c will be treated as a new sub-goal for T to be achieved from Snew.\nMRBTP Algorithm 4 gives the pseudocode of MRBTP to plan BTs for the whole robot team. The algorithm initializes a set of conditions to be explored Cu = {g} and a set of expanded conditions CE = \u00d8 (line 1-2). The BT for each robot i is initialized as T\u2081 = Fallback(g) (line 4), which is FTS fromto g. Then the algorithm continually explores conditions in Cu (line 5-6) until a solution is found, otherwise it returns Unsolvable (line 14). For each explored c, it is either pruned if \u2203c \u2208 CE, C'\u2286 c (line 7), or expanded by all robots through one-step cross-tree expansion (line 8-9). After the one-step expansion for each robot, the newly expanded conditions Cnew will be appended to CE and Cu (line 12-13). If at that time \u2203c' \u2208 Cnew, c'\u2286 80, which means a solution is found, the algorithm returns \u03a6 = {T}=1 as the solution (line 10-11).\nProposition 3. After the k-th (k \u2265 1) iteration of the while loop in Algorithm 4, where the explored condition is"}, {"title": "Intention Sharing for Multi-BT Execution", "content": "From the MRBTP planning process, we can observe that if multiple robots have identical actions (or similar actions with the same effect), MRBTP will expand them simultaneously in different BTs. This could lead to backup structures. These structures are beneficial for fault tolerance because if one robot fails, others can take over and complete the action. However, when multiple robots are available, backup structures can result in redundant execution. To avoid this, we introduce the multi-BT intention sharing method based on communication.\nIntention Queue During execution, each robot i maintains an intention queue Z\u2081 = (a1,a2,...,am) that indicates the actions being performed by other robots. In a situation with good communication, all robots' intention queues should remain consistent. Therefore, in the following text, we use I to refer to the intention queues of all robots. Based on the intention queue, we can calculate the belief success space BS and the belief failure space BF for robot i:\n$B_S^i = \u222a_j^i = 1 (add(a_k) \\del(a_k))$ (4)\n$B_F^i = \u222a_j^i = 1 (del(a_k) \\ add(a_k))$ (5)\nwhere j is the index of its own action aj in the intention queue Z. If j = 1, then $B_S^i = B_F^i = \u00d8$, which means the action is not dependent on any other's intention. If the robot currently has no action, it will be treated as j = m + 1 when calculating belief spaces.\nBS and BF will be used during the ticks of each BT. For each atomic condition node represented by a single literal c = l, it will first check if l is in the belief spaces when ticked. If $l \u2208 B_S^i$, it returns S without interacting with the environment, and returns F when $l \u2208 B_F^i$.\nWhenever a robot i exits an action or enters a new one, it will be broadcast to every other robot. Each robot then removes the old action of robot i from the intention queue I (if it exists) and pushes the new action into it (if applicable). After this, each robot will update its belief spaces BS and BF to adjust its actions reactively. Note that an action exiting or entering may be due to two cases: (1) the environment state has changed, or (2) the belief spaces have changed. As a result, any addition or removal of actions in the intention queue I may lead to adjustments in other actions, creating a chain reaction. In other words, our intention-sharing method maintains the reactivity and robustness of BTs in response to uncertain environments.\nParallelism and Blocking While intention sharing can avoid redundant execution, it also enhances action parallelism within the robot team. For example, as shown in Figure 2, in a warehouse management scenario, there are two robots capable of opening doors and transporting packages. They have expanded almost identical tree structures, sequentially executing Open (Door), Walk (Package), and Move (Package). However, since IsClose (Door)\u2208 So, both robots satisfy the precondition to execute Open (Door). Without intention sharing, they would perform this action simultaneously, causing redundancy. With intention sharing, however, if robot 1 ticks its BT 71 first, it will execute Open (Door) and send this intention to robot 2. For robot 2, IsOpen(Door) \u2208 B after updating the intention queue I, so the corresponding condition node for IsOpen (Door) will return S, allowing the BT T2 to continue ticking and start executing Walk (Package). This transforms a serial BT structure into parallel execution.\nHowever, when robot 2 attempts to execute Move (Package), which relies on the precondition IsOpen (Door), robot 2 will wait until the door is actually opened by robot 1. Formally speaking, if l \u2208 B but not in the current state l \u2209 s, when robot i attempts to perform an action a where l \u2208 pre(a), a will be blocked. In this case, robot i shares the intention of a, and a returns R as if it were executing, but it is actually doing nothing. The blocking mechanism prevents actions from being executed under incorrect preconditions, while also enabling the parallel execution of subsequent actions, thereby further enhancing the execution efficiency of the robot team."}, {"title": "Optional Plugin: Subtree Pre-planning", "content": "While MRBTP with intention sharing is proven to be an effective and efficient algorithm for the multi-robot BT planning problem, there is still room for further improving its efficiency. To achieve this, we begin by considering the following observations.\n\u2022 During planning, the same tree structure might be generated multiple times, especially when multiple robots have overlapping action spaces.\n\u2022 During execution, sharing the intentions of every short-horizon atomic action not only increases the communication overhead but is also ineffective for long-term task scheduling.\nA natural idea is that if we can obtain some long-horizon actions for each robot that are beneficial to the task, which we call subtrees, and add these actions to the corresponding robot's action space. During planning, we let these subtrees be prioritized over atomic actions, thereby speeding up the search for solutions and avoiding redundant planning. During execution, we only share the intentions of these subtrees. If the subtrees are well-designed, this approach can reduce communication overhead while also improving the efficiency of parallel execution.\nSubtree Pre-planning Let's first assume that we have obtained an action sequence A = (a1,a2,..., am) for planning the subtree, and then consider how to use LLMs to generate task-related action sequences for each robot. Due to the modularity of the BT, we can treat the action sequence A as a long-horizon action, and its action model can be calculated:\n$pre(A) = \u222a_j = 1 ^m (pre(a_j) \\ \u222a_k = 1 ^j - 1 add(a_k))$ (6)\n$add(A) = \u222a_j = 1 ^m (add(a_j) \\del(a_j)) \u2013 pre(A)$ (7)\n$del(A) = \u222a_j = 1 ^m (del(a_j) \\add(a_j))$ (8)\nWe can obtain the tree structure of execution actions in A sequentially by running a single-robot BT planning algorithm, with constraints on the order of actions to be expanded, a process we call subtree pre-planning.\nHowever, to make a subtree behave like an atomic action, i.e., not to exit the precondition of A while running in intermediate states, we need to introduce an additional subtree control structure, as illustrated in Figure 3. The subtree TA has the preconditions Close (Door) and Empty (Hand), but after Get (Key), the Empty (Hand) condition is no longer satisfied. In the conventional BT planning algorithm, this would result in the subsequent actions not being ticked, causing the entire subtree T\u0104 to fail. To address this issue, we introduce three subtree control nodes: EnterSubtree, ExitSubtree, and RunningSubtree. If pre(A) is satisfied and the robot is not currently running this subtree TA, then EnterSubtree will be executed. This action will change the status of the subtree to running. The RunningSubtree will return S until ExitSubtree is executed, or the BT begins executing a new action due to a change in the environment state. The parameter for the three nodes can be any identifier of the subtree. A simple way is to use the add effect add(am) of the last action in the action sequence A as the identifier."}, {"title": "Experiments", "content": "We evaluate the performance of MRBTP in two simulated scenarios: (1) Warehouse management with coarse action granularity and a smaller action space, and (2) Home service with finer granularity and a larger action space. First, we assess the robustness of the MRBTP method under varying levels of homogeneity by introducing a failure probability for each action. Next, we conduct an ablation study on intention sharing to verify its contribution to the execution efficiency of multi-robot BTs. Then, given the finer action granularity in the home service scenario, we perform an ablation study to evaluate subtree pre-planning, examining the effectiveness of pre-trained LLMs in generating task-related action sequences and their impact on the overall efficiency of the MRBTP. All experiments were conducted on a system equipped with an AMD Ryzen 9 5900X 12-core processor with a 3.70 GHz base clock and 128 GB of DDR4 RAM."}, {"title": "Experimental Setup", "content": "Scenarios (a) Warehouse Management. We extend the Minigrid (Chevalier-Boisvert et al. 2023) environment for multi-robot simulations with 4-8 robots in 4 rooms containing randomly placed packages. Robots have diverse action spaces, including room inspection and package relocation, with some possessing specialized capabilities or restricted access. The goal is to optimize warehouse space utilization. (b) Home Service. In the VirtualHome (Puig et al. 2018) environment, 2-4 robots interact with dozens of objects and perform hundreds of potential actions. Each robot's action space is diverse, aiming to complete complex household tasks, such as setting the table or preparing a meal.\nEvaluation Metrics The algorithm's performance was evaluated using the following metrics: (a) Success Rate (SR): The percentage of successfully completed tasks across multiple trials, accounting for action failure probabilities. (b) Team Steps (TS): The total number of steps required for all robots to complete their tasks in parallel. (c) Total Robot Steps (RS): The sum of steps taken by each robot independently. (d) Communication Overhead (Comm.): The number of broadcast communications between robots due to intention sharing. (e) Number of Expanded Conditions (EC): The number of condition nodes expanded during the multi-robot BTs planning process, including those from subtree pre-planning if available. (f) Planning Time (PT): The time taken for multi-robot BT planning, including subtree pre-planning when available.\nSettings (a) Homogeneity (a): The proportion of redundant actions assigned to robots, where a = 1 denotes complete heterogeneity (no overlap in action spaces) and a = 0 denotes complete homogeneity (identical action spaces). (b) Action Failure Probability (FP): The probability that a robot fails to execute an action. (c) Subtree Intention Sharing (Subtree IS) and Atomic Action Nodes Intention Sharing (Atomic IS): These terms refer to the application of Intention Sharing either among subtrees or at the level of individual atomic action nodes. (d) Feedback (F) and No Feedback (NF): This setting distinguishes between LLMs that use feedback during subtree generation and those that do not. In the Feedback condition, the LLM receives up to 3 feedback iterations, while in the No Feedback condition, no feedback is provided.\nBaselines BT planning algorithms typically utilize action models for planning. To ensure consistency under the same problem assumptions, we propose directly adapting the BT-Expansion (Cai et al. 2021) algorithm, which has"}, {"title": "Experimental Results", "content": "Performance Comparison We randomly generated solvable multi-robot BT planning problems under various settings. shows a significant drop in BT-Expansion's success rate as homogeneity decreases. In contrast, MRBTP maintains a perfect success rate of 100% across all settings due to its cross-tree expansion. To avoid bias in execution efficiency (TS, RS) caused by planning failures, we only compared cases where both algorithms succeeded. Notably, even under full homogeneity, MRBTP outperforms BT-Expansion in execution efficiency due to intention sharing.\nRobustness As shown in Figure 4a, the robustness of our algorithm improves with increasing homogeneity and is further enhanced by a larger number of robots. This improvement results from the increased likelihood of other robots compensating for action failures. Even with a 50% failure probability per action, the system retains approximately a 50% chance of achieving the goal with 8 robots and complete action space homogeneity.\nExecution Efficiency As shown in Figure 4b, in fully heterogeneous scenarios, enabling intention sharing results in fewer team steps, indicating that our MRBTP algorithm inherently maintains superior execution efficiency under these conditions. Additionally, as homogeneity increases, the likelihood of robots performing redundant actions rises, reducing the probability of parallel task execution. However, with intention sharing, redundant actions are significantly minimized, preventing further efficiency loss. In this context, increased homogeneity brings more backup structures, further improving execution efficiency.\nEffectiveness of Task-Specific Subtree Pre-Planning We constructed a dataset of 75 instances across three levels of homogeneity. The model used to generate subtrees"}, {"title": "Execution Efficiency across Different LLMS", "content": "We tested different versions of LLMs, including gpt-3.5-turbo (2024.12) and gpt-4o-2024-08-06 (OpenAI 2023), for assisting in subtree pre-planning. As shown in , with the increased reasoning capability of the LLMs, there is a slight improvement in execution efficiency, while communication overhead remains largely unchanged. This can be attributed to the fact that subtree pre-planning becomes more appropriate and effective as the model's reasoning ability improves. Additionally, the results further demonstrate that the feedback mechanism enhances execution efficiency across all LLMs."}, {"title": "Related Work", "content": "BT Planning. Many works have focused on automatically generating BTs to perform tasks, such as evolutionary computing (Neupane and Goodrich 2019; Colledanchise, Parasuraman, and \u00d6gren 2019; Lim, Baumgarten, and Colton 2010), reinforcement learning (Banerjee 2018; Pereira and Engel 2015), imitation learning (French et al. 2019), MCTS (Scheide, Best, and Hollinger 2021), and formal synthesis (Li et al. 2021; Tadewos, Newaz, and Karimoddini 2022; Neupane and Goodrich 2023). Recently, some works directly generate BTs using LLMs (Lykov and Tsetserukou 2023; Lykov et al. 2023). However, the above methods either require complex environment modeling or cannot guarantee the reliability of BTs. In contrast, BT planning (Cai et al. 2021; Chen et al. 2024a) based on STRIPS-style modeling not only offers intuitive environment modeling but also ensures the reliability and robustness of the generated BTs.\nBT in MRS. BT generation for Multi-Robot Systems (MRS) has been investigated using various methodologies. Evolutionary computing (Neupane and Goodrich 2019) is a general heuristic search method applied to BT generation in MRS. While versatile, this approach often suffers from slow search efficiency due to its lack of integration with the action model. Given the modular nature of BT systems, the action model is not difficult to obtain (Arora et al. 2018), enabling the development of methods that can yield more efficient solutions. MRS BT generation methods based on LLMs (Lykov et al. 2023) or other machine learning techniques have also been explored. These methods require substantial training data, making data collection and model training resource-intensive. Moreover, the aforementioned methods lack guarantees for the completeness and correctness of the generated BTs. Auction-based methods, some of which incorporate action model planning, rely on the assumption of reliable communication and low transmission delay to ensure efficient task completion. However, such conditions are not always guaranteed, rendering these approaches less robust in environments with unreliable communication. In contrast, our method generates BTs before the robot team begins execution, ensuring task completion even in the absence of communication during execution. Communication during execution serves only to improve coordination efficiency, rather than being a necessary assumption.\nLLM for Task Reasoning. Recently, significant progress has been made in using LLMs for task reasoning such as progprompt, PlanBench, and Voyager. Furthermore, the LLM has shown the ability to decompose the task into subgoals, which is closely related to our subtree pre-planning for multi-robot BT planning. As the task reasoning abilities of LLMs continue to evolve and strengthen, our subtree pre-planning technique is poised to become increasingly relevant and effective."}, {"title": "Conclusion", "content": "We propose MRBTP, the first sound and complete algorithm for solving the multi-robot BT planning problem. The cross-tree expansion coordinates BTs for achieving goals, while intention sharing improves execution efficiency and robustness. The LLM plugin further enhances planning speed and reduces communication overhead. These contributions represent a key step forward in scalable, reliable multi-robot systems. Future research will refine the algorithm's performance and extend its application to more complex, dynamic environments, solidifying MRBTP as a foundational approach in multi-robot planning. Furthermore, the potential deployment of the algorithm on actual robotic systems will be explored, evaluating its effectiveness, scalability, and practicality in real-world scenarios."}, {"title": "Appendix", "content": "A.Proofs of MRBTP\nIn this section, we present a comprehensive version of the formalizations and proofs for Multi-Robot Behavior Tree Planning\n(MRBTP).\nDefinitions\nDefinition 3 (Behavior Tree). A behavior tree (BT) is a three-tuple $T =< f,r,\u2206t >$. $f : 2^n \u2192 2^n$ is its effect on the environment state, \u2206t is the time step, and $r : 2^n \u2192 {S, R, F}$ partitions states into three regions, where T returns success, running, failure, respectively.\nIn BT planning for a single robot (Cai et al. 2021), we represent the problem as: < S, L, A, M, so, g >, where S is the finite set of environment states, L is the finite set of literals that form states, A is the finite set of actions, M is the action model, so is the initial state, g is the goal condition.\nA condition c in BT is usually a subset of a state s. If $c \u2286 s$, it is said condition e holds in that state s. The state transition affected by action a \u2208 A can be defined as a triplet M(a) =< pre(a), add(a), del(a) >, comprising the precondition, add effects, and delete effects of the action. We assume that an action always finishes in finite time. If a is finished after k time step, the subsequent state st' will be:\n$St' = f_a(st) = st \u222a add(a) \\ del(a), t' = t + k$ (9)\nThe following property holds for Va \u2208 A:\nadd(a) \u2229 del(a) = \u00d8 (10)\nadd(a) \u2229 pre(a) = \u00d8 (11)\nWe then extend the BT representation from a single robot to a multi-robot system.\nDefinition 4 (Multi-BT System). A n-robot BT system is a four-tuple $(\\Phi, f_\u03b8, r_\u03b8, \u2206t)$, where $\\Phi = {T_i}_{i=1}^{n}$ is the set of BTs, $f_\u03b8: S \u2192 S$ is the team state transition function, \u2206t is the team time step, $r_\u03b8 : S \u2194 { S, R, F }$ is the team region partition.\nDue to variability in hardware performance, we allow each robot's BT to have a different response frequency, with Ato representing the common minimum response interval. The state transition can be calculated as follows:\n$S_{t+\u2206ts} = f_\u03b8(St) = St\u222a\u222a (add(ai) \\del(ai))$ (12)\nwhere ai is the action of robot i in time t. If robot i do not have an action or its action is running, we let add(ai) =\ndel(ai) = \u00d8.\nThe team region partition can be calculated as follows:\n$r_0(s) = \\begin{cases}\nR \\text{if} i, r_i(s) = R\\\\S \\text{if} \\forall i, r_i(s) \\neq R \\text{and} \\exists i, r_i(s) = S\\\\F \\text{if} \\forall i, r_i(s) = F\n\\end{cases}$ (13)\nThe status of I is R if any BT is still running, S if some BT returns success and no one is running, and F if all BT fails.\nDefinition 5 (Finite Time Successful). \u0424is finite time successful (FTS) from region of attraction (ROA) R to condition c, if \u2200so \u2208 R there is a finite time \u315c such that for any t < \u315c, r\u00f8(st) = R, and for any t > T, ro(st) = S, c \u2286 St.\nWith definitions above, the multi-robot BT planning problem can finally be defined.\nProblem 2 (Multi-Robot BT Planning). The problem is a tuple (S, L, {Ai}=1, M, so, g), where S is the finite set of environment states, L is the finite set literals that form states and conditions, Ai is the finite action set of robot i, M is the action model, so is the initial state, g is the goal condition. A solution to this problem is a BT set \u03a6 = {T}=1 built with {A}=1, such that I is FTS from R\u018f so to g.\nPropositions and Proofs\nLemma 1. Given a condition c, the sequence structure Ta = sequence(ca,a) expanded in Algorithm 3 (line 7) is FTS from Sa = {s \u2208 S|Ca \u2286 s} to c.\nProof. Starting from any st \u2208 Sa = {s \u2208 S|Ca \u2286 s}, \u2203Ca, Cast. According to Equation 9, there exists a finite k such that the action returns success and st+k = st\u222aadd(a)\\del(a) \u2265 ca Uadd(a)\\del(a) = pre(a)Uc\\del(a). Since action selection (line 5) ensures that c \\ del(a) = c, we have st+k\u2287 pre(a) Uc \u2287 c. Therefore Ta is FTS from Sa to c.\nLemma 2. Given a condition c and Cnew \u2260 0, Tnew expanded in Algorithm 3 (line 8) is FTS from Snew = {s \u2208 S|Ca s, Ca \u2208 Cnew} to c."}, {"title": "Assumption", "content": "As mentioned above", "occur": "n(1) Deadlocks."}]}