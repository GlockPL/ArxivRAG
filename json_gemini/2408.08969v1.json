{"title": "Differentiable Edge-based OPC", "authors": ["Guojin Chen", "Haoyu Yang", "Haoxing Ren", "Bei Yu", "David Z. Pan"], "abstract": "Optical proximity correction (OPC) is crucial for pushing the boundaries of semiconductor manufacturing and enabling the continued scaling of integrated circuits. While pixel-based OPC, termed as inverse lithography technology (ILT), has gained research interest due to its flexibility and precision. Its complexity and intricate features can lead to challenges in mask writing, increased defects, and higher costs, hence hindering widespread industrial adoption. In this paper, we propose DiffOPC, a differentiable OPC framework that enjoys the virtue of both edge-based OPC and ILT. By employing a mask rule-aware gradient-based optimization approach, DiffOPC efficiently guides mask edge segment movement during mask optimization, minimizing wafer error by propagating true gradients from the cost function back to the mask edges. Our approach achieves lower edge placement error while reducing manufacturing cost by half compared to state-of-the-art OPC techniques, bridging the gap between the high accuracy of pixel-based OPC and the practicality required for industrial adoption, thus offering a promising solution for advanced semiconductor manufacturing.", "sections": [{"title": "Introduction", "content": "Optical proximity correction (OPC) is a critical technique in computational lithography that compensates for the optical proximity effect (OPE) caused by interference and diffraction in the lithographic imaging process. As integrated circuit technology nodes advance to 90 nm and below, simple resolution enhancement techniques (RET) can no longer meet the requirements for high-resolution and high-fidelity lithographic imaging. To address this challenge, OPC has evolved from rule-based OPC (RBOPC) to model-based OPC (MBOPC).\nRBOPC relies on a pre-established mask correction rule table, which is derived from engineering experience or fitted experimental and simulation data [1]. Although RBOPC is computationally fast and produces relatively simple optimized mask patterns, it can only compensate for local OPE and cannot find a globally optimal solution for the mask optimization problem.\nMBOPC, on the other hand, is based on the physical model of lithographic imaging and employs numerical optimization algorithms to modify the mask pattern. As depicted in Figure 1, MBOPC can be further classified into edge-based OPC (EBOPC) and pixel-based OPC (PBOPC). EBOPC divides the edge contour of the mask pattern into several segments and iteratively optimizes the position of each segment along its normal direction to compensate for lithographic imaging errors [2].\nHowever, current EBOPC methods, such as the Mask Error Enhancement Factor (MEEF) matrix algorithm [2], have limitations in computational efficiency and accuracy. The algorithm is computationally intensive, scaling poorly with the size and complexity of IC layouts. Its foundational linearity assumptions often fail to account for the nonlinearities prevalent in advanced lithography, leading to subpar performance in complex cases where edge interactions are significant and not adequately captured. The MEEF matrix, further burdened by potential ill-conditioning and a static representation throughout optimization, may not adapt to dynamic process variations, thus trading off accuracy for computational manageability.\nPBOPC, also known as inverse lithography technology (ILT), pushes the boundaries of mask optimization by rasterizing the mask layout into a pixel array and optimizing the transmission of each mask pixel by gradient descent [3]. This approach allows for free-form curved edge contours and the addition of sub-resolution assist features (SRAF) [4-7] to improve imaging performance. ILT algorithms can be categorized into two classes based on their mask representation: end-to-end pixel-based methods for prediction [8-14] or acceleration, and implicit function-based methods using level sets to enhance acceleration and manufacturability [15-17]. Among the SOTA ILT methods, MultiILT [14] adopts a multi-level resolution strategy for better OPC performance and manufacturability.\nDespite the advancements in ILT algorithms, they still face several challenges that hinder their widespread adoption in the semiconductor industry. As illustrated in Figure 1, the pixelated mask patterns generated by ILT are often complex and difficult to manufacture, requiring costly rectangular decomposition into manufacturable Manhattan polygons. Further, the application of decomposition and mask rule check (MRC) methods to regularize the mask patterns may"}, {"title": "Preliminaries", "content": "We employ the sum of coherent systems (SOCS) decomposition of a 193nm wavelength system as the optical model for lithography modeling, following the same approach as [18]. The aerial image intensity $I$ is represented by the convolution of the mask $M$ and a set of optical kernels $H$. The $N$th order approximation to the partially coherent system is obtained using eq. (1):\n$I(x, y) \\approx \\sum_{i=1}^{N_k} \\sigma_i |M(x, y) \\otimes h_i (x, y)|^2,$\nwhere $\\otimes$ denotes the convolution operation, $h_i$ is the $i$th kernel of $H$, $\\sigma_i$ is the corresponding weight of the coherent system, and $(x, y)$ is the index notation of the matrix. $M(x, y)$ represents the pixel value at the point $(x, y)$ of the mask image $M$. A constant threshold resist model (CTR) is applied to convert the aerial image intensity $I$ to the printed resist image $Z$.\n$Z(x, y) =\\begin{cases}\n1, & \\text{if } I (x, y) > I_{th} \\\\\n0, & \\text{otherwise,}\n\\end{cases}$\nwhere $I_{th}$ is the intensity threshold."}, {"title": "Evaluation Metrics", "content": "In this paper, we use squared $L2$ error, process variation band (PVB) and edge placement error (EPE) as three typical metrics to evaluate OPC performance. Moreover, the mask fracturing shot count (#shot) proposed in [10] is also applied in this work to evaluate mask complexity and manufacturability.\nSquared $L2$ error $L_2$ measures the difference between the nominal resist image $Z_{nom}$ and the target image $T$, defined as:\n$L_2(Z_{nom},T) = ||Z_{nom} \u2013 T||^2.$\nPVB evaluates the robustness of the mask against different process conditions. It is computed by measuring the bitwise XOR region between the printed images from the maximum and minimum process conditions ($\\pm 2\\%$) $Z_{max}, Z_{min}$. A smaller PVB indicates a more robust mask. $PVB(Z_{max}, Z_{min}) = ||Z_{max} \u2013 Z_{min}||^2$.\nEdge placement error The Edge Placement Error (EPE) [18] quantifies the geometric distortion of the resist image.\nShot count #Shot [10] is the number of decomposed rectangles that replicate the original mask exactly."}, {"title": "Problem Formulation", "content": "Given a target design $T$, we aim to find a set of boundary segments $S = {S_1, S_2, . . ., S_n}$, and a binary mask $M\\in {0,1}^{m\\times n}$ formed by the matrix inside the boundary composed of these segments $S$, where $m$ and $n$ are the dimensions of $T$. The objective is to determine the corresponding printed image $Z$ that minimizes the weighted sum of EPE, L2, PVB, and #shots."}, {"title": "DiffOPC Algorithm", "content": "To enable the application of differentiable EBOPC to arbitrary layout patterns while utilizing minimal additional information, such as the EPE measure points, several challenges need to be addressed: 1) Ensuring a more flexible movement of segments in Manhattan geometries, particularly at pattern corners. 2) Mapping discrete edge movements to a continuous space for efficient updates. 3) Maintaining compatibility with the chain rule for differentiation during the rasterization process, which converts edge parameters to pixel binary masks. In this section, we introduce the movement and update mechanisms for edge segments, describe a CUDA-accelerated ray casting algorithm for rasterization, demonstrate how lithography gradients can be utilized to update the movement of edge segments, and introduce an algorithm for SRAF placement."}, {"title": "Edge Segmentation and Movement", "content": "We present Algorithm 1 for segmenting target polygon edges into smaller segments of a pre-defined length. The algorithm returns a minimal set of segments, denoted as $S \\in \\mathbb{R}^{N_s\\times 2\\times 2}$, where $\\mathbb{R}$ represents the real number domain and $N_s$ is the number of segments. Each segment $s_i \\in S$ is represented by its starting and ending coordinates in vector form: $[[x_1, y_1], [x_2, y_2]]$. These segments $S$ serve as the optimization parameters for DiffOPC, providing increased flexibility in handling corner edges compared to traditional EBOPC methods which only optimize the edge movement distance. As illustrated in Figure 2, each segment $s_i$ is associated with a direction vector $d_i \\in D$, which enables better reconstruction of segments back into polygons and determines the direction of movement. Furthermore, the algorithm ensures compliance with the MRC by merging excessively short segments when necessary.\nIn DiffOPC, after determining the segments $S$ and their corresponding directions $D$, it is crucial to establish the velocity vector $v_i$ for each segment $s_i$. The velocity vector connects the movement of edge segments with the gradients obtained from lithography simulations. The concept of velocity vectors is inspired by level set-based ILT (LSILT). In LSILT, the velocity component is the projection of the gradient of the implicit level set function $\\phi$ onto the mask plane, denoted as $V$, which can be a vector in any direction. However, in DiffOPC, the movement direction $v_i$ of an edge segment $s_i$ is restricted to be perpendicular to its direction vector $d_i$, (either horizontal or vertical), satisfying the condition $v_i \\cdot d_i = 0$. Additionally, we set the default orientation of all velocity vectors $v_i$ to point outward from the polygon, as illustrated in Figure 2."}, {"title": "Differentiable Edge-Based OPC", "content": "The preprocessed data consists of segments $S$ and corresponding velocity vectors $V$. $S$ is stored as learnable parameters in tensor $S\\in \\mathbb{R}^{N_S\\times 2\\times 2}$, while $V$ is a fixed tensor $V \\in \\mathbb{R}^{N_S\\times 2}$ used in computations, where $N_S$ is the number of segments. In DiffOPC, the forward pass from edge parameters $S$ to the resist image $Z$ involves five differentiable steps: 1) Edge parameter rounding. 2) Merging corner edges. 3) Edge-to-mask rasterization. 4) Forward lithography simulation. 5) Loss calculation. Each step's forward and backward computations will be discussed in detail in this chapter.\nDifferentiable edge parameter rounding. Since the edge parameters $S$ are real-valued, while the edge coordinate system is integer-valued, the rounding operation is non-differentiable. To address this issue and enable a differentiable process, we employ the straight-through estimator (STE) for rounding $S$.\n$\\hat{x_i} = STE(x_i), \\hat{y_i} = STE(y_i), \\hat{s_i} = STE(s_i), \\hat{S} = STE(S).$\nSTE is defined as:\n$\\hat{x} = STE(x) = Round(x), $\n$\\frac{\\partial L}{\\partial STE(x)} = \\frac{\\partial L}{\\partial x}$\nThe forward pass illustrated in Figure 3(a) applies the rounding function to $S$, while the backward pass directly propagates the gradients from $L$ to $S$, as shown in Figure 3(b).\nCorner edge merging. During the optimization, as edges move, the endpoints of different segments separate. For non-corner segments, the segment length remains unchanged since they only move along"}, {"title": "Transform Mask to Edge Gradients with Velocity", "content": "The forward pass of the rasterization process converts the edge parameters, represented as a tensor of shape $[N_s, 2, 2]$, into a mask tensor of shape $[W, H]$, where $N_s$ is the number of segments, and $W$ and $H$ are the width and height of the mask, respectively. In contrast, the backward pass requires transforming the gradients from the lithography model, which are of shape $[W, H]$, into gradients for the segments, represented as a tensor of shape $[N_s, 2, 2]$. To accomplish this, the algorithm first computes the gradient of the mask tensor with respect to the edge parameters using automatic differentiation. Let $\\frac{\\partial L}{\\partial M}$ be the gradient of the loss function $L$ with respect to the mask tensor $M$, obtained from the lithography model. The goal is to calculate $\\frac{\\partial L}{\\partial S}$, the gradient of the loss function with respect to the edge parameters $S$. Applying the chain rule, we have:\n$\\frac{\\partial L}{\\partial \\hat{S}} = \\frac{\\partial L}{\\partial M} \\frac{\\partial M}{\\partial S}$\nThe term $\\frac{\\partial M}{\\partial S}$ represents the Jacobian matrix of the rasterization process, which maps changes in edge parameters to changes in the mask tensor. This Jacobian matrix is computed efficiently using Algorithm 4. In our implementation, as in the Interpolate function in line 10, we choose the gradient at the midpoint of each segment as the representative gradient for that segment, as stated in eq. (10). Once the Jacobian matrix is obtained, the gradient of the loss function with respect to the edge parameters can be calculated by multiplying the gradient of the loss function with respect to the mask tensor, $\\frac{\\partial L}{\\partial M}$, by the Jacobian matrix $\\frac{\\partial M}{\\partial S}$. This operation effectively backpropagates the gradients from the lithography model to the edge parameters, enabling the optimization of the edge-based OPC problem using gradient-based methods.\nMRC aware optimization. One of the significant advantages of EBOPC is the ability to obtain boundary information in real-time during the optimization process, including edges, line ends, jogs, notches, and other features. This is not possible with PBOPC. While"}, {"title": "Lithography simulations", "content": "After obtaining the mask $M$ through the rasterization process, we can utilize forward lithography model in eq. (1) to calculate the aerial intensity $I$. To obtain a continuous-valued printed image $Z$, we employ the sigmoid function $\\sigma(\\cdot)$ to scale eq. (2) into a continuous space: $Z = \\sigma(\\alpha(I \u2013 I_{th}))$, where $\\alpha$ is the steepness of $\\sigma(\\cdot)$, and $I_{th}$ is the threshold intensity value.\nObjective function. We employ a combination of three loss functions: L2 loss, PVB loss, and EPE loss. The L2 loss and PVB loss are defined as:\n$L_2 = ||Z_{nom} - T||^2, L_{pvb} = ||Z_{max} \u2013 Z_{min}||^2.$\nFor the EPE loss, measured points are sampled along the boundary of the target patterns, which includes a set of samples on horizontal edges (HS) and a set of samples on vertical edges (VS). To map the EPE loss to the continuous-value domain, we utilize the sigmoid function. First, we calculate the distance between $Z_{nom}$ and the target pattern $T$ at the sampled points in VS and HS:\nD_{sum_{ij}} =\\begin{cases}\n\\sum_{k=j-th_{epe}}^{j+th_{epe}} D_{ik} & \\text{if } (i, j) \\in HS, \\\\\n\\sum_{k=i-th_{epe}}^{i+th_{epe}} D_{kj} & \\text{if } (i, j) \\in VS,\n\\end{cases}\nwhere $D_{ik}$ and $D_{kj}$ represent the distances between the printed image and the target pattern at the corresponding locations, and $th_{epe}$ is a threshold value that determines the neighborhood size for the distance calculation. $D$ is calculated by $D = (Z_{nom} - T)^2$. Next, we apply the sigmoid function to the calculated distances to obtain the continuous-valued EPE loss:\nL_{epe} = \\frac{1}{\\|HS \\cup VS\\|} \\sum_{(i,j) \\in HS \\cup VS} \\frac{1}{1 + exp(-\\gamma D_{sum_{ij}})},$\nwhere $\\gamma$ is a scaling factor that controls the steepness of the sigmoid function. The total loss function is then defined as a weighted sum of the three individual loss components:\nL_{total} = w_1L_2 + w_2L_{pvb} + w_3L_{epe},\nwhere $w_1, w_2$, and $w_3$ are the weights assigned to each loss component. The use of the sigmoid function in the EPE loss allows for a smooth integration of the EPE into the continuous-value domain, enabling efficient gradient-based optimization.\nFor the backward pass, the gradients of the total loss function with respect to the segment $s_i$ are calculated using the chain rule:\n\\frac{\\partial L}{\\partial s_i} = \\frac{\\partial L}{\\partial M} \\frac{\\partial M}{\\partial s_i} = w_1 \\frac{\\partial L_2}{\\partial M} + w_2 \\frac{\\partial L_{pub}}{\\partial M} + w_3 \\frac{\\partial L_{epe}}{\\partial M},\nwhere $\\lfloor \\cdot \\rfloor$ is floor operation and\n\\hat{x_i} = \\lfloor \\frac{X_{i1} + X_{i2}}{2} \\rfloor, \\hat{y_i} = \\lfloor \\frac{Y_{i1} + Y_{i2}}{2} \\rfloor,\nFor the $L_2$ loss, the gradient is calculated as:\n\\frac{\\partial L_2}{\\partial M} = 2 \\cdot (Z - T)\n=\n=\n&=\n&(H')^* \\otimes [(Z \u2013 T) \\odot Z \\odot (1 \u2013 Z) \\odot (M \\otimes H)]},\nwhere the $H'$ is the flipped kernel set $H$, and the $H^*$ is the conjugate of $H$. Similarly, for the PVB loss, the gradient is calculated as:\n\\frac{\\partial L_{pub}}{\\partial M} = 2 \\cdot (Z_{min} - Z_{max}),\nThe derivation of $\\frac{\\partial Z_{min}}{\\partial M}$ and $\\frac{\\partial Z_{max}}{\\partial M}$ is similar to that of $\\frac{\\partial Z}{\\partial M}$ in eq. (12). For the EPE loss, the gradient is calculated by summarizing the gradients at the measure points $(i, j)$:\n\\frac{\\partial L_{epe}}{\\partial M} = \\sum_{(i,j) \\in HS \\cup VS} \\frac{\\partial L_{epe}}{\\partial D_{sum_{ij}}} \\frac{\\partial D_{sum_{ij}}}{\\partial M},\nand\n=\n\n &= \\gamma \\cdot \\frac{1}{1+exp(-\\gamma D_{sum_{ij}})} (1 \u2013 \\frac{1}{1+exp(-\\gamma D_{sum_{ij}})}),\nD_{kj} & \\text{if } (i, j) \\in VS,"}, {"title": "Experimental Results", "content": "In our implementation, we set $N_k = 24$ for the SOCS approximation. The parameters $\\alpha = \\beta = \\gamma = 50, w_1 = 1, W_2 = 0.9, w_3 = 100$. The default segment length is set to 80 nm. The lithography recipe is provided by the ICCAD 2013 [18] contest evaluation package. The mask fracturing tool is implemented based on a GPU-accelerated rectangular decomposition algorithm [20]. The entire framework is written in PyTorch and tested on an Nvidia RTX 3090 GPU. The mask rule check (MRC) is performed using KLayout. DiffOPC is tested on both metal layer and via layer designs. The metal layer evaluation designs for 32 nm M1 layout designs are from [18], and larger layouts from [14] for the same process node. The via layer evaluation designs are adopted from [21], containing ten 2\u00b5m \u00d7 2\u00b5m clips with different numbers of 70nm \u00d7 70nm via patterns. SRAF seeds are generated in a low resolution of 512 \u00d7 512 and optimized at a resolution of 2048 \u00d7 2048."}, {"title": "Experimental Results on Metal Layer", "content": "Comparison with ILT. Table 2 compares the performance of our proposed DiffOPC framework with state-of-the-art (SOTA) ILT approaches, namely NeuralILT [10] and MultiILT [14], on the ICCAD13 benchmark. The comparison is based on key metrics such as L2 (nm\u00b2), PVB (nm\u00b2), EPE (nm), number of shots, and turnaround time (TAT, seconds). DiffOPC demonstrates superior performance, achieving an average L2 of 28280, which is 1.5% and 27% lower than MultiILT and NeuralILT, respectively. Attributed to the utilization of EPE loss introduced in eq. (8), DiffOPC achieves lower EPE, with an average of 2.2, representing a 19% and 71% reduction compared to MultiILT and NeuralILT. Moreover, DiffOPC requires significantly fewer shots per case, with an average of 106.1 shots, representing a 62% and 81% reduction compared to MultiILT and NeuralILT, which translates to lower manufacturing costs. These results highlight the effectiveness of DiffOPC in generating mask patterns with improved printability while maintaining better manufacturability compared to ILT methods. As mentioned in Section 1 and illustrated in Figure 5, ILT approaches are prone to introducing MRC violations, which do not meet industrial requirements. We also present the post-MRC results for MultiILT in the \"Post-MRC\" column, where the TAT includes both the ILT runtime and the post-processing time for cleaning mask rule violations. It is noteworthy that the post-MRC stage for MultiILT leads to a significant performance degradation, evident from the increased average values of L2, PVB, EPE, and TAT compared to the original MultiILT results. The results of DiffOPC outperform all metrics of ILT in the post-MRC stage. This indicates that ILT-generated patterns may not optimize as desired and could introduce more violations, prolonging processing times due to MRC. In contrast, DiffOPC maintains superior performance without extra post-processing steps, highlighting its robustness and efficiency in generating high-quality, manufacturable mask patterns meeting industrial standards.\nLarge dataset. To further validate the robustness and scalability of our proposed DiffOPC framework, we conduct experiments on a larger dataset and compare its performance with SOTA methods in Table 3. The results demonstrate that DiffOPC consistently outperforms the other methods, highlighting its effectiveness in handling complex and diverse patterns. DiffOPC achieves an average L2 of 50684, which is 4.7% and 28.2% lower than MultiILT and NeuralILT,"}, {"title": "Experimental Results on Via Layer", "content": "In Table 5, we evaluate the performance of DiffOPC on the via layer against SOTA ILT and EBOPC methods, including a commercial tool, Calibre [22].\nComparison with ILT methods. DiffOPC outperforms ILT methods in terms of L2 and EPE, achieving the lowest values of 3957 and 13.5, respectively. Notably, DiffOPC achieves these improvements while maintaining a significantly lower shot count (9.7 shots on average), which is approximately 1/20th of the shot count required by [14] (225 shots).\nComparison with EBOPC methods. Among the EBOPC methods, DiffOPC demonstrates superior performance, achieving the lowest L2 (3957), EPE (13.5), and TAT (2.8 seconds) compared to the commercial Calibre tool and the MEEF-based approach."}, {"title": "Ablation Study", "content": "Efficiency of CUDA-accelerated ray casting rasterization. We compare the runtime of our CUDA-accelerated ray casting rasterization approach with the traditional EBOPC method based on indexing and the find-then-move strategy. For a clip size of 2\u00b5m\u00d72\u00b5m, a single forward rasterization step in DiffOPC takes 16 milliseconds, while the traditional method requires 196 milliseconds, representing a 12.3x speedup achieved by our CUDA ray casting implementation.\nAblation Study on Segment Length. Segment length in DiffOPC also impacts optimization performance. In an ablation study using the ICCAD 2013 benchmark, segment lengths of 60nm, 80nm, and 100nm resulted in EPE of 2.6, 2.2, and 2.8, with runtimes of 8.95, 8.42, and 6.92 seconds. This shows that optimal segment length selection can enhance OPC performance. Future work could explore adaptive segment length strategies, adjusting lengths based on pattern complexity and optimization progress for better performance."}, {"title": "Summary of Experimental Results", "content": "The experimental results on both metal and via layers demonstrate DiffOPC's superiority over SOTA ILT, post-MRC ILT and EBOPC methods in terms of printability, manufacturability, and cost-efficiency. On metal layers, DiffOPC consistently outperforms SOTA ILT methods, exhibiting reduced EPE and shot count, along with lower manufacturing costs, while maintaining competitive TAT. The proposed framework eliminates the need for additional post-processing to address MRC violations, making it an efficient and reliable edge-based OPC solution for large-scale OPC tasks. On via layers, DiffOPC achieves the best performance in L2, EPE, and TAT among EBOPC methods, surpassing even the commercial Calibre tool. Compared to ILT methods, DiffOPC shows the lowest L2 and EPE values while significantly reducing the number of shots, leading to lower manufacturing costs and improved throughput. These results highlight DiffOPC's enhanced printability, pattern fidelity, and computational efficiency."}, {"title": "Conclusion", "content": "We propose DiffOPC, a differentiable edge-based OPC framework that bridges the gap between the superior manufacturability of EBOPC and the enhanced performance of ILT. By leveraging a CUDA-accelerated ray casting algorithm, DiffOPC enables a differentiable rasterization process that allows gradients to propagate through the lithography model, facilitating the efficient optimization of edge segment positions. This innovative approach results in significant improvements in key metrics such as L2 and EPE while maintaining an exceptionally low shot count, leading to substantially reduced manufacturing costs. Moreover, DiffOPC incorporates an efficient SRAF generation method, which seamlessly integrates SRAF with the main pattern optimization for a holistic and effective OPC solution. Experimental results highlight DiffOPC's superior performance and efficiency over SOTA EBOPC and ILT methods, making it a promising advancement in semiconductor technologies."}]}