{"title": "Differentiable Edge-based OPC", "authors": ["Guojin Chen", "Haoyu Yang", "Haoxing Ren", "Bei Yu", "David Z. Pan"], "abstract": "Optical proximity correction (OPC) is crucial for pushing the boundaries of semiconductor manufacturing and enabling the continued scaling of integrated circuits. While pixel-based OPC, termed as inverse lithography technology (ILT), has gained research interest due to its flexibility and precision. Its complexity and intricate features can lead to challenges in mask writing, increased defects, and higher costs, hence hindering widespread industrial adoption. In this paper, we propose DiffOPC, a differentiable OPC framework that enjoys the virtue of both edge-based OPC and ILT. By employing a mask rule-aware gradient-based optimization approach, DiffOPC efficiently guides mask edge segment movement during mask optimization, minimizing wafer error by propagating true gradients from the cost function back to the mask edges. Our approach achieves lower edge placement error while reducing manufacturing cost by half compared to state-of-the-art OPC techniques, bridging the gap between the high accuracy of pixel-based OPC and the practicality required for industrial adoption, thus offering a promising solution for advanced semiconductor manufacturing.", "sections": [{"title": "Introduction", "content": "Optical proximity correction (OPC) is a critical technique in computational lithography that compensates for the optical proximity effect (OPE) caused by interference and diffraction in the lithographic imaging process. As integrated circuit technology nodes advance to 90 nm and below, simple resolution enhancement techniques (RET) can no longer meet the requirements for high-resolution and high-fidelity lithographic imaging. To address this challenge, OPC has evolved from rule-based OPC (RBOPC) to model-based OPC (MBOPC).\nRBOPC relies on a pre-established mask correction rule table, which is derived from engineering experience or fitted experimental and simulation data [1]. Although RBOPC is computationally fast and produces relatively simple optimized mask patterns, it can only compensate for local OPE and cannot find a globally optimal solution for the mask optimization problem.\nMBOPC, on the other hand, is based on the physical model of lithographic imaging and employs numerical optimization algorithms to modify the mask pattern. As depicted in Figure 1, MBOPC can be further classified into edge-based OPC (EBOPC) and pixel-based OPC (PBOPC). EBOPC divides the edge contour of the mask pattern into several segments and iteratively optimizes the position of each segment along its normal direction to compensate for lithographic imaging errors [2].\nHowever, current EBOPC methods, such as the Mask Error Enhancement Factor (MEEF) matrix algorithm [2], have limitations in computational efficiency and accuracy. The algorithm is computationally intensive, scaling poorly with the size and complexity of IC layouts. Its foundational linearity assumptions often fail to account for the nonlinearities prevalent in advanced lithography, leading to subpar performance in complex cases where edge interactions are significant and not adequately captured. The MEEF matrix, further burdened by potential ill-conditioning and a static representation throughout optimization, may not adapt to dynamic process variations, thus trading off accuracy for computational manageability.\nPBOPC, also known as inverse lithography technology (ILT), pushes the boundaries of mask optimization by rasterizing the mask layout into a pixel array and optimizing the transmission of each mask pixel by gradient descent [3]. This approach allows for free-form curved edge contours and the addition of sub-resolution assist features (SRAF) [4-7] to improve imaging performance. ILT algorithms can be categorized into two classes based on their mask representation: end-to-end pixel-based methods for prediction [8-14] or acceleration, and implicit function-based methods using level sets to enhance acceleration and manufacturability [15-17]. Among the SOTA ILT methods, MultiILT [14] adopts a multi-level resolution strategy for better OPC performance and manufacturability.\nDespite the advancements in ILT algorithms, they still face several challenges that hinder their widespread adoption in the semiconductor industry. As illustrated in Figure 1, the pixelated mask patterns generated by ILT are often complex and difficult to manufacture, requiring costly rectangular decomposition into manufacturable Manhattan polygons. Further, the application of decomposition and mask rule check (MRC) methods to regularize the mask patterns may lead to a decline in OPC performance and introduce new hotspots, negating the performance advantages of ILT. Moreover, ILT algorithms tend to over-optimize shape corners because the simulated line-ends will never match the Manhattan rectangles at the line-end. Nevertheless, these challenges have been largely overlooked, preventing ILT's large-scale adoption in the industry, which tends to favor EBOPC due to lower manufacturing costs.\nTo bridge the gap between the manufacturability of EBOPC and the performance of ILT, we propose DiffOPC, a differentiable edge-based OPC method that leverages gradient information to optimize edge placement error (EPE) while considering process variation. By relaxing discrete edge movements and embedding mask rule constraints into the gradient computation, DiffOPC combines EBOPC's high manufacturability with ILT's performance. Additionally, it ensures MRC-clean results, allowing the optimized mask patterns to be directly used for mask fabrication without additional post-processing.\nDiffOPC introduces efficient solutions to enhance the edge-based OPC process. In the forward algorithm, a flexible segmentation approach and CUDA-accelerated ray casting expedite differentiable layout rasterization, while a novel SRAF seed generation algorithm optimizes SRAF placement. In the backward algorithm, DiffOPC computes lithography gradients for edge movements using a chain-rule approach and incorporates mask rule constraints to ensure manufacturability. By combining these improvements, DiffOPC achieves superior OPC performance with high manufacturability. In summary, our main contributions are as follows:\n\u2022 We propose DiffOPC, a differentiable edge-based OPC framework that integrates EPE loss and leverages MRC-aware gradients for mask optimization.\n\u2022 A flexible segmentation approach and a CUDA-accelerated ray casting algorithm are introduced to expedite layout rasterization.\n\u2022 DiffOPC efficiently computes edge segment gradients using a chain-rule approach to ensure manufacturability.\n\u2022 A novel SRAF seed generation algorithm leveraging gradients for optimal SRAF placement and further optimization.\n\u2022 DiffOPC bridges the gap between EBOPC's manufacturability and ILT's performance, offering a promising solution for high-quality and efficient OPC corrections. The experimental results show that DiffOPC reduces EBOPC's EPE by half, and even achieves lower EPE than ILT while maintaining manufacturing costs that are half of ILT's."}, {"title": "Preliminaries", "content": ""}, {"title": "Forward Lithography Model", "content": "We employ the sum of coherent systems (SOCS) decomposition of a 193nm wavelength system as the optical model for lithography modeling, following the same approach as [18]. The aerial image intensity $I$ is represented by the convolution of the mask $M$ and a set of optical kernels $H$. The $N_k$th order approximation to the partially coherent system is obtained using eq. (1):\n$I(x, y) \\approx \\sum_{i=1}^{N_k} \\sigma_i |M(x, y) \\otimes h_i(x, y)|^2,$ (1)\nwhere $\\otimes$ denotes the convolution operation, $h_i$ is the $i$th kernel of $H$, $\\sigma_i$ is the corresponding weight of the coherent system, and $(x, y)$ is the index notation of the matrix. $M(x, y)$ represents the pixel value at the point $(x, y)$ of the mask image $M$. A constant threshold resist model (CTR) is applied to convert the aerial image intensity $I$ to the printed resist image $Z$.\n$Z(x, y) =\\begin{cases}\n1, & \\text{if } I (x, y) > I_{th} \\\\\n0, & \\text{otherwise},\n\\end{cases}$ (2)\nwhere $I_{th}$ is the intensity threshold."}, {"title": "Evaluation Metrics", "content": "In this paper, we use squared $L_2$ error, process variation band (PVB) and edge placement error (EPE) as three typical metrics to evaluate OPC performance. Moreover, the mask fracturing shot count (#shot) proposed in [10] is also applied in this work to evaluate mask complexity and manufacturability.\nSquared $L_2$ error $L_2$ measures the difference between the nominal resist image $Z_{nom}$ and the target image $T$, defined as:\n$L_2(Z_{nom}, T) = ||Z_{nom} - T||^2.$ (3)\nPVB evaluates the robustness of the mask against different process conditions. It is computed by measuring the bitwise XOR region between the printed images from the maximum and minimum process conditions ($\\pm 2\\%$) $Z_{max}$, $Z_{min}$. A smaller PVB indicates a more robust mask. $PVB(Z_{max}, Z_{min}) = ||Z_{max} - Z_{min}||^2$.\nEdge placement error The Edge Placement Error (EPE) [18] quantifies the geometric distortion of the resist image.\nShot count #Shot [10] is the number of decomposed rectangles that replicate the original mask exactly."}, {"title": "Problem Formulation", "content": "Given a target design $T$, we aim to find a set of boundary segments $S = \\{S_1, S_2, ..., S_n\\}$, and a binary mask $M \\in \\{0, 1\\}^{m \\times n}$ formed by the matrix inside the boundary composed of these segments $S$, where $m$ and $n$ are the dimensions of $T$. The objective is to determine the corresponding printed image $Z$ that minimizes the weighted sum of EPE, $L_2$, PVB, and #shots."}, {"title": "DiffOPC Algorithm", "content": "To enable the application of differentiable EBOPC to arbitrary layout patterns while utilizing minimal additional information, such as the EPE measure points, several challenges need to be addressed: 1) Ensuring a more flexible movement of segments in Manhattan geometries, particularly at pattern corners. 2) Mapping discrete edge movements to a continuous space for efficient updates. 3) Maintaining compatibility with the chain rule for differentiation during the rasterization process, which converts edge parameters to pixel binary masks. In this section, we introduce the movement and update mechanisms for edge segments, describe a CUDA-accelerated ray casting algorithm for rasterization, demonstrate how lithography gradients can be utilized to update the movement of edge segments, and introduce an algorithm for SRAF placement."}, {"title": "Edge Segmentation and Movement", "content": "We present Algorithm 1 for segmenting target polygon edges into smaller segments of a pre-defined length. The algorithm returns a minimal set of segments, denoted as $S \\in \\mathbb{R}^{N_s \\times 2 \\times 2}$, where $\\mathbb{R}$ represents the real number domain and $N_s$ is the number of segments. Each segment $s_i \\in S$ is represented by its starting and ending coordinates in vector form: [[$x_1, y_1$], [$x_2, y_2$]]. These segments $S$ serve as the optimization parameters for DiffOPC, providing increased flexibility in handling corner edges compared to traditional EBOPC methods which only optimize the edge movement distance. As illustrated in Figure 2, each segment $s_i$ is associated with a direction vector $d_i \\in D$, which enables better reconstruction of segments back into polygons and determines the direction of movement. Furthermore, the algorithm ensures compliance with the MRC by merging excessively short segments when necessary."}, {"title": "Differentiable Edge-Based OPC", "content": "The preprocessed data consists of segments $S$ and corresponding velocity vectors $V$. $S$ is stored as learnable parameters in tensor $\\textbf{S} \\in \\mathbb{R}^{N_S \\times 2 \\times 2}$, while $V$ is a fixed tensor $V \\in \\mathbb{R}^{N_S \\times 2}$ used in computations, where $N_S$ is the number of segments. In DiffOPC, the forward pass from edge parameters $S$ to the resist image $Z$ involves five differentiable steps: 1) Edge parameter rounding. 2) Merging corner edges. 3) Edge-to-mask rasterization. 4) Forward lithography simulation. 5) Loss calculation. Each step's forward and backward computations will be discussed in detail in this chapter.\nDifferentiable edge parameter rounding. Since the edge parameters $S$ are real-valued, while the edge coordinate system is integer-valued, the rounding operation is non-differentiable. To address this issue and enable a differentiable process, we employ the straight-through estimator (STE) for rounding $\\textbf{S}$.\n$x_i = STE(x_i), \\hat{y_i} = STE(y_i), \\hat{s_i} = STE(s_i), \\hat{S} = STE(S)$. (4)\nSTE is defined as:\n$\\hat{x} = STE(x) = Round(x),$ \\quad \\triangleright STE forward.\n$\\frac{\\partial L}{\\partial STE(x)} = \\frac{\\partial L}{\\partial x},$ \\quad \\triangleright STE backward.\n(5)\nThe forward pass illustrated in Figure 3(a) applies the rounding function to $\\textbf{S}$, while the backward pass directly propagates the gradients from $\\hat{S}$ to $\\textbf{S}$, as shown in Figure 3(b).\nCorner edge merging. During the optimization, as edges move, the endpoints of different segments separate. For non-corner segments, the segment length remains unchanged since they only move along"}, {"title": "Differentiable rasterization using CUDA-accelerated ray casting", "content": "The core challenge in DiffOPC is the edge-to-pixel rasterization, as the lithography model in eq. (1) only accepts pixel-based mask input M. This rasterization process must be differentiable to allow the gradient flow to reach the edge parameters from the mask, and it should be as fast as possible since it is performed in every optimization epoch. Traditional EBOPC methods involve moving segments and then filling or subtracting the corresponding binary matrix at the new positions. However, this approach is time-consuming due to the need to sequentially access each segment and convert the segment's displacement into mask indices, repeatedly reading and modifying the corresponding locations. To address these issues, a method that effectively generates a binary mask from rounded edge parameters using CUDA-accelerated ray casting is proposed in Algorithm 3.\nAlgorithm 3 presents an efficient, fully parallelized method for generating a binary mask from edge parameters using ray casting. The main function, Rasterize, initializes an empty mask and a count matrix, then extracts horizontal segments from the edge parameters. Since the polygons in the mask are Manhattan rectangles and closed shapes, the algorithm only needs to process segments along one direction (either horizontal or vertical), reducing the computational cost by half. For each segment, the algorithm performs parallel computation across all grid points within the bounding box, calling the check_cross function to determine ray-segment intersections. The check_cross function uses cross products to efficiently check if a ray from a point intersects a segment. After processing all segments, the even-odd rule is applied to finalize the binary mask based on the parity of intersections at each point. The algorithm leverages parallel computation, efficient ray-segment intersection checks, and the properties of Manhattan rectangles to enable fast and accurate mask generation, making it suitable for use in the DiffOPC framework.\nThe forward pass of the rasterization process converts the edge parameters, represented as a tensor of shape [$N_S$, 2, 2], into a mask tensor of shape [W, H], where $N_S$ is the number of segments, and W and H are the width and height of the mask, respectively. In contrast, the backward pass requires transforming the gradients from the lithography model, which are of shape [W, H], into gradients for the segments, represented as a tensor of shape [$N_S$, 2, 2]. To accomplish this, the algorithm first computes the gradient of the mask tensor M with respect to the edge parameters using automatic differentiation. Let $\\frac{\\partial L}{\\partial M}$ be the gradient of the loss function L with respect to the mask tensor M, obtained from the lithography model. The goal is to calculate $\\frac{\\partial L}{\\partial \\hat{S}}$, the gradient of the loss function with respect to the edge parameters $\\hat{S}$. Applying the chain rule, we have:\n$\\frac{\\partial L}{\\partial \\hat{S}} = \\frac{\\partial L}{\\partial M} \\frac{\\partial M}{\\partial S}$\nThe term $\\frac{\\partial M}{\\partial S}$ represents the Jacobian matrix of the rasterization process, which maps changes in edge parameters to changes in the mask tensor. This Jacobian matrix is computed efficiently using Algorithm 4. In our implementation, as in the Interpolate function in line 10, we choose the gradient at the midpoint of each segment as the representative gradient for that segment, as stated in eq. (10). Once the Jacobian matrix is obtained, the gradient of the loss function with respect to the edge parameters can be calculated by multiplying the gradient of the loss function with respect to the mask tensor, $\\frac{\\partial L}{\\partial M}$, by the Jacobian matrix $\\frac{\\partial M}{\\partial S}$. This operation effectively backpropagates the gradients from the lithography model to the edge parameters, enabling the optimization of the edge-based OPC problem using gradient-based methods."}, {"title": "MRC aware optimization", "content": "One of the significant advantages of EBOPC is the ability to obtain boundary information in real-time during the optimization process, including edges, line ends, jogs, notches, and other features. This is not possible with PBOPC. While level set-based methods can control boundaries globally, they lack the ability to fine-tune specific locations. DiffOPC generates MRC-clean optimization results by explicitly controlling manufacturability through the velocity term $v_i$ during optimization. Before the experiment, we divide the MRC edges into corresponding check pairs. We classify mask rules into two categories: spacing checks, such as minimum spacing, end of line spacing, jog to jog spacing, and special notch spacing, and width checks, such as minimum width check. Let $\\delta$ denote the distance vector between check pairs. The projection of $\\delta$ along the y-direction is given by $proj_y \\delta = (\\delta \\cdot \\hat{j}) \\hat{j}$, where $\\hat{j}$ is the unit vector in the y-direction. The projection along the x-direction is similarly defined. We achieve MRC-aware optimization by controlling the velocity $v_i$ as follows: $v = v_i \\cdot \\tau(\\delta)$ where $\\tau(\\delta)$ is a function related to $\\delta$, defined as: $\\tau(\\delta) = \\sigma(\\beta (proj \\delta - D))$. Here, D is a constant related to the mask rule, and proj is the projection operator in either x or y direction, $\\beta$ is the steepness of sigmoid function $\\sigma(\\cdot)$. For the spacing and width check, when the distance proj $\\delta$ is smaller than D, the velocity term rapidly decays to 0, preventing further reduction in the distance. When proj $\\delta$ is greater than D, $\\tau(\\delta)$ returns to 1, allowing normal optimization to proceed without interference. By controlling the velocity term based on the distance between check pairs and mask rule constants, DiffOPC effectively incorporates MRC constraints into the optimization process."}, {"title": "Lithography simulations", "content": "After obtaining the mask M through the rasterization process, we can utilize forward lithography model in eq. (1) to calculate the aerial intensity I. To obtain a continuous-valued printed image Z, we employ the sigmoid function $\\sigma(\\cdot)$ to scale eq. (2) into a continuous space: $Z = \\sigma(\\alpha (I - I_{th}))$, where $\\alpha$ is the steepness of $\\sigma(\\cdot)$, and $I_{th}$ is the threshold intensity value."}, {"title": "Objective function", "content": "We employ a combination of three loss functions: $L_2$ loss, PVB loss, and EPE loss. The $L_2$ loss and PVB loss are defined as:\n$L_2 = ||Z_{nom} - T||^2, L_{pvb} = ||Z_{max} - Z_{min}||^2.$ (6)\nFor the EPE loss, measured points are sampled along the boundary of the target patterns, which includes a set of samples on horizontal edges (HS) and a set of samples on vertical edges (VS). To map the EPE loss to the continuous-value domain, we utilize the sigmoid function. First, we calculate the distance between $Z_{nom}$ and the target pattern $T$ at the sampled points in VS and HS:\n$D_{sum_{ij}} =\\begin{cases}\n\\sum_{k=j-\\theta_{epe}}^{j+\\theta_{epe}} D_{ik} & \\text{if } (i, j) \\in HS, \\\\\n\\sum_{k=i-\\theta_{epe}}^{i+\\theta_{epe}} D_{kj} & \\text{if } (i, j) \\in VS,\n\\end{cases}$ (7)\nwhere $D_{ik}$ and $D_{kj}$ represent the distances between the printed image and the target pattern at the corresponding locations, and $\\theta_{epe}$ is a threshold value that determines the neighborhood size for the distance calculation. D is calculated by $D = (Z_{nom} - T)^2$. Next, we apply the sigmoid function to the calculated distances to obtain the continuous-valued EPE loss:\n$L_{epe} = \\zeta \\sum_{(i,j) \\in HS \\cup VS} \\frac{1}{1 + exp(-\\gamma D_{sum_{ij}})},$ (8)\nwhere $\\gamma$ is a scaling factor that controls the steepness of the sigmoid function. The total loss function is then defined as a weighted sum of the three individual loss components:\n$L_{total} = w_1L_2 + w_2L_{pvb} + w_3L_{epe},$ (9)\nwhere $w_1$, $w_2$, and $w_3$ are the weights assigned to each loss component. The use of the sigmoid function in the EPE loss allows for a smooth integration of the EPE into the continuous-value domain, enabling efficient gradient-based optimization.\nFor the backward pass, the gradients of the total loss function with respect to the segment $s_i$ are calculated using the chain rule:\n$\\frac{\\partial L}{\\partial s_i} = \\frac{\\partial L}{\\partial M} \\frac{\\partial M}{\\partial s_i} = \\frac{\\partial L}{\\partial M} \\\\ \\frac{x_{i_1} + x_{i_2}}{2}, \\frac{y_{i_1} + y_{i_2}}{2} \\\\$ (10)\nwhere $[\\cdot]$ is floor operation and\n$\\frac{\\partial L}{\\partial M} = w_1 \\frac{\\partial L_2}{\\partial M} + w_2 \\frac{\\partial L_{pvb}}{\\partial M} + w_3 \\frac{\\partial L_{epe}}{\\partial M},$ (11)\nFor the $L_2$ loss, the gradient is calculated as:\n$\\frac{\\partial L_2}{\\partial M} = 2 \\cdot (Z - T) \\frac{\\partial Z}{\\partial M}.$ (12)\n$\\frac{\\partial Z}{\\partial M} = 2\\alpha \\cdot \\{H' \\otimes [(Z - T) \\odot Z \\odot (1 - Z) \\odot (M \\otimes H^*))] \\quad + (H')^* \\otimes [(Z - T) \\odot Z \\odot (1 - Z) \\odot (M \\otimes H)]\\},$ where the $H'$ is the flipped kernel set $H$, and the $H^*$ is the conjugate of H. Similarly, for the PVB loss, the gradient is calculated as:\n$\\frac{\\partial L_{pvb}}{\\partial M} = 2 \\alpha (Z_{min} - Z_{max}) \\\\ \\frac{\\partial Z_{min}}{\\partial M} - \\frac{\\partial Z_{max}}{\\partial M}.$ (13)\nThe derivation of $\\frac{\\partial Z_{min}}{\\partial M}$ and $\\frac{\\partial Z_{max}}{\\partial M}$ is similar to that of $\\frac{\\partial Z}{\\partial M}$ in eq. (12). For the EPE loss, the gradient is calculated by summarizing the gradients at the measure points (i, j):\n$\\frac{\\partial L_{epe}}{\\partial M} = \\sum_{(i,j) \\in HS \\cup VS} \\frac{\\partial L_{epe}}{\\partial D_{sum_{ij}}} \\frac{\\partial D_{sum_{ij}}}{\\partial M},$ (14)\nwhere\n$\\frac{\\partial L_{epe}}{\\partial D_{sum_{ij}}} = \\gamma \\cdot \\frac{1}{1 + exp(-\\gamma D_{sum_{ij}})} (1 - \\frac{1}{1 + exp(-\\gamma D_{sum_{ij}})}),$ (15)\nand\n$\\frac{\\partial D_{sum_{ij}}}{\\partial M} =\\begin{cases}\n\\sum_{k=j-\\theta_{epe}}^{j+\\theta_{epe}} \\frac{\\partial D_{ik}}{\\partial M}, & \\text{if } (i, j) \\in HS, \\\\\n\\sum_{k=i-\\theta_{epe}}^{i+\\theta_{epe}} \\frac{\\partial D_{kj}}{\\partial M}, & \\text{if } (i, j) \\in VS,\n\\end{cases}$ (16)\nwith $D_{ij}$ calculated as:\n$\\frac{\\partial D_{ij}}{\\partial M} = \\frac{\\alpha}{\\partial M} (Z_{ij} - T_{ij})^2 = 2(Z_{ij} - T_{ij}) \\frac{\\partial Z_{ij}}{\\partial M}.$ (17)\nThe detailed derivation of $\\frac{\\partial Z}{\\partial M}$ can be found in eq. (12)."}, {"title": "SRAF generation", "content": "SRAFs in lithography enhance sub-resolution element printability by modifying diffraction and interference patterns in photoresist, leading to widened process windows, improved resolution, depth of focus, and reduced line edge roughness. The primary distinction among prior works lies in their handling of SRAFs. In level set-based ILT methods, the implicit function f is tied to the primary pattern, preventing the generation of SRAFs during optimization. Conversely, pixel-based ILT methods like [14] can generate SRAFs during mask optimization due to their higher degree of freedom. However, pixel-based ILT cannot impose rule-based constraints on SRAFs, causing their growth to rely solely on gradients. This improves printability but can increase MRC violations and hotspots. To address these issues, we propose a two-stage SRAF optimization algorithm. The first stage involves efficient SRAF seed generation using gradient contours, and the second stage employs a differentiable edge-based optimization for the generated SRAFs. This approach effectively avoids the problems of missing SRAFs in level set-based methods and violations in pixel-based SRAFs.\nGradient Contour-based SRAF Seed Generation: During the optimization process, we observe that certain regions near the main pattern exhibit gradients that flip the mask value, changing it from 0 to 1. However, since the edge-based segments do not include these regions, they remain at 0. Combining continuous transmission mask (CTM) [19] theory and the results from [14], we conclude that these gradients can contribute to SRAF generation. As depicted in Figure 4(a), the contour line of the mask gradient map shows the position of the extreme gradient points and indicates the gradient drop rate. The position of the extreme points can guide SRAF placement, while the gradient information can guide the subsequent SRAF cleanup process. The implementation involves extending the existing mask by a certain distance related to the mask rules to create a SRAF forbidden region. As illustrated in Figure 4(a), gradient contour lines are drawn outside the SRAF forbidden region. The extreme points and the corresponding contour aspect ratios are used as the center of the SRAF seeds. The initial SRAF minimum width/length is set to a fixed value, and the shape and placement of the SRAF are determined based on the aspect ratio. This step does not require precise SRAF generation; it only needs to determine the initial position and aspect ratio.\nDifferentiable Edge-based SRAF Optimization: In the second stage, the generated seeds illustrated in Figure 4(a) are processed using the Algorithm 1 segmentation method to create new segments, which are then added to the main optimization process. The SRAFs are optimized together with the mask. To accelerate the SRAF optimization process, we adopt a multi-resolution strategy similar to [14]. SRAF seeds are generated at low resolution, and then the seeds and mask are refined in high resolution for more precise optimization. Sample results are shown in Figure 4(b). The proposed two-stage SRAF optimization algorithm enables the generation of SRAFs that enhance printability while minimizing MRC violations. We conducted a comprehensive comparison of DiffOPC, ILTs, and EBOPC in Table 1."}, {"title": "Experimental Results", "content": "In our implementation, we set $N_k = 24$ for the SOCS approximation. The parameters $\\alpha = \\beta = \\gamma = 50$, $w_1 = 1$, $w_2 = 0.9$, $w_3 = 100$. The default segment length is set to 80 nm. The lithography recipe is provided by the ICCAD 2013 [18] contest evaluation package. The mask fracturing tool is implemented based on a GPU-accelerated rectangular decomposition algorithm [20]. The entire framework is written in PyTorch and tested on an Nvidia RTX 3090 GPU. The mask rule check (MRC) is performed using KLayout. DiffOPC is tested on both metal layer and via layer designs. The metal layer evaluation designs for 32 nm M1 layout designs are from [18], and larger layouts from [14] for the same process node. The via layer evaluation designs are adopted from [21], containing ten 2\u00b5m \u00d7 2\u00b5m clips with different numbers of 70nm \u00d7 70nm via patterns. SRAF seeds are generated in a low resolution of 512 \u00d7 512 and optimized at a resolution of 2048 \u00d7 2048."}, {"title": "Experimental Results on Metal Layer", "content": "Comparison with ILT. Table 2 compares the performance of our proposed DiffOPC framework with state-of-the-art (SOTA) ILT approaches, namely NeuralILT [10] and MultiILT [14], on the ICCAD13 benchmark. The comparison is based on key metrics such as $L_2$ (nm\u00b2), PVB (nm\u00b2), EPE (nm), number of shots, and turnaround time (TAT, seconds). DiffOPC demonstrates superior performance, achieving an average $L_2$ of 28280, which is 1.5% and 27% lower than MultiILT and NeuralILT, respectively. Attributed to the utilization of EPE loss introduced in eq. (8), DiffOPC achieves lower EPE, with an average of 2.2, representing a 19% and 71% reduction compared to MultiILT and NeuralILT. Moreover, DiffOPC requires significantly fewer shots per case, with an average of 106.1 shots, representing a 62% and 81% reduction compared to MultiILT and NeuralILT, which translates to lower manufacturing costs. These results highlight the effectiveness of DiffOPC in generating mask patterns with improved printability while maintaining better manufacturability compared to ILT methods. As mentioned in Section 1 and illustrated in Figure 5, ILT approaches are prone to introducing MRC violations, which do not meet industrial requirements. We also present the post-MRC results for MultiILT in the \"Post-MRC\" column, where the TAT includes both the ILT runtime and the post-processing time for cleaning mask rule violations. It is noteworthy that the post-MRC stage for MultiILT leads to a significant performance degradation, evident from the increased average values of L2, PVB, EPE, and TAT compared to the original MultiILT results. The results of DiffOPC outperform all metrics of ILT in the post-MRC stage. This indicates that ILT-generated patterns may not optimize as desired and could introduce more violations, prolonging processing times due to MRC. In contrast, DiffOPC maintains superior performance without extra post-processing steps, highlighting its robustness and efficiency in generating high-quality, manufacturable mask patterns meeting industrial standards.\nLarge dataset. To further validate the robustness and scalability of our proposed DiffOPC framework, we conduct experiments on a larger dataset and compare its performance with SOTA methods in Table 3. The results demonstrate that DiffOPC consistently outperforms the other methods, highlighting its effectiveness in handling complex and diverse patterns. DiffOPC achieves an average $L_2$ of 50684, which is 4.7% and 28.2% lower than MultiILT and NeuralILT, respectively. Moreover, it exhibits superior performance in terms of EPE, with an average EPE of 2.7, representing a 23% and 75% reduction over MultiILT and NeuralILT. Notably, DiffOPC requires significantly fewer shots per case, with an average of 218.5 shots, which is 63% and 64% lower than MultiILT and NeuralILT. As observed in the previous experiment, the post-MRC stage for MultiILT leads to a deterioration in performance. This further underscores"}, {"title": "Experimental Results on Via Layer", "content": "In Table 5, we evaluate the performance of DiffOPC on the via layer against SOTA ILT and EBOPC methods, including a commercial tool, Calibre [22].\nComparison with ILT methods. DiffOPC outperforms ILT methods in terms of L2 and EPE, achieving the lowest values of 3957 and 13.5, respectively. Notably, DiffOPC achieves these improvements while maintaining a significantly lower shot count (9.7 shots on average), which is approximately 1/20th of the shot count required by [14] (225 shots).\nComparison with EBOPC methods. Among the EBOPC methods, DiffOPC demonstrates superior performance, achieving the lowest L2 (3957), EPE (13.5), and TAT (2.8 seconds) compared to the commercial Calibre tool and the MEEF-based approach."}, {"title": "Ablation Study", "content": "Efficiency of CUDA-accelerated ray casting rasterization. We compare the runtime of our CUDA-accelerated ray casting rasterization approach with the traditional EBOPC method based on indexing and the find-then-move strategy. For a clip size of 2\u00b5m\u00d72\u00b5m, a single forward rasterization step in DiffOPC takes 16 milliseconds, while the traditional method requires 196 milliseconds, representing a 12.3x speedup achieved by our CUDA ray casting implementation.\nAblation Study on Segment Length. Segment length in DiffOPC also impacts optimization performance. In an ablation study using the ICCAD 2013 benchmark, segment lengths of 60nm, 80nm, and 100nm resulted in EPE of 2.6, 2.2, and 2.8, with runtimes of 8.95, 8.42, and 6.92 seconds. This shows that optimal segment length selection can enhance OPC performance. Future work could explore adaptive segment length strategies, adjusting lengths based on pattern complexity and optimization progress for better performance."}, {"title": "Summary of Experimental Results", "content": "The experimental results on both metal and via layers demonstrate DiffOPC's superiority over SOTA"}]}