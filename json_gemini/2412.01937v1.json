{"title": "Approximately Optimal Search on a Higher-dimensional Sliding Puzzle", "authors": ["Nono SC Merleau", "Miguel O'Malley", "\u00c9rika Rold\u00e1n", "Sayan Mukherjee"], "abstract": "Higher-dimensional sliding puzzles are constructed on the vertices of a d-dimensional hypercube, where 2d-l vertices are distinctly coloured. Rings with the same colours are initially set randomly on the vertices of the hypercube. The goal of the puzzle is to move each of the 2d - I rings to pre-defined target vertices on the cube. In this setting, the k-rule constraint represents a generalisation of edge collision for the movement of colours between vertices, allowing movement only when a hypercube face of dimension k containing a ring is completely free of other rings. Starting from an initial configuration, what is the minimum number of moves needed to make ring colours match the vertex colours? An algorithm that provides us with such a number is called God's algorithm. When such an algorithm exists, it does not have a polynomial time complexity, at least in the case of the 15-puzzle corresponding to k = 1 in the cubical puzzle. This paper presents a comprehensive computational study of different scenarios of the higher-dimensional puzzle. A benchmark of three computational techniques, an exact algorithm (the A* search) and two approximately optimal search techniques (an evolutionary algorithm (EA) and reinforcement learning (RL)) is presented in this work. The experiments show that all three methods can successfully solve the puzzle of dimension three for different face dimensions and across various difficulty levels. When the dimension increases, the A* search fails, and RL and EA methods can still provide a generally acceptable solution, i.e. a distribution of a number of moves with a median value of less than 30. Overall, the EA method consistently requires less computational time, while failing in most cases to minimise the number of moves for the puzzle dimensions d = 4 and d = 5.", "sections": [{"title": "1 Introduction", "content": "Many engineering problems of scientific importance can be related to the general problem of finding the shortest path through a graph. When considering a game setting, the graph vertices are game configurations, and an edge exists between two vertices if a legal move (depending on the rules of the puzzle) allows one configuration to be obtained from another. Like finding the shortest path through a graph, solving a sliding puzzle involves finding the minimum number of moves (or slides) to get the target configuration from a given starting configuration. The 15-puzzle is a classic example often employed to demonstrate the potential for some starting position configurations to yield unsolvable results (See Figure 1a and Figure 1b for illustration). A study in more depth of the 15-puzzle for a more general graph has previously been done, and its solvability has been understood [1], but it still needs a general rule, i.e. for face dimension k \u2265 1.\nInspired by the 15-puzzle, Alpert [2] examines square and hexagonal sliding puzzles in greater generality, to establish broader properties of their configuration spaces. Rold\u00e1n and Karpman [3] extend their examination to establish parity properties of hexagonal sliding puzzles, identifying a broader analogue of the parity property present in the configuration space of the 15-puzzle for the hexagonal case. Most recently, Rold\u00e1n et al. [4] establish a generalisation of the sliding puzzle to the cubical case, establishing strong conditions"}, {"title": "2 Game Setting", "content": "The higher-dimensional sliding puzzle we study in this work is built on a d-dimensional cube (Each node of the cube is a binary string of length d, and two nodes are connected if they differ by a single bit) where 2d - l randomly selected vertices are coloured (i.e., I vertices are uncoloured or have the same colour). Then, there are precisely 2d \u2013 I rings with the same colours initially set randomly on vertices. The 15-puzzle can be seen as a version of this game played on a (4 \u00d7 4)-grid. In that setting, rings block each other's movement simply by being in the way. However, topologically, this can be considered to represent the rule that movement is blocked when the 1-simplex where the ring would move over is occupied by another ring. The higher-dimensional puzzle setting is a generalisation of this puzzle's setup as the (d, k, l) scheme, where the puzzle"}, {"title": "3 Computational approaches to the higher-dimensional sliding puz- zle", "content": "We study in this work three computational approaches to the higher-dimensional sliding puzzle: the A* search, the RL and the EA. This section presents an overview of each technique and a general description of their corresponding algorithms."}, {"title": "3.1 A* search", "content": "The sliding puzzle is defined on a hypercube Qa, where each position of the rings leads to a unique game configuration. Both the target (T) and the starting (S) configurations are represented by a list of pairs (ring position and ring colour) of the same length (2d \u2013 1). The goal is to find the minimum number of moves to get to T, starting from S.\nAs with any puzzle seeking the shortest path between two points in the configuration space, slow, optimal methods exist that will surely return the shortest possible solution; perhaps the most well-known among"}, {"title": "3.2 Reinforcement learning (RL)", "content": "Similar to classical combinatorial problems such as TSP, applying the RL method to the higher-dimensional puzzle needs to be modeled as a sequential decision-making process, where the agent interacts with the environment by performing a sequence of actions to find a solution. The MDP provides a widely used mathematical framework for modeling this type of problem.\nDefinition 3. MDP can be defined as a tuple M = (Qd, A, R,T,r,s), where\n\u2022 Qd \u2013 state space Ct \u2208 Qd. State space for our higher-dimensional puzzle represents any valid game configuration, i.e., a configuration accessible through a k-rule;"}, {"title": "\u03c0* = arg max E\u03c0 [\u03a3t=0s r R(Ct, at)]", "content": "(2)"}, {"title": "3.3 Evolutionary algorithm (EA)", "content": "In general, an evolutionary search algorithm on any fitness landscape consists of three main parts, which in the context of games:\n\u2022 Initialisation: generating an initial population of game configurations, which consists of a population of starting configurations.\n\u2022 Evaluation and selection: evaluating a given configuration in the population consists of assigning a weight to a list of moves already performed by an individual. Then, a selection force is computed by combining in a linear fashion, the number of cumulative moves and the weight and selecting a weighted (the higher the selection force, the more significant the proportion in the sample) random sample with replacement from the current population of agents to generate a new population. A detailed description of the objective function used in this work is provided in the following sections.\n\u2022 Mutation (or move) operation defines a set of rules or steps used to produce new configurations from the selected or initial ones. This component is elaborated further in the following subsection.\nAn individual in our EA is an agent with the following properties:\n1. List of moves: an array that contains the different moves already performed by the agent\n2. Actual configuration: an array of (2d \u2212 1)-tuple containing the occupied vertices and the corresponding ring occupying the vertex.\n3. The hypercube Qa: the graph on which the puzzle is built.\nAn EA to solve this puzzle consists of evolving a population of agents that independently perform random moves on the hypercube to match all the rings to the appropriate vertex colour by minimising the number of moves. Two essential components must be defined to implement an EA on the higher-dimensional sliding puzzle: the fitness function or objective function and the mutation operator."}, {"title": "1/ 1 + L \u2013 h(C, T)", "content": "(3)"}, {"title": "L \u03a3i=1 \u03b4(Ci, Ti)", "content": "(4)"}, {"title": "\u03b4(Ci, Ti) ={1  if Ci \u2260 Ti 0  otherwise.", "content": ""}, {"title": "Sa(C,T, Am) = a fa+  1 1+ Am", "content": "(5)"}, {"title": "pi(A) =\u03a3Si i=1Si", "content": "(6)"}, {"title": "L c \u03a3k=11/kc", "content": ""}, {"title": "4 Experimental Results", "content": "Using the above methods, we computationally study the sliding game for dimensions d = 3, d = 4, and d = 5 for face dimensions 1 \u2264 k < d across different difficulty levels. This section provides a detailed analysis of the performances of each algorithm. We first surf through each method's individual performances, then present a comparative and CPU analysis."}, {"title": "4.1 Individual Performances", "content": "Depending on the initial position of the rings, the difficulty of solving the cubic puzzle can move from easy to very hard or impossible. For the puzzle of dimension 3, three difficulty levels out of the four reported in"}, {"title": "4.2 EA vs. RL Performances", "content": "Among the three algorithms benchmarked in the previous section, EA and RL techniques are\u00e5 both choose the next move with respect to some probability proportional to the total reward/fitness of the path after adding that configuration to the solution path. This leads to random solution outputs. It is, therefore, essential, when comparing the EA and RL performances, to analyse the distribution of the minimum number of moves produced by each algorithm.\nWhen only looking at the success rate, from Tables 4 and 5 we notice that the RL method successfully solves the puzzles for dimension d = 3,4 and d = 5 under different k-rules and across different difficulty levels. In contrast, the EA method failed to solve the puzzles of dimension 4 for the face dimension k = 3 with an overall success rate of less than 5% and one puzzle of dimension 5.\nFurthermore, we assessed the distributions of the number of moves produced by both methods for the puzzle of dimensions 3 and 4 for face dimension k = 2. Figure 4 shows the distributions of the number of moves for both EA and RL methods. We noticed a less significant gap between the median and the variance of the distribution of the number of moves produced by our EA method and that of the RL method (p-value = 0.12). For the puzzles of dimension d = 3 and face dimension k = 2, the EA distributions have medians 9,10, and 14, whereas RL distributions are 6, 7 and 10, which results in an average gap of 3 moves. Besides the median number of moves, the standard deviation of RL distributions is also lower than that of EA. The difference in the median number of moves is more significant, with a p-value of 0.03 when comparing the distribution data for the puzzle of dimension d = 4 and face dimension k = 2. When comparing both results to the solved puzzle by A* search, since the A* outputs the exact solution when it stops, we notice very similar performance in terms of the minimum number of moves found. For the puzzles of dimension 3, both methods, RL and EA, successfully solved the puzzle at least once with the minimum number of moves. The capacity of EA and RL to minimise the number of moves diminishes with the dimension increase and the difficulty levels, except for the face dimension k = 1. In most cases, when both methods fail to produce the minimum number of moves, their approximated minimum number of moves is equal except for the puzzles of face dimension k = 3, where EA fails to solve the puzzle. The principal advantage of the RL method over EA is when EA fails completely to produce an output, similar to the A* search."}, {"title": "4.3 CPU Time Analysis", "content": "Another aspect of our computational study is the time complexity of different algorithms evaluated in our work. This section provides a quick analysis of the A* search algorithm and a brief empirical comparison of the its running CPU time compared to the RL and EA algorithms."}, {"title": "A* Time Complexity", "content": "The computational complexity of A* search is known to derive from the branching factor of the underlying state space. That is, if the average branching factor of each searched state is b \u2208 N and the optimal solution is of length n, the complexity of A* search will be O(br) [36]. Hence, we show the following:\nProposition 1. The complexity of A* search on the cubical sliding puzzle with k-rule and optimal solution length n is at least O((2k \u2212 1)n)\nProof. From [4], it is known that with chosen k-rule for k, if a configuration can be branched from there are at least 2k \u2212 1 moves which can be made with any mobile vertex. Thus, the branching factor of each state is at least 2k \u2212 1. The conclusion follows from the complexity of A* search.\nFor example, we may conclude that the complexity of A* search for a face dimension k = 4 is at most O(7\") for optimal solution n. This is a worst-case complexity assumption since the difficulty level influences the search algorithm greatly, as our previous analysis pointed out. We further present in Figure 5 the empirical CPU time measurements for all the A* search solved puzzles we previously presented. We notice the CPU time depends not only on the face dimension (or k-rules) but also significantly on the puzzle difficulty levels. The CPU time increases with difficulty levels across puzzle dimensions d = 3 and d = 4 while staying generally consistent with the face dimension.\""}, {"title": "RL and EA CPU Time Analysis", "content": "Comparing CPU time between exact and heuristic algorithms is not straightforward since the latter does not ensure optimality. On the one hand, our RL implementation performance strongly depends on the number of iterations and the number of branching states, which also implies a strong dependency between the CPU time and these two parameters. On the other hand, our EA performance depends on the population size and"}, {"title": "5 Conclusion", "content": "In this work, we studied the performance of three computational methods, EA, RL, and A* search, on the higher-dimensional puzzle for dimensions d = 3, 4, and 5. The first part of our work was designing the algorithms and methods for the higher-dimensional sliding puzzle. The second part was benchmarking different approaches and providing a plausible analysis of each method's performance and CPU time.\nFor the sliding puzzle of dimension d = 3, all tools have proven excellent performance across different difficulty levels in minimising the number of moves except our EA method, especially for the face dimension k = 2. The distributions of the number of moves produced by our EA had higher variance, possibly because of the choice of the implemented mutation scheme. When comparing the CPU time for the overall solved puzzles, A* search and EA were faster in producing solutions than RL despite our EA being less efficient in minimising the number of moves.\nFor the puzzle of dimensions d = 4, on the one hand, the A* search method successfully finds the shortest path, i.e., the smallest consecutive number of configurations that lead to the target configuration, whereas"}]}