{"title": "Complete Implementation of WXF Chinese Chess Rules", "authors": ["Daniel Tan", "Neftali Watkinson Medina"], "abstract": "Unlike repetitions in Western Chess where all repetitions are draws, repetitions in Chinese Chess could result in a win, draw, or loss depending on the kind of repetition being made by both players. One of the biggest hurdles facing Chinese Chess application development is a proper system for judging games correctly. This paper introduces a complete algorithm for ruling the WXF rules correctly in all 110 example cases found in the WXF manual. We introduce several novel optimizations for speeding up the repetition handling without compromising the program correctness. This algorithm is usable in engines, and we saw a total increase in playing strength by +10 point rating increase, or an increased 5% winrate when integrating this approach into our prototype engine.", "sections": [{"title": "1 INTRODUCTION", "content": "Chinese Chess (or Xiangqi) is one of the most popular board games in Asian countries such as China and Vietnam [15]. Chinese Chess is an indispensable part of the daily lives of Chinese people. There are over one hundred Chinese idioms that have their roots in Chinese Chess [15]. Chinese Chess and Western Chess share many similarities. Both games are two player turn-based strategy games where the objective of the game is to checkmate the opponent's king using a set of pieces with varying kinds of movement. However, while in Western Chess having multiple repetitions can end in a draw, in Chinese Chess repetitions can result in a win, loss, or draw depending on how that repetition is performed. Judging the actual outcome of repetitions is a complex, nontrivial problem. In this paper, we implement and document an algorithm that completely covers all 110 example diagrams. Unlike other implementations that are missing several cases [12], we present an algorithm that correctly identifies each case correctly."}, {"title": "1.1 Overview of Chinese Chess Repetition Rules", "content": "A short overview of the repetition rules is that no player is allowed to either perpetually chase an unprotected opponent's piece or perpetually check the opponent's king. The player that performs a perpetual chase or a perpetual check loses the game. This is completely different than in Western Chess where a perpetual check is a draw and perpetual chases are close to nonexistent. Under all conditions, perpetual check in Chinese Chess results in a loss for the player constantly checking the opponent's king. If both players simultaneously perform perpetual checks, then the game will result in a draw. If both players simultaneously perform perpetual chases, then the game will result in a draw. If neither player is doing a perpetual check nor a perpetual chase, then the game is ruled a draw. Figures 1, 2, and 3 provide an example of perpetual check, perpetual chase, and both players simultaneously performing perpetual check, respectively.\nMost Chinese Chess players, from casual enthusiasts to top grandmasters, have an intuitive grasp of the repetition rules, but do not fully understand all the repetition rules [12]. The whole set of rules to determine who wins, draws or loses is complex. This is even more complex if both players are engaging in a chase or if multiple pieces are chasing multiple pieces. If a tournament game runs into a dispute, a special qualified referee is called to resolve the dispute. If a referee determines that a player is performing a losing repetition, the referee will warn the losing side to change moves or lose the match.\nThere are two main versions of the official Chinese Chess repetition rules used in tournament play: the WXF rules (World Xiangqi Federation Rules) [21] and the CXA rules (Chinese Xiangqi Association Rules) [3]. The WXF rules are used for international competitions between different countries, while the CXA rules are used in Mainland China. The CXA rules are complicated, subjective, and contradictory [23], but games using these rules are less likely to end with a draw. The WXF rules lead to more draws, but are more straightforward and consistent. This paper focuses on WXF rules because CXA rules are too subjective and WXF is the standard for Chinese Chess engine play and international competitions between different countries.\nThe official WXF rules [21] are summarized in 4 pages (WXF manual 35-39), with around 110 example diagrams with paragraphs of explanations for each diagram spanning 59 pages (WXF manual 40-99). Given that the WXF manual is 116 pages long, over two thirds of the manual is dedicated to outcomes for repetitions. In this paper, we implement and document an algorithm that completely covers all 110 example diagrams. Unlike other implementations that are missing several cases [12], we present an algorithm that correctly identifies each case correctly. When we integrated this"}, {"title": "1.2 Motivation", "content": "Due to the sheer complexity of the rules, Chinese Chess programmers put more emphasis on evaluating millions of nodes as fast as possible rather than rule correctness [12]. Heuristics are used to estimate repetitive chasing accurately for a majority of judgement calls. Errors in heuristics can be compensated by having a good minimax search and/or better handcrafted evaluation heuristics.\nDespite this, a complete implementation is still important. For example, Chinese Chess websites and software would benefit from a complete implementation of the rules since it is impossible to get a human referee to oversee all possible online or virtual games. People playing online should not be able to swindle a victory or a draw by exploiting losing repetition moves that the software is not able to detect. If even a few example cases are wrong, it could lead to many thousands of games ruled incorrectly and even threaten the program's stability.\nTo illustrate this point, consider diagram 34 (figure 4) from the WXF manual [21]. Black is attempting to checkmate red by moving the cannon to the bottom rank, while red attempts to block the black cannon using the red rook. Black moves back and forth, perpetually threatening checkmate, while red perpetually threatens the unprotected black cannon. The black perpetual kill is allowed, while the red perpetual chase results in a loss for red. If red breaks the repetition, he will end up getting checkmated by the black cannon. But if red continues to perform the repetition, he will lose due to the per- petual chase rule. Either way, red has lost. These situations are not just hypothetical; grandmaster strategy often involves forcing opponents into critical situations similar to this to either force a significant loss of material or deliver a checkmate [22]. Different software implementations have varying degrees of support for the rules. Many popular Chinese Chess software applications [14] fail to support cases such as this, but others such as [6], [12], and [13] handle this case correctly."}, {"title": "2 BACKGROUND", "content": "Therefore, one of the biggest hurdles facing Chinese Chess application development is a proper system for judging games correctly. In the most popular Chinese Chess application Tiantian Xiangqi, repetitions are not handled in the software at all, and most of the time, it rules repetitions incorrectly as draws [14]. Most repetition handling in the most popular Chinese Chess applications are completely broken.\nAnother motivating factor is that with the introduction of techniques such as NNUE: Efficiently updatable neural networks [10], handcrafted evaluation functions are being replaced with more dynamic neural network evaluation functions that play in a more human like way. NNUE, unlike handcrafted evaluation, has millions of parameters all tuned automatically using stochastic gradient descent. A handcrafted evaluation may have only several hundred parameters that can be easily hand-tuned by a programmer, but a neural network with millions of parameters is impossible to tune by hand. From our observations during NNUE training, the model exaggerated the errors created by the heuristics, led to poor decision making, and resulted in a decrease in playing strength.\nAnd finally, a complete implementation is necessary for Alpha-Zero [16] like engines using Monte Carlo Tree Search, where an engine learns the game from scratch without any human intervention. When one is building a self-learning Chinese Chess engine starting from zero knowledge, it is necessary to be able to evaluate all positions accurately to get the correct win/draw/loss ratio for Monte Carlo Tree Search to function correctly."}, {"title": "3 DEFINITIONS", "content": "Due to the technical nature of this paper, we want to establish some clear terminology and how we define words. Since we implement WXF rules [22], we borrow heavily from their terminology. For the sake of clarity, we provide the following definitions:\nattacker - The piece that is performing an attack on another piece. If a rook attacks an unprotected cannon, for example, the rook is the attacker.\ncapture move - a move that captures a piece\ncheck - a condition that occurs when a player's king is under attack\nchase a move that threatens to capture a piece other than the king in the next move.\nexchange - a move that trades a piece with an opponent's piece (e.g. trading rook for rook).\nidle\na move that is not a check or chase. We are using the term 'idle' slightly different than the WXF manual [22] terminology. While the WXF manual makes a distinction between terminologies such as 'kill', 'block', 'offer', 'idle', etc.,"}, {"title": "4 IMPLEMENTATION DETAILS", "content": "In this portion of the paper, we will explain in detail how the repetition rules work, how we interpret and frame the problem, and how that framing influences the design of our algorithm.\nThere are four main parts of the algorithm: generating captures on unprotected pieces, evaluating whether a particular capture is a chase, determining the violation level of a single player, and a function that returns whether the position has no repetitions, is a winning/losing repetition relative to the side, or a draw. There are a few basic fundamental functions and data structures we will also explain in detail."}, {"title": "4.1 Data Structures Problem Representation", "content": "In our Chinese Chess position data structure, we create a position history data structure for storing position hashes of previous positions, the previous moves, a position status enum that could be either a chase, check, or idle, and a set of chased pieces. We compute position hashes using techniques described in [26]. When determining if the position is repeating, we traverse backward from the current position examining previous position hashes, and if the hash value of the position matches the hash value of a previous board position found in the position history data structure, then it is considered a repetition. If there is a chase, we track the set of consistently chased pieces to detect whether a perpetual chase is happening or not. The algorithm uses a bitwise or on all previous board position status, and enums (enumerators) to determine whether all positions are checking, chasing, idling, or some hybrid of both."}, {"title": "4.2 Protected Pieces", "content": "The `is_protected` function determines whether a piece is attacking an unprotected piece. The implementation of `is_protected` matches the definition found in the WXF manual [22], which is if at least one defender can recapture the piece in the next move legally, then return true. If no defenders can come to the defense of the piece, then return false. If a less valuable piece is attacking a more valuable piece (e.g. cannon attacks rook, knight attacks rook), then `is_protected` returns false, since it is almost always advantageous to exchange a less valuable piece for a more valuable"}, {"title": "Algorithm 1 Data Structures", "content": ""}, {"title": "Algorithm 2 is_protected", "content": ""}, {"title": "Algorithm 3 get_defenders", "content": "blocking and chasing. (figures 5,6, and 7).\nThe get_defenders subfunction used within the `is_protected` function iterates through all possible defending pieces, and if a defender is found, returns a move that defends the piece with a recapture. The cannon and rook defending a piece is determined from the position and pieces occupied in the current position in consideration rather than the subsequent move that affects how protection works."}, {"title": "4.3 Generating Captures on Unprotected Pieces", "content": "When generating captures on unprotected pieces, we generate all pseudo-legal capture moves of the opposing side. We then filter out all illegal moves and captures on protected pieces.\nThere are many exceptions to attacks on unprotected pieces. If a lone king or pawn chases a piece, the game will be ruled as a draw. Exchange (e.g. trading rook for rook) moves should be ruled as a draw. If one side can legally capture the piece but the other side cannot legally capture the piece back, then it is considered a chase rather than an exchange. Pawns remaining on their side of the board that did not cross the river to the opponent's side cannot be chased."}, {"title": "4.4 Detecting a Chase", "content": "If a check, capture move, or forward pawn move is detected, then we do not compute any chase information. Moves that result in a check are not chase moves since one is checking the king. Capture moves are irreversible moves that"}, {"title": "Algorithm 4 gen_captures", "content": ""}, {"title": "Algorithm 5 get_chases", "content": ""}, {"title": "Algorithm 6 detect_block", "content": "If a given position is in check, the position hash is labeled as a Check position. If a given position has been reached from a capture or pawn advance, its position hash is labeled a Cancel. Cancel is used to break from the loop early if an irreversible move is detected. If a position does not involve chasing, it is labeled Idle. If the position has a chase, it is labeled Chase.\nAfter generating captures on unprotected pieces, the algorithm determines whether the capture move is considered a chase. During a chase, the piece must be unprotected on one turn, and the next move responds to the threat by protecting the piece directly. If the opponent does not block or evade the chase and the piece can be taken for free, then it cannot be considered a chase, since the opponent did not respond to the chase (see WXF diagram 10, figure 8) [21]. An opponent may decide to counter-attack the chase by threatening a mating attack, sacrificing a piece, threatening to capture an opponent's piece, or accidentally giving up the piece for free. When these situations occur, the position should not be classified as a chase. Multiple pieces could be chased at the same time (highly unlikely in a normal game, but possible). If at least one piece is being chased, we mark the position as being chased.\nAccording to WXF rules [22], if multiple pieces are being chased by one or more pieces in a repetition, then it is ruled as a draw. If a single piece is being chased by one or more pieces in a repetition, it is considered a perpetual chase. It does not matter how many attackers are attacking a single piece. In this algorithm, we ignore the number of attackers and only focus on the set of chased victim pieces."}, {"title": "4.5 Detecting Repetition of a Player", "content": "After labeling each position's hash and computing a set of pieces being chased, for every new position encountered that we want to check for a repetition, we iterate over the previous position hashes of the position hash history to check if there is a repetition for only a single player. If no repetition exists, this function returns undecided. If there is a repetition, this function attempts to classify the repetition violation level for a single player as either a perpetual check, perpetual chase, or perpetual idle. We have identified that all 16 different WXF repetition conditions fall into at least one of these 3 classes:\n\u2022 The perpetual check is a repetition where the player performs a perpetual check only, without ever breaking off the check. Doing at least one check followed by at least one block or chase is not a perpetual check, but rather a perpetual idle.\n\u2022 The perpetual chase is a repetition where a player performs a perpetual chase on a single unprotected piece other than a king. Any multiple attacking pieces can chase a single victim piece in this software implementation. If multiple victim pieces are being chased, it is not considered a chase, but rather a perpetual idle.\n\u2022 The perpetual idle covers all other cases that are not perpetual checks or perpetual chases. Perpetual exchanges, offers, kills (threatening to checkmate the opponent), alternating between a check and kill, perpetually chasing two or more pieces, and alternating between a chase and check repetitions also fall into this category."}, {"title": "Algorithm 7 judge_player", "content": ""}, {"title": "4.6 Judging A Chinese Chess Repetition", "content": "In the main judge function, we take in as input a list of position hashes alongside a list of a set of chase victims for position hash. The judge function outputs a game result: undecided, win, loss, or draw relative to the player's turn. For example, if the function returns a win, it means the player whose turn it is won the game."}, {"title": "Algorithm 8 judge_ntimes", "content": ""}, {"title": "4.7 Testing The Repetition Rules", "content": "We tested and verified that all repetition rules worked correctly by setting up positions found in the example diagrams, making the repetition sequences detailed in the example diagrams, and checking that the result of the main judge function matched the result described in the diagrams. We created 173 test cases using the 110 diagrams to test the win/draw/loss repetition sequences that could arise from each position.\nWhen integrating the repetition rules into the engine, we tested the engine to ensure that it handles repetitions properly by observing whether it handles the positions. In several of the WXF diagrams, there is a discrete checkmate solution and an optimal way to win the game based on the WXF repetition rules (see figure 4). In the diagrams with an optimal solution, we tested whether the engine could find the checkmate solution while handling repetitions correctly."}, {"title": "5 OPTIMIZATIONS ON THE REPETITION RULES IN AN ALPHA BETA NEGAMAX ENGINE", "content": "The full implementation of chasing rules can be slow, and we utilize several techniques to speed up the repetition handling within the engine. These optimizations do not compromise the correctness of the engine."}, {"title": "5.1 Staged Evaluation of Chasing Moves", "content": "Alpha beta negamax chess engines rely heavily on good move ordering to prune the search tree aggressively and achieve higher depth. To briefly summarize the way a typical chess engine does move ordering, board moves are ordering with the principle variation best move first (there are many vast different kinds of implementations of this [11]), followed by capture moves, and last of all quiet moves. The vast majority of the time, a quiet move is refuted by a capture move since the majority of move sequences involve a piece moving into the attack range of an opponent's piece and losing that piece for free in the next turn.\nTo illustrate the importance of giving capture moves higher priority in alpha beta negamax, one can compare the negamax performance debug logs of a didactic engine [20] without capture move ordering with one with a basic MVV-LVA (most valuable victim, least valuable attacker) capture move ordering heuristic.\ninfo score cp 25 depth 1 seldepth 5 time 878 nodes 5161544\ninfo score cp 25 depth 2 seldepth 5 time 6429 nodes 38369245\ninfo score cp 20 depth 3 seldepth 5 time 121942 nodes 722743000\nWithout MVV-LVA move ordering heuristic, the didactic Rustic Chess engine can only complete a depth of 3 over the course of 2 minutes. A lot of time is spent searching a negamax tree with a large branching factor.\ninfo score cp 25 depth 1 seldepth 3 time 0 nodes 1598\ninfo score cp 25 depth 2 seldepth 3 time 1 nodes 3196\ninfo score cp 20 depth 3 seldepth 5 time 2 nodes 7315\ninfo score cp 20 depth 4 seldepth 5 time 6 nodes 20260"}, {"title": "info score cp 5 depth 5 seldepth 9 time 25 nodes 76603", "content": "info score cp 20 depth 6 seldepth 7 time 109 nodes 293985\ninfo score cp 5 depth 7 seldepth 9 time 543 nodes 1333835\ninfo score cp 5 depth 8 seldepth 9 time 2900 nodes 7288058\ninfo score cp -40 depth 9 seldepth 11 time 16933 nodes 39339223\nWith MVV-LVA move ordering heuristic, the didactic Rustic Chess engine can complete a depth of 9 over the course of 2 minutes. This is a significant improvement from depth of 3 to a depth of 9, with many nodes being pruned quickly within the first 2-4 moves instead of searching through a negamax tree with a large branching factor. The engine can search much deeper and dramatically save millions of nodes just using MVV-LVA alone [20].\nMost engines use a staged move generation [17] that generates capture moves first, and delays generation of quiet moves until it is determined that the position is not refuted by a capture move beta cutoff. Because most nodes are refuted by the first few capture moves without ever searching quiet moves, the program can avoid generating all 35-45 different possible quiet moves if a beta cutoff occurs.\nGiven that captures are usually given priority and cannot cause a repetition, we can delay computing chasing informa- tion of a position until the first quiet move is being evaluated. Since most nodes are pruned by a capture move on an unprotected piece, we can prune many negamax subtrees without computing chasing information. Since we compute chasing information during quiet moves, the program maintains its correctness. Algorithm 9 provides psuedo-code for how repetitions are evaluated within negamax."}, {"title": "5.2 Judge Beta Cutoff", "content": "In an alpha-beta negamax search, if an evaluation is greater than or equal to the beta value, then the search stops and prunes the tree. A good search depth is essential for being able to look deeply into a position and avoid a horizon effect, and getting an earlier beta cutoff is important for searching as deep as possible.\nIn an alpha beta search, we are either looking for the optimal evaluation score for a position, or an evaluation score that is equal to or exceeds the beta cutoff value. If the draw score is equal to or exceeds the beta cutoff, just getting a draw score is good enough for accuracy. Algorithm 10 provides a pseudo-code description of how this works.\nIf a player is doing a perpetual idle in their turn, then we know that the player cannot lose, and the best that the player can get is either a win or a draw. If a draw is greater or equal to the beta cutoff, then we do not need to perform a check of the opponent's repetitions, but rather only a simpler check if the opponent is repeating moves. This saves us from a considerable amount of computation. In the condition described, we could skip 50% of the computation."}, {"title": "6 RESULTS", "content": ""}, {"title": "6.1 Summary of Implementation Details of Engine", "content": "Our prototype engine is a relatively powerful neural network negamax engine. Playing strength is expected to improve after training and learning from more games. The engine utilizes many complicated search techniques such as principle"}, {"title": "Algorithm 9 negamax", "content": ""}, {"title": "Algorithm 10 judge_prune", "content": ""}, {"title": "6.2 Playing Style and Strength of Engine", "content": "In terms of general playing style, integrating the complete implementation of Chinese Chess repetition rules into our engine caused the engine to attack opponents more aggressively and accurately rather than playing passively and de- fensively. Previously, the engine threw away critical attacking maneuvers because it was unsure about how to deal with repetitions. With the proper repetition rules implemented, it can understand how to take full advantage of the repetition"}]}