{"title": "Solving Multiagent Path Finding on Highly Centralized Networks", "authors": ["Foivos Fioravantes", "Du\u0161an Knop", "Jan Maty\u00e1\u0161 K\u0159i\u0161\u0165an", "Nikolaos Melissinos", "Michal Opler", "Tung Anh Vu"], "abstract": "The MUTLIAGENT Path FINDING (MAPF) problem consists of identifying the trajectories that a set of agents should follow inside a given network in order to reach their desired destinations as soon as possible, but without colliding with each other. We aim to minimize the maximum time any agent takes to reach their goal, ensuring optimal path length. In this work, we complement a recent thread of results that aim to systematically study the algorithmic behavior of this problem, through the parameterized complexity point of view.\nFirst, we show that MAPF is NP-hard when the given network has a star-like topology (bounded vertex cover number) or is a tree with 11 leaves. Both of these results fill important gaps in our understanding of the tractability of this problem that were left untreated in the recent work of [Fioravantes et al. Exact Algorithms and Lowerbounds for Multiagent Path Finding: Power of Treelike Topology. AAAI'24]. Nevertheless, our main contribution is an exact algorithm that scales well as the input grows (FPT) when the topology of the given network is highly centralized (bounded distance to clique). This parameter is significant as it mirrors real-world networks. In such environments, a bunch of central hubs (e.g., processing areas) are connected to only few peripheral nodes.", "sections": [{"title": "Introduction", "content": "Collision avoidance and optimal navigation are crucial in scenarios that require a group of agents to move through a network in an autonomous way. The real-world applications for such problems are well documented and range from virtual agents moving through a video game level (Snape et al. 2012), to actual robots transporting goods around a warehouse (Wurman, D'Andrea, and Mountz 2008; Li et al. 2021). Agents can be required to move through simpler topologies that span multiple \"floors\" (Veloso et al. 2015), or much more complicated topologies on a single \"floor\", e.g., in Airport surface management (Morris et al. 2016).\nMany different models have been proposed to capture and solve the scenarios described above (Stern et al. 2019). This is due in part to the ubiquity of these scenarios, but also to the variety of slightly different requirements that each real-world application demands. For example, there are models where a set of positions must be reached, regardless of which"}, {"title": "Our Contribution", "content": "The first two parameters that one would hope could be exploited are the number of agents $k$ and the makespan $l$, i.e.,"}, {"title": "Theorem 1.", "content": "MULTIAGENT PATH FINDING remains NP-hard on trees with nine internal vertices and vertex cover number 7.\nWe stress here that the above result is based on the tree having many leaves. In fact, if a tree has few internal vertices and leaves, the entire instance is bounded in size, and finding a solution cannot be intractable. Therefore, we ask the following question: What if the tree has only a few leaves? A generalization of this is captured by the parameter known as the max leaf number: the maximum number of leaves a spanning tree of a graph can have. Note that the max leaf number is a parameter that limits the structure of the input in a rather drastic way-the graph is essentially a subdivided tree with few edges (consequently, few internal vertices and leaves). Graphs admitting this structure appear quite often as transportation networks, in particular, underground trains (Eppstein 2015). Indeed, many problems are tractable with respect to the max leaf number (see, e.g., (Fellows et al. 2009)); a notable exception is the GRAPH MOTIF problem (Bonnet and Sikora 2017). Here, we obtain yet another intractability result for this parameter."}, {"title": "Theorem 2.", "content": "MULTIAGENT PATH FINDING remains NP-hard on trees with 11 leaves."}, {"title": "Theorem 3.", "content": "COLORED MAPF remains NP-hard even if there are only 6 groups of agents and G is a tree with 11 leaves."}, {"title": "Theorem 4.", "content": "MULTIAGENT PATH FINDING is in FPT parameterized by the distance to clique."}, {"title": "Preliminaries", "content": "We follow standard graph-theoretic notation (Diestel 2012).\nFor $a, b \\in \\mathbb{N}$, let $[a, b] = \\{c\\in \\mathbb{Z} \\mid a \\leq c \\leq b\\}$ and $[a] = [1, a]$. Let $G = (V, E)$ be a graph. For a subset of vertices $U \\subseteq V$ and a vertex $u \\in V$ we denote by $N_U(u)$ the set of vertices of $U$ that are adjacent to $u$. By $N_U[u]$ we mean $N_U(u) \\cup \\{u\\}$. As a short-hand, we write $N_G = N_{V(G)}$. When clear from the context, the subscripts will be omitted. Finally, for any $S \\subseteq V$, let $G[S]$ be the subgraph of $G$ that is induced by $S$, i.e., the graph that remains after deleting the vertices of $V \\setminus S$ from $G$ (along with their incident edges). For an $m$-dimensional integer vector $\\tilde{u} \\in \\mathbb{N}^m$, we write $\\|\\tilde{u}\\|_p = (\\Sigma_{i=1}^m u_i)^{1/p}$, i.e. its $\\ell_p$-norm. By default, $\\| \\cdot \\|$ denotes the $\\ell_1$-norm. For a function $f\\colon A \\to B$ and $C \\subseteq A$ we write $f(C) = \\{f(c) \\mid c \\in C\\}$.\nFormally, the input of the MULTIAGENT PATH FINDING (MAPF) problem consists of a graph $G = (V, E)$, a set of agents $A$, two functions $s_0\\colon A \\to V$ and $t\\colon A \\to V$ and a positive integer $l$. For any pair $a, b \\in A$ where $a \\neq b$, we have that $s_0(a) \\neq s_0(b)$ and $t(a) \\neq t(b)$. Initially, each agent $a \\in A$ is placed on the vertex $s_0(a)$. At specific times, called turns or rounds (we will use both interchangeably), the agents are allowed to move to a neighboring vertex, but are not obliged to do so. The agents can make at most one move per turn and each vertex can host at most one agent at a given turn. The position of the agents in the end of turn $i$ (after the agents have moved) is given by an injective function $s_i\\colon A\\to V$.\nWe say that a schedule $s_1, \\dots, s_m$ is a feasible solution of an instance $I = (G, A, s_0, t, l)$ of MAPF if:\n1. $s_i(a) \\in N[s_{i-1}(a)]$ for all $a \\in A$ and every $i \\in [m]$,"}, {"title": "2.", "content": "$s_i(a) \\neq s_i(b)$ for all $i \\in [m]$ and $a \\neq b \\in A$, and"}, {"title": "3.", "content": "$s_m = t$.\nA feasible solution $s_1, \\dots, s_m$ has makespan $m$. A feasible solution of minimum makespan will be called optimum. Our goal is to decide if there exists a feasible solution of makespan $m \\leq l$.\nIt is worth mentioning here that there are two principal variations of MAPF. The first, more \u201cgenerous\" version, allows the agents to share edges if the wish to do so. For example, in this version, two agents $a$ and $b$ such that $s_i(a) = u, s_i(b) = v$, are allowed to move so that $s_{i+1}(a) = v, s_{i+1}(b) = u$, even if $u$ and $v$ are connected through a unique edge. The second, more \"restrictive\", version does not allow this behaviour. In this work we focus on the restrictive version."}, {"title": "Parameterized Complexity", "content": "Parameterized complexity is a field in algorithm design that takes into consideration additional measures to determine the time complexity. In some sense, it is about the multidimensional analysis of the time complexity of an algorithm, each dimension being dedicated to its own parameter. Formally, a parameterized problem is a set of instances $(x,k) \\in \\Sigma^* \\times \\mathbb{N}$; $k$ is referred to as the parameter. The goal in this paradigm is to design Fixed-Parameter Tractable (FPT) algorithms, i.e., an algorithm that solves the problem $f(k)|x|^{O(1)}$ time for any arbitrary computable function $f\\colon \\mathbb{N} \\to \\mathbb{N}$. We say that a problem is in FPT if it admits an FPT algorithm. We refer the interested reader to classical monographs (Cygan et al. 2015; Downey and Fellows 2012) for a more comprehensive introduction to this topic."}, {"title": "Structural Parameters", "content": "There are three structural parameters that we consider in this work. Let $G = (V, E)$ be a graph.\nFirst we have the vertex cover number of $G$. A set $S \\subseteq V$ is called a vertex cover of $G$ if for every edge $uv \\in E$ we have that either $u \\in S$ or $v \\in S$ (or both). The vertex cover number of $G$ is the size of a minimum vertex cover of $G$. This is a parameter that can be computed in FPT time, e.g., by (Chen, Kanj, and Xia 2006).\nNext, we will consider the distance to clique of $G$. This is defined as the size of a minimum set $S \\subseteq V$ such that $G[V \\setminus S]$ is a clique (a graph where each vertex is adjacent to all other vertices of the graph). The distance to clique of $G$ can be computed in FPT time by computing the vertex cover number of the complement of $G$. Recall that the complement of a graph $G$ is the graph $G' = (V, E')$, where $uv \\in E'$ if and only if $uv \\notin E$.\nFinally, the max leaf number of $G$ is defined as the maximum number of leaves (i.e., vertices with only one neighbor) in a spanning tree of $G$. Recall that $T$ is a spanning tree of $G$ if the vertex set of $T$ is the same as $G$ and $T$ contains no cycles. The max leaf number of a given graph can also be computed in FPT time (Fellows and Langston 1992)."}, {"title": "Efficient Algorithm for Centralized Networks", "content": "In this section we prove the main positive result of this paper. First, we prove that the MULTIAGENT PATH FINDING problem can be solved in polynomial time on cliques; this will be necessary later on.\nThroughout this section, there is a notion of swap that is going to play a very important role. A swap is the behavior that happens when two neighboring agents have to exchange positions in one turn according to the schedule. Formally, let $\\alpha, \\beta$ be two agents and $s, s'$ be two placements of agents. We say that $\\alpha, \\beta$ are swapping between $s$ and $s'$ (alternatively swapping in $s, s'$) if $s'(\\alpha) = u = s(\\beta)$ and $s'(\\beta) = v = s(\\alpha)$; observe that this can only happen if $uv \\in E(G')$. Such a behavior is not allowed in the version of MULTIAGENT PATH FINDING that we consider. Additionally, given a potential solution $s_1 \\dots s_m$, we will say that a swap is happening in turn $i$ if there exits a pair of agents that are swapping between the placements $s_{i-1}$ and $s_i$.\nTheorem 5. Let $I = (G, A, s_0, t,l)$ be an instance of MULTIAGENT PATH FINDING and $G = (V, E)$ be a clique. We can decide if $I$ is a yes-instance in polynomial time. Additionally, if $l \\geq 2$ and $V(G) \\geq 4$ then $I$ is always a yes-instance."}, {"title": "Proof.", "content": "Clearly, if $|V| < 4$ we can compute an optimal solution of $I$ in polynomial time. Therefore, we can decide if $I$ is a yes-instance in polynomial time. Therefore, we may assume that $|V| \\geq 4$.\nFirst, we check if there exists a feasible solution of makespan 1. For every $i \\in [l - 1]$, we define a swapping pair of agents to be any pair of two agents $\\alpha, \\beta \\in A$, with $\\alpha \\neq \\beta$, such that $s_0(\\alpha) = t(\\beta)$ and $s_0(\\beta) = t(\\alpha)$. It is easy to see that $I$ accepts a feasibly solution of makespan 1 if and only if there exists no swapping pair. If such a pair does not exists, then $s_1 = t$ is a feasible solution of makespan 1. Otherwise, there is no feasible solution of makespan 1.\nNext, we focus on the case where there is no feasible solution of makespan 1. Let $p > 1$ be the number of swapping pairs that exist and let $(\\alpha_i, \\beta_i), i \\in [p]$, be these pairs. We consider two cases, according to whether $p > 2$ or not."}, {"title": "Case 1.", "content": "($p \\geq 2$): Here, we can compute a feasible solution of makespan 2 as follows.\n*   For all $i \\in [p - 1]$, we set $s_1(\\alpha_i) = s_0(\\alpha_i)$,\n*   for all $i \\in [p - 1]$ we set $s_1(\\beta_i) = s_0(\\beta_{i+1})$,\n*   we set $s_1(\\alpha_p) = s_0(\\beta_1)$,\n*   we set $s_1(\\beta_p) = s_0(\\alpha_p)$ and\n*   for every other agent $a \\in A$, we set $s_1(a) = s_0(a)$.\nThen, for every agent $a \\in A$, we set $s_2(a) = t(a)$. The schedule $s_1, s_2$ is a feasible solution of $I$ which contains no swapping pairs. Indeed, the positions of $s_1$ are achieved by having $i + 1 \\geq 3$ agents moving in a cycle."}, {"title": "Case 2.", "content": "($p = 1$): If $|V| > |A|$, then there exists at least one vertex $v \\neq s_0(a)$, for all $\\alpha \\in A$. We set $s_1(0_1) = v$ and $s_1(a) = s_0(a)$ for all $a \\in A \\setminus \\{0_1\\}$. Then $s_1, s_2$, where $s_2(a) = t(a)$ for all $a \\in A$, is a feasible solution which does not contain any swapping pair."}, {"title": "Therefore,", "content": "we may assume that $|V| = |A|$. Since $|V| \\geq 4$, there exist at least two agents in $A \\setminus \\{\\alpha_1, \\beta_1\\}$. We select a pair of agents $\\alpha_0, \\beta_0$ such that, either $s_0(\\alpha_0) = t(\\alpha_0)$ and $s_0(\\beta_0) = t(\\beta_0)$, or $s_0(\\alpha_0) \\neq t(\\alpha_0)$ and $s_0(\\beta_0) \\neq t(\\beta_0)$. Notice that such a pair $(\\alpha, \\beta)$ always exists. We deal with each case of the $\\alpha_0$ and $\\beta_0$ pair separately."}, {"title": "Case 2 (a).", "content": "($s_0(\\alpha_0) = t(\\alpha_0)$ and $s_0(\\beta_0) = t(\\beta_0)$): Consider the following schedule:\n*   $s_1(\\alpha_1) = s_0(\\alpha_0), s_1(\\alpha_0) = s_0(\\beta_0)$ and $s_1(\\beta_0) = s_0(\\alpha_1)$.\n*   For all $a \\in A \\setminus \\{\\alpha_0, \\alpha_1, \\beta_0\\}$, we set $s_1(a) = s_0(a)$.\nWe claim that $s_1, s_2$, where $s_2(a) = t(a)$ for all $a \\in A$, is a feasible solution which does not contain any swapping pair. Since we are in a clique we just need to prove that there are no swaps between $s_1$ and $s_2$.\nAssume that we have a swapping pair $\\alpha, \\beta$ and that the swap happens between $s_0$ and $s_1$. Notice that, $\\alpha, \\beta \\notin \\{\\alpha_0, \\alpha_1, \\beta_0\\}$. Indeed, if $a \\in A \\setminus \\{\\alpha_0, \\alpha_1, \\beta_0\\}$, then $s_1(a) = s_0(a) \\neq s_0(\\beta)$, for any $\\beta \\in A$; therefore there is no swap. Also, if $\\alpha, \\beta \\in \\{\\alpha_0, \\alpha_1, \\beta_0\\}$, then again there is no swap by the construction of $s_1$. Indeed, the agents $\\alpha_0, \\alpha_1, \\beta_0$ are moving in a cycle of length 3.\nNext, assume we have a swapping pair $\\alpha, \\beta$ and that the swap happens between $s_1$ and $s_2$. Recall that we have assumed that we have exactly one pair of swapping agents, the pair $\\alpha_1, \\beta_1$."}, {"title": "Claim 1.", "content": "$\\alpha, \\beta \\notin \\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\}$\nProof of the claim. Assume that $a \\notin \\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\}$. By the selection of $\\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\}$, it follows that $t(a) \\notin s_0(\\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\}) = s_1(\\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\})$. Since we have assumed that $\\alpha$ and $\\beta$ are a swapping pair, we have that $\\beta \\notin \\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\}$, as $s_1(\\beta) = t(a) \\notin s_1(\\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\})$. It follows by the construction of $s_1$ that $s_1(a) = s_0(a)$ and $s_1(\\beta) = s_0(\\beta)$. Therefore, $\\alpha$ and $\\beta$ are swapping between $s_1$ and $s_2$ if and only if they are swapping between $s_0$ and $t$ (as $s_2 = t$). This is a contradiction as only the pair $(\\alpha_1, \\beta_1)$ is swapping between $s_0$ and $t$.   $\\diamond$\nWe proceed with $\\alpha, \\beta \\in \\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\}$. By the selection of $\\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\}$, we have that $t(\\alpha_0) = s_0(\\alpha_0), t(\\beta_0) = s_0(\\beta_0), t(x_1) = s_0(\\beta_1)$ and $t(\\beta_1) = s_0(\\alpha_1)$. Also, by the construction of $s_1$, we have that $s_1(\\beta_1) = s_0(\\beta_1), s_1(\\alpha_1) = s_0(\\alpha_0), s_1(\\alpha_0) = s_0(\\beta_0)$ and $s_1(\\beta_0) = s_0(\\alpha_1)$. Therefore, the agents are moving in a cycle of length 4."}, {"title": "Case 2 (b).", "content": "($s_0(\\alpha_0) \\neq t(\\alpha_0)$ and $s_0(\\beta_0) \\neq t(\\beta_0)$): In this case we have that at least one of the following is true: $t(\\alpha_0) \\neq s_0(\\beta_0)$ or $t(\\beta_0) \\neq s_0(\\alpha_0)$. Indeed, if both are true, there exists a second swapping pair, contradicting that $p = 1$. W.l.o.g., assume that $t(\\alpha_0) \\neq s_0(\\beta_0)$. Consider the following schedule:\n*   $s_1(\\alpha_1) = s_0(\\alpha_0), s_1(\\beta_1) = s_0(\\alpha_1)$ and $s_1(\\alpha_0) = s_0(\\beta_1)$.\n*   For all $a \\in A \\setminus \\{\\alpha_0, \\alpha_1, \\beta_1\\}$ we are setting $s_1(a) = s_0(a)$."}, {"title": "contain any swapping pair.", "content": "Since we are in a clique we just need to prove that there are no swaps between $s_1$ and $s_2$.\nAssume that two agents $\\alpha, \\beta$ are a swapping pair and that the swap happens between $s_0$ and $s_1$. Notice that $\\alpha, \\beta \\notin \\{\\alpha_0, \\alpha_1, \\beta_1\\}$. Indeed, if $a \\in A \\setminus \\{\\alpha_0, \\alpha_1, \\beta_1\\}$, then $s_1(a) = s_0(a) \\neq s_0(\\beta)$, for any $\\beta \\in A$; therefore there is no swap. Since $\\alpha, \\beta \\in \\{\\alpha_0, \\alpha_1, \\beta_1\\}$, then again there is no swap by construction of $s_1$. Indeed, the agents $\\alpha_0, \\alpha_1, \\beta_1$ are moving in a cycle of length 3.\nNext, we consider the case where $\\alpha, \\beta$ are swapping between $s_1$ and $s_2$. Recall that $s_1(\\{\\alpha_0, \\alpha_1, \\beta_1\\}) = s_0(\\{\\alpha_0, \\alpha_1, \\beta_1\\})$ and $s_1(\\gamma) = s_0(\\gamma)$, for all $\\gamma \\notin \\{\\alpha_0, \\alpha_1, \\beta_1\\}$. We will prove that if both $\\alpha$ and $\\beta$ do not belong in $\\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\}$, then $\\alpha$ and $\\beta$ are not swapping. Indeed, since $s_1(a) = s_0(a), s_2(a) = t(a), s_1(\\beta) = s_0(\\beta)$ and $s_2(\\beta) = t(\\beta)$, we have that $\\alpha, \\beta$ are swapping between $s_1$ and $s_2$ if and only if they are swapping in $s_0, t$. This is a contradiction as the only pair that swaps in $s_0, t$ is $\\alpha_1, \\beta_1$.\nTherefore we can assume, w.l.o.g., that $\\alpha \\in \\{\\alpha_0, \\alpha_1, \\beta_0, \\beta_1\\}$. We proceed by considering each case separately."}, {"title": "Case $\\alpha = \\alpha_0$.", "content": "We have that $t(\\alpha_0) \\notin s_1(\\{\\alpha_1, \\beta_0, \\beta_1\\})$. Indeed, $s_1(\\alpha_1) = s_0(\\alpha_0) \\neq t(\\alpha_0)$ (by the selection of $\\alpha_0$), $s_1(\\beta_0) = s_0(\\beta_0) \\neq t(\\alpha_0)$ (by the selection of $\\alpha_0$) and $s_1(\\beta_1) = s_0(a_1) = t(\\beta_1) \\neq t(\\alpha_0)$. Since we have assumed that $\\alpha$ and $\\beta$ swap between $s_1$ and $s_2$, we have that $s_1(\\beta) = t(a)$ thus $\\beta \\in \\{\\alpha_1, \\beta_0, \\beta_1\\}$. Additionally, because we have that assumed that $\\alpha$ and $\\beta$ also swap between $s_1$ and $s_2$, we have that $t(\\beta) = s_1(a) = s_1(\\alpha_0) = t(\\alpha_1)$. Therefore, $\\beta = \\alpha_1$. This is a contradiction."}, {"title": "Case $\\alpha = \\beta_0$.", "content": "Here we need to consider two sub-cases, whether $t(\\beta_0) = s_0(\\alpha_0)$ or $t(\\beta_0) \\neq s_0(\\{\\alpha_0, \\alpha_1, \\beta_1\\})$. In the first case, we have no swap because $s_1(\\alpha_1) = s_0(\\alpha_0) = t(\\beta)$ but $t(a_1) = s_0(\\beta_1) \\neq s_0(\\beta_0) = s_1(\\beta_0)$. In the second case, $t(\\beta_0) = s_1(\\gamma)$ and $\\beta = \\gamma \\notin \\{\\alpha_0, \\alpha_1, \\beta_1\\}$. As both $\\alpha, \\beta \\in \\{\\alpha_0, \\alpha_1, \\beta_1\\}$, we have that $s_1(a) = s_0(a)$ and $s_1(\\beta) = s_0(\\beta)$. Therefore, $\\alpha$ and $\\beta$ are swapping between $s_1$ and $s_2$ if and only if they are swapping in $s_0, t$. This is a contradiction as the only pair that swaps in $s_0, t$ is $\\alpha_1, \\beta_1$."}, {"title": "Case $\\alpha = \\alpha_1$.", "content": "Notice that $t(\\alpha_1) = s_0(\\beta_1) = s_1 (\\alpha_0)$. Since $t(\\alpha_0) \\neq s_0(\\alpha_0) = s_1(\\alpha_1)$, there is non swap."}, {"title": "Case $\\alpha = \\beta_1$.", "content": "Notice that $t(\\beta_1) = s_1(\\beta_1)$. Therefore, there is no swap including $\\beta_1$.\nTherefore, $s_1, s_2$ does not include any swaps. This completes the proof of the theorem.   $\\square$"}, {"title": "Theorem 4.", "content": "MULTIAGENT PATH FINDING is in FPT parameterized by the distance to clique."}, {"title": "Proof.", "content": "Before we start, let us mention that we can assume that the makespan of any optimal solution is strictly larger than 2. This is due to the fact that instances with for $l < 2$ are easily solvable in polynomial time through matching.\nInstead of just deciding if the given instance of MULTIAGENT PATH FINDING is a yes-instance or not, we will compute an optimal solution of the given instance (i.e., a"}, {"title": "feasible solution of minimum makespan) if such a feasible solution exists.", "content": "Basically, we will deal with the optimization version instead of the decision version of the problem; thus, we will drop the target makespan $l$ in the input instance.Let $I = (G, A, s_0, t)$ be an instance of MULTIAGENT PATH FINDING. Recall that $d_c(G)$ is the minimum number of vertices we need to delete from $G$ such that the resulting graph is a clique. That is, there exists a partition $(M, Q)$ of $V(G)$ such that $G[Q]$ is a clique and $|M| = d_c(G)$ and for any other a partition $(M', Q')$, either $G[Q']$ is not a clique or $|M'\\geq d_c(G)$. Recall also that we can compute $M$ is FPT time parameterized by $d_c(G)$. Hereafter, we assume that we have such a partition $(M, Q)$ and will use $d_c$ to refer to the number $d_c(G) = |M|$.\nThe idea behind this proof is:"}, {"title": "1.", "content": "We prove that, if $I$ admits a feasible solution, then the makespan of any optimal solution is bounded by a computable function of $d_c$."}, {"title": "2.", "content": "We create a new instance $K = \\langle G', A', s'_0, t' \\rangle$ of MULTIAGENT PATH FINDING such that:\n*   $G'$ is an induced subgraph of $G$ with a number of vertices that is bounded by a computable function of $d_c$,\n*   $V(G')\\supset M$ and\n*   $A'$ is an appropriately selected subset of $A$."}, {"title": "3.", "content": "We prove that, if $I$ admits a feasible solution $s_1,..., s_m$, then $K$ admits a feasible solution $s'_1,..., s'_m$ such that $|s'(A') \\cap M| > |A| - |Q|$."}, {"title": "4.", "content": "We compute an optimal solution $s'_1,..., s'_{m'}$ of $K$ such that $|s'(A') \\cap M| > |A| - |Q|$ (if such a solution exists). This can be done in FPT time parameterized by $d_c$ as $|V(G')|$ is bounded by a computable function of $d_c$."}, {"title": "5.", "content": "We extend $s'_1,..., s'_{m'}$ into a feasible solution $s_1,..., s_{m'}$ of $I$. To do so, we create consecutive matchings between the positions of the agents $A \\setminus A'$ in the turn $i \\in [m - 1] \\cup \\{0\\}$ and $Q \\setminus s_{i+1}(A')$, i.e., the empty positions in the clique in the turn $i + 1$.\nIt is easy to see that, if we implement all the previous steps, then the algorithm will return an optimal solution of $I$ if there exists any. Otherwise we can conclude that there is no feasible solution for $I$."}, {"title": "Step 1.", "content": "We will show that, if there exists a feasible solution $s_1,..., s_m$ of $I$, then there exists a feasible solution $s_1,..., s'_{f(|M|)}$ of $I$, where $f : \\mathbb{N} \\to \\mathbb{N}$ is a commutable function.\nTo this end, we first define a generalization of MULTIAGENT PATH FINDING, called PARTIALLY ANONYMOUS MULTIAGENT PATH FINDING, as follows. The input of the (optimization version of) PARTIALLY ANONYMOUS MULTIAGENT Path FindinG problem consists of a graph $G = (V, E)$, two sets of agents $A$ and $B$, two functions $s_0\\colon A \\cup B \\to V$ and $t\\colon A \\to V$ and a subset $T$ of $V$ such that $|T| = |B|$. For any $a, b \\in A$ and $c\\in B$ where $a \\neq b$, we have that $s_0(a) \\neq s_0(b), s_0(a) \\neq s_0(c), t(a) \\neq t(b)$ and $t(a) \\notin T$. A sequence $s_1, ..., s_m$ is a feasible solution of an instance $(G, A, B, s_0, t,T)$ of PARTIALLY ANONYMOUS MULTIAGENT PATH FINDING if"}, {"title": "1.", "content": "for all $i \\in [m]$ we have that $s_i : A \\cup B \\to V$,"}, {"title": "2.", "content": "$s_i(a)$ is a neighbor of $s_{i-1}(a)$ in $G$, for every agent $a \\in A \\cup B$ and $i \\in [m]$,"}, {}]}