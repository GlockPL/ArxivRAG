{"title": "Solving 7x7 Killall-Go with Seki Database", "authors": ["Yun-Jui Tsai", "Ting Han Wei", "Chi-Huang Lin", "Chung-Chin Shih", "Hung Guei", "I-Chen Wu", "Ti-Rong Wu"], "abstract": "Game solving is the process of finding the theoretical out- come for a game, assuming that all player choices are optimal. This paper focuses on a technique that can reduce the heuristic search space signif- icantly for 7x7 Killall-Go. In Go and Killall-Go, live patterns are stones that are protected from opponent capture. Mutual life, also referred to as seki, is when both players' stones achieve life by sharing liberties with their opponent. Whichever player attempts to capture the opponent first will leave their own stones vulnerable. Therefore, it is critical to recog- nize seki patterns to avoid putting oneself in jeopardy. Recognizing seki can reduce the search depth significantly. In this paper, we enumerate all seki patterns up to a predetermined area size, then store these patterns into a seki table. This allows us to recognize seki during search, which significantly improves solving efficiency for the game of Killall-Go. Experiments show that a position that could not be solved within a day can be solved in 482 seconds with the addition of a seki table. For general positions, a 10% to 20% improvement in wall clock time and node count is observed.", "sections": [{"title": "1 Introduction", "content": "Games solving [14], particularly for the complex game of Go, is one of the most challenging pursuits in artificial intelligence. While AlphaZero [13] has mastered 19x19 Go in game playing, only up to 5x6 Go has been fully solved [15]. One interesting variant of Go is Killall-Go, which follows similar rules but with Black aiming to capture all White's stones to win. The game can also be viewed as a whole board life-and-death problem in Go, which is a fundamental concept for Go learners. Killall-Go is therefore a valuable test bed for solving larger board sizes in Go, with many attempts to solve the 7x7 version of the game [12, 21, 22].\nIn 7x7 Killall-Go, Black plays two consecutive moves first, followed by al- ternating turns between White and Black, as shown in Fig. 1a. There are two"}, {"title": "2 Background", "content": ""}, {"title": "2.1 Game Solver", "content": "A game is considered solved when its game-theoretic value is found, i.e. we know the outcome under optimal play. Since the search space is often extremely large, heuristics are often used to guide the search, minimizing the number of winning moves explored, while simultaneously searching through the shortest game length that leads to a solution. AlphaZero-like algorithms are known for producing strong agents that do not necessarily attempt to finish games as quickly as possible [22], which make them less ideal for game solving. Proof-number search (PNS) [2], depth-first proof number search (DFPN) [7], and threat-space search [1] are some common search algorithms that prune unnecessary branches when solving games, potentially leading to more efficient solutions.\nA notable example of a game solved is checkers. Schaeffer et al. [10] used a distributed solving system comprised of a proof-tree manager and numerous"}, {"title": "2.2 7x7 Killall-Go", "content": "Killall-Go is a two-player, zero-sum game like Go. In 7x7 Killall-Go, Black is given a large advantage by placing two stones in their first turn. Accordingly, Black is expected to capture all White stones to win. On the other hand, White only needs to secure one safe area to win. To determine whether an area is secure, Benson [3] proposed an algorithm based on Go rules to determine whether a set of blocks is unconditionally alive (UCA), i.e. the block is guaranteed to be safe from capture, even if the opponent is allowed an unlimited number of consecutive turns. There are two core rules in Go. First, a string of connected stones are called blocks, and empty grids that are adjacent to blocks are called liberties. A block is captured, with its stones removed from the board, when it no longer has any liberties. Second, neither player is allowed to capture stones of their own. With these two rules in mind, a block is UCA if it has at least two liberties in which their opponent may not play in. Benson's algorithm examines blocks systematically to determine if this is true. It is worth noting that UCA is a strong guarantee. White does not need to achieve UCA to secure a safe area to win in Killall-Go. In fact, Black and White can coexist in the same area, sharing liberties between their stones, unable to capture each other. This situation is referred to as mutual life, or seki."}, {"title": "2.3 Seki", "content": "In Killall-Go, seki often involves 1) White securing an area; 2) Black occupying the boundary of the White area, while also attempting to capture white stones inside it, as shown in Fig. 1c. In the seki area, neither Black nor White can capture all opponent stones, nor achieve UCA. In fact, whichever player plays inside the seki area renders their stones vulnerable for capture. Thus, players can only move outside the seki area or pass when playing optimally."}, {"title": "3 Method", "content": "In this section, we describe how the seki database is created and how it is used. First, we enumerate all potential seki patterns for specific area sizes. Second, each pattern is analyzed via exhaustive search to determine whether they are seki, where valid entries are stored in the database. Lastly, we describe how the seki database is integrated into the search algorithm during game solving."}, {"title": "3.1 Pattern Enumeration", "content": "The process of generating a seki database is similar to that of chess endgame tablebases. As mentioned in subsection 2.3, we only focus on local seki. For all potential local seki patterns, there are three key components: a black boundary, a white block enclosing a contiguous potential seki area, and interior black stones within the seki area. There are two examples of such patterns on the left hand side of Fig. 2. All potential local seki can be categorized according to the pattern size, just like how chess tablebases are categorized by piece count. In this paper, we enumerate all possible patterns from size 5 to 8. We skip sizes 4 and below since they are too small to form seki patterns.\nWe begin by generating all possible contiguous shapes of the specified area size n. For each shape, we create a potential pattern in four steps. First, we define the generated shape as the seki area. Next, we surround the area with an enclosing white block. A black boundary is then added to the pattern to deprive the enclosing white block of all external liberties. Lastly, we systematically fill the interior area with black stones until there are only two or three empty grids; this will yield $\\binom{n}{2} + \\binom{n}{3}$ combinations."}, {"title": "3.2 Seki Verification and Storage", "content": "For each generated pattern, we mostly follow Niu et al.'s local seki detection method [9] to determine whether they are seki. As with Niu et al.'s method, we search each pattern twice, where Black and White each play first. All can- didate moves need to be within the seki area. Moves played outside of the area have no impact, and therefore can be viewed as equivalent to passing; thus, two consecutive passes no longer ends the game. Following the definition of a seki (see subsection 2.3), whoever plays inside the area first loses. For this reason, we prohibit passing as the first move of the search, i.e. the position must change as a result of the first player's first move. To avoid perpetual delays, if the position remains the same due to continual passing from both sides, the first player must play to change the situation. If the pattern inside the area is a seki, the first player is guaranteed to lose. Following Niu et al.'s method, if both Black and White loses as the first player, the area is a local seki. Since the seki database is generated offline, with no time constraints, we simply implemented this ver- ification and-or search with depth-first search, instead of the more efficient but elaborate DFPN algorithm."}, {"title": "3.3 Using the Seki Database in Solving Killall-Go", "content": "In Killall-Go, the winning condition for White simply requires them to hold any amount of territory. This can usually be achieved through UCA, but seki, while rare, can also guarantee life. Therefore, upon confirmation of either UCA for White or seki, we have reached a terminal position and White's win can be updated accordingly in the and-or tree.\nWe describe how the seki database is used via Fig. 2. To reduce overhead, we only query the seki database if the most recent move is either part of an enclosing White block (as is the case on the top) or within a White enclosed area (as is on the bottom). The input for the query consists of the shape of the area (represented by their indices, and denoted by the shaded colors) and whether each grid is empty (green) or contains a black stone (blue).\nIn this illustrated example, we could not find a matching pattern for the bottom case, which means the search must proceed to obtain the correct game outcome. On the other hand, the top case is a hit, which means the enclosing white block must be alive due to seki or UCA. To explain the latter case, keep in mind that we only look for matching patterns inside the enclosed area, which confirms that Black cannot invade successfully. Meanwhile, if White's enclosing block also forms at least one eye, it satisfies the stronger UCA condition. In either case, White has secured territory and won.\nIt is worth noting that there are edge cases of seki that our generation method does not cover. For example, even in patterns that do not match, an external"}, {"title": "4 Experiments", "content": "We perform our experiments on the online fine-tuning solver presented in our previous paper [21], for which the code is based on the MiniZero framework [20], only changing the top-k configuration from 4 to 2. Subsection 4.1 provides statistics related to the generation of the seki database. The online fine-tuning solver is a distributed solver system that has workers analyzing different positions in parallel. Subsections 4.2 and 4.3 both investigate how the seki database affects performance, where the former looks at the whole solving system, from manager to workers, and the latter looks at job statistics (i.e. only workers)."}, {"title": "4.1 Database Generation", "content": "We generate seki patterns between area sizes of 5 to 8 using two E5-2683 v3 CPUs, for a total of 16 threads. Table 1 shows the relevant data for each area size, along with the cumulative statistics. The possible number of patterns roughly increases by four times for each area size increase. Larger area sizes mean larger search spaces, and longer times to generate seki entries. For each increase in area size, the time to generate entries roughly increases 30 fold. The right hand side of Fig. 2 shows eight examples of the patterns stored in the database, two for each area size. Note that size 8 patterns take up the majority of stored entries in the database."}, {"title": "4.2 Solver Performance on Benchmark Openings", "content": "We now try to solve a collection of ten openings using our previously presented online fine-tuning solver [21]. The benchmark problems can be separated into three parts. Cases A and B are problems suggested by Go experts, with a high probability of seki occurring. Cases C to H are problems that were collected"}, {"title": "4.3 The Seki Database's Impact on Job Solve Rates", "content": "In subsection 4.2, we looked at the seki database's impact on the online fine- tuning solver holistically. In this subsection, we now turn to its impact on in- dividual jobs, categorized by the number of seki encountered during the job. We randomly sampled 10,000 jobs sent from the manager, while not using the seki database when solving opening A, as shown in Fig. 3a. These jobs are then recalculated with and without the seki database, then categorized by the seki database hit rate within each job, where the hit rate is calculated by the number of matching patterns divided by the total number of terminal nodes encountered while analyzing the job. As an extreme example, if the position shown in the upper left corner of Fig. 2 is sent as a job to a worker, it will match an entry in the database, and recognized as a win for White, with a seki hit rate of 100%. Alternatively, if the position in the bottom left is sent as a job, no matches can be found, and the search will proceed as usual. If it is then solved and exactly two positions are matched among 100 terminal nodes, its hit rate is 2%."}, {"title": "5 Conclusion", "content": "This paper clearly illustrates that attempting to solve 7x7 Killall-Go without seki detection is prohibitively costly even for simple positions that may encounter relatively few seki situations. When encountering positions where seki appears more than 10% of the time, the solving rate drops to lower than 6.68%. In the most extreme case, subsection 4.2 demonstrates that previously unsolvable seki positions can now be solved in just 482 seconds, especially since it avoids exhaustive seki detection algorithms during runtime.\nEven for common openings in Killall-Go, seki knowledge also gives a 10-20% discount on solving time and nodes. Other than local seki, we could also extend the database for global seki, edge cases, or relevancy zones [12]. We believe that the underlying concept of endgame databases such as the database presented in this paper can also be applied to other applications."}]}