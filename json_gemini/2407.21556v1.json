{"title": "Operator-based semantics for choice programs: is choosing losing? (full version)", "authors": ["Jesse Heyninck"], "abstract": "Choice constructs are an important part of the language of logic programming, yet the study of their semantics has been a challenging task. So far, only two-valued semantics have been studied, and the different proposals for such semantics have not been compared in a principled way. In this paper, an operator-based framework allow for the definition and comparison of different semantics in a principled way is proposed.", "sections": [{"title": "Introduction", "content": "Logic programming is one of the most popular declarative formalisms, as it offers an expressive, rule-based modelling language and efficient solvers for knowledge representation. An important part of this expressive-ness comes from choice constructs [Simons et al., 2002], that allow to state e.g. set constraints in the body or head of rules, and are, among others, part of the ASP-Core-2 standard [Calimeri et al., 2012]. For example, the rule \\(1\\{p,q,r\\}2 \\leftarrow s.\\) expresses that if s is true, between 1 and 2 atoms among p, q and r are true. Choice constructs are non-deterministic, in the sense that there is more than one way to satisfy them. For example, \\(1\\{p,q,r\\}2\\) can be satisfied by \\({\\{p\\}}\\), \\({\\{p,q\\}}\\), \\({\\{r\\}}\\), Formulating semantics for such non-deterministic rules has proven a challenging task [Liu et al., 2010; Marek and Remmel, 2004; Faber et al., 2004; Son and Pontelli, 2007]: several semantics have been proposed but no unifying framework for defining and comparing these se-mantics exists. Furthermore, attention has been restricted to two-valued semantics, in contradistinction to many other dialects for logic programming for which three- or four-valued semantics have been proposed. Moreover, many proposed semantics only allow for choice constructs in the body, but not in the head. Finally, relations with the non-deterministic construct disjunction remain unclear.\nIn this paper, a unifying framework for the definition and study of semantics for logic programs with choice constructs in the head and body is provided. This framework is based on immediate consequence operators, which are also useful for the design of explanatory tools and provide foundations for solvers [Kaminski and Schaub, 2023; Eiter and Geibinger, 2023]. The contributions of this paper are the following: (1) we show how the famework of non-deterministic approximation fixpoint theory (AFT) [Heyninck et al., 2024] can be used to define a wide variety of supported and stable semantics for choice logic programs, (2) we introduce the constructive stable fixpoints, allowing to (3) generalize many existing semantics for choice programs, (4) compare these semantics by introducing postulates, (5) provide a principled comparison with disjunctive logic programs.\nOutline of the Paper: In Section 2, the background on choice programs and non-deterministic approximation fixpoint theory is given. In Section 3, approximation operators for choice programs are defined. In Section 4, we study the resulting supported semantics. In Section 5, we define stable semantics and show representation"}, {"title": "Background and Preliminaries", "content": "We recall choice programs and non-deterministic AFT."}, {"title": "Choice Rules and Programs", "content": "A choice atom (relative to a set of atoms A) is an expression C = (dom, sat) where \\(dom\\subseteq A\\) and \\(sat\\subseteq p(dom)\\). Intuitively, dom denotes the domain of C, i.e. the atoms relevant for the evaluation of C, whereas sat is the set of satisfiers of C. We also denote, for C = (dom, sat), dom by dom(C) and sat by sat(C). For a concrete example, consider \\(1\\{p,q,r\\}2\\) which intuitively states that between 1 and 2 of the atoms p, q and r have to be true, corresponds to the choice atom \\((\\langle\\{p,q,r\\},\\{\\{p\\},\\{q\\},\\{r\\}, \\{p,q\\},\\{p,r\\}, \\{q,r\\}\\} \\rangle)\\) (notice that \\(\\{p,q,r\\}\\) is the domain and not a satisfier). For such choice atoms, we assume the domain and satisfiers are clear and can be left implicit (and similarly for constructs such as \\({\\{p,q\\}} = 1\\) or \\({\\{p,q\\}} \\neq 1\\)).\nA choice rule has the form \\(C \\leftarrow C_1,...,C_n\\) where C, \\(C_1,..., C_n\\) are choice atoms. C is called the head (denoted hd(r)) and \\(C_1,...,C_n\\) the body. If \\(C_i\\) is a literal (i.e. \\(C_i = (\\{a\\},\\{\\{a\\}})\\), abbreviated by a, or \\(C_i = (\\{a\\}, \\{\\emptyset\\})\\), abbreviated by \\(\\neg a\\)) for every i = 1, . . . , n, we call it a normal choice rule. If C is an atom, we call r an aggregate rule. A choice program is a set of choice rules, and is called normal [aggregate] if all of the rules are so. A choice atom C is monotone if \\(dom(C) \\cap x \\in sat(C)\\) implies \\(dom(C) \\cap x' \\in sat(C)\\) for any \\(x \\subseteq x' \\subseteq A\\), and it is convex if for any s.t. \\(x \\subseteq y \\subseteq A\\), \\(dom(C) \\cap x \\in sat(C)\\) and \\(dom(C) \\cap y \\in sat(C)\\), \\(dom(C) \\cap z \\in sat(C)\\) for any \\(x\\subseteq z \\subseteq y\\).\nFollowing Liu et al. [2010], a set \\(x \\in A\\) satisfies a choice atom C if \\(dom(C) \\cap x \\in sat(C)\\). An interpretation x satisfies a ruler if x satisfies the head of r or does not satisfy some choice atom in the body of r. x is a model of P if it satisfies every rule in P. A rule \\(r \\in P\\) is x-applicable if x satisfies the body of r, and the set of x-applicable rules in P is denoted by P(x). \\(x \\in A\\) is a supported model of P if it is a model and \\(x \\subseteq \\bigcup_{r \\in P(x)} dom(hd(r))\\). For some \\(x \\subseteq A\\), let \\(HD_P(x) = \\{hd(r) \\mid r \\in P(x)\\}\\) and \\(IC_P(x) =\\)\n\\({\\bigcup_{C\\in HD_P(x)} dom(C) \\mid \\forall C \\in HD_P(x) : z(C) = T\\}}\\)\nConsider the program \\(P = \\{1\\{p,q\\}2 \\leftarrow \\{p,q\\} \\neq 1\\}\\). The choice atoms behave as follows:"}, {"title": "Approximation Fixpoint Theory", "content": "We first recall some basic algebraic notions. A lattice is a partially ordered set (poset) \\((L,\\leq)\\) s.t. for every x, y \u2208 L, a least upper bound x \u2228 y and a greatest lower bound x \u2227 y exist. A lattice is complete if every X \u2286 L has a least upper bound ||X and a greatest lower bound \u22c2X. ||L is denoted by \u22a4 and \u22c2L is denoted by \u22a5. A function \\(f : X \\rightarrow Y\\) from a poset \\((X, \\leq_1)\\) to a poset \\((Y, \\leq_2)\\) is monotonic if \\(x_1 \\leq_1 x_2\\) implies \\(f(x_1) \\leq_2 f(x_2),\\)"}, {"title": "Approximation Operators for Choice Programs", "content": "The central task is to define non-deterministic approximations of the immediate consequence operator \\(IC_P\\). As is usual, we conceive of pairs of sets of atoms (x,y) as four-valued interpretations, where atoms in x are true whereas those in y are not false. Thus, assuming \\(x \\subseteq y\\), (x,y) represents an approximation of some set \\(z\\in [x, y]\\). The basic idea behind all the operators defined below is the same: given an input interpretation (x, y), we determine a set of rules that are to be taken into account when constructing the new lower (respectively upper bound), and then take as new lower (respectively upper bounds) the interpretations that make true the heads of all these rules. As is well-known already in the case for aggregate programs, there are various ways to give formal substance to this idea. We will consider four operators inspired by previous work on aggregate or choice programs, namely \\({IC}_P^{GZ}\\) [Gelfond and Zhang, 2014], \\({IC}_P^{MR}\\) [Marek and Remmel, 2004], \\({IC}_P^{LPST}\\) [Liu et al., 2010], and \\({IC}_P^{U}\\) [Heyninck and Bogaerts, 2023]. The study of further operators is left for future"}, {"title": "Supported Model Semantics", "content": "In this section, we look at the fixpoints of IC, which give a three-valued generalisation of the supported model semantics by Liu et al. [2010] (and the three-valued model semantics of normal logic programs). Intu-itively, fixpoints of IC generalise the idea that only atoms supported by activated rules can be accepted.\nA first insight is that the total fixpoints of all operators coincide with supported models [Liu et al., 2010].\nProposition 3. Let a choice program P and x \u2208 {LPST,MR, GZ,U} be given. Then (x,x) is a fixpoint of IC iff x is a supported model of P.\nHowever, our extension to three-valued semantics allows to give semantics to a wider class of programs:"}, {"title": "Stable Semantics", "content": "We now move to the stable semantics, whose main aim is favvoding the acceptance of self-supporting cycles, e.g. accepting (\\({\\{p\\}}, {\\{p\\}}\\)) as a reasonable model of the program \\({\\{p \\leftarrow p\\}}\\). For the deterministic case, this is done by looking at fixpoints of the stable operator, obtained by calculating a new lower bound as the least fixpoint of Or(\u00b7,y), where y is the input upper bound (and similarly for the upper bound). Intuitively, we take the least information the upper bound obliges use to derive. In contradistinction to the deterministic case, there are divergent options for how to define stable semantics for non-deterministic operators. We first consider the minimality-based stable semantics known from non-deterministic AFT [Heyninck et al., 2024], defined as the \\(\\leq_t\\)-minimal fixpoints of O\u2081(\u00b7,y) (cf. Section 2.2), which where shown to generalize the (partial) stable model semantics for disjunctive (aggregate) programs [Heyninck et al., 2024; Heyninck and Bogaerts, 2023]. For choice constructs, this construction is overly strong:\nExample 7. Consider the program \\(P = \\{1\\{p,q\\}2 \\leftarrow\\}\\). Intuitively, this rule allows to choose between one and two among p and q. The stable version of IC (cf. Section 2.1) behaves as follows (for any x = LPST, MR, GZ):\n\\(S(IC'(x)) = \\{\\{p\\},\\{q\\}\\}\\) for any \\(x \\subseteq A\\)\n{\\{p\\}} and {\\{q\\}} are the two stable fixpoints of IC. This is undesirable, as according to the intuitive reading of P, {\\{p,q\\}} should also be allowed as a stable interpretation.\nIf we take one step back, we can explain the choice for minimal fixpoints, and their shortcomings in the context of choice constructs, in stable non-deterministic operators [Heyninck et al., 2024] as follows. For deterministic operators, the stable version of an approximation operator O is defined as the greatest lower bound (glb) of fixpoints of O\u2081(\u00b7,y). For deterministic operators over finite lattices, the minimal fixpoint of O1(\u00b7,y) are identical to the glb of fixpoints of O\u2081(\u00b7,y), and it is also identical to the fixpoint obtained by iterating O\u2081(\u00b7,y) starting from \u22a5 (i.e. \\(\\bigcup_{i=1} O_1(\\bot, y)\\)). For non-deterministic operators, this correspondence does not hold. Indeed, the glb of fixpoints of O1 (\u00b7,x) is often too weak (e.g. for the program P from Example 7 we get {\\{p\\}} \\cap \\{q\\} \\subset \\{p,q\\} = \\emptyset as the glb of fixpoints). However, this still leaves a third choice: namely looking at fixpoints reachable by applications of O\u2081 (\u00b7, y) starting from \u22a5. E.g. for choice programs, we are interested in the fixpoints of IC (., y) that can built them up from the ground up (i.e. from \u00d8) by a sequence of applications of IC (., y). We first generalize the notion of a well-founded sequence by Denecker and Vennekens [2014]:\nDefinition 3. Given a non-deterministic operator \\(O : L \\rightarrow (L)\\) over a complete lattice, a sequence \\(x_0, ...,x_n \\subseteq L\\) is well-founded relative to O if: (1) \\(x_0 = \\bot\\); (2) \\(x_i \\subseteq x_{i+1}\\) and \\(x_{i+1} \\in O(x_i)\\) for every successor ordinal i > 0; and (3) \\(x_{\\lambda} = (\\{\\bigcup_{i<1} x_i\\})\\) for a limit ordinal \u03bb. The well-founded sequences relative to O are denoted by wfs(0).\nRemark 2. The assumption of a complete lattice in Definition 3 is needed since the greatest lower bound is used in point 3 of Definition 3."}, {"title": "Groundedness", "content": "We introduce several postulates to facilitate a comparison between semantics for choice programs (thus solving an open question in the literature Alviano et al. [2023]) formalizing in different ways the idea of groundedness. Furthermore, we show that for every notion of groundedness, there exist examples which have been argued in the literature to be counter-intuitive.\nIntuitively, the idea behind groundedness is that models should be derivable from the ground up, i.e. they should be supported by non-cyclic arguments. For choice programs, what constitutes a cycle becomes less clear:\nDefinition 6. A set x is d(omain)-grounded (for P) if there is some \\(K : x \\rightarrow N\\) s.t. every \\(a \\in x\\) there is some \\(r = C \\leftarrow C_1,...,C_n \\in P\\) s.t. \\(a \\in dom(C)\\), \\(\\kappa(a) > max\\{\\kappa(b) \\mid b \\in \\bigcup_{i=1} dom(C_i)\\}\\).\nAs already observed by Alviano et al. [2023], this requirement might be overly strong:\nDefinition 7. (1) A set x is an y-trigger for \\(C \\leftarrow C_1, ..., C_n\\) if for every \\(z \\in [x, y]\\), z(Ci) = T for every i = 1,...,n. (2) A set x is strongly)-grounded (for P) if there is some \\(K : x \\rightarrow N\\) s.t. every \\(a \\in x\\), there is some \\(r = C \\leftarrow C_1,..., C_n \\in P\\) s.t. \\(a \\in dom(C)\\) and there is an x-trigger z for r s.t. \\(\\kappa(a) > max\\{\\kappa(b) \\mid b \\in z\\}\\).\nIntuitively, x is s-grounded if for every atom \\(a \\in x\\), we can find a rule that that has an x-trigger in a strictly lower level.\nD-grounded sets are s-grounded, but not vice-versa:\nDefinition 8. A set x is a(ntecedent)-grounded if there is some \\(K: x \\rightarrow N\\) s.t. every \\(a \\in x\\), there is some \\(r = C \\leftarrow C_1, ...,C_n \\in P\\) s.t. \\(a \\in dom(C)\\) and for every i = 1,...,n there is some z \u2286 {\\{b | k(b) < \u03ba(a)\\}} s.t. z(Ci) = T ."}, {"title": "Disjunctions are Choice Constructs", "content": "Our study allows us to give a principled account of the relation between stable semantics for disjunctive logic programs (DLPs) and choice programs. Indeed, in this section, we show that for DLPs [Heyninck et al., 2024; Heyninck and Bogaerts, 2023] are a special case of the operator for choice programs. This means that all"}]}