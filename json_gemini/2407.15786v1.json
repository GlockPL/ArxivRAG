{"title": "Concept-Based Interpretable Reinforcement Learning with Limited to No Human Labels", "authors": ["Zhuorui Ye", "Stephanie Milani", "Geoffrey J. Gordon", "Fei Fang"], "abstract": "Recent advances in reinforcement learning (RL) have predominantly leveraged neural network-based policies for decision-making, yet these models often lack interpretability, posing challenges for stakeholder comprehension and trust. Concept bottleneck models offer an interpretable alternative by integrating human-understandable concepts into neural networks. However, a significant limitation in prior work is the assumption that human annotations for these concepts are readily available during training, necessitating continuous real-time input from human annotators. To overcome this limitation, we introduce a novel training scheme that enables RL algorithms to efficiently learn a concept-based policy by only querying humans to label a small set of data, or in the extreme case, without any human labels. Our algorithm, LICORICE, involves three main contributions: interleaving concept learning and RL training, using a concept ensembles to actively select informative data points for labeling, and decorrelating the concept data with a simple strategy. We show how LICORICE reduces manual labeling efforts to to 500 or fewer concept labels in three environments. Finally, we present an initial study to explore how we can use powerful vision-language models to infer concepts from raw visual inputs without explicit labels at minimal cost to performance.", "sections": [{"title": "1 Introduction", "content": "In reinforcement learning (RL), agents are tasked with learning a policy, a rule that makes sequential, reactive decisions in complex environments. In recent RL work, agents typically represent the policy as a neural network, as such representations tend to lead to high performance [17]. However, this choice can come at a cost: such policies are challenging for stakeholders to interpret - particularly when the inputs to the network are also complex, such as high-dimensional sensor data. This opacity can become a significant hurdle, especially in applications where understanding the rationale behind decisions is critical, such as healthcare [32] or finance [15]. In such applications, decisions can have significant consequences, so it is essential for stakeholders to fully grasp the reasoning behind actions in order to confidently adopt or collaborate on a policy.\n*Equal Contribution.\n\u2020This work was done when Ye was a visiting intern at CMU.\nPreprint. Under review."}, {"title": "2 Preliminaries", "content": "In RL, an agent learns to make decisions by interacting with an environment [27]. The environment is commonly modeled as a Markov decision process [21], consisting of the following components: a set of states S, a set of actions A, a state transition function \\(T:S\\times A \\times S \\rightarrow [0,1]\\) that indicates the probability of transitioning from one state to another given an action, a reward function \\(R:S\\times A \\times S \\rightarrow \\mathbb{R}\\) that assigns a reward for each state-action-state transition, and a discount factor \\(\\gamma\\in [0, 1]\\) that determines the present value of future rewards. The agent learns a policy \\(\\pi: S \\times A \\rightarrow [0, 1]\\), which maps states to actions with the aim of maximizing the expected cumulative discounted reward. We evaluate a policy via its value function, which is defined as \\(V^{\\pi}(s) = \\mathbb{E}_{\\pi}[\\sum_{k=0}^{\\infty}\\gamma^k r_{t+k+1} | S_0 = s], \\forall s \\in S\\). The ultimate aim in RL is to determine the optimal policy, \\(\\pi^*\\). To do so, the agent iteratively refines its policy based on feedback from the environment."}, {"title": "2.2 Concept Bottleneck Models", "content": "Concept-based explanations have emerged as a common paradigm in explainable AI [20]. They explain a model's decision-making process through human-interpretable attributes and abstractions. Concept bottleneck models [13] are an example of concept-based explanations: they learn a mapping from samples \\(x \\in X\\) to labels \\(y \\in Y\\) through two functions, g and f. The concept encoder function \\(g: X \\rightarrow C\\) maps samples from the input space to an intermediate space of human-interpretable concepts. The label predictor function \\(f : C \\rightarrow Y\\) maps samples from the concept space to a downstream task space, such as labels for supervised classification. As a result, the prediction \\(\\hat{y} = f(g(x))\\) relies on the input x entirely through the bottleneck \\(\\hat{c} = g(x).\nTraining these models requires a dataset of \\(X \\times C \\times Y\\), in which each sample consists of input features x, a ground truth concept vector \\(c \\in \\{0,1\\}^k\\), and a task label y. The functions f and g are parameterized by neural networks. These models are trained independently, jointly, or sequentially. The independent training method trains \u0192 and \u011d independently. Critically, f is trained using the true c, but at test time it takes \u011d(x) as input. If directly applied to the RL setting, this approach would require continuous access to ground-truth concepts for training f, which we would like to avoid. In joint training, the model minimizes the weighted sum of the concept losses with the task performance loss. This paradigm can be problematic, as the losses can interfere with each other, and it may require careful tuning to find the right balance between the two losses. In sequential training, the model first learns \u011d. It then uses the concept predictions \u011d(x) to learn f(\u011d(x)). As we will later show, this setup is problematic for RL, as concepts may only emerge after the policy is sufficiently performant."}, {"title": "3 LICORICE", "content": "We now describe LICORICE, our algorithm for interactively querying for concept labels under a limited concept label budget during RL training. In Section 3.1, we describe the architecture of the concept bottleneck policy. We then detail our iterative training process (Section 3.2) and explain our active learning approach for choosing informative training points (Section 3.3). Finally, in Section 3.4, we detail how we use VLMs as a substitute for human concept labeling."}, {"title": "3.1 Concept Bottleneck Policies", "content": "We insert a concept bottleneck layer into the policy network, such that \\(\\pi\\) maps from states S to concepts C to actions A, \\(\\pi = f(g(s))\\). These concepts serve as intermediaries in the policy network, which subsequently maps the concept vector to a distribution over possible actions. This setup allows the policy to base its decisions on understandable and meaningful features. We describe additional modifications necessary to accommodate the concept bottleneck in Appendix A.2. As a result, we can use any RL algorithm as long as we include an additional loss function for concept prediction.\nLoss Function We now describe how we use two loss functions for training in our iterative training scheme, described in more detail in Section 3.2. Because we employ an iterative training scheme, we disentangle the two loss functions - the concept prediction loss and the standard RL loss - to prevent interference between them. In this way, the concept prediction loss \\(\\mathcal{L}_C\\) only affects g, the part of the model responsible for predicting concepts, and the standard RL loss \\(\\mathcal{L}_{RL}\\) only affects f. For training g, we employ two types of loss functions depending on the nature of the concepts (MSE for continous concepts; cross-entropy loss for categorical concepts). If the problem requires mixed-type concepts, we could discretize the continuous attributes, converting them into categorical forms suitable for classification. This approach ensures that our method accommodates a diverse range of concept types."}, {"title": "3.2 Training Process", "content": "We now present LICORICE, our novel algorithm for optimizing concept-based models for RL within a fixed concept query budget. Our iterative training approach extends the sequential bottleneck training paradigm by incorporating multiple phases. Intuitively, this strategy can be advantageous for obtaining accurate on-policy concept estimates. To collect candidate training data for g, we employ our current policy for rollouts. To minimize data point correlation and collect a diverse range of data,"}, {"title": "3.3 Active Concept Learning", "content": "We propose to leverage an ensemble of concept models to calculate the disagreement-based acquisition function for actively querying for concept labels. To quantify the concept disagreement of a state U(s), we use two different formulations, depending on the concept learning task.\nClassification For concept classification, we use a query-by-committee [24] approach. When the models produce diverse predictions, it indicates that the instance is difficult and more information would be particularly valuable. Conversely, if all models agree, the instance is likely already well understood, and additional labels would be less beneficial. More specifically, we prioritize points with a high proportion of predicted class labels that are not the modal class prediction (also called the variation ratio [3]). This is given by \\(U(s) = 1 - \\max_{c \\in C}[\\frac{1}{N}\\sum_{i=1}^N \\mathbb{I}[\\hat{g}_i(s) = c]]\\), where \\(\\hat{g}_i(s)\\) is the concept prediction of the i-th model on state s.\nRegression For concept regression, we observe that we can instead directly use variance as a measure of disagreement. Specifically, the concept disagreement of a state is quantified by the unbiased estimation of variance \\(U(s) = \\sigma^2(s)\\) of the predictions across the concept models, due to Bessel's correction, defined as: \\(U(s) = \\sigma^2(s) = \\frac{1}{N-1}\\sum_{i=1}^N(\\hat{g}_i(s) - \\mu(s))^2\\), where \\(\\mu(s) = \\frac{1}{N}\\sum_{i=1}^N \\hat{g}_i(s)\\) is the mean prediction of the N concept models."}, {"title": "3.4 Using Vision-Language Models for Concept Labeling", "content": "Equipped with our overall algorithm, we now seek to further reduce human annotation burden. To do so, we turn to VLMs due to their remarkable performance in understanding and generating human-like descriptions of visual content [22]. Within the pipeline of LICORICE, we keep all aspects of our algorithm the same but use the VLM as the concept annotator in the training loop. By doing so, we effectively decrease the human annotation effort to zero, albeit with some labeling inaccuracy introduced.\nIn our experiments, we use GPT-40 [1], a closed-source model that is possibly the most capable vision-language model in the world at the time of writing the paper. During the training loop of LICORICE, we query GPT-40 each time the algorithm requires a concept label (line 13 in Algorithm 1). As we are using a pre-specified concept set, we design prompts with detailed general descriptions of the scene layout and definitions of all concepts, in a similar fashion to giving labeling instructions to real humans. We then prompt the GPT-40 to obtain the generated labels. In environments where continuous concept values are required, we ask GPT-40 to give as accurate estimates as possible; in environments with concepts that are discrete and more intuitive to label, we provide clear instructions of how to read the concept numbers according to the input image. More details about our prompts can be found in Appendix A.3."}, {"title": "4 Experiments", "content": "In our experiments, we investigate the following questions:\nRQ 1 Does LICORICE enable both high concept accuracy and high environment reward?\nRQ 2 To what extent does LICORICE enable a reduction in human labeling effort without substantially impacting performance?\nRQ 3 Can LICORICE be used alongside powerful vision-language models to further alleviate the labeling burden?"}, {"title": "4.1 Environments", "content": "We evaluate our approach on three environments. For each environment, we define an interpretable concept set, where we define concepts to describe properties of objects of interest.\nPixelCartPole In PixelCartPole-v1 [31], the states are images, and the concepts are the original continuous features in the standard CartPole environment: the cart position, the cart velocity, the pole angle, and the pole angular velocity. To obtain the mapping from images to concepts, we use a fixed window of the four most recent images for the temporal concepts, such as the cart velocity. We also include the last action as input to ensure that the information is sufficient to infer concept values. This domain is deceptively difficult due to the temporal concepts.\nDoorKey In DoorKey-7x7 [5], the agent operates in a 5x5 grid\u00b3 to pick up an item to unlock the door, then reach the green goal square. The states are fully observable images. We define 6 groups of concepts with 12 concept variables in total: 1) the agent's position, 2) the agent's direction, 3) the key's position or a fixed position (0, 0) outside the grid if the key has been picked up, 4) the door's position, 5) whether the door is open, and 6) whether the agent can move along each of four directions, i.e., the corresponding cell is empty. Each group contains one or more concept variables. For example, position groups contain x and y coordinates.\nDynamicObstacles In DynamicObstacles-5x5 [5], the agent operates in a 3x3 grid to avoid two moving obstacles while navigating to the goal. Colliding with the dynamic obstacles yields a large penalty, so the agent must correctly learn concepts to safely reach the goal. The states are fully observable images. We define 5 groups of concepts with 11 concept variables in total: 1) the agent's position, 2) the agent's direction, 3) the first obstacle's position, 4) the second obstacle's position, and 5) whether the agent can move along each of four directions, i.e., the corresponding cell is empty. Each group contains one or more concept variables. For example, position groups contain x and y coordinates."}, {"title": "4.2 Experiment Details", "content": "In each experiment, we run each algorithm 5 times, each with a random seed. More implementation details and hyperparameters are in Appendix A.2.\nArchitecture For the backbone model and algorithm, we use PPO (implementation provided by Stable Baselines 3 [23]). We preserve most of the network architecture, but we add a concept layer in the policy network. Specifically, after passing the image through the feature extractor, which consists of 3 CNN layers, we introduce a linear layer to map to the concept layer and obtain predicted concept values. Each predicted concept is represented as a real value for the regression case and one categorical value derived from a classification head for the classification case. This portion of the network corresponds to g. For f, we utilize an MLP extractor with 2 fully connected layers, each with 64 neurons and a Tanh activation function. We share the default CNN feature extractor between policy and value functions, as we found this to be beneficial in preliminary experiments.\nConcept Representation We model concept learning for PixelCartPole-v1 as a regression problem (minimizing mean squared error) as the concepts are real-valued, and concept learning for DoorKey-7x7 and DynamicObstacles-5x5 as classification problems as the concepts are categorical. The observation images have resolutions of (240, 160) for PixelCartPole-v1, and (160, 160) for DoorKey-7x7 and DynamicObstacles-5x5. These dimensions maintain a short side of 160 pixels while preserving the aspect ratio of the original rendered images, as we observe lower resolutions may impact performance.\nPerformance Metrics To obtain an upper bound on the reward for each environment, we directly use ground-truth concept labels to learn a policy, leading to a reward of 500, 0.97, and 0.91 for the three environments respectively. In the following sections, we report the reward as a ratio of this upper bound. Percentages (or ratios) make sense here since the minimum reasonable reward is 0 in all environments: in PixelCartPole-v1 and DoorKey-7x7, all rewards are nonnegative; in DynamicObstacles-5x5, a random policy would have negative reward due to collisions, but the agent can ensure nonnegative reward by simply staying in place. We additionally report the concept error (MSE for regression; 1 - accuracy for classification). All the reported numbers are calculated during the testing stage, where we evaluate the models on 100 episodes."}, {"title": "4.3 Results", "content": "We first validate that LICORICE can achieve high reward in all test environments while accurately identifying concepts. We first compare against baselines with a fixed budget of B = [500, 300, 300]\n3In both of the Minigrid environments, the actual usable area is smaller than what shows in its name, as the outermost layer is a boundary.\nqueries for PixelCartPole-v1, DoorKey-7x7, and DynamicObstacles-5x5, respectively, as depicted in the first section of Table 1. We choose these budgets by starting from 500 and then decreasing by units of 100 until we find that LICORICE can no longer achieve 99% of the reward upper bound if we further decrease the budget. We treat the minimum budget under which LICORICE can achieve 99% of the reward upper bound as the maximum budget considered for that environment.\nComparison with Budget-Constrained Baselines To our knowledge, no previous algorithms exist that seek to minimize the number of train-time labels for concept-based RL training, so we implement our own baselines. In Sequential-Q, the agent spends all of B queries on the first B states it encounters during the initial policy rollout. In Disagreement-Q, the agent similarly spends its budget at the beginning of its learning process; however, it uses active learning with the same acquisition function as LICORICE to strategically choose the training data. In Random-Q, the agent receives B concept labels at random points in the training process using a probability to decide whether to query for a concept for each state. We show the results in the first section of Table 1. In the three environments, LICORICE performs similarly to or better than all baselines in terms of both reward and concept error. The main performance differences can be seen for PixelCartPole-v1 and DoorKey-7x7, where LICORICE achieves 100% and 99% of the optimal reward, respectively, while the second best algorithm achieves 36% and 89%, respectively. Random-Q, Disagreement-Q, and LICORICE perform similarly on DynamicObstacles-5x5, indicating that this environment is relatively simple and may not benefit from a more advanced strategy. Its simplicity may be due to the lack of concept distribution shift that is present in the other two environments. For example, in PixelCartPole-v1, the policy must be further refined to improve its estimate of the more on-policy concepts. In the initial training stages, when the policy is more random, the agent needs to estimate a wide range of possible values for the pole angle, as the pole starts upright and frequently falls. As the agent's policy improves, it requires more precise estimates of the pole angle primarily around the vertical position.\nComparison with Budget-Unconstrained Baseline To better understand the performance of our approach, we compare it against existing work that is not constrained by concept label budgets. Specifically, we implement Concept Policy Model (CPM) from previous work in multi-agent RL [33] but for the single-agent setting. This approach jointly trains the concept bottleneck and the policy, assuming unlimited access to concept labels. It represents an upper bound on concept accuracy, as the agent receives continuous concept feedback throughout learning. Surprisingly, LICORICE outperforms CPM in PixelCartPole-v1and has similar performance to CPM in the other two envi-ronments in this unfair comparison. We emphasize that CPM is given an unlimited budget, and in fact, it uses over 1M concept labels for each environment, whereas LICORICE uses 500 or fewer. We therefore answer RQ 1 affirmatively: compared to baselines, LICORICE demonstrates both high concept accuracy (low concept error) and high reward on our three test environments, all while using substantially fewer concept labels than existing algorithms."}, {"title": "4.3.2 Budget Allocation Effectiveness", "content": "To understand the extent to which LICORICE enables a reduction in human labeling effort without substantially impacting performance, we conduct experiments across three different environments with varying concept labeling budgets. We start with the baseline budget B from our previous experiments and test two additional budgets, decreasing by steps of 100. The only component of our algorithm that we vary is the number of iterations M. For each budget and environment, we report a single performance value that maximizes the sum of the relative reward and inverse concept error, both scaled to [0, 1]. The results of this experiment are shown in Table 2.\nOur findings reveal that the impact of budget reductions (human labeling effort) varies across environ-ments. In general, we see an increase in concept error and a decrease in reward for all environments with decreasing budget. However, both DynamicObstacles-5x5 and DoorKey-7x7 show more re-silience to budget reductions, while PixelCartPole-v1 exhibits higher sensitivity. Specifically, we find that even with B = 100 for DynamicObstacles-5x5, LICORICE can still achieve 96% of the optimal reward. With B = 200, LICORICE can still achieve 93% of the optimal reward on DoorKey-7x7. In contrast, we see large decreases in reward from the budget reductions for PixelCartPole-v1. We therefore provide a more nuanced answer to RQ 2: LICORICE can indeed enable reductions in human labeling effort without substantially impacting performance, but the extent of this re-duction is environment-dependent. In simpler environments, human effort can be dramatically reduced while maintaining near-optimal performance. However, in more complex environments like PixelCartPole-v1, the trade-off between reduced human effort and maintained performance becomes more pronounced. This finding aligns with the intuition that different environments have varying levels of complexity and would require different levels of human input to accurately capture all relevant concepts and their relationships."}, {"title": "4.3.3 Integration with Vision-Language Models", "content": "We now seek to answer the question of whether VLMs can successfully provide concept labels in lieu of a human an-notator within our LICORICE framework. For consistency, we use the same hyperparameters for LICORICE as in Sec-tion 4.3.2. Because using VLMs incurs costs and users re-quiring interpretable policies for their environments may still face budget constraints, we operate within the same budget-constrained setting as described in Section 4.3.2. Here, the reduction in the number of \"human\" labels required trans-lates to cost savings.\nWe show the results in Table 3. We find that GPT-40 can in-deed serve as an annotator for some but not all environments. In DoorKey-7x7 and DynamicObstacles-5x5, LICORICE with GPT-40 labels achieves 83% and 88% of the optimal reward, respectively. The concept error rate is comparable to GPT-40's labeling error, both evaluated on the same rollout observations, with sampling applied to the latter due to cost constraints. Additionally, the concept error gap between our trained concept model and GPT-40 almost diminishes with"}, {"title": "4.3.4 Ablation Study", "content": "Given the previous results, we now conduct ablations to confirm the effectiveness of our three main contributions: iterative training, decorrelation, and active learning. LICORICE-IT corresponds to LICORICE with only one iteration, LICORICE-DE corresponds to LICORICE without decorrelation, and LICORICE-AC corresponds to LICORICE without active learning (instead, it uses the entire unlabeled dataset for querying). We show the learning curves for PixelCartPole-v1 in Figure 1; the full set of curves is in Appendix B.\nTable 4 depicts the results of our ablation study on all environments. The bottom row corresponds to the upper bound on performance by LICORICE, with all components included. All of our contributions are critical to achieving both high reward and low concept error. However, the compo-nent that most contributes to the reward or concept performance differs depending on the environ-ment. For example, compared with LICORICE, LICORICE-IT exhibits the largest reward gap for PixelCartPole-v1; however, LICORICE-AC yields the largest reward gap for DynamicObstacles-5x5, and LICORICE-DE yields the largest gap for DoorKey-7x7. We suspect that this difference is because the concepts in DynamicObstacles-5x5 are simple enough such that one iteration is suffi-cient for learning, meaning that the largest gains can be made by using active learning. In contrast, PixelCartPole-v1 requires further refinement of the policy to better estimate on-distribution concept values, so the largest gains can be made by leveraging multiple iterations."}, {"title": "5 Related Work", "content": "Interpretable Reinforcement Learning Interpretable RL has gained significant attention in recent years [10]. One prominent approach uses rule-based methods such as decision trees [26, 29], logic [8], and programs [30, 19] - to represent policies. These works either assume that the state is already interpretable or that the policy is pre-specified. Unlike prior work, our method involves learning the interpretable representation (through concept training) for policy learning.\nConcept Learning for Reinforcement Learning Inspired by successes in the supervised setting [6, 25, 34], concept-based explanations have recently been incorporated into RL. One approach [7] learns a joint embedding model between state-action pairs and concept-based explanations to expedite learning via reward shaping. Unlike our work, their policy is not a strict function of the concepts, allowing our techniques to be combined to provide both concept-based explanations and a concept-based interpretable policy. Another example, CPM [33], is a multi-agent RL concept architecture that focuses on trade-offs between interpretability and accuracy. They assume that concept labels are available continuously during training. As we have shown, this approach uses over 1M concept labels in our test environments, whereas our approach reduces the need for continuous human intervention, requiring only 500 or fewer concept labels to achieve similar or better performance in single-agent environments.\nLearning Concepts with Human Feedback Another line of work explores how to best leverage human concept labels but not in the RL setting, and does not focus on reducing the labeling burden. In contrast, our approach aims to reduce the concept labeling burden during training. One work [14] instead has users label additional information about the relevance of certain feature dimensions to the concept label. Another work [4] develops an intervention policy at prediction time to choose which concepts to request a label for with the goal of improving the final prediction. Future work could explore using these techniques alongside our method."}, {"title": "6 Discussion and Conclusion", "content": "In this work, we proposed LICORICE, a novel RL algorithm that addresses the critical issue of model interpretability while minimizing the reliance on continuous human annotation. We introduced a training scheme that enables RL algorithms to learn concepts more efficiently from little to no labeled concept data. Our approach interleaves concept learning and RL training, uses an ensemble-based active learning technique to select informative data points for labeling, and uses a simple sampling strategy to better decorrelate the concept data. We demonstrated how this approach reduces manual labeling effort. Finally, we conducted initial experiments to demonstrate how we can leverage powerful VLMs to infer concepts from raw visual inputs without explicit labels in some environments. There are broader societal impacts of our work that must be considered. These include both the impacts of using VLMs in real-world applications, as well as considerations around interpretability more generally. For a more detailed discussion, please refer to Appendix C.\nLimitations and Future Work Although VLMs can be successfully used for automatic labeling of some concepts, there are still hallucination issues [2] and other failure cases, such as providing inaccurate counts. We believe that future work that seeks to improve general VLM capabilities and mitigate hallucinations would also help overcome this limitation. Another exciting direction is the work in human-AI complementarity and learning-to-defer algorithms [18] to train an additional classifier for deferring concept labeling to a person when the chance of making an error is high."}, {"title": "A Experimental Result Reproducibility", "content": "In this section, we provided detailed descriptions to achieve reproducibility."}, {"title": "A.1 Concepts Definitions", "content": "Table 5 provides more details on the concepts used in each environment, categorizing them by their names, types, and value ranges. For the PixelCartPole-v1 environment, all concepts such as Cart Position, Cart Velocity, Pole Angle, and Pole Angular Velocity are continuous. In contrast, the DoorKey-7x7 environment features discrete concepts like Agent Position (x and y), Key Position (x and y), and Door Open status, each with specific value ranges. Similarly, the DynamicObstacles-5x5 environment lists discrete concepts, including Agent and Obstacle positions, with corresponding value ranges.\nWe also visualize the start configurations for DoorKey-7x7 in Figure 2 to illustrate the importance of concept definitions. As shown, the concepts must be defined in such a way to allow the agent to generalize to all possible environment configurations."}, {"title": "A.2 LICORICE Details", "content": "In this section, we provide additional implementation details for LICORICE. The model architecture has been mostly described in the main text and we state all additional details here. The number of neurons in the concept layer is exactly the number of concepts. For continuous concept values, we directly use a linear layer to map from features to concept values. For discrete concept values, since different concepts have different numbers of categories, we create one linear classification head for each single concept, and to predict the final action, we calculate the class with the largest predicted probability for each concept.\nValue-Based Methods If we were to use a value-based method as the RL backbone, we would need to make the following changes. First, we would need to modify V(s, a) or Q(s, a) to include a concept bottleneck, such that Q(s, a) = f(g(s)). Then, we can conduct interleaved training in a similar way to LICORICE.\nFeature Extractor If we use the actor-critic paradigm, we propose to share a feature extractor between the policy and value networks, shown in Figure 3. Intuitively, this choice can offer several advantages compared with using image or predicted concepts as input for both networks. Sharing a feature extractor enables both networks to benefit from a common, rich representation of the input data, reducing the number of parameters to be trained. More importantly, it balances the updates of the policy and value networks. In experiments, we observed that directly using the raw image as input for both networks complicated policy learning. Conversely, relying solely on predicted concepts for the value network may limit its accuracy in value estimation, particularly if the concepts do not capture all the nuances relevant to the value predictions."}, {"title": "A.3 VLM Details", "content": "We detail our prompts for each environment here.\nPixelCartPole-v1\nPrompt: Here are the past 4 rendered frames from the CartPole environment. Please use these images to estimate the following values in the latest frame (the last one):\n\u2022 Cart Position, within the range (-2.4, 2.4)\n\u2022 Cart Velocity\n\u2022 Pole Angle, within the range (-0.2095, 0.2095)\n\u2022 Pole Angular Velocity\nAdditionally, please note that the last action taken was [last action].\nPlease carefully determine the following values and give concise answers one by one. Make sure to return an estimated value for each parameter, even if the task may look challenging.\nFollow the reporting format:\n\u2022 Cart Position: estimated_value\n\u2022 Cart Velocity: estimated_value\n\u2022 Pole Angle: estimated_value\n\u2022 Pole Angular Velocity: estimated_value"}, {"title": "DoorKey-7x7", "content": "Prompt: Here is an image of a 4x4 grid composed of black cells, with each cell either empty or containing an object. Each cell is defined by an integer-valued coordinate system starting at (1, 1) for the top-left cell. The coordinates increase rightward along the x-axis and downward along the y-axis. Within this grid, there is a red isosceles triangle representing the agent, a yellow cell representing the door (which may visually disappear if the door is open), a yellow key icon representing the key (which may disappear), and one green square representing the goal. Carefully analyze the grid and report on the following attributes, focusing only on the black cells as the gray cells are excluded from the active black area.\nDetailed Instructions:\n1. Agent Position: Identify and report the coordinates (x, y) of the red triangle (agent). Ensure the accuracy by double-checking the agent's exact location within the grid.\n2. Agent Direction: Specify the direction the red triangle is facing, which is the orientation of the vertex (pointy corner) of the isosceles triangle. Choose from 'right', 'down', 'left', or 'up'. Clarify that this direction is independent of movement options.\n3. Key Position: Provide the coordinates (x, y) where the key is located. If the key is absent, report as (0, 0). Verify visually that the key is present or not before reporting.\n4. Door Position:\n\u2022 Position: Determine and report the coordinates (x, y) of the door.\n\u2022 Status: Assess whether the door is open or closed (closed means the door is visible as a whole yellow cell, while open means the door disappears visually). Report as 'true' for open and 'false' for closed. Double-check the door's appearance to confirm if it is open or closed.\n5. Direction Movable: Evaluate and report whether the agent can move one cell in each specified direction, namely, the neighboring cell in that direction is active and empty (not key, closed door, or grey inactive cell):\n\u2022 Right (x + 1): Check the cell to the right.\n\u2022 Down (y + 1): Check the cell below.\n\u2022 Left (x - 1): Check the cell to the left.\n\u2022 Up (y - 1): Check the cell above.\nEach direction's feasibility should be reported as 'true' if clear and within the grid, and 'false' otherwise.\nReporting Format: Carefully report each piece of information sequentially, following the format 'name: answer'. Ensure each response is precise and reflects careful verification of the grid details as viewed."}, {"title": "DynamicObstacles-5x5", "content": "Prompt: Here is an image of a 3x3 grid composed of black cells, with each cell either empty or containing an object. Each cell is defined by an integer-valued coordinate system starting at (1, 1) for the top-left cell. The coordinates increase rightward along the x-axis and downward along the y-axis. Within this grid, there is a red isosceles triangle representing the agent, two blue balls representing obstacles, and one green square representing the goal. Please carefully determine the following values and give concise answers one by one:\n1. Agent Position: Identify and report the coordinates (x, y) of the red triangle (agent). Ensure the accuracy by double-checking the agent's exact location within the grid.\n2. Agent Direction: Specify the direction the red triangle is facing, which is the orientation of the vertex (pointy corner) of the isosceles triangle. Choose from 'right', 'down', 'left', or 'up'. Clarify that this direction is independent of movement options.\n3. Obstacle Position: Identify and report the coordinates of the two obstacles in ascending order. Compare the coordinates by their x-values first. If the x-values are equal, compare by their y-values.\n(a) First Obstacle: Provide the coordinates (x, y) of the first blue ball.\n(b) Second Obstacle: Provide the coordinates (x, y) of the second blue ball.\n4. Direction Movable: Evaluate and report whether the agent can move one cell in each specified direction, namely, the neighboring cell in that direction is active and empty (not obstacle or out of bounds):\n\u2022 Right (x + 1): Check the cell to the right.\n\u2022 Down (y+ 1): Check the cell below.\n\u2022 Left (x - 1): Check the cell to the left.\n\u2022 Up (y - 1): Check the cell above.\nEach direction's feasibility should be reported as 'true' if clear and within the grid, and 'false' otherwise.\nReporting Format: Carefully report each piece of information sequentially, following the format 'name: answer'. Ensure each response is precise and reflects careful verification of the grid details as viewed."}, {"title": "A.4 Experimental Details", "content": "For the PPO hyperparameters, we set 4 \u00b7 106 total timesteps for PixelCartPole-v1and DoorKey-7x7, and 106 for DynamicObstacles-5x5. Besides that, for all environments, we use 8 vectorized environments, horizon T = 4096, 10 epochs for training, batch size of 512, learning rate 3 \u00b710-4, entropy coefficient 0.01, and value function coefficient 1. For all other hyperparameters, we use the default values from Stable Baselines 3 [23].\nFor the concept training, we set 100 epochs with Adam optimizer with the learning rate linearly decay-ing from 3 \u00b710-4 to 0 for each iteration in PixelCartPole-v1. In DoorKey-7x7 and DynamicObstacles-5x5, we use the same optimizer and initial learning rate, yet set 50 epochs instead and set early stopping with threshold linearly increasing from 10 to 20, to incentivize the concept network not to overfit in earlier iterations. The batch size is 32.\nFor LICORICE, we set the sample acceptance rate p = 0.05, the ratio for active learning \u03c4 = 10, batch size to query labels in the active learning module b = 20, and the number of ensemble models N = 5. The number of iterations chosen in our algorithm is M = 4 for PixelCartPole-v1and M = 2 for the other two environments.\nWe use NVIDIA A6000 and NVIDIA RTX 6000 Ada Generation. Each of our programs uses less than 2GB GPU memory. For PixelCartPole-v1 and DoorKey-7x7, each run takes less than 9 hours to finish. For DynamicObstacles-5x5, each run takes less than 2 hours to finish.\nFor all experiments, we consistently use 5 seeds [123, 456, 789, 1011, 1213] to train the models. We then evaluate on the environment with seed 42 with 100 episodes and take the average of the reward across the episodes and the concept error across the observations within each episode."}]}