{"title": "Understanding Enthymemes in Argument Maps:\nBridging Argument Mining and Logic-based Argumentation", "authors": ["Jonathan Ben-Naim", "Victor David", "Anthony Hunter"], "abstract": "Argument mining is natural language processing technology aimed at identifying arguments in text.\nFurthermore, the approach is being developed to identify the premises and claims of those arguments,\nand to identify the relationships between arguments including support and attack relationships. In this\npaper, we assume that an argument map contains the premises and claims of arguments, and support and\nattack relationships between them, that have been identified by argument mining. So from a piece of\ntext, we assume an argument map is obtained automatically by natural language processing. However,\nto understand and to automatically analyse that argument map, it would be desirable to instantiate that\nargument map with logical arguments. Once we have the logical representation of the arguments in an\nargument map, we can use automated reasoning to analyze the argumentation (e.g. check consistency\nof premises, check validity of claims, and check the labelling on each arc corresponds with the logical\narguments). We address this need by using classical logic for representing the explicit information in the\ntext, and using default logic for representing the implicit information in the text. In order to investigate\nour proposal, we consider some specific options for instantiation.", "sections": [{"title": "1 Introduction", "content": "Argument mining aims to identify the parts of text that represent arguments (premises and/or claims), and\nthe support or attack relationships between those arguments [LR19]. Using a range of natural language\nprocessing (NLP) technology, with increasing emphasis on large language models, they can be trained to\nidentify arguments and relationships between them with increasing accuracy. The resulting information can\nthen be represented by an argument graph or argument map, where each node contains the text representing\nthe premises and claim of the argument, and each arc denotes a relationship (such as positive/support,\nor negative/attack) between arguments, as illustrated in Figures 1 and 2. In this paper, we assume the\ndifference between an argument graph and argument map is the latter distinguishes between the premises\nand the claim of each argument.\nWhilst argument graphs and maps provide a useful visualizable summary of argumentation in text, there\nis then a lack of automated methods for analysing or reasoning with the information in the argument map.\nTo address this shortcoming, it would be desirable to translate the text into logical arguments, and then\nuse automated reasoning to analyze the arguments (e.g. check consistency of premises, check validity of\nclaims, and check the labelling on each arc corresponds with the logical arguments assigned to the abstract\narguments in the map). Unfortunately, there is a lack of a formal representational framework for bridging\nargument maps and the underlying logical arguments. So this gives us the first problem that we tackle in\nthis paper:\n(Problem 1) How can we represent the explicit information in an argument map, and then\nrepresent that explicit information in a logical rendition of the arguments?"}, {"title": "2 Translation of explicit premise and claim into logic", "content": "We assume the usual propositional and predicate (first-order) languages for classical logic. Let A be the set\nof ground atoms (i.e. propositional atoms and positive ground literals). Let P be the set of propositional\nformulae composed from atoms A and the logical connectives ^, V, \u00ac. Let F be the set of first-order\nformulae composed from a set of function symbols, predicate symbols, the logical connectives A, V, \u00ac,\nand the quantifiers \u2200 and \u2203. Since we are often indifferent as to whether we use the propositional or first-\norder language, we use L to denote a language that can be either a propositional or first-order language. In\nthe examples, we will use teletype font for the logical formulae."}, {"title": "2.1 Argument maps", "content": "We assume an argument map is obtained as output from argument mining of a text (e.g. a discussion doc-\nument). Each node denotes an argument (often with some/all of the premises and/or claim being implicit).\nOften the text in a node appear as a statement rather than a complete argument since either the premises or\nclaim are implicit. We represent an argument map as a tuple as follows.\nDefinition 1. Let T be a set of text strings. An argument map is a tuple $(N, P, C, L)$ where $N$ is a set\nof nodes; $P: N \\rightarrow T\\cup \\{Null\\}$ is a text labelling function for premises; $C: N \\rightarrow T\\cup \\{Null\\}$ is a\ntext labelling function for claims; And $L : N \\times N \\rightarrow \\{+,-,\\square\\}$ is an arc labelling function, where +"}, {"title": "2.2 Logical translation", "content": "Given an argument map, we want to represent each of the premise and the claim by a set of formulae\nof classical logic. The following definition of translation function is a key step in bridging the output of\nargument mining (i.e. the text-based annotation of argument maps) and a logic-based representation of the\nargument map.\nDefinition 2. Let T be a set of text strings. A logical translation is a function $T : T\\cup \\{Null\\} \\rightarrow \\mathcal{P}(L)$\ns.t.$^2$ $T(Null) = \\emptyset$.\nIf there is no text string (i.e. Null), then the translation is \u00d8 (i.e. tautology) which represents no useful\ninformation.\nAtomic translation. The logical translation is a set of propositional atoms. So each text string is assigned\nan atom (as illustrated in Example 1). This allows for different ways that a claim is expressed in\ntext being assigned to the same atom (as illustrated in Example 2). This can be implemented by\na text string classifier where each string is assigned an atom that denotes its class. Assignments\ncan group similar text items to the same atom as in intent classification [GTF+23] or key point\nanalysis [BEK+21]. Also, in an argumentative chatbot system, sentence embeddings have been used\nto classify a user input as to being one of around 1500 arguments in an argument graph in order to\nidentify a counterargument to be given by the chatbot [CH20]."}, {"title": "3 Review of default logic", "content": "We use \u03b1, \u03b2, \u03b3, \u03b4, \u03c6, \u03c8, ... for arbitrary formulae and \u0394, \u0393,... for arbitrary sets of classical formulae.\nWe let $\\vdash$ denote the classical consequence relation, and write $\\Delta \\vdash \\alpha$ to denote that \u0394 is inconsistent.\nAtoms(A) gives the atoms appearing in the formulae in \u2206. Let $Cn$ be the consequence closure function\n(i.e. Cn(A) = {$\\phi | \\Delta \\vdash \\phi $}). For \u03c6, \u03c8 \u2208 L, \u03c6 = \u03c8 denotes that 4 and 4 are equivalent (i.e. {$\u03c6$} $\\vdash$ \u03c8 and\n{\u03c8} $\\vdash$ \u03c6). For \u2206, \u0393 \u2286 L, \u0394 = \u0393 denotes that \u0394 and \u0393 are equivalent (i.e. Cn(\u2206) = Cn(\u0393)).\nAs a basis of representing and reasoning with default knowledge, default logic, proposed by Reiter\n[Rei80], is one of the best known and most widely studied formalisations of default reasoning. Furthermore,\nit offers a very expressive and lucid language."}, {"title": "3.1 Types of default theory", "content": "There are various special cases of default rules that will be useful for our purposes. These include the\nfollowing.\n\u2022 Precondition-free default rule. This is a default rule of the form T : \u03b2/\u03b3 and so the consequent is\nobtained as long as the justification is satisfiable. For example, we might use the following default\nrule to capture the reasoning that anything that is unbroken is usable.\nT:\u00acbroken(X)/useable(X)\n\u2022 Justification-free default rule. This is a default rule of the form \u03b1 : \u03a4/y and so the consequent is\nobtained as long as the precondition holds, and so there is no block by the justification. This would\nmean that we assume that there are no exceptions. For example, we might use the following default\nrule to capture the reasoning that anything that is divisible by two is even.\ndivisablebytwo(X): T/even(X)\n\u2022 Normal default rule. This is a default rule of the form \u03b1 : \u03b2/\u03b2 and so the consequent is obtained\nwhen the precondition holds, and the consequent is satisfiable. For example, we might use the\nfollowing default rule to capture the reasoning that if it is consistent to believe that someone has no\nbrother, then we infer they have no brother.\nperson(X): \u00achasBrother(X)/\u00achasBrother(X)\n\u2022 Semi-normal default rule. This a default rule of the form \u03b1 : \u03b2\u039b \u03b3/\u03b3and so the consequent is ob-\ntained when the precondition holds, and the justification which includes the consequent is satisfiable.\nFor example, we might use the following default rule to capture that a bird flies if it is consistent to\nbelieve that it flies and that it is not a penguin (as we used in Example 5).\nbird(X): penguin (X) \\wedge fly(X)/fly(X)\nFor more coverage of default logic, see [Bes89, Bre91, BDK97]. There are algorithms for automated\nreasoning with default logic [BQQ83, RS94], and scalable implementations of default logic [TDJ22]. Also,\na default theory can be translated into an answer set program (ASP) and an ASP solver used to automate\nthe reasoning [CWZZ10]."}, {"title": "3.2 Singular default theories", "content": "In the next section, we use default logic in our definition for default arguments. For this, the only restriction\nis that the default rules in the premises give a unique extension, and for this we introduce the following\nsubsidiary definition."}, {"title": "4 Default arguments", "content": "We use the singular criteria (Definition 4) in the following definition of a default argument to ensure that\nthe implicit premises (respectively implicit claim) give a single perspective on the explicit premises (re-\nspectively explicit claim). The definition is very general, and we will consider constraints on this definition\nin order to give us appropriate notions of logical argument.\nDefinition 5. A default argument is a tuple $(W^P, D^P, W^C, D^C)$ where $W^P, W^C \\subseteq L$, and $D^P, D^C \\subseteq D$\ns.t. $(D^P, W^P)$ is singular and $(D^C, W^C)$ is singular.\nFor a default argument A = $(W^P, D^P, W^C, D^C)$, we refer to $W^P$ as the explicit premises, $D^P$ as the\nimplicit premises, $W^C$ as the explicit claims, and $D^C$ as the implicit claims. To extract these components\nof a default argument A, we use the following functions: Ep(A) = $W^P$; Ip(A) = $D^P$; Ec(A) = $W^C$; and\nIc(A) = $D^C$.\nAs we will explore in the rest of this paper, a default argument provides a richer representation of\nan argument than available with other approaches to structured argumentation. This includes the follow-\ning features which go beyond other formalisms for logic-based argumentation: Delineatation of implicit\ninformation connecting premises and claims: The set $D^P$ is a set of defaults that represents the im-\nplicit information in the premises; Logical mechanism for disabling connection between premises and\nclaims: The justification of each default rule can be negated by the claim of another argument, thereby\nattacking the connection between the premise and claim; Delineatation of implicit information connect-\ning one argument with another: The set $D^C$ is a set of defaults that represents the implicit information\nin the claim; Logical mechanism for disabling connection between one argument and another: The\njustification of each default rule can be negated by the claim of another argument, thereby attacking the\nconnection between that argument and other arguments.\nLet R be the set of all possible default rules. The set of default arguments from a set of default rules\n$\\Pi \\subseteq R$ is Arguments(II) = {$(W^P, D^P, W^C, D^C)$ | $W^P, W^C \\subseteq L$ and $D^C, D^C \\subseteq \\Pi $}. Using default logic"}, {"title": "5 Relationships between arguments", "content": "We now consider how one default argument supports or attacks another default argument. For this, we will\nrequire some subsidiary definitions. The first is to identify the justifications that arise in the default rules in\nthe premises of an argument using the following definition for the premise justification function, where\nA is an argument.\nJp(A) = {\u03b2 | \u03b1 : \u03b2/\u03b3\u2208 lp(A)}\nWe also require the following variants of the S and C functions. For any default argument A, $C^* (A) =$\n$C(A) \\setminus Cn(\\{T\\})$ and $S^*(A) = S(A) \\setminus Cn(\\{T\\})$. We use $C^*(A)$ and $S^*(A)$ instead of C(A) and S(A) as\nwe want to avoid trivial support involving tautologies.\nWe define the following notions of support relation that hold between a pair of default arguments.\nWhilst there are further kinds of support that we could define, we start with these intuitive options. Es-\nsentially, we restrict the definitions to comparing the explicit claim or consequence (i.e. extension of the\nimplicit and explicit claims) of a supporting argument A (i.e. Ec(A) or C(A)), and the explicit premises,\nor support (i.e. extension of the implicit and explicit premises), or justification, of the supported argument\nB (i.e. Ep(B), or S(B), or Jp(B)), and we restrict the comparison between the supporting and supported\narguments to an intersection between the respective sets of formulae.\nDefinition 8. For default arguments A and B, the following are types of support.\n\u2022 A inferentially supports B iff $S^* (B) \\cap C^* (A) \\neq \\emptyset$.\n\u2022 A directly supports B iff $Ep(B) \\cap C^*(A) \\neq \\emptyset$.\n\u2022 A explicitly supports B iff $Ep(B) \\cap Cn(Ec(A)) \\neq \\emptyset$.\n\u2022 A justification supports B iff $Jp(B) \\cap C^*(A) \\neq \\emptyset$.\nWe explain the above definitions as follows and provide an example below: Inferential support ensures\nthat there is a consequence of A that is a support in B; Direct support ensures that there is a consequence of\nA that is an explicit premise in B; Explicit support ensures that the explicit claim in A implies an explicit\npremise in B; And justification support ensures that there is a consequence of A that is a justification in the\nimplicit premises in B.\nDefinition 9. For default arguments A and B, the following are types of support.\n\u2022 A strongly inferentially supports B iff A inferentially supports B and $S(B) \\subseteq C(A)$.\n\u2022 A strongly directly supports B iff A directly supports B and $Ep(B) \\subseteq C(A)$.\n\u2022 A strongly explicitly supports B iff A explicitly supports B and $Ep(B) \\subseteq Cn(Ec(A))$.\n\u2022 A strongly justification supports B iff A justification supports B and $Jp(B) \\subseteq C(A)$.\nProposition 7. If default argument A directly supports, or explicitly supports, default argument B, then A\ninferentially supports B.\nDefinition 10. For default arguments A and B, the following are types of attack.\n\u2022 A support attacks B iff $C(A) \\cup S(B) \\vdash \\bot$.\n\u2022 A consequence attacks B iff $C(A) \\cup C(B) \\vdash \\bot$.\n\u2022 A justification attacks B iff $C(A) \\cup Jp(B)) \\vdash \\bot$.\nSo a justification attack by an argument negates a justification of default rule used in the attacked\nargument. Note, there is no link between support attacks, consequence attacks, or justification attacks. In\nother words, it is straightforwards to find examples that are instances of one these relations but that are not\ninstance of either of the other two relations.\nDefinition 11. For default arguments A and B, the attacks relation is defined as follows.\n\u2022 A attacks B iff $C(A) \\cup S(B) \\cup Jp(B) \\vdash \\bot$.\nDefinition 12. For default arguments A and B, the types of focused attack are defined as follows.\n\u2022 A undermines B iff there exists \u00ac\u03b2 \u2208 C(A) s.t. $Ep(B) = \\beta$.\n\u2022 A rebuts B iff there exists \u00ac\u03b2\u2208 C(A) s.t. $Ec(B) = \\beta$.\n\u2022 A undercuts B iff there exists \u00ac\u03b2 \u2208 C(A) s.t. there exists \u03b1 : \u03b2/\u03b3 \u2208 $Ip(B)$.\n\u2022 A overcuts B iff there exists \u00ac\u03b2 \u2208 C(A) s.t. there exists \u03b1 : \u03b2/\u03b3 \u2208 $Ic(B)$.\nDefinition 13. For default arguments A and B, some special types of attack are defined as follows.\n\u2022 A explicitly undermines B iff there exists \u00ac\u03b2\u2208 Cn(Ec(A)) s.t. \u03b2\u2208 $Ep(B)$.\n\u2022 A explicitly rebuts B iff there exists \u00ac\u03b2 \u2208 Cn(Ec(A)) s.t. \u03b2 \u2208 $Ec(B)$.\n\u2022 A implicitly undermines B iff A undermines B and A not explicitly undermines B.\n\u2022 A implicitly rebuts B iff A rebuts B and A not explicitly rebuts B.\nProposition 10. For default arguments A and B, suppose each rule in $Ic(B)$ is normal: (1) If A undercuts\nB, then A support attacks B; And (2) if A overcuts B, then A consequence attacks B."}, {"title": "6 Bridging framework", "content": "Now we can address the need to bridge argument maps and logic-based argumentation by producing instan-\ntiated argument maps. The first part of this bridging is the logical translation of premises and claims into\nlogical formulae using a translation function (as discussed in Section 2). The second part of the briding is\nthe instantiation by the logical argument assignment function defined below. This simply assigns a default\nargument to each node in the argument map.\nDefinition 14. Let $M = (N,P,C, L)$ be an argument map and let A be a set of default arguments. A\nlogical argument assignment for M is a function $I : N \\rightarrow A$.\nWe give examples of logical argument assignments in Examples 29 to 32. We give further examples in\nFigure 14 and Figure 15.\nDefinition 15. Let $M = (N, P, C, L)$ be an argument map, let A be a set of default arguments, For each\n$n_i \\in N$, the atomic logical translation function T is such that $T(P(n_i)) = a_i$, $T(C(n_i)) = b_i$. The\npremise atomic logical argument assignment for M is the smallest function $I : N \\rightarrow A$, such that for\nall $n_i, n_j \\in N$,\n\u2022 $Ip(I(n_i)) = \\{(a_i: b_i/b_i)\\};$\n\u2022 if $n_i$ attacks $n_j$ (i.e. $L(n_i, n_j) = \u2212)$, then $(b_i : \u00aca_j/\u00aca_j) \\in Ic(I(n_i))$;\n\u2022 if $n_j$ supports $n_j$ (i.e. $L(n_i, n_j) = +)$, then $(b_i : a_j/a_j) \\in Ic(I(n_i))$."}, {"title": "7 Literature review", "content": "In this section, we consider our proposal for instantiated argument maps with developments in abstract\nbipolar argumentation, structured argumentation including approaches using default logic, and formalisms\nfor handling of enthymemes."}, {"title": "7.1 Bipolar argumentation", "content": "Bipolar argumentation is a generalization of abstract argumentation that incorporates a support relation in\naddition to the attack relation [CL05a, CL05b, ACLL08, CL13]. A bipolar argument graph is a directed"}, {"title": "7.2 Structured argumentation", "content": "Our proposal goes beyond existing proposals for structured argumentation. In Section 4, we have shown\nhow we can capture classical logic deductive arguments as default logic. It is then straightforward to\ncapture the range of attack relationships [BH01, BH08a, GH11] and support relationships [Hun23] in"}, {"title": "7.3 Handling enthymemes", "content": "Most proposals for handling enthymemes in the compuptational argumentation literature either focus on\nthe coding/decoding of enthymemes via abduction [Hun07, BH12, HMR14], and how this can be under-\ntaken within a dialogue [BH08b, dS11b, dS11a, XHMB20, PMB22, LGG23]. However, these proposals do not provide a sys-\ntematic framework for translating argument maps into logic, and concomitantly, addressing the problem of\nidentifying the missing premises and/or claim, and discerning the relationships between them.\nAnother important aspect of dealing with enthymemes is the uncertainty that arises from decoding.\nWhen an audience is listening to participants in a discussion or debate, the participants present arguments\nincluding enthymemes. The way these are presented gives some idea to the audience of which are meant\nto attack which. However, if an argument being attacked is an enthymeme, and the attacking and attacked\narguments are from different participants, then there is uncertainty about whether it is indeed a valid attack.\nEach enthymeme is a representative for an intended argument, but for the audience it may be uncertain\nwhich decoding is the intended argument. The audience may have zero or more choices. This means that\nthe audience takes an argument graph as input, and tries to determine the intended argument graph (i.e. the\ngraph obtained by instantiating each node with its intended argument and deleting the arcs that are not valid\nattacks). This intended argument graph has a structure that would be isomorphic to a spanning subgraph\nof the original argument graph. One way to model this uncertainty is to use the constellations approach\nto probabilistic argumentation, where a probability distribution over these graphs is used to reflect the\nuncertainty [Hun13]."}, {"title": "8 Discussion", "content": "In the real-world, arguments are often enthymemes (i.e. arguments with some premises being implicit).\nThe missing premises have to be abduced by the recipient. These may be obtained from contextual and\nbackground knowledge, and more challengingly, common-sense knowledge. We need to understand en-\nthymemes if we want to make sense of them or respond to them. If we don't understand an enthymeme\nproperly, we can have misunderstandings, and we can talk at cross-purposes.\nArgument mining find sentences representing premises and claims. But there is a lack of a framework\nto then identify the underlying logical arguments. We have addressed this shortcoming by providing the"}]}