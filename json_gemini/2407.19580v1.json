[{"title": "Memory-efficient Training of LLMs with Larger Mini-batches", "authors": ["Dang Nguyen", "Wenhan Yang", "Rathul Anand", "Yu Yang", "Baharan Mirzasoleiman"], "abstract": "Training with larger mini-batches improves the performance and convergence rate of training machine learning models. However, training with large mini-batches becomes prohibitive for Large Language Models (LLMs) with billions of parameters, due to the large GPU memory requirement. To address this problem, we propose finding small mini-batches that simulate the dynamics of training with larger mini-batches. Specifically, we formulate selecting smaller mini-batches of examples that closely capture gradients of large mini-batches as a submodular maximization problem. Nevertheless, the very large dimensionality of the gradients makes the problem very challenging to solve. To address this, we leverage ideas from zeroth-order optimization and neural network pruning to find lower-dimensional gradient estimates that allow finding high-quality subsets effectively with a limited amount of memory. We prove the superior convergence rate of training on the small mini-batches found by our method and empirically show its effectiveness. Our method can effectively reduce the memory requirement by 2x and speed up training by 1.3x, as we confirm for fine-tuning Phi-2 on MathInstruct. Our method can be easily stacked with LoRA and other memory-efficient methods to further reduce the memory requirements of training LLMs.", "sections": [{"title": "1 Introduction", "content": "Large Language Models (LLMs) have achieved remarkable success in a variety of tasks, ranging from machine translation to conversational AI. However, pre-training and fine-tuning LLMs with billions of parameters requires a large amount of compute and GPU memory not only to store the parameters but also to compute gradients and optimizer states, such as momentum and variance in Adam, which is often used for training LLMs. For example, fine-tuning a small language model, such as Phi-2 with 2.7B parameters, with a batch size of 128 requires at least 44 GB of GPU memory. The large memory requirement makes it prohibitive to train such models with larger batch sizes, which can effectively improve the convergence of training and performance of the models. This raises a key question: can we train LLMs with larger batch sizes, using a limited amount of GPU memory?\nTo address this problem, many memory-efficient techniques have been recently proposed, mainly to enable efficient fine-tuning of pre-trained language models. At a high level, such methods try to find a smaller set of parameters [Adelman et al., 2021], or find low-rank [Hu et al., 2021, Zhao et al., 2024] or quantized [Dettmers et al., 2022] weights or optimizer states to train the model in a memory-efficient manner. There have also been efforts to adapt gradient-free optimization for training LLMs [Malladi et al., 2023]. However, most memory-efficient techniques cannot achieve a performance comparable to that of training the full model parameters or considerably increase the training time of LLMs."}, {"title": "2 Related Work", "content": "Memory-efficient training of LLMs. To address the large memory requirements of training LLMs, several methods have been recently proposed. LoRA [Hu et al., 2021] freezes the pre-trained model weights and trains two low-rank adaptor weight matrices to adapt the weights of each layer. Despite gaining memory efficiency, LoRA suffers from a performance drop compared to training with full-rank matrices. To improve upon this, several variations of LoRA [Liu et al., 2024, Renduchintala et al., 2023, Xia et al., 2024b] have been proposed, which aim to preserve the training dynamics of full-parameter training. However, these changes also lead to increased computational costs. GaLore [Zhao et al., 2024] reduces the memory cost of optimizer states during pre-training and fine-tuning by calculating the gradients and projecting them into a low-rank space.\nSeveral methods approximate backpropagation by sparsifying gradients [Frantar and Alistarh, 2023], subsampling the computational graph [Adelman et al., 2021], gradient check-pointing [Chen et al., 2016], and quantization of weights and optimizer states [Dettmers et al., 2022]. However, these approaches can incur large approximation errors and cause performance drops. Zeroth-order gradient approximation has also been used for memory-efficient training. MeZO [Malladi et al., 2023] builds on the traditional zeroth-order methods to estimate gradients using two forward passes, significantly reducing the memory cost of LLM fine-tuning to the same level as LLM inference. However, training with MeZo cannot reach a comparable performance as training the full model parameters.\nOur method can be easily stacked with existing memory-efficient methods to improve convergence and further reduce memory requirements.\nData selection for training LLMs. Data selection for training LLMs has garnered significant attention due to its potential to enhance model performance while reducing computational costs. For pre-training, training on examples with middle Perplexity rankings is shown beneficial [Marion et al., 2023]. Clustering based on embeddings of a pretrained model and sampling from the clusters to drop redundancies has been also investigated [Tirumala et al., 2024].\nFor fine-tuning, training on manually crafted high-quality instruction/response pairs has shown highly beneficial [Zhou et al., 2023a]. Building on this observation, data selection using LLMs such as chat-GPT or training on textbooks is proposed [Chen et al., 2024, Eldan and Li, 2023, Li et al., 2023a,c], and metrics such as diversity [Bukharin and Zhao, 2023, Du et al., 2023], and difficulty [Bhatt et al., 2024, Marion et al., 2023, Zhou et al., 2023b] are shown relevant. Using influence functions to select a subset of the fine-tuning data that is most beneficial for a given validation set has been also explored [Xia et al., 2024a]. Existing methods select data in a one-shot manner before fine-tuning, and either require access to another open LLM or a large preprocessing time to fine-"}, {"title": "3 Problem Formulation and Background", "content": "We consider the task of supervised fine-tuning a large language model \\(f\\) on data \\(\\mathcal{D}\\), containing a set of \\(I\\) prompts and ground-truth responses. Formally, denoting the tokens for the \\(i\\)-th prompt by \\(X_i = [X_{i,1}, X_{i,2},\\cdots]\\) and the tokens in the corresponding response by \\(Y_i = [Y_{i,1}, Y_{i,2},\\ldots, Y_{i,T_{\\mathcal{E}}}]\\), we wish to minimize the following loss function:\n\\[\n\\theta^* = \\arg \\min_{\\theta} L_{\\mathcal{D}}(\\theta), \\quad \\text{s.t.} \\quad L_{\\mathcal{D}}(\\theta) = \\sum_{i=1}^I \\sum_{t=1}^{T} -\\log[Pr(Y_{i,t+1}|x_i, Y_{i,1}\\ldots_{t}, \\theta)].\n\\]\n(1)\nThe standard approach to minimize the above loss function is using mini-batch gradient methods such as mini-batch SGD, which iteratively samples random mini-batches \\(M_t\\) of \\(b\\) examples scaled by the learning rate \\(\\eta\\), and updates the model parameters in the negative direction of the gradient of the mini-batch.\n\\[\n\\theta_{t+1} = \\theta_t - \\eta g_t, \\quad \\text{s.t.} \\quad g_t = \\frac{1}{|M_t|} \\sum_{i \\in M_t} \\nabla L_i(\\theta),\n\\]\n(2)\nwhere \\(L_i(\\theta)\\) is the loss of the \\(i\\)-th prompt. Other stochastic optimizers like Adam [Kingma and Ba, 2014] adapt the learning rate across dimensions by scaling the gradient updates by square roots of exponential moving averages of squared past gradients. In doing so, they reduce the learning rate across sharp dimensions and increase the learning rate across flatter dimensions to improve convergence. In general, training with larger mini-batches effectively improves the convergence rate and performance of the trained models.\nFor random mini-batches that are unbiased estimates of the full gradient, i.e., \\(\\mathbb{E}_{i \\in I}[\\nabla L_i(\\theta)] = \\nabla L(\\theta)\\), as long as the mini-batch size \\(|M_t| = b\\) is not too large, the convergence rate of mini-batch SGD directly scales with a factor of \\(1/b\\). Formally, for a non-convex \\(L\\)-gradient Lipschitz function, mini-batch SGD with a small enough step size will visit an \\(\\epsilon\\)-stationary point with a high probability at least once in the following number of iterations [Ghadimi and Lan, 2013]:\n\\[\n\\mathcal{O}\\left(\\frac{L(L(\\theta_0) - L^*)}{\\epsilon^2} + \\frac{\\sigma^2}{b\\epsilon^2}\\right)\n\\]\n(3)\nwhere \\(\\mathbb{E}_{i \\in I} [(\\nabla L_i(\\theta) - \\nabla L(\\theta))^2] < \\sigma^2\\) is the variance of the individual gradients and \\(b\\) is the mini-batch size. Effectively, the variance of the mini-batches scales with the size of the mini-batches and directly improves the convergence rate. The effect of the mini-batch size on other stochastic optimizers is similar. Nevertheless, for LLMs with billions of parameters, training with large mini-batches requires very large GPU memory and becomes prohibitively expensive. Hence, in practice one needs to train with a small mini-batch size.\nTo improve the convergence and performance of training LLMs, our goal is to find small mini-batches that closely capture the training dynamics with larger mini-batches. Formally, we wish to find a set of smaller mini-batches \\(\\{S_1, S_2, \\ldots \\}\\) of size \\(|S_t| = r < b = |M_t|\\) that are unbiased and have a similar variance to that of larger mini-batches of size \\(b\\). That is,\n\\[\ng_t' = \\frac{1}{|S_t|} \\sum_{i \\in S_t} \\nabla L_i(\\theta) \\approx g_t, \\quad \\text{Vars}_{|S_t|}[g_t'] = \\text{Var}_{|M_t|}[g_t] = \\frac{\\sigma^2}{b},\n\\]\n(4)\nIf such mini-batches can be found efficiently, they can (1) directly improve the convergence rate of mini-batch SGD and subsequently improve the performance; (2) reduce the memory requirement and speed up training by reducing the time required for backpropagating over the large mini-batch.\nDue to the high cost of pre-training, we mainly focus on fine-tuning LLMs in this work, but our problem formulation and approach applies to pre-training LLMs, without further modification."}, {"title": "4 Method", "content": "In this section, we discuss finding smaller mini-batches of examples that can simulate the dynamics of training with large mini-batches."}, {"title": "4.1 Finding the Small Mini-batches", "content": "The key observation is that since larger random mini-batches \\(M_t\\) are unbiased and have a small variance, if we can find small mini-batches \\(S_t\\) such that each \\(S_t\\) closely matches the gradient of the large mini-batches \\(M_t\\), then the small mini-batches will also be unbiased and will have a small variance of \\(\\sigma^2/b\\). Formally, we wish to solve the following optimization problem at every iteration of training with mini-batch stochastic optimization methods, such as mini-batch SGD and Adam:\n\\[\nS_t^* \\in \\arg \\min_{S_t \\subset M_t, |S_t|=r} ||g_t - g_t'||.\n\\]\n(5)\nIn doing so, training on \\(S_t\\) instead of \\(M_t\\) yields the benefits of training with larger mini-batches, including improved convergence and performance. Improved mini-batch selection has recently been shown to boost the convergence of training vision classifiers [Yang et al., 2023]. Nevertheless, solving Problem (5) for LLMs requires addressing several new challenges, as we will discuss below.\nProblem (5) is NP-hard. However, a near-optimal subset can be found efficiently by maximiz- ing the following monotone submodular\u00b9 facility location function [Mirzasoleiman et al., 2020a,b, Pooladzandi et al., 2022]:\n\\[\nS_t^* \\in \\arg \\max_{S_t \\subset M_t, |S_t|=r} \\sum_{i \\in M_t} \\max_{s \\in S_t} [C - ||\\nabla L_i(\\theta) - \\nabla L_s(\\theta) ||],\n\\]\n(6)\nwith a large constant \\(C\\) and assigning a weight \\(\\gamma_s = \\sum_{i \\in M_t} \\mathbb{I}(\\arg \\min_{s \\in S_t} ||\\nabla L_i(\\theta) - \\nabla L_s(\\theta) || = s)\\) to every example \\(s \\in S_t\\). The weighted gradient of the subset \\(g_t' = \\sum_{s \\in S_t} \\gamma_s \\nabla L_s\\) then closely captures the gradient of the larger mini-batch \\(g_t\\).\nA monotone submodular function can be efficiently maximized by applying the greedy algorithm [Wolsey, 1982]. The greedy algorithm commences with an empty set \\(S_0 = \\emptyset\\), and at each step \\(i\\), it selects an element \\(e \\in M_t\\) that maximizes the marginal utility \\(F(e|S_i) = F(S_i \\cup \\{e\\}) - F(S_i)\\). Formally, \\(S_{i+1} = S_{i} \\cup \\{ \\arg \\max_{e \\in M_t} F(e|S_{i}) \\}\\). The time complexity of the greedy algorithm is \\(O(brq)\\) where identify \\(r = |S_t|\\), \\(b = |M_t|\\) and \\(q\\) is the complexity of calculating \\(F\\). The greedy algorithm can be further expedited through lazy evaluation [Minoux, 2005].\nChallenges of finding subsets for LLMs. The facility location formulation in Eq. (6) allows find- ing a near-optimal subset \\(S_t\\) that closely replicates the gradient of \\(M_t\\). Nevertheless, to calculate the value of the function \\(F\\), it requires calculating pairwise distances between gradients of all ex- amples in the large mini-batch \\(M_t\\), which in turn requires calculating the gradients of all examples in \\(M_t\\). However, this does not yield any memory efficiency or speedup. In addition, even if one calculates the full gradients, their very large dimensionality prevents calculating meaningful sim- ilarities. Indeed, pairwise similarities in such high-dimensional gradient vectors become vacuous, and hence a high-quality subset cannot be extracted. In summary, there are two main challenges in finding smaller mini-batches that closely capture the gradient of large mini-batches: (1) finding lower-dimensional gradient estimates without having to explicitly calculate the full gradient of ex- amples in \\(M_t\\), and (2) calculating the lower-dimensional gradients efficiently with a limited about of memory. Next, we will discuss addressing each of these challenges in detail."}, {"title": "4.2 Finding Lower-dimensional Gradient Approximations", "content": "In this section, we address the challenge of finding lower-dimensional gradient estimates efficiently. First, we propose a memory-efficient zeroth-order approach to obtain lower-dimensional gradient estimates. Then, we discuss how we can further reduce the dimensionality of the gradient estimates to enable finding a high-quality subset efficiently with a limited amount of memory."}, {"title": "(1) Obtaining Memory-efficient Zeroth-order Lower-dimensional Gradient Estimates", "content": "First, we discuss calculating memory-efficient and lower-dimensional gradient estimates. To do so, we use Simultaneous Perturbation Stochastic Approximation (SPSA) [Spall, 1992] to get memory- efficient gradient estimates. SPSA estimates the gradient as:\n\\[\n\\widehat{\\nabla L_i(\\theta)} = \\frac{L_i(\\theta + \\epsilon z) - L_i(\\theta - \\epsilon z)}{2 \\epsilon} z \\approx \\epsilon z z^T \\nabla L_i(\\theta),\n\\]\n(7)\nwhere \\(z \\in \\mathbb{R}^d\\) with \\(z \\sim \\mathcal{N}(0, I_d)\\), and \\(d\\) is the number of model parameters and \\(\\epsilon\\) is the perturbation scale. The \\(n\\)-SPSA gradient estimate averages \\(\\widehat{\\nabla L_i(\\theta)}\\) over \\(n\\) randomly sampled \\(z\\).\nSPSA requires two forward passes through the model to compute the gradient estimate for each example. As \\(\\epsilon \\rightarrow 0\\), the SPSA estimate provides a rank-1 reconstruction of the gradient. During training, \\(n\\) is a hyperparameter and can follow a schedule [Bollapragada et al., 2018, Cai et al., 2022]. Nevertheless, for language models \\(n=1\\) is shown to be the most effective [Malladi et al., 2023]. The vanilla calculation of \\(\\widehat{\\nabla L_i}\\) costs twice the memory of inference, as it needs to store \\(z \\in \\mathbb{R}^d\\). However, [Malladi et al., 2023] proposed a memory-efficient way (MeZo) to calculate \\(\\widehat{\\nabla L_i}\\), by first sampling a random seed \\(s\\), and then for each of \\(z\\)'s uses in Eq. (7), the random number generator is reset by \\(s\\) and resample the relevant entry of \\(z\\). Using this in-place implementation, calculating \\(\\widehat{\\nabla L_i}\\) has a memory footprint equivalent to the inference memory cost.\nTraining with MeZo cannot reach a comparable performance as training the full model parameters. Nevertheless, it is accurate enough to find the subsets effectively.\nUsing MeZo to get the last-layer gradients. While MeZo enables calculating full gradients in a memory-efficient manner, full gradients are too high-dimensional to allow finding the subsets effectively. Hence, we need to lower the dimensionality of the gradients before they can be used to find a subset.\nTo do so, we only calculate the last layer gradients, which capture most of the gradient variation [Katharopoulos and Fleuret, 2018]. To get the last layer gradient with MeZo, our key idea is to only sample random perturbations for parameters corresponding to the last layer (\\(\\mathcal{V}\\) projection) in the perturbation vector \\(z\\), and use zero for the other entries. That is,\n\\[\n\\widehat{\\nabla L_i(\\theta_L)} = \\frac{L_i(\\theta + \\epsilon z_L) - L_i(\\theta - \\epsilon z_L)}{2 \\epsilon} z_L,\n\\]\n(8)\nwhere \\(z_L \\in \\mathbb{R}^{d_L}\\) with \\(z = [0_{d-d_L}, z_L]\\) and \\(z_L \\sim \\mathcal{N}(0, I_{d_L})\\), and \\(d_L\\) is the dimensionality of the flattened last layer weight matrix.\nThe above zeroth-order last-layer gradient estimates can be calculated very efficiently in just one forward pass. To do so, we first make a forward pass to get the activations \\(X_{L-1}\\) of the penultimate layer of the network. Then, we only perturb the last-layer parameters twice to calculate \\(\\widehat{\\nabla L_i}\\) based on the pre-calculated \\(X_{L-1}\\). The time of getting the lower dimensional last-layer gradients will be dominated by the time of computing \\(X_{L-1}\\), and the cost of the second step is negligible. For calculating the loss of the perturbed last-layer parameters in a memory-efficient manner, we use a fixed seed to generate the same perturbations \\(z^L\\) multiple times, as is done in MeZo. Hence, the memory overhead is also negligible.\nWhile the dimensionality of the last-layer gradients is considerably lower than the full gradients, they are still too high-dimensional to allow finding high-quality subsets. For example, the dimensionality of the last layer (last \\(\\mathcal{V}\\) projection) of Phi-2 model is \\(2560 \\times 2560 = 6,553,600\\) when training the full parameters and \\(2560 \\times 128 = 327,680\\) when using LoRA. This makes calculating the pair- wise gradient similarity between examples prohibitive and ineffective in practice. Indeed, in such a high-dimensional space, small noisy dimensions dominate the similarity calculation and make them vacuous. This prevents selecting high-quality subsets."}, {"title": "(2) Further Reduce the Dimensionality by Sparsifying the Last-layer Gradients", "content": "To further reduce the dimensionality of the gradient estimates, we sparsify the last-layer gradients to obtain lower-dimensional gradients in a memory-efficient way. Our goal is to find a small number of dimensions in the last (\\(\\mathcal{V}\\) projection) layer which yields a similar loss reduction to that of the full gradient, at one parameter update step. As shown below, the gradient norm indicates, to the first"}, {"title": "4.3 Method: Select Small Mini-batches (SSM)", "content": "We summarize our method here. At every iteration of training, we sample a large mini-batch of ex- amples. Then, we use MeZo to find memory-efficient estimates of last-layer gradients for examples in the large mini-batch. This can be done efficiently with just one forward pass. We further reduce the dimensionality of the gradient estimates by selecting the top \\(k\\) dimensions with the highest mag- nitude. We calculate the pairwise similarity between the lower-dimensional gradient estimates using \\(l_1\\) distance. \\(l_1\\) distance preserves the distances better in high-dimensional spaces and is consistently more preferable than Euclidean distance [Aggarwal et al., 2001]. Finally, we find a small mini-batch from every large random batch during the training by applying the greedy algorithm to maximize the submodular facility location function in Eq. (6). We do not assign weights (\\(\\gamma\\)) to gradients of examples in the subset, to effectively reduce the redundancy in the data and balance different groups of examples.\nThe following theorem shows that as long as the smaller mini-batches closely mimic the gradient of the large batches, training with SSM imitates the training dynamics with large batches. Thus, it improves convergence and performance, compared to training with small random mini-batches.\nTheorem 4.1. As long as \\(\\mathbb{E}[||g_t - g_t'||] \\le ||\\nabla L(\\theta_t)||\\) and learning rate is small enough, minimizing a non-convex L-gradient Lipschitz function with mini-batches of size r < b found by SSM from larger mini-batches of size b will visit an \\(\\epsilon\\)-stationary point with a high probability at least once in"}, {"title": "5 Experiments", "content": "In this section, we evaluate the performance of our method, SSM, for fine-tuning LLMs. We com- pare the performance, memory requirement, and wall-clock training time of training with small and large random mini-batches, with that of our method. We also do an ablation study showing the effectiveness of different design choices of SSM."}, {"title": "5.1 Settings", "content": "Datasets. We fine-tune the MathInstruct [Yue et al., 2023] dataset for the mathematical reasoning task. This dataset consists of about 260K instruction tuning examples, which are curated from 13 open-source math datasets. MathInstruct has a broad coverage of mathematical fields and a wide range of difficulty levels. Fine-tuning LLMs on MathInstruct has shown state-of-the-art performance on a variety of standard math evaluation benchmarks.\nModels. We utilize the Phi-2 model [Li et al., 2023b], a 2.7 billion-parameter language model by Microsoft Research. Phi-2 achieves high performance on various benchmarks despite its smaller size. Utilizing high-quality, curated training data and advanced scaling techniques, Phi-2 outper- forms much larger models on multi-step reasoning tasks.\nTraining details. Following the setup used in [Yue et al., 2023], we adopt a training regime with a learning rate of 2e-5 and a cosine scheduler with a 3% warm-up period, i.e. the learning rate linearly increases from 0 to 2e-5 over the first 3% of training steps, then follows a cosine decay to 0 at the end of training. We set a maximum sequence length of 512. For all experiments on MathInstruct, we standardize the number of gradient steps to correspond to 1K, unless explicitly specified. We use LoRA with a rank of 128, alpha of 512, and dropout rate of 0.05. For Phi-2, we apply LORA for all attention matrices (QKV_proj) and two fully connected layers. All experiments are run on 4 NVIDIA A40 GPUs. We ran each experiment three times.\nEvaluation datasets. We adopt the framework established in [Yue et al., 2023], leveraging a vari- ety of popular datasets across both in-domain and out-of-domain datasets. The in-domain datasets include GSM8K [Cobbe et al., 2021], MATH [Hendrycks et al., 2021], and NumGLUE [Mishra et al., 2022]. For the out-of-domain datasets, we include SVAMP [Patel et al., 2021], Mathematics [Davies et al., 2021], and SimulEq [Koncel-Kedziorski et al., 2016]. These datasets collectively cover a wide range of mathematical areas such as algebra, probability, number theory, calculus, and geometry. Furthermore, some questions in these datasets require the application of commonsense, reading comprehension, and multi-step reasoning. All questions are formatted as open-ended.\nEvaluation metric. We use the standard evaluation metric for open-formed questions, exact match, which measures the model's accuracy by comparing its generated answers against the correct solu- tions. For an answer to be considered correct, it must match the reference solution precisely. We evaluate under the 0-shot setting with a maximum sequence length of 2048 tokens for decoding. The default prompt is Program-of-Thought (PoT), falling back to Chain-of-Thought (CoT) prompting if the former does not work [Yue et al., 2023]."}, {"title": "5.2 Main results", "content": "SSM achieves a superior performance with limited memory. Tab 1 shows the in-distribution and out-of-distribution accuracies when LoRA fine-tuning Phi-2 on the MathInstruct dataset for 1K and 2K iterations. We see that larger mini-batches (bs=128) generally outperform training with smaller mini-batches (bs=64), given the same number of training iterations. This is consistent with our the- oretical results. By closely capturing the gradients of larger mini-batches, SSM effectively outper- forms training with random mini-batches of the same size. Moreover, we see that training with more iterations also improves the performance on both in-domain and out-domain evaluation datasets as indicated by an increase in the performance of all methods from iteration 1K to 2K. Notably, SSM improves the performance of training with both smaller and larger mini-batches throughout the train- ing process as depicted in Fig 1. Averaging over all datasets, SSM improves the performance over training with smaller mini-batches by 3.9% at iteration 1K and 1.2% at iteration 2K.\nSSM speeds up training and improves convergence. Fig. 2 compares the wall-clock time and the average performance of LoRA fine-tuned Phi-2 with different mini-batch sizes. For 1K train- ing steps, when SSM selects smaller mini-batches of 64 examples from 128, it speeds up training by 1.3x, compared to training with a mini-batch size of 128, while halving the memory consump- tion. On the other hand, while using the same memory budget, SSM yields a roughly 4% higher performance compared to models trained with a smaller mini-batch size of 64."}, {"title": "5.3 Ablation studies", "content": "The importance of weighted sampling. Tab 2 highlights the importance of weighted sampling in SSM. Weighted sampling ensures samples from different data sources are equally represented in the larger mini-batch, improving the accuracy significantly by 2.5% on average."}, {"title": "6 Conclusion", "content": "In this work, we proposed a memory-efficient approach to train Large Language Models (LLMs). Our method efficiently finds small mini-batches of examples that closely capture gradients of large random mini-batches. In doing so, it simulates training with large mini-batches using a small amount of memory. We formulated the problem as a submodular maximization problem based on pairwise gradient similarities between examples in the large mini-batch. To address the challenges of finding subsets based on the very high-dimensional gradients of LLMs, we leveraged ideas from zeroth- order optimization and neural network pruning to find lower-dimensional gradient estimation that allows finding high-quality subsets effectively with a limited amount of memory. We proved the superior convergence rate of training on the small mini-batches found by our method and empirically showed its effectiveness for fine-tuning Phi-2 on MathInstruct to solve challenging math problems."}, {"title": "A Proof of Theorem 4.1", "content": "We build on the analysis of [Ghadimi and Lan", "2023": "and characterize the effect of the small mini-batch gradient errors on the convergence.\nFor a L-gradient Lipschitz function L we have:\n\\[\n|L(\\theta_1) - L(\\theta_2) - \\langle \\nabla L(\\theta_2)", "theta_2||^2.\n\\": "n(11)\nThe gradient descent updates when training on mini-batches found by SSM can be written as fol- lows:\n\\[\n\\theta_{t+1"}, "leftarrow \\theta_t - \\eta_t(\\nabla L(\\theta_t) + \\zeta_t), \\quad \\text{s.t.} \\quad \\zeta_t = \\delta_t + \\varepsilon_t\n\\"], "have": "n\\[\nL(\\theta_{t+1"}, {"obtain": "n\\[\n\\sum_{t=1}^N \\left(\\eta_t - \\frac{L \\eta_t^2}{2}\\right) ||\\nabla L(\\theta_t)||^2 \\leq L(\\theta_0) - L(\\theta_{N+1}) - \\sum_{t=1}^N \\eta_t \\langle \\nabla L(\\theta_t), \\delta_t + \\varepsilon_t \\rangle + \\frac{L}{2} \\sum_{t=1}^N \\eta_t^2 ||\\delta_t + \\varepsilon_t||^2\n\\]\n(17)\n\\[\n< L(\\theta_0) - L^* - \\sum_{t=1}^N \\eta_t \\langle \\nabla L(\\theta_t), \\delta_t + \\varepsilon_t \\rangle + \\frac{L}{2} \\sum_{t=1}^N \\eta_t^2 ||\\delta_t + \\varepsilon_t||^2\n\\]\n(18)\n\\[\n= L(\\theta_0) - L^* - \\sum_{t=1}^N \\eta_t \\langle \\nabla L(\\theta_t), \\zeta_t \\rangle + \\frac{L}{2} \\sum_{t=1}^N \\eta_t^2 ||\\zeta_t||^2\n\\]\n(19)\n\\[\nL(\\theta_0) - L^* - \\sum_{t=1}^N \\eta_t \\langle \\nabla L(\\theta_t), \\delta_t + \\varepsilon_t"}]