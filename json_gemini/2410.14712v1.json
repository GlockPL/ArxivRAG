{"title": "Abstracting Situation Calculus Action Theories", "authors": ["Bita Banihashemi", "Giuseppe De Giacomo", "Yves Lesp\u00e9rance"], "abstract": "We develop a general framework for agent abstraction based on the situation calculus and the ConGolog agent programming language. We assume that we have a high-level specification and a low-level specification of the agent, both represented as basic action theories. A refinement mapping specifies how each high-level action is implemented by a low-level ConGolog program and how each high-level fluent can be translated into a low-level formula. We define a notion of sound abstraction between such action theories in terms of the existence of a suitable bisimulation between their respective models. Sound abstractions have many useful properties that ensure that we can reason about the agent's actions (e.g., executability, projection, and planning) at the abstract level, and refine and concretely execute them at the low level. We also characterize the notion of complete abstraction where all actions (including exogenous ones) that the high level thinks can happen can in fact occur at the low level. To facilitate verifying that one has a sound/complete abstraction relative to a mapping, we provide a set of necessary and sufficient conditions. Finally, we identify a set of basic action theory constraints that ensure that for any low-level action sequence, there is a unique high-level action sequence that it refines. This allows us to track/monitor what the low-level agent is doing and describe it in abstract terms (i.e., provide high-level explanations, for instance, to a client or manager).", "sections": [{"title": "1. Introduction", "content": "Autonomous agents often operate in complex domains and have complex behaviors.\u00b9 Reasoning about such agents and even describing their behavior can be difficult. One way to cope with this is to use abstraction [64]. In essence, this involves developing an abstract model of the agent/domain that suppresses less important details. The abstract model allows us to reason more easily about the agent's possible behaviors and to provide high-level explanations of the agent's behavior. To efficiently solve a complex reasoning problem, e.g. planning, one may first try to find a solution in the abstract model, and then use this abstract solution as a template to guide the search for a solution in the concrete model. Systems developed using abstractions are typically more robust to change, as adjustments to more detailed levels may leave the abstract levels unchanged.\nIn this paper, we develop a general framework for agent abstraction based on the situation calculus [52, 62] and the ConGolog [21] agent programming language. We assume that one has a high-level/abstract action theory, a low-level/concrete action theory, and a refinement mapping between the two. The mapping associates each high-level primitive action to a (possibly non-deterministic) ConGolog program defined over the low-level action theory that \"implements it\u201d. Moreover, it maps each high-level fluent to a state formula in the low-level language that characterizes the concrete conditions under which it holds.\nIn this setting, we define a notion of a high-level theory being a sound abstraction of a low-level theory under a given refinement mapping. The formalization involves the existence of a suitable bisimulation relation [54, 55] relative to a mapping between models of the low-level and high-level theories. With a sound abstraction, whenever the high-level theory entails that a sequence of actions is executable and achieves a certain condition, then the low level must also entail that there exists an executable refinement of the sequence such that the \u201ctranslated\u201d condition holds afterwards. Moreover, whenever the low level thinks that a refinement of a high-level action (perhaps"}, {"title": "2. Preliminaries", "content": "The Situation Calculus and Basic Action Theories. The situation calculus is a well known predicate logic language for representing and reasoning about dynamically changing worlds [52, 62]. All changes to the world are the result of actions, which are terms in the language. A possible world history is represented by a term called a situation. The constant So is used to denote the initial situation. Sequences of actions are built using the function symbol do, such that do(a, s) denotes the successor situation resulting from performing action a in situation s. Predicates and functions whose value varies from situation to situation are called fluents, and are denoted by symbols taking a situation term as their last argument. For example, we may have that Door1 is not open in the initial situation So, i.e., \u00acIsOpen(Door1, So) holds, but is open in the situation that results from doing the action open(Door1) in So, i.e., IsOpen(Door1, do(open(Door1), So) holds. s \u2291 s' means that s is a predecessor situation of s', and s \u2286 s' stands for s = s' \u2228 s \u2291 s'. The abbreviation do([a1,..., an], s) stands for do(an, do(an-1, ..., do(a\u2081, s) . . .)); also for an action sequence \u03b1, we often write do(\u00e3, s) for do([a], s).\nWithin this language, one can formulate action theories that describe how the world changes as a result of the available actions. Here, we concentrate on basic action theories as proposed in [60, 62]. We also assume that there is a finite number of action types A. Moreover, we assume that the terms of object sort are in fact a countably infinite set N of standard names for which we have the unique name assumption and domain closure.\u00b2 For simplicity, and w.l.o.g., we assume that there are no functions other than constants and no non-fluent predicates. As a result, a basic action theory D is the union of the following disjoint sets of first-order (FO) and second-order (SO) axioms:"}, {"title": "\u2022 Dso: (FO) initial situation description axioms describing the initial configuration of the world (such a description may be complete or in- complete);", "content": "Dso: (FO) initial situation description axioms describing the initial configuration of the world (such a description may be complete or in- complete);"}, {"title": "\u2022 Dposs: (FO) precondition axioms of the form Poss(A(x), s) = \u03c6PossA(x, s), one per action type, stating the conditions \u03c6Poss A(x, s) under which an action A(x) can be legally performed in situation s; these use a special predicate Poss(a, s) meaning that action a is executable in situation s; \u03c6A(x, s) is a formula of the situation calculus that is uniform in s;", "content": "Dposs: (FO) precondition axioms of the form\nPoss(A(x), s) = \u03c6_{A}^{Poss}(x, s),\none per action type, stating the conditions \u03c6_{A}^{Poss}(x, s) under which an action A(x) can be legally performed in situation s; these use a special predicate Poss(a, s) meaning that action a is executable in situation s; \u03c6A(x, s) is a formula of the situation calculus that is uniform in s;\u00b3"}, {"title": "\u2022 Dssa: (FO) successor state axioms of the form F(x, do(a, s)) = \u03c6ssa F(x, a, s), one per fluent, describing how the fluent changes when an action is performed; the right-hand side (RHS) \u03c6ssa F(x, a, s) is again a situation calculus formula uniform in s; successor state axioms encode the causal laws of the world being modeled; they take the place of the so-called effect axioms and provide a solution to the frame problem;", "content": "Dssa: (FO) successor state axioms of the form\nF(x, do(a, s)) = \u03c6_{F}^{ssa}(x, a, s),\none per fluent, describing how the fluent changes when an action is performed; the right-hand side (RHS) \u03c6_{F}^{ssa}(x, a, s) is again a situation calculus formula uniform in s; successor state axioms encode the causal laws of the world being modeled; they take the place of the so-called effect axioms and provide a solution to the frame problem;"}, {"title": "\u2022 Dea: (FO) unique name axioms for actions and (FO) domain closure on action types;", "content": "Dea: (FO) unique name axioms for actions and (FO) domain closure on action types;"}, {"title": "\u2022 Dcoa: (SO) unique name axioms and domain closure for object constants in N;", "content": "Dcoa: (SO) unique name axioms and domain closure for object con- stants in N;"}, {"title": "\u2022 \u03a3: (SO) foundational, domain independent, axioms of the situation calculus [60].", "content": "\u03a3: (SO) foundational, domain independent, axioms of the situation calculus [60]."}, {"title": "High-Level Programs", "content": "To represent and reason about complex actions or pro- cesses obtained by suitably executing atomic actions, various so-called high- level programming languages have been defined. Here we concentrate on (a fragment of) ConGolog [21] that includes the following constructs:\n\u03b4 ::= \u03b1 | \u03c6? | \u03b4\u2081; \u03b42 | \u03b4\u2081|\u03b42 | \u03c0x.\u03b4 | \u03b4* | \u03b41||\u03b42\nIn the above, \u03b1 is an action term, possibly with parameters, and \u03c6 is a situation-suppressed formula, i.e., a formula with all situation arguments in fluents suppressed. We denote by \u03c6[s] the formula obtained from \u03c6 by restoring the situation argument s into all fluents in \u03c6. The test action \u03c6? checks if condition \u03c6 holds in the current situation. The sequence of program \u03b41 followed by program \u03b42 is denoted by \u03b41; \u03b42. Program \u03b41 | \u03b42 allows for the nondeterministic choice between programs \u03b41 and \u03b42, while \u03c0x.\u03b4 executes program \u03b4 for some nondeterministic choice of a legal binding for variable x (observe that such a choice is, in general, unbounded). \u03b4* performs \u03b4 zero or more times. Program \u03b41 ||\u03b42 expresses the concurrent execution (interpreted as interleaving) of programs \u03b4\u2081 and \u03b42. We also use nil, an abbreviation for True?, to represent the empty program, i.e., when nothing remains to be performed.\nFormally, the semantics of ConGolog is specified in terms of single-step transitions, using the following two predicates [21]: (i) Trans(\u03b4, s, \u03b4', s'), which holds if one step of program \u03b4 in situation s may lead to situation s' with \u03b4' remaining to be executed; and (ii) Final(\u03b4, s), which holds if program \u03b4 may legally terminate in situation s. The definitions of Trans"}, {"title": "3. Refinement Mappings", "content": "Suppose that we have a basic action theory Di and another basic action theory Dh. We would like to characterize whether D\u0127 is a reasonable abstraction of Dr. Here, we consider D\u012b as representing the low-level (LL) (or concrete) action theory/agent and Dh the high-level (HL) (or abstract) action theory/agent. We assume that Dh (resp. D\u0131) involves a finite set of primitive action types Ah (resp. A\u2081) and a finite set of primitive fluent predicates Fh (resp. F\u2081). For simplicity, we assume that Dh and Di, share no domain specific symbols except for the set of standard names for objects N.\nWe want to relate expressions in the language of Dh and expressions in the language of Dr. We say that a function m is a refinement mapping from Dh to Di if and only if:\n1. for every high-level primitive action type A in Ah, m(A(x)) = \u03b4(x), where \u03b4\u2081(7) is a ConGolog program over the low-level theory Di whose only free variables are 2, the parameters of the high-level action type; intuitively, \u03b4() represents how the high-level action A(z) can be im- plemented at the low level; since we use programs to specify the action"}, {"title": "Example", "content": "For our running example, we use a simple logistics domain. There is a shipment with ID 123 that is initially at a warehouse (W), and needs to be delivered to a cafe (Cf), along a network of roads shown in Figure 1.\nHigh-Level BAT D9. At the high level, we abstract over navigation and delivery procedure details. We have actions that represent choices of major routes and delivering a shipment. D\u2079 includes the following precondition axioms (throughout the paper, we assume that free variables are universally"}, {"title": "4. m-Bisimulation", "content": "To relate high-level and low-level models/theories, we resort to a suitable notion of bisimulation, i.e., one that is relative to the refinement mapping. Let M\u2081 be a model of the high-level BAT D\u0127, Mi a model of the low-level BAT DUC, and m a refinement mapping from Dh to Di.\nWe first define a local condition for the bisimulation. We say that situa- tion sh in Mh is m-isomorphic to situation si in M\u2081, written sh \u2243~_{M_h, M_i}^{m} s_i, if and only if\nM_{h}, v[s/s_{h}] |= F(x, s) if and only if M_{l}, v[s/s_{l}] |= m(F(x))[s]\nfor every high-level primitive fluent F(x) in F\u0127 and every variable assignment v (v[x/e] stands for the assignment that is like v except that x is mapped to e), i.e., sh and si interpret all high-level fluents the same.\nA relation B \u2286 \u2206Mh \u00d7 \u2206Mi (where \u2206 stands for the situation domain of M) is an m-bisimulation relation between M\u0127 and M\u0131 if (sh,s\u0131) \u2208 B implies that:\n1. sh \u2243~_{M_h, M_i}^{m} s_i, i.e., sh in M\u0127 is m-isomorphic to situation s\u0131 in M\u2081;\n2. for every high-level primitive action type A in An, if there exists sh such that Mh, v[s/sh,s'/sh] |= Poss(A(x), s) \u2227 s' = do(A(x), s), then there exists s' such that M\u2081, v[s/s\u0131, s'/s] |= Do(m(A(x)), s, s') and (s'h, s\u00ed) \u2208 B, i.e., if A(x) is executable in the high-level model at sh, then the program that implements A(z) must be executable in the low-level model at si, and the resulting pair of situations s'h and s must be bisimilar;\n3. for every high-level primitive action type A in Ah, if there exists s' such that M\u2081, v[s/s\u0131, s'/s] |= Do(m(A(x)), s, s'), then there exists sh such that Mh, v[S/sh,s'/sh] |= Poss(A(x), s) \u2227 s' = do(A(x), s) and (sh, s\u00ed) \u2208 B, i.e., if the program that implements A(z) is executable in the high- level model at s\u0131, then A(z) must be executable in the high- level model at sh, and the resulting pair of situations s'h and s must be bisimilar."}, {"title": "5. Sound Abstraction", "content": "To ensure that the high-level theory is consistent with the low-level theory and mapping m, we may require that for every model of the low-level theory, there is an m-bisimilar structure that is a model of the high-level theory.\nWe say that Dh is a sound abstraction of Di relative to refinement map- ping m if and only if, for every model M\u012b of Di UC, there exists a model Mh of Dh such that Mh ~m Mi.\nSound abstractions have many interesting and useful properties. First, from the definition of sound abstraction and Theorem 3, we immediately get the following result:\nCorollary 4. Suppose that Dh is a sound abstraction of Di relative to map- ping m. Then for any sequence of ground high-level actions \u03b1 and for any high-level situation-suppressed formula \u03c6, if D\u0131 UCU {\u2203s.Do(m(a), So, s) \u2227 m(\u03c6)[s]} is satisfiable, then Dh \u222a {Executable(do(\u03b1, So)) \u2227 \u03c6[do(\u03b1, So)]} is also satisfiable. In particular, if D\u2081 UCU {\u2203s.Do(m(a), So, s)} is satisfiable, then Dh \u222a {Executable(do(a, So))} is also satisfiable.\nThus if the low-level agent/theory thinks that a refinement of \u03b1 (perhaps involving exogenous actions) may occur (with m(\u03c6) holding afterwards), the high-level agent/theory also thinks that \u03b1 may occur (with \u03c6 holding after- wards). If we observe that such a refinement actually occurs it will thus be consistent with the high-level theory.\nWe can also show that if the high-level theory entails that some sequence of high-level actions \u03b1 is executable, and that in the resulting situation, a situation-suppressed formula \u03c6 holds, then the low-level theory must also en- tail that some refinement of \u03b1 is executable and that in the resulting situation m(\u03c6) holds:\nTheorem 5. Suppose that D\u0127 is a sound abstraction of Di relative to map- ping m. Then for any ground high-level action sequence a and for any high-level situation-suppressed formula \u03c6, if Dh |= Executable(do(\u03b1, So)) \u2227 \u03c6[do(a, So)], then D\u2081 UC |= \u2203s.Do(m(a), So, s) \u2227m(\u03c6)[s]."}, {"title": "6. Complete Abstraction", "content": "When we have a sound abstraction Dh of a low-level theory D\u2081 with re- spect to a mapping m, the high-level theory Dh's conclusions are always"}, {"title": "7. Monitoring and Explanation", "content": "A refinement mapping m from a high-level action theory Dh to a low- level action theory D\u012b tells us what are the refinements of high-level actions into executions of low-level programs. In some application contexts, one is interested in tracking/monitoring what the low-level agent is doing and describing it in abstract terms, e.g., to a client or manager. If we have a ground low-level situation term S\u012f such that D\u2081 \u222a {Executable(S\u2081)} is satis- fiable, and D\u2081 \u222a {Do(m(a), So, S\u0131)} is satisfiable, then the ground high-level action sequence a is a possible way of describing in abstract terms what has occurred in getting to situation St. If Dh \u222a {Executable(do(a, So))} is also satisfiable (it must be if Dh is a sound abstraction of D\u012b with re- spect to m), then one can also answer high-level queries about what may hold in the resulting situation, i.e., whether Dh\u222a {Executable(do(a, So)) \u2227 (do(a, So))} is satisfiable, and what must hold in such a resulting situation, i.e., whether Dh\u222a {Executable(do(\u03b1, So))} |= \u03c6(do(\u03b1, So)). One can also an- swer queries about what high-level action \u00df might occur next, i.e., whether Dh\u222a {Executable(do(\u03b1\u03b2, So))} is satisfiable.\nIn general, there may be several distinct ground high-level action se- quences a that match a ground low-level situation term S\u2081; even if we have complete information and a single model M\u2081 of Di UC, i.e., we may have M\u2081 |= Do(m(61), So, S\u0131) \u2227 Do(m(&2), So, S\u0131) and Dh |= 01 \u2260 02.6\nIn many contexts, this would be counter-intuitive and we would like to be able to map a sequence of low-level actions performed by the low-level agent back into a unique abstract high-level action sequence it refines, i.e., we would like to define an inverse mapping function m\u207b\u00b9. Let's see how we can do this. First, we introduce the abbreviation lpm(s, s'), meaning that s' is a largest prefix of s that can be produced by executing a sequence of high-level actions:\nlpm(s, s') = Do(ANYSEQHL, So, s') \u2227s' \u2291 s\u2227\n\u2200s''.(s' < s'' < s \u2283 \u00acDo(ANYSEQHL, So, s''))\nWe can show that the relation lpm(s, s') is actually a total function:\nTheorem 17. For any refinement mapping m from Dh to Di, we have that:"}, {"title": "8. Related Work", "content": "Given the importance of abstraction in AI, it is unsurprising that there has been much previous work on the topic. Among logical theories of ab- straction, Plaisted [61] is perhaps the first to propose a general theory of abstraction focused on theorem proving (and in particular on resolution) in a first-order language. He proposed a notion of abstraction as a mapping from a set of clauses B to a simpler (i.e., more abstract) set of clauses A that satisfied certain properties with respect to the resolution mechanism. Resolution proofs from B map onto (possibly) simpler resolution proofs in A. Plaisted introduced different types of syntactic abstraction mappings, including renaming predicate and function symbols, where several predicates (resp. functions) could be renamed to the same predicate (resp. function) in the abstract clause. Plaisted was aware that this approach could yield an abstract theory that produces inferences that are not sanctioned by the base theory, and called this issue the \u201cfalse proof"}, {"title": "9. Adaptations and Extensions of the Abstraction Framework", "content": "Since it first appeared in [4], our abstraction framework has been adapted, used, and extended in various directions. We summarize such work in this section.\nSome work has addressed the issue of automated verification and synthe- sis of abstractions. In [51], Luo et al. investigate the relationship between our account of agent abstraction and the well-known notion of forgetting in first-order/second-order logic. They also address the problem of synthesizing a sound and complete abstraction given a low-level BAT and a refinement mapping. They show that one can use forgetting (of low-level fluent and action symbols) to obtain second-order theory that is a sound and complete abstraction of a low-level BAT for a given mapping, provided that the map- ping is nondeterministic uniform (NDU) with respect to the low-level BAT, i.e, such that different refinements of a high-level action sequence are in-"}, {"title": "10. Conclusion", "content": "In this paper, we proposed a general framework for agent abstraction based on the situation calculus and ConGolog. We defined a notion of a high-level basic action theory (BAT) being a sound/complete abstraction of a low-level BAT with respect to a given mapping between their respective languages. This formalization involved the existence of a bisimulation re- lation relative to the mapping between models of the abstract and concrete theories. Furthermore, we identified a set of necessary and sufficient con- ditions for checking if one has a sound and/or complete abstraction with respect to a mapping. We have shown that sound abstractions have many useful properties that ensure that we can reason about the agent's actions (e.g., executability, projection, and planning) at the abstract level, and refine and concretely execute them at the low level. Finally, we identified a set of BAT constraints that ensure that for any low-level action sequence, there is a unique high-level action sequence that it refines. This is useful for monitoring"}, {"title": "Appendix A. Proofs", "content": ""}, {"title": "Appendix A.1. m-Bisimulation", "content": ""}, {"title": "Appendix A.2. Sound Abstraction", "content": ""}, {"title": "Appendix A.3. Complete Abstraction", "content": ""}, {"title": "Appendix A.4. Monitoring and Explanation", "content": ""}, {"title": "Appendix B. Additional Details on ConGolog Semantics", "content": "The definitions of Trans and Final for the ConGolog constructs used in this paper are as in [25]. Note that since Trans and Final take programs (that include tests of formulas) as arguments, this requires encoding formulas and programs as terms; see [21] for details.\nThe predicate Trans is characterized by the following set of axioms:\nTrans(a, s, \u03b4', s') = s' = do(a, s) \u2227 Poss(a, s) \u2227 \u03b4' = True?\nTrans(\u03c6?, s, \u03b4', s') = False\nTrans(\u03b41; \u03b42, s, \u03b4', s') =\nTrans(\u03b41, s, \u03b4'\u2081, s') \u2227 \u03b4' = \u03b4'\u2081; \u03b42 \u2228\nFinal(\u03b41, s) \u2227 Trans(\u03b42, s, \u03b4', s')\nTrans(\u03b41|\u03b42, s, \u03b4', s') = Trans(\u03b41, s, \u03b4', s') \u2228 Trans(\u03b42, s, \u03b4', s')\nTrans(\u03c0x.\u03b4, s, \u03b4', s') = \u2203x.Trans(\u03b4, s, \u03b4', s')\nTrans(\u03b4*, s, \u03b4', s') = Trans(\u03b4, s, \u03b4'', s') \u2227 \u03b4' = \u03b4''; \u03b4*\nTrans(\u03b41||\u03b42, s, \u03b4', s') =\nTrans(\u03b41, s, \u03b4'\u2081, s') \u2227 \u03b4' = \u03b4'\u2081||\u03b42 \u2228\nTrans(\u03b42, s, \u03b4'\u2082, s') \u2227 \u03b4' = \u03b4'\u2082||\u03b42\nThe predicate Final is characterized by the following set of axioms:\nFinal(a, s) = False\nFinal(\u03c6?, s) = \u03c6[s]\nFinal(\u03b41; \u03b42, s) = Final(\u03b41, s) \u2227 Final(\u03b42, s)\nFinal(\u03b41|\u03b42, s) = Final(\u03b41, s) \u2228 Final(\u03b42, s)\nFinal(\u03c0x.\u03b4, s) = \u2203x.Final(\u03b4, s)\nFinal(\u03b4*, s) =True\nFinal(\u03b41||\u03b42, s) = Final(\u03b41, s) \u2227 Final(\u03b42, s)\nThese are in fact the usual ones [21], except that, following [16], the test construct \u03c6? does not yield any transition, but is final when satisfied. Thus, it is a synchronous version of the original test construct (it does not allow interleaving).\nAlso, note that the construct if \u03c6 then \u03b4\u2081 else \u03b42 endIf is defined as [\u03c6?; \u03b41] | [\u00ac\u03c6?; \u03b42] and while \u03c6 do \u03b4 endWhile is defined as (\u03c6 : \u03b4)*; \u00ac\u03c6?."}]}