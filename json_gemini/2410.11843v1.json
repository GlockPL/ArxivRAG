{"title": "From Commands to Prompts:\nLLM-based Semantic File System for AIOS", "authors": ["Zeru Shi", "Kai Mei", "Mingyu Jin", "Yongye Su", "Chaoji Zuo", "Wenyue Hua", "Wujiang Xu", "Yujie Ren", "Zirui Liu", "Mengnan Du", "Dong Deng", "Yongfeng Zhang"], "abstract": "Large language models (LLMs) have demonstrated significant potential in the\ndevelopment of intelligent applications and systems such as LLM-based agents and\nagent operating systems (AIOS). However, when these applications and systems\ninteract with the underlying file system, the file system still remains the traditional\nparadigm: reliant on manual navigation through precise commands. This paradigm\nposes a bottleneck to the usability of these systems as users are required to navigate\ncomplex folder hierarchies and remember cryptic file names. To address this\nlimitation, we propose an LLM-based semantic file system (LSFS) for prompt-\ndriven file management. Unlike conventional approaches, LSFS incorporates\nLLMs to enable users or agents to interact with files through natural language\nprompts, facilitating semantic file management. At the macro-level, we develop\na comprehensive API set to achieve semantic file management functionalities,\nsuch as semantic file retrieval, file update monitoring and summarization, and\nsemantic file rollback). At the micro-level, we store files by constructing semantic\nindexes for them, design and implement syscalls of different semantic operations\n(e.g., CRUD, group by, join) powered by vector database. Our experiments show\nthat LSFS offers significant improvements over traditional file systems in terms\nof user convenience, the diversity of supported functions, and the accuracy and\nefficiency of file operations. Additionally, with the integration of LLM, our system\nenables more intelligent file management tasks, such as content summarization and\nversion comparison, further enhancing its capabilities. The code is open-source at\nhttps://github.com/agiresearch/AIOS-LSFS.", "sections": [{"title": "1 Introduction", "content": "In recent years, researchers have integrated AI with operating systems to create innovative, efficiency-\nboosting applications [3,30]. For example, machine learning algorithms can dynamically adjust\nsystem resource allocation [14,36]. Besides, by monitoring application performance and user behavior,\nAl models can predict future resource needs and pre-allocate CPU, memory, and other resources,\nenhancing overall system performance and response speed [25]. With the recent developments\nof generative AI, researchers have envisioned Large Language Models (LLMs) based operating\nsystems [12].\nAt present, LLMs have demonstrated great planning and reasoning ability [16,23,40,45,48], which\nfacilitates the development of LLM-based agents, including single-agent applications [8, 15,44,47]\nand collaborative multi-agent applications [11,18,37,42]. Nowadays, researchers have been trying to\nembed LLMs from the application-level to the system-level to serve users and AI agent applications,\nenabling LLM-based artificial intelligent operating system (AIOS) [30]. Through such integration,\nthe powerful understanding and generation ability of LLMs not only can help to complete tasks on\nthe application-level, but also can help to intelligently manage various resources such as memory and\nstorage on the system-level.\nFile system is one of the most fundamental and essential components of an operating system, yet it\ncomes with significant limitations in terms of AIOS. Currently, file management primarily relies on\nindex structures that organize files based on attributes like file name, size, and timestamps. However,\nthis approach does not leverage the semantic meaning of the files themselves. For instance, if two\nfiles have similar content-such as different versions of the same document-traditional file systems lack\nthe capability to organize or retrieve these files based on their content similarity. User interactions\nwith traditional file systems require complex operating system commands or manual navigation\nthrough the user interface, forcing users to precisely recall file names or locations. For systems\nwith numerous files, this retrieval process can be inefficient and time-consuming, reducing overall\nsystem usability. Nowadays, based on the strong language understanding capability of LLMs, we\ncan make better use of the file content and semantic information for file management by introducing\nLLMs into the system. However, existing works on using LLMs to facilitate file management are\nmostly conducted on the application level, which targets at designing specific agent for file retrieval\nand manipulation [28,38]. The community still lacks a more general LSFS to serve as a common\nfoundation that can be used by various agents on the application-level. To solve the above problems,\nwe propose LSFS, an LLM-based semantic file system, to enhance the interaction between LLM and\ntraditional file system for better semantic file management.\nFor problem 0, our LSFS introduces a semantic-based index structure that leverages a vector database\nfor file storage. By extracting semantic features from the file content and generating corresponding\nembedding vectors, LSFS incorporates semantic information into its file operations. Additionally, we\nhave designed numerous reusable syscall interfaces for LSFS, modeled after traditional file system\nfunctions. At the same time, we design several APIs that can realize complex file functions based on\nthe syscalls. These syscalls and APIs not only can realize the basic functions of the file system but\nalso can provide the operations that the traditional file systems do not include."}, {"title": "2 Related Work", "content": "2.1 Semantic File System\nCurrently, file storage and retrieval primarily rely on an index structure maintained by the system,\nwhere file metadata points to the file's location on the disk [7]. While optimizing the index structure\ncan enhance retrieval efficiency, the current storage model is still largely dependent on the keywords\nextracted from the file's content. Gifford et al. [13] were the first to propose a semantic file system,\nwhich introduced a layer that generates directories by extracting attributes from files, enabling users\nto query file attributes through navigation. [9] proposed a semantic file system to manage the data.\nMany subsequent works have integrated semantics into metadata [17, 19, 20, 29, 31]. Mahalingam\net al. [29] proposed a semantic deep file management system called Sedar, which embeds semantic\nfeatures into file metadata, allowing retrieval to be matched with semantic vectors. However, Sedar\nfaces challenges with the similarity of extracted semantic vectors. Hua et al. [20] further integrated\nsemantic information into metadata, restricting complex queries to a related metadata group. The\nsame authors [21] also utilized semantics to reduce the relevance of queries using the semantic\nsimilarity between files based on the semantic naming system. Leung et al. [26] used semantic\ninformation combined with the file system design of graphs to provide scalable search and navigation.\nOn the other hand, Bloehdorn et al. [4] proposed to manage files through semantic tags. Schandl et\nal. [35] developed an approach for managing desktop data using a semantic vocabulary. In contrast,\nour semantic file system is based on the strong language understanding ability of LLMs. Besides,\nit integrates comprehensive semantic information across all aspects of the file system\u2013from storage\nand file operations to practical applications. This holistic approach enhances the system's ability to\nunderstand and manage files, significantly improving functionality beyond what traditional systems\nand earlier semantic file systems offer.\n2.2 Semantic Parser\nResearchers have also devoted efforts to developing semantic parsers [6, 24, 32, 41, 46] capable of\ntransforming natural language into a machine-interpretable format. Mooney et al. [32] pioneered\nthis area by introducing a suite of machine learning-based semantic parsers designed for specific\ntasks. Iyer et al. [22] subsequently focused on parsing database commands, while Berant et al. [1]\nproposed a question-answer pair learning approach to enhance parsing efficiency. In further work,\nthe same authors explored a paraphrasing technique [2] to improve semantic parsing performance.\nPoon et al. [33] introduced a Markov logic-based approach, and Wang et al. [39] addressed the\nchallenge of building parsers from scratch in new domains. Ge et al. [10] proposed a parse tree-based"}, {"title": "2.3 OS-related LLMs and Agents", "content": "To enhance user experience and improve task completion efficiency, many LLM-based AI agents\nhave been introduced to fulfill operating system related tasks such as software development [34,\n44] and manipulating resources on traditional OS [5,43]. Wu et al. [43] developed LLM-based\nagents for co-piloting users' interaction with computers, such as drawing charts and creating web\npages. MetaGPT [18] employs a sophisticated large language model in a multi-agent conversational\nsetting to automate software development, assigning specific roles to various GPTs for seamless\ncollaboration. CHATDEV [34] presents a framework for software development, utilizing agents to\nenhance cooperation among different roles within the development process. Beyond the application-\nlevel research on LLM-based agents, researchers also explored integrating LLMs into the system-\nlevel [5, 30], which enables LLM-based agent operating system (AIOS) that provides fundamental\nservices to the agent applications on top of it, such as agent scheduling, memory and storage\nmanagement, tool management, security features, and access control."}, {"title": "3 Architecture of LSFS", "content": "Traditional file systems primarily rely on file attributes to build metadata. These attributes, typically\nobtained by scanning the file, include file size, creation and modification timestamps. The actual\nfile content is stored as binary data, with traditional file systems leveraging index structures such as\nB+ trees to efficiently locate this data. While these designs continue to evolve and improve, they\ngenerally overlook the semantic content information within files, making it difficult for traditional file\nsystems to support tasks that require deeper semantic understanding. To address this limitation, we\npropose a semantic file management system powered by LLMs and vector databases. This system\nretains traditional file attributes and integrates semantic information derived from the file's content.\nUnlike traditional file systems, our system enhances metadata by including user-defined keywords\nthat capture the essence of the file's content, in addition to standard file attributes. Our semantic\nfile management system employs embedding models to convert textual content into semantic vector\nrepresentations. These vectors enable the construction of a semantic-based data index, facilitating the\nstructured storage of data and enabling robust, semantically-driven file retrieval and management. This\noptimized architecture allows for more intelligent and semantic interactions with file data, enhancing\nthe system's functionality and making it particularly well-suited for modern file management tasks."}, {"title": "4 Implementation of LSFS", "content": "In this section, we introduce our implementation of the LSFS. We present the key functions imple-\nmented in our LSFS and compare the counterparts with traditional file systems, which can be seen\nfrom the Table 1.\nWe introduce the implementation of LSFS from the bottom to the top in the LSFS architecture shown\nin the Figure 2. We start by introducing the basic syscalls implemented in LSFS and introduce the\nsupervisor which interacts between LSFS syscalls and traditional file systems. Then we present the\nAPIs that built upon the syscalls to achieve more complex functionalities. After that, we introduce\nthe LSFS parser on top to show how natural language prompts have been decoded into executable\nLSFS APIs. At last, we use different concrete prompts to show how different modules in the LSFS\nare executed to achieve functionalities."}, {"title": "4.1 Basic Syscall of LSFS", "content": "In this section, we introduce the syscalls implemented for LSFS. These syscalls are primarily\ncategorized into two types: atomic syscalls and composite syscalls. Atomic syscalls involve operations\ncovering the most basic operations, e.g., create, retrieve and write of files. Composite syscalls are\ncombinations of two or more atomic syscalls to execute composite functions, e.g., join and group by.\nAtomic Syscall of LSFS. These syscalls involve the atomic operations that cannot be divided\nfurther into sub operations, i.e., creation, retrieval, write, and deletion of files.\n\u2022 create_or_get_file() This syscall integrates various functions of traditional file systems,\nincluding creating, reading, and opening files, and performs specific operations based on the pro-"}, {"title": "4.2 Supervisor", "content": "The supervisor is implemented to track the changes in the files in the disk and sync the changes to\nthe LSFS. The supervisor periodically scans the files within its specified directory. When it detects\nany change or deletion of the file content, it automatically synchronizes this information with the\nLSFS by invoking the appropriate syscall. This ensures that the state of the file in the LSFS reflects\nthe current state of the file in memory. In order to ensure the accuracy of other syscall operations\non the file after Supervisor modifies the internal file status of LSFS, LSFS introduces the process\nlock mechanism to ensure that multiple processes can access the file correctly. When asked, the\nsupervisor can generate status change reports. For example, when a file is modified, the supervisor\ninvokes LLMs to generate a detailed modification log, compares the contents of the file before and\nafter modification, and presents this log to the user."}, {"title": "4.3 API of LSFS", "content": "In this module, we introduce the APIs that are implemented on top of the syscalls mentioned in\nSection 3 to support higher-level semantic file management functions. Specifically, we provide the\nfollowing APIs that cover the basic semantic file management requirements, i.e., semantic CRUD\n(create, read, update, and delete) of files."}, {"title": "4.4 LSFS Parser", "content": "We design an LSFS parser to\nguide this conversion process\nand create a general prompt tem-\nplate for future API designs to ex-\ntract parameters from natural lan-\nguage prompts. As illustrated in\nthe accompanying Figure 3, we\nleverage large language model\nto parse natural language com-\nmands. For each API, we design\ndistinct system prompt words,\nwhich, when input alongside the\nuser's command, allow the lan-"}, {"title": "4.5 The Interaction between Modules", "content": "In Figure 4, we present the examples to demonstrate how components of LSFS interact with each\nother to achieve different functionalities. The upper section of Figure 4 depicts the workflow of\nthe retrieve-summary API, while the lower section outlines the workflows of the change-summary\nAPI and rollback API. In the upper part of Figure 4, the LSFS parser decodes prompts into API\ncalls with API name and API arguments. Then LSFS executes the API to check vector database to\nget results. This API also provides user-interaction interface for the users to verify results. After\nthe verification, the content will be summarized by leveraging LLM. In the lower part of Figure 4,\nwhen a modification request is submitted, the LSFS parser decodes the file information (name and\nlocation) that is to be modified. The LSFS then modifies the semantic changes in both the vector\ndatabase and the files stored in the disk. Meanwhile, the supervisor of the LSFS is kept running\nto ensure consistency between the semantic index of files in the LSFS and the files stored in the\ndisk. Upon updated, the summarization API compares the file contents before and after the change\nto generate a detailed change log. Additionally, the API stores the pre-modification content in the\nversion recorder. If a rollback is requested, the API retrieves the specific version from the version\nrecorder and synchronizes it in both the LSFS and files in the disk."}, {"title": "5 Evaluation", "content": "In this section, we propose the following research questions regarding the performance of LSFS and\nconduct experiments to answer these research questions.\n\u2022 RQ1: What is the success rate of the LSFS parser to parse natural language prompts into executable\nAPI calls?\n\u2022 RQ2: How does LSFS perform in semantic file management tasks, e.g., semantic file retrieval and\nsemantic file rollback?"}, {"title": "5.1 RQ1: Effectiveness of LSFS Parser", "content": "For RQ1, we assess the accuracy of the LSFS parser in translating user natural language prompt into\nexecutable LSFS API calls. We evaluate the accuracy of LSFS parser with 30 different samples for\neach API on different LLM backbones, i.e., Gemmi-1.5-Flash, GPT-40-mini, Qwen-2, and Gemma-2.\nThe results, illustrated in Figure 5, reveal that the LSFS parser performs exceptionally well on parsing\nprompts related to change-summary API and link API (for which the semantic information in the user\nprompt is relatively simple), achieving high accuracy across all LLMs, with some reaching 100%\naccuracy. For more complex\nprompts, such as those intended\nfor the rollback API and retrieve-\nsummary API (for which the se-\nmantic information in the user\nprompt is complex), accuracy re-\nmains above 85% for most mod-\nels, except for Gemma-2. The av-\nerage parsing accuracy reaches\n90%. These results show that\nthe LSFS parser can effectively\ntranslate natural language infor-\nmation into executable API calls,\nshowcasing its reliability in di-\nverse scenarios. In all cases, the translated command is provided to users for approval before real\nexecution, ensuring safety when executing commands in the file system."}, {"title": "5.2 RQ2: Analysis of LSFS in Semantic File Management Tasks", "content": "Performance Analysis in Semantic File Retrieval. In our experiments, we compare the perfor-\nmance of using LSFS and without using LSFS under the same LLM backbone. The details of the\nprompts we use for the comparison are in the Appendix B. Specifically, we use Gemini-1.5-flash and\nGPT-40-mini as the LLM backbone, respectively, for the comparison. As shown in Table 2, using\nLSFS to implement the retrieval function significantly enhances both the accuracy and the efficiency\ncompared to only leveraging LLM for retrieval without using LSFS. As file number increases, the\nretrieval accuracy tends to drop significantly when using LLM for retrieval without LSFS. This is\nbecause more files can lead to longer context for the LLM, which degrades the LLM's performance of\nidentifying information in the long context. By contrast, using LSFS can still achieve good retrieval\naccuracy and have much better retrieval efficiency when file number increases, because lsfs replaces\nthe reasoning process of LLM by using keyword matching and semantic similarity matching, it saves\na lot of time and avoids the errors of LLM when facing complex input text.\nWe conduct a case study using the example prompt \"Please search for the two papers most related\nto LLMs Uncertainty from folder named example\" to better illustrate the retrieval results, which is\nshown in the Figure 6. For the method without using LSFS, the answer to the intermediate result\nis \u201cGNN-RAG: Graph Neural Retrieval for Large Language Model Reasoning\u2026\u2026,\u201d which fails to"}, {"title": "5.3 RQ3: Analysis of LSFS in Non-Semantic File Management Tasks", "content": "For RQ3, we evaluate on non-semantic file management tasks to measure whether LSFS can still\nmaintain good performance as traditional file systems in these tasks.\nPerformance Analysis in Keyword-based File Retrieval. In this section, we compare LSFS and\ntraditional file system in keyword-based file retrieval task. The task is to use keywords existing in the\nfilename or file content to retrieve files. We build a hierarchical file folder with file numbers as 10,"}, {"title": "6 Conclusions", "content": "In this paper, we present an LLM-based semantic file system (LSFS), which offers advancement over\ntraditional file systems by enabling files to be stored and managed based on their semantic information.\nThis enhancement improves the system's ability to comprehend and utilize the semantics embedded\nin file contents. Additionally, we introduce a series of reusable semantic syscalls and a framework\nfor mapping natural language into LSFS parameters. These innovations provide a foundation for\nfuture research and development in the area of semantic file management systems. Looking ahead,\nfuture work can further explore and expand the application of LSFS across a wider scope of user\nenvironments and integrate semantic file management into everyday computing. This can help to\nsimplify user operations and pave the way for a more intelligent and user-friendly operating system."}, {"title": "7 Acknowledgement", "content": "We thank Minghua Ma and Sam Lin for the useful discussions with them."}, {"title": "A The Implementation Details of Syscall", "content": "create_or_get_file() This syscall integrates multiple traditional file system functions such\nas creating files, reading files, and opening files, enabling different operations based on the parameters\nprovided. The function accepts four parameters: the LSFS path, the target directory name, the target\nfilename, and the import file. The first two parameters are positional, while the latter two are default\nparameters. When all four parameters are provided, if the target file does not exist within LSFS, the\nsystem will create an imported file using the specified target directory name, target filename, and\nthe import file. The import file can be supplied as a string or a file path, and our system supports\nvarious text file formats, including PDF, DOCX, TXT and so on. If the target filename is not passed,\nthe syscall returns a list of files within the target directory. If the content of the import file is not\nprovided, the syscall will return the target file, allowing access to its content, metadata, embedding\nvector, and other associated information.\nadd_() This syscall facilitates appending content to a file by accepting four positional parameters:\nthe LSFS path, the target directory name, the target filename, and the content of the import file. The\nimport file content can be provided either as a string or a text file in various formats. When all four\nparameters are supplied, the syscall appends the specified content to the designated file within the\nsystem.\noverwrite() This syscall implements the overwriting of the file contents. The passed Parameters\nare also LSFS path, target directory name, target filename, import file, all of which are Positional\nParameters. When passed in, LSFS will overwrite everything in the source file with the contents of\nthe imported file.\ndel_() This syscall performs the deletion of files and directories by accepting four parameters: the\nLSFS path, the target directory name, the target filename, and the key text. The first two parameters are\npositional, while the last two are default parameters. If neither of the last two parameters is provided,\nthe syscall raises an error, indicating that at least one must be passed. When the target filename is\nprovided, LSFS deletes the specified file. If the key text is provided instead, the system searches for\nfiles containing the key text within the target directory and deletes them if found. Additionally, once\nall files within a directory are deleted, LSFS will automatically remove the directory.\nkeywords_retrieve()This syscall implements LSFS's keyword search functionality, retrieving\nall files within a specified directory that contain a given keyword. The arguments passed include\nthe LSFS path, directory name, keyword, and matching condition. The LSFS path and keyword are\nPositional Parameters, while the directory name and condition are Default Parameters. If a directory\nname is provided, the syscall retrieves files within that directory that match the keyword; otherwise,\nit searches across the entire system. To match multiple keywords, the matching condition must be\npassed, specifying the relationship between keywords, such as and or or. The search results return a\nlist of file names and a list of file contents.\nsemantic_retrieve() This syscall implements the semantic similarity search function within\nthe LSFS, allowing retrieval of files that semantically match a given query within a specified directory.\nThe parameters for this function include the LSFS path, the target directory, the search keyword, and\nthe number of results to return. The LSFS path and search keyword are Positional Parameters, while\nthe target directory and number of results are Default Parameters. Similar to keyword-based retrieval,\nthe search directory will be determined based on whether a target directory is provided. The number\nof results to return dictates how many of the top-scoring matches are retrieved. Our semantic retrieval\nleverages the LlamaIndex framework. During file creation, a LlamaIndex vector store is generated\nalongside the index, enabling more intelligent and efficient data retrieval. This setup ensures that\nsemantic queries can return highly relevant results with improved accuracy. The search results return\na list of file names and a list of file contents.\ncreate() This syscall function facilitates batch directory creation and bulk file reading. It accepts\nthe LSFS path, directory name, and the import file path as Positional Parameters. This function can\nread multiple files at once and store them in the specified target directory. If the filenames are not\nexplicitly provided, they will default to the original filenames from the filesystem."}, {"title": "B Details of keyword-based and semantic retrieval.", "content": "The example of instruction of keyword-based retrieval with single-condition and multi-condition in LSFS and in LLM without LSFS."}, {"title": "C The Instruction of API", "content": "Some examples of instruction of API in Section 4.3. For every API, we provide different\ninstructions in different task condition. The instruction of retrieve-summary API is in Appendix B."}, {"title": "D Experiment Details of File Sharing", "content": "In this module, we show some examples that the LLM execution results in a failure to correctly\ngenerate shareable links. We give each LLM the following input: You are good at writing code, please\nwrite code to generate shared links for the file 'path'.\nD.1 The code cannot generate link\nIn the experiment, the code generated by LLMs may not produce the correct link or link address.\nFor instance, even after successfully installing the required file packages, the following code block\ndemonstrates that the generated link does not direct to the intended target file. The pseudo-code is in\nAlgorithm 1\nD.2 The code can only generate local link\nIn most cases, the generated code will produce links to the corresponding files. The code block\ntypically appears as shown below; however, the links generated by this code are limited to local\naccess and do not provide shareable links for external users. The pseudo-code is in Alg. 2\nD.3 The code can generate shareable link\nIn our experiments, the code generated by LLMs can occasionally produce a shareable link. However,\ngenerating such a link often involves complex configuration steps. For instance, users need to\nauthorize the Dropbox app, obtain an access token, and perform other setup tasks, as illustrated in\nthe following code block. Moreover, due to the variety of platforms for generating shareable links,\nLLMs may switch between different platforms with each code generation, leading to considerable\nuser configuration time. The Steps and Pseudo-code in Alg. 3"}, {"title": "E Further Discussions", "content": "File system is one of the most important components of an operating system. Enhancing and\nexpanding its capability based on LLMs can help to increase its usability for users. Building on\nthe foundation of LSFS, there are numerous avenues for future research to explore. This section\nhighlights key areas of study that could extend and enhance the core capabilities of LSFS.\nMulti-modal, Multi-extension File Manipulation Currently, LSFS primarily supports operations\non text files. While it also provides basic functionality for handling other types of files, such as XLSX,\nJPG, MP3, and MP4, through writing and deletion, it lacks dedicated syscall interfaces tailored to\nthese formats. Future work could focus on leveraging the semantic information embedded in these\nnon-text file types to design and optimize file management operations, enabling more intelligent and\ncontext-aware file management across a broader directory of formats.\nSecurity and Privacy Enhancements LSFS must implement robust protection measures to de-\nfend against a variety of security threats, such as file data leakage, tampering, and unauthorized\naccess. Additionally, incorporating encryption techniques is essential to secure data interactions and\ntransmissions between LSFS and LLMs, ensuring that file privacy remains protected at all stages of\nprocessing and communication.\nOptimized Retrieval Strategies The core functionality of LSFS lies in its keyword and semantic\nretrieval capabilities. In future work, these retrieval methods can be further optimized by integrating\nmore advanced and precise algorithms, enhancing the overall accuracy and effectiveness of LSFS's\nretrieval performance.\nMore Instantiated APIs and syscalls There are two main directions for future optimization of\nLSFS design. First, further deepening the integration of traditional file system functions into LSFS.\nWhile this paper focuses on the design of the most essential and commonly used syscalls within\nLSFS, many additional functionalities remain unexplored and can be developed in the future. Second,\nas user demands for file systems continue to grow, there are numerous operations that traditional file\nsystems are unable to support. To address these needs, LSFS can be expanded to instantiate APIs for\nrelated operations, providing users with more versatile and advanced capabilities."}]}