{"title": "Repository-Level Graph Representation Learning for Enhanced Security Patch Detection", "authors": ["Xin-Cheng Wen", "Zirui Lin", "Cuiyun Gao", "Hongyu Zhang", "Yong Wang", "Qing Liao"], "abstract": "Abstract-Software vendors often silently release security patches without providing sufficient advisories (e.g., Common Vulnerabilities and Exposures) or delayed updates via resources (e.g., National Vulnerability Database). Therefore, it has become crucial to detect these security patches to ensure secure software maintenance. However, existing methods face the following challenges: (1) They primarily focus on the information within the patches themselves, overlooking the complex dependencies in the repository. (2) Security patches typically involve multiple functions and files, increasing the difficulty in well learning the representations. To alleviate the above challenges, this paper proposes a Repository-level Security Patch Detection framework named RepoSPD, which comprises three key components: 1) a repository-level graph construction, RepoCPG, which represents software patches by merging pre-patch and post-patch source code at the repository level; 2) a structure-aware patch representation, which fuses the graph and sequence branch and aims at comprehending the relationship among multiple code changes; 3) progressive learning, which facilitates the model in balancing semantic and structural information. To evaluate RepoSPD, we employ two widely-used datasets in security patch detection: SPI-DB and PatchDB. We further extend these datasets to the repository level, incorporating a total of 20,238 and 28,781 versions of repository in C/C++ programming languages, respectively, denoted as SPI-DB* and PatchDB*. We compare RepoSPD with six existing security patch detection methods and five static tools. Our experimental results demonstrate that RepoSPD outperforms the state-of-the-art baseline, with improvements of 11.90%, and 3.10% in terms of accuracy on the two datasets, respectively. These results underscore the effectiveness of RepoSPD in detecting security patches. Furthermore, RepoSPD can detect 151 security patches, which outperforms the best-performing baseline by 21.36% with respect to accuracy.", "sections": [{"title": "I. INTRODUCTION", "content": "In recent years, the increasing number and diversity of vulnerabilities [1], [2] in Open-Source Software (OSS) have presented significant challenges to software security, posing substantial risks to society [3], [4]. According to the Synopsys [5] report in 2024, 84% of codebases contain at least one open-source vulnerability, and 91% of these codebases include components that are outdated by ten or more versions [6]. There is a critical need for the timely detection of software security patches to mitigate attacks [7]. However, the management of security patches is often subjective by managers [7], [8], leading software vendors to release security updates without sufficient publicity [9]. This practice of silently releasing patches complicates the identification and remediation processes, as users or administrators are frequently overwhelmed by the growing number of patches [10], which often results in delayed software updates and vulnerability reports. The existing study has revealed that over 82% of user-submitted software vulnerability reports are filed more than 30 days after the initial detection [11]. For example, CVE-2024-24919 [12], an information disclosure vulnerability, was first disclosed on May 24th, 2024. However, threat actors had begun exploiting this vulnerability as early as April 30th, targeting over 51 IP addresses [13]. Consequently, more than a hundred thousand users, including those in banks, federal agencies, and large enterprises, faced significant exposure risks. Therefore, it is imperative for both users and developers to automatically distinguish security patches from other updates and prioritize those that directly address security vulnerabilities.\nDeep Learning (DL)-based methods have achieved great success in identifying security patches as they can reduce the dependence on the quality of commit messages in patches and offer a broader spectrum of capabilities in detecting various security patches [14]\u2013[16]. Current methods can be categorized into sequence-based and graph-based approaches. Sequence-based methods process the sequential inputs of all code changes in a patch and then utilize DL models to determine whether a code commit fixes a vulnerability. For example, PatchRNN [17] uses both commit messages and code changes as input and then employs the Recurrent Neural Network (RNN) [18] to deal with the input sequentially. Graph-based methods convert the code changes from a code commit into a graph structure, incorporating control flow [19] or data flow dependencies [20], and then use Graph Neural Networks (GNNs) [21] or serialize the graph structure to identify security patches. For example, GraphSPD [22] proposes a PatchCPG and employs a Graph Convolutional Network (GCN) [23] to detect security patches.\nHowever, existing methods face the following challenges:"}, {"title": "(1) Lack of consideration of the comprehensive contexts at the repository level.", "content": "The previous methods [17], [22] primarily focus on the information within the security patches, overlooking the complex dependencies in the repository. However, patches typically have complex dependencies in the repository, such as the call function to invoke functions in the patches, which are necessary for identifying a security patch. For instance, as shown in Fig. 1, the patch addresses a buffer overflow vulnerability identified as CVE-2014-0205 [25]. The function futex_wait() (shaded in orange in Fig. 1(C) and (D)) fails to properly manage a specific reference count during requeue operations, which may lead to trigger the use-after-free or system crash via the queue_lock() and queue_unlock() functions (in Fig. 1(A) and (B), respectively). Moreover, the provided patch does not include repository-level dependency about the get_futex_key_refs (Line 4 in Fig. 1(A)) and put_futex_key (Line 3 in Fig. 1(B), respectively). Therefore, we cannot determine if this patch is a valid security patch due to insufficient contextual information. (2) Hard to learn the patch representation due to the complex relationships among multiple code changes. Security patches generally encompass multiple functions and files, increasing the difficulty in learning the representations. For instance, the given commit involves five functions and seven code changes (Fig. 1 shows three functions and four code changes). These code changes do not represent a sequential relationship (i.e., they are not linearly related, such as Fig. 1(C) and Fig. 1(D) simultaneously modifying futex_wait() function, shaded in orange). This complexity can limit the existing models' capability to learn representations among multiple code changes."}, {"title": "Our work.", "content": "To alleviate the above challenges, we propose a Repository-level Security Patch Detection framework named RepoSPD, which comprises three key components: 1) a novel graph structure, called RepoCPG, aims at extracting comprehensive contexts at the repository level by merging pre-patch and post-patch source code and retaining code changes semantics within the patches; 2) a structure-aware patch representation, which fuses the graph-based and sequence-based representations, aiming at comprehending the relationship among multiple code changes from the structure and semantics perspective, respectively; 3) progressive learning, which aims at facilitating the model in balancing structural and semantic information. Additionally, we extend the SPI-DB [26] and PatchDB [27] datasets to incorporate a total of 20,238 and 28,781 versions of repositories, respectively, denoted as SPI-DB* and PatchDB*.\nTo evaluate RepoSPD, we compare RepoSPD with five existing security patch detection baselines and five static vulnerability detection methods. The experimental results show that RepoSPD outperforms the state-of-the-art security patch detection approaches, with improvements of 11.90%, and 3.10% in terms of accuracy and F1 score, respectively. Furthermore, RepoSPD detects 151 security patches with an accuracy of 78.65%, which achieves a substantial improvement of 21.36% over the static-analysis-based baselines. These results demonstrate the effectiveness of RepoSPD in identifying security patches."}, {"title": "Contributions.", "content": "The major contributions of this paper are summarized as follows:"}, {"title": "Algorithm 1 RepoCPG Construction", "content": "Input : Pre_code: Code_pre, Post_code: Code_post, Repo_Function: Repo_func\nOutput: RepoCPG, RepoCPG\nFunction RepoCPG Construction:\n// Generating the Pre-Patch and Post-Patch CPGs\nPre_CPG(N_pre, E_pre) \u2190 Code_pre\nPost_CPG(N_post, E_post) \u2190 Code_post\n// Fuse the Pre_CPG and Post_CPG to obtain the MergeCPG.\nfor v\u2190 N_pre, N_post, E_pre, E_post do\nif v \u2208 V_pre and v \u2208 V_post then\nv.type \u2190 fuse\nelse\nif v \u2208 V_pre then\nv.type \u2190 pre\nend\nif v \u2208 V_post then\nv.type \u2190 post\nend\nend\nMerge_CPG\u2190 Construct_MergeCPG(Pre_CPG, Post_CPG)\n// Integrating the repository-level dependency.\nif node.type \u2208 Call_graph then\n// Adopt static tool to extract Function_name in the repository\nif Function_name \u2208 Repo_func then\nCall_func\u2190 Repo_func[i]\nend\n// Construct the Call_CPG of Call_func\nCall_CPG \u2190 Construct_Call_CPG(Call_func)\n// Find the root_node of Call_CPG\nAdd Edge (node, root_node) and mark the root_node as R\n// Update Merge_CPG\nRepoCPG + Update (Merge_CPG, Call_CPG, R)\nend\n// Slicing code changes in repository-level.\nif RE Code Change then\n// Deleted-based Repository Slicing\nRepoCPG_Deleted Delete_Slice(RepoCPG)\n// Added-based Repository Slicing\nRepoCPG_Added \u2190 Add_Slice(RepoCPG)\nend\nRepoCPG \u2190 RepoCPG_Deleted U RepoCPG_Added\nreturn RepoCPG"}, {"title": "III. PROPOSED FRAMEWORK", "content": "We provide an overview of RepoSPD workflow in Fig. 2. RepoSPD mainly consists of three components: (A) RepoCPG construction, (B) structure-aware patch representation, and (C) progressive learning."}, {"title": "A. RepoCPG Construction", "content": "The purpose of the Repository-level CPG (RepoCPG) construction is to extract comprehensive contexts at the repository level and retain code change semantics within the patches, which consists of the following three steps:\n(1) Generating MergeCPG: It aims to establish connections before (pre-patch) and after (post-patch) the patch. However, when multiple code changes occur within a single file, they often lack structural connection to each other due to the patch only containing three lines of code within the code changes [22]. Therefore, we initially employ the commit-id in conjunction with the git reset command to precisely revert to the specific versions of the repository, thereby retrieving the entire files both pre-patch and post-patch, rather than merely using the code changes. As shown in the Algorithm 1 (Lines 2-4), we generate the CPG for each version of the file to construct pre-patch and post-patch CPGs, respectively."}, {"title": "B. Structure-aware Patch Representation", "content": "In this component, we elaborate on the proposed structure-aware patch representation, which involves the graph branch for capturing the structural information of RepoCPG, and combines the sequence branch for further enhancing the security patch representations.\n(1) Graph branch: The graph branch learns vulnerability patterns from semantic and structural information. The semantic information is exhibited by each node embedding in the RepoCPG, while the structural information is achieved by the graph structure by diverse relationships between node and edges. The content of each node in RepoCPG can be a statement node in CDG/DDG or token node in AST. We use UniXcoder [44] to initialize the representations of each node in the RepoCPG. We generate the node vector $h_i^{(0)}$ for each node i in the RepoCPG, which is calculated as follows:\n$h_i^{(0)} = H^O(N_i) + H^L(N_i)$ (1)\nwhere $H^O$ and $H^L$ denote the first and last layer embedding of UniXCoder [44], respectively.\nWe then use the Graph Attention Networks (GAT) [45], which aims at capturing the local structural information of the RepoCPG. Specifically, two types of edge roles and four-bit vectors are defined: version (pre-patch, post-patch, or common), and functional (CFG, DDG, or AST). It is noteworthy that repository-level edges are not listed separately; instead, they encompass both version information and functional relationships. Owing to the distinct roles, it is impractical to apply a uniform set of weights across the entire model for learning the graph representation. Consequently, we construct four subgraphs (i.e., four GAT layers) to cater to four-bit vectors. Within this framework, a GAT layer computes a new set of node embedding by leveraging the input node features along with the attention coefficients that have been learned. For each subgraph, the normalized attention coefficients between nodes i and j are calculated using the following formula:\n$a_{ij}^{[k]} = softmax(LeakyReLU (a^{[l]} (W h_i^{(l-1)} || W h_j^{(l-1)})))$, (2)\nwhere $a^{[l]}$ and W denote the learnable vector and weight matrix, respectively. ||, softmax, and LeakyReLU denote the concatenation operation, softmax function, and activation function, respectively. k is the index of the subgraph. The node embedding $h_i^{[l]}$ of subgraph k in layer l is computed as follows:\n$h_i^{[k]} = \\sigma( \\sum_{j \\in N(i)} a_{ij}^{[k]} W h_j^{[k](l-1)})$ (3)\nwhere N(i) and \u03c3 denote the set of neighboring nodes of node i and the activation function, respectively. The different roles of edges and the structure-level information in the RepoCPG will be aggregated to the whole graph feature $h^{[g]}$, which can be formulated as:\n$h^{[g]} = || h^{[k]}$ (4)\nwhere K represents the total number of subgraphs. Since the graph feature $h^{[g]}$ only provides individual attention for each subgraph, we further employ another GAT layer to learn the structural information from the whole RepoCPG. Finally, we calculate the representation $f_g$ through a pooling layer to obtain the graph-branch representation $f_g$.\n(2) Sequence branch: We also integrate a sequence branch specifically designed to analyze the code changes within a patch. A typical patch includes several lines of contextual code, but it also often encompasses a substantial amount of extraneous data, such as line numbers and diff markers (e.g., \"@@ string1 @@\"). Such information can potentially mislead the model during the learning process. To mitigate this issue, the sequence branch is configured to selectively retain only the lines of code changes, along with the version information (either pre-patch or post-patch), to enhance semantic learning. We exclude non-critical elements such as index lines, file-names, and location indicators. Specifically, we fine-tune [46] the UniXcoder [44] and obtain the sequential representation $f_s$ for the sequence branch."}, {"title": "C. Progressive Learning", "content": "As shown in Fig. 2(C), we introduce progressive learning that systematically alternates focus between the graph and sequence branches by modulating the respective model weights. This approach is necessitated by the inherent differences in modalities and input characteristic between the graph and sequence branches. Due to these differences, the learning rates and shared parameters between the branches vary substantially, posing challenges for capturing patch-related patterns. Therefore, we propose a method to progressively learn the graph branch and sequence branch, by selectively freezing the model weights of branches during the training process.\nMore concretely, the feature vectors $f_g$ and $f_s$ will be sent into the classifiers $W_g$ and $W_s$, respectively and the outputs will be integrated together. The predicted output is formulated as:\n$\\hat{p} = \\frac{W_g f_g + W_s f_s}{2}$ (5)\nThen, progressive learning is to initially train the sequence model, leveraging the domain knowledge provided by the pre-trained model. Subsequently, the focus shifts to the more complex graph structure, ensuring comprehensive learning"}, {"title": "IV. EXPERIMENTAL SETUP", "content": "In this section, we evaluate the effectiveness of RepoSPD by comparing it with the state-of-the-art security patch detection approaches and focus on the following four Research Questions (RQs):\nRQ1: How effective is RepoSPD compared with existing security patch detection approaches?\nRQ2: How effective is RepoSPD in security patch detection compared with the static analysis-based approaches?\nRQ3: How effective is RepoSPD over patches with different vulnerability types?\nRQ4: What is the influence of different components of RepoSPD on the performance for identifying security patches?"}, {"title": "B. Datasets", "content": "1) Data Source: To address the proposed RQs, we select two widely-used datasets as the raw data: SPI-DB [26] and PatchDB [27]. Specifically, SPI-DB collects patches from two major C/C++ datasets, FFMPeg and Qemu, encompassing 25k patches, of which 10k have been classified as security-related. PatchDB compiles data from 348 open-source repositories, containing over 36k code snippets, approximately 12k identified as security patches.\n2) Data Process: To evaluate the security patches at the repository level, we further collect the versions of the repository source code and extract the dependency at the repository level via three steps: (1) We initially select repositories from which complete source code and commit logs can be retrieved via GitHub. This process resulted in the selection of 20,482 patches from SPI-DB and 29,042 from PatchDB, as detailed in Table I. (2) For each identified patch, we use the corresponding commit ID to collect specific code versions at the repository level. This effort has led to the collection of 20,238 versions from repositories (i.e., #Version of Repo in Table I) in SPI-DB and 28,781 from PatchDB. (3) Finally, we traverse the entire repository by Tree-sitter [41] tool to parse the function-level dependencies. Subsequently, we employ the CFlow [43] to further extract dependency elements. As detailed in Table I, we extract the repository dependencies from 80,223 and 103,258 files to construct the SPI-DB* and PatchDB*, respectively.\n3) Data Split: Following the previous work [22], we split the datasets into disjoint training, validation, and test sets in a ratio of 8:1:1, as shown in the Table I. We use the training set to train the models, use the validation set for selecting best-performance models, and evaluate the performance in the test set."}, {"title": "C. Baselines", "content": "1) Comparison on Security Patch Detection Approaches: To address RQ1, we evaluate the effectiveness of RepoSPD by comparing the following six security patch detection approaches. We categorize these baselines into three groups: Supervised-based methods: We utilize PatchRNN and GraphSPD for this category. PatchRNN [17] employs an RNN-based model that processes only source code as input, while GraphSPD [22] introduces PatchCPG and leverages a GNN to learn structural information. These methods are widely recognized and frequently adopted as baselines in recent studies. Pretrained model-based methods: We select three prominent pre-trained models: CodeBERT [47], CodeT5 [48], and UniXcoder [44]. These models use code changes (i.e., patches) as input and are further fine-tuned for the downstream task of security patch detection. LLM-based methods: Due to resource constraints, we construct the prompt and utilize Llama3-70b [49] to assess the performance of LLMs in security patch detection.\n2) Comparison on Static Analysis Approaches: In RQ2, beyond directly identifying security patches, a common approach involves utilizing static analysis tools to detect security patches [22]. This method entails detecting vulnerabilities in pre-patch code snippets and verifying their absence in post-patch code snippets. In this paper, we select five widely used baselines: Cppcheck [50], RATS [51], Semgrep [52], Flawfinder [53], and VUDDY [54]. These methods employ predefined rules and patterns to identify potential vulnerabilities in source code at the repository level. Therefore, they can detect vulnerabilities in the vulnerable version (i.e., pre-patch) and should not identify such vulnerabilities if they have been successfully patched (i.e., post-patch)."}, {"title": "D. Evaluation Metrics", "content": "We choose the following three metrics to evaluate the performance of RepoSPD."}, {"title": "V. EXPERIMENTAL RESULTS", "content": "To answer RQ1, we compare the three types of security patch detection approaches, including supervised-based, pre-trained model-based, and LLM-based methods. Table II shows the experimental results of each baseline of accuracy, F1 score, and FP rate metrics."}, {"title": "1) Overall Results:", "content": "The experimental results presented in Table II demonstrate that RepoSPD consistently outperforms all baseline methods on the SPI-DB* and PatchDB* datasets across all evaluated metrics. Specifically, RepoSPD achieves an accuracy of up to 74.55%, and an F1 score of 68.98% on the SPI-DB* dataset. Furthermore, RepoSPD exhibits a higher accuracy of 83.35% and a reduced FP rate of 6.65% on the PatchDB* dataset. This enhanced performance in PatchDB* may be attributed to the larger training data compared to SPI-DB*."}, {"title": "2) RepoSPD VS. Supervised-based Methods:", "content": "The results summarized in Table II indicate that RepoSPD enhances performance metrics across both datasets when compared to all other supervised-based methods. Specifically, RepoSPD achieves average improvements of 14.22% in accuracy, and 20.61% in F1 score. GraphSPD outperforms TwinRNN, primarily because GraphSPD integrates the dependency within the patch to provide structural information. Furthermore, RepoSPD incorporates repository-level information to construct RepoCPG, which contributes to its superior performance."}, {"title": "3) RepoSPD VS. Pre-trained Model-based Methods:", "content": "Table II reveals that pre-trained model-based methods generally surpass those supervised-based methods. Specifically, CodeBERT, CodeT5, and UniXcoder achieve an average performance of 66.17% and 61.18% in terms of the accuracy and F1 score on the SPI-DB* dataset. Despite these results, these methods still behave worse than RepoSPD across all metrics. Particularly, RepoSPD outperforms the state-of-the-art baseline, with relative improvements of 7.50% of accuracy, and 8.70% of F1 score on average across the SPI-DB* and PatchDB* datasets. The primary factor contributing to this performance gap is that pre-trained model-based methods focus on semantic information within code changes. However, they do not adequately address the lack of structural information at the repository level, which is crucial for comprehensive analysis. In contrast, RepoSPD effectively integrates both semantic and structural information, thereby enhancing its overall performance in security patch detection. Furthermore, we also conduct the statistical significance tests between RepoSPD and the best-performing methods, CodeT5. RepoSPD surpasses CodeT5 in both PatchDB* and SPI-DB* at the 0.05 significance level, with p-values of 1.15E-2 and 5.46E-7, respectively. These results show that the RepoSPD significantly outperforms other baselines."}, {"title": "B. RQ2: RepoSPD VS. Static Analysis Approaches", "content": "To evaluate the effectiveness of RepoSPD in identifying security patches, we also compare with widely-used static analysis-based approaches. In this paper, we select five static analysis tools and utilize a dataset comprising 192 security patches. Specifically, to maintain consistency with Graph-SPD [22], the criteria of the selection include: (1) The patches without associated CVEs are removed since they are hard to be verified. (2) The non-security patches are excluded from the dataset. (3) The patches are selected only from the test set to prevent data leakage between the training and valid sets. Based on the selection criteria, the Patch-DB* comprises only 192 patches.\nAs demonstrated in Table III, the results show that RepoSPD surpasses all baselines, detecting an additional 41 security patches and achieving a 21.36% improvement in terms of accuracy. The static analysis tools such as Cppcheck, RATS, and Semgrep fail to detect any security patches, indicating their potential limitation in accurately identifying identify security patches. For instance, Cppcheck identifies 31 vulnerabilities in the pre-patch versions of the code. However, it also identifies the same vulnerabilities in the post-patch versions, indicating that it fails to recognize any of the applied security patches.\nAmong the static analysis-based approaches, VUDDY exhibits superior detection performance, identifying 131 vulnerabilities in pre-patch code and 59 in post-patch code. Among the vulnerabilities detected in the post-patch code, 38 are not associated with the same patches as the 131 vulnerabilities identified in the pre-patch code. This discrepancy highlights the challenges in accurately classifying patches, with VUDDY correctly identifying 110 patches as secure patches.\nIn summary, despite the widespread use of existing static analysis-based methods in practice, they exhibit a notable deficiency in detecting security patches. This limitation underscores the value of RepoSPD, which demonstrates a robust capability to identify security patches in the repository-level, thereby enhancing its practical utility."}, {"title": "C. RQ3: Effectiveness of Different Types of Patches in RepoSPD", "content": "To evaluate the effectiveness of RepoSPD in identifying different types of security patches, we utilize the same dataset as in RQ2. This dataset encompasses 28 types of Common Weakness Enumerations (CWE) [58] across 74 projects. The proportion and type of vulnerability are presented in Table IV. It is important to note that this dataset exclusively contains security patches and does not include non-security patches.\nOverall, we observe that RepoSPD is effective across all ten types of vulnerabilities analyzed, achieving an average accuracy of 81.11%. We can observe the following findings: (1) The RepoSPD shows excellent performance at identifying vulnerabilities associated with a higher number of security patches, such as Buffer Overflow, Resource Leakage, and Numeric Error, with accuracy performance of 87.88%, 82.14%, and 91.67%, respectively. In addition, it also reveals that RepoSPD with a relatively low number of security patches can perform well in some cases, such as untrusted data and race conditions. (2) The security patches that are frequently misclassified typically pertain to vulnerabilities stemming from inadequate verification processes, such as improper input validation and improper access control. These cases often do not present overt errors but rather require the understanding of multiple dependencies to identify vulnerabilities."}, {"title": "D. RQ4: Effectiveness of Different Components in RepoSPD", "content": "In this section, we explore the impact of different components of RepoSPD including the RepoCPG construction (i.e., w/o RepoCPG), the structure-aware patch representation (i.e., w/o sequence and w/o graph), and progressive learning (i.e., w/o progressive). The experimental results are shown in Table V.\n1) RepoCPG Construction: To explore the effect of the RepoCPG, we deploy one variant (i.e., w/o RepoCPG) by only using the PatchCPG proposed by GraphSPD. As shown in Table V, the RepoCPG can improve the performance of RepoSPD on all datasets. Specifically, incorporating the repository-level information to construct the RepoCPG leads to the average drop of 5.12% in accuracy, and 5.88% F1 score on two datasets. Especially on the SPI-DB* dataset, RepoCPG boosts the performance by 9.80% for accuracy, and 11.32% for F1 score, respectively. In addition, We attribute the relatively small improvement on the PatchDB* dataset to the higher number of dependencies, which is approximately twice that of SPI-DB*. The complex inter-dependencies may hinder the model's learning process to some extent.\n2) Structure-aware Patch Representation: To investigate the impact of the structure-aware patch representation, we construct two experimental variants for comparative analysis: (1) a variant exclusively utilizes the graph-based branch (i.e., w/o sequence), and (2) another solely employs the sequence-based branch (i.e., w/o graph), which verify the effectiveness of capturing semantic and structural information for detecting security patches, respectively.\nOur findings indicate a consistent performance decline across two datasets when the variants operate independently. Specifically, the variant using only the graph branch exhibits a decrease of 8.00%, while the variant relying solely on the sequence branch shows a decrease of 5.47% in terms of accuracy. This demonstrates that the sequence branch exerts more influence on RepoSPD. Furthermore, the graph branch notably reduces the FP rate, with the decrease of 13.60% and 2.03% in the SPI-DB* and PatchDB* datasets, respectively. This underscores the importance of structural information to increase the performance of security patch detection. We can achieve that both the graph and sequence branches contribute to the overall performance of RepoSPD, each playing a crucial role in security patch detection.\n3) Progressive Learning: To understand the effect of progressive learning, we also implement two variants for comparative analysis: (1) a variant of RepoSPD without the progressive learning component (i.e., w/o progressive), thereby requiring the model to learn weights simultaneously across all components. (2) another variant first trains the graph representation and then refines it into a sequence representation (i.e., changes order). Specifically, the performance consistently shows an average decrease of 2.36% in accuracy, and 2.83% in F1 score across SPI-DB* and PatchDB* datasets without a progressive learning component. It also demonstrate that RepoSPD performs well across two datasets, with an average improvement of 4.40% in accuracy and 3.61% in F1 score, while reducing the FPR by 7.61%. These results underscore the different branches have different learning strategies across various branches of the RepoSPD, with each branch learning unique discriminative representations. It allows for staged optimization and more targeted learning of different branches, which in turn enhances the overall capabilities of detecting security patches."}, {"title": "VI. DISCUSSION", "content": "We identify the advantages of RepoSPD, which can explain its effectiveness in security patch detection.\n(1) Incorporating repository-level information to help the security patch detection. We propose RepoCPG to integrate repository-level dependencies, which enhances the performance of security patch detection. As illustrated in Fig. 4(A), the example is drawn from a resource leakage vulnerability in the Linux kernel (i.e., CVE-2016-5243 [59]). Specifically, the function tipc_nl_compat_link_dump in net/tipc/netlink_compat.c fails to copy a particular string (Line 5), thereby allowing local users to access sensitive data from the kernel stack memory. This issue is addressed in Lines 6-7 through the use of nla_strlcp. However, nla_strlcp is not defined within the patch itself. RepoSPD effectively incorporates nla_strlcp as a dependency into RepoCPG, and accurately identifies the security patch.\n(2) Effectively capturing both structural and sequential information among multiple code changes. We propose the structure-aware patch representation to comprehend the relationships among multiple code changes. As illustrated in Fig. 4 (C), the _TIFFmalloc call at Line 5 of the pre-patch code implicitly assumes successful memory allocation, which effectively acts as an implicit assertion check. This assumption may lead to buffer overflows in release mode, particularly when handling atypical tile sizes. Furthermore, the patch includes a total of 11 code changes. RepoSPD can extract the structural dependency between Line 12 and Line 18, which collaboratively changes the function fpDiff. Additionally, RepoSPD captures the semantic information, revealing that Line 4 and Line 18 utilize identical statements to address the vulnerabilities. Based on the structural and semantic information, RepoSPD effectively detects the security patch."}, {"title": "B. Impact of Repository-level Context on False Negatives", "content": "We also perform experiments on the impact of repository-level context on false negatives and the results are listed in Table VI. The experimental results demonstrate that RepoSPD outperforms the current state-of-the-art baseline, CodeT5, in 5 out of 6 cases. Specifically, RepoSPD achieves improvements of 6.56% in precision and 2.24% in recall on the PatchDB* dataset. The sole exception is in the recall metric in SPI-DB*, where CodeT5 surpasses RepoSPD by 0.8%. It may be attributed to the additional context, which in some cases, has a minor impact on the rate of false negatives."}, {"title": "C. Training and Inference Time", "content": "We have conducted a detailed analysis of the training and inference time costs per epoch for both RepoSPD and CodeT5, as presented in Table VII. The results indicate that RepoSPD requires, only 857.15 seconds for training per epoch and 64.58 seconds for inference in the test set. In comparison, the best-performing baseline, CodeT5, requires 2745.51 seconds for training and 189.29 seconds for inference. The reason is that the graph branch is more efficient than the sequence branch (pre-trained model)."}, {"title": "D. Threats and Limitations", "content": "We have identified the following major threats and limitations:\nConstraints of Data Collection. To facilitate the identification of security patches at the repository level, we meticulously extracted 20,238 and 28,781 versions of repositories from platforms such as GitHub to reconstruct SPI-DB* and PatchDB*. Despite our extensive efforts to crawl the largest known repositories, some repositories listed in the National Vulnerability Database (NVD) [61] remained inaccessible. In our future work, we aim to expand our collection of security patches.\nGeneralizability on Other Programming Languages. In this paper, we construct the RepoCPG using Joern, Tree-sitter, and Cflow, specifically tailored for C/C++. While our experimental evaluations are focused on C/C++, the RepoSPD can be extended to support other programming languages by integrating code analyzers that accommodate the respective syntax and structural paradigms. In future work, we plan to explore the applicability and effectiveness of RepoSPD across wider programming languages, such as Java and Python, thereby broadening its applicability for security patch detection.\nRestrictions of Dependency Extraction in Repository. We do not use the entire dependency graph in the repository due to the size of the RepoCPG and the limitations inherent in static analysis techniques. While this approach is generally sufficient, it fails to encompass all scenarios, such as multi-level function calls within the repository. A potential solution to enhance the coverage could involve the development of additional rules and the application of more sophisticated slicing methods to construct the RepoCPG."}, {"title": "VII. RELATED WORK"}]}