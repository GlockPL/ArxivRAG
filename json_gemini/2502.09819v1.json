{"title": "A SOLVER-AIDED HIERARCHICAL LANGUAGE FOR LLM-DRIVEN CAD DESIGN", "authors": ["Benjamin T. Jones", "Felix H\u00e4hnlein", "Zihan Zhang", "Maaz Ahmad", "Vladimir Kim", "Adriana Schulz"], "abstract": "Large language models (LLMs) have been enormously successful in solving a wide variety of structured and unstructured generative tasks, but they struggle to generate procedural geometry in Computer Aided Design (CAD). These difficulties arise from an inability to do spatial reasoning and the necessity to guide a model through complex, long range planning to generate complex geometry. We enable generative CAD Design with LLMs through the introduction of a solver-aided, hierarchical domain specific language (DSL) called AIDL, which offloads the spatial reasoning requirements to a geometric constraint solver. Additionally, we show that in the few-shot regime, AIDL outperforms even a language with in-training data (OpenSCAD), both in terms of generating visual results closer to the prompt and creating objects that are easier to post-process and reason about.", "sections": [{"title": "INTRODUCTION", "content": "Parametric Computer-Aided Design (CAD) systems revolutionized manufacturing-oriented design by introducing a paradigm where geometry is created through a sequence of constructive operations. This approach enables both accuracy and precision in modeling and offers flexibility in design editing. Essentially, CAD systems use domain-specific languages (DSLs) to express geometry as a program, with CAD GUIs as end-user programming interfaces.\nRecent advances in generative AI have significantly enhanced the creation of 2D and 3D geometry, yet achieving the precision, detail, and editability provided by CAD models remains a challenge. To bridge this gap, one promising strategy is to harness the powerful code generation capabilities of pre-trained large language models (LLMs) and the geometry-as-a-program paradigm from CAD. Rather than generating the geometries directly, we generate CAD programs that produce the geometric structures. However, this raises a crucial question: How can we reimagine the traditional CAD DSL principles, which have been designed for a constant visual feedback loop, to craft innovative languages for design in an age where code is generated with support from AIs?\nIn this work, we address this question and propose a new DSL for CAD modeling with LLMs, which we call AIDL: AI Design Language. Through experiments with different existing models and prior work that analyzes their observed behavior, we identify four key design goals for our DSL. Namely, we propose a solver-aided approach that enables LLMs to concentrate on high-level reasoning that they excel at while offloading finer computational tasks that demand precision to external solvers. For CAD, this means that the DSL should enable implicitly referencing previously constructed geometry (dependencies) and specifying relationships between parts that can then be solved by the solver (constraints). Further, we aim to create semantically meaningful abstractions that leverage the LLM's proficiency in understanding and manipulating natural language (semantics). Finally, we advocate for a hierarchical design approach, which allows for encapsulating reasoning within different model parts and enhancing editability (hierarchy).\nOur analysis of existing CAD DSLs reveals that none achieve all four design goals, and supporting all goals simultaneously presents challenges due to conflicting requirements. For example, the ability to unambiguously reference all intermediate parts of the geometry (dependencies) is a known challenge in CAD. While recent work proposes a language that supports unambiguous referencing, it requires semantic complexity (semantics). Additionally, while constraints are widely used in specific aspects of CAD design, such as assembly modeling (constraints), supporting them in a complex model with hierarchically defined constraints (hierarchy) is computationally challenging. Our key insight is that we can address these challenges by both limiting and expanding different language constructs from prior CAD DSLs. While we limit the use of references to constructed geometry, without losing geometric expressivity, we expand the use of constraints to hierarchical groups of geometry, so called structures. We support these novel language constructs with a recursive constraint solver that leverages the hierarchical structure to tractably solve global constraint systems.\nWe present a series of text-to-CAD results in 2D generated with our language, and we evaluate the importance of different aspects of AIDL by comparing it to OpenSCAD, a popular CAD language, and subsets of the AIDL language that has hierarchy or constraints disabled. For these methods, we report CLIP scores of the generated results and conducted a perceptual study on the generated CAD renderings. Our experiments show that AIDL programs are visually on-par with or better than their OpenSCAD counterparts despite the LLM not seeing AIDL code in its training data, while having superior editability, and our ablations demonstrate that introducing hierarchy contributes to local editability, while constraints allow complex multi-part objects to be composed precisely. With AIDL we show that language design alone can improve LLM performance in CAD generation."}, {"title": "RELATED WORK", "content": "The compilation of large CAD datasets in recent years (Koch et al., 2019; Willis et al., 2021b; Jones et al., 2021; Willis et al., 2022) has inspired a wealth of research on synthesizing CAD models. These efforts fall into two broad categories; those which generate CAD geometry directly (Willis et al., 2021a; Guo et al., 2022; Jayaraman et al., 2023; Nash et al., 2020; Xu et al., 2024; Liu et al., 2024), and those which generate a procedure that generates CAD geometry (Wu et al., 2021b; Ellis et al., 2017; 2018; Ganin et al., 2021; Ren et al., 2022; Li et al., 2023a; Xu et al., 2022; Lambourne et al., 2022; Para et al., 2021a; Seff et al., 2022; Willis et al., 2021b; Ma et al., 2024; Li et al., 2024; Khan et al., 2024). A fundamental challenge with these tools is the ability to control the generation. While many methods can be conditioned on an input allowing for reverse engineering applications (Lambourne et al., 2022; Guo et al., 2022), the few methods that directly focus on generation give limited control over their output (Jayaraman et al., 2023; Wu et al., 2021a; Xu et al., 2024; Seff et al., 2022). The highest degree of control is afforded by those that take sketches as input, such as Free2CAD (Li et al., 2022) but these are effectively reverse reverse engineering an existing geometric design rather than enabling high level guidance. The goal of AIDL is to enable control without direct geometric supervision, and to incorporate semantic understanding beyond that of existing CAD programs. We have thus chosen to design our system around general purpose language models rather than CAD specific models, and focus on DSL design rather than the design or training of a generative model. Importantly, all prior works use CAD DSLs that have limitations when it comes to LLM needs, as we discuss in Section 3.1.\nSoftware engineering has been one of the marquee applications of LLMs, so a detailed enumeration of works in the field is beyond the scope of this paper. We instead refer the reader to a survey Zhang et al. (2024), and reserve this section to position AIDL within the space. The majority of research on using LLMs for coding focus on how to make LLMs work more effectively with existing programming languages. A popular approach is to specifically train or fine-tune a model on code repositories and coding specific tasks (Li et al., 2023b; Lozhkov et al., 2024; Grattafiori et al., 2023), or more recently to use LLMs to generate higher complexity training examples (Xu et al., 2023; Luo et al., 2023). Other approaches tackle prompt complexity through system design, exploring prompt engineering and multi-agent strategies for pre-planning or coordinating a divide-and-conquer strategy (Dong et al., 2023; Bairi et al., 2023; Silver et al., 2023). AIDL approaches LLM code generation from an entirely different perspective, by asking which language features will best enable an LLM to work with a programming system. Most similar is BOSQUE, a proposed general purpose programming language (Marron, 2023). In particular, BOSQUE's embrace of pre and post conditions mirrors AIDL's use of constraints and strong validation, but does not go so far as to employ a solver to enforce constraints.\nWhile there are many CAD DSLs, they can be grouped intro three broad categories:\nConstructive Solid Geometry (CSG) In CSG, users can specify 2D and 3D parametric primitives, such as rectangles or spheres, directly in global coordinates. Using boolean operations, such as union or intersection, users then combine these primitives in a hierarchical tree structure to achieve complex designs. While some CSG languages, such as OpenSCAD, allow the use of variables or expressions for primitive parameters, they do not support specifying relationships or dependencies between different parts of the geometry. This absence of dependencies simplifies the abstraction, making CSG widely used in inverse design and reconstruction tasks (Du et al., 2018; Nandi et al., 2020; Yu et al., 2022; Michel & Boubekeur, 2021). However, this limitation also makes modeling more challenging, which is why CSG is not commonly used in most commercial CAD tools.\nQuery-based CAD Most commercial CAD tools use query-based languages, such as Feature-Script (Onshape, 2024), which employ a sequence of operators to create and modify models (e.g., extrude, fillet, chamfer). These operators reference intermediate geometry-e.g., a chamfer operator takes a reference to an edge. This referencing creates implicit dependencies, simplifying modeling and enabling easy editing as operations propagate when intermediate geometry is updated. However, a challenge arises when edits lead to topological changes, making reference resolution ambiguous. For example, if an edge gets split or disappears, where should the chamfer be applied? To address this, these languages do not reference geometry explicitly. Instead, geometric references are specified implicitly via a language construct called queries. These queries are resolved during runtime by a solver (CadQuery, 2024; Onshape, 2024), which typically uses heuristics to resolve ambiguities. This makes automating design challenging, and generative tools that use CAD operators restrict themselves to sequences where references are not needed, such as sketch and extrude (Wu et al., 2021a; Willis et al., 2021b; Lambourne et al., 2022). While recent work allows for the unambiguous direct specification of references (Cascaval et al., 2023), mastering this language is complex and demands significant expertise.\nConstraint-based CAD As the name implies, constraint-based CAD DSLs natively enable users to create geometric constraints between geometric primitives. This frees designers from specifying parameters consistently, allowing for freeform design while ensuring that relationships between parts are preserved. This approach is used in content creation languages like Shape-Assembly (Jones et al., 2020), GeoCode (Pearl et al., 2022), and SketchGen (Para et al., 2021b). In typical commercial CAD tools, constraint-based abstractions are used in sketches-2D drawings that get extruded to form 3D geometry\u2014and during assembly modeling, but not during solid modeling which uses queries. These languages do not provide operations to modify primitives or to create intermediate geometry and therefore they reference geometry directly. Designs specified in these languages are non-hierarchical, all constraints are being solved simultaneously."}, {"title": "AIDL - A LANGUAGE FOR AI DESIGN", "content": "In this section, we present AIDL, a CAD DSL for LLM-generated designs."}, {"title": "LLM ANALYSIS AND DESIGN GOALS", "content": "We review the strengths and weaknesses of LLMs and formulate design goals that our DSL should support.\nDirect vs. indirect computation Findings by Bubeck et al. (2023) and Makatura et al. (2023) suggest LLMs perform better with external solvers. For CAD, we aim to enable LLMs to express design intent by specifying geometric relationships instead of performing direct computation. In modern CAD tools, geometric relationships can be defined using implicit dependencies or explicit constraints, each with trade-offs. Geometric dependencies create implicit constraints that are easy to enforce, but long chains of references are challenging to reason over (Makatura et al., 2023). Users typically avoid this issue by generating references automatically through CAD state interaction rather than writing CAD code directly. Explicit constraints, like those in CAD sketches or assemblies are easier to reason about, but harder to solve. It is also challenging to add just the right number of constraints so that the system is neither often under-or over-constrained. To achieve the best of both worlds, we aim to support both implicit constraints through geometric dependencies (dependencies) and specification of geometric relationships via constraints (constraints).\nNamed variables and semantic cues LLMs are designed to manipulate words, i.e., terms with semantic meaning. In their experiments, Makatura et al. (2023) reparametrize CSG programs with and without informing the LLM about the modeled object. Their results suggest that better reparametrizations are obtained by providing additional semantic knowledge. Our CAD DSL should use intuitively named terms (semantics) for design operations, references and constraints. Our language should also expose geometric entities easily, without many semantic indirections.\nDesign complexity and modularity Bubeck et al. (2023) observe that GPT-4 can generate \"syntactically invalid or semantically incorrect code, especially for longer or more complex programs.\" Similarly, Makatura et al. (2023) note that complex designs may miss components or have them incorrectly placed. To address this, our CAD DSL should treat hierarchical design that supports modularity (hierarchy) as a first-class construct, enabling the breakdown of complex problems into manageable units. This hierarchy should facilitate planning and iteration in code generation."}, {"title": "KEY CHALLENGES AND DSL DESIGN DECISIONS", "content": "Combining all of the goals above in a single CAD DSL requires addressing two key challenges.\nThe first challenge is creating dependencies on previously constructed geometry (dependencies) without increasing the semantic complexity of operators (semantics). As explained in Sec. 2.3, previously constructed geometry cannot be persistently named because parametric variations often lead to topological changes. DSLs that reference previously constructed geometry use queries-algorithms that retrieve the geometry at a given state. However, this solution prevents assigning persistent semantic names to geometric entities, increasing semantic complexity and, our analysis shows that LLMs struggle to reason about queries with long chains, motivating our choice to disable them by design.\nOur solution to enable dependencies without queries arises from the observation that all geometric primitives in CAD are created either through constructive operations that instantiate primitives or through boolean operations (e.g., when two edges intersect, a new vertex is generated). While this is evident for CSG DSLs we note that query-based CAD DSLs are not more expressive than CSG DSLS since all CAD operators (e.g. chamfering) can be expressed as a combination of a constructive and a boolean operation Cascaval et al. (2023). Reference challenges emerge from boolean operations, as changes in parameters can lead to a varying number of generated primitives.\nWhile we still want the geometric expressivity enabled by boolean operations, we want to reference geometry without queries. To overcome this problem, we decide to restrict our DSL to only use references for geometry created before boolean operations. In our DSL, boolean operations are applied to structures, which is an intermediate type to create tree-structured hierarchies, see Fig. 5. The result of these booleans cannot be referenced, just as with CSG DSLs, however, we can reference constructed geometry and structures themselves. Although this introduces a language limitation, it does not affect 1) geometric expressivity, since in the worst case, you can have one geometry per structure, achieving the same expressiveness as CSG, and 2) dependency expressivity, as AIDL allows for arbitrary parametric expressions, meaning that in the worst case, dependencies can still be expressed manually, albeit with more effort.\nSecond, using constraints (constraints) to specify the relationship between elements within hierarchical designs (hierarchy) is computationally challenging. Hierarchical designs encourage growing complexity and an increasing number of constraints, driving down solver performance. Query-based languages deal with this complexity by solving constraints in intermediate, flat designs, e.g constraints between sketch elements in a CAD sketch are first solved before the user can extrude the sketch. Solving constraints from all CAD operations simultaneously is computationally too expensive for these systems. To tackle this challenge, we introduce (1) two types of constraints, one between geometry and one between structures, and (2) a custom recursive solver to hierarchically solve constraints in a design. This strategy allows us to explicitly define the hierarchy of constraints and to practically solve it, without providing intermediate feedback to the LLM."}, {"title": "AIDL BY EXAMPLE", "content": "Next, we showcase AIDL by example and show how the different language constructs fulfill our design goals. First, we will illustrate the basic constructs of AIDL with the phone handset example in Fig. 2. An AIDL program starts by defining the high-level logic of a design. These high-level building blocks are called structures and they are of different types, such as Solid and Hole, and they can be empty, a list of primitives, a list of substructures or any combination of these, see Fig. 5.\nIn the handset example, we first define an empty structure, L.2, which we populate with primitives, such as rectangles, lines and arcs, L.3-L.8. Next, we add unary and binary geometric constraints, e.g. Horizontal and Coincident, between these primitives, L.10-L.16. Finally, we solve the constraint system to optimize for the final parameters of each geometric primitive, L.18.\nIn AIDL, references are pointers to geometry, parameters or structures. They have various usages.\nFirst, instead of specifying coordinates directly such as in L.3, we can use references to reuse already defined geometry. For example, in L.4, we define an Arc, which in the AIDL API is defined via Arc(center, start, end). The left_round arc starts at the upper left corner of the base rectangle via the reference handset.base.top_left. This strategy lowers the risk of erroneously recomputing coordinates of the upper left point. Second, this reference ensures that base and left_round stay attached during the constraint solving process. Indeed, by sharing a common point, we implicitly define a coincidence constraint between them.\nGeometric primitives can also be referenced within constraint calls. In L.10, we explicitly define a coincidence constraint between the upper right corner of base and the end point of the arc right_round. The arc right_round has been defined with explicit coordinates in L.6, which, without further constraints, is not necessarily connected to the rest of the shape, see Fig. 2 (top right).\nLastly, as can be seen in Fig. 5, references can also point to parameters of geometric primitives. This allows for more control and more expressivity when defining geometry and constraints. Consider L.12, where we used equation constraints to express a symmetric design intent on the two lines left_line and right_line. L.12 declares that both lines should have the same length, which is a parameter of the Line primitive. Parameters are referenceable on the same level as geometry and structures, making them first-class constructs in our language.\nConstraints Constraints express design intent, i.e., the way that geometry should behave under change. As we have already seen, in AIDL, constraints can be implied by sharing a reference, see L.4, or by explicitly adding them to the design via AddConstraint calls. Constraint operations have a certain constraint type and they take as input references. Depending on the constraint type, either equality or inequality constraints will be enforced on the geometric parameters specified by the input references. For example, in L.14, the Equal constraint type enforces the diameter of the two arcs left_fillet and right_fillet to be the same.\nUsing references and constraints, we can explicitly state the design intent, which will be realized by an external solver, L.18, (dependencies), (constraints).\nSynonymous operators References and constraints in a DSL are useful if they are easy to use. For human users, learning a new DSL can be challenging if its API is long and redundant. Concise APIs are usually preferred. However, designing a DSL for LLMs introduces a different criteria, which is that the LLM might write a function call which is not part of the API, but which is semantically equivalent. For example, consider the two constraint calls: (1) AddConstraint(Perpendicular( line_1, line_2)) and (2) AddConstraint (Orthogonal( line_1, line_2)).\nIntuitively, both Perpendicular and Orthogonal should enforce the same angle between the two lines, i.e., they are synonyms. However, to reduce redundancy, most APIs will choose only one of them. In AIDL, we expose both constraint types, to account for syntactical weaknesses of LLMs and to take advantage of their semantic versatility (semantics). More generally, we opt for a robust API vocabulary, allowing for different ways of constructing primitives, e.g. Triangle (center, base, height) vs. Triangle(pt_a, pt_b, pt_c).\nNote that even though we have synonymous references in AIDL, they are all being compiled to unique identifiers. During the interpretation of the program, we include only referenced entities in the model.\nHierarchical designs Next, we illustrate the use of hierarchical designs with a complete phone design, see Fig. 1. The phone is an assembly made out of three different structures, the base, receiver and dial_plate, which are all Solid structures. These structures are directly attached to the telephone structure on lines 5, 9 and 13. As for the handset design in Fig. 2, each structure defines its own geometry and and constraints, e.g. the constraints for the receiver, L.20-21. Constraints can also be enforced between structures, which will be solved iteratively in tandem with structure-internal constraints, see Sec. 3.4.\nFinally, in AIDL, the result of a boolean operation cannot be referenced, since the parameter-dependent topological outcome requires queries, see Sec. 3.1. To implement this, boolean operations are implied by using different structure types and then applied after constraint solving in a boolean post-process."}, {"title": "COMPILATION AND CONSTRAINT SOLVING", "content": "The hierarchical organization of AIDL models allows for recursive constraint solving. We employ an iterative deepening, recursive solver strategy that allows AIDL to solve a minimal constraint problem at each stage, and also keeps substructures fixed as much as is possible to avoid unintuitive changes to substructures due to higher-level constraints. (translations of substructures are preferred over modification of internal geometry to satisfy constraints). To facilitate this recursive solving, AIDL models are first validated to ensure that each substructure is independently solvable, then compiled into a hierarchy of geometric constraint problems that we solve with an iterated Newton's method solver. The solved model is then post-processed to perform boolean operations and generate the final geometry.\nWhen an AIDL program is run as a Python program, it generates a Structure tree data structure. An AIDL model is valid if Geometry only references other Geometry belonging to the same Structure, and Constraints only reference Geometry, Parameters and Structures within the same subtree. Definition of constraint equations in AIDL is deferred until after the tree structure is finalized because bounding boxes and some geometric constraints are not well defined until the model topology and initial parameters are fixed. Two non-inversion constraints are added to each bounding box, $height >= 0$ and $width >= 0$, using a slack variable formulation borrowed from linear programming (e.g. $height + s == 0 \\ s - |s| == 0$).\nThe constraint system of an AIDL model is solved hierarchically as described in Appendix B using an iterated Newton's method solver (based on SolveSpace Westhues (2022)). Iteration is used to support bounding boxes; at each iteration we fix the expression of each bounding box limit relative to the initial positions of its geometry, then re-check and re-solve if a different piece of geometry now defines the limit. Solved AIDL models are post-processed to apply boolean operations defined by Solid and Hole Structures. Curve geometry is recursively aggregated to discover closed faces which are boolean unioned or subtracted from each other depending on the type of Structure they belong to. We use the OpenCascade Modeling Kernel OCCT3D (2021) to perform boolean operations and generate output in the CAD standard STEP format."}, {"title": "EXPERIMENTS", "content": "Implementation For our experiments, we perform LLM-driven 2D CAD generations with AIDL. AIDL enables LLM-driven text-to-CAD through a front-end generation pipeline. The pipeline follows a common validate-until-correct pattern. We first prompt the LLM with a detailed language description of AIDL, which includes AIDL's syntax, primitive geometry types, and available constraints. Then the LLM is prompted with six manually designed example programs in AIDL for these objects: bottle opener, ruler, hanger, key, toy sword, and wrench. Please refer to the supplemental material for the full list of prompts. Finally, it is prompted to generated the full AIDL program of the desired model. The front-end then executes the generated program, returning tracebacks directly to the LLM in case of failure and prompting the LLM to fix the error. This generation loop is repeated until either a syntactically correct program is found or after N = 5 failed attempts, taking advantage of incomplete executability to give feedback on partial generations. For all our experiments, we use the OpenAI's gpt-40 model without finetuning, and we run each prompt ten times with different seeds and collect the runs that generated a valid program.\nResults We report both the rendering and program of all runs of on 36 manually generated prompts in the supplemental material. In Figure 3, we show renderings for a diverse subset of the generated AIDL programs. Despite the LLM not being finetuned with our AIDL language, it successfully generates accurate CAD geometry based on its prior knowledge of these objects. Furthermore, the geometries are grouped hierarchically by semantically meaningful structures and constraints, making them easy to edit. See appendix D for an illustration of how an AIDL model can be modified.\nComparisons For comparison, we perform 2D text-to-CAD with the OpenSCAD language, the most common language for directly coding geometries in CAD, unlike other languages that are typically used with GUIs for end-user programming. We directly prompt the LLM to generated CAD geometry in the OpenSCAD language since the gpt-40 model has prior knowledge about its syntax. We used the same 36 prompts and report all results in the supplemental material. Despite the LLM's familiarity with OpenSCAD, we observe that AIDL results are often closer to the prompt and achieve higher CLIP scores (see Table 2). In addition to better prompt alignment, AIDL results exhibit more semantic structure. In particular, the OpenSCAD language does not support specifying relationships or dependencies between components, thus the LLM would often opt to generate polygons of the desired shape by specifying explicitly the vertex coordinates (see Figure 4), making the resulting program highly difficult to edit.\nWe also attempted using FeatureScript and the DSL from the recent work Cascaval et al. (2023) for LLM-drive 2D CAD generations. However, the LLM failed to generate syntactically correct programs in almost all cases. This issue was not rectified even when prompting the LLM with example programs and code documentations in those languages. These two languages are not syntactically based on common programming languages usually found in LLM training sets. This indicates the importance of designing a semantically rich language that is easy for the LLM to use and manipulate."}, {"title": "Ablations", "content": "We ablate our language design choices by comparing AIDL against two variants: AIDL no hierarchy and AIDLno constraints, which disable hierarchy and constraints respectively. In AIDLno hierarchy, all the geometries of a program will live on the same level under a single Structure instance, and all constraints will also be attributed to this single Structure. On the other hand, AIDLno constraints is a subset of AIDL where we have simply removed the ability to specify any constraints. For these language subsets, we modify our initial prompts to the LLM to reflect the altered language features. We report all runs on the same 36 prompts in the supplemental material.\nWhile AIDLno constraints occasionally places components correctly, editing such programs is difficult because scaling requires individual adjustments for each component, whereas constraints allow a single edit to affect all geometries. Additionally, it often produces detached components due to the lack of constraints (see Figure 4 and the \"fountain pen\" example in the supplemental material).\nPrograms generated with AIDLno hierarchy, while being visually similar to the ones generated with AIDL, are harder to refine, since the user cannot choose a particular part of the CAD shape to make local edits, as shown in Figure 4.\nWe observe that neither variation of AIDL significantly impacts CLIP scores for the renderings (Table 2), because that CLIP scores do not take into account editability and they place more emphasis on local semantics than having precisely connected geometries."}, {"title": "Results Across Multiple Runs", "content": "All methods produced at least one valid output per prompt, with success rates as follows: ours: 64%, AIDLno constraints: 94%, AIDL no hierarchy: 77%, and OpenSCAD: 79%. Notably, our method's success rate is only slightly lower than OpenSCAD, which is included in the training data. To showcase the highest-quality output for each method side by side, considering that LLMs produce varying outputs across runs, we conducted a perceptual study to rank the valid CAD programs generated from the 10 runs per method and prompt. The study details are discussed in appendix C, and the results are provided in the supplemental material."}, {"title": "Limitations", "content": "Our experiments revealed limitations of our system, particularly around model complexity and underused language features. AIDL supports rectangle rotation, yet all rectangles used in generated examples are axis-aligned. Looking at the generated code and conversation history (see supplemental) shows that the LLM did frequently specify that rectangles were rotatable (a flag in the Rectangle constructor), but failed to rotate them. One shortcoming of the AIDL library is that rectangles can only be rotated by the constraint solver, so an appropriate constraint (usually Angle) must be imposed to cause a rectangle to rotate. In cases where the LLM attempted to do this, it hallucinated a non-existent constraint like Rotate instead. When errors are reported to the LLM, the most common response is to try removing constraints or structures until the error goes away. Since we apply a validate-until-correct pattern, this means that the removed design intent (e.g. rectangle rotation) is never returned to the model. These limitations stem from our choice to focus on DSL design rather than the complementary approaches of model training or tuning, or prompt engineering. Fine-tuning a model on AIDL code could reduce the incidence of language feature hallucination, and crafting a more interactive prompting and feedback system could allow an LLM to recover lost complexity and design intent in the face of errors."}, {"title": "CONCLUSION", "content": "AIDL is an experiment in a new way of building graphics systems for language models; what if, instead of tuning a model for a graphics system, we build a graphics system tailored for language models? By taking this approach, we are able to draw on the rich literature of programming languages, crafting a language that supports language-based dependency reasoning through semantically meaningful references, separation of concerns with a modular, hierarchical structure, and that compliments the shortcomings of LLMs with a solver assistance. Taking this neurosymbolic, procedural approach allows our system to tap into the general knowledge of LLMs as well as being more applicable to CAD by promoting precision, accuracy, and editability. Framing AI CAD generation as a language design problem is a complementary approach to model training and prompt engineering, and we are excited to see how advance in these fields will synergize with AIDL and its successors, especially as the capabilities of multi-modal vision-language models improve. AI-driven, procedural design coming to CAD, and AIDL provides a template for that future."}, {"title": "LANGUAGE SYNTAX", "content": "A LANGUAGE SYNTAX\nstructure ::= (frame, sketch, [ref(structure)], [constraint])\nframe ::= (type \u2208 {Assembly, Solid, Hole, Drawing}, orientation \u2208 { Top, Front, Side }, ...)\nsketch ::= <[ref(geometry)], [ref (parameter)])\nparameter ::= <val \u2208 R, mutable \u2208 B )\nref(T) ::= <name \u2208 String, ptr \u2208\u315c)\ngeometry ::= Point | Line | Arc | Circle | Rectangle | ... primitives ::= make_point | make_line | make_arc | make_circle | make_rectangle | ...\nconstraint ::= logical_expr | structural_constraint (ref(T), ref(T))\nlogical_expr ::= unary_geometric_constraint (ref (T)) | binary_geometric_constraint (ref (T), ref(T))\nstructural_constraint ::= above center inside left_of taller ...\nunary_geometric_constraint ::= horizontal diameter fixed...\nbinary-geometric_constraint ::= coincident tangent equal symmetric...\nlogical_expr ::= arith_expr = arith_expr | arith_expr < arith_expr | arith_expr > arith_expr | logical_expr ^ logical_expr\narith_expr ::= parameter | u_op arith_expr | arith_expr b_op arith_expr\nu_op ::= sin | cos | arcsin | arccos | sqrt | abs | norm | square\nb_op ::= + - \u00d7 \u00f7 | min | max\nTypes and operations of AIDL. T represents the union type (structure-parameter-geometry). [8] is the notation used to represent an array or list of 0."}, {"title": "SOLVER DETAILS", "content": "B SOLVER DETAILS\nIterative Deepening Recursive Solve Constraint problems in AIDL are solved recursively over the structure tree in a post-order traversal, illustrated in the left half of Figure 6. At each step of this recursive solve, AIDL attempts to find a solution where only the geometry and parameters of the structure being solved, and not its substructures, are free parameters in the solve; everything deeper is initially treated as constants. This is done to minimize both the size of the constraint problem being solved, and to minimize perturbations to previously solved substructures. The validity condition that constraints can only reference geometry, structures, and parameters within a structure subtree ensures that if the constraints defined at the root of a subtree are satisfied, then the whole subtree is fully solved because child structure constraints cannot reference variables that would have changed.\nSome constraint problems cannot be solved entirely locally, especially when a constraint in used to relate geometry between children. This is where we apply iterative deepening, in two stages. First we iteratively allow child structures at deeper levels to be translated by adding their translation frame parameters into the solver's set of free variables. As this search deepens, it also necessitates re-adding the constraint sets of the parent structures of translatable structures into the constraint set to be satisfied, since moving a child structure could invalidate a previously solved constraint. If translating structures is insufficient to satisfy the constraint system, then we repeat a similar iterative deepening, this time allowing all parameters, translation and otherwise to be solvable at each level. In this second iterative deepening it is necessary to include the constraints at the same level as the frontier of solver parameters, rather than the parent level, since geometric parameter changes could invalidate previously solved constraints. Iterative deepening continues until a valid solution is found, or all levels of the hierarchy have been exhausted (in which case the solve has failed because the constraint system is inconsistent or intractable.)\nDeferred Expressions While some constraints and expressions are well-defined mid-execution of an AIDL program, others can only be explicitly specified after the full topology and initialization of the model has been finalized by running the Python DSL code. The primary examples of these are bounding box coordinates, because they could depend on dynamically generated geometry, and ambiguous geometry constraints. An example ambiguous constraint is one like Angle (L1, L2, theta), which constraints the angle between lines L1 and L2 to be equal to theta. The meaning of this constraint depends on the angle convention in use; is the angle measured clockwise or counter-clockwise between these two lines? In a traditional constraint language, a single consistent convention would be applied and programmers expected to learn and follow this convention, but a design principle of AIDL is to be flexible in calling conventions. To allow this, we infer the calling convention intended by picking the convention that is nearest to being satisfied by the initial parameters of the constrained geometry. Since parameters are dynamically mutable, these determinations must also be deferred until immediately before constraint solving.\nBounding box expressions"}]}