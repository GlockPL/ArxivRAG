{"title": "ONLINE DESIGN OF DYNAMIC NETWORKS", "authors": ["Duo Wang", "Andrea Araldo", "Mounim El Yacoubi"], "abstract": "Designing a network (e.g., a telecommunication or transport network) is mainly done offline, in a planning phase, prior to the operation of the network. On the other hand, a massive effort has been devoted to characterizing dynamic networks, i.e., those that evolve over time. The novelty of this paper is that we introduce a method for the online design of dynamic networks. The need to do so emerges when a network needs to operate in a dynamic and stochastic environment. In this case, one may wish to build a network over time, on the fly, in order to react to the changes of the environment and to keep certain performance targets. We tackle this online design problem with a rolling horizon optimization based on Monte Carlo Tree Search. The potential of online network design is showcased for the design of a futuristic dynamic public transport network, where bus lines are constructed on the fly to better adapt to a stochastic user demand. In such a scenario, we compare our results with state-of-the-art dynamic vehicle routing problem (VRP) resolution methods, simulating requests from a New York City taxi dataset. Differently from classic VRP methods, that extend vehicle trajectories in isolation, our method enables us to build a structured network of line buses, where complex user journeys are possible, thus increasing system performance.", "sections": [{"title": "1 Introduction", "content": "Methods for network designs are generally only aimed at static networks [1, 2]. They usually assume a fixed structure of graphs. However, these graphs are far from the real world. However, real-world networks are dynamic. For example, friend relationships in social networks are added or deleted over time, and transport systems often change over time. These dynamics can be captured by Temporal Graphs (TGs), which can change over time. TGs have been adopted to model transport systems [3, 4], social networks [5], recommendation systems [6] and many others [7, 8, 9].\nPrevious works focus on analyzing TGs, or on solving problems on top of a TG with exogenous time-evolution. To the best of our knowledge, this paper is the first to tackle the design of TGs. Differently from previous work, where dynamics are exogenous, we wish instead to determine such dynamics to optimize some objective function, faced with some random and time-varying environment. We focus in particular on a particular class of TGs, namely Time-Expanded Graphs.\nOur main contributions are the following:"}, {"title": "2 Related Work", "content": "We first frame our approach in the context of the research work on Temporal Graphs. Since we also apply our method to a transport case, we also briefly review the related literature."}, {"title": "2.1 Dynamic graphs", "content": "Temporal Graphs (TGs) are graphs that evolve over time. Several types of temporal graphs exist. Two main types of evolution have been mainly considered. (1) Label evolution refers to changes of attributes associated to edges and/or vertices. (2) Topological evolution refers to changes in a graph topology (for instance, nodes and edges appear or disappear over time). We focus on the latter category in this paper and whenever we write Temporal Graph (TG), we refer just to this latter category.\nA review of the literature on TGs is provided in [11]. Currently, the main research tasks considered for TGs are mining frequent subgraphs [12, 13], mining periodic patterns [14], finding association rules [15], mining motifs [16] and temporal link prediction [17]. Temporal Graph Neural Networks (TGNNs) have achieved state-of-the-art results in the above problems [17]. The main purpose of the above studies is \u201cobservation\u201d, i.e., to learn some common patterns, for example common frequent subgraphs, in TGs or analyze some statistical properties. More precisely, given a TG G = {G_{t\u2212N},G_{t\u2212N+1},..., G_t}, they try to find some common patterns in the current state and then verify these patterns in the next state G = {G_{t-N},G_{t-N+1},...,G_{t+1}}. These studies attempt to observe some common characteristics in the evolution of TGs without such an evolution.\nIn other work, on top of an evolving network modeled via TG, a certain optimization problem is solved [18, 19]. In this case, the decision variables of such problems do not impact network evolution, rather they have to \"cope with\" network evolution. In other words, in such work, network evolution is exogenous. In this paper, we are interested instead in designing network evolution ourselves. In other words, we do not perform some tasks on a network that is evolving out of our control, but we instead construct a temporal network. To emphasize the idea of construction over time, we will say that we grow a TG. This case is particularly important when dealing with dynamic networks such as communication or transport networks. In such cases, we may not be content with analyzing them, rather we may need to design them.\nTemporal Graphs can be represented in many ways. The most common representation methods for a TG are (1) using a sequence of snapshots (static graphs) [20, 21] and (2) using a Time-Expanded Graph representation, which replicates every node at each time instant to expand the time dimension, e.g. [22, Fig. 3]. A sequence of snapshots represents discrete moments, and changes occurring between such moments might be missed. A TEG can instead capture the evolution of the network over time in a single graph, allowing for continuous representation of changes. While the \u201cobserving\u201d problems, mentioned above, can rely on a sequence of snapshots to represent a dynamic network, in our design problem, it is preferable to be able to make the graph evolve at any moment. This is why we concentrate on TEGs here.\nWe now review work solving some optimization problems on top of TEGs. In [23], the shortest paths are computed on a TEG. Since TEGs could be in theory extended up to infinity, the question of how to efficiently \u201cunroll\u201d a TEG over"}, {"title": "2.2 Dynamic Vehicle Routing Problem (DVRP)", "content": "In \u00a74, we apply our generic method to a transport problem, which could also be framed as a Dynamic Vehicle Routing Problem (DVRP). DVRP is reviewed in [27] and [28]. In DVRP, trip requests arrive over time and the route of a fleet of vehicles is dynamically adjusted to serve those trips. Heuristics such as insertion methods [29, 30] or reoptimization methods [31] are the most popular. The optimization method of [32] is considered by many the state of the art. DVRP methods generally suffer from the following limitations: (1) each vehicle is routed independently and (2) a user can only use one vehicle, no transfers are allowed. These characteristics are typical of shared-taxis systems and limit their capacity, far below conventional public transport. Our method allows instead to design a novel type of system, which is in-between a shared-taxi and a conventional public transport system. As the former, it can change vehicle routes dynamically, to adapt to the arriving requests. As the latter, it creates a structured network of bus lines, with the possibility of transfers, with the difference that our lines change continuously over time. In a certain sense, we invert the logic of DVRP: while in DVRP vehicle routes change upon request arrival, in our system, instead, bus lines are proactively modified, in order to create a rich graph ahead of time, on which future requests can be efficiently routed. To adapt to the changes in request arrival, our design actions are evaluated against a prediction model of future requests."}, {"title": "3 Model", "content": "Let \\(G_{substr} = (V, E_{substr})\\) a graph, which we call substrate graph, where V is the set of nodes and \\(E_{substr} \\subseteq V \\times V\\) the set of edges. Each node \\(v \\in V\\) represents a bus stop v. If there exists edge \\((v, v') \\in E_{substr}\\), then it is possible to go directly from node v to node v', taking a certain time \\(w_{v,v'} \\geq 0\\).\nA time-expanded edge is a tuple e = (v, v', t) to describe that it is possible to transition from node v to v', leaving at time instant t and arriving at time t' = t + wv,v', which we call departure time and arrival time of e, respectively. Let E be a set of time expanded edges. We define G = (V, Esubstr, E) a Time-Expanded Graph (TEG). TEG G represents the entire set of possible transitions from a node to another, together with the time instants in which they are possible."}, {"title": "3.2 Decision Process", "content": "Let Env be a marked point process [33, Def. 2.1.2], which we call the environment, generates events over time. Env may, for instance, generate perturbations of weights wv,v of the substrate graph. Or Env may generate requests. A context cx(t) evolves over time, which may contain, for instance, the values of the weights of the substrate graph or the set of unserved requests. Finally, let G(t) denote the Time-Expanded Graph (TEG) constructed at time t. The state is a pair st(t) = (cx(t), G(t)). We impose a look-ahead buffer B \u2265 0, i.e., graph G(t) should already contain all the evolution of the TEG until instant t + B. In other words, in any other graph G(t + \u20ac), de > 0, there will not be any edge e = (ve, ve, te) with te < t + B that was not already present in G(t). The look-ahead buffer represents some real system constraint. For instance, in the transport system case that we analyze later (\u00a74), it is important to build the TEG"}, {"title": "3.3 Monte Carlo Online Planning", "content": "Since random events arrive over time, our goal is to build a TEG online in order to adapt to such events, with the aim to maximize collected rewards. Action space A(t, st(t)) consisting of the possible time-expanded edges that can be added might be too big for Q-learning methods. In such cases, Monte Carlo Tree Search (MCTS) is preferable. MCTS converges to the optimal policy (i.e., the sequence of action which collects the most reward) as the agent collects more and more experience [35, Theorem 6].\nMCTS constructs a search tree Tree(s), starting from current state st(t) = (cx(t), G(t)) as root. Tree(s) is a decision tree, each node represents a new state resulting from an action. Tree(s) is created by running n simulations. In each simulation, a sequence of random events is generated randomly, trying to mimic the statistical characteristics of the environment. Moreover, time advancement is also simulated. Fig. 1 shows an example of Tree(s). Each node on the tree is identified by pair sk = (tk, Gk).\nSuppose we are at time t and we need to take an action, guided by MCTS. To do so, we have to construct a tree via simulation. We set the root as (to, Go), where to = t and Go = G(t). We also consider context cxo = cx(t). We then start a simulation. An action is chosen in A(to, Go), which deterministically induces another node (t1, G1), where G1 is the graph obtained after the chosen action and t\u2081 is the next time instant in which it would be possible to take an action. In the meantime, the reward that would be collected if such an action was really put in place is estimated, based on a simulated sequence of events between to and t\u2081, together with the modifications induced on the context, which would thus go from cxo to cx1. We continue the simulation: from node (t1, G1), we choose another action, and we repeat the same reasoning as before, going, for instance, to node (t4, G4) of the tree (Fig. 1). We end the simulation after a certain number of actions (which must be decided as a hyperparameter). We repeat n simulations, similarly.\nAfter those simulations, we can estimate how promising each sequence of actions is. Indeed, we can asso- ciate to node (tk, Gk) of the tree, number n_{sk} of simulations that have passed through node (tk, Gk), and set {r_{(t_k,G_k)}^{(tk,Gk)}, r_{(t_k,G_k)}^{(tk,Gk)}, ..., r_{(t_k,G_k)}^{(tk, G_k)} } of cumulative rewards collected in those simulations, counting rewards only starting from tk, Gk. We now detail better the aforementioned simulations.\nEach simulation includes the following four steps (selection, expansion, rollout, backpropagation). A simulation is a complete path from the root to a leaf in Fig. 1.\nStep one: selection. We start from the root to, Go, and select the child node on the tree with the largest Upper Confidence Bound applied to trees (UCT) [36, Figure 1]. The UCT of node (tk, Gk) is:\n\\(UCT(t_k, G_k) = \\frac{1}{N_{t_k, G_k}} \\sum_{i=1}^{n_{t_k G_k}} r_i^{(t_k,G_k)} + c \\sqrt{\\frac{ln n_{t_0, G_0}}{N_{t_k,G_k}}}\\) (1)\nwhere c is a constant, e.g., c = 2. The selection process ends until that it finds a node which can be expanded. For example, The selection process of Fig. 2 finds the expandable node is node 85.\nStep two: expansion. The expandable node usually has some actions that have never been selected in previous simulations, so the expansion process will randomly select one of the actions and initialize the child node accordingly. In Fig. 2, action a7 has never been selected before, so this time the simulation will first select action a7, and then initialize the child node 87 with a triple (87, ns7 = 0, 0).\nStep three: rollout. After the expansion process, we reach a new leaf node. Starting from this leaf node, we select a sequence of actions uniformly at random, for Nend (hyperparameter) times. At the same time, we record the sum of simulated rewards in rollout process as the cumulative reward starting from the leaf node. For example, in Fig. 2, rollout process starts from leaf node 87, after a series of actions, finally reach to the node send. Accumulated reward r_{17} in the process is calculated.\nStep four: backpropagation. For all nodes passed by the selection process and expansion process, their number of visits will be increased by one, and their new cumulative rewards are recorded. For example, in Fig. 2, node 85 is visited. Therefore, we update node 85:\nNs5 \u2190 Ns5 + 1 (2)\nand\n\\{{r_{s_5}^{(1)},r_{s_5}^{(2)},...,r_{s_5}^{(n_{s_5})}} \\}\\longleftarrow \\{{r_{s_5}^{(1)},r_{s_5}^{(2)},...,r_{s_5}^{(n_{s_5})}} \\} \\cup \\{r_i+r_{a_7}\\} (3)\nwhere reward r_{a_7} is the reward of taking action a7 in this simulation. Other nodes are updated according to the same method."}, {"title": "3.4 Online Design of Dynamic Networks (OD2N) Algorithm", "content": "We propose Algorithm 1 to design the reactive networks. Our basic idea is to use MCTS introduced in Section 3.3 to choose actions, then update the state of the network based on these actions, and record changes during state transitions. It should be noted that Algorithm 1 is an online method, and we can set ending time t\u2081 = \u221e, which means that we will never terminate the algorithm to provide network designing plans in real time."}, {"title": "3.5 Application to Configuration of Complex Systems", "content": "Before delving into our main application (\u00a74), we provide here briefly some high-level thoughts on how our method could be applied for deciding switching among configurations of a complex system [25]. In this case, substrate graph Gsubstr = (V, Esubstr) consists of sets V of potential configurations and Esubstr \u2286 \u03bd\u00d7\u03bd of edges. An edge represents the possibility to switch between two configurations. When we decide on an action, which is to switch configurations, the environment Env gives us a certain cost suffered from the system (opposite of reward r), which depends on its current configuration. Contest cx(t) is the accumulated cost up to t. Having defined states, actions and reward, we can use our method to design the evolution of configuration switches of the complex system, in real time, with the aim to minimize accumulated stochastic cost."}, {"title": "4 Specialization of the method for the Online Bus Network Design", "content": "We now apply our general framework to design a futuristic public transport system, in which a network of bus lines is designed online and dynamically evolves, to adapt to a stochastic sequence of user trip requests. This problem can be also framed as a Dynamic Vehicle Routing Problem (DVRP), where incoming requests are associated to vehicles, whose routes are adjusted on the fly. DVRP is a solution to route a fleet of shared taxis for low density demand, whose vehicle routes are extended independently. We tackle instead a system comparable with conventional public transport, which can achieve similar high capacity via building a structured network of bus lines, where transfers are possible. The difference with conventional public transport is that bus lines evolve over time."}, {"title": "4.1 Time-Expanded Graph of a Bus Network", "content": "In the case considered here, substrate graph Gsubstr = (V, Esubstr) consists of sets V of potential bus stops and Esubstr \u2286 V \u00d7 V of edges (Fig. 3-(a)). Edge (v, v') \u2208 Esubstr indicates that a bus can travel directly from stop v to stop v', taking time wv,v'. We further introduce a set B of N buses.\nA Time-Expanded Graph (TEG) is a tuple G(t) = (V, Esubstr, E(t)) in our case. Set E(t) contains all the possible transitions that users can choose before time t + B. To be more precise, time-expanded edge e = (v,v',t) \u2208 E(t) means the following: if v' \u2260 v, edge e represents that there is a bus departing from bus stop v to bus stop v' at time t (red lines and blues lines in Fig. 3 (b)); if v' = v, edge e represents that a user begin to wait in a bus stop v at time t until a bus arrives (green lines in Fig. 3 (b)). For example, in Fig. 3 (b), when we schedule that bus 1 to arrive at stop vo at 9:22 and bus 2 to arrive at vo at 9:24, we automatically add an edge (green line) from (9:22,\u03c5\u03bf) to (9:24,00), which allows users us to transfer from bus 1 to bus 2, waiting for 2 minutes.\nAn Event ev(t) is a request d = (v, v', t), where v, v' \u2208 V are the origin and destination nodes respectively, t is the departure time of a passenger. Routing request d into TEG G(t) means to calculate a time-expanded path, defined as p = (v, t, e\u2081, . . ., en, v'), where e\u2081, . . ., en is a set of time-expanded edges in G(t). Path p must satisfy the following conditions:\nej = (vj, Vj+1, tj) \u2208 E, (4)\nt + Wv,v\u2081 < t1 (5)\ntj + Wvj,vj+1 \u2264tj+1, Vj = 1,..., n-1 (6)\nV1 = V, Un+1 = \u03c5' (7)\nThe arrival time of p is t' (p) = t + wv,v'. Let P(v, v', t, G) be the set of paths in G starting at node v \u2208 V at time t and arriving at node v' \u2208 V. The shortest path is p* (v, v', t) \u2208 arg min_{p\u2208P(v,v',t,G)} t'p.\nWe associate to request d = (v, v', t) the shortest path p*(d) = p*(v,v',t). TEG G(t) is composed of a set of time-expanded subgraphs, each representing the movement of a bus. Time-expanded subgraph SGi(t) of bus i \u2208 B is composed of a sequence of edges, describing its movement. Designing a bus network amounts to design such subgraphs, by taking actions, consisting in adding time-expanded edges to each subgraph, over time. Such time-expanded subgraphs are however not extended in isolation, as the quality of a sequence of actions is measured against the user requests served collectively by the entire network. Differently from the classic DVRP approach, a vehicle route is not modified in order to accommodate one request in particular. Each modification is aimed at making the entire graph more capable of serving future requests, by creating relevant connections between time-expanded subgraphs that allow transfers."}, {"title": "4.2 Online bus network design process", "content": "We here adapt our generic decision process (\u00a73.2) to the online bus network design task. Let t denote the current real-world time and G(t) the TEG available at time t. All edges departing before t + B must be already present in G(t)."}, {"title": "4.3 Requests Generation Model", "content": "As explained in \u00a73.3, MCTS simulates future possible evolution trajectories of the system, so that one can choose the next action that will likely induce the most desirable evolution. To perform such simulation, we need a model Env' of the environment, which generates events (requests in this case) that are statistically similar to those generated by the real environment Env. We can build from historical data of real-world environment Env. In the transport case we are tackling here, model Env' can be trained on historical dataset D of previously observed trips. Requests are a spatial-temporal marked point process [37]. Therefore, Env' must be able to mimic the spatial patterns (where origins and destinations of trips are distributed) and temporal patterns (rate of requests).\n1. Learning temporal patterns. For each day in the past, we first count the number of requests generated at different timeslots. We train a support-vector machine (SVM) so that it predicts sufficiently well the request counts of all timeslots in the next day.\n2. Learning spatial patterns. We count the origin and destination of all past requests and build an OD matrix \\(M = \\{a_{uv}\\}_{u,v \\in \u03bd}\\) where auv is the fraction of observed trips that went from origin u to destination v. The value of aij can be interpreted as the probability that, given any trip request, its origin will be u and its destination v.\nWhen, within MCTS, we use Env' to generate simulated requests, we do as follows. We first predict the number of future requests via the SVM at each timeslot. For each of them, we randomly select the origin and the destination based on probabilities au,v. Note that, instead of this very simple Env', one may pick any of the advanced demand prediction models available in the literature, which is however outside the scope of this work."}, {"title": "5 Experimental Results", "content": ""}, {"title": "5.1 Considered scenario", "content": "We apply our method to design a bus network online in a scenario in Manhattan (Table 1), where the environment consists of a sequence of trip requests from end-users. To test our method, we replay a randomly selected subset of real taxi requests from a public dataset [38]. Taxi zones are shown in Fig. 4. Manhattan has 67 taxis zones. We find the centroid of each taxi zone, and use these centroids as candidate bus stops. In this case, substrate graph Gsubstr = (V, Esubstr), where V is the set of all centroids. Graph Gsubstr is a fully connected graph. Weight Wu,v of edge (u, v) \u2208 Gsubstr is the time (in minutes) to travel between nodes, i.e., wu,v = d(u, v)/vbus, where du,v is the distance between u, v \u03b5\u03bd and Ubus is the average speed of the bus. We introduce set B of N buses, with random initial positions."}, {"title": "5.2 Performance", "content": "Upon arrival, a request is placed in a list of unserved requests. Figure 5-(a) shows the number of such requests over time. For any fleet size, the number of unserved requests increased significantly in the period starting at 9:00. This is because our system has just started, and at t =9:00 we initialize TEG G(t) randomly (Alg. 1), which means that bus schedule is randomly planned in until time t + B = 9 : 30. After the simulation runs for a period of time, the real-time number of unserved requests no longer increases significantly. Figure 5 (b) shows the percentage of unserved requests out of all requests received so far. Unserved requests go below 8% with a sufficiently large fleet size. It should be noted that, in any dynamic bus system, it is impossible to serve all requests. There can be requests whose origin and destination are very far or in remote places. This kind of trips might be rejected also in current real transport system (and the user would be better-off taking their car). Public transport needs indeed to balance user satisfaction and efficiency, and it cannot thus provide a service tightly tailored to very specific user needs. Differently from [32], which sets a maximum waiting time after which users are rejected, we count all unserved requests in Fig. 5, no matter their waiting time.\nIn Table 2, we instead test two values of maximum waiting time and compare our results with an algorithm [32] largely known as state-of-the-art (SOTA), of which we run an open source implementation [41]. We run both algorithms with a fleet size of 40 and infinite seat capacity. We wish indeed to first evaluate the level of sharing the system can obtain"}, {"title": "6 Conclusion", "content": "In this paper, we introduced the novel problem of designing temporal graphs. Our framework allows building networks able to react to a stochastic environment and adjust their evolution in order to keep satisfying performance. We formalized a general rolling horizon decision process and a Monte Carlo Tree Search-based solution method. We showcased the potential of our approach in a transport context, by designing a futuristic fully dynamic network of bus lines that is able to adapt to a stochastic and unknown request arrival. Our designed network outperforms state-of-the-art Dynamic Vehicle Routing Problem (DVRP) algorithms. This work opens new research avenues on the design of dynamic networks, whose application can go far beyond the transport context showcased here."}]}