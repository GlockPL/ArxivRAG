{"title": "Craftium: An Extensible Framework for Creating Reinforcement Learning Environments", "authors": ["Mikel Malag\u00f3n", "Josu Ceberio", "Jose A. Lozano"], "abstract": "Most Reinforcement Learning (RL) environments are created by adapting existing physics simulators or video games. However, they usually lack the flexibility required for analyzing specific characteristics of RL methods often relevant to research. This paper presents Craftium, a novel framework for exploring and creating rich 3D visual RL environments that builds upon the Minetest game engine and the popular Gymnasium API. Minetest is built to be extended and can be used to easily create voxel-based 3D environments (often similar to Minecraft), while Gymnasium offers a simple and common interface for RL research. Craftium provides a platform that allows practitioners to create fully customized environments to suit their specific research requirements, ranging from simple visual tasks to infinite and procedurally generated worlds. We also provide five ready-to-use environments for benchmarking and as examples of how to develop new ones. The code and documentation are available at https://github.com/mikelma/craftium/.", "sections": [{"title": "1 Introduction", "content": "Reinforcement Learning (RL) research is inherently tied to the environments where agents are trained, tested, and analyzed. Each new insight or advancement in RL is supported by an environment that enables specific behaviors to emerge and be studied. However, many environments extensively employed in the RL literature are physics simulators or video games, not particularly developed for RL research, and have been adapted to suit general RL requirements. These environments include the"}, {"title": "2 Background: Minetest and Minecraft", "content": "Minecraft is a sandbox game where players explore a voxel-based, procedurally generated 3D world, gather resources, craft tools, and construct structures. Although Minecraft supports mods, it is limited by being a closed-source game restricting access to its underlying logic. Additionally, its Java implementation is known to impact the game's performance.\nIn contrast, Minetest is an open-source voxel-based game engine inspired by Minecraft, serving as a platform for creating games rather than being a game itself. Minetest is implemented in the C++ programming language, known for its high efficiency. Furthermore, Minetest exposes"}, {"title": "3 The Craftium framework", "content": "Training an agent in Craftium involves three main components, illustrated in Figure 2. The first is the modified version of the Minetest game engine. The main modifications include the ability to communicate with the Craftium process (via the TCP protocol) and extensions to the Lua API for defining RL tasks. We have kept changes to the original Minetest source minimal and non-intrusive to ensure compatibility with future updates to the game engine. The second component is Craftium, whose Python library facilitates communication with Minetest and integrates with the popular Gymnasium API. The final component is the agent, that employs the mentioned API to interact with the environment.\nThe Craftium framework and the set of predefined environments that it includes are detailed in the following lines."}, {"title": "3.1 Observations, actions, and rewards", "content": "Observations. In Craftium, observations are, by default, single RGB images of the player's main camera whose size can be customized (defined when instantiating the environment). An example of such observation is provided in Figure 3. As Craftium implements the Gymnasium API, the observation space of a task can be further customized employing observation wrappers. For instance, the FrameStack wrapper stacks multiple consecutive images into a single observation, allowing the agent to perceive movement only from observations. Moreover, custom observation wrappers can also be created to further control the space of observations.\nActions. By default, actions are composed of 21 keyboard actions and a tuple that defines the movement of the mouse (or camera). Keyboard-related actions are binary variables with a value of 1 if the key is pressed and 0 otherwise. The movement of the mouse is defined with the tuple $(\\Delta x, \\Delta y) \\in [-1,1]^2$, where $\\Delta x < 0$ moves the mouse to the left in the horizontal axis and $\\Delta x > 0$ to the right, similarly, $\\Delta y < 0$ moves the mouse downwards in the vertical axis and $\\Delta y > 0$ moves it upwards. Thus, if $\\Delta x = y = 0$, the mouse is not moved. Note that in Minetest games, mouse movement is mainly used to move the player's camera.\nThe default action space is designed to provide almost complete control of the game to the player, providing great flexibility to define complex tasks. Craftium also provides two action wrappers that can be used to customize the action space for problems that do not require the whole default space, simplifying the task for the learning agent. These wrappers allow defining alternative action spaces, where actions are indices or binary vectors, that only consider a subset of the 21 key actions and discretized actions for the mouse movement.\nRewards. Craftium modifies Minetest to include Lua functions to get and set the reward value. The latter enables implementing reward functions inside Minetest mods, opening the door to the vast possibilities that Minetest's Lua API offers. An example of such a mod is discussed in Section 3.2."}, {"title": "3.2 Creating custom environments", "content": "Craftium environments have two main components: the world and the mod. The first step when creating a custom Craftium environment is to generate the world the agent will interact with. Although Minetest offers unlimited possibilities, creating a world can be as simple as a few clicks when using an already predefined map generator or mod. If a finer control over this step is needed, Minetest offers tools for this purpose, or custom Lua mods can be used. Once the world is created, a Lua mod is used to control the mechanics of the environment and define the reward.\nA mod is a directory with (at least) two files: a configuration file named mod.conf, and a Lua script named init. lua. The configuration file is used for the mod's metadata, including the name, description, dependencies to other mods, etc. An example of a typical mod configuration file is provided in Figure 4. More interestingly, the init. lua file defines the task (e.g., the reward function, termination conditions, player's initial position). This file is a Lua script that can use all the default functionalities that the Lua programming language provides together with the ones provided by the Minetest's API. An example script for an environment where the objective is to chop trees is illustrated in Figure 5. The first line registers a callback function called every time the player (i.e., the agent) digs a node. This function, checks if the dug node is part of a tree (line 2), and if that is the case, sets the reward to 1 for that timestep (line 3). Note that set_reward_once only sets the reward (function's first parameter) from one timestep, after resetting it to 0 (function's second parameter)."}, {"title": "3.3 Interface", "content": "Craftium implements the popular Gymnasium API, a common and easy-to-use interface for RL. The latter makes Craftium environments compatible with a great variety of existing tools and projects to train, test, develop, and analyze many RL algorithms. Some of these projects include: stable-baselines3 , Ray RLlib , CleanRL , and skrl . Figure 6 shows an example that uses the mentioned interface. First, line 1 loads a predefined Craftium environment (these are discussed later in Section 3.4), then line 6 initiates an episode, obtaining the current observation and an information dictionary. Note that the dictionaries can be used by Gymnasium to provide additional information to the reward and termination and truncation flags, elapsed time, or episodic return for example. Lines 7-12 implement the agent-environment interaction loop, where a random action is selected (line 8) and executed in the environment (line 9), returning the next observation, the reward, and two boolean flags indicating whether the episode is terminated or truncated, and the new information dictionary, respectively. In case the episode is terminated or truncated (line 11), a new episode is initiated by calling env. reset (line 12). Finally, once the main loop ends, the environment is cleanly closed in the last line."}, {"title": "3.4 Provided environments", "content": "Although Craftium is primarily designed for creating new environments, it also offers a set of baseline environments intended to serve as benchmarks and examples for implementing environments of varying complexity.\nBy default, all the environments in this section share the same observation space of RGB images 64 x 64 pixels. Nonetheless, this parameter can be modified when loading the environments. Regarding the action space, we use action wrappers to simplify the default action space to only con-sider the relevant actions for each task. Specifically, all environments employ discrete actions $\\alpha\\in \\{0, 1, 2, ...\\}$, where $\\alpha$ O is the NOP action (no-op action) and rest of the actions are different and are set according to the requirements of the task. Below, we list and describe all the predefined environments provided by Craftium, which are illustrated in Figure 7."}, {"title": "4 Related work", "content": "The RL literature has proposed a vast number of environments and tasks to train and benchmark algorithms, most of which are based on video games or physic simulators . Usually, environments offer static scenarios with a limited number of adjustable parameters to adjust the task to the particular needs of the researcher . However, these often tend to be very limited and fail to reach the flexibility required in research.\nTo overcome this issue, ProcGen introduced procedurally generated 2D environments. Nonetheless, the diversity of the environments is limited, and modifications to existing environments are accomplished by changing predefined parameters. Equivalently, the NetHack Learning Environment also leverages procedural generation in 2D environments, although environment customization is similarly limited.\nTo further improve the customization of existing environments and the flexibility when creating new ones, some works introduce Domain Specific Languages (DSLs) for this purpose. For example, VizDoom employs the ZScript, the DSL of ZDoom (the game on which VizDoom is based), and MiniHack uses the des-file format inherited from the original NetHack game. However, in many cases, DSLs are very specific to the purpose they were created for and fail to provide the flexi-bility and expected features of proper programming languages. For instance, the des-file format is specifically designed for composing NetHack levels, but it is not a programming language per se. Moreover, DSLs tend to deviate from the syntax and semantics of mainstream programming languages, hindering their usage and adoption.\nOther works offer similar customization capabilities by allowing modifying and creating new envi-ronments from the programming language they are implemented in, usually Python, avoiding the mentioned issues of DSLs. For instance, Griddly and MiniGrid offer a Python API for 2D grid-like environment creation. While grid environments are fast to simulate, they often lack the complexity and richness of others (e.g., procedural generation, weather systems, animals, monsters, multiple biomes). In principle, more complex tasks could be implemented in these frameworks. However, this would require significant effort from researchers. Regarding 3D environments, MiniWorld"}, {"title": "5 Conclusion", "content": "Creating new environments or customizing existing ones is fundamental for the progress of the RL field, especially in research, where specific characteristics or behaviors of the methods are to be analyzed. However, many of the existing environments and benchmarks in the RL literature offer very limited or no customization capabilities at all . In the light of this issue, some works have created libraries and platforms for developing RL environments , but depend on limited DSLs or only offer grid-like 2D worlds.\nIn this work, we present Craftium, a rich and easy-to-use environment creation framework based on the open-source Minetest voxel game engine. Minetest is implemented in the C++ programming language, leveraging the efficiency of low-level programming languages. Additionally, Minetest supports extensive customization through its Lua API, allowing users to integrate their modifications within the game engine with ease. These features make Minetest the ideal platform for RL research. Specifically, Craftium makes minimal modifications to Minetest to communicate with a tailored Python library. Furthermore, Craftium implements the popular Gymnasium API, making it compatible with a great number of existing tools and libraries. Craftium is completely open source and provides thorough documentation of its Python library, while including five predefined tasks as examples and for benchmarking purposes. The project is available at https://github.com/mikelma/craftium/.\nAlthough Craftium is an environment creation framework, we believe that future work on creating additional environments is relevant, ultimately creating a benchmark for comparing novel and baseline RL methods. As the Gymnasium API in the case of the single agent setting, we think that multi-agent interactions could be integrated into the proposed framework in the future, implementing the Petting Zoo API in this case."}]}