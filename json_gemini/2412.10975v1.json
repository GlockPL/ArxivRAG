{"title": "Recursive Aggregates as Intensional Functions in Answer Set Programming: Semantics and Strong Equivalence", "authors": ["Jorge Fandinno", "Zachary Hansen"], "abstract": "This paper shows that the semantics of programs with aggregates implemented by the solvers clingo and dlv can be characterized as extended First-Order formulas with intensional functions in the logic of Here-and-There. Furthermore, this characterization can be used to study the strong equivalence of programs with aggregates under either semantics. We also present a transformation that reduces the task of checking strong equivalence to reasoning in classical First-Order logic, which serves as a foundation for automating this procedure.", "sections": [{"title": "Introduction", "content": "Answer set programming (ASP) is a declarative programming paradigm well-suited for solving knowledge-intensive search and optimization problems (Lifschitz 2019). Its success relies on the combination of a rich knowledge representation language with effective solvers. Some of its most useful constructs are aggregates, that is, functions that apply to sets. The semantics of aggregates have been extensively studied in the literature (Simons, Niemel\u00e4, and Soininen 2002; Dovier, Pontelli, and Rossi 2003; Pelov, Denecker, and Bruynooghe 2007; Son and Pontelli 2007; Ferraris 2011; Faber, Pfeifer, and Leone 2011; Gelfond and Zhang 2014, 2019; Cabalar et al. 2019). In most cases, they rely on the idea of grounding\u2014a process that replaces all variables by variable-free terms. This makes reasoning about First-Order (FO) programs with aggregates cumbersome and it does not allow the use of classical FO theorem provers for verifying properties about this class of programs.\nThough several approaches describe the semantics of aggregates bypassing the need for grounding, most of these approaches only allow a restricted class of aggregates (Lee, Lifschitz, and Palla 2008; Lifschitz 2022) or use some extension of the logical language (Bartholomew, Lee, and Meng 2011; Lee and Meng 2012; Asuncion et al. 2015; Cabalar et al. 2018). Recently, Fandinno, Hansen, and Lierler (2022, 2024) showed how to translate logic programs with aggregates into FO sentences, which, after the application of the SM operator (Ferraris, Lee, and Lifschitz 2011), captures the ASP-Core-2 semantics. Though most practical problems can be represented within the restrictions of the ASP-Core-2 semantics, some notable exceptions are more naturally represented using recursive aggregates, which are not allowed by ASP-Core-2. One of these examples is the Company Control problem, which consists of finding companies that control other companies by (directly or indirectly) owning a majority of their shares. This problem has been encoded in the literature using the following logic program (Pelov, Denecker, and Bruynooghe 2007; Faber, Pfeifer, and Leone 2011; Mumick, Pirahesh, and Ramakrishnan 1990; Kemp and Stuckey 1991; Ross and Sagiv 1997):\nctrStk(C1,C1,C2,P) :- ownsStk(C1,C2,P).\nctrStk(C1,C2,C3,P) :- controls(C1,C2),\nownsStk(C2,C3,P).\ncontrols(C1,C3):-company(C1), company(C3),\n#sum{P,C2:ctrStk(C1,C2,C3,P)}>50.\nwhere atom ownsStk(C1,C2,P) means that company C1 directly owns P% of the shares of company C2; ctrStk(C1,C2,C3,P) means that company C1 controls P% of the shares of company C3 through company C2 that it controls; and controls(C1,C3) means that company C1 controls company C3. Another area where allowing recursive aggregates is important is in the study of strong equivalence (Lifschitz, Pearce, and Valverde 2001, 2007). The strong equivalence problem consists of determining whether two programs have the same behavior in any context. Even if the programs we are analyzing do not contain recursion, adding some context may introduce it.\nIn this paper, we show that the translation introduced by Fandinno, Hansen, and Lierler can also be used for programs with recursive aggregates if we interpret functions in an intensional way (Lin and Wang 2008; Cabalar 2011; Lifschitz 2012; Balduccini 2013; Bartholomew and Lee 2019). We focus on the Abstract Gringo (Gebser et al. 2015) generalization of the semantics by Ferraris (2011), which is used in the answer set solver clingo, and the semantics by Faber, Pfeifer, and Leone (2011), which are used in the answer set solver dlv. We prove that the translation introduced by Fandinno, Hansen, and Lierler coincides with the Abstract Gringo semantics when we interpret the function symbols representing sets according to the semantics for intensional functions by Bartholomew and Lee. For dlv, we introduce a similar translation, which uses a second form of"}, {"title": "Preliminaries", "content": "We start by reviewing the syntax of programs with aggregates and presenting an extension of the logic of Quantified Here-and-There (Pearce and Valverde 2008) with intensional functions that is suited for programs with aggregates.\nWe follow here the presentation by Fandinno, Hansen, and Lierler (2022). We assume a (program) signature with three countably infinite sets of symbols: numerals, symbolic constants and program variables. We also assume a 1-to-1 correspondence between numerals and integers; the numeral corresponding to an integer n is denoted by n. Program terms are either numerals, symbolic constants, variables or one of the special symbols inf and sup. A program term (or any other expression) is ground if it contains no variables. We assume that a total order on ground terms is chosen such that\n\u2022 inf is its least element and sup is its greatest element,\n\u2022 for any integers m and n, m < \u00f1 iff m < n, and\n\u2022 for any integer n and any symbolic constant c, n < c.\nAn atom is an expression of the form p(t), where p is a symbolic constant and t is a list of program terms. A comparison is an expression of the form $t \\prec t'$, where t and t' are program terms and  $\\prec$ is one of the comparison symbols:\n= \u2260 < > \u2264 \u2265\nAn atomic formula is either an atom or a comparison. A basic literal is an atomic formula possibly preceded by one or two occurrences of not. An aggregate element has the form\n$t_1,..., t_k : l_1,..., l_m$\nwhere each $t_i$ (1 \u2264 i \u2264 k) is a program term and each $l_i$ (1 \u2264 i \u2264 m) is a basic literal. An aggregate atom is of form #op{E} <u where op is an operation name, E is an aggregate element, \u4eba is one of the comparison symbols in (1), and u is a program term, called guard. We consider operation names count and sum. For example, the expression\n#sum{P,C2:ctrStk(C1,C2,C3,P)}>50\nin the body of rule (3) is an aggregate atom. An aggregate literal is an aggregate atom possibly preceded by one or two occurrences of not. A literal is either a basic literal or an aggregate literal. A rule is an expression of the form\nHead :- B1,..., Bn,\nwhere Head is an atom or symbol \u22a5, and each Bi is a literal. We call the symbol :- the rule operator. We call the left-hand side of the rule operator the head, the right-hand side of the rule operator the body. When the head of the rule is an atom we call the rule normal, and when it is the symbol \u22a5 we call it a constraint. When the body of a normal rule is empty, we call the rule a fact. A program is a set of rules.\nEach operation name op is associated with a function op that maps every set of tuples of ground terms to a ground"}, {"title": "Stable Model Semantics with Intensional Functions", "content": "term. If the first member of a tuple t is a numeral in then we say that integer n is the weight of t, otherwise the weight of t is 0. For any set A of tuples of ground terms,\n\u2022 count(A) is the numeral corresponding to the cardinality of A, if A is finite; and sup otherwise.\n\u2022 sum(A) is the numeral corresponding to the sum of the weights of all tuples in A, if A contains finitely many tuples with non-zero weights; and 0 otherwise. If A is empty, then sum(A) = 0.\nThough we illustrate the semantics of aggregates using the operation names count and sum, the semantics can be extended to other operation names by adding the appropriate functions op (Fandinno, Hansen, and Lierler 2024).\nA many-sorted signature consists of symbols of three kinds-sorts, function constants, and predicate constants. A reflexive and transitive subsort relation is defined on the set of sorts. A tuple $s_1,..., s_n$ (n > 0) of argument sorts is assigned to every function constant and to every predicate constant; in addition, a value sort is assigned to every function constant. Function constants with n = 0 are called object constants. For every sort, an infinite sequence of object variables of that sort is chosen. Terms and atomic formulas over a (many-sorted) signature \u03c3 are defined as usual with the consideration that the sort of a term must be a subsort of the sort of the function or predicate constant of which it is an argument. Extended First-Order formulas over \u03c3 are formed from atomic formulas and the 0-place connective \u22a5 (falsity) using the unary connective \u00ac, the binary connectives \u2227, \u2228, \u2192 and the quantifiers \u2200, \u2203. We define the usual abbreviations: F \u2261 F \u2192 \u22a5 and F \u2194 G stands for (F \u2192 G) \u2227 (G \u2192 F). We have two negation symbols (\u00ac and \u2514) and both correspond to classical negation in the context of classical FO logic. The symbol \u00ac represents standard negation in the logic of Here-and-There and corresponds to default negation in logic programs under the clingo semantics, while symbol \u2514 is a new connective and it represents default negation under the dlv semantics. Interpretations, sentences, theories, satisfaction and models are defined as usual with the additional condition that I |= \u2514F iff I \u00a5 F. A standard FO formula (resp. sentence, theory) is a formula (resp. sentence, theory) without the new operator.\nLet I and H be two interpretations of a signature \u03c3 and P and F respectively be sets of predicate and function constants of \u03c3. We write H <PF I if\n\u2022 H and I have the same universe for each sort;\n\u2022 pH \u2286 pI for every predicate constant p in P and pH = pI for every predicate constant p not in P; and\n\u2022 fH = fI for every function constant f not in F.\nIf I is an interpretation of a signature \u03c3 then by \u03c3I we denote the signature obtained from \u03c3 by adding, for every element d of a domain Is, its name d\u2217 as an object constant of sort s. An ht-interpretation of \u03c3 is a pair \u3008H, I\u3009, where H and I are interpretations of \u03c3 such that H <PF I. (In terms of many-sorted Kripke models, I is the there-world, and H"}, {"title": "Logic Programs With Aggregates as Extended Many-Sorted First-Order Sentences", "content": "is the here-world). The satisfaction relation $ \\models_{ht}$ between an HT-interpretation \u3008H, I\u3009 of \u03c3 and a sentence F over \u03c3I is defined recursively as follows:\n\u2022 $\\langle H, I\\rangle \\models_{ht} p(t)$, if I |= p(t) and H |= p(t);\n\u2022 $\\langle H, I\\rangle \\models_{ht} t_1 = t_2$ if $t_1^I = t_2^I$ and $t_1^H = t_2^H$;\n\u2022 $\\langle H, I\\rangle \\models_{ht} \\neg F$ if both I |= F and H $ \\neq$ F;\n\u2022 $\\langle H, I\\rangle \\models_{ht} F \\wedge G$ if $\\langle H, I\\rangle \\models_{ht} F$ and $\\langle H, I\\rangle \\models_{ht} G$;\n\u2022 $\\langle H, I\\rangle \\models_{ht} F \\vee G$ if $\\langle H, I\\rangle \\models_{ht} F$ or $\\langle H, I\\rangle \\models_{ht} G$;\n\u2022 $\\langle H, I\\rangle \\models_{ht} F \\rightarrow G$ if $I \\models F \\rightarrow G$, and\nfor $\\langle H, I\\rangle \\models_{ht} F$ for $\\langle H, I\\rangle \\models_{ht} G$;\n\u2022 $\\langle H, I\\rangle \\models_{ht} \\forall X F(X)$ if $\\langle H, I\\rangle \\models_{ht} F(d^*)$ for each $d \\in |I|^s$, where s is the sort of X;\n\u2022 $\\langle H, I\\rangle \\models_{ht} \\exists X F(X)$ if $\\langle H, I\\rangle \\models_{ht} F(d^*)$ for some $d \\in |I|^s$, where s is the sort of X.\nIf $\\langle H, I\\rangle \\models_{ht} F$ holds, we say that $\\langle H, I\\rangle$ ht-satisfies F and that $\\langle H, I\\rangle$ is an ht-model of F. If it is clear from the context that theht entailment relation is referred to, we will simply say that $\\langle H, I\\rangle$ satisfies F. We say that $\\langle H, I\\rangle$ satisfies a set of sentences \u0393 if it satisfies every sentence F in \u0413.\nWe write H <PF I if H <PF I and H $ \\neq$ I. A model I of a set I of sentences is called stable if there is no H <PF I such that $\\langle H, I\\rangle$ satisfies \u0393. For finite standard theories, this definition of stable models coincides with the definition of one by Bartholomew and Lee (2019) when sets P and F respectively contain the intensional predicate and function constants. For (possibly infinite) standard theories with F = \u00d8, each stable model I corresponds to the equilibrium model \u3008I, I\u3009 by Pearce and Valverde (2008).\nWe present here translations $\\tau^{cli}_{}$ and $\\tau^{dlv}_{}$ that turn a program into extended FO sentences with equality over a signature \u03c3(P, S) of three sorts; P and S are sets of predicate and set symbols, respectively. Superscripts cli and dlv refer to the semantics of clingo and dlv, respectively.\nA set symbol is a pair E/X, where E is an aggregate element and X is a list of variables occurring in E. For brevity's sake, each set symbol E/X is assigned a short name $\\mathcal{S}_{E/X}$. The target signature is of three sorts. The first sort is called the general sort (denoted $s_{gen}$); all program terms are of this sort. The second sort is called the tuple sort (denoted $s_{tuple}$); it contains entities that are tuples of objects of the general sort. The third sort is called the set sort (denoted $s_{set}$); it contains entities that are sets of elements of the second sort, that is, sets of tuples of objects of the general sort. Signature \u03c3(P, S) contains:\n1. all ground terms as object constants of the general sort;\n2. all predicate symbols in P with all arguments of the general sort;\n3. comparison symbols other than equality as binary predicate symbols whose arguments are of the general sort;\n4. predicate constant $ \\in/2$ with the first argument of the sort tuple and the second argument of the sort set;"}, {"title": "Translations", "content": "5. function constant tuple/k with arguments of the general sort and value of the tuple sort for each set symbol E/X in S with E of the form of (5);\n6. unary function constants count and sum whose argument is of the set sort and whose value is of the general sort;\n7. for each set symbol E/X in S where n is the number of variables in X, function constants $s^{cli}_{E/\\vec{X}}$ and $s^{dlv}_{E/\\vec{X}}$ with n arguments of the general sort and whose value is of the set sort.\nWe assume that P is the set of intensional predicates and that the set of intensional functions is the set of all function symbols corresponding to set symbols in S. We use infix notation in constructing atoms that utilize predicate symbols of comparisons (>, \u2265, <, \u2264, \u2260) and the set membership predicate \u2208. Function constants $s^{cli}_{E/\\vec{X}}$ and $s^{dlv}_{E/\\vec{X}}$ are used to represent sets occurring in aggregates for the clingo and dlv semantics, respectively. Each of these function constants maps an n-tuple of ground terms $\\vec{x}$ to the set of tuples represented\u00b9 by $E\\vec{x}$. These claims are formalized below.\nAbout a predicate symbol p/n, we say that it occurs in a program \u03a0 if there is an atom of the form $p(t_1, . . ., t_n)$ in \u03a0. For set symbols, we need to introduce first the concepts of global variables and set symbols. A variable is said to be global in a rule if\n1. it occurs in any non-aggregate literal, or\n2. it occurs in a guard of any aggregate literal.\nWe say that set symbol E/X occurs in rule R if this rule contains an aggregate literal with the aggregate element E and X is the lexicographically ordered list of all variables in E that are global in R. We say that E/X occurs in a program \u03a0 if E/X occurs in some rule of the program. For instance, in rule (3) the global variables are C1 and C3. Set symbol $E_{ctr}/X_{ctr}$ occurs in this rule where $E_{ctr}$ stands for the aggregate element $P, C2:ctrStk(C1,C2,C3,P)$ and $X_{ctr}$ is the list of variables C1, C3. We denote by $s^{cli}/2$ and $s^{dlv}/2$ the function symbols associated with this set symbol for the clingo and dlv semantics, respectively.\nWhen discussing a program II, we assume a signature \u03c3(P, S) such that P and S are the sets that contain all predicate symbols and all set symbols occurring in II, respectively. Furthermore, when it is clear from the context, we write just o instead of \u03c3(P, S).\nWe now describe translations that convert a program into a set of extended FO sentences. We use $\u03c4^{cli}$ and $\u03c4^{dlv}$ to denote the rules that are common to both translations when x is replaced by either cli or dlv. Given a list Z of global variables in some rule R, we define $\u03c4^{cli}_Z$ and $\u03c4^{dlv}_Z$ for all elements of R as follows."}, {"title": "Standard interpretations", "content": "1. for every atomic formula A occurring outside of an aggregate literal, its translation $\u03c4^{cli}_Z A$ is A itself; $\u03c4^{cli}_Z \\bot$ is \u22a5;\n2. for an aggregate atom A of form #count{E} \u4eba u or #sum{E} <u, its translation $\u03c4^{cli}_Z A$ is the atom\ncount($s^{cli}_{E/X}$(X)) < u or sum($s^{cli}_{E/X}$(X)) \u4ebau\nrespectively, where X is the lexicographically ordered list of the variables in Z occurring in E;\n3. for every (basic or aggregate) literal of the form not A its translation $\u03c4^{cli}_Z(not A)$ is $\\neg \u03c4^{cli}_Z A$ and its translation $\u03c4^{dlv}_Z(not A)$ is $\\neg \u03c4^{dlv}_Z A$; for every literal of the form not not A its translation $\u03c4^{cli}_Z(not not A)$ is $\\neg\\neg \u03c4^{cli}_Z A$ and its translation $\u03c4^{dlv}_Z(not not A)$ is $ \\lfloor \\lfloor  \u03c4^{dlv}_Z A$.\nWe now define the translation \u03c4 as follows:\n4. for every rule R of form (4), its translation $\u03c4_{R}$ is the universal closure of\n$\u03c4_Z B_1 \\wedge ... \\wedge \u03c4_Z B_n \\rightarrow \u03c4_Z Head$\nwhere Z is the list of the global variables of R.\n5. for every program II, its translation $\u03c4_{II}$ is the theory containing $\u03c4_{R}$ for each rule R in \u03a0.\n$\u03c4^{cli}$ and $\u03c4^{dlv}$ only differ in the translation of negation and the use of different function constants for set symbols. For instance, rule (3) is translated into the universal closure of\ncompany (C1) \u2227 company (C3)\n$ \\wedge sum(s^{x}_{ctr}(C1, C3)) > 50 \\rightarrow controls(C1, C3)\nwhere variables C1 and C3 are of the general sort, and x is either cli or dlv depending on the semantics considered.\nA standard interpretation I is an interpretation of \u03c3(P, S) that satisfies the following conditions:\n1. universe $|I|_{s_{gen}}$ is the set containing all ground terms of the general sort;\n2. universe $|I|_{s_{tuple}}$ is the set of all tuples of form (d1, . . ., dk) with $d_i \u2208 |I|_{s_{gen}}$ for each set symbol E/X in S with E of the form of (5);\n3. every element of $|I|_{s_{set}}$ is a subset of $|I|_{s_{tuple}}$;\n4. I interprets each ground program term as itself;\n5. I interprets predicate symbols >, \u2265, <, \u2264 according to the total order chosen earlier;\n6. I interprets each tuple term of form tuple(t1, . . ., tk) as the tuple (t1, . . ., tk);\n7. \u2208I is the set of pairs (t, s) s.t. tuple t belongs to set s;\n8. for term $t_{set}$ of sort $s_{set}$, count($t_{set}$)$^I$ is count($t_{set}$);\n9. for term $t_{set}$ of sort $s_{set}$, sum($t_{set}$)$^I$ is sum($t_{set}$);\nAn agg-interpretation is a standard interpretation I satisfying, for every set symbol E/X in S with E of the form of (5) and for all x \u2208 {cli, dlv}, that $s^{x}_{E/\\vec{X}}$(x)I is the set of all tuples of the form $((t_1)_{XY}, . . ., (t_k)_{XY})$ such that I satisfies $\u03c4_X (l_1)_{XY} \u2227\u00b7\u00b7\u00b7\u2227 \u03c4_X (l_m)_{XY}$.\nFor instance, the program representing the Company Control problem has a unique set symbol that is associated with the function symbols $s^{x}_{ctr}/2$ (x \u2208 {cli, dlv})."}, {"title": "Correspondence with clingo and dlv", "content": "If I is an agg-interpretation such that ctrStkI is the set containing (C1, C2,C3,10) and (C1, C4, C3, 20), it follows that $s^{x}_{ctr}(C1, C3)$ (with x \u2208 {cli, dlv}) is the set containing tuples (10, C2) and (20, C4).\nAn ht-interpretation \u3008H, I\u3009 is said to be standard if both H and I are standard. An agg-ht-interpretation is a standard ht-interpretation \u3008H, I\u3009 satisfying that I is an agg-interpretation and the following conditions for every set symbol E/X in S with E of the form of (5) :\n\u2022 $s^{cli}_{E/\\vec{X}}(x)$ is the set of all tuples of form $((t_1)_{XY}, . . ., (t_k)_{XY})$ such that $\\langle H, I \\rangle$ satisfies $\u03c4^{cli}_X (l_1)_{XY}... \u03c4^{cli}_X (l_m)_{XY}$; and\n\u2022 $s^{dlv}_{E/\\vec{X}}(x)$ is the set of all tuples of form $((t_1)_{XY}, . . ., (t_k)_{XY})$ such that H satisfies $\u03c4^{dlv}_X (l_1)_{XY}... \u03c4^{dlv}_X (l_m)_{XY}$.\nwhere Y is the lexicographically ordered list of the variables occurring in E that are not in X. Let us consider now an agg-ht-interpretation \u3008H, I\u3009 where I is as described above and $ctrStk^I$ is the set containing (C1, C2, C3, 10). Then, $s^{x}_{ctr}(C1, C3)^H$ is the set containing tuples (10, C2). In this example, there is no difference between the semantics of clingo and dlv.\nAs an example of where these semantics differ, consider an agg-ht-interpretation \u3008H, I\u3009 with $p^H = r^H = (\\emptyset)$ and $p^I = q^H = {1}$, and $q^I = r^I = {\\bot}$, and rule\np(1):-#sum{X:q(X), not r(X)}<1.\nThis rule is translated into the sentences\nsum($s^{cli}(H)$) <1\u2192p(1)\nsum($s^{dlv}(H)$) <1\u2192p(1)\nfor the clingo and dlv semantics, respectively. It is clear that I satisfies both rules because 1 belongs to $p^I$. However, when considering the agg-ht-interpretation $\\langle H, I \\rangle$, only the second rule is satisfied. On the one hand, $(s^{cli}/x)^I$ (with x \u2208 {cli, dlv}) is the empty set. Furthermore, $(s^{cli}/x)^H$ is also the empty set because $\\langle H, I \\rangle | \u00acr(1)$, and the antecedent of (9) is satisfied. Then, the rule is not satisfied because the consequent is not satisfied due to 1 not belonging to pH. On the other hand, $(s^{dlv}/x)^I$ is the set containing 1 because $H \\models q(1) \u2227 \\lfloor r(1)$. Hence, \u3008H, I\u3009 does not satisfy the antecedent of (10) and the rule is satisfied.\nWe now define stable models for programs with aggregates. A model of a formula or theory that is also an agg-interpretation is called an agg-model and an agg-ht-interpretation that satisfies a formula or theory is called an agg-ht-model.\nDefinition 1. An agg-model I of I is an agg-stable model of F if there is no agg-ht-model \u3008H, I\u3009 with H <PF I.\nWe establish now the correspondence between the semantics of programs with aggregates introduced in the previous section and the semantics of the solver clingo, named Abstract Gringo (Gebser et al. 2015), and the solver dlv, which"}, {"title": "Strong Equivalence", "content": "is based on the FLP-reduct (Faber, Pfeifer, and Leone 2011). These semantics are stated in terms of infinitary formulas following the work by Harrison and Lifschitz (2019).\nFor every nonnegative integer r, infinitary ground formulas of rank r are defined recursively:\n\u2022 every ground atom in o is a formula of rank 0,\n\u2022 if \u0393 is a set of formulas, and r is the smallest nonnegative integer that is greater than the ranks of all elements of \u0393, then \u0393\u2227 and \u0393\u2228 are formulas of rank r,\n\u2022 if F and G are formulas, and r is the smallest nonnegative integer that is greater than the ranks of F and G, then FG is a formula of rank r,\n\u2022 if F is a formula, and r is the smallest nonnegative integer that is greater than the rank F, then \u2013F is a formula of rank r.\nWe write {F, G}\u2227 as F\u2227G, {F,G}\u2228 as FVG, and \u00d8 as \u22a5. We extend the satisfaction relation for ht-interpretations to infinitary formulas by adding the following two conditions to the definition for FO formulas:\n\u2022 $\\langle H, I\\rangle \\models_{ht} \\Gamma \\wedge$ if for every formula F in \u0393, $\\langle H, I\\rangle \\models_{ht} F$,\n\u2022 $\\langle H, I\\rangle \\models_{ht} \\Gamma \\vee$ if there is a formula F in \u0393 such that $\\langle H, I\\rangle \\models_{ht} F$,\nWe write I |= F if $\\langle I, I\\rangle \\models_{ht} F$.\nTruszczy\u0144ski (2012) defines the satisfaction of infinitary formulas with respect to sets of ground atoms instead of FO interpretations. Such a satisfaction relation for infinitary formulas can be defined when we have no intensional functions. An infinitary ground formula is propositional if it does not contain intensional functions. For a signature \u03c3, by op we denote the set of all ground atoms over \u03c3 that do not contain intensional functions. Subsets of a propositional signature op are called propositional interpretations. The satisfaction relation between a propositional interpretation A and an infinitary propositional formula is defined recursively:\n\u2022 for every ground atom A from \u03c3, A |= A if A belongs to A,\n\u2022 A |= \u0393\u2227 if for every formula F in \u0393, A |= F,\n\u2022 A |= \u0393\u2228 if there is a formula F in \u0393 such that A |= F,\n\u2022 A |= F \u2192 G if A \u00a5 F or A |= G,\n\u2022 A |= \u00acF if A \u00a5 F.\nIn the following, if I is an interpretation, then II denotes the set of atomic formulas of op satisfied by I. With this notation, the following result is easily proved by induction.\nProposition 1. Let F be an infinitary propositional formula. Then, I |= F iff II |= F.\nallows us to replace quantifiers with infinitary conjunctions and disjunctions. Formally, the grounding of a First-Order sentence F with respect to an interpretation I and sets P and F of intensional predicate and function symbols is defined as follows:\n\u2022 $gr_{I}^{P,F}(\\bot)$ is \u22a5;\u2022"}, {"title": "Strong Equivalence using Classical Logic", "content": "\u2022 $gr_{I}^{P,F}(p(t))$ is p(t) if p(t) contains intensional symbols;\n\u2022 $gr_{I}^{P,F}(p(t))$ is T if p(t) does not contain intensional symbols and I |= p(t); and $gr_{I}^{P,F}(p(t))$ is \u22a5 otherwise;\n\u2022 $gr_{I}^{P,F}(t_1 = t_2)$ is (t1 = t2) if t1 or t2 contain intensional symbols;\n\u2022 $gr_{I}^{P,F}(t_1 \\neq t_2)$ is T if t1 and t2 do not contain intensional symbols and t1 = t2; and \u22a5 otherwise;\n\u2022 $gr_{I}^{P,F}(\\neg F)$ is $\\neg gr_{I}^{P,F}(F)$;\n\u2022 $gr_{I}^{P,F}(F \\otimes G)$ is $gr_{I}^{P,F}(F) \\otimes gr_{I}^{P,F}(G)$ if $ \\otimes$ is \u2227, \u2228, or \u2192;\n\u2022 $gr_{I}^{P,F}(\\exists X F(X))$ is {$gr_{I}^{P,F}(F(u)) | u \\in |I|^*\\} \\vee$ if X is a variable of sort s;\n\u2022 $gr_{I}^{P,F}(\\forall X F(X))$ is {$gr_{I}^{P,F}(F(u)) | u \\in |I|^*\\} \\wedge$ if X is a variable of sort s.\nFor a first-order theory \u0393, we define $gr_{I}^{P,F}(\u0393) = {gr_{I}^{P,F}(F) | F \u2208 \u0393} \\wedge$. For any first-order theory \u0393, $gr_{I}^{P,F}(\u0393)$ is an infinitary formula, which may contain intensional functions or the \u2514 connective. We write $gr_I(\\cdot)$ instead of $gr_{I}^{P,F}(\\cdot)$ when it is clear from the context.\nProposition 2. $\\langle H, I\\rangle \\models_{ht} F$ iff $\\langle H, I\\rangle \\models_{ht} gr_I(F)$.\nWe say that an infinitary propositional formula is standard if it does not contain the connective. The definitions of the semantics of clingo and dlv only use standard infinitary formulas and rely on the notion of minimal models. A propositional interpretation A satisfies a set \u0393 of formulas, in symbols A |= \u0393, if it satisfies every formula in \u0393. We say that a set A of atoms is a \u2286-minimal model of a set of infinitary formulas \u0393, if A |= \u0393 and there is no B satisfying B |= \u0393 and B \u2282 A.\nThe $F^{T}$-reduct $F^A$ of a standard infinitary formula F with respect to a propositional interpretation A is defined recursively. If A \u00a5 F then FA is \u22a5; otherwise,\n\u2022 for every ground atom A, $A^{A}$ is A\n\u2022 $(\u0393 \\wedge)^{A} = {G^{A} | G \u2208 \u0393}^\\wedge$,\n\u2022 $(\u0393 \\vee)^{A} = {G^{A} | G \u2208 \u0393}^\\vee$,\n\u2022 $(G \u2192 H)^{A}$ is $G^{A} \u2192 H^{A}$,\nWe say that a propositional interpretation A is an $F^{T}$-stable model of a formula F if it is a \u2286-minimal model of $F^{A}$. We say that a set A of ground atoms is a clingo answer set of a program II if A is an $F^{T}$-stable model of (II)where T is the translation from logic programs to infinitary formulas defined by Gebser et al. (2015). The following result states that the usual relation between ht-interpretations and the FT-reduct is satisfied in our settings.\nProposition 3. Let F be a standard infinitary formula of op. Then, $\\langle H, I\\rangle \\models_{ht} F$ iff H |= FI.\nFor agg-ht-interpretations we can state the relation <PF in terms of the atomic formulas satisfied by it as follows:\nProposition 4. Let $\\langle H,I\\rangle$ be an agg-ht-interpretation. Then, H <PF I iff H \u2282 I.\nUsing Propositions 1-4, we can prove the relation between clingo answer sets and agg-stable models of the corresponding FO theory. Note that clingo answer sets are propositional"}, {"title": "Discussion and Conclusions", "content": "interpretations while agg-stable models of FO theories are FO interpretations. To fill this gap, we introduce the following notation. If I is an agg-stable model of (II), we say that I"}]}