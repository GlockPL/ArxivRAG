{"title": "ReQFlow: Rectified Quaternion Flow for Efficient and High-Quality Protein Backbone Generation", "authors": ["Angxiao Yue", "Zichong Wang", "Hongteng Xu"], "abstract": "Protein backbone generation plays a central role in de novo protein design and is significant for many biological and medical applications. Although diffusion and flow-based generative models provide potential solutions to this challenging task, they often generate proteins with undesired designability and suffer computational inefficiency. In this study, we propose a novel rectified quaternion flow (ReQFlow) matching method for fast and high-quality protein backbone generation. In particular, our method generates a local translation and a 3D rotation from random noise for each residue in a protein chain, which represents each 3D rotation as a unit quaternion and constructs its flow by spherical linear interpolation (SLERP) in an exponential format. We train the model by quaternion flow (QFlow) matching with guaranteed numerical stability and rectify the QFlow model to accelerate its inference and improve the designability of generated protein backbones, leading to the proposed ReQFlow model. Experiments show that ReQFlow achieves state-of-the-art performance in protein backbone generation while requiring much fewer sampling steps and significantly less inference time (e.g., being 37\u00d7 faster than RFDiffusion and 62x faster than Genie2 when generating a backbone of length 300), demonstrating its effectiveness and efficiency. The code is available at https://github.com/AngxiaoYue/ReQFlow.", "sections": [{"title": "1 Introduction", "content": "De novo protein design [12, 19] aims to design rational proteins from scratch with specific properties or functions, which has many biological and medical applications, such as developing novel enzymes for biocatalysis [15] and discovering new drugs for diseases [29, 27]. This task is challenging due to the extremely huge design space of proteins. For simplifying the task, the mainstream de nov\u03bf protein design strategy takes protein backbone generation (i.e., generating 3D protein structures without side chains) as the key step that largely determines the rationality and basic properties of designed proteins.\nFocusing on protein backbone generation, many deep generative models, especially those diffusion and flow-based models [10, 32, 20, 35, 34, 2, 11, 22], have been proposed as potential solutions. However, these models often generate protein backbones with poor designability (the key metric indicating the quality of generated protein backbones), especially for proteins with long residue chains."}, {"title": "2 Related Work and Preliminaries", "content": ""}, {"title": "2.1 Protein Backbone Generation", "content": "Many diffusion and flow-based methods have been proposed to generate protein backbones. These methods often parameterize protein backbones like AlphaFold2 [13] does, representing each protein's residues as a set of SE(3) frames. Accordingly, FrameDiff [35] generates protein backbones by two independent diffusion processes, generating the corresponding frames' local translations and rotations, respectively. Following the same framework, flow-based methods like FrameFlow [34] and FoldFlow [2] replace the stochastic diffusion processes with deterministic flows.\nFor the above methods, many efforts have been made to modify their model architectures and improve data representations, e.g., the Clifford frame attention module in GAFL [31] and the asymmetric protein representation module in Genie [19] and Genie2 [20]. In addition, some methods leverage large-scale pre-trained models to improve generation quality. For example, RFDiffusion [32] utilizes the pre-trained RoseTTAFold [1] as the backbone model. FoldFlow2 [11] improves FoldFlow by using a protein large language model for residue sequence encoding.\nCurrently, the above methods often suffer the conflict on computational efficiency and generation quality. The state-of-the-art methods like RFDiffusion [32] and Genie2 [20] need long inference time to generate protein backbones with reasonable quality. FrameFlow [34] and GAFL [31] significantly improves inference speed while lags behind RFDiffusion and Genie2 in protein backbone quality. Moreover, all the methods suffer severe performance degradation when generating long-chain protein backbones. These limitations motivate us to develop the proposed ReQFlow, improving the current flow-based methods and generating protein backbones efficiently with satisfactory designability."}, {"title": "2.2 Quaternion Algebra and Its Applications", "content": "The proposed ReQFlow is designed based on quaternion algebra [5, 39]. Mathematically, quaternion is an extension of complex numbers into four-dimensional space, consists of one real component and three orthogonal imaginary components. A quaternion is formally expressed as $q = s + xi + yj + zk \u2208 H$, where H denotes the quaternion domain, and s,x,y,z \u2208 R. The imaginary components {i,j,k} satisfy $i\u00b2 = j2 = k2 = ijk = -1$. Each $q \u2208 H$ can be equivalently represented as a vector $q$ = $[s, u^T]^T \u2208 R^4$, where $u$ = $[x, y, z]^T$. Given $q_1$ = $[s_1, u_1]^T$ and $q_2$ = $[s_2, u_2]$, their multiplication is achieved by Hamilton product, i.e.,\n$q_1 \\otimes q_2 = \\begin{bmatrix} s_1 s_2 - u_1^T u_2 \\\\ s_1 u_2 + s_2 u_1 + u_1 \\times u_2 \\end{bmatrix}$                                                                                                                                                                                                                                                                                                     (1)"}, {"title": "3 Proposed Method", "content": ""}, {"title": "3.1 Protein Backbone Parameterization", "content": "We parameterize the protein backbone following [13, 35, 34, 2]. As illustrated in Figure 1, each residue is represented as a frame, where the frame encodes a rigid transformation starting from the idealized coordinates of four heavy atoms: [N*,C*,C*, O*] \u2208 R3\u00d74. In this representation, C* = [0,0,0] is placed at the origin, and the transformation incorporates experimental bond angles and lengths [7]. We can derive each residue's frame by\n[Ni, C\u03b1i, C\u2071, Oi] = Ti \u2218 [N*, C\u03b1*, C*, O*],                                                                                                                                                                                                                                                                                           (5)\nwhere Ti \u2208 SE(3) is the local orientation-preserving rigid transformation mapping the idealized frame to the frame of the i-th residue. In this study, we represent Ti = (xi, qi), where xi \u2208 R3 represents the 3D translation and a unit quaternion qi \u2208 S3, which double-covers SO(3), represents a 3D rotation. According to Eq. 4, the action of Ti on a coordinate v \u2208 R3 can be implemented as\nTi \u2218 v = xi + Im(qi \u25ca [0, vT] \u25ca qi\u22121).                                                                                                                                                                                                                                                                                                    (6)\nNote that, for protein backbone generation, we can use the planar geometry of backbone to impute the coordinate of the oxygen atom Oi [34, 32], so we do not need to parameterize the rotation angle"}, {"title": "3.2 Quaternion Flow Matching", "content": "We decouple the translation and rotation of each frame, establishing two independent flows in R\u00b3 and SO(3), respectively. Without the loss of generality, we define these two flows in the time interval [0, 1]. When t = 0, we sample the starting points of the flows as random noise, i.e., T0 = (x0, q0) ~ T0 \u00d7 Q0, where T0 = N(0, I3) is the Gaussian distribution for translations, and Q0 = IGSO(3) is the isotropic Gaussian distribution on SO(3) for rotations [18], corresponding to uniformly sampling rotation axis u \u2208 S2 and rotation angle \u03c6\u2208 [0, \u03c0]. Based on Eq. 2, we convert the sampled axis and angle to q0. When t = 1, the ending points of these two flows, denoted as T1 = (x1, q1), should be the transformation of a frame. We denote the data distribution of T1 as T1 \u00d7 Q1.\nLinear Interpolation of Translation. For x0 ~ T0 and x1 ~ T1, we can interpolate the trajectory between them linearly: for t \u2208 [0, 1],\n$x_t = (1 - t)x_0 + tx_1$, with constant translation velocity: $v = x_1 - x_0$.                                                                                                                                                                                                                                                                    (7)\nSLERP of Rotation in Exponential Format. For unit quaternions q0 ~ Q0 and q1 ~ Q1, we interpolate the trajectory between them via SLERP in an exponential format [28]:\n$q_t = q_0 \\exp(t \\log(q_0^{-1} q_1))$, with constant angular velocity: $\u03c9 = \\phi u$.                                                                                                                                                                                                                                        (8)\nHere, $q_0^{-1} q_1$ = $[\\cos (\\phi/2), \\sin (\\phi/2) u^T]^T$ and $\u03c9 = 2 \\log(q_0^{-1} q_1)$. exp(\u00b7) and log(\u00b7) are exponential and logarithmic maps defined in Eq. 2 and Eq. 3, respectively.\nTraining QFlow Model. In this study, we adopt the SE(3)-equivariant neural network in FrameFlow [34], denoted as M\u03b8, to model the flows. Given the transformation at time t, i.e., Tt, the model predicts the transformation at t = 1:\n$\\\\mathcal{T}_{0,1} = (x_{\\theta,1}, q_{\\theta,1}) = M_\\theta(T_t, t)$.                                                                                                                                                                                                                                                                                                                                                                          (9)\nWe train this model by the proposed quaternion flow (QFlow) matching method. In particular, given the frame T1 = (x1, q1), we first sample a timestamp t ~ Uniform([0, 1]) and random initial points T0 = (x0, q0) ~ T0 \u00d7 Q0. Then, we derive obtain (xt, v) and (qt, \u03c9) via Eq. 7 and Eq. 8, respectively. Passing (xt, qt, t) through the model M\u03b8, we obtain x\u03b8,1 and q\u03b8,1, and derive the translation and angular velocities at time t by\n$v_{\\theta,t} = \\frac{x_{\\theta,1} - x_t}{1 - t}, \\qquad  \u03c9_{\\theta,t} = \\frac{2 \\log(q_t^{-1} q_{\\theta,1})}{1 - t}$                                                                                                                                                                                                                                                          (10)\nBased on the constancy of the velocities, we train the model M\u03b8 by minimizing the following two objectives:\n$\\\\mathcal{L}_{R^3} = E_{t, \\mathcal{T}_0, \\mathcal{T}_1} [||v - v_{\\theta,t}||^2], \\quad \\mathcal{L}_{SO(3)} = E_{t, Q_0, Q_1} [||\u03c9 - \u03c9_{\\theta,t}||^2].$                                                                                                                                                                                                                                                                     (11)\nBesides the above MSE losses, we further consider the auxiliary loss proposed in [35], which discourages physical violations, e.g., chain breaks or steric clashes. Therefore, we train the model by\n$\\\\min_{\\theta} \\mathcal{L}_{R^3} + \\mathcal{L}_{SO(3)} + \u03b1 \u00b7 1\\{t < \\epsilon\\} \u00b7 \\mathcal{L}_{aux}$,                                                                                                                                                                                                                                                                                          (12)"}, {"title": "3.3 Rectified Quaternion Flow", "content": "Given the trained QFlow model M\u03b8, we can rewire the flows in R\u00b3 and SO(3), respectively, with a non-crossing manner by the flow rectification method in [23]. In particular, we generate noisy T'0 = {x0, q0} ~ T0 \u00d7 Q0 and transfer to T'1 = {x1, q1} ~ T1 \u00d7 Q1 by M\u03b8. Taking M\u03b8 as the initialization, we use the noise-sample pairs, i.e., {T'0, T'1}, to train the model further by the same loss in Eq. 12 and derive the rectified QFlow (ReQFlow) model.\nThe work in [23] has demonstrated that the rectified flow of translation in R\u00b3 preserves the marginal law of the original translation flow and reduces the transport cost from the noise to the samples. We find that these theoretical properties are also held by the rectified quaternion flow under mild assumptions. Let (q0, q1) ~ Q0 \u00d7 Q1 be the pair used to train QFlow, and ($q_0^{\\dagger}$, $q_1^{\\dagger}$) be the pair induced from (q0, q1) by flow rectification. Then, we have\nTheorem 3.1. (Marginal preserving property). The pair ($q_0^{\\dagger}$, $q_1^{\\dagger}$) is a coupling of Q0 and Q1. The marginal law of $q_t^{\\dagger}$ equals that of qt at everytime, that is Law($q_t^{\\dagger}$) = Law(qt).\nTheorem 3.2. (Reducing transport costs). The pair ($q_0^{\\dagger}$, $q_1^{\\dagger}$) yields lower or equal convex transport costs than the input (q0, q1). For any convex c: R\u00b3 \u2192 R, define the cost as $C(q_0, q_1)$ = $c (log(q^{-1}_0 q_1))$. Then, we have $E[C(q_0^{\\dagger}, q_1^{\\dagger})] \u2264 E[C(q_0, q_1)]$.\nTheorem 3.2 shows that the coupling ($q_0^{\\dagger}$, $q_1^{\\dagger}$) either achieves a strictly lower or the same convex transport cost compared to the original one, highlighting the advantage of the quaternion flow rectification in reducing the overall rotation displacement cost without compromising the marginal distribution constraints (Theorem 3.1). In addition, we have\nCorollary 3.3. (Cost Reduction with Nonconstant Speed). Suppose the geodesic interpolation qt between q0 and q1 has a constant axis u, but its speed is nonconstant in time, i.e, \u03c9t = \u03b1(t)u. The quaternion flow rectification still reduces or preserves the transport cost.\nThis corollary means that when applying the exponential step size scheduler (i.e., Eq. 15), the rectification still reduces or preserves the transport cost."}, {"title": "3.4 Rationality Analysis", "content": "Most existing methods, like FrameFlow [34] and FoldFlow [2], represent rotations as 3 \u00d7 3 matrices. Given two rotation matrices R0 and R1, they construct a flow in SO(3) with matrix geodesic interpolation:\nRt = R0 expM (tlogM (R0T R1)),                                                                                                                                                                                                                                                                           (16)\nwhere expM(\u00b7) and logM(\u00b7) denote the matrix exponential and logarithmic maps, respectively. The corresponding angular velocity \u03a9 = logM(R0T R1). Different from existing methods [34, 35, 2], our method applies quaternion-based rotation representation and achieves rotation interpolation by SLERP in an exponential format, which achieves superior numerical stability and thus benefits protein backbone generation.\nTo verify this claim, we conduct a round-trip error experiment: given an rotation \u03c9 in the axis-angle format, we convert it to a rotation matrix R and a quaternion q, respectively, and convert it back to the axis-angle format, denoted as \u03c9r and \u03c9q, respectively. Figure 3a shows the round-trip errors in L2 norm for large rotation angles (e.g., \u03c6 \u2208 [\u03c0 \u2013 10\u22122, \u03c0)). Our quaternion-based method is numerically stable while the matrix-based representation suffers severe numerical errors. When training a protein backbone generation model, the numerical stability for large rotation angles is important. Given the frames in the Protein Data Bank (PDB) [3] dataset and the SCOPe [4] dataset, we sample a random noise for each frame and calculate the rotation angle between them. The histogram in Figure 3b shows that when training an arbitrary flow-based model, the probability of suffering at least one large angle per protein is 0.59 for PDB and 0.34 for SCOPe, respectively. It means that the matrix-based representation may introduce undesired numerical errors that aggregate and propagate during training.\nIn addition, a very recent work, AssembleFlow [8], also applies quaternion-based rotation represen- tation and SLERP when modeling 3D molecules. In particular, it applies SLERP in an additive format:\n$q_t = \\frac{\\sin((1-t)\\frac{\\phi}{2})}{\\sin(\\frac{\\phi}{2})} q_0 + \\frac{\\sin(t\\frac{\\phi}{2})}{\\sin(\\frac{\\phi}{2})} q_1$,                                                                                                                                                                                                                                                                                (17)"}, {"title": "4 Experiment", "content": "To demonstrate the effectiveness and efficiency of our methods (QFlow and ReQFlow), we conduct comprehensive experiments to compare them with state-of-the-art protein backbone generation methods. In addition, we conduct ablation studies to verify the usefulness of the flow rectification strategy and the impact of sampling steps on model performance. All the experiments are implemented on four NVIDIA A100 80G GPUs. Implementation details and experimental results are shown in this section and Appendix C."}, {"title": "4.1 Experimental Setup", "content": "Datasets. We apply two commonly used datasets in our experiments. The first is the 23,366 protein backbones collected from Protein Data Bank (PDB) [3], whose lengths range from 60 to 512. The second is the SCOPe dataset [4] pre-processed by FrameFlow [34], which contains 3,673 protein backbones with lengths ranging from 60 to 128.\nBaselines. The baselines of our methods include diffusion-based methods (FrameDiff [35], RFDiffusion [32], and Genie2 [20]) and flow-based methods (FrameFlow [34], FoldFlow [2], and FoldFlow2 [11]). In addition, we rectify FrameFlow by our method (i.e., re-training FrameFlow based on the paired data generated by itself) and consider the rectified FrameFlow (ReFrameFlow) as a baseline as well."}, {"title": "4.2 Comparison Experiments on PDB", "content": "Generation Quality. Given the models trained on PDB, we set the length of backbone N \u2208 {100, 150, 200, 250, 300}, and generate 50 protein backbones for each length. Table 2 shows that ReQFlow achieves state-of-the-art performance in designability, achieving the highest Fraction (0.972) among all models, significantly outperforming strong competitors such as Genie2 (0.908) and RFDiffusion (0.904). Additionally, it achieves the lowest scRMSD (1.071\u00b10.482), with a notably smaller variance compared to the other methods, highlighting the model's consistency and reliability in generating high-quality protein backbones. Meanwhile, ReQFlow maintains competitive performance in diversity and novelty (0.828), comparable to state-of-the-art baselines.\nComputational Efficiency. Moreover, ReQFlow achieves ultra-fast protein backbone generation. Typically, ReQFlow achieves a high Fraction score (0.912) with merely 50 steps and 1.81s, outper- forming RFDiffusion and Genie2 with 37\u00d7 and 62\u00d7 acceleration, respectively. The state-of-the-art methods like Genie2 and FoldFlow2 suffer severe performance degradation in designability when the number of steps is halved, while ReQFlow performs stably even reducing the number of steps from 500 to 20. In addition, even if using the same model architecture and inference setting, ReQFlow can be ~10% faster than FrameFlow because of utilizing the quaternion-based computation.\nFitness of Data Distribution. Given generated protein backbones, we record the percentages of"}, {"title": "5 Conclusion and Future Work", "content": "In this study, we propose a rectified quaternion flow matching method for efficient and high-quality protein backbone generation. Leveraging quaternion-based representation and flow rectification, our method achieves state-of-the-art performance and significantly reduces inference time. In the near future, we plan to improve our method for generating high-quality long-chain protein backbones, including constructing a larger training dataset, improving our model architecture, and leveraging the knowledge within large-scale pre-training models. As long-term goals, we will extend our method to conditional protein backbone generation for controllable protein design and explore its applications in side chain generation and full-atom protein generation."}, {"title": "A Proofs of Key Theoretical Results", "content": ""}, {"title": "A.1 The Angular Velocity under Exponential Scheduler", "content": "Proposition A.1. For spherical linear interpolation (SLERP) with angular velocity \u03c9, when applying an exponential scheduler during inference:\n$q_t$ = $q_0$ \u2297 $\\exp ((1 \u2212 e^{-\u03b3t}) \\log(q^{-1}_0 q_1))$,                                                                                                                                                                                                                                                                     (19)\nthe resulting angular velocity evolves as \u1f63t = $\u03b3e^{\u2212\u03b3t}\u03c9$.\nProof. The standard SLERP formulation in exponential form is:\nqt = q0 \u2297 exp (t log(q0\u22121 q1)),                                                                                                                                                                                                                                                                          (20)\nwhere the relative rotation $q_{rel}$ = $q_0^{-1} q_1$ has logarithm map log($q_{rel}$) = $\\phi u$. The angular velocity is:\n$\u03c9 = 2 \u00b7 log(q_{rel}) = \\phi u$.                                                                                                                                                                                                                                                                          (21)\nIntroducing an exponential scheduler \u03ba(t) = $1 \u2212 e^{\u2212\u03b3t}$ with derivative \u03ba'(t) = $\u03b3e^{\u2212\u03b3t}$, the modified SLERP becomes:\nqt = q0 \u2297 exp (\u03ba(t) log(qrel)) .                                                                                                                                                                                                                                                                 (22)\nDifferentiating with respect to time using the chain rule:\n$q_t = q_0 \u2297 \\frac{d}{dt} \\exp (\u03ba(t) log(qrel))$\n= $\u03b3e^{\u2212\u03b3t} \\log(q_{rel}) \u2297 q_0 \u2297 \\exp (\u03ba(t) log(q_{rel}))$\n= $\u03b3e^{\u2212\u03b3t} \\log(q_{rel}) \u2297 q_t$.                                                                                                                                                                                                                                                                       (23)\nApplying the quaternion kinematics equation $\u0121$ = $\\frac{1}{2} [0, \\omega]^T \u2297 q$ [28], we solve for the effective angular velocity:\n$\\frac{1}{2} [0, \u03c9]^T$ = $2q_t q^{-1}_t$\n= $2\u03b3e^{\u2212\u03b3t} \\log(q_{rel}) \u2297 q_t \u2297 q^{-1}_t$\n= $2\u03b3e^{\u2212\u03b3t} \\log(q_{rel})$.                                                                                                                                                                                                                                                                   (24)\nSubstituting the angular velocity from Eq. 21 yields:\n\u1f63t = $\u03b3e^{\u2212\u03b3t}\u03c9$.\n(25)"}, {"title": "A.2 Proofs of The Theorems in Section 3.3", "content": "Our proofs yield the same pipeline used in [23]. The proofs are inspired by that work and derived based on the same techniques. What we did is extending and specifying the theoretical results in [23] for S3. The original rotation process is {$q_t$}$_{t\u2208[0,1]}$, where each $q_t$ is a unit quaternion representating a rotation in SO(3), $w_t \u2208 R^3$ is the angular velocity at time t. The quaternion dynamics are given by\n$\u0121_t = \\frac{1}{2} [0, w]^T q_t \u2208 Tq_t(S^3)$,                                                                                                                                                                                                                                                                 (26)"}, {"title": "B Implementation Details", "content": ""}, {"title": "B.1 Ensuring The Shortest Geodesic Path on SO(3)", "content": "When we interpolate two quaternions by using SLERP in an exponential format (Eq. 8), due to the double-cover property of quaternions (where every 3D rotation is represented by two antipodal unit quaternions), it is possible that the inner product\u3008$q_0$, $q_1$\u3009 < 0, which means that $q_0$ and $q_1$ lie in opposite hemispheres. In such a situation, we apply -q1 in Eq. 8, ensuring the shortest geodesic path on SO(3)."}, {"title": "B.2 Auxiliary Loss", "content": "We adopt the auxiliary loss from [35] to discourage physical violations such as chain breaks or steric clashes. Let A = [N, Ca, C, O] be the collection of backbone atoms. The first term penalizes deviations in backbone atom coordinates:\n$\\mathcal{L}_{bb} = \\frac{1}{40} \\sum_{n=1}^N \\sum_{a \\in A} ||a_n - \\hat{a}_n||^2$,                                                                                                                                                                                                                                                                 (49)\nwhere an is the ground-truth atom position, \u00e2n is our predicted position, N represents the number of residues. The second loss is a local neighborhood loss on pairwise atomic distances,\n$\\mathcal{L}_{dis} = \\sum_{n,m=1}^N \\sum_{a,b \\in A} \\frac{1}{Z} 1\\{d_{ab}^{nm} < 0.6\\} ||d_{ab}^{nm} - \\hat{d}_{ab}^{nm}||^2$,                                                                                                                                                                                                          (50)\n$Z = \\sum_{n,m=1}^N \\sum_{a,b \\in A} 1\\{d_{ab}^{nm} < 0.6\\} - N$,                                                                                                                                                                                                                                  (51)\nwhere $\\hat{d}_{ab}^{nm} = ||a_n - b_m||$ and $\\hat{d}_{ab}^{nm} = ||\\hat{a}_n - \\hat{b}_m||$ represent true and predicted inter-atomic distances between atoms a, b \u2208 A for residue n and m. 1 is an indicator, signifying that only penalize atoms within 0.6nm(6\u00c5). The full auxiliary loss can be written as\n$\\mathcal{L}_{aux} = \\mathcal{L}_{bb} + \\mathcal{L}_{dis}$.                                                                                                                                                                                                                                                                 (52)"}, {"title": "B.3 The Schemes of Training and Inference Algorithms", "content": "The schemes of our training and inference algorithms are shown below."}, {"title": "B.4 Data Statistics and Hyperparameter Settings", "content": "We follow [35] to construct PDB dataset. The dataset was downloaded on December 17, 2024. We then applied a length filter (60\u2013512 residues) and a resolution filter (< 5 \u00c5) to select high-quality structures. To further refine the dataset, we processed each monomer using DSSP [14], removing those with more than 50% loops to ensure high secondary structure content. After filtering, 23,366 proteins remained for training. We directly use the SCOPe dataset preprocessed by [34] for training, which consists of 3,673 proteins after filtering. The distribution of dataset length is shown on Figure 7.\nWhen conducting reflow, we first generated a large amount of data to create the training dataset and then applied filtering to refine it. The filtering criteria were as follows: for proteins with lengths"}, {"title": "B.5 Metrics", "content": "Designability. A protein backbone is considered designable if at least one amino acid sequence can fold into its structure. Our evaluation follows the methodology described in [35]. Specifically", "},\n    {": "itle", "B.6 Baselines": "content\": \"Genie2 We use the code from Genie2 public repository. We loaded the base checkpoint trained for 40 epochs. The noise scale was set to 1 for full temperature sampling and 0.6 for low temperature sampling.\nRFdiffusion We use the code from RFdiffusion public repository. Default configuration of the repository was used for sampling.\nFoldFlow We use the code from FoldFlow public repository, which contains both FoldFlow and FoldFlow2. We set noise_scale to 0.1 and flow_matcher.so3.inference_scaling to 10 to achieve best performance.\nFrameFlow We install FrameFlow from its public repository. Model weights are downloaded from here.\nFrameDiff We used the code from FrameDiff public repository. The checkpoint we use is located in ./weights/paper_weights.pth. We use the provided conda environment and default configuration for sampling."}, {"title": "C More Experimental Results", "content": ""}, {"title": "C.1 Detailed Comparisons Based on SCOPe", "content": "Table 5 presents comprehensive results from the SCOPe experiment, further demonstrating the superiority of the QFlow model and the reflow operation, especially in the context of ReQFlow. Notably, even with a generation process as concise as 10 steps, ReQFlow achieves a designable fraction of 0.848, while having an impressively fast inference time of just 0.26 seconds per protein. This highlights the efficiency and effectiveness of ReQFlow in generating feasible protein structures within a minimal timeframe. Additionally, both QFlow and ReQFlow models produce proteins with reasonable secondary structure distributions, indicating their capability to generate structurally plausible proteins. These findings underscore the potential of these models to significantly advance the field of protein design by balancing computational efficiency with structural accuracy."}, {"title": "C.2 Comparisons on Model Size and Training Data Size", "content": "The comparison of model size and training dataset size is listed in Table 6. Model sizes in the table refer to the number of total parameter. FoldFlow2 utilizes a pre-trained model, thus having 672M parameters in total. The number of trainable parameters is 21M."}, {"title": "C.3 Visualization Results", "content": "We use Mol Viewer [25] to visualize protein structures generated by different models, as shown in Figure 8 and Figure 9. In Figure 8, all proteins originate from the same noise initialization generated by QFlow, whereas in Figure 9, the initialization is generated by FoldFlow. Each method follows its own denoising trajectory, leading to distinct structural outputs. FoldFlow2 adopts a default sampling step of 50, while all other methods use 500 steps. Due to architectural differences, the final structures vary across models, but within the same model, different sampling steps generally yield"}]}