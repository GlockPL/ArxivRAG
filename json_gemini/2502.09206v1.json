{"title": "Efficient OWL2QL Meta-reasoning Using ASP-based Hybrid Knowledge Bases", "authors": ["Haya Majid Qureshi", "Wolfgang Faber"], "abstract": "Metamodeling refers to scenarios in ontologies in which classes and roles can be members of classes or occur in roles. This is a desirable modelling feature in several applications, but allowing it without restrictions is problematic for several reasons, mainly because it causes undecidability. Therefore, practical languages either forbid metamodeling explicitly or treat occurrences of classes as instances to be semantically different from other occurrences, thereby not allowing metamodeling semantically. Several extensions have been proposed to provide metamodeling to some extent. Building on earlier work that reduces metamodeling query answering to Datalog query answering, recently reductions to query answering over hybrid knowledge bases were proposed with the aim of using the Datalog transformation only where necessary. Preliminary work showed that the approach works, but the hoped-for performance improvements were not observed yet. In this work we expand on this body of work by improving the theoretical basis of the reductions and by using alternative tools that show competitive performance.", "sections": [{"title": "1 Introduction", "content": "Metamodeling helps in specifying conceptual modelling requirements with the notion of meta-classes (for instance, classes that are instances of other classes) and meta-properties (relations between meta-concepts). These notions can be expressed in OWL Full. However, OWL Full is so expressive for metamodeling that it leads to undecidability [13]. OWL 2 DL and its sub-profiles guarantee decidability, but they provide a very restricted form of metamodeling [7] and give no semantic support due to the prevalent Direct Semantics (DS).\nConsider an example adapted from [6], concerning the modeling of biological species, stating that all golden eagles are eagles, all eagles are birds, and Harry is an instance of GoldenEagle, which further can be inferred as an instance of Eagle and Bird. However, in the species domain one can not just express properties of and relationships among species, but also express properties of the species themselves. For example \"GoldenEagle is listed in the IUCN Red List of endangered species\u201d states that GoldenEagle as a whole class is an endangered species. Note that this is also not a subclass relation, as Harry is not an endangered species. To formally model this expression, we can declare GoldenEagle to be an instance of new class EndangeredSpecies.\nEagle \u2286 Bird, GoldenEagle \u2286 Eagle, GoldenEagle(Harry)\nEndangeredSpecies \u2286 Species, EndangeredSpecies(GoldenEagle)\nNote that the two occurrences of the IRI for GoldenEagle (in a class position and in an individual position) are treated as different objects in the standard direct semantics DS\u00b9, therefore not giving semantic"}, {"title": "2 Preliminaries", "content": "This section gives a brief overview of the language and the formalism used in this work."}, {"title": "2.1 OWL 2 QL", "content": "This section recalls the syntax of the ontology language OWL 2 QL and the Metamodeling Semantics (MS) for OWL 2 QL, as given in [12]."}, {"title": "2.1.1 Syntax", "content": "We start by recalling some basic elements used for representing knowledge in ontologies: Concepts, a set of individuals with common properties, Individuals, objects of a domain of discourse, and Roles, a set of relations that link individuals. An OWL 2 ontology is a set of axioms that describes the domain of interest. The elements are classified into literals and entities, where literals are values belonging to datatypes and entities are the basic ontology elements denoted by Internationalized Resource Identifiers (IRI). The notion of the vocabulary V of an OWL 2 QL, constituted by the tuple V = (Ve, Vc,Vp,Va, D, Vi, LQL). In V, Ve is the union of Vc, Vp, Va, V; and its elements are called atomic expressions; Vc, Vp, Va, and V; are sets of IRIs, denoting, respectively, classes, object properties, data properties, and individuals, LOL denotes the"}, {"title": "2.1.2 Meta-modeling Semantics", "content": "The Meta-modeling Semantics (MS) is based on the idea that every entity in V may simultaneously have more than one type, so it can be a class, or an individual, or data property, or an object property or a data type. To formalise this idea, the Meta-modeling Semantics has been defined for OWL 2 QL. In what follows, P(S) denotes the power set of S. The meta-modeling semantics for O over V is based on the notion of interpretation, constituted by a tuple I = (\u2206, .1, C, P, .D, .T, .I), where\n\u2022 A is the union of the two non-empty disjoint sets: A = \u2206\u00ba UA\", where A\u00ba is the object domain, and A' is the value domain defined by DMQL;\n\u2022 .1 : \u0394\u00b0 \u2192 {True,False} is a total function for each object o \u2208 \u0394\u00ba, which indicates whether o is an individual; if C, P, .D, .T are undefined for an o, then we require o\u00b9 = True, also in other cases, e.g., if o is in the range of .C;\n\u2022 .C : \u2206\u00ba \u2192 P(A\u00ba) is partial and can assign the extension of a class;\n\u2022 .P : \u2206\u00ba \u2192 P(\u0394\u00ba \u00d7 \u25b3\u00ba) is partial and can assign the extension of an object property;\n\u2022 .D : \u2206\u00ba \u2192 P(\u0394\u00ba \u00d7 \u25b3') is partial and can assign the extension of a data property;\n\u2022 .\u03a4 : \u0394\u00ba \u2192 P(A') is partial and can assign the extension of a datatype;\n\u2022 .I is a function that maps every expression in Exp to \u2206\u00ba and every literal to Av.\nThis allows for a single object o to be simultaneously interpreted as an individual via 1, a class via .C, an object property via P, a data property via D, and a data type via \u00b7T. For instance, for Example 1, .C, I would be defined for GoldenEagle, while .P, .D and .T would be undefined for it.\nThe semantics of logical axiom a is defined in accordance with the notion of axiom satisfaction for an MS interpretation I. The complete set of notions is specified in Table 3.B in [12]. Moreover, I is said to be a model of an ontology if it satisfies all axioms of O. Finally, an axiom a is said to be logically implied by O, denoted as 0 = a, if it is satisfied by every model of 0.\""}, {"title": "2.2 Hybrid Knowledge Bases", "content": "Hybrid Knowledge Bases (HKBs) have been proposed for coupling logic programming (LP) and Description Logic (DL) reasoning on a clear semantic basis. Our approach uses HKBs of the form K = (0, P), where O is an OWL 2 QL knowledge base and P is a hex program, as defined next.\nHex programs [3] extend answer set programs with external computation sources. We use hex programs with unidirectional external atoms, which import elements from the ontology of an HKB. For a detailed discussion and the semantics of external atoms, we refer to [4]. What we describe here is a simplification of the much more general hex formalism.\nRegular atoms are of the form p(X1,...,Xn) where p is a predicate symbol of arity n and X1,...,Xn are terms, that is, constants or variables. An external atom is of the form &g[X1, ..., Xn](Y1, ...,Ym) where g is an external predicate name g (which in our case interfaces with the ontology), X1,..., Xn are input terms and Y\u2081, ..., Ym are output terms.\nNext, we define the notion of positive rules that may contain external atoms.\nDefinition 1. A hex rule r is of the form\na \u2190 b\u2081,...,bk. k\u22650\nwhere a is regular atom and b\u2081,...,bk are regular or external atoms. We refer to a as the head of r, denoted as H(r), while the conjunction b\u2081,...,bk is called the body of r.\nWe call r ordinary if it does not contain external atoms. A program P containing only ordinary rules is called a positive program, otherwise a hex program. A hex program is a finite set of rules.\nThe semantics of hex programs generalizes the answer set semantics. The Herbrand base of P, denoted HBP, is the set of all possible ground versions of atoms and external atoms occurring in P (obtained by replacing variables with constants). Note that constants are not just those in the standard Herbrand universe (those occuring in P) but also those created by external atoms, which in our case will be IRIs from O. Let the grounding of a rule r be grd(r) and the grounding of program P be grd(P) = Ur\u2208p grd(r). An interpretation relative to P is any subset I \u2286 HBp containing only regular atoms. We write I = a iff a \u2208 I. With every external predicate name &g \u2208 G we associate an (n+m+1)-ary Boolean function f&g (called oracle function) assigning each tuple (I,x1,...,Xn, Y1..., ym) either 0 or 1, where I is an interpretation and xi,yj are constants. We say that I = &g[x1,...,Xn](y1,..., \u0423\u0442) iff f&g(I,X1...,Xn,y1,...,ym) = 1. For a ground rule r, I = B(r) iff I = a for all a \u2208 B(r) and I = r iff I = H(r) whenever I = B(r). We say that I is a model of P, denoted I|= P, iff I |= r for all r\u2208 grd(P). The FLP-reduct of P w.r.t I, denoted as f\u00d8l, is the set of all r \u2208 grd(P) such that I|= B(r). An interpretation I is an answer set of P iff I is a minimal model of f Pl. By AS(P) we denote the set of all answer sets of P. If K = (0, P), then we write AS(K) = AS(P) \u2014 note that O is implicitly involved via the external atoms in P. In this paper, AS(K) will always contain exactly one answer set, so we will abuse notation and write AS(K) to denote this unique answer set.\nWe will also need the notion of query answers of HKBs that contain rules defining a dedicated query predicate q. Given a hybrid knowledge base K and a query predicate q, let ANS(q, K) denote the set {(x1,...,xn) | q(x1,...,xn) \u2208 AS(K)}."}, {"title": "3 Query Answering Using MSER", "content": "We consider SPARQL queries, a W3C standard for querying ontologies. While SPARQL query results can in general either be result sets or RDF graphs, we have restricted ourselves to simple SELECT"}, {"title": "4 MSER Query Answering via Hybrid Knowledge Bases", "content": "We propose four variants for answering MSER queries by means of Hybrid Knowledge Bases. We first describe the general approach and then define each of the four variants."}, {"title": "4.1 General Architecture", "content": "The general architecture is outlined in Figure 1. In all cases, the inputs are an OWL 2 QL ontology O and a SPARQL query 2. We then differentiate between OntologyFunctions and QueryFunctions. The OntologyFunctions achieves two basic tasks: first, the ontology is split into two partitions O' and O\", then \u03c4(0\") is produced.\nThe Query Functions work mainly on the query. First, a set N of IRIs is determined for creating Interface Rules (IR, simple hex rules), denoted as \u03c0(N) for importing the extensions of relevant classes and properties from O'. In the simplest case, N, consist of all IRIs in O', but we also consider isolating those IRIs that are relevant to the query by means of Logic-based Module Extraction (LME) as defined in [8]. Then, \u03c4\u00ba translates 2 into a Datalog query \u03c4\u00ba(2). Finally, the created hex program components are united (plus the fixed inference rules), yielding the rule part P = Rql \u222a \u03c0(N) UT(O\") Ut9(2), which together with O' forms the HKB K = (O', P), for which we then determine ANS(q, K), where q is the query predicate introduced by t\u00ba(2)."}, {"title": "4.2 Basic Notions", "content": "Before defining the specific variations of our approach, we first define some auxiliary notions. The first definition identifies meta-elements.\nDefinition 2. Given an Ontology O, IRIs in (VUV\u266d)\u2229V; are meta-elements, i.e., IRIs that occur both as individuals and classes or object properties.\nIn our example, GoldenEagle is a meta-element. Meta-elements form the basis of our main notion, clashing axioms."}, {"title": "4.3 Variants", "content": "Now we define the four variants for the ontology functions, and two for the query functions. Since for one ontology function ' is empty, the two query functions have the same effect, and we therefore arrive at seven different variants for creating the hybrid knowledge bases (HKB).\nThe difference in the ontology functions is which axioms of O = (A, I) stay in O' and which are in O\", the latter of which is translated to Datalog. We use a simple naming scheme, indicating these two components:\nA-T: 0' = A, O\" = T .\nNAT-CAT: 0' = (AN, T), O\" = (AC, T).\nNAT-CACT: 0' = (AN, T), O\" = (AC, TC).\nE-AT: 0' =0,0\" = 0 = (A, T).\nE-AT serves as a baseline, as it boils down to the Datalog encoding of [2].\nDefinition 6. Given O = (A, T), let the A\u2013T HKB be KA-T (O) = (A, Rql UT(T)); the NAT \u2013CAT HKB be KNAT\u2013CAT (0) = ((AN, T), Rql\u016aT((AC, T))); the NAT \u2013CACT HKB be KNAT-CACT (0) = ((AN, T), RqlUt((AC, TC))); the E-AT HKB be KE-AT (0) = (0,Rql UT(O)).\nNext we turn to the query functions. As hinted at earlier, we will consider two versions, which differ in the Interface Rules they create. Both create query rules \u03c4\u00ba(2) for the given query, but one (All) will create interface rules for all classes and properties in the ontology part of the HKB, while the other (Mod) will extract the portion of the ontology relevant to query using LME and create Interface Rules only for classes and properties in this module.\nFor notation, we will overload the U operator for HKBs, so we let (O, P)U(O', P') = (OUO', PUP') and we also let (O, P)UP' = (0, PUP') for ontologies O and O' and hex programs Pand P'\nDefinition 7. Given an HKB (0, P) and query 2, let the All HKB be defined as Hall((O, P), 2) =\n(0, PU\u03c4\u03b1 (2) \u03c5\u03c0(S(0))).\nDefinition 8. Given an HKB (O, P) and query 2, let the Mod HKB be Kmod((O, P), 2) = (0, PU\n\u03c4\u03b1(2) U\u03c0(S(LME(S(2), 0))))).\nWe will combine ontology functions and query functions, and instead of Hp (Ka(0), 2) we will write X(0,2). We thus get eight combinations, but we will not use Ko, as it unnecessarily introduces Interface Rules. Also note that KE-AT (0, 2) does not contain any Interface Rules, because the ontology part of KE-AT (0) is empty.\nWe will next show the correctness of the transformations. We start with the simplest case.\nProposition 1. Let O be a consistent OWL 2 QL ontology and 2 a conjunctive SPARQL query. Then, ANS(2, 0) = ANS(q, KE-AT (0, 2)), where q is the query predicate introduced by t\u00ba(2).\nProof. In [2] it was shown that ANS(2,0) = Pq(\u03c4(0)) = {(x1,...,xn) | q(x1,...,xn) \u2208 MM(Rql U\n\u03c4(0)\u222a\u03c4\u03b1(2))}.\nSince MM(P) = AS(P) = AS((0,P)) for any Datalog program P, it follows that ANS(2,0) =\n{(x1,...,xn) | q(x1,...,xn) \u2208 AS((0, Rql UT(O) Utq(2)))}.\nPer definition, we get KETAT (0,2) = Kall(KE-AT (0), 0, 2) = KA11((O,Rql UT(0)), 0, 2) =\n(O,Rql UT(O) Urq(2) \u222a \u03c0(S(0))), therefore ANS(q, K-AT (0,2)) = {(x1,...,xn) | q(x1,...,xn) \u2208\nAS((0, RqlUT(O) Utq(2) U\u03c0(S(0))))}."}, {"title": "5 Evaluation", "content": "In [15] we conducted experiments using HEXLite with the OWL-API plugin. While it did show drastic improvements when using one of the hybrid approaches with respect to the baseline E-AT and with using Mod rather then All, the absolute performance left to be desired. In particular, with the larger ontologies considered, no answer could be obtained even after hours. This contrasts sharply with the findings in [14], in which the best systems took only seconds to answer queries even on the larger ontologies. The main reasons appeared to be inefficiencies in the OWL-API plugin, paired with a lack of query-oriented computation.\nIn the meantime we became aware of DLV2 with Python external atoms.\nThe version of DLV2 that we obtained from the developers directly supports the Turtle format of ontologies, and one can use ontology IRIs directly as predicate names. The rules in Definition 5 can then directly use class and role identifiers:\nDefinition 9. For a set a of IRIs N, let \u03c0(N) denote the DLV2 program containing a rule\ninstc(C,X) \u2190 C(X).\nfor each class identifier C \u2208 N, and a rule\ninstr(R,X,Y) \u2190 R(X,Y).\nfor each property identifier R\u2208N.\nFor transforming our ontologies to Turtle format, we have used a utility called ont-converter that automatically transforms the source ontology in different formats (RDF/XML, OWL/XML, N3, etc).\nThe experimental setting is the same as in [15]: we conducted two sets of experiments on the widely used Lehigh University Benchmark (LUBM) dataset and on the Making Open Data Effectively USable (MODEUS) Ontologies7. We only use the query function Mod, as it was evident in [15] that All has no advantage over Mod.\nThe LUBM datasets describe a university domain with information like departments, courses, students, and faculty. This dataset comes with 14 queries with different characteristics (low selectivity vs high selectivity, implicit relationships vs explicit relationships, small input vs large input, etc.). We have also considered the meta-queries mq1, mq4, mq5, and mq10 from [9] as they contain variables in-property positions and are long conjunctive queries. We have also considered two special-case queries sql and sq2 from [2] to exercise the MSER features and identify the new challenges introduced by the additional expressivity over the ABox queries. Basically, in special-case queries, we check the impact of DISJOINTWITH and meta-classes in a query. For this, like in [2], we have introduced a new class named TypeOfProfessor and make FullProfessor, AssociateProfessor and AssistantProfessor instances of this new class and also define FullProfessor, AssociateProfessor and AssistantProfessor to be disjoint from each other. Then, in sql we are asking for all those y and z, where y is a professor, z is a type of professor and y is an instance of z. In sq2, we have asked for different pairs of professors.\nThe MODEUS ontologies describe the Italian Public Debt domain with information like financial liability or financial assets to any given contracts [11]. It comes with 8 queries. These queries are pure meta-queries as they span over several levels of the knowledge base. MODEUS ontologies are meta-modeling ontologies with meta-classes and meta-properties."}, {"title": "6 Discussion and Conclusion", "content": "This work shows that the methods introduced in [15] do not only have a positive relative impact when using a hybrid reasoner, but that they can also yield the best known performance when using a suitable tool for hybrid reasoning.\nIt seems clear from the result that there is a benefit of keeping some portions in the ontology rather than transforming the entire ontology to facts. This is, however, contingent of the availability of a query-aware method (in this case magic sets). Among the variants, NAT -CACTshowed best performance, which is also the one that hybridizes most.\nIn the future, we plan to investigate alternative variants for producing hybrid knowledge bases and assessing their performance. Another line of future work will be to identify more hybrid reasoning systems that are query aware and benchmark these."}]}