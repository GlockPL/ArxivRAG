{"title": "Incremental IVF Index Maintenance for Streaming Vector Search", "authors": ["Jason Mohoney", "Anil Pacaci", "Shihabur Rahman Chowdhury", "Umar Farooq Minhas", "Jeffrey Pound", "Cedric Renggli", "Nima Reyhani", "Ihab F. Ilyas", "Theodoros Rekatsinas", "Shivaram Venkataraman"], "abstract": "The prevalence of vector similarity search in modern machine learning applications and the continuously changing nature of data processed by these applications necessitate efficient and effective index maintenance techniques for vector search indexes. Designed primarily for static workloads, existing vector search indexes degrade in search quality and performance as the underlying data is updated unless costly index reconstruction is performed. To address this, we introduce Ada-IVF, an incremental indexing methodology for Inverted File (IVF) indexes. Ada-IVF consists of 1) an adaptive maintenance policy that decides which index partitions are problematic for performance and should be repartitioned and 2) a local re-clustering mechanism that determines how to repartition them. Compared with state-of-the-art dynamic IVF index maintenance strategies, Ada-IVF achieves an average of 2x and up to 5x higher update throughput across a range of benchmark workloads.", "sections": [{"title": "1 INTRODUCTION", "content": "Modern machine learning applications increasingly rely on high-dimensional vector embeddings to transform complex data such as images, text, or entities in knowledge graphs to vector representations that retain semantically meaningful information [19, 20, 27, 35, 48]. Vector similarity search is a critical component in such applications as it enables more accurate and contextualized search [28, 33, 34, 56] and recommendations [46, 47, 51, 53, 62] over multi-modal data. Partitioned indexes for vector similarity search have recently gained widespread adoption in these modern machine learning applications due to their performance and scalability [29, 38, 49, 66, 69, 71]. A common type of partitioned index is the Inverted File (IVF) index, where a vector quantization algorithm (typically k-means) is used to partition a vector dataset, and the resulting clusters constitute the partitions of the index [40]. While existing IVF index implementations are designed for static workloads, i.e., the partitioning is performed based on the initial state of the underlying vector dataset, real-world deployments require high-throughput search and updates over dynamic vector data where the underlying vector dataset is continuously modified through insertions and deletions [15, 58, 69]. In addition to being robust against modifications to the vector dataset, the indexes must be robust against changing query patterns over time, as observed in [15]. In this work, we study the effect of updates on the IVF index's search and update throughput and propose an incremental maintenance methodology for IVF indexes.\nIVF indexes out-of-the-box do not have the notion of inserting new vectors or deleting existing vectors once constructed. Indeed, the most common method used by practitioners today is to rebuild the index from scratch to reflect any updates that have accumulated over time. However, depending on the scale of the vector dataset and the volume and frequency of updates, a full index rebuild can be prohibitively expensive. For example, it takes multiple days to rebuild an IVF index from scratch for billion-scale vector datasets [21, 69], making it necessary to revisit how updates can be reflected. Devising such an update mechanism consists of re-adjusting the partitioning of the high-dimensional space defined by the clusters and ensuring that the re-adjusted partitioning: (i) keeps the reconstruction error, i.e., the average distance between a vector and its nearest cluster centroid, at minimum, otherwise, queries would require scanning more partitions to reach a target recall and degrades search throughput; (ii) does not create an imbalance in the size distribution of the partitions, which can result in variable search latency across queries [15, 39, 69].\nIn industrial vector search workloads, we observe that the partition access patterns of search and update operations over an IVF index are non-uniform and change over time. For instance, in a typical day of a KG entity search workload we studied [36, 49], we find that only 15% of partitions were accessed during search operations, and 80% of the updates affected partitions that were not accessed by any search operation. Such skewed access patterns induced by real-world vector search workloads present an oppor-tunity for efficient and effective maintenance of IVF indexes over dynamic datasets. Specifically, index maintenance overhead can be minimized by devising a local, incremental indexing strategy and focusing the maintenance process on frequently accessed par-titions during search. To the best of our knowledge, no existing approaches in the literature utilize partition access patterns for IVF index maintenance.\nTo this end, we propose Ada-IVF, an incremental maintenance mechanism for IVF indexes. Our approach is based on (i) the observation that reconstruction error and partition imbalance serve as indicators of an IVF index's search quality and performance (Section 2.2), and (ii) workload patterns can be utilized for local, incremental maintenance of its underlying partitions (Section 2.3). Ada-IVF con-sists of a workload-adaptive policy that identifies which partitions"}, {"title": "2 PRELIMINARIES & MOTIVATION", "content": "We now define the streaming vector search problem. We also provide a brief overview of IVF indexes, their use of vector search, and existing methods for supporting updates. Finally, we discuss our observations on the characteristics of streaming vector search workloads and their impacts on the IVF index performance, which motivate the incremental indexing strategy introduced in this paper."}, {"title": "2.1 Vector Search & Data Updates", "content": "Streaming vector search [9, 58] is the process of finding the top-k nearest neighbors of a d-dimensional query vector q in an evolving set of d-dimensional vectors X. We consider the following operations over the set of vectors X:\n\u2022 Insertion: Adding a new vector x to the set X, making X = X U {x}.\n\u2022 Deletion: Removing an existing vector x \u2208 X from the set, resulting in = X \\ {x}.\n\u2022 Search: Find the top-k nearest neighbors to q in X according to a similarity metric.\nObtaining the exact top-k nearest neighbors of a query vector q in X is prohibitively expensive if |X| is large. In practice, approximate nearest neighbor (ANN) search methods that leverage indexes are used, providing a trade-off between accuracy and performance. Search accuracy is most commonly measured using recall, defined as  r = \\frac{|G \\cap R|}{k} , where R is the set of ids returned from approximate search and G is the set of ground truth ids obtained by a linear scan. Performance, on the other hand, is most generally measured as the number of queries processed per second (QPS). Indexes for ANN search need to be updated otherwise performance can deteriorate with respect to a fixed recall target.\nA streaming vector search workload is an ordered set of search and update operations over the set of vectors X. As defined above, search operations correspond to finding k-nearest neighbors of a query vector over the current state of X, and update operations modify set X. These operations can be batched, searching, or updating multiple vectors at a time."}, {"title": "2.2 IVF Indexes", "content": "An IVF index is a partitioned data structure for high-dimensional vector search that consists of nc partitions (clusters) and their representative vectors (centroids). An IVF index over a vector dataset X is constructed offline using a vector quantizer, typically a variant of k-means [21, 39]; consequently, the index construction process requires a global view of the underlying vector dataset X. Clustering-based partitioning of the dataset enables similar vectors (based on the embedding distance) to be assigned to the same partition. At search time, such partitioning is utilized to reduce the number of distance computations performed; the distance from the query vector q to each cluster centroid is computed to identify np nearest partitions, and each of the p partitions is scanned to obtain the approximate k-nearest neighbors. By controlling the subset partitions scanned for each query, np provides a way to navigate the trade-off between quality and performance.\nThe primary indicators of IVF index search performance are i) partition imbalance and ii) reconstruction error. Partition imbalance refers to the uneven size distribution of partitions, and it adversely affects the search throughput as queries will take longer to scan overpopulated partitions. A common strategy to mitigate partition imbalance during index construction is to use balanced k-means, which can produce roughly equal-sized partitions so that latency is consistent across queries for a given np [69]. The reconstruction error is the average distance from each vector to its nearest centroid, and the objective function of the quantization algorithm minimizes the error. Numerous works have been proposed to minimize the reconstruction error of static vector search indexes [13, 25, 67]. Indexes with a larger reconstruction error have less compact clusters and require queries to scan more partitions to find their nearest"}, {"title": "2.3 Impact of Updates on IVF Indexes", "content": "Here, we motivate Ada-IVF and its incremental maintenance method-ology by discussing the characteristics of vector search workloads and the impact of updates on existing IVF index maintenance strate-gies. First, we show how partition imbalance and reconstruction error are impacted by simple baseline strategies such as Frozen, which does not change the clustering. Second, we measure partition access patterns of an industrial search workload to show the skew in read and write access patterns of real-world workloads. Finally, we show how the state-of-the-art incremental IVF index-ing approach, LIRE, incurs unnecessary maintenance overhead by over-triggering reindexing for rarely accessed partitions.\nFigure 2 demonstrates the relationship between the search per-formance and partition imbalance by showing the query throughput"}, {"title": "3 ADA-IVF OVERVIEW", "content": "We introduce Ada-IVF, an incremental maintenance solution for IVF indexes. Figure 6 depicts the high-level overview of our in-cremental reindexing solution. In brief, Ada-IVF maintains robust search performance in the face of updates by selectively reindexing a subset of partitions that negatively contribute to the partition imbalance and reconstruction error, proxies for index performance, as discussed in the previous section. Ada-IVF has the following steps:\n\u2022 Step 1: Maintain index metadata. Ada-IVF maintains the size, centroid, and read temperature of partitions. Where the temperature denotes the frequency and recency of reads for a given partition. Search operations modify the temperature (S), and update operations modify the partition contents, size, and centroid (U, A, B).\n\u2022 Step 2: Monitor index partitions for increases in imbalance and reconstruction error. Partitions are assigned a reindexing score (C), which is a function of imbalance and reconstruction error, a higher score indicating higher im-balance/error. Partitions exceeding a score threshold of tf are violators (e.g., Partition 1).\n\u2022 Step 3: Reindex violating partitions using local reindexing. Violating partitions are split and merged with neighboring partitions (D) to minimize imbalance and reconstruction error."}, {"title": "4 INDEX QUALITY MAINTENANCE", "content": "This section describes the details of Ada-IVF's incremental index maintenance. Beginning with the update rules for index metadata, covering local reindexing, and concluding with global reindexing."}, {"title": "4.1 Tracking Index Properties", "content": "To identify the subset of partitions that cause degradation in query throughput, it is necessary to track how the underlying clustering properties evolve over time. For this purpose, we maintain the set of vectors that are present in each partition (Xi) and the corresponding mean of the vectors (\u03bc\u2081) for each partition. These are used to"}, {"title": "4.2 Local Reindexing", "content": "Next, we introduce Ada-IVF's local indicator function f, which is used to identify partitions that should be considered as candi-dates for reindexing and describe its local reindexing algorithm for addressing the increase in imbalance and reconstruction error without rebuilding the entire index from scratch."}, {"title": "4.2.1 Local Indicator Function f.", "content": "The local indicator function (f) quantifies the deviation from a partition's original state w.r.t. imbalance and reconstruction error, determining when a local reindexing operation should be triggered. This function is evaluated for a single partition upon modification of the partition. The indicator function captures changes in the partition's size and mean over time, and the partition temperature is used as a scaling factor. If the value of f for a given partition exceeds a threshold, the partition is denoted as a violator and is selected for reclustering. Deviations in partition size introduce imbalance in the index, while change in the partition mean is a proxy for increasing reconstruction error.\nPartition temperature is used to determine the severity of devia-tions; degradations in a partition with a high temperature have a significant impact on the overall query throughput for a workload because more queries access that partition. Therefore, we should more aggressively select highly accessed partitions for reindexing. Conversely, a partition with a low temperature (i.e., rarely or never"}, {"title": "Temperature Scaling Function fr.", "content": "The function fr aims to capture how frequently we should re-index a partition based on the temperature T of the partition. Thus, if the temperature is high, it should have a larger score, and vice-versa for low temperature. Thus, we use a linear function parameterized by a scale factor a\n fr (T) = \u03b1\u03a4"}, {"title": "Local Size Imbalance Function fs.", "content": "The function fs captures if a partition has grown too large or small. Thus, denoting ts as the target partition size, we define fs as:\n fs (s, ts) ={\n(sts)/ts, if s\u2265 ts\\(Ts-s)/s, if s < Ts\n}"}, {"title": "Local Drift Function fa.", "content": "The function fa captures if a partition c has drifted from its initial state co, which is a proxy for increasing reconstruction error. We quantify drift by measuring the relative change in partition mean u from initial \u03bc\u03bf.\n fa = ||(\u03bc \u2013 \u03bc\u03bf)|||/||\u03bc\u03bf||"}, {"title": "4.2.2 Local Reindexing Algorithm.", "content": "Local reindexing consists of three phases: i) splitting and deleting of violating partitions, ii) finding the nearest partitions to the violating partitions, and iii) applying k-means to the vectors of the violating partitions and their neighbors (Algorithm 4). Partitions are selected as violators if the value of their indicator function f exceeds the threshold tf. If the size of the violating partition exceeds the target partition size ts, it is split using k-means (Lines 4-6). Otherwise, it is deleted (Line"}, {"title": "4.3 Global Reindexing", "content": "While Ada-IVFs local reindexing mechanism can handle deviations in individual partitions when updates and their impact on parti-tions exhibit locality, it is possible to observe deviations in a large number of partitions or overall index quality that might render local, partition-specific maintenance ineffective. It is necessary for Ada-IVF to identify such an index state and perform a full index rebuild. Here, we describe the global indicator function G that we use to determine when to reconstruct the index from scratch instead of performing local reindexing. Similar to local reindexing, we use a global indicator function to quantify deviations in the overall clustering and construct a new index over the current state of X.\nThe global indicator function G is a function of the current reconstruction error & of the clustering, the partition size standard deviation \u03c3, and the estimated reconstruction error \u03b5', the estima-tion of the reconstruction error of k-means clustering if a full index rebuild were to occur over the current set of vectors."}, {"title": "G(\u03b5, \u03c3, \u03b5\u0384) = \u03b3Gs (\u03c3) + (1 \u2212 \u03b3)Ge(\u03b5, \u03b5\u0384) \u2264 TG", "content": "(5)\nThe individual functions Gs, Ge capture the contribution of the size imbalance and reconstruction error, and y controls their relative contribution; TG is a tunable threshold."}, {"title": "Global Imbalance Function Gs.", "content": "We use the relative change in the standard deviation of partition sizes to estimate the increase in global imbalance. Intuitively, the standard deviation in partition size indicates how imbalanced the partitions are with respect to a balanced partitioning. The change in standard deviation captures if the imbalance has increased due to updates performed on the index.\n Gs = |\u03c3 - \u03c3\u03bf\u03b9/\u03c3\u03bf"}, {"title": "Global Reconstruction Error Function Ge.", "content": "As a part of the global reindexing mechanism, we aim to trigger a rebuild if the global reconstruction error grows high. We propose doing this by estimat-ing the projected improvement in reconstruction error that can be achieved if we perform a full index rebuild. Thus, we define Go as the relative difference between the current observed error & and an ideal error \u03b5'. We define ideal error as the error that would be measured if a full index rebuild were performed, i.e., if k-means were to be applied over the current set of vectors. In other words, if the error of the index deviates far enough from the estimated ideal error, then a rebuild should be performed to recover performance. However, estimating the ideal reconstruction error is challenging and we next describe our approach to address this challenge."}, {"title": "Go = |\u03b5 \u2013 \u03b5'\u03b5'", "content": "(7)"}, {"title": "Estimating e'.", "content": "An IVF Index can be viewed as a vector quantiza-tion scheme, where groups of vectors (clusters) are represented by a representative encoding (centroid). It is proven that k-means clustering produces an empirically optimal quantizer [55] with error \u03b5'. There are well-defined bounds [16] on the difference between the error of an empirically optimal quantizer &' and an optimal quantizer &*, where the constant A is a data-dependent parameter."}, {"title": "\u03b5\u2032 \u2212 \u03b5* < A", "content": "\u2264(8)\nSimilarly, assuming that the initial state of the clustering is em-pirically optimal, we can derive a bound on its reconstruction error."}, {"title": "Combining 8 and 9 gives", "content": "(10)\nWe make the assumption that  (* - *dno) is negligible and\nachieve the final estimate."}, {"title": "We empirically validate the estimate in Figures 8 and 9.", "content": "Our experiments show that our estimate is within 2.5% and 1% of the true error of a rebuild for Sift1M and Glove1M vector datasets, respectively."}, {"title": "5 EXPERIMENTS", "content": "We evaluate Ada-IVF by using a variety of benchmark workloads against state-of-the-art techniques for IVF index maintenance. We begin with an end-to-end performance analysis on an internal workload trace and the BigANN-SS public benchmark (Section 5.2). We then present an extensive sensitivity analysis to demonstrate the robustness of Ada-IVF compared to baselines across various workload scenarios. To do this, we developed a tool that generates workloads from a given vector dataset with varied read and write properties (Section 5.3). Finally, we present results from a set of microbenchmarks that validate our contributions (Section 5.4).\nExperimental Highlights\n\u2022 On an internal recommendation workload, Ada-IVF reduces the update time to 62% of that of LIRE with a 9% improve-ment in QPS.\n\u2022 For the public BIGANN-SS benchmark, Ada-IVF reduces the update time by 50% and matches the same QPS as LIRE."}, {"title": "5.1 Experimental Setup", "content": "5.1.1 Workloads. Internal is a real-world, industrial workload for an online recommendation application where both the updates to the index and the queries are processed in a streaming fashion. This read-heavy workload exhibits significant write locality as each batch of updates primarily targets a specific partition. We execute this workload using access properties derived from real-world data using MSTuring10m as the underlying vector dataset.\nWe also use BigANN-SS, a batch public streaming benchmark that is developed as part of the Neurips'23 BigANN competition. BigANN-SS uses a 30M subset of the MSTuring dataset, and its workload consists of batch inserts and delete,s where each batch is based on a cluster of the original dataset. By inserting and deleting based on partitions, BigANN-SS's workload exhibits update locality. The inserts and deletes vary in size between 10-250k. After each update, the same set of 10k queries are evaluated in bulk with a target recall of 0.9.\n5.1.2 Workload Generator. We use a configurable workload gener-ator that can simulate a variety of settings on any vector dataset. Using such a generator helps us evaluate the sensitivity and robust-ness of Ada-IVF and its components on public vector datasets. Given a vector dataset and workload parameters, the generator clusters the dataset and samples from the clusters to produce inserts, deletes, and queries. The six primary parameters of the generator are (i) the initial size so, (ii) the update size su, (iii) the insert/delete ratio rid, (iv) the update cluster sample fraction CSFu, (v) the read/write ratio rrw and (vi) the query cluster sample fraction CSFq, which is optional if queries are provided with the dataset. The update and query sample fractions allow for configuring the locality of updates and queries by controlling the fraction of vectors sampled from a given cluster to produce the update/query. With CSF=1.0, an entire cluster of vectors is sampled for an insert/delete; therefore, the update is highly localized. A small CSF (e.g., CSF=.001) corre-sponds to a less localized update, as vectors are sampled from many clusters across the vector space."}, {"title": "5.1.3 Baselines.", "content": "We compare Ada-IVF's performance against the following standard and state-of-the-art maintenance strategies that are employed in existing systems for handling updates in IVF In-dexes (Section 2). Ada-IVF's configurable indicator functions and flexible reindexing manager allow us to implement these algorith-mic baselines in our system easily. This ensures that the system overheads are the same for all strategies. For ease of explanation, queries are serially executed in a synchronous fashion for all ap-proaches and workloads.\n\u2022 Frozen: Does no maintenance.\n\u2022 Update [11, 15]: Updates centroids on partition modification to reflect the true mean of the partition.\n\u2022 Rebuild [66]: Periodically rebuilds the index.\n\u2022 LIRE [69]: Performs splitting and merging of partitions if a target size is violated. After splitting and merging, vector reassignment of neighboring partitions is performed. LIRE is implemented within Ada-IVF with the corresponding parameters tf = 0, 1 = 0, and \u03b2 = 1.0."}, {"title": "5.2 Industrial and Benchmark Workloads", "content": "Table 3 shows the search and update throughput on Internal and BigANN-SS of Ada-IVF and baselines relative to Rebuild, which is optimal for search throughput. Below, we detail each workload.\nBigANN-SS. Figure 10 shows the workload trace for the BigANN-SS benchmark. In this workload, a series of inserts and deletes are performed, which grow and shrink the set of vectors in the index over time. First, looking at the search QPS (top figure), we observe that Frozen and Update achieve 3.5\u00d7 and 1.9\u00d7 less QPS than Rebuild, while LIRE and Ada-IVF can achieve similar QPS. We attribute this to the re-balancing mechanisms applied by both methods. There is still a gap between the QPS of Ada-IVF and Rebuild, suggesting room for improvement. The middle figure shows the cumulative update time over the workload normalized by Rebuild's update time. Frozen and Update achieve the lowest update times as they have minimal overhead. LIRE and Ada-IVF obtain an update throughput of 4.7\u00d7 and 10.0\u00d7 relative to Rebuild, resulting in a lower total update time. Ada-IVF achieves a high update throughput due to the indicator function it employs, as it is not as aggressive in selecting partitions for reindexing. This can be observed in the bottom figure, which shows the number of partitions over time. The number of partitions varies significantly for LIRE, while Ada-IVF remains more stable throughout the workload. Overall, Ada-IVF achieves a 2\u00d7 higher update throughput over LIRE while matching query throughput. Compared to Rebuild, it achieves 10\u00d7 higher update throughput with 85% of the search throughput.\nInternal Workload. Table 3 shows the search and update through-put for Internal. We see that Frozen and Update perform relatively well, showing an order of magnitude higher update time compared to Rebuild with only a .81\u00d7 and .84\u00d7 reduction in QPS for Frozen and Update, respectively. We attribute the good performance of the Frozen and Update to the large initial size of the workload. Unlike BigANN-SS, Internal starts with a significantly larger set of vectors, and Frozen and Update obtain a more representative initial cluster-ing of the data points. LIRE achieves a similar QPS as Frozen with 4.7\u00d7 higher update throughput than Rebuild. Ada-IVF achieves a higher QPS than baseline methods with .89\u00d7 QPS with a further 1.6\u00d7 improvement in update throughput over LIRE."}, {"title": "5.3 Sensitivity Analysis", "content": "To demonstrate the robustness of Ada-IVF to a variety of workload scenarios, we conduct a sensitivity analysis of Ada-IVF and base-lines update methodologies using a workload generator. For each experiment, we vary a single generator parameter while keeping the rest fixed, as discussed in 5.1.2.\nInsert/Delete Ratio. First, we vary the insert/delete ratio, which determines the index's rate of growth. We see that Ada-IVF matches the query performance of LIRE with a slight improvement in update time as the ratio increases. We also observe a general decrease in update and query throughput as the ratio increases. This is due to the growing dataset size for positive ratios.\nUpdate Locality. Here, we vary the cluster sample fraction (CSF) used to generate inserts and deletes. This controls the locality of up-dates (5.1.2). Figure 11b shows the query and update throughput for Ada-IVF and baseline methods. Ada-IVF consistently matches the QPS of a Rebuild across all sample fractions, while other methods"}, {"title": "5.4 Microbenchmarks", "content": "We now evaluate individual components of our design in further detail using a synthetic SIFT1M workload with rid = 1. We first evaluate the effect of indicator function parameters by performing a comprehensive parameter sweep of Ada-IVF parameters. We then perform a similar parameter scan to evaluate the effect of varying the local reindexing mechanism parameters. We then evaluate the effect of batching updates."}, {"title": "6 DISCUSSION", "content": "We outline extensions of our method to Product Quantization and hierarchical IVF indexes, and then we discuss related work."}, {"title": "6.1 Extensions", "content": "The IVF index maintenance techniques introduced in this work apply to single-level IVF indexes, but we believe they are applica-ble to any type of index based on vector quantization. Below, we discuss extensions of our index maintenance technique to two com-monly used indexes: Product Quantization [40] and Hierarchical IVF indexes [59].\nProduct Quantization (PQ) encodes a d-dimensional vector into a d'-dimensional code vector using d' codebooks. Codebooks are ob-tained by KMeans to cluster d' subspaces of the vector distribution. Product quantization is generally used for lossy vector compression [40] and is a commonly used technique in ANN index design [66]. In a dynamic setting where new vectors are added, and existing vectors are deleted, the quality of the codebook trained on the initial vector dataset decreases. This eventually necessitates an expensive codebook rebuild and re-encoding of vectors to recover index qual-ity. In contrast with IVF indexes, imbalance does not negatively affect query performance, as the only objective is to minimize the quantization error of the encoding. Hence, when applied in this setting, our indicator functions (Section 4) should only consider the error term (\u03b2 = 0, y = 0). However, a significant challenge with applying our method to PQ quantization is that, typically, there are few clusters in a given codebook. For example, it's common to use 8-bit codes corresponding to a total of 255 centroids in each codebook [40], meaning that a modest reindexing radius of 25 will recluster 10% of the data if a single cluster violates the indicator function. Therefore, local reindexing is more applicable to cases where larger codes (e.g., 16-bit codes, 65k centroids) are used. There exists some work that studies the impact of updates in the context of product quantization [45, 68]. Future study is required to as-sess the performance implications of using Ada-IVF's maintenance technique over product quantization codebooks.\nHierarchical IVF indexes [59] efficiently scale to large data sizes by maintaining a hierarchical KMeans clustering. In a basic two-level structure, vectors are grouped into fine-grained clusters whose centroids are further aggregated into coarse clusters. Changes to underlying vectors necessitate reindexing these fine clusters, im-pacting the coarse-level structure by centroid updates. We can extend our single-level methodology in Ada-IVF by using an inde-pendent update manager for each hierarchy level. This ensures that any changes in the fine-grained centroids have a limited effect on the quality of the coarse-grained clustering. Utilizing this approach, we can extend our method to maintain hierarchical IVF indexes.\nWe reserve the study of streaming workloads and approaches for handling updates on other types of indexes for future work."}, {"title": "6.2 Related Work", "content": "Vector Indexes. Indexes for vector search predominately fall un-der two categories: partitioned and graph indexes. IVF indexes are the most prominent type of partitioned index with a multitude of variants [12, 14, 21, 29, 41, 66]. IVFADC [41] pairs IVF indexes with Product Quantization (PQ). SCANN uses a hierarchical IVF index and PQ and includes optimizations for Maximum Inner Product Search (MIPS). [29, 59]. SPANN [21] replicates vectors across partitions and includes a graph index over the centroids to accelerate centroid scans. Hash-based [26, 37, 61], learned [10, 30, 31, 43], and"}, {"title": "7 CONCLUSION", "content": "We introduced Ada-IVF, an incremental methodology for maintain-ing IVF index performance for dynamic workloads. Ada-IVF uses local and global indicator functions that determine which clusters need to be reindexed using local reindexing. We evaluated our ap-proach across a variety of benchmarks and found that compared with the state-of-the-art dynamic IVF index maintenance strategy, Ada-IVF achieves an average of 2x and up to 5x higher update throughput while matching query throughput across a range of benchmark workloads."}]}