{"title": "FuzzWiz - Fuzzing Framework for Efficient Hardware Coverage", "authors": ["Deepak Narayan Gadde", "Aman Kumar", "Djones Lettnin", "Sebastian Simon"], "abstract": "Ever-increasing design complexity of System-on-Chips (SoCs) led to significant verification challenges. Unlike software, bugs in hardware design are vigorous and eternal i.e., once the hardware is fabricated, it cannot be repaired with any patch. Despite being one of the powerful techniques used in verification, the dynamic random approach cannot give confidence to complex Register Transfer Level (RTL) designs during the pre-silicon design phase. In particular, achieving coverage targets and exposing bugs is a complicated task with random simulations. In this paper, we leverage an existing testing solution available in the software world known as fuzzing and apply it to hardware verification in order to achieve coverage targets in quick time. We created an automated hardware fuzzing framework Fuzz Wiz using metamodeling and Python to achieve coverage goals faster. It includes parsing the RTL design module, converting it into C/C++ models, creating generic testbench with assertions, fuzzer-specific compilation, linking, and fuzzing. Furthermore, it is configurable and provides the debug flow if any crash is detected during the fuzzing process. The proposed framework is applied on four IP blocks from Google's OpenTitan chip with various fuzzing engines to show its scalability and compatibility. Our benchmarking results show that we could achieve around 90% of the coverage 10 times faster than traditional simulation regression based approach.", "sections": [{"title": "I. INTRODUCTION", "content": "Design verification has become the bottleneck with the increasing complexity of SoCs, accounting for more than 60% of the total project time [1]. The simulation-based verification is the strongest method in verification and it entails simulating a Design Under Verification (DUV) with valid input sequences and evaluating the DUV's behavior during or after simulation to discover bugs in the design [2]. Constrained Random Verification (CRV) is one of the most widely used methodologies, it creates test scenarios by randomizing input sequences. Although successful in identifying RTL design bugs, this method falls short in thoroughly exploring the state space of the design due to the phenomenon of time-space explosion. Additionally, Coverage Directed Test Generation (CDG) is another renowned dynamic method which is deployed in both software testing and hardware verification. In this technique, coverage metrics from the present simulation are used to drive the generation of inputs for subsequent simulations. Over the last two decades, numerous solutions have been proposed for CDG. However, effectiveness of the test generation depends on the structure of the DUV, the coverage criterion, and input space. The generated tests still miss a large number of potentially severe bugs [3]. Regression of these test simulations often require longer turnaround time to reach sensible coverage metrics [4]. Hence, researchers are still in search for an efficient solution to reduce these turnaround times and to improve verification throughput.\nFew of those solutions include the coverage-guided fuzzing technique which is used widely in software testing for security assessment and to achieve efficient coverage of the program under test. Several studies on fuzzing in hardware verification have been conducted in recent years to address the CDG problem [5]. These studies, while yielding positive outcomes, have certain limitations in terms of Hardware Description Language (HDL) used for RTL implementation, type of coverage feedback, and the fuzzing engine used (Sec. III). This caught our attention and motivated us to create an automated framework to perform hardware fuzzing.\nOur contributions to this work are sketched as follows:\n\u2022 Automated fuzzing framework using Python and metamodel - Fuzz Wiz (Sec. IV)\n\u2022 Metamodeling code generation framework to produce fuzzer specific testbench - MetaFuzz (Sec. IV-D)\n\u2022 Benchmarking different fuzzing engines based on their performance on OpenTitan IP cores [6] in terms of coverage (Sec. V)"}, {"title": "II. BACKGROUND", "content": "In this section, we provide the basis for the fuzzing technique and corresponding tools used for it i.e., fuzzers together with an introduction to the metamodel framework.\n\nThe fundamental process of coverage-guided fuzzing is shown in Fig. 1 which includes input generation and mutation, test execution, error detection, analysis, and a feedback loop [7]. These steps repeat in a systematic manner to uncover vulnerabilities in the target system by covering most of the input combinations. It continuously monitors and analyzes the code coverage achieved during testing, prioritizing inputs that lead to unexplored or less-covered code paths within the target application. By doing so, it maximizes the chances of identifying critical security flaws, crashes, or unexpected behaviors [8]. This feedback-driven methodology has proven to be most valuable and has helped in achieving the target coverage and detecting crashes in software [9]."}, {"title": "III. RELATED WORK", "content": "All relevant prior works on fuzzing the hardware designs are discussed in this section. RFUZZ [13] was an early endeavor that performed coverage-directed mutational fuzzing directly on HDL, employing mux toggle coverage to steer the process and showing promising results across various RTL designs. [10] proposed a design-agnostic technique to convert HDL code into software binaries, enabling the use of the American Fuzzy Lop (AFL) fuzzer for hardware design. This method, complemented with generic interfaces and binary instrumentation for tracing hardware coverage in software, achieved substantial HDL code coverage on OpenTitan IP designs. DirectFuzz [22] introduced targeted gray-box fuzzing, producing test inputs aimed at specific RTL module instances, and delivered faster coverage compared to RFUZZ. Other works such as DIFUZZRTL [23], focused on register-coverage guidance to unearth CPU bugs in RTL designs. And ProcessorFuzz [24], which utilized a novel Control and Status Register (CSR)-transition coverage metric to monitor processor state changes, proved more efficient in bug detection than previous methods.\nMost of the research [13], [23], [24] discussed earlier used specific metrics such as mux toggle, CSR-transition, or register coverage, to guide the fuzzing technique and various fuzzing tools. It is questionable how their specific coverage metrics relate to traditional RTL code or functional coverage which are needed to ensure that the DUV is verified. Moreover, some of the prior works [13] could not be applied on any generic RTL design. Although one cannot completely guarantee the flawless condition of a system due to the random and unpredictable behavior of fuzzers, their capability for automation provides great potential to be a valuable supplement to the existing verification methods.\nIn our work, we developed an automation framework which takes the generic RTL design(s) as an input and performs fuzzing to improve the overall HDL coverage with flexibility to choose which fuzzing engine should be applied. Some of the work from [10] is reused in this work to perform a statistical comparison of our coverage results."}, {"title": "IV. PROPOSED FUZZING FRAMEWORK", "content": "This section presents the proposed fuzzing framework FuzzWiz as shown in Fig. 3. The main steps involved in the FuzzWiz framework are demonstrated with a simple RTL module given in Listing 1. This design has a register intended for the secure storage of cryptographic keys with an additional debug feature. Consider a critical security requirement here that the keys must remain inaccessible during debug mode to prevent unauthorized access."}, {"title": "A. Configuration of the framework", "content": "A hjson file is used for configuring the Fuzz Wiz framework which contains attributes, the preferred fuzzing engine, and the duration to perform the fuzzing process. These values are updated by the user based on their preferred fuzzing engine and on how long the RTL code should be fuzzed.\nFor demonstration, FuzzWiz is configured to run fuzzing on the example design (Listing 1) for one hour using the Fairfuzz engine to reach efficient hardware coverage."}, {"title": "B. Generation of software models", "content": "Most open-source simulators initially transform the hardware RTL into software representations, typically in the form of C or C++ models, prior to conducting simulations. To facilitate fuzzing of hardware designs, this software model is intercepted and used by fuzzer. In our FuzzWiz framework, we employ Verilator [25] for the conversion of RTL files into equivalent C++ files."}, {"title": "C. Extraction of specification from the RTL", "content": "All the primary ports of DUV, along with the other data such as direction of the ports, size and type of ports, and top module name are extracted using an RTL parser. This information is used to create a formalized specification in XML format."}, {"title": "D. Creation of generic testbench", "content": "The formalized specification is transferred to the Template of Testbench (ToTB) within the intermediary MetaFuzz layer. The ToTB, which is based on Python, is responsible for the extraction of design details from the specification and the subsequent definition of MetaFuzz models for each necessary testbench file. Following this, the view layer of MetaFuzz is responsible for mapping these models onto a specific language, such as SystemVerilog or C++. This mapping facilitates the generation of a generic testbench in SystemVerilog and fuzzer-specific files in C++, tailored to the given RTL. For example, the testbench in Listing 2 is generated using metamodel MetaFuzz for the design in Listing 1."}, {"title": "E. Generation of a HSB", "content": "Before initiating the fuzzing process, the converted software C++ models are instrumented using a specific compiler depending on the chosen fuzzing engine. All the five fuzzers used in this work offer their own compiler variant. These specialized compilers perform source code instrumentation to enhance the fuzzing technique. The instrumented files in conjunction with the SystemVerilog testbench files are linked to generate a Hardware Simulation Binary (HSB)."}, {"title": "F. Fuzzing and visualization of coverage output", "content": "The generated HSB will be fuzzed by the selected fuzzing engine for a certain duration depending on the framework configuration. After the fuzzing process, coverage details are extracted individually for each testcase generated by the fuzzer. Open-source tools such as kcov [26], LLVM [27], and Verilator [25] are integrated in Fuzz Wiz and are used to trace and merge various coverage data such as software line, block, and hardware line coverage respectively. Subsequently, the collected data is used by Python automation scripts to create CSV files for the specific coverage type and to plot graphs. This paper focuses on results related to hardware line coverage."}, {"title": "G. RTL debug flow", "content": "The inputs that resulted in a software crash during the fuzzing process are recorded for RTL debugging purposes. The Metamodel MetaFuzz generates a SystemVerilog testbench containing the input sequence that caused the crash. With the aid of any hardware simulator, this testbench can simulate the DUV and provide a waveform that can be utilized for finding the root cause for a software crash at RTL level.\nFor instance, one of the crashes during the fuzzing of the DUV (Listing 1) is analyzed as follows: After resetting the DUV, the testbench receives input stimuli (i.e., debug_mode) from the fuzzer. When debug_mode is 0x1, the first assertion fails as the stored key 0x0000BADE0000ACEC is observed at the output pin. This assertion failure is recorded as a crash, the corresponding inputs are also captured. A testbench is generated using metamodeling with these inputs to run a RTL simulation as shown in Fig. 4"}, {"title": "V. RESULTS AND DISCUSSION", "content": "With our FuzzWiz framework, we were able to fuzz any hardware design written in most widely used HDLs such as VHDL, Verilog, and SystemVerilog. We evaluated this framework on multiple proprietary designs along with open-source ones."}, {"title": "A. Designs under verification", "content": "To show the significance and compatibility of Fuzz Wiz, four Intellectual Property (IP) cores from Google's OpenTitan [6] project were selected as DUVs and are given below.\n\u2022 Advanced Encryption Standard (AES)\n\u2022 Keccak Message Authentication Code (KMAC)\n\u2022 Hash-based Message Authentication Code (HMAC)\n\u2022 RISC-V Timer (RV-Timer)\nThese IPs play critical roles in security and system timing functions of the OpenTitan chip. AES is crucial for data encryption and offers high-level security for various block sizes. KMAC extends this security to message authentication and leverages Keccak sponge construction for adaptability. HMAC uses SHA-256 as a hash function, and is crucial for maintaining data integrity in communication by authenticating messages. Lastly, RV-Timer maintains system integrity with precise timing in RISC-V architectures. These cores were chosen because they represent fundamental components in cryptographic operations, system control, and longer time to reach coverage targets making them vital for benchmarking the efficacy of various fuzzing engines and their mutation strategies."}, {"title": "B. Results and discussion", "content": "In an industrial setup, design verification engineers run simulation regressions with random seeds over a certain period of time, for instance around 10 hours. After the regression completes, the generated results such as coverage metrics are further analyzed. Hence, we fuzzed the previously discussed DUVs multiple times for 10 hours to get meaningful results. The graphs represented in Fig. 5 are generated using the best coverage results produced by each of those engines. From these results, it is evident that Fairfuzz attained the highest hardware line coverage of around 90% for two out of four design IPs i.e., HMAC and RV-Timer as shown in Fig. 5c and Fig. 5d respectively. This is primarily due to the input mutation strategy used by Fairfuzz, with which it automatically prioritizes inputs exercising rare parts of the program under verification. But for AES and KMAC designs AFL++ fuzzer was predominant to reach a better coverage than Fairfuzz in the same given time of 10 hours. This could be observed in Fig. 5a and Fig. 5b.\nAs the fuzzing progresses, it is observed from all the graphs shown in Fig. 5 that the AFL++ fuzzer attains the coverage faster compared to other fuzzers because of its superior instrumentation and integration into Linux kernel module which improved its speed during the fuzzing process. In the course of our experiments, we observed that AFL++ has very little variance on the final coverage results achieved after fuzzing the DUVs multiple times with random seeds. Among all the fuzzers we applied, Perffuzz and Tortoisefuzz achieved comparatively lower coverage in the majority of the designs. These observations reveal that choosing an appropriate fuzzing engine is critical. Additionally, RTL simulations of these IPs take 10 times more runtime than the fuzzing process to reach similar coverage [28] [10]. To show the significance of our framework FuzzWiz, we have compared it with other prior works as shown in Table II. In contrast to previous works, FuzzWiz is design-agnostic and comes with an option to choose which fuzzing engine is to be used. It also provides the testbenches with particular testvector (if there are any crashes during fuzzing process) to enhance the RTL debugging capabilities."}, {"title": "VI. CONCLUSION", "content": "In this paper, we presented an automated framework FuzzWiz that can be used to perform fuzzing on hardware designs in order to reach coverage goals faster. We have applied FuzzWiz on different internal and open-source designs to prove that it is design-agnostic. Unlike prior research, Fuzz Wiz is compatible with various open-source software fuzzing engines. In order to show the importance and interoperability of the framework, it was applied on four IPs from Google's OpenTitan. We explained how hardware fuzzing achieved around 90% of coverage for two out of four DUVs. We emphasized on the importance of choosing the correct fuzzing engine to reach coverage targets faster. We benchmarked the fuzzing engines by running them for 10 hours multiple times. From the results, we observed that Fairfuzz performed better in terms of reaching the"}]}