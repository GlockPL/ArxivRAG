{"title": "Goal-Driven Query Answering over First- and Second-Order Dependencies with Equality", "authors": ["Efthymia Tsamouraa", "Boris Motikb"], "abstract": "Dependencies are logical statements that formally describe a domain of interest. In databases, dependencies are used to express integrity constraints, deal with data incompleteness, or specify transformations between database schemas. In knowledge representation and reasoning, dependencies are sometimes called existential rules, and they are used to describe background knowledge about an application domain. Dependencies are usually expressed in fragments of first-order logic, but second-order dependencies have received considerable attention as well: they support existentially quantified function variables, which are necessary to express composition of certain classes of schema mappings [39, 7] and can generally simplify domain modelling. When second-order dependencies are combined with equality reasoning (i.e., the ability to derive equality statements), the resulting language can express composition of very expressive classes of schema mappings [70, 6].\nQuery answering over data with dependencies plays a central role in most applications of dependencies. The problem is commonly solved by using a suitable variant of the chase algorithm to compute a universal model of the dependencies and the data and thus explicate all knowledge implicit in the dependencies. After this preprocessing step, an arbitrary conjunctive query over the dependencies and the data can be answered by evaluating it the computed universal model. If, however, the query to be answered is fixed and known in advance, computing the universal model is often inefficient as many inferences made during this process can be irrelevant to a given query. In such cases, a goal-driven approach, which avoids drawing unnecessary inferences, promises to be more efficient and thus preferable in practice.\nIn this paper we present what we believe to be the first technique for goal-driven query answering over first- and second-order dependencies with equality reasoning. Our technique transforms the input dependencies so that applying the chase to the output avoids many inferences that are irrelevant to the query. The transformation proceeds in several steps, which comprise the following three novel techniques. First, we present a variant of the singularisation technique by Marnette [60] that is applicable to second-order dependencies and that corrects an incompleteness of a related formulation by ten Cate et al. [74]. Second, we present a relevance analysis technique that can eliminate from the input dependencies that provably do not contribute to query answers. Third, we present a variant of the magic sets algorithm [19] that can handle second-order dependencies with equality reasoning. We also present the results of an extensive empirical evaluation, which show that goal-driven query answering can be orders of magnitude faster than computing the full universal model.", "sections": [{"title": "1. Introduction", "content": "The need to describe a domain of interest using formal statements naturally arises in many areas of databases and knowledge representation. Such descriptions are usually formulated in a suitable fragment of first- or second-order logic, and are, depending on one's perspective and background, called dependencies [20], \u2200\u2203-rules [12], existential rules [69], or Datalog\u2260 [28]. For the sake of consistency, we use the term 'dependency' throughout this paper, but our results apply equally in all of these contexts."}, {"title": "1.1. Background: Dependencies", "content": "Dependencies are used in databases for many different purposes. They are often used to formulate integrity constraints\u2014statements that describe valid database states [38, 32]. They can also be used to complete an incomplete database with missing facts and thus provide richer answers to users' queries [45]. Finally, they have been used extensively in declarative data integration [56, 48, 55] and to specify mappings between database schemas [37] that is, how to transform any database expressed in one schema to a database in another schema. In knowledge representation, it was shown that ontology languages such as EL++ [10] and certain languages of the DL-Lite family [31, 9] can be expressed as dependencies [28]."}, {"title": "1.2. Background: Query Answering over Dependencies", "content": "We have thus far discussed dependency languages only from the point of expressivity; however, another key issue is their ability to support effective query answering over data with dependencies. Given a set of input dependencies, a dataset (i.e., a"}, {"title": "1.3. The Need for Goal-Driven Query Answering", "content": "When terminating chase is used to answer queries, the universal model can be computed once and subsequently used to answer any conjunctive query, which is clearly beneficial in many use cases. However, query answers in practice often rely only on a relatively small portion of the universal model, and moreover universal models sometimes cannot be computed due to their size. Hence, if the query workload is known in advance, computing the chase in full can be inefficient in the sense that many inferences made by the chase algorithm do not contribute to the query answers. This problem is exacerbated if the data changes frequently, so the universal model needs to be recomputed after each change. When dependencies do not contain existential quantifiers (and are thus equivalent to Datalog possible extended with equality), this inefficiency can be mitigated by using an incremental maintenance algorithm that can efficiently update the universal model [58, 68, 66]; however, to the best of our knowledge, no such algorithm is known for general first- and second-order dependencies with equalities.\nTo overcome these drawbacks, in this paper we turn out attention to goal-driven query answering techniques, whose underpinning idea is to start from the query and work backwards through dependencies to identify the relevant inferences. Some of the rewriting techniques mentioned in Section 1.2, such as the query rewriting algorithm for DL-Lite [31] or the piece-based backward chaining [12], can be seen as being goal-driven; however, these are applicable only to syntactically restricted dependency classes that can be insufficiently expressive in certain applications. SLD resolution [53] provides goal-driven query answering for logic programs. Furthermore, the magic sets technique for logic programs [14, 19, 13] optimises the tuple-at-a-time style of processing of SLD resolution. The idea behind the magic sets is to analyse the program's inferences and modify the program so that applying the chase to the transformation resulting simulates backward chaining. This is achieved by introducing auxiliary magic predicates to accumulate the bindings that would be produced during backward chaining, and by using these predicates as guards to restrict the program's rules to the relevant bindings. This idea has been adapted to many contexts, such as finitely recursive programs [30], programs with aggregates [3], disjunctive Datalog programs [4], and Shy dependencies [5].\nAs we argued in Section 1.1, second-order dependencies with equality atoms are necessary to capture many relevant data management and knowledge representation tasks. However, to the best of our knowledge, none of the goal-driven techniques we outlined thus far are applicable to this class of dependencies. A na\u00efve approach might be to explicitly axiomatise equality as an ordinary predicate [40] (see Section 2), and to use the standard magic sets technique for logic programs (possibly containing function symbols) [19]; however, reasoning with the explicit axiomatisation of equality can be very inefficient in practice [67]. Consequently, efficient and practically successful goal-driven query answering over first- and second-oder dependencies with equality remains an open problem."}, {"title": "1.4. Our Contribution", "content": "In this paper, we present what we believe to be the first goal-driven approach to answering queries over first- and second-order dependencies with equality. Our technique takes as input a dataset, a set of dependencies, and a query, and it modifies the dependencies so that applying the chase to the dataset and the transformed dependencies avoid many inferences that are irrelevant to the query. Our technique is inspired by the magic sets variants outlined in Section 1.3, but is considerably more involved. The key technical problem is due to the fact that equality inferences are prolific (i.e., they can affect any predicate in any dependency) and are highly redundant (i.e., the same conclusion is often be derived in many different ways). Both of these issues make the analysis of equality inferences very hard. Our solution is based on the following three main contributions.\nFirst, to facilitate a precise and efficient analysis of equality inferences, we use the singularisation technique by Marnette [60], which axiomatises equality without the congruence axioms [40] and thus avoids a key source of inefficiency in practice [67]. To compensate for the lack of congruence axioms, the dependencies need to be modified too. One can intuitively understand this as 'pruning' redundant inferences from the original dependencies, which in turn allows for an efficient analysis of equality inferences. Marnette [60] introduced singularisation for first-order dependencies, and ten Cate et al. [74] applied this technique to second-order dependencies; however, the result is not complete: in Section 3 we present an example where singularisation by ten Cate et al. [74] does not preserve all query answers. This problem arises because singularisation does not take into account functional reflexivity of equality, which in turn ensures that function variables behave like functions: if we derive that a and b are equal, then we should also ensure that f(a) and f(b) are equal as well. Completeness of singularisation can be easily recovered by axiomatising functional reflexivity, but this prevents chase termination: if f(a) and f(b) are equal, then f(f(a)) and f(f(b)) should be equal as well, and so on ad infinitum. We overcome this by presenting a novel singularisation variant where functional reflexivity is constrained to derive 'just the right' equalities: sufficient to derive all relevant answers, but without necessarily making the universal model infinite.\nWe stress that singularisation is used only to facilitate our transformation: it is 'undone' at the end of our transformation and equality is treated as 'true' equality in the result. In other words, the final chase step (which is likely to be critical to the performance of query answering) does not suffer from any overheads associated with axiomatising equality.\nSecond, we present a relevance analysis technique that can identify and eliminate dependencies for which no conclusion is relevant to the query. Roughly speaking, this technique computes an abstraction of a universal model\u2014that is, a model that contains a homomorphic image of a universal model computed by the chase on the given dataset. This abstraction is then used to perform a backward analysis of the inferences and dependencies that contribute to query answers.\nThird, we present a modification of the magic sets technique for logic programs that we optimised to handle equality more efficiently. Roughly speaking, our technique takes into account the reflexivity, symmetry, and transitivity of equality to reduce the number of rules produced. In particular, a careful handling of reflexivity is essential: an equality of the form t \u2248 t can be derived from any predicate, so the standard magic sets transformation necessarily identifies each dependency in the input. In contrast, if the input dependencies are safe (which intuitively ensures that the conclusions of the dependencies do not depend on the interpretation domain), we show that reflexivity does not need to be taken into account during the magic sets transformation, which usually reduces the number of rules in the output.\nOur three techniques are complementary. In particular, singularisation facilitates the use of the relevance analyses and the magic sets transformation, and neither of the latter two techniques subsumes the other. Thus, all three techniques are required to facilitate efficient goal-driven query answering.\nOur objective was to show that our techniques are practical, but we faced a significant obstacle: whereas we could find suitable first-order benchmarks (e.g., by Benedikt et al. [23]), we are unaware of any publicly available benchmarks that use second-order dependencies with equalities. To overcome this problem, in Section 5 we present a new technique that can randomly generate such benchmarks. Several generators of dependencies and/or datasets have been proposed in practice. For example, iBench [8] can produce dependencies capturing mapping scenarios; furthermore, ToXgene [17] can generate XML data (which can easily be converted into relational form), and WatDiv [2] can generate RDF data. However, to the best of our knowledge, no existing system can generate second-order dependencies. Furthermore, when dependencies and data are generated in isolation (as is usually the case in practice), it is difficult to guarantee a certain level of \u2018reasoning hardness'\u2014that is, there is no guarantee that the dependencies will produce interesting inferences on the generated datasets. To address these issues, our technique randomly generates derivation trees of instantiated dependencies that is, dependencies with variable-free terms of a bounded depth. Then, it systematically replaces certain terms with variables to obtain standard second-order dependencies, and it produces a dataset from the tree leaves. In this way, the resulting dependencies are guaranteed to perform at least the inferences that were considered when the derivation trees were generated, which allows us to control a minimum level of 'reasoning hardness'.\nIn Section 6, we present the results of an extensive evaluation of our techniques on a range of existing and new test scenarios involving first- and second-order dependencies. Our objective was to determine to what extent a query can be answered more efficiently than by using the chase to compute a universal model. Moreover, to isolate the contributions of different techniques, we compared answering the query by relevance analysis only, magic sets only, and with both techniques combined. Our results show that goal-driven query answering can be very effective: on certain scenarios, we were able to answer certain queries orders of magnitude faster than by computing a universal model. Our relevance analysis technique seems to be the main reason behind the"}, {"title": "1.5. Summary of Contributions and Paper Structure", "content": "The results presented in this paper extend our earlier work published at the 2018 AAAI conference [25], and the main novelty can be summarised as follows:\n\u2022 an extension of the singularisation technique by Marnette [60] to second-order dependencies, which corrects the incom-pleteness in the work by ten Cate et al. [74];\n\u2022 an extension of the relevance analysis and magic sets techniques to second-order dependencies;\n\u2022 a generator of second-order dependencies and data that can control the lever of 'reasoning hardness' in more detail;\n\u2022 the first implementation of the chase for second-order dependencies with equality; and\n\u2022 an extensive empirical evaluation showing that our techniques can be effective in practice.\nThe rest of our paper is structured as follows. In Section 2 we recapitulate the well-known definitions, terminology, and notation that we use throughout the paper. In Section 3 we present a running example that illustrates some of the difficulties we need to overcome in our work, and we present a high-level overview of our approach. In Section 4 we present our approach in detail and prove its correctness. In Section 6 we discuss the results of our experimental evaluation. Finally, in Section 7 we recapitulate our main findings and discuss possible avenues for further work."}, {"title": "2. Preliminaries", "content": "We use first-order and second-order logic, as well as logic programming rules in the presentation of our results. To avoid defining each formalism separately, we ground all of them in second-order logic as presented by Enderton [36]. To make this paper self-contained, in the rest of this section we recapitulate the terminology, the notation, and the basic definitions of first- and second-order logic. Next, we recapitulate the definitions of second- and first-order dependencies, and we introduce the problem of query answering. Finally, we recapitulate the notions of logic programming, and we discuss how our definitions relate to the definitions of dependencies commonly used in the literature."}, {"title": "First- and Second-Order Logic: Syntax", "content": "We fix arbitrary, countably infinite, and mutually disjoint sets of constants, individual variables, function symbols, function variables, and predicates. Each function symbol, function variable, and predicate is associated with an nonnegative integer arity. A term is inductively defined as a constant, an individual variable, or an expression of the form f(t1, ..., tn) where t\u2081, ..., tn are terms and f is an n-ary function symbol or an n-ary function variable. An atom is an expression of the form R(t1, ..., tn) where R is an n-ary atom and t\u2081, ..., tn are terms called the atom's arguments. We assume that the set of predicates contains a distinct binary equality predicate \u2248. Atoms of the form \u2248(t1, t2) are typically written as t\u2081 \u2248 t2 and are called equality atoms (or just equalities); moreover, all atoms with a predicate different from \u2248 are called relational. Formulas of second-order logic are constructed as usual using Boolean connectives \u2227, \u2228, and \u00ac, first-order quantifiers \u2203x and \u2200x where x is an individual variable, and second-order quantifiers \u2200f and \u2203f where f is a function variable. As usual, an implication \u03c6 \u2192 \u03c8 abbreviates \u00ac\u03c6 \u2228 \u03c8. A first-order formula is a second-order formula that does not contain function variables. A sentence is a formula with no free (individual or function) variables. In the context of first-order formulas, individual variables are typically called just variables. Unless otherwise stated, possibly subscripted letters a, b, c, . . . denote constants, s, t, . . . denote terms, x, y, z, ... denote individual variables, and f, g, h, ... denote either function symbols of function variables; in the latter case, the intended use will always be clear from the context."}, {"title": "First- and Second-Order Logic: Semantics", "content": "The notion of an interpretation plays a central role in the definition of the semantics of first- and second-order logic. An interpretation I = (\u0394', \u00b7') consists of a nonempty domain set \u2206' and a function .1 that maps each constant a to a domain element a\u00b9 \u2208 \u0394', each n-ary function symbol f to a function f\u00b9 : (\u0394')\u207f \u2192 \u0394', and each n-ary predicate R to a relation R\u00b9 \u2286 (\u0394')\u207f. A valuation n on I maps each individual variable x to a domain element x\u03c0 \u2208 \u0394', and each n-ary function variable f to an n-ary function f\u03c0 : (\u0394')\u207f \u2192 \u0394'. Given an interpretation I and a valuation n in I, each term t is assigned a value t", "follows": "na\u00b9\nx\u03c0 if t is a constant a,\nif t is an individual variable x,\nf'(t,...,th", "and\nf\u03c0(t": "...", "th": "if t = f(t1, ..., tn) with f an n-ary function variable.\nLet o be a first- or second-order formula (possibly containing free first- and/or second-order variables), let I be an interpreta-tion, and let n be a valuation defined on all free (individual and function) variables of 4. We can determine whether o is satisfied"}, {"title": "Auxiliary Definitions", "content": "A term t\u2081 is a subterm of a term t2 if t\u2081 syntactically occurs inside t2 (note that this definitions allows t\u2081 = t2); moreover t\u2081 is a proper subterm of t2 if t\u2081 is a subterm of t2 and t\u2081 \u2260 t2. The depth dep(t) of a term t is inductively defined as follows: dep(t) = 0 if t is a variable or a constant, and dep(t) = 1 + max{dep(t\u2081) | 1 \u2264 i \u2264 n} if t = f(t1,..., tn). The depth of an atom is equal to the maximum depth of its arguments. We often abbreviate a tuple t\u2081,..., tn of terms as t. We sometimes abuse the notation and treat t as a set; for example, we write t \u2208 t to indicate that term t occurs in vector t. Analogously, we often abbreviate a tuple f\u2081, ..., fn of function symbols as f. For a a term, an atom, or a set thereof, vars(a) is the set containing precisely all variables that occur in a. A term is ground if it does not contain a variable, and an atom is ground if all of its arguments are ground. A ground atom is often called a fact, and a base fact is a fact that neither uses the \u2248 predicate nor contains a function symbol. An instance is a (possibly infinite) set of facts, and a base instance is a finite set of base facts."}, {"title": "Generalised Second-Order Dependencies", "content": "A generalised second-order (SO) dependency is a second-order formula of the form\n\u2203f.[\u2200x\u2081.[\u03c6\u2081(x\u2081) \u2192 \u2203y\u2081.\u03c8\u2081(x\u2081, y\u2081)] \u2227 \u00b7 \u00b7 \u00b7 \u2200xn.[\u03c6n(xn) \u2192 \u2203yn.\u03c8n(xn, yn)]],                                                               (6)\nwhere f is a tuple of function variables and, for each i \u2208 {1, ..., n},\n\u2022 xi and yi are tuples of distinct individual variables,\n\u2022 \u03c6i(xi) is a conjunction consisting of (i) relational atoms whose arguments are constructed using constants and individual variables in xi, and (ii) equality atoms whose arguments are terms of depth at most one constructed using constants, individual variables in xi, and function variables in f,\n\u2022 \u03c8i(xi, yi) is a conjunction of atoms whose arguments are individual variables in yi, or terms of depth at most one constructed using constants, individual variables in xi, and function variables in f, and\n\u2022 each individual variable in xi appears in \u03c6i(xi) in a relational atom.\nThe last condition is called safety and is needed to ensure domain independence that is, that the satisfaction of a formula in an interpretation does not depend on the choice of the interpretation domain [39]. Since formula (6) can contain an arbitrary number of conjuncts, it suffices to consider just one generalised second-order dependency (instead of a set of dependencies). However, to simplify the notation, we often write down a generalised SO dependency as a set of formulas of the form \u03c6i(xi) \u2192 \u2203yi.\u03c8i(xi, yi) where quantifiers f and \u2200xi are left implicit. For each conjunct \u03b4 = \u2200xi.[\u03c6i(xi) \u2192 \u2203yi.\u03c8(xi, yi)], formulas \u2203yi.\u03c8(xi, yi) and \u03c6i(xi) are called the head and body of \u03b4, respectively, and are denoted by h(\u03b4) and b(\u03b4).\nUnlike most definitions of SO dependencies in the literature, we assume that all terms occurring in a generalised SO depen-dency are of depth at most one that is, terms with nested function variables, such as f(g(x)) are disallowed. This assumption allows us to simplify our results, and it is without loss of generality: Arenas et al. [6, Theorems 7.1 and 7.2] have shown that, for each generalised SO dependency \u03a3, there exists an equivalent generalised SO dependency \u03a3' where all terms are of depth at most one. Apart from this technical assumption, the syntactic form of (6) generalises most notions of dependencies we are familiar with. In particular, standard tuple-generating and equality-generating dependencies (TGDs and EGDs) [37] are obtained"}, {"title": "Queries and Query Answers", "content": "Conjunctive queries and unions of conjunctive queries are the most common query languages for dependencies considered in the literature [37]. In our work, it is convenient to \u2018absorb' the notion of a query into dependencies. Thus, we assume that there exists a distinguished query predicate Q, and that a query is defined as part of the formula (6) using one or more conjuncts of the form \u2200xi.[\u03c6i(xi) \u2192 Q(x)] where x \u2286 xi, and where the query predicate Q does not occur in the body of any conjunct of the formula (6). In other words, atoms with the query predicate cannot occur in a conjunct body, they can occur as the only atom of a conjunct head, and they are not allowed to contain constants, existentially quantified variables, or function variables. Thus, a conjunctive query of the form \u2203y.\u03c8(x, y) as defined by Fagin et al. [37] corresponds to a formula \u2200x, y.[\u03c8(x, y) \u2192 Q(x)] in our setting.\nFor \u03a3 a generalised SO dependency, Q a query defined by \u03a3, and B a base instance, a tuple of constants a is an answer to Q over \u03a3 and B, written {\u03a3} \u222a B |=\u2248 Q(a), if I |=\u2248 Q(a) for each interpretation I such that I |=\u2248 {\u03a3} \u222a B. Analogously, for \u03a3 a set of generalised FO dependencies, Q a query defined by \u03a3, and B a base instance, a tuple of constants a is an answer to Q over \u03a3 and B, written \u03a3 \u222a B |=\u2248 Q(a), if I |= Q(a) for each interpretation I such that I |= \u03a3 \u222a B."}, {"title": "Skolemisation", "content": "The Skolemisation of a conjunct \u03b4 = \u2200x.[\u03c6(x) \u2192 \u2203y.\u03c8(x, y)] of a generalised SO dependency is the formula \u03b4' = \u2200x.[\u03c6(x) \u2192 \u03c8'(x)], where \u03c8'(x') is obtained from \u03c8(x, y) by replacing each existentially quantified individual variable y \u2208 y with a term g(x') where g is a fresh function variable and x' contains all variables of x that occur free in \u03c8(x, y). For all such \u03b4 and \u03b4', let f be the tuple of function variables occurring in \u03b4, and let g be the tuple of function variables occurring in \u03b4' but not \u03b4; then, formulas \u2203f.\u03b4 and \u2203f, g.\u03b4' are equivalent. Thus, first-order quantification is redundant in second-order dependencies because first-order quantifiers can always be eliminated via Skolemisation; however, as we discuss in Section 4.3, distinguishing first- and second-order quantification allows us to optimise our query answering approach.\nSkolemisation can also be applied to generalised FO dependencies, in which case it introduces fresh function symbols (rather than function variables). These fresh function symbols cannot be quanfied (as they are not variables), so a set \u03a3 of generalised FO dependencies is not necessarily equivalent to its Skolemisation \u03a3'. However, for each base instance B and each fact of the form Q(a), we have {\u03a3} \u222a B |=\u2248 Q(a) if and only if {\u03a3'} \u222a B |=\u2248 Q(a); that is, Skolemisation does not affect the query answers.\nThroughout this paper, we call the function symbols (resp. function variables) occurring in the input FO or SO dependen-cies true function symbols (resp. function variables), and we call the function symbols (resp. function variables) introduced by Skolemization Skolem function symbols (resp. function variables). We discuss the rationale for this distinction in Section 4.3."}, {"title": "Equality as an Ordinary Predicate", "content": "Our algorithms will need to analyse inferences that use the equality predicate, which, as we discuss in detail in Section 3, can be very challenging. We overcome this issue by explicitly axiomatising the properties of equality and treating \u2248 as an ordinary predicate. To clearly distinguish the two uses of equality, we shall use the symbol = for satisfaction and entailment whenever we assume that \u2248 is an ordinary predicate without any special meaning. For example, let \u03c6 = R(a, b) \u2227 S(a, c) \u2227 \u2200x.[R(x, x\u2081) \u2227 S(x, X2) \u2192 X1 \u2248 X2]. Then, |=\u2248 b\u2248 c and \u2248 c \u2248 b; the latter holds because |=\u2248 interprets \u2248 as a symmetric predicate. In contrast, \u03c6 |= b \u2248 c, but \u03c6 * c \u2248 b; the latter holds because |= interprets \u2248 as just another predicate whose semantics is specified only by the formula \u03c6. Even when \u2248 is interpreted as an ordinary predicate, we shall still syntactically distinguish relational and equality atoms as outlined earlier."}, {"title": "Explicit Axiomatisation of Equality", "content": "When equality is treated as an ordinary predicate, the properties of equality can be explicitly axiomatised so that there is no distinction in the query answers. In particular, for \u03a3 a generalised SO dependency and B a base instance, let EQ(\u03a3) be a conjunction containing a domain dependency (7) instantiated for each constant c occurring in \u03a3, a domain dependency (8) instantiated for each n-ary predicate R occurring in \u03a3 distinct from \u2248 and Q and each i \u2208 {1, ..., n}, the"}, {"title": "The Chase", "content": "A standard way to answer the query Q over a second-order dependency \u03a3 and a base instance B is to compute a universal model for \u03a3 and B using an appropriate variant of the chase algorithm, and then to simply 'read off' the facts that use the Q predicate and consist of constants only. Numerous chase variants have been proposed [59, 21, 37, 27, 60, 73, 62, 33, 39, 6].\nTo the best of our knowledge, Arenas et al. [6] presented the first chase variant that is applicable to second-order dependencies with equality atoms in the heads. We next present a variant that can handle both first- and second-order quantification, and that distinguishes true and Skolem function variables. Both of these points allow us to optimise reasoning in certain cases.\nThe algorithm relies on the set of labelled nulls\u2014objects whose existence is implied by first- and second-order quantifiers. In particular, we distinguish a countably infinite set of base labelled nulls disjoint with the set of constants, and a countably infinite set of functional labelled nulls defined inductively as the smallest set containing a distinct object n\u1d62 for each term of the form t = f(u\u2081, ..., un) where f is a (true or Skolem) function variable and u1,..., un are constants or (base or functional) labelled nulls. Finally, we assume that all constants and labelled nulls are totally ordered using an arbitrary, but fixed ordering < where all constants precede all labelled nulls.\nThe chase algorithm for SO dependencies takes as input a generalised second-order dependency \u03a3 of the form (6) and a base instance B. We allow \u03a3 to contain both true and Skolem function variables. To simplify the presentation, we assume that no constant occurs in the body of a conjunct of \u03a3; thus, the bodies of the conjuncts of \u03a3 consist of relational atoms with variable ar-guments, as well as of equalities with terms of depth at most one. The algorithm manipulates facts whose arguments are constants or (base or functional) labelled nulls. Furthermore, for each true n-ary function variable f, the algorithm introduces a distinct n + 1-ary predicate Vf. Let I be an instance consisting of facts constructed using the predicates of \u03a3 and B, the equality predicate \u2248, and the predicates Vf where f is a true function variable, and furthermore assume that {V f(u\u2081, . . ., un, v), V f(u\u2081, . . ., un, v')} \u2286 I implies v = v' for all \u0192 and u\u2081, . . ., un. For t a term of depth at most one, we define the value of t in I, written t\u00b9, as follows.\n\u2022 If t is a constant or a (base or functional) labelled null, then t\u00b9 = t.\n\u2022 If t = f(u1,..., un), then t\u00b9 = v if I contains a fact of the form Vf(u\u2081, . . ., un, v), and t\u00b9 = n, otherwise.\nMoreover, let F = R(t1, ..., tn) be an equality or a relational ground atom where terms t\u2081,..., tn are all of depth at most one. Whether F is true in I, written I |= F, is defined as follows.\n\u2022 If F is an equality t\u2081 \u2248 t2, then I |= t\u2081 \u2248 t2 if t\u00b9 = t2.\n\u2022 Otherwise, I |= R(t1, ..., tn) if R(t\u2081, ...,th) \u2208 I."}, {"title": "3. Motivation & Overview", "content": "Before presenting formally our goal-driven query answering approach, in Section 3.1 we present a running example and discuss the problems that need to be overcome, and in Section 3.2 we present a high-level overview of our solution."}, {"title": "3.1. Problem Outline", "content": "The following running example demonstrates various issues that need to be overcome to facilitate goal-driven query answer-ing over generalised first- and second-order dependencies."}, {"title": "3.2. Solution Overview", "content": "Algorithm 1 presents our goal-driven query answering approach. The algorithm takes as input a generalised SO dependency \u03a3 and a base instance B", "B": "they depend only on \u03a3 and the definition of Q in it. Furthermore", "true": "quality (modulo some details that we discuss shortly)", "60": "that correctly handles second-order dependen-cies. This step uses a set of axioms SG(\u03a3) that relaxes EQ(\u03a3): set SG(\u03a3) does not contain the congruence dependencies (13)", "answers": "\u03a32 \u222aSG(\u03a32) \u222a B |= Q(a) if and only if P3 \u222a SG(P3) \u222a B |= Q(a) for each fact Q(a). In Section 4.3 we discuss a key observation: functional reflexivity dependencies need to be instantiated only for true function symbols", "25": ".", "steps": "the relevance analysis in (line 4) removes entire rules from P3 that provably do not contribute to query answers", "19": "line 5) prunes irrelevant inferences from the program P5. We discuss these techniques in Sections 4.4 and 4.5"}, {"answers": "Pi \u222a SG(Pi) \u222a B |= Q(a) if and only if Pi+1 \u222a SG(Pi+1) \u222a B |= Q(a) for each fact Q(a) and each i \u2208 {3, 4}.\nThe original query can now be answered over P5 \u222a SG(P5), and this will typically involve fewer inferences than computing the chase of \u03a3. However"}]}