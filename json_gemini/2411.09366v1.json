{"title": "LTLf+ and PPLTL+: Extending LTLf and PPLTL to Infinite Traces", "authors": ["Benjamin Aminof", "Giuseppe De Giacomo", "Sasha Rubin", "Moshe Y. Vardi"], "abstract": "We introduce LTLf+ and PPLTL+, two logics to express properties of infinite traces, that are based on the linear-time temporal logics LTLf and PPLTL on finite traces. LTLf+/PPLTL+ use levels of Manna and Pnueli's LTL safety-progress hierarchy, and thus have the same expressive power as LTL. However, they also retain a crucial characteristic of the reactive synthesis problem for the base logics: the game arena for strategy extraction can be derived from deterministic finite automata (DFA). Consequently, these logics circumvent the notorious difficulties associated with determinizing infinite trace automata, typical of LTL reactive synthesis. We present DFA-based synthesis techniques for LTLf+/PPLTL+, and show that synthesis is 2EXPTIME-complete for LTLf+ (matching LTLf) and EXPTIME-complete for PPLTL+ (matching PPLTL). Notably, while PPLTL+ retains the full expressive power of LTL, reactive synthesis is EXPTIME-complete instead of 2EXPTIME-complete. The techniques are also adapted to optimally solve satisfiability, validity, and model-checking, to get EXPSPACE-complete for LTLf+ (extending a recent result for the guarantee level using LTLf), and PSPACE-complete for PPLTL+.", "sections": [{"title": "Introduction", "content": "Reactive synthesis is concerned with synthesizing programs (aka, strategies) for reactive computations (e.g., processes, protocols, controllers, robots) in active environments (Pnueli and Rosner 1989; Finkbeiner 2016; Ehlers et al. 2017). The basic techniques for reactive synthesis share several similarities with Model Checking, and are based on the connections between Logics, Automata, and Games (Fijalkow et al. 2023). The most common specification language is possibly Linear Temporal Logic (LTL) (Pnueli 1977).\nReactive Synthesis for LTL involves the following Steps:\n(1) having a specification \\( \\varphi \\) of the desired system behavior in LTL, in which one distinguishes controllable and uncontrollable variables; (2) extracting from the specification an equivalent automaton on infinite words, corresponding to the infinite traces satisfying \\( \\varphi \\); (3) (differently from Model Checking) determinizing the automaton to obtain an arena for a game between the system and the environment; (4) solving the game, by fixpoint computation, for an objective determined by the automaton's accepting condition (e.g., a parity objective for LTL), yielding a strategy for the system that fulfills the original specification \\( \\varphi \\).\nModel Checking is mature, and many of its techniques may be exploited in Reactive Synthesis as well, e.g., symbolic techniques based on Boolean encodings may be used to compactly represent the game arena and to compute fix-points over it. However, despite this, Step (3) remains a major performance obstacle. For LTL, this involves determinizing nondeterministic B\u00fcchi automata, which is notoriously difficult (Vardi 2007). This has held back the use of reactive synthesis in applications.\nReactive synthesis is deeply related to Planning (De Giacomo and Rubin 2018; Alberto, Bienvenu, and McIlraith 2019), and in particular to (strong) planning for temporally extended goals in fully observable nondeterministic domains (Cimatti et al. 2003; Bacchus and Kabanza 1998, 2000; Calvanese, De Giacomo, and Vardi 2002; Baier and McIlraith 2006; Baier, Fritz, and McIlraith 2007; Gerevini et al. 2009). A key characteristic of Planning is that the system continuously receives a goal, \u201cthinks\" about how to achieve it, synthesizes a plan, executes the plan, and repeats (Geffner and Bonet 2013). This suggests to focus on goal specifications that can be satisfied on finite traces. Recently, this led to a shift in Reactive Synthesis to focus on logics on finite traces (instead of infinite traces), e.g., LTLf (De Giacomo and Vardi 2013, 2015). The advantage of focusing on finite traces is that in Step (3) one can rely on (classic) automata operating on finite traces, including deterministic finite automata (DFA), and use known determinization algorithms with good practical performance. The development of LTLf synthesis (De Giacomo and Vardi 2015) has brought about scalable tools that are unprecedented in reactive synthesis (Zhu et al. 2017; Bansal et al. 2020; De Giacomo and Favorito 2021; De Giacomo et al. 2022). Beside LTLf, another finite-trace logic that is gaining popularity in AI is Pure Past LTL (PPLTL) (De Giacomo et al. 2020; Cimatti et al. 2020; Bonassi et al. 2023b,a, 2024). This is a variant of LTLf that sees the trace backwards and has the notable property that one can obtain a symbolic (i.e., factorized) DFA directly from the formula in linear time; moreover, while the size of the (non-symbolic) DFA corresponding to an LTLf formula can be double-exponential in the size of the formula itself,"}, {"title": "Preliminaries", "content": "For a non-negative integer k, let [k] = {1, 2, . . ., k}.\nTrace Properties Let \\( \\Sigma \\) be a finite alphabet. If S \\( \\subseteq \\Sigma \\), then \\( S^\\omega \\) (resp. \\( S^* \\)) is the set of infinite (resp. finite) sequences over \\( \\Sigma \\). The empty sequence is denoted \\( \\varepsilon \\). Indexing sequences starts at 0, and we write \\( T = T_0T_1... \\). For \\( 0 \\lt i \\lt |\\tau| \\), write \\( \\tau_{\\lt i} \\) for the prefix \\( T_0...T_i \\), and \\( \\tau_{\\ge i} \\) for the suffix \\( T_iT_{i+1}... \\) of \\( T \\). Let AP be a finite non-empty set of atoms. We assume that AP is fixed, and do not measure its size in any of the complexities. A trace is a non-empty finite or infinite sequence \\( \\tau \\) over \\( \\Sigma = 2^{AP} \\) (valuations of atoms); in particular, the empty sequence \\( \\Lambda \\) is not a trace. The length of \\( \\tau \\) is denoted \\( |\\tau| \\in \\mathbb{N}\\cup \\{\\omega\\} \\). A finite-trace property is a set of finite traces. An infinite-trace property is a set of infinite traces. A trace satisfies a property Z if it is in Z. Let L be a logic for representing infinite-trace (resp. finite-trace) properties. The set of infinite (resp. finite) traces satisfying a formula \\( \\varphi \\) of L is denoted \\( [\\varphi] \\). An infinite-trace (resp. finite-trace) property Z is definable (aka, expressible) in L iff there is some formula \\( \\varphi \\) of L such that \\( Z = [\\varphi] \\).\nPrefix Quantifiers For a finite-trace property Z, define four fundamental infinite-trace properties as follows: \\( \\forall Z \\) (resp. \\( \\exists Z \\)) denotes the set of infinite traces \\( \\tau \\) such that every (resp. some) non-empty finite prefix of \\( \\tau \\) satisfies Z;\n\\( \\forall^\\omega Z \\) (resp. \\( \\exists^\\omega Z \\)) denotes the set of infinite traces \\( \\tau \\) such that infinitely many (resp. all but finitely many, aka almost all) non-empty finite prefixes of \\( \\tau \\) satisfies Z.\nTransition Systems A nondeterministic transition system \\( \\mathcal{T} = (\\Sigma, Q, I, \\delta) \\) consists of a finite input alphabet \\( \\Sigma \\) (typically, \\( \\Sigma = 2^{AP} \\)), a finite set Q of states, a set \\( I \\subseteq Q \\) of initial states, and a transition relation \\( \\delta \\subseteq Q \\times \\Sigma \\times Q \\). The size of \\( \\mathcal{T} \\) is \\( |Q| \\), the number of its states. We say that \\( \\mathcal{T} \\) is total if for every q, a there exists q' such that \\( (q, a, q') \\in \\delta \\). Unless stated otherwise, nondeterministic transition systems are assumed to be total. In case \\( I = \\{ \\iota \\} \\) is a singleton and \\( \\delta \\) is functional, i.e., for every q, a there is a unique q' such that \\( (q, a, q') \\in \\delta \\), the transition system is called deterministic instead of nondeterministic; in this case we write \\( \\iota \\) instead of I, and \\( \\delta(s, a) = s' \\) instead of \\( (s, a, s') \\in \\delta \\). A run (aka path) induced by the trace \\( \\tau \\) is a sequence \\( p = p_0p_1... \\) of states, where \\( p_0 \\in I \\) and \\( p_{i+1} \\in \\delta(p_i, \\tau_i) \\) for \\( 0 \\le i \\lt |\\tau| \\). We simply say that \\( \\tau \\) has the run p and that p is a run of \\( \\mathcal{T} \\). In a nondeterministic transition system \\( \\mathcal{T} \\), a trace may have any number of runs (including none). If a trace \\( \\tau \\) has a run in \\( \\mathcal{T} \\), we say that \\( \\mathcal{T} \\) generates \\( \\tau \\). For \\( i\\in \\{1,2\\} \\), let \\( \\mathcal{T}_i = (\\Sigma, Q_i, \\iota_i, \\delta_i) \\) be deterministic transition systems over the same alphabet. The product \\( \\mathcal{T}_1 \\times \\mathcal{T}_2 \\) is the deterministic transition system \\( (\\Sigma, Q', \\iota', \\delta') \\) where \\( Q' = Q_1 \\times Q_2 \\), \\( \\iota' = (\\iota_1,\\iota_2) \\), and \\( \\delta((q_1,q_2), a) = (\\delta_1(q_1,a), \\delta_2(q_2, a)) \\). This naturally extends to a product of n-many systems. For an infinite run p, define \\( inf(p) \\subseteq Q \\) to be the set of states \\( q\\in Q \\) such that \\( q = p_i \\) for infinitely many i.\nAutomata on finite traces A finite automaton is a pair \\( \\mathcal{A} = (\\mathcal{T}, F) \\), where \\( \\mathcal{T} \\) is a transition system and \\( F \\subseteq Q \\) is the set of final states. The size of \\( \\mathcal{A} \\) is the size of \\( \\mathcal{T} \\). If \\( \\mathcal{T} \\) is nondeterministic, then \\( \\mathcal{A} \\) is called a nondeterministic finite automaton (NFA); if \\( \\mathcal{T} \\) is deterministic, then \\( \\mathcal{A} \\) is called a deterministic finite automaton (DFA). A finite trace is accepted by \\( \\mathcal{A} \\) if it has a run that ends in a state of F. The set of finite traces accepted by \\( \\mathcal{A} \\) is called the language of \\( \\mathcal{A} \\), and is denoted \\( L(\\mathcal{A}) \\). Two automata \\( \\mathcal{A}, \\mathcal{B} \\) are equivalent if \\( L(\\mathcal{A}) = L(\\mathcal{B}) \\). We say that \\( \\mathcal{A} \\) is equivalent to an LTLf/PPLTL formula \\( \\varphi \\) if \\( L(\\mathcal{A}) = [\\varphi] \\).\nGames and Synthesis An arena is a deterministic tran-sition system \\( D = (\\Sigma, Q, \\iota, \\delta) \\) where \\( \\Sigma = 2^{AP} \\) and AP is partitioned into \\( X \\cup Y \\) for some sets X, Y of atoms. Elements of \\( 2^Y \\) (resp. \\( 2^X \\)) are called environment moves (resp. agent moves). An objective O over D is a subset of Q. Elements of O are said to satisfy O. A game is a pair \\( G = (D,O) \\). A strategy is a function \\( \\sigma : (2^Y)^* \\rightarrow (2^X) \\) that maps sequences of environment moves to agent moves (including the empty sequence, because the agent moves first). An outcome of \\( \\sigma \\) is an infinite trace \\( \\tau \\) over \\( 2^{AP} \\) such that (i) \\( \\tau_0 \\cap X = \\sigma(\\epsilon) \\), and (ii) for \\( i \\gt 0 \\) we have \\( \\tau_i \\cap X = \\sigma(\\tau_0 \\cap Y \\cdot \\tau_1 \\cap Y... \\tau_{i-1} \\cap Y) \\). A strategy \\( \\sigma \\) is winning if for every outcome \\( \\tau \\), the run \\( \\rho \\in Q^\\omega \\) induced by the trace \\( \\tau \\) in D satisfies O. The following computational problem is called game solving: given \\( G = (D,O) \\), decide if there is a winning strategy, and if so, to return a finite rep-resentation of one. Intuitively, in a game, the agent moves first, the environment responds, and this repeats producing"}, {"title": "Linear Temporal Logics on Finite Traces", "content": "We base our infinite-trace logics on finite-trace logics. The latter should have two features: (1) each formula in the logic can be converted into an equivalent DFA; (2) it must be efficiently closed under Boolean operations, i.e., one should be able to obtain the negation of a formula in polynomial time. For example, regular expressions satisfy (1) but not (2). On the other hand, Linear Temporal Logic on Finite Traces (LTLf) (De Giacomo and Vardi 2013) and Pure Past Linear Temporal Logic (PPLTL) (Lichtenstein, Pnueli, and Zuck 1985) satisfy both (1) and (2). We now recall these.\nLTLf The syntax is given by: \\( \\varphi ::= p | \\neg \\varphi| \\varphi \\wedge \\varphi |\\varphi \\text{X} \\varphi |\\varphi \\text{U}\\varphi \\), where \\( p \\in AP \\). Here X (\u201cnext\u201d) and U (\u201cuntil\u201d) are the future operators. Common abbreviations include \\( \\text{WX} \\varphi = \\neg \\text{X} \\neg \\varphi \\) (\u201cweak next\u201d). We interpret LTLf formulas over finite traces. Intuitively, we evaluate starting in position 0 of the trace, X \\( \\varphi \\) says that \\( \\varphi \\) holds in the next step, and \\( \\varphi_1 \\text{U} \\varphi_2 \\) says that \\( \\varphi_2 \\) holds eventually, and \\( \\varphi_1 \\) holds at every point in time until then (the formal semantics of LTLf is in the supplement). In LTLf, one can predicate about both ends of the finite trace: the first instant of the trace by avoiding temporal operators (as in LTL), and the last instant by using the abbreviation last := \\( \\neg \\text{X} \\text{true} \\).\nPPLTL The syntax is given by: \\( \\varphi ::= p | \\neg \\varphi | \\varphi \\wedge \\varphi | \\varphi \\text{Y} \\varphi | \\varphi \\text{S}\\varphi \\), where \\( p \\in AP \\). Here Y (\u201cyesterday\u201d) and S (\u201csince\u201d) are the past operators, analogues of \u201cnext\u201d and \u201cuntil\u201d, respectively, but in the past. Common abbreviations"}, {"title": "LTLf+ and PPLTL+", "content": "Based on LTLf (resp. PPLTL), we define the logic LTLf+ (resp. PPLTL+) for specifying infinite-trace properties. Fix a set AP of atomic predicates.\nSyntax The syntax of LTLf+ (resp. PPLTL+) is given by the following grammar:\n\\( \\Psi ::= \\Psi \\vee \\Psi | \\Psi \\wedge \\Psi | \\neg \\Psi | \\forall \\Phi | \\exists \\Phi | \\forall^\\omega \\Phi | \\exists^\\omega \\Phi \\), where \\( \\Phi \\) are formulas in LTLf (resp. PPLTL) over AP. We use common abbreviations, e.g., \\( \\Psi \\supset \\Psi' \\) for \\( \\neg \\Psi \\vee \\Psi' \\). The formulas \\( \\forall \\Phi, \\exists \\Phi, \\exists^\\omega \\Phi, \\exists \\forall \\Phi \\) are called infinite-trace formulas, and the formulas \\( \\Phi \\) are called finite-trace formulas.\nSemantics For an LTL/PPLTL formula \\( \\Phi \\), recall that we write \\( [\\Phi] \\subseteq (2^{AP})^* \\) for the set of finite traces that satisfy \\( \\Phi \\). For an LTLf+/PPLTL+ formula \\( \\Psi \\) let \\( [\\Psi] \\subseteq (2^{AP})^\\omega \\) denote the set of infinite-trace properties, defined recursively as follows:\n*   \\[\\begin{aligned}\\* [\\Psi\\vee \\Psi'] &= [\\Psi] \\cup [\\Psi'],\\\\ [\\Psi\\wedge \\Psi'] &= [\\Psi] \\cap [\\Psi'], \\text{ and}\\\\ [\\neg\\Psi] &= (2^{AP})^\\omega \\setminus [\\Psi];\\\\ [\\forall\\Phi] &= \\forall [\\Phi],\\\\ [\\exists\\Phi] &= \\exists [\\Phi],\\\\ [\\forall^\\omega \\Phi] &= \\forall^\\omega [\\Phi], \\text{ and}\\\\ [\\exists^\\omega \\Phi] &= \\exists^\\omega [\\Phi]. \\end{aligned}\\]\nIn words, the Boolean operations are handled as usual, and \\( \\forall [\\Phi] \\) (resp. \\( \\exists [\\Phi] \\)) denotes the set of infinite traces \\( \\tau \\) such that every (resp. some) non-empty finite prefix of \\( \\tau \\) satisfies \\( \\Phi \\), and \\( \\forall^\\omega [\\Phi] \\) (resp. \\( \\exists^\\omega [\\Phi] \\)) denotes the set of infinite traces \\( \\tau \\) such that infinitely many (resp. all but finitely many) non-empty finite prefixes of \\( \\tau \\) are in \\( \\Phi \\). Note that \\( \\forall \\) and \\( \\exists \\neg \\exists \\neg \\Phi \\), as are \\( \\forall^\\omega \\) and \\( \\exists^\\omega \\) since \\( \\exists^\\omega \\Phi = \\neg \\exists \\forall \\neg \\Phi \\). We write \\( \\tau \\models \\Psi \\) to mean that \\( \\tau \\in [\\Psi] \\)."}, {"title": "Reactive Synthesis", "content": "The synthesis problem for LTL was introduced in (Pnueli and Rosner 1989). In this section we define and study the synthesis problem for PPLTL+ and LTLf+.\nDefinition 1. The LTLf+ synthesis problem (resp. PPLTL+ synthesis problem) asks, given \\( \\Psi \\) in LTLf+ (resp. PPLTL+), to decide if there is a strategy \\( \\sigma \\) such that every outcome of \\( \\sigma \\) satisfies \\( \\Psi \\) (such a strategy is said to enforce \\( \\Psi \\)), and, if so, to return a finite representation of such a strategy.\nWe solve the LTLf+/PPLTL+ synthesis problem with an automata-theoretic approach based on DFAs, in a 4-step Synthesis Algorithm, as follows.\nFor convenience, we begin with a formula \\( \\Psi \\) in positive normal-form. The formula \\( \\Psi \\) can be thought of as a Boolean formula (i.e., without negations) over a set of the form [k] (for some k); thus \\( \\Psi \\) can be formed from \\( \\Psi \\) by replacing, for every \\( i \\in [k] \\), every occurrence of i in \\( \\Psi \\) by a certain infinite-trace formula of the form \\( Q_i\\Phi_i \\), where \\( Q_i \\in \\{\\exists, \\forall, \\exists\\forall, \\forall\\exists\\} \\).\nStep 1. Convert each finite-trace formula \\( \\Phi_i \\) into an equiv-alent DFA \\( \\mathcal{A}_i = (D_i, F_i) \\) as in Theorem 2. Say \\( D_i = (\\Sigma, Q_i, \\iota_i, \\delta_i) \\). We assume, without loss of generality, that the initial state has no incoming transitions.\nStep 2. For each \\( i\\in [k] \\), build a transition system \\( D_i' = (\\Sigma, Q_i, \\iota_i, \\delta_i) \\), a set \\( F_i' \\subseteq Q_i \\), and an objective \\( O_i \\) over \\( Q_i \\):\n1.  Say \\( Q_i = \\forall\\exists \\Phi_i \\). Let \\( \\delta_i' = \\delta_i, F_i' = F_i \\), and \\( O_i = \\{p : inf(p) \\cap F_i \\neq \\emptyset\\} \\).\n2.  Say \\( Q_i = \\exists\\forall \\Phi_i \\). Let \\( \\delta_i' = \\delta_i, F_i' = F_i \\), and \\( O_i = \\{p : inf(p) \\cap (Q \\setminus F_i) = \\emptyset\\} \\).\n3.  Say \\( Q_i = \\forall \\Phi_i \\). If \\( \\iota_i \\) is not a final state, make it into a final state, i.e., define \\( F_i' = F_i \\cup \\{\\iota_i\\} \\). Let \\( \\delta_i' \\) be like \\( \\delta_i \\) except that every non-final state is a sink, i.e., define \\( \\delta'(q, a) \\) to be q if \\( q \\notin F_i \\), and otherwise to be \\( \\delta_i(q, a) \\). Let \\( O_i = \\{p : inf(p) \\cap F_i \\neq \\emptyset\\} \\).\n4.  Say \\( Q_i = \\exists \\Phi_i \\). If \\( \\iota_i \\) is a final state, make it into a non-final state, i.e., define \\( F_i' = F_i \\setminus \\{\\iota_i\\} \\). Let \\( \\delta_i' \\) be like \\( \\delta_i \\) except that every final state q is a sink, i.e., define \\( \\delta'(q, a) \\) to be q if \\( q \\in F_i \\), and otherwise to be \\( \\delta_i(q, a) \\). Let \\( O_i = \\{p : inf(p) \\cap F_i \\neq \\emptyset\\} \\).\nWe get the following from these definitions"}, {"title": "A new and simple algorithm for solving Emerson-Lei games", "content": "Emerson-Lei games can be solved in time polynomial in the size of the arena and exponential in the number of labels. We mention two approaches to do this (Hausmann, Lehaut, and Piterman 2024). One approach amounts to solving fixpoint equation systems, and has the potential to be implemented symbolically directly. Another approach first converts EL-games to parity games, and then solves the parity game. We supply a simple algorithm that takes the second approach. It uses a variation of the \"state appearance record\" construction for converting Muller automata to parity automata (Apt and Gr\u00e4del 2011). This yields the same complexity as in Theorem 1.\nParity automata Let D be a deterministic transition sys-tem with state set Q. A function \\( c : Q \\rightarrow \\mathbb{N} \\) is called a coloring function on D. The index of c is \\( |c(Q)| \\, i.e., the number of different colors actually used by c. The parity ob-jective \\( O_c \\) consists of the infinite runs p such that the largest color seen infinitely often on p is even, i.e., \\( p\\in O_c \\) iff \\( max\\{c(q): q\\in inf(p)\\} \\) is even. The pair (D, c) is called a deterministic parity automaton (DPA). A parity game is a pair G = (D, c) where D is an arena. Parity games can be solved in time polynomial in the size of D and exponential in the index (Apt and Gr\u00e4del 2011); better algorithms are known, but we will not need these here.\nConverting EL-automata to parity automata We now describe the construction of a parity automaton B = (D', c) equivalent to a given Emerson-Lei automaton A = (D, (\\Gamma, \\lambda, B)). The idea is to enrich the state space of D by keeping track of two pieces of information along a run: (i) the order in which labels in \\( \\Gamma \\) were last visited - this is done by keeping a permutation \\( \\pi \\) of the elements of \\( \\Gamma \\); (ii) a way to detect which elements of \\( \\Gamma \\) are visited infinitely often - this is done by keeping the largest position h in that \\( \\pi \\) contains a label visited by the source state. Thus, the states of B are of the form (q, \\( \\pi \\), h) where q is a state of A. Intuitively, the job of the permutations and pointers in the states of B is to help the parity condition of B detect if the"}, {"title": "Reasoning", "content": "We now study other standard computational problems for our logics. Let L be one of LTLf/PPLTL. The L+ satisfiability problem asks, given \\( \\Psi \\) in L+, to decide whether \\( [\\Psi] \\neq \\emptyset \\). The L+ validity problem asks, given \\( \\Psi \\) in L+, to decide whether \\( [\\Psi] = (2^{AP})^\\omega \\). For a nondeterministic tran-sition system \\( \\mathcal{T} \\), that is not assumed to be total, with input"}]}