{"title": "Traffic-Rule-Compliant Trajectory Repair via Satisfiability Modulo Theories and Reachability Analysis", "authors": ["Yuanfei Lin", "Zekun Xing", "Xuyuan Han", "Matthias Althoff"], "abstract": "Complying with traffic rules is challenging for automated vehicles, as numerous rules need to be considered simultaneously. If a planned trajectory violates traffic rules, it is common to replan a new trajectory from scratch. We instead propose a trajectory repair technique to save computation time. By coupling satisfiability modulo theories with set-based reachability analysis, we determine if and in what manner the initial trajectory can be repaired. Experiments in high-fidelity simulators and in the real world demonstrate the benefits of our proposed approach in various scenarios. Even in complex environments with intricate rules, we efficiently and reliably repair rule-violating trajectories, enabling automated vehicles to swiftly resume legally safe operation in real-time.", "sections": [{"title": "I. INTRODUCTION", "content": "JUST like human drivers, automated vehicles must explicitly comply with traffic rules to ensure their safe operation on roads. If this is done carefully, automated driving can gain the necessary public trust, and responsible operators can mitigate potential liability claims in case of accidents. However, despite the paramount importance of rule compliance, existing motion planning algorithms, as highlighted in recent surveys [1]\u2013[4], either overlook traffic rules, incorporate them implicitly using deep learning approaches [5], or address only a limited selection [6], [7].\nRuntime verification (aka monitoring) is an efficient method to verify if the planned trajectory aligns with expected behaviors [8]\u2013[10]. If planned trajectories are monitored and identified as rule-violating, it is common to replan them within a receding-horizon planning framework. Nevertheless, replanning the entire trajectory is often undesired and inefficient for several reasons:\n1) it relies on the strong assumption that the used planner inherently accommodates every traffic rule;\n2) replanning typically requires substantially more computational resources than focusing on adjusting specific trajectory segments; and\n3) frequent replanning can lead to unpredictable and inconsistent behavior, potentially causing confusion among other traffic participants [11, Sec. I].\nTherefore, we propose a trajectory repair framework that selectively refines a planned trajectory to address violations of traffic rules"}, {"title": "A. Literature Overview", "content": "We categorize existing works on rule-informed motion planning, trajectory replanning, and repair techniques for automated vehicles. Since our work focuses on traffic rules derived from legal resources and consultations with lawyers, we do not review works on modifying specifications online [12]\u2013[14].\n1) Rule-Informed Motion Planning: Traffic rules are initially described in natural language, which usually introduces ambiguity and unintended interpretations. Formal methods address this issue by using rigorous mathematical formalization [4]. In particular, temporal logic is extensively used to formalize safety requirements and complex traffic rules. Examples include linear temporal logic (LTL) [15], [16], metric temporal logic (MTL) [17]\u2013[19], signal temporal logic (STL) [20], and their variants [21], [22].\nSeveral studies integrate LTL specifications into the motion planning problem by formulating them as automata and use rapidly-exploring random trees (RRTs) [23] to plan trajectories [24]\u2013[26]. The automata-based approaches are computationally expensive, and the RRT algorithm is only probabilistically complete [27]. In contrast, MTL and STL have the advantage of quantitatively evaluating the degree of satisfaction or vi-"}, {"title": "2) Trajectory Replanning:", "content": "In classical motion planning, incremental techniques are widely employed to replan trajectories by dynamically adapting the motion planner to changing environments [2]. Search algorithms such as lifelong planning A* [37], [38], D* [39], and anytime repairing A* [40] are incremental variants of the original A* algorithm. Similarly, many sampling-based motion planners [41]\u2013[45] use incremental strategies to progressively explore the solution space. In task planning with LTL specifications, several studies [46]\u2013 [48] promote an incremental method for mending the product automaton, which combines an abstract model of the system and the specification automaton. To ensure the safety of black-box motion planners, the authors of [49] use reachability analysis to verify safety and replan unsafe trajectories by sampling from feasible configuration spaces. Likewise, the approach proposed in [50] replans actions suggested by a reinforcement learning agent when they violate traffic rules. Furthermore, the work presented in [51] harnesses the power of large language models to enhance the performance of motion planners. However, these methods are tightly integrated within the motion planner, which limits their flexibility."}, {"title": "3) Trajectory Repair:", "content": "Trajectory repair differs from replanning by relying solely on the output of the motion planner, either by making local adjustments or branching off.\na) Local Trajectory Repair: Local trajectory repair typically uses the planned trajectory as a reference to improve its quality when it fails to meet the given criteria. For example, the authors of [52] employ an optimization procedure that incorporates trajectory smoothness as an additional constraint. A similar regime is outlined in [53]\u2013[59], where search algorithms, optimizers, or parametric curves are used to repair the initial plan. In addition, the initial trajectory can be locally deformed to avoid collisions, either by modeling it as an elastic band [60] or through an affine transformation [61]. However, when addressing the nonholonomic motion of a vehicle, solving the two-point boundary value problem finding a trajectory that satisfies given initial and final conditions poses significant challenges, especially in real-time applications.\nb) Branching Off From Trajectories: When the initially planned result maintains a sufficiently high quality, it can be partially reused and a new partial trajectory can be branched off to meet all requirements. The works in [62]\u2013[68] bear conceptual similarities to our approach in this regard. They account for potential future scenario evolutions, resulting in trajectories branching off for each alternative future scenario. Notably, the authors of [66] highlight the benefits of delaying branching points as much as possible, which reduces the number of constraints in the trajectory optimization problem and leaves more reaction time for the vehicle to handle potential hazards. This also aligns with the preference of system designers for safety systems to intervene at the latest possible point in time [69]. However, their selection of branching points is not suitable for rule-compliant trajectory repair, as these are either defined solely by divergences in future predictions [66], determined through a static choice [63], [64], or lack well-defined frameworks [62], [68]. To address these limitations, we proposed using criticality measures in our previous work [70]\u2013 [72], as they objectively assess behavioral safety and offer a systematic approach for determining the appropriate timing of interventions. To efficiently obtain a satisfactory solution, satisfiability modulo theories (SMT) [73] is used to determine whether and how the violated rules can be satisfied."}, {"title": "B. Contributions and Outline", "content": "Building upon our previous work [70]\u2013[72], we present a trajectory repair approach to promote compliance with formalized traffic rules of an automated vehicle, referred to as the ego vehicle from now on. In particular, unlike our previous work, our approach simultaneously:\n1) supports traffic rules formalized in STL with arbitrary temporal operators;\n2) employs for the first time model predictive robustness as enhanced heuristics for Boolean satisfiability (SAT) solving an NP-complete problem within an SMT solver. This also makes it possible to obtain reasonable robustness values without excessive manual tuning;\n3) for the first time, applies set-based reachability analysis to compute the spatio-temporal constraints needed to repair trajectories;\n4) requires less computation time in more critical scenarios with smaller solution spaces;\n5) can be applied to arbitrary traffic scenarios, covering diverse driving environments, such as interstates and intersections; and\n6) has been extensively validated through both open-loop and closed-loop traffic simulations, as well as real-world testing on a research vehicle, with each validation type using a different nominal planner.\nThis article is structured as follows: After introducing the preliminaries and problem statement in Sec. II, we present an overview of our approach in Sec. III. The abstraction process for propositional rule formulas is described in Sec. IV, followed by SAT solving and trajectory repair in Sec. V and Sec. VI, respectively. Finally, we evaluate our concept in Sec. VII before drawing conclusions in Sec. VIII."}, {"title": "II. PRELIMINARIES AND PROBLEM STATEMENT", "content": null}, {"title": "A. System Description and Notations", "content": "An index $k \\in \\mathbb{N}_0$ corresponds to a discrete time step $t_k = k\\Delta t$, where $\\Delta t \\in \\mathbb{R}^+$ is a fixed time increment. The motion of vehicles is modeled as a discrete-time system:\n$x_{k+1} = f(x_k, u_k)$,\nwhere $x_k \\in \\mathbb{R}^{n_x}$ is the state vector and $u_k \\in \\mathbb{R}^{n_u}$ is the input vector. The state and input are bounded by sets of admissible values: $\\forall k \\in [0,h]: x_k \\in X_k$ and $\\forall k \\in [0, h - 1]: u_k \\in U_k$, where $h \\in \\mathbb{N}^+$ is the final time step. We denote the solution of (1) at time step $k$ as $x(k, x_0, u_{[0,k-1]})$, given an initial state $x_0$ and an input trajectory $u_{[0,k-1]}$ for the time interval $[0, k - 1]$. For simplicity, we sometimes write $x$ instead of $x([0, h], x_0, u_{[0,h-1]})$. The road network $L$ is composed of a set of lanelets [74], each defined by polylines that establish its left and right boundaries. Given a planned or predicted trajectory, we compute a reference path $\\Gamma$ [75], which uniquely corresponds to a sequence of lanelets $L_{dir} \\subset L$ aligned with the driving direction. As depicted in Fig. 2, a curvilinear coordinate system is derived from $\\Gamma$ for locating the vehicle using its longitudinal position $s$ and lateral deviation $d$ from $\\Gamma$ at $s$ [75]. Let $\\Box$ represent a variable. The initial and repaired values of $\\Box$ are denoted by $\\Box^{ini}$ and $\\Box^{rep}$, respectively. Values associated with the ego vehicle are represented by $\\Box_{ego}$, and those associated with an obstacle $\\Box_{obs} \\in B$ by $\\Box_{obs}$, where $B$ denotes the set of rule-relevant obstacles. The concatenated states of vehicles is denoted by $W_k := \\left[ x^T_{ego, k}, x^T_{obs_0, k}, \\dots, x^T_{obs_{|B|-1},k} \\right]^T$"}, {"title": "B. Signal Temporal Logic", "content": "For traffic rule evaluation, we consider a discrete-time signal $\\omega := \\omega_0,..., \\omega_k,...,\\omega_h$. Given formulas $\\varphi, \\varphi_1, \\text{and } \\varphi_2$, the syntax of STL is defined as [76, Sec. 2.1]:\n$\\varphi := p \\mid \\neg\\varphi \\mid \\varphi_1 \\lor \\varphi_2 \\mid \\varphi_1 S_{[a,b]}\\varphi_2 \\mid \\varphi_1 U_{[a,b]}\\varphi_2$,\nwhere $p := \\alpha(\\omega_k) > 0$ is an atomic predicate, with $\\alpha: X^{[B+1]} \\rightarrow \\mathbb{R}$. The symbols $\\neg$ and $\\lor$ denote Boolean negation and disjunction operators. Additionally, $\\varphi_1 S_{[a,b]}\\varphi_2$ and $\\varphi_1 U_{[a,b]}\\varphi_2$ represent the temporal since and until operators, respectively, with a time bound of $[a, b]$, where $a, b \\in \\mathbb{N}_0$ and $b> a$. The logical True and False are denoted as $\\top$ and $\\bot$, respectively, and the valuation of a formula is denoted as $[\\varphi]$, e.g., $[\\varphi] = \\top$. To simplify notation, we omit the interval from temporal operators when it extends to the end of the input signal, which is always finite in this work. If a signal $\\omega$ complies with $\\varphi$ at time step $k$, we write $\\omega_k \\models \\varphi$. If not, we write $\\omega_k \\nvDash \\varphi$. Additional temporal logic operators can be constructed from (2) (see [76, Sec. 2.1]), such as $\\varphi_1 \\land \\varphi_2 := \\neg(\\neg\\varphi_1 \\lor \\neg\\varphi_2)$ (conjunction), $\\varphi_1 \\Rightarrow \\varphi_2 := (\\neg\\varphi_1 \\lor \\varphi_2)$ (implication), $P\\varphi := \\top S\\varphi$ (previous), $O_{[a,b]}\\varphi := \\top S_{[a,b]}\\varphi$ (once), $F_{[a,b]}\\varphi := \\top U_{[a,b]}\\varphi$ (eventually), $H_{[a,b]}\\varphi := \\neg O_{[a,b]}\\neg\\varphi$ (historically), and $G_{[a,b]}\\varphi := \\neg F_{[a,b]}\\neg\\varphi$ (globally).\nIn this article, we focus on future-time temporal operators as the outermost operators, specifically F and G, which are most frequently used in motion planning. The past-time operators O and H can be defined analogously, as they mirror their future-time counterparts F and G, respectively, operating in reverse time. We now define the robustness of STL formulas."}, {"title": "Definition 1", "content": "(STL Robustness [29, Def. 3]) The robustness $\\rho(\\varphi, \\omega, k)$ of an STL formula $\\varphi$ (see (2)) with respect to a signal $\\omega$ at time step $k$ is defined as:\n$\\begin{aligned} \\rho(\\neg \\varphi)(\\omega, k) &:= -\\rho(\\varphi)(\\omega, k), \\\\ \\rho(\\varphi_1 \\lor \\varphi_2)(\\omega, k) &:= \\max \\left( \\rho(\\varphi_1)(\\omega, k), \\rho(\\varphi_2)(\\omega, k) \\right), \\\\ \\rho(F_{[a,b]}\\varphi)(\\omega, k) &:= \\max_{k'\\in[k+a,k+b]} \\left( \\rho(\\varphi)(\\omega, k') \\right), \\\\ \\rho(G_{[a,b]}\\varphi)(\\omega, k) &:= \\min_{k'\\in[k+a,k+b]} \\left( \\rho(\\varphi)(\\omega, k') \\right). \\end{aligned}$"}, {"title": "C. Definitions for Trajectory Repair", "content": "Without loss of generality, we assume from now on that all STL formulas are expressed in negation normal form (NNF) [77, Sec. IV.A]$^1$, where negations are restricted to predicates and are omitted in the definitions for simplicity. To establish an upper bound for determining the branching step $k_{cut}$, where the associated state is the cut-off state [72, Def. 1], we define:"}, {"title": "Definition 2", "content": "(Time-To-Violation [72, Def. 4]) The time-to-violation TV for a trajectory originating from $x_0$ with the input $u_{[0,h-1]}$ with respect to an STL formula $\\varphi$ is defined as:\n$\\begin{aligned} TV_p(u_{[0,h-1]}, k) &:= \\begin{cases} k & \\text{if } x(k, x_0, u_{[0,k-1]}) \\nvDash p, \\\\ \\infty & \\text{otherwise,} \\end{cases} \\\\ TV_{F_{[a,b]}}\\varphi (u_{[0,h-1]}, k) &:= \\max \\left( TV_{\\varphi_1}(u_{[0,h-1]}, k), \\\\ &\\quad \\max_{k+a \\leq k' \\leq k+b} TV_{\\varphi}(u_{[0,h-1]}, k') \\right), \\\\ TV_{G_{[a,b]}}\\varphi(u_{[0,h-1]}, k) &:= \\min_{k+a < k' < k+b} TV_{\\varphi}(u_{[0,h-1]}, k'). \\end{aligned}$"}, {"title": "Definition 3", "content": "(Time-To-Comply [72, Def. 5]) The time-to-comply TC is the latest time step before TV, at which a trajectory complying with $\\varphi$ exists:\n$TC_{\\varphi}^{ini}(u_{[0,h-1]}) := \\max \\left( \\{-\\infty\\} \\cup \\left\\{ k \\in \\left\\{ 0, \\dots, TV_{\\varphi}^{ini}(u_{[0,h-1]}, 0) \\right\\} \\middle| \\begin{aligned} &\\exists u_{[k,h-1]}: \\forall k' \\in [k, h - 1]: u_{k'} \\in U_{k'}, \\\\ &TV_{\\varphi}(u_{[k,h-1]}, 0) = \\infty \\end{aligned} \\right\\} \\right)$.\nHereafter, we assume that TV and TC are evaluated at time step 0 and omit their input dependency for brevity. If no violation of $\\varphi$ occurs, then $TC_{\\varphi} = TV_{\\varphi} = \\infty$.  Finally, we define reachable sets, which help us to find rule-compliant trajectories starting from the cut-off state:"}, {"title": "Definition 4", "content": "(Specification-Compliant Reachable Sets [36, Sec. II.C]) The exact specification-compliant reachable set $R_k(\\mathcal{X}_0, \\varphi)$ at time step $k$ is the set of states that can be reached from the set of initial states $\\mathcal{X}_0$ while complying with the specification $\\varphi$ from time step 0 to $k$:\n$\\begin{aligned} R_k(\\mathcal{X}_0, \\varphi) := \\left\\{ x(k, x_0, u_{[0,k-1]}) \\middle| & \\exists x_0 \\in \\mathcal{X}_0, \\forall k' \\in [0, k], \\\\ & \\exists u_{k'} \\in U_{k'}: x([0, k'], x_0, u_{[0,k' -1]}) \\models \\varphi \\right\\}. \\end{aligned}$"}, {"title": "D. Problem Formulation", "content": "We focus on traffic rules formalized in STL, where the only difference from MTL is that atomic propositions $\\sigma$ in MTL have to be expressed as predicates $p$ in STL [76]. Once $x^{ini}$ violates a rule $\\varphi$, i.e., $TV_{\\varphi}^{ini} \\neq \\infty$, our repairer aims to solve$^2$:\n$\\begin{aligned} & \\min_{u([k_{cut},h-1])} \\sum_{\\tau=k_{cut}}^h J(x_\\tau, u_\\tau) \\\\ &\\text{subject to} \\\\ &k_{cut} = \\underset{k}{\\text{arg max}} \\left\\{ k \\in [0, TV_{\\varphi}] \\middle| x([0, k], x_0, u_{k-1]) \\models \\varphi \\land R(\\mathcal{X}^{ini}, \\varphi) \\neq \\emptyset \\right\\}, \\\\ & \\forall \\tau \\in [0, k_{cut}]: x_\\tau = x^{ini}, \\\\ & \\forall \\tau \\in [k_{cut}, h - 1]: (1), u_\\tau \\in U_\\tau, \\\\ & \\forall \\tau \\in [k_{cut} + 1,h]: x_\\tau \\in R(\\mathcal{X}^{ini}, \\varphi). \\end{aligned}$\nInformally, our first goal is to preserve the maximum rule-compliant portion of the initial trajectory unchanged up to $k_{cut}$, while guaranteeing the existence of specification-compliant reachable sets from $k_{cut}$ onward (cf. (3b) and (3c)). Subsequently, we optimize the input trajectory $u([k_{cut}, h-1])$ under the system constraints in (3d), minimizing the cost function $J$ and ensuring rule compliance by maintaining the solution within the reachable sets in (3e)."}, {"title": "III. OVERVIEW OF THE TRAJECTORY REPAIR APPROACH", "content": "Within the outermost temporal operator, traffic rules are typically formalized to comprehensively cover all relevant situations, often expressed through disjunctions or implications [17]\u2013[19]. Consequently, satisfying only parts of the formula is sufficient to ensure that the entire formula is satisfied. To this end, we use a lazy SMT solver [78], which combines a SAT solver and a T-solver, to solve $\\varphi$ by automatically reasoning about smaller subformulas derived from its abstraction."}, {"title": "IV. PROPOSITIONAL TRAFFIC RULE ABSTRACTION", "content": "Our goal is to abstract the violated rules offline into a propositional logic formula that is sufficiently expressive for the SMT solver, while enabling effective online trajectory repair. To achieve this, we generalize the approach outlined in [72] by incorporating formula rewriting , distributive decomposition, and CNF conversion."}, {"title": "A. Formula Rewriting", "content": "To obtain a more compact formula with reduced nesting, each STL formula $\\varphi$ is rewritten into NNF $\\varphi^F$ [77]."}, {"title": "B. Distributive Decomposition", "content": "To further decompose $\\varphi$ into subformulas interconnected by disjunctions and conjunctions, denoted as $\\varphi^D$, we utilize the distributive properties of temporal operators [80, Sec. 3.6] [81, Prop. 1]. For instance, for G, we have:\n$\\begin{aligned} G(\\varphi_1 \\land \\varphi_2) &= G(\\varphi_1) \\land G(\\varphi_2), \\\\ G(\\varphi_1 \\lor \\varphi_2) &= G(\\varphi_1) \\lor G(\\varphi_2). \\end{aligned}$"}, {"title": "C. CNF Conversion", "content": "Subformulas in $\\varphi^D$ connected by logical connectives are replaced by propositional variables $\\sigma_j$, $j \\in \\mathbb{N}_+$, while those involving nested temporal operators are retained as intact units to preserve their structural integrity. This selective substitution simplifies the transformation of $\\varphi^D$ into an equivalent propositional formula $\\varphi^P$ in CNF, suitable for SAT solvers, using techniques such as the Tseitin transformation [82]."}, {"title": "V. SAT SOLVER", "content": "We employ the popular Davis-Putnam-Logemann-Loveland (DPLL) algorithm [83] to solve the Boolean satisfiability of $\\varphi^P$ online. Since the robustness quantifies the extent of violation or satisfaction, it can serve as a prioritization heuristic to determine the order of evaluated atomic propositions. The evaluation of STL robustness fundamentally relies on the robustness of predicates, which, however, is not included in Def. 1. Therefore, we begin by computing the model predictive robustness for the predicates in Sec. V-A, followed by the SAT solving process in Sec. V-B."}, {"title": "A. Model Predictive Robustness", "content": "The evaluation of robustness for STL formulas fundamentally relies on the robustness of predicates. To incorporate the dynamics of underlying system models (e.g., (1)) and streamline robustness evaluation across various predicates, we use model predictive robustness. The fundamental concept of model predictive robustness is to systematically assess the model capability for adhering to rule predicates.\n$\\rho_p(\\omega, k) := \\begin{cases} \\frac{|X_c|}{|X_{MC}|} & \\text{if } \\alpha(\\omega_k) > 0, \\\\ \\frac{|X_{MC} - X_c|}{|X_{MC}|} & \\text{otherwise,} \\end{cases}$"}, {"title": "VI. T-SOLVER", "content": "In the T-Solver, we solve (3) by replacing $\\varphi$ with the SAT solution $\\phi$ and determining the cut-off state of the initial trajectory at TC. Following [72, Alg. 2], we first compute $TC_{\\varphi}$ based on $\\phi$ and TV. Next, we compute the specification-compliant reachable sets starting from $TC_{\\varphi}$ in Sec. VI-B, followed by solving a convex optimization problem to obtain the repaired trajectory in Sec. VI-C."}, {"title": "A. Time-To-Comply Computation", "content": "Since considering all possible reachable states to calculate the exact $TC_{\\varphi}$ (cf. Def. 3) is computationally intractable, we employ an underapproximation that focuses on a selected set of maneuvers M [72, Sec. IV.C]. The goal is to alter the truth assignment of the atomic propositions $\\varphi_r \\subseteq \\varphi$, which differ in their values at TV, from the case where the propositional formula is satisfied, i.e., $[\\, \\varphi^P\\,] = \\top$. The maneuvers are automatically determined by the categories relative to the domains of the predicates within $\\varphi_r$, as outlined in Tab. II and illustrated in Fig. 6. Note that predicates within past-time temporal operators cannot guide actions for future compliance. Each maneuver is associated with a time-to-maneuver [85], representing the latest possible time at which the maneuver can still be executed to comply with and calculated using [88, Alg. 2]. According to Def. 3, $TC_{\\varphi}$ is then underapproximated by the maximum time-to-maneuver among the set M."}, {"title": "B. Specification-Compliant Reachability Analysis", "content": "After the cut-off state $x_{k_{cut}}$, we adopt the approach proposed in [35], [36] to compute the reachable sets against $\\phi$ in (3e) as the search space over the time interval $[TC_{\\varphi}, h]$. Since computing the exact reachable sets under specifications is infeasible for efficiency reasons [36, Sec. II.D], we use a tight overapproximation $R_k$ of $R$, that encloses all kinematically feasible and specification-compliant trajectories. Note that the distributivity of G over $\\lor$ in (6) imposes stricter rule requirements (cf. Rem. 1). To mitigate its impact of overly shrinking the valid solution space, we follow the syntactic timing separation theorem [81, Thm. 1] and relax $G_{[TC_{\\varphi},h]}\\varphi$"}, {"title": "C. Optimization-Based Trajectory Repair", "content": "Based on the reachable sets, we first extract a driving corridor [35, Sec. II.E] with no holes by applying utility functions such as spatial coverage. Then, we formulate a convex optimization problem [89] for finding repaired trajectories with a fast convergence. Setting $k_{cut}$ to $TC_{\\varphi}$, the problem in (3) over the time interval $[TC_{\\varphi}, h]$ aligns with the problem statement and can be addressed using the approach detailed in [90], with one addition: to enhance rule compliance, we include a robustness term in $J$ to minimize deviations from, e.g., the edges of reachable sets, where vehicle states with high robustness values are typically located. Since the reachable sets are tightly overapproximative, the computed trajectory may exhibit slight violations of $\\varphi$. Thus, we only return the repaired trajectory if it is verified to be rule-compliant."}, {"title": "VII. EXPERIMENTAL RESULTS", "content": "We showcase the usefulness of our framework to effectively address multiple rule violations and adeptly handle complex, real-world scenarios. Following the implementation details in Sec. VII-A, we focus on repairing multiple rule violations in Sec. VII-B. We then show the scalability of our approach to intersection traffic rules in Sec. VII-C, compare it with related work in Sec. VII-D, and analyze the computation time in Sec. VII-E. Finally, we validate our method for the first time through closed-loop planning tests conducted within the realistic CARLA simulator in Sec. VII-F and in the real world in Sec. VII-G."}, {"title": "B. Multiple Traffic Rule Violations", "content": "We begin by considering a highway scenario from the highD dataset, where the initial trajectory of the ego vehicle violates multiple traffic rules. As illustrated in Fig. 8, these violations include the safe distance rule $\\varphi_{G1}$ and the speed limit rule $\\varphi_{G3}$ [17]. We combine the violated rules using a conjunction as $\\varphi_{G1, G3}$: $\\varphi_{G1, G3} = \\varphi_{G1} \\land \\varphi_{G3}$,\nwith\n$\\begin{aligned} \\varphi_{G1} = &G(\\text{in\\_same\\_lane}(x_{ego}, x_{obs}) \\land \\text{behind}(x_{ego}, x_{obs}) \\\\ &\\Rightarrow \\neg O_{[0,t_c]}(\\text{cut\\_in}(x_{obs}, x_{ego}) \\\\ &\\lor P(\\text{cut\\_in}(x_{obs}, x_{ego}))) \\\\ &\\Rightarrow \\text{keeps\\_safe\\_distance\\_prec}(x_{ego}, x_{obs})) \\text{and} \\\\ \\varphi_{G3} = &G(\\text{keeps\\_lane\\_speed\\_limit}(x_{ego}) \\land \\\\ &\\text{keeps\\_type\\_speed\\_limit}(x_{ego}) \\land \\\\ &\\text{keeps\\_fov\\_speed\\_limit}(x_{ego}) \\land \\\\ &\\text{keeps\\_braking\\_speed\\_limit}(x_{ego})). \\end{aligned}$"}, {"title": "C. Intersection Traffic Rule Violation", "content": "In this section, we demonstrate our trajectory repair approach against typical intersection rules using inD scenarios.\n1) Stop Line Rule: Consider the stop line rule in (4), where a violation occurs if the ego vehicle fails to stop for $t_{slw}$ behind the stop line before crossing it, as shown in Fig. 9a. In the first iteration of the repair process, the SAT solver returns the solution $[\\, \\sigma_1 \\,] = \\top$ (cf. (8) and Tab. IV), which does not correspond to any maneuvers due to the presence of a past-time temporal operator in $\\sigma_1$. Consequently, the second iteration yields the solution $[\\, \\sigma_1 \\,] = \\bot$, $[\\, \\sigma_2 \\,] = \\top$, leading to braking and kick-down maneuvers, resulting in $TC_{\\varphi} = 12$. After performing reachability analysis and optimization-based trajectory repair, the initial trajectory is adjusted to slow down from $TC_{\\varphi}$ and come to a full stop before the stop line (cf. Fig. 9b).\n2) Priority Rule: Next, we consider a more complex rule rural priority rule $\\varphi_{IN4}$ [19], which prohibits the ego vehicle from entering an intersection if this action would pose a danger to another vehicle with the right of way:\n$\\begin{aligned} \\varphi_{IN4} = G(&\\text{obs\\_straight\\_ego\\_straight\\_obs\\_prio}(x_{obs}, x_{ego}) \\\\ &\\lor \\text{obs\\_straight\\_ego\\_left\\_turns\\_obs\\_prio}(x_{obs}, x_{ego}) \\\\ &\\lor ...\\text{combinations of turning directions}...)\\\\ &\\Rightarrow (G(\\text{not\\_endanger\\_intersection}(x_{ego}, x_{obs})) \\\\ &\\lor \\neg\\text{on\\_lanelet\\_with\\_type\\_intersection}(x_{ego}))), \\end{aligned}$"}, {"title": "D. Comparison with Related Work", "content": "To further support our claims in Sec. I, we compare our approach with a full trajectory replanning strategy, highlighting the advantages of partially adapting the initial trajectory.\n1) Replanning Using Mixed-Integer Convex Programming: The first comparison is with a state-of-the-art temporal logic motion planner based on mixed-integer convex programming (MICP) [98], [99], which encodes STL specifications in NNF over convex predicates using binary variables. To align with the repair setup (cf. Sec. VII-A2), the dynamics of the ego vehicle are modeled as fourth-order integrators for both longitudinal and lateral directions along $\\Gamma$. For simple predicates that map state variables to real values, we parameterize them based on the definition provided in [100, Sec. IV.C], facilitating the formulation of convex constraints. In more complex cases, we employ approximations to evaluate robustness while maintaining the soundness of the approach [84, Prop. 1]. For instance, for $\\neg \\text{in\\_intersection\\_conflict\\_area}()$, we overapproximate the exact conflict area with a polygon defined by its extreme (maximum and minimum) vertex coordinates in the curvilinear coordinate system (cf. Fig. 10b). The robustness is then computed as the signed distance to its longitudinal and lateral bounds. Furthermore, to primarily investigate the impact of the rules on computation time, we limit the collision avoidance constraints to obstacles within the same lane $L_{dir}$ as the ego vehicle. For solving the optimization problem, we employ Gurobi [94], consistent with our setup."}, {"title": "2) Replanning Using Sampling-Based Planner:", "content": "We adapt the popular sampling-based motion planner described in [11"}]}