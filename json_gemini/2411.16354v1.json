{"title": "Graph Neural Networks-based Parameter Design towards Large-Scale Superconducting Quantum Circuits for Crosstalk Mitigation", "authors": ["Hao Ai", "Yu-xi Liu"], "abstract": "To demonstrate supremacy of quantum computing, increasingly large-scale superconducting quantum computing chips are being designed and fabricated, sparking the demand for electronic design automation in pursuit of better efficiency and effectiveness. However, the complexity of simulating quantum systems poses a significant challenge to computer-aided design of quantum chips. Harnessing the scalability of graph neural networks (GNNs), we here propose a parameter designing algorithm for large-scale superconducting quantum circuits. The algorithm depends on the so-called 'three-stair scaling' mechanism, which comprises two neural-network models: an evaluator supervisedly trained on small-scale circuits for applying to medium-scale circuits, and a designer unsupervisedly trained on medium-scale circuits for applying to large-scale ones. We demonstrate our algorithm in mitigating quantum crosstalk errors, which are commonly present and closely related to the graph structures and parameter assignments of superconducting quantum circuits. Parameters for both single- and two-qubit gates are considered simultaneously. Numerical results indicate that the well-trained designer achieves notable advantages not only in efficiency but also in effectiveness, especially for large-scale circuits. For example, in superconducting quantum circuits consisting of around 870 qubits, the trained designer requires only 27 seconds to complete the frequency designing task which necessitates 90 minutes for the traditional Snake algorithm. More importantly, the crosstalk errors using our algorithm are only 51% of those produced by the Snake algorithm. For specific superconducting quantum chips in real experiments, the designer's outputs can serve as initial iteration values of traditional optimizers to enhance the designing performances. Overall, this study initially demonstrates the advantages of applying graph neural networks to design parameters in quantum processors, and provides insights for systems where large-scale numerical simulations are challenging in electronic design automation.", "sections": [{"title": "I. INTRODUCTION", "content": "Quantum computing may have applications in fields including cryptography [1], databases [2], computational chemistry [3], and machine learning [4]. Thus, large-scale quantum information processors are demanded to fully manifest the quantum advantages. Among various quantum computing platforms including neutral atom arrays [5] and trapped irons [6], superconducting quantum computing system based on Josephson junctions is a leading candidate [7\u201310]. Qubit numbers and the scales of quantum processors implemented by superconducting quantum electronic circuits (SQECs) are rapidly increasing. The numbers of quantum elements in superconducting quantum computing chip are now more than hundreds and even reach thousands, e.g. in chips of IBM company [11]. Due to the rapid growth of circuit complexity, the analysis and manual design on these large-scale SQECs are becoming challenging. Thus, the design automation for quantum computing systems aided by electronic computers or artificial intelligence is attracting more and more attentions [12\u201319].\nFor semiconductor integrated circuits, electronic design automation (EDA), also known as electronic computer-aided design, has achieved a high level of maturity [20]. Additionally, artificial intelligence has recently been applied to enhance the efficiency of semiconductor integrated circuit design automation [21\u201323]. However, due to the substantial differences in fundamental components, operating conditions, and operational modes between semiconductor integrated circuits and SQECs, it is difficult to directly apply traditional EDA techniques to the design of SQECs. Moreover, as the dimension of the Hilbert space exponentially scales with the number of qubits in quantum processors [24], the evaluation of the designed SQECs through numerical simulations is becoming a challenging task, which further complicates the automated design towards large-scale quantum processors. In this study, we focus on the automated design of working parameters in SQECs with given structures. In previous studies, the Snake algorithm was developed for designing parameters in large-scale SQECs [25, 26] and was applied in the context of Google's Sycamore processor [7].\nSimilar to the graphic representation of semiconductor integrated circuits, SQECs can be readily conceptualized as graph structures. This inspires us to achieve automated parameter design for large-scale SQECs by utilizing the scalability of graph neural networks [27, 28] (GNNs). Within the graphic structures, the qubits for storing and processing quantum information are considered as nodes. Meanwhile, nearest neighbor coupled-qubit pairs represent edges in the graphs. The configuration of parameters on each node and edge can significantly impact the performance of quantum comput-"}, {"title": "II. ALGORITHM", "content": "Our GNNs-based algorithm can design parameters for a coupled-qubit graph conceptualized from a given SQEC, in which various parameters of nodes (qubits) and edges (coupled-qubit pairs) need to be designed for mitigating errors of quantum computing [26, 33]. Some of the parameters are considered graph-independent, which can be designed and optimized individually. While other parameters may have graph-dependent effects, i.e., the parameters of certain node or edge may impact the neighboring nodes and edges. This requires a comprehensive consideration of the entire graph during the designing process. Furthermore, the error dependence on the graph-dependent parameters is complicated, for example, parameters optimized for one node may cause large errors on other nodes. Consequently, powerful algorithms should be implemented to achieve the optimal design of the parameters. Thus, the following studies are based on the graphs conceptualized from SQECs, as schematically shown in Fig. 1(a).\nThe GNNs-based parameter designing algorithm con-siders parameters of nodes and edges, and includes errors from influences of higher-order neighbors (e.g., 2-hop, 3-hop neighbors). As illustrated in Fig. 1, graphs with three scales are involved, i.e., small-scale graphs denoted as stair-1, medium-scale graphs denoted as stair-2, and large-scale graphs denoted as stair-3. The three stairs are connected via two neural-network models: the evaluator and the designer. The evaluator is supervisedly trained on small-scale graphs, and is applied to medium-scale graphs. While the designer is unsupervisedly trained on medium-scale graphs to be applied to large-scale graphs. First, as shown in Fig. 1(b), training data for the evaluator is collected on several small graphs, where a variety of parameter assignments are randomly generated as input labels, and corresponding errors are numerically simulated to serve as output labels. Then the evaluator is trained through supervised learning. As demonstrated in Fig. 1(c), the evaluator employs multiple graph-based MLPs to predict errors based on the graph structure, parameter assignment, and type of quantum operations. When training the evaluator, mean square errors (MSES) are calculated as loss functions, and the corresponding gradients are used for backpropagation. After training the evaluator, it can be directly applied for parameter assignments on medium-scale graphs, e.g., Fig. 1(d). Unsupervised learning is employed to train the designer using the errors obtained by the evaluator. As illustrated in Fig. 1(e), the designer integrates GNNs and MLPs to determine optimal parameters for nodes and edges based on the input graphs and trial parameters. In each training iteration, a batch of medium-scale graphs is randomly created as input data for the designer, e.g., in Fig. 1(f), some of the nodes and edges are randomly removed from several fundamental graphs. Subsequently, the designer outputs a parameter assignment for each graph as shown with Fig. 1(d), and the corresponding average error is estimated using the trained evaluator. After training the designer on medium-scale random graphs, the scalability of GNNs enables the trained designer to be directly applied to graphs of various structures and scales, including large-scale ones as exemplified with Figs. 1(g) and (h). Additionally, leveraging the parallelism capabilities of machine learning frameworks such as PyTorch [48] and TensorFlow [49], we can further enhance the performance on specific graphs by generating diverse sets of trial parameter assignments and utilizing the designer in batches.\nAs an essential property making the algorithm effective, the generalization ability of the evaluator is guaranteed in two ways. First, extra graphs only for testing purposes are introduced as depicted in Fig. 2(a). The extra testing graphs ensure that the trained evaluator can be applied to graphs with different underlying structures. Second, the influence of the parameters in question should be localized. In other words, for two nodes, e.g., Ni and Nk in a graph, the undesired impact from Ni to Nk decays exponentially with the distance between the two nodes, as illustrated in Fig. 2(b). The localized na-ture of the parameters is essential for the evaluator, which ensures that the MLPs trained on small-scale graphs remain effective for larger-scale ones. For the designer, considering the errors' dependence on higher-order neighboring parameters, we apply higher-order graph convolutional networks (GCNs) to solve the problem. The architecture of high-order GCNs used here is inspired by some similar GNNs [50, 51]. As exemplified in Fig. 2(c), a layer of higher-order GCN is defined as\n$F^{(l+1)} = \\sigma (A_0F^{(l)}W_0 + A_1F^{(l)}W_1 + A_2F^{(l)}W_2 +... )$,\nwhere $A_p = (D_p)^{-1/2}(A_p + I)(D_p)^{-1/2}$ (with p = 0,1,2,...) stands for the normalized p-th order adjacency matrix, where I is the identity matrix and $(D_p)_{ik} = \\sum_k (A_p + I)_{ik}$. $(A_p)_{ik} = 1$ if the distance of Ni and Nk is p, otherwise, $(A_p)_{ik} = 0$. $F^{(l)}$ is the feature matrix of the l-th layer, $W_i$ is the trainable weight, and $\u03c3(\u00b7)$ is the nonlinear activation function. The architecture of designer is shown in Fig. 2(e), with more details available in the Methods section and supplementary materials [43].\nThe proposed algorithm is demonstrated with the task of designing frequencies in SQECs to mitigate quantum crosstalk errors. In other words, node and edge frequencies are selected as parameters to be designed by our algorithm. Three types of quantum operations are involved in the following discussion, including single-qubit Rx operation (for nodes), single-qubit Ry operation (for nodes) [44], and two-qubit Rxy operation via the XY interaction (for edges) [52]. These three types of quantum operations can be used to build universal quantum computation. Quantum crosstalk errors usually occur when performing quantum operations. Based on the system details outlined in the Methods section, the average crosstalk excitations on a specific node Nk resulting from quantum operations on node Ni (or edge Eij) solely depend on the operation type, graph structure, and frequency assignment. These dependencies delineate the inputs and architecture of the evaluator. Extensive datasets are generated for training, validating, and testing the evaluator. Following the training of the evaluator, the designer undergoes training and testing in accordance with the evaluator's estimations, showcasing its superiority over other alternative algorithms."}, {"title": "III. TRAINING AND TESTING", "content": "The evaluator. After generating the datasets through numerical simulations, the evaluator is trained, validated, and tested in a supervised learning manner. The evaluator consists of multiple MLPs. Each MLP serves for one type of quantum operations and predicts the average crosstalk excitation on a node Nk resulting from operations on node Ni (or edge Eij), where k \u2260 i, j. The inputs of the MLP are the relevant node and edge frequencies denoted by $\\tilde{\u03c9}$ and the distances represented by the elements of adjacency matri-ces, i.e., $A_k$ (together with $A_k^2$ for two-qubit opera-tions). To maintain consistency in the outputs of the MLPs, the crosstalk errors in the simulated datasets are transformed using base-10 logarithms. Thus, the losses of the MLPs are determined by the corresponding MSES,\n$L_{evaluator} = |O|^{-1} \\sum_{\\lambda \\in \\Lambda_O} \u03b4_{O,\u03bb}^2$, and\n$\u03b4_{O,\u03bb} = |MLP_O(\\tilde{\u03c9}_\u03bb, A_\u03bb^1, A_\u03bb^2, ...) - \\log_{10}(E_{O,\u03bb})|$,\nwhere O is the type of quantum operations, \u03bb is a specific index of data in the operation's dataset \u039bO with the size |\u039bO|, and Eo,\u03bb is the simulated crosstalk error.\nThe crosstalk errors smaller than e.g., 1 \u00d7 10\u22124, or larger than, e.g., 1 \u00d7 10\u22121, are not concerned, because excessively small crosstalk errors usually do not dominate the error components, while larger ones exhibit strong randomness. Individual MLPs are supervisedly trained for different types of quantum operations, with the resulting MSEs and r2 for the training, validation, extra validation, testing and extra testing sets presented in Tab. I.\nThe coefficient of determination r2 exceeds 0.9 for each case, indicating a strong ability of the evaluator to fit the dataset [53]. More details are available in the Methods section and the supplementary materials [43].\nTo demonstrate the reliability of the trained evaluator, we select various frequency assignments on a linear graph with 6 qubits numbered sequentially 'Q0 \u2212 Q1 \u2212 Q2 \u2212 Q3 \u2212 Q4 \u2212 Q5', and compare the numerical simulation results with the fitting results from the evaluator. In Figs. 3(a)-(i), the solid blue lines describe the results from numerical simulations, while the dashed red lines represent the fitting results from the evaluator, and the two results agree well with each other. For single-qubit operations, we vary the node frequency \u03c90 of qubit Q0 while maintaining the other frequencies constant. The crosstalk excitations on qubits Q1, Q2 and Q3 are plotted to signify the crosstalk errors induced by single-qubit operations. For two-qubit operations, we scan the edge frequency of coupled-qubit pair (Q2,Q3) with the other frequencies unchanged, and plot the crosstalk excitations on qubits Q1, Q4 and Q5. It should be noted that minor discrepancies between the fitting results and the simulations are permissible, provided that the evaluator can guide the training of the designer.\nThe designer. As shown in Fig. 1, during the training of the designer, medium-scale graphs G = (N,E) with nodes N and edges E are randomly generated and input into the designer to output a frequency assignment \u03c9 for each graph. The trained evaluator estimates the crosstalk errors for a particular \u03c9 on corresponding G. Then the designer's loss could be calculated,\n$L_{designer}(G, \u1ff6) = \\frac{1}{|N|} \\sum_{N_i \\in N} \\sum_{N_k \\neq N_i} E_{Rx, N_i \\rightarrow N_k}$\n$\\frac{1}{|N|} \\sum_{N_i \\in N} \\sum_{N_k \\neq N_i} E_{Ry, N_i \\rightarrow N_k}$\n$\\frac{1}{|E|} \\sum_{E_{ij} \\in E} \\sum_{N_k \\neq N_i, N_j} E_{Rxy, E_{ij} \\rightarrow N_k}$,\nFirst, the estimated crosstalk errors, e.g., ERx,Ni\u2192Nk,\non different nodes Nk are summed to obtain the total crosstalk error of operations on node Ni (or edgeEij). Second, the node(edge)-related errors are subsequently averaged to get the errors for one specific type of quantum operations. Then, the crosstalk errors of all three types of quantum operations are summed up to obtain the comprehensive quantum crosstalk error, serv-"}, {"title": "IV. DISCUSSIONS", "content": "We apply two graph-based neural-network models named evaluator and designer to tackle the challenge of mitigating quantum crosstalk errors in large-scale SQECs. The evaluator undergoes training, validation, and testing on three 6-qubit graphs. Moreover, additional validation and testing are conducted on two extra 6-qubit graphs to verify the evaluator's generalization ability. Following the evaluator's training, the designer is unsupervisedly trained on randomly generated medium-scale graphs, based on the errors estimated by the evaluator. The designer incorporates high-order graph convolutional networks, enables its direct applications to graphs of diverse structures and scales. According to our tests, the designer outperforms traditional optimization algorithms in both efficiency and effectiveness, particularly for large-scale SQECs. The proposed algorithm can be integrated with real experiments from two perspectives. On the one hand, the simulation data used to train the evaluator can also be collected through experiments. Even in cases where the experiment can only generate limited data, the MLPs in the evaluator can be substituted with simpler models that consider more theoretical insights. On the other hand, the parameter assignments provided by the designer can serve as initial optimization values which closely approximate the optimal experimental settings. In the future research, additional error sources and variations between qubits may be taken into account, thus the practicality of the proposed algorithm can be further enhanced.\nThe 'three-stair scaling' mechanism harnesses the scaling benefits of graph neural networks, paves the way for EDA in the realm of large-scale SQECs. Considering the scaling challenge commonly exists in simulat-"}, {"title": "V. DATA AND CODE AVAILABILITY", "content": "The dataset generated by numerical simulations, the code for training, validating and testing the models, together with the trained models will be open-soured after"}, {"title": "Appendix A: Physical System", "content": "The building block of SQECs is the interconnected 'qubit-coupler-qubit' subsystem [46] as schematically shown in Fig. 5(a), where three frequency-adjustable transmons [47] are capacitively coupled in pairs. The middle one functions as the tunable coupler, which is now extensively utilized in SQEC experiments, e.g. in Refs. [7, 8]. The building-block Hamiltonian of SQEC is\n$H = \\sum_{i \\in Q \\cup C} \u0127\u03c9_i(t)a_i^\u2020 a_i + \\frac{\u0127\u03b1_i}{2}(a_i^\u2020 a_i)^2$\n$+ \\sum_{i, j \\in Q \\cup C} \u0127g_{ij} (a_i^\u2020 a_j + a_j^\u2020 a_i)$\n$+ \\sum_{i \\in Q} \u03a9_x^i(t) cos[\u03c9_d^i(t)t] (a_i^\u2020 + a_i)$\n$- \\sum_{i \\in Q} \u03a9_y^i(t) sin[\u03c9_d^i(t)t] i(a_i^\u2020 - a_i)$,\nwhere \u0127 is the reduced Plank's constant. The set C only includes the middle transmon acting as the coupler, while the set Q includes other two transmons as the qubits. \u03c9i(t) is the eigen-frequency of the first excitation, ai and $a_i^\u2020$ are the annihilation and creation operators of the i-th transmon, respectively. We assume that all three transmons have the same anharmonicity \u03b1 for simplicity of discussions. The parameter gij denotes the coupling strength between the i-th and the j-th transmons, $\u03c9_d^i(t)$ and $\u03a9^i(t)$ are the driving frequencies corresponding to the driving strengths $\u03a9_x^i(t)$ and $\u03a9_y^i(t)$ for different single-qubit operations [10]. We note that the time-dependent terms can be controlled or devised by the experimenters.\nIn this building block, the two qubits typically have the resonant or near resonant frequencies, while the middle coupler is often detuned significantly from two qubits. Thus, the coupler mode can be equivalently eliminated, leading to the weak effective ZZ and XY couplings between two qubits [33], as illustrated in Fig. 5(b). According to the definition [33, 55], the ZZ coupling can be given as\n$g_{ZZ}^{eff} = (E_{|110\\rangle} - E_{|100\\rangle}) - (E_{|010\\rangle} \u2013 E_{|000\\rangle})$,\nwhere $E_{|Q_0,Q_1,C\\rangle}$ represents the energy corresponding to the state |Q0, Q1, C\u232a, in which qubit Q0, qubit Q1 and"}, {"title": "Appendix B: Quantum Operations", "content": "Quantum crosstalk commonly arises during quantum operations, also called as quantum gates. We select single-qubit Rx, Ry [44], and two-qubit Rxy operations [52] as the fundamental quantum gates. According to the quantum computation principles, these three types of operations can be combined to construct universal quantum computation [44]. Fig. 5(e) illustrates the control for the frequencies of qubits, coupler and driv-"}, {"title": "Appendix C: Crosstalk Analysis", "content": "In order to quantitatively describe quantum crosstalk, the undesired excitations occurring on a specific qubit Qk are simulated when single-qubit (or two-qubit) operations are applied to qubit Qi (or coupled-qubit pair Q&Qj) with k\u2260 i, j. We define such excitations on Qk as crosstalk errors from node Ni (or edge Eij) to node Nk. In our simulations, Qi is (or Q&Qj are) initialized to some excited states, while Qk is set in its ground state. After finishing the simulation, the average excitation on Qk is calculated to reflect the crosstalk error under the corresponding configurations.\nFor a given type of quantum operations, the main factors influencing crosstalk errors include the qubit frequencies, the qubit distances within the graph, the inter-qubit coupling strengths, the driving strengths of single-qubit operations, and the time durations of operations.\n1.  Qubit frequencies: Qualitatively, because the conservation of both energy and excitation number must be satisfied simultaneously, the quantum crosstalk error between two qubits is expected to increase as their frequency difference decreases [43]. As shown in the black lines in Figs. 5(g) and (h), the correlations between nearest-neighbor crosstalk errors and frequency differences are evident, which facilitates the fitting with neural networks.\n2.  Qubit distances within the graph: Given that the distant qubits can only interact through weak indirect or parasitic couplings [45], the quantum crosstalk error between them would significantly decrease with the increase of their distance, as exemplified in Fig. 2(b). Qubit distances are also taken into account by the evaluator to estimate quantum crosstalk errors.\n3.  Coupling and driving strengths: The coupling strengths between two qubits (or between a qubit and a coupler) and the driving strengths for single-qubit operations can also influence quantum crosstalk errors. The decrease of the coupling and driving strengths generally helps to mitigate crosstalk errors, but this often impacts the efficiency of quantum operations [33]. Moreover, the trade-off and adjustment of coupling and driving strengths are independent on the graph structure, thus their values are fixed in this study.\n4.  Time durations of operations: As demonstrated in Figs. 5(g) and (h), time durations could affect crosstalk excitations when single- or two-qubit operations are implemented. Nevertheless, when other parameters are given, the time duration for a specific operation is determined by the user-input parameters, such as the rotation angle of Rx gate. Therefore, crosstalk errors are averaged over multiple time durations in our numerical simulations.\nIn this work, classical resources of errors are not considered. For example, defects in fabrication [56] and distortions in modulating microwave pulses [57] can also affect the quality of quantum information processing. Additionally, when signals are applied through specific control lines, the microwave current induced magnetic fields may introduce unwanted signals in other control lines, leading to what is known as classical crosstalk. Many works are studying the mitigation of classical crosstalk errors [58\u201360]. The classical resources of errors are not taken into account in this study, because they are usually graph-independent.\nIn a word, after the coupling and driving strengths are given and multiple operating time durations are averaged, the quantum crosstalk errors only depend on the node and edge frequencies, graph structures, and operation types. Thus, neural networks can be trained to evaluate the frequency assignments for quantum crosstalk mitigation."}, {"title": "Appendix D: Numerical Simulations", "content": "To simulate quantum operations, the Hamiltonian in Eq. (A1) is transformed into a rotating frame with the rotating wave approximations [61]. Taking the single-qubit Rx operation applying on qubit Q0 as an example, the transformed Hamiltonian without other operations in Eq. (A1) is given as\n$H = \\sum_{i \\in Q \\cup C} (\u03c9_i - \u03c9_0)a_i^\u2020 a_i + \\frac{\u0127\u03b1_i}{2} (a_i^\u2020 a_i)^2$\n$+ \\sum_{i, j \\in Q \\cup C} \u0127g_{ij} (a_i^\u2020 a_j + a_j^\u2020 a_i) + \u0127\u03a9_0 (a_{Q_0}^\u2020 + a_{Q_0})$,\nwhich can be numerically solved to obtain an expected quantum operation. We note that all quantum states involved in numerical simulations for quantum operations are dressed states [42], which can be directly measured in real experiments.\nIn our simulations, the adjustable qubit frequencies are assumed to be in the range of 4.9 to 5.1 GHz. The coupler frequencies are aligned along the ZZ-free line, which are around 6.0 GHz. Other parameters are assumed as follows. The anharmonicity of each qubit and coupler are 300 MHz. The direct qubit-qubit coupling is 10 MHz, the qubit-coupler coupling is 100 MHz, the single-qubit driving strength is 25 MHz, and the driving frequency matches the corresponding qubit frequency. Residual coupling between higher-order neighboring qubits due to parasitic capacitance is also taken into account [33, 45], which is 0.1 MHz between 2-hop neighboring qubits and 0.01 MHz between 3-hop neighboring qubits.\nAccording to the definition, the quantum crosstalk errors from node Ni (or edge Eij) to node Nk are simulated. When focusing on the single-qubit operations on qubit Qi, and taking Rx operations as an example, we assume that the quantum state of Qi is initialized to $ |\u00b1\\rangle_i = (|0\\rangle_i + |1\\rangle_i)/\\sqrt{2}$, while the other qubits are initialized to their ground states. In our simulations, 20 operation time durations are uniformly sampled in a range from 0 to 2\u03c0/\u03a9, corresponding to rotating angles of Rx operations uniformly sampled from 0 to 2\u03c0. Thus, the undesired excitations on qubit Qk across these 40 scenarios are simulated and averaged to represent the crosstalk error from Qi to Qk when Rx operations are implemented. For two-qubit operations applied to the coupled-qubit pair (Qi, Qj), the initial states are assumed to be $ |+\\rangle_i |+\\rangle_j$ or $ |-\\rangle_i |-\\rangle_j$, with the remaining qubits in their ground states. In our simulations, 20 time durations ranging from 0 to $2\u03c0/g_{XY}^{eff}$ are also uniformly sampled. Similar to the approach taken for single-qubit operations, 40 crosstalk excitations from coupled-qubit pair (Qi, Qj) to Qk are simulated and averaged.\nThe dataset used for training, validating, and testing the evaluator is generated on small graphs as shown in Fig. 2(a), which are the most common qubit coupling structures. Specifically, 25, 600 sets of node and edge fre-"}, {"title": "Appendix E: Evaluator: Graph-Based MLPs", "content": "The evaluator comprises multiple MLPs to estimate the errors associated with different types of quantum operations. Each MLP is tailored to a specific type of quantum operations, such as Rx, Ry, or Rxy operations. These MLPs are trained to output the base-10 logarithm of respective crosstalk errors, while the inputs for single- and two-qubit operations are slightly different. The MLPs for single-qubit operations are trained to predict the undesired excitations from one node to another. Taking the average crosstalk error of Rx operation from node Ni to node Nk as an example, the MLP takes the node frequencies wi,wk and the corresponding matrix elements $(A_p)_{ik}$ as inputs, where $(A_p)_{ik}$ denotes the element of the p-th order adjacency matrix as defined before. The MLP for two-qubit Rxy operations can evaluate the crosstalk error from edge Eij to node Nk, where k\u2260i,j. Similar to the case of single-qubit operations, the inputs for two-qubit operations encompass the node frequencies wi, wj, wk, the edge frequency Wij, as well as the matrix elements $(A_p)_{ik}$ and $(A_p)_{jk}$. Each MLP comprises 4 hidden layers, each with 32 neurons. Further details can be found in the supplementary materials [43]."}, {"title": "Appendix F: Designer: GNNs and MLPs", "content": "As shown in Fig. 2(d), the designer is used to design parameters on both nodes and edges within the input graphs. Given a batch of graphs and random node frequencies as inputs, a deep high-order GCN and an MLP can assign frequencies for each node, which constitute part of the designer's output. Subsequently, these node frequencies serve as inputs for another high-order GCN to output new node features, which are then aggregated by edges and fed into an MLP. For an edge Eij, with a softmax function applied to the two output-layer neurons, the MLP generates the selection preferences pi and pj for the respective edge frequency wij from its two node frequencies wi and wj. Ultimately, each edge's frequency is determined by\n$w_{ij} = p_i w_i + p_j w_j$.\nThus another part of the designer's output is obtained. In this work, the three-order GCN for node frequencies"}, {"title": "Appendix G: Traditional Methods", "content": "In addition to the GNNs-based designing algorithm proposed in this study, three traditional methods are also discussed for comparisons. These include the direct utilization of a gradient-free optimization algorithm (DirectOptim), the direct application of gradient descent algorithm (GradAlg), and the Snake algorithm for large-scale graphs [25, 26].\n1.  Direct Optim: A straightforward consideration for the parameter designing problem is to utilize feedback-based optimization algorithms [62] to find available parameter assignments for specific coupled-qubit graphs directly, as shown in Fig. 7. For a specific graph as exemplified in Fig. 7(a), randomly generated trial parameters for all the nodes and edges are input into the optimizer. The optimizer, shown in Fig. 7(b), iteratively explores new parameter assignments, such as Fig. 7(c). In Fig. 7(d), the assignments are given to the evaluation module to assess the corresponding errors. The evaluation module can utilize real experiments for small-scale SQECs or employ the trained evaluator for larger-scale SQECs. Then the errors are fed back to the optimizer to ultimately obtain an appropriate parameter assignment.\n2.  GradAlg: The direct application of gradient descent algorithm is similar to DirectOptim, which replaces the gradient-free optimizers in DirectOptim with gradient descent algorithms. Since the errors under given frequency assignments can be estimated through the evaluator, the corresponding gradient information is available after the errors are calculated. So, gradient descent algorithms can be utilized to find the frequency assignments with mitigated errors.\n3.  Snake: Due to the low computational efficiency, DirectOptim and GradAlg are not applicable for large-scale SQECs. Snake algorithm was proposed as an improvement of direct optimization by dividing the entire graph into multiple small-scale subgraphs and sequentially applying the optimizer to optimize these subgraphs [25, 26]. Thus, Snake algorithm can be used to design parameters for larger-scale graphs, such as the Sycamore processor, which is said to be the first to achieve quantum supremacy [7].\nAll these traditional algorithms overlook the graph structures established by the qubits and their couplings. This oversight may significantly impact the effectiveness and efficiency of optimization when considering large-scale graphs.\nIn our tests, both GNNs-based designing algorithm and the three traditional algorithms leverage the trained evaluator to estimate the crosstalk errors. For Snake and DirectOptim, Powell optimizer is employed [63], and all other settings adhere to the default settings provided by Scipy [62]. The scope of Snake is 4, which is the best choice in Ref. [26]. Among these four algorithms, the GNNs-based designer and Snake are available for large-scale graphs, whereas the other two are limited to medium-scale graphs due to their inefficiency. On the other hand, the GNNs-based designer and GradAlg require gradient information from the evaluator, while the"}]}