{"title": "The Complexity of Symmetry Breaking Beyond Lex-Leader", "authors": ["Markus Anders", "Sofia Brenner", "Gaurav Rattan"], "abstract": "Symmetry breaking is a widely popular approach to enhance solvers in constraint programming, such as those for SAT or MIP. Symmetry breaking predicates (SBPs) typically impose an order on variables and single out the lexicographic leader (lex-leader) in each orbit of assignments. Although it is NP-hard to find complete lex-leader SBPs, incomplete lex-leader SBPs are widely used in practice.\nIn this paper, we investigate the complexity of computing complete SBPs, lex-leader or otherwise, for SAT. Our main result proves a natural barrier for efficiently computing SBPs: efficient certification of graph non-isomorphism. Our results explain the difficulty of obtaining short SBPs for important CP problems, such as matrix-models with row-column symmetries and graph generation problems. Our results hold even when SBPs are allowed to introduce additional variables. We show polynomial upper bounds for breaking certain symmetry groups, namely automorphism groups of trees and wreath products of groups with efficient SBPs.", "sections": [{"title": "Introduction", "content": "The search space of a constraint program can exhibit a large amount of symmetry. This simple yet far-reaching observation forms the core principle behind the use of symmetry based approaches in the realm of constraint programming [24, 45]. Such methods prune the symmetric parts of the search space to save computational costs. Ideally, they ensure that at most one solution exists per equivalence class of candidate solutions. Over the last two decades, numerous methods have been proposed to exploit symmetries of constraint programs. In particular, many approaches have been developed for Boolean satisfiability solvers [15, 1, 14, 18, 28, 31, 17, 44, 39] as well as mixed integer programming [36, 40, 41]. Symmetry-based solving remains an active and fruitful area of interest, especially from a practical perspective: for example, the defining feature of arguably one of the most successful entries in the SAT competition 2023 was symmetry breaking [12, 11].\nHow symmetries should be used best remains unclear. Approaches can be roughly divided into two different categories: in dynamic and static approaches. In a dynamic approach, symmetries are used during the execution of a solver [44, 19, 17, 39]. A typical example is that the solver incorporates a branching rule that makes use of the symmetries directly [44].\nThe second approach is the static use of symmetries, which is the main focus of this paper. Here, additional constraints, so-called symmetry breaking predicates (SBPs), are added to a given problem instance. The notion of SBPs was first introduced in the seminal paper of Crawford, Ginsberg, Luks and Roy [15]. Their goal was to generate polynomial-sized SBPs for SAT formulas in conjunctive normal form (CNF). However, since their framework is rooted in group theory, many results neatly generalize to other constraint languages.\nThe framework of Crawford et al., as well as the majority of the subsequent work in this area, uses so-called lex-leader predicates to achieve complete symmetry breaking. Using incomplete lex-leader predicates is arguably one of the most successful approaches to symmetry breaking in practice [1, 18]. On a complexity-theoretic level, however, Crawford et al. proved that computing a predicate true of only the lex-leader in each equivalence class of Boolean assignments is NP-hard. Subsequent results showed that this even holds true for restricted classes of groups [35], as well as orders similar to lex-leader [30, 47].\nOne may wonder whether there are other kinds of SBPs that are efficiently computable. Here, other kinds of SBPs simply means that they do not make use of a lexicographic ordering of the assignments. In principle, choosing any canonical representative among symmetric assignments is permissible, lex-leader or otherwise. This question is motivated, for instance, by the realm of graph isomorphism (GI). There, choosing the lex-leader is also known to be NP-hard [7], and the best theoretical and practical approaches make use of other mechanisms.\nConcerning practical symmetry breaking, only a few, though surprisingly different, ap-proaches of generating non-lex-leader SBPs have been explored. In [23], the global cardinality constraint [43] is used in conjunction with lex-leader constraints to efficiently handle (particular) wreath symmetry. In [14], SAT symmetry breaking constraints for graph problems are produced similarly to the canonical labeling algorithm NAUTY [38]. In [26], minimal SAT symmetry breaking constraints are generated for small groups.\nIn general, however, the complexity of SBPs remains largely unexplored, even for fairly restricted kinds of symmetries. Perhaps the most glaring example is the problem of breaking row-column symmetries, which arise in the so-called matrix models [21]. These models allow the decision variables to be arranged in a matrix such that interchanging any two rows or any two columns is a symmetry of the model. Matrix models arise in multiple areas of constraint programming such as scheduling, combinatorial problems, and design [22]. Perhaps the most well-known matrix model is the pigeonhole principle problem, for which it is NP-hard to compute the lex-leader or similar assignments [15]. While the problem of devising SBPs for such models has received much attention [21, 30, 24], the known results do not explain the lack of compact SBPs for matrix models."}, {"title": "1.1 Our Results", "content": "The objective of this paper is to further investigate the exact complexity of computing static symmetry breaking predicates. Given a group of symmetries on the variables of a formula, how hard is it to generate a complete symmetry breaking predicate? The ultimate goal of our work is to obtain a classification of symmetry groups, in terms of the complexity of computing SBPs. Such a classification could help inform practitioners as to which cases can be handled easily, and which ones are more challenging.\nIn order to simplify the exposition, our setting of choice is that of Boolean satisfiability testing (SAT). However, in the same vein as [15], our results are founded in a general group-theoretic setting, so they should easily transfer to many branches of constraint programming: we consider computing symmetry breaking predicates for a given permutation group, instead of a particular SAT formula exhibiting such symmetry.\nOur results can be divided into hardness results and upper bounds. The high-level idea for the hardness results can be summarized as follows: We show that if symmetry breaking is feasible for certain expressive groups, such as matrix groups or Johnson actions, then graph isomorphism is in coNP. The containment GI \u2208 co-NP is a major unresolved problem [32], even for the restricted case of group isomorphism [5]. While GI \u2208 co-NP seems to have no other major complexity theoretic consequences and is seemingly not \u201cimplausible\u201d, it still poses a barrier to compact SBPs.\nThe idea of our reductions is to encode the input graphs as binary strings in a suitable way, then guess a canonizing permutation, and use the symmetry-breaking constraint to verify that the result is indeed the canonical form: By definition, the symmetry-breaking constraint is true of precisely the canonical forms. The graphs are non-isomorphic exactly when the canonical forms are different. As a strengthening, we show that this holds even when the symmetry breaking constraint uses additional variables as their values can be guessed as well.\nWe now explain our hardness results in greater detail.\nMatrix Models. Our first result tackles the difficulty of breaking row-column symmetries in matrix models. As mentioned above, this problem has received much attention in symmetry breaking literature.\nTheorem 1.1. Suppose there exists a polynomial time algorithm for generating complete symmetry breaking predicates for row-column symmetries. Then GI \u2208 co-NP holds, i.e., graph non-isomorphism admits a non-deterministic polynomial time algorithm.\nOur theorem explains the difficulty of obtaining compact symmetry breaking predicates for matrix models, in the sense that it would imply polynomial time algorithms for certifying graph non-isomorphism. Section 3.1 contains a detailed description of our result.\nJohnson Actions. We identify yet another class of groups for which symmetry breaking is hard, namely the (k,t)-Johnson groups. These are symmetric groups Sym(k) acting on t-subsets of [k] for fixed t < k. It is well-known that these actions form an important sub-case of Babai's quasi-polynomial algorithm for graph isomorphism [5].\nTheorem 1.2. Let t > 1 be a fixed positive integer. Suppose that we can generate complete symmetry breaking predicates for all (k, t)-Johnson groups in polynomial time (in terms of the domain size). Then GI \u2208 coNP holds.\nSection 4 contains a formal description of this result. In fact, it follows from Theorem 4.3, which proves a stronger statement.\nCertificates for Canonization. We strengthen our hardness results of Theorem 1.1 and Theorem 1.2 as follows. We allow an algorithm to produce more expressive SBPs:\n1. The SBP can be given as a Boolean circuit.\n2. The SBP is allowed to introduce additional variables. Essentially, this gives the predicate access to additional non-determinism. The SBP may introduce an arbitrary number of additional variables, as long as the overall size is polynomial.\nDespite allowing more powerful SBPs, we conclude a stronger hardness implication: an effi-cient algorithm for such predicates implies an efficiently verifiable graph canonical form (see Theorem 3.4 and Theorem 4.2). Note that an efficient verifier for graph canonical forms implies an efficient verifier for graph non-isomorphism (Lemma 3.3), but the converse is unknown.\nFor this result, we observe that SBPs for a permutation group G on the domain [n] essen-tially solve a particular decision version of the string canonization problem w.r.t. G on strings of length n. String canonization is a fundamental problem of interest in the graph isomorphism"}, {"title": "2 Preliminaries", "content": "In summary, Figure 1 provides a concise description of our progress towards a complexity classification for the problem of generating SBPs for permutation groups."}, {"title": "2.1 Boolean Circuits and Satisfiability", "content": "Boolean Circuits. A Boolean circuit $4$ is a circuit consisting of input gates, one output gate, and {AND, OR, NOT}-gates connecting them in the usual way. We refer to the input gates as the variables Var(4). The size of a circuit refers to the number of gates.\nAn assignment of y is a function $\u03b8$: V \u2192 {0,1} where V \u2286 Var(4). The assignment is complete whenever V = Var(4) and partial otherwise. A circuit $4$ is evaluated using an assignment $\u03b8$: V \u2192 {0,1}, by replacing each input gate v \u2208 V with \u03b8(v), with the usual meaning.\nThe resulting circuit is 4[\u03b8]. Whenever e is complete, the value of the output gate can be determined in linear time, and hence either 4[0] = 0 or 4[\u03b8] = 1 holds.\nIf \u03c8[0] = 1 we call 0 a satisfying assignment, whereas if 4[\u03b8] = 0 we call 0 a conflicting assignment. A circuit 4 is satisfiable if and only if there exists a satisfying assignment to 4.\nConjunctive Normal Form. In practice, a SAT instance 4 is typically given in conjunctive normal form (CNF), which we denote with 4 = {{l1,1 \u2228\uff65\uff65\uff65 \u2228 l\u2081,k\u2081 } \u2227\uff65\uff65\uff65 \u2227 {lm,1 \u2228\uff65\uff65\uff65 \u2228lm,km}}. Each element C \u2208 \u03c8 is called a clause, whereas a clause itself consists of a set of literals. A literal is either a variable v or its negation . \nA symmetry, or automorphism, of y is a permutation of the variables q: Var(\u03c8) \u2192 Var(\u03c8) which maps y back to itself, i.e., 4\u00ba = 4, where q is applied element-wise to the variables in each clause. The permutation group of all symmetries of f is Aut(\u03c8) \u2264 Sym(Var(\u03c8)). \nAnother common way to define symmetries is to define them on the literals of the formula, allowing the use of so-called negation symmetries (see [45]). In any case, symmetries can be efficiently computed in practice using state-of-the-art symmetry detection tools [38, 29, 16, 2]."}, {"title": "2.2 Permutation Groups", "content": "We briefly introduce some notation and results for permutation groups. For further back-ground material on permutation groups, we refer to [20]. Throughout, we use the notation [n] := {1, ..., n} for n \u2208 Z>0 and set [0] := \u00d8.\nLet O be a nonempty finite set. Let Sym(\u03a9) denote the symmetric group on Q, i.e., the group of permutations of \u03a9. \u0391 permutation group is a subgroup G of Sym(\u03a9), denoted by G \u2264 Sym(\u03a9). We also say that G acts on \u03a9. A permutation group is always specified by the abstract isomorphism type of G (for instance, G could be cyclic of order 10), together with the action of G on \u03a9. For g \u2208 G and \u03c9 \u2208 \u03a9, we write w\u00ba for the image of w under g and wG = {w\u00a3: g \u2208 G} for the orbit of w under G. The support of G consists of those elements in Q that are moved (i.e., not fixed) by some element of G. For a partition P = (\u03a9\u2081,..., \u03a9\u2081) of\n\u03a9 (i.e., \u03a9 = \u03a9\u2081 \u222a\u2026 \u222a \u03a9\u2081), the partition stabilizer of P in G consists of all elements g \u2208 G that setwise stabilize \u03a9\u2081, \u2026 \u2026 \u2026, \u03a9\u2081, i.e. for all i \u2208 [r], {w\u00a3 : w \u2208 \u03a9\u2081} = \u03a9\u00a1. The index of a subgroup H of G is |G : H| := |G|/|H|.\nTwo permutation groups G < Sym(\u03a9) and H \u2264 Sym(\u25b3) are permutation isomorphic if there exists a bijection \u03bb: \u03a9 \u2192 \u2206 and a group isomorphism a: G \u2192 H such that (w) = \u03bb(\u03c9)a(8) for all w \u2208 \u03a9 and g \u2208 G. Note that this notion is stronger than G and H being isomorphic (as abstract groups) as the same abstract group can give rise to different group actions. For instance, Sym(k) admits so-called Johnson actions on different domains:\nJohnson Groups. Let k be a positive integer and t \u2208 [k \u2212 1]. A permutation \u03c0\u2208 Sym(k) induces a permutation t on the domain $\\binom{k}{t}$ of t-subsets of [k], mapping a t-subset A to Aft = {a"}, {"title": "2.3 Graph Isomorphism and String Canonization", "content": "Graphs. A finite, undirected graph \u0393 = (V,E) consists of a set of vertices V \u2286 N and an edge relation EC $\\binom{V}{2}$. Unless stated otherwise, the set of vertices V is {1, ..., n} and m := |E| denotes the number of edges. We may refer to the set of vertices of \u0393 with V(\u0393), and to the set of edges with E(\u0413). The adjacency matrix of F is the n \u00d7 n-matrix A = (aij) with aij = 1 if {i,j} \u2208 E(\u0393), and aij = 0 otherwise. Unless stated otherwise, we assume our graphs are given as adjacency matrices.\nA graph \u0393 is bipartite if V(F) = AUB can be partitioned into two independent sets A = {a\u2081,...,ak} and B = {b\u2081,...,be}. In this case, we may obtain an bipartite adjacency matrix M = (mij) by setting mij = 1 if a\u2081 and bj are adjacent, and mij = 0 otherwise.\nLexicographic ordering. For {0,1}-strings \u03b8, \u03b8' of the same length, we write \u03b8\u2264lex \u03b8' if \u03b8 is smaller or equal to \u03b8' with respect to the lexicographic ordering. Likewise, we define a lexicographic ordering of matrices with entries in {0,1} of a fixed size by interpreting them as strings, reading them row by row.\nRelational Structures. As a generalization of graphs, we define a t-ary relational structure R = (U, A), where U is a universe and A is a t-ary relation on U. A t-ary relational structure is symmetric if for every t-tuple (u1,...,ut) \u2208 A and for every \u03c3\u2208 Sym(t), it holds that $(U_{\\sigma(1)},..., U_{\\sigma(t)}) \u2208 A$.\nGraph Isomorphism. Two graphs \u0413\u2081 = (V1, E1), \u03932 = (V2, E2) are said to be isomorphic, whenever there exists a bijection q: V\u2081 \u2192 V2 such that \u03c6(\u0393\u2081) = (V, E\u2081) = (V2, E2) = \u04132 holds. Here, V\u2081 and Er means applying q element-wise to each element in V\u2081, and each element of each tuple in E\u2081, respectively. We call q an isomorphism between \u0413\u2081 and \u04132. We may write \u0393\u2081 =\u2243 \u03932 to denote isomorphism. A corresponding computational problem follows:"}, {"title": "2.4 Notions of Symmetry Breaking", "content": "Next, we define our notions of symmetry breaking. Let y be a CNF formula. Typically, symmetry breaking is defined specifically for the automorphism group Aut(4) of \u03c8. However, it turns out that often, our symmetry breaking predicates only depend on the structure of Aut(4) and its action on the set of variables Var(4). In particular, they do not depend on the specific shape of the formula \u03c8. Hence, we define symmetry breaking only using an arbitrary permutation group G \u2264 Sym(\u03a9) and without referring to a precise formula 4.\nSymmetry Breaking Constraints. We begin with a discussion of complete symmetry break-ing. Indeed, we find that in the literature two different notions are in use.\nThe first of these notions is what we will refer to simply as complete symmetry breaking. The idea is that a complete symmetry breaking constraint must ensure that in each orbit of complete assignments, all but one canonical representative is conflicting [15].\nFormally, we let @full(\u03a9) := {0 | \u03b8: \u03a9 \u2192 {0,1}} denote the set of all complete assignments to \u03a9. We let G \u2264 Sym(\u03a9) act on @full(\u03a9) in the natural way. A Boolean circuit 4 with Var(4) \u2286 \u03a9 is called a complete symmetry breaking circuit for G, whenever for each orbit"}, {"title": "3 Row-Column Symmetries", "content": "In this section, we analyze the complexity of computing symmetry breaking predicates for row-column symmetry. Section 3.1 describes the hardness of obtaining SBPs for breaking row-column symmetries. In particular, we provide a proof of Theorem 1.1. Section 3.2 estab-lishes the connection between symmetry breaking and decision string canonization. Lastly, in Section 3.3, we strengthen our results to work for circuit SBPs and SBPs with extra variables."}, {"title": "3.1 Hardness of Breaking Row-Column Symmetries", "content": "We begin with a formal definition of row-column symmetry.\nRow-Column Symmetry. Let m, n be two positive integers, and \u03a9 := [n] \u00d7 [m]. The row-column symmetry group G is defined to be the group Sym([n]) \u00d7 Sym([m]), where Sym([n]) naturally acts on the first component of Q, and Sym([m]) on the second component. Informally, we can view \u03a9 as a matrix with n rows and m columns. The group G <\u2264 Sym(\u03a9) then consists of all the possible row transpositions and all possible column transpositions, along with their arbitrary compositions.\nA matrix model is a constraint program whose decision variables can be arranged as a matrix above such that its automorphism group is the row-column symmetry group for this matrix arrangement. For such programs, it is typical to index their variable set by \u03a9 = {xij | i \u2208 [n], j\u2208 [m]}.\nThe following lemma states a one-to-one correspondence between assignments to a matrix model and bipartite graphs. Let \u0393(U, V) denote a bipartite graph with a designated left-partition U and a right-partition V, where U and V are non-interchangeable."}, {"title": "3.2 A Decision Version of String Canonization", "content": "We now introduce a decision variant of the string canonization problem, which only decides whether a given string is the canonical string:\nProblem 3.2 (d-SCANONF). Given a group G \u2264 Sym(\u03a9), a finite alphabet \u03a3 and a string \u03c3 \u03b5 \u03a3\u03a9, decide whether o = F(G,o) holds, i.e., whether o is the canonical representative within its isomorphism class \u03c3G.\nLet us consider a CNF formula 4. We consider the case of the string canonization problem where \u03a3 = {0,1} and the group G \u2264 Sym(Var(4)) consists of symmetries of 4. Note that any two given assignments 01 and 02 of 4 can be interpreted as strings, and 0\u2081 =G 02 holds if and only if they are in the same orbit of G.\nWe observe that an algorithm for d-sCANON accepts precisely one assignment per orbit of G. But this just means that if we translate such an algorithm into a Boolean circuit, the resulting circuit is a symmetry breaking circuit.\nClearly, d-SCANONF Polynomial time reduces to S-SCANONF. Since s-SCANON can be solved using a quasi-polynomial time algorithm [6], Theorem 1.3 follows immediately.\nAnalogously, we may define a decision version of the graph canonization problem, denoted as d-GCanonf. Recall that graph canonization is a special case of string canonization. In the following, we prove that the decision canonization problem is tightly related to graph isomorphism in terms of its non-deterministic complexity."}, {"title": "3.3 Hardness of Symmetry Breaking with Additional Variables", "content": "Consider the situation where one is allowed to use additional variables from a set \u03a9' to write down symmetry breaking constraints. In principle, this expands our domain \u03a9 of variables used to \u03a9\u03cb\u03a9'. Since the introduction of new variables \u03a9' changes the set of assignments, we need to adjust our definition of complete symmetry breaking.\nSymmetry Breaking with Additional Variables. A Boolean circuit 4 is called a complete symmetry breaking circuit with additional variables for G < Sym(\u03a9), whenever for each orbit \u03c4\u2286 \u03c3full(\u03a9) under G, there is\n\u2022 a \u03c4' \u2208 \u03c4 such that \u03c8[\u03c4'] is satisfiable,\n\u2022 for all \u03c4\" \u03b5\u03c4 with \u03c4' \u2260 \u03c4\" the circuit \u03c8[\u03c4'] is unsatisfiable.\nA point of contention in the above definition might be whether \u03c8[\u03c4'] should actually have exactly one satisfying assignment. This would ensure that there is precisely one satisfying as-signment per orbit, while our definition only suffices to ensure a unique satisfying assignment when restricted to the variables of 4. In this paper, we stick to the above definition.\nUsing additional variables is typically not considered in the literature, most likely because this might substantially alter the difficulty of the underlying instance. Introducing additional variables is however intriguing: it gives the symmetry breaking predicates access to non-determinism, and hence might enable substantially more powerful constraints.\nHardness with Additional Variables. We show hardness results for symmetry breaking even if we are allowed to introduce new variables."}, {"title": "4 Johnson Actions", "content": "Next, we consider the so-called Johnson groups. Johnson groups are groups which naturally occur in problems encoding graph generation tasks [31]. We begin this section by describing a correspondence between Johnson groups and symmetric relational structures. Then, we provide a formal proof of Theorem 1.2. Lastly, we show how to derive SBPs for a group G, given SBPs for a small index subgroup H < G (Lemma 4.5)."}, {"title": "4.1 Johnson Groups and Relational Structures", "content": "Johnson Families. Let k be a positive integer. For t \u2208 [k \u2212 1], let X be the set of variables indexed by t-element subsets of [k]. In particular, we have |X| = $\\binom{k}{t}$. For fixed t > 1, we call the group family S(t)k \u2264 Sym(X) the Johnson family of arity t.\nJohnson groups form a subclass of the so-called groups of Cameron type. These groups as well as their natural action can be recognized in polynomial time (see [9]).\nRelational Structures and Johnson Groups. To a symmetric t-ary relational structure R, we associate an assignment fr: X \u2192 {0,1} with f(xs) = 1 for a t-subset S of [k] if S is a hyperedge in R, and f(xs) = 0 otherwise. Conversely, given f: X \u2192 {0,1}, we define a symmetric t-ary relational structure Rf on the universe [k] whose relation is the set of all tuples (a1,...,at) with f({a1,...,at}) = 1.\nThis defines a one-to-one correspondence between assignments of X and symmetric t-ary relational structures. The following result formalizes the correspondence (see also [34])."}, {"title": "4.2 Johnson Families of Fixed Arity are Hard", "content": "In this section, we show that polynomial time symmetry breaking for Johnson families of fixed arity t > 2 implies Gl \u2208 coNP."}, {"title": "4.3 Subgroups of Small Index and Large Primitive Groups", "content": "In this section, we consider symmetry breaking for a permutation group G \u2264 Sym(n) and a subgroup H of G. Mostly, we are interested in the case that H has polynomial index in G. We first show that a symmetry breaking constraint for H gives rise to symmetry breaking constraint for G:"}, {"title": "5 Upper Bounds", "content": "Complementing the results from the previous sections, we show that certain families of groups can be efficiently handled. We begin by recalling three simple cases.\nGroups of Polynomial Order. The first case pertains to groups where the order is polyno-mial in the size of the original formula. For these groups, we can explicitly write a constraint that breaks each element of the group [15]. The resulting constraint is complete and of poly-nomial size in the formula.\nSymmetric Groups. Symmetric groups in their natural action can be handled by imposing an ordering on the assignments. For Sym(n), this can be achieved by the predicate \u03c8n = X1 \u2264 X2\u2264\u2264 Xn.\nA slight extension of symmetric groups are known and used in practice, namely row-interchangeability subgroups [18, 41]. We say that a permutation group G \u2264 Sym(\u03a9) ex-hibits row-interchangeability if \u03a9 can be arranged in an n \u00d7 m-matrix X = (xij) such that G consists precisely of the permutations of the rows of X. This symmetry can be broken by lexicographically ordering the rows in any assignment 0: X \u2192 {0,1} (viewed as an n \u00d7 m-matrix). Formally, for i \u2208 [n \u2212 1], let Xi := (Ar\u2208[k\u22121](xir = X(i+1)r)) \u2192 (Xik \u2264 X(i+1)k). Then \u03bbn,m := -1 -1 A is a symmetry breaking predicate for G.\nDisjoint direct decomposition. A direct product G = G\u2081 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 G, of permutation groups is called a disjoint direct decomposition if the subgroups G1, ..., Gr have pairwise disjoint sup-ports. Disjoint direct products naturally arise and have been successfully used in practice [18]. The finest disjoint direct decomposition can be computed in polynomial time for gen-eral permutation groups [13], and in quasi-linear time for automorphism groups of graphs [3]. For the sake of completeness, we argue that disjoint direct decompositions can be exploited without giving up on complete symmetry breaking.\nWreath Products. We now turn our attention to so-called wreath products. They naturally occur as the automorphism groups of tree-like structures and can be detected as the induced action on a block system [46]. Tree-like appendages are already detected and exploited by practical symmetry detection algorithms [4], and thus these wreath products seem readily available.\nWreath Products with CNF. Let us first focus on CNF predicates. Recall the predicate Am,n from the beginning of this section. The following result shows that a symmetry breaking predicate for a permutation group G can be \u201clifted\u201d to a predicate for G(Sym(m):"}, {"title": "6 Conclusion and Future Work", "content": "We laid the foundation for a systematic study of the complexity of symmetry breaking. A central tool in our investigation was the relation to the string canonization problem (see Section 3). In particular, we showed that polynomial time symmetry breaking for the row-column symmetry group, even with circuits and additional variables, implies GI \u2208 coNP (see Theorem 1.1). The same applies to proper Johnson actions (see Theorem 1.2). On the other hand, we showed that symmetry breaking in polynomial time is possible for several families of groups, including certain classes of wreath products (see Section 5).\nClearly, the dividing line between permutation groups that are \u201chard\u201d instances for sym-metry breaking, and those which admit efficient symmetry breaking, needs to be further explored. Among others, the following questions immediately arise:\n1. Given a permutation group G and a subgroup H of polynomial index, does H admit efficient symmetry breaking if G does (i.e., does the converse of Lemma 4.5 hold)?\n2. How difficult are permutation groups of intermediate size, in particular groups of quasi-polynomial order in the size of the domain?\nA positive answer to Question 1 would not only contribute to further decomposition results, but it is particularly relevant as large primitive permutation groups are known to contain normal subgroups of small index exhibiting a Johnson action."}]}