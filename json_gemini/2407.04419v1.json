{"title": "The Complexity of Symmetry Breaking Beyond Lex-Leader", "authors": ["Markus Anders", "Sofia Brenner", "Gaurav Rattan"], "abstract": "Symmetry breaking is a widely popular approach to enhance solvers in constraint programming, such as those for SAT or MIP. Symmetry breaking predicates (SBPs) typically impose an order on variables and single out the lexicographic leader (lex-leader) in each orbit of assignments. Although it is NP-hard to find complete lex-leader SBPs, incomplete lex-leader SBPs are widely used in practice.\nIn this paper, we investigate the complexity of computing complete SBPs, lex-leader or otherwise, for SAT. Our main result proves a natural barrier for efficiently computing SBPs: efficient certification of graph non-isomorphism. Our results explain the difficulty of obtaining short SBPs for important CP problems, such as matrix-models with row-column symmetries and graph generation problems. Our results hold even when SBPs are allowed to introduce additional variables. We show polynomial upper bounds for breaking certain symmetry groups, namely automorphism groups of trees and wreath products of groups with efficient SBPs.", "sections": [{"title": "1 Introduction", "content": "The search space of a constraint program can exhibit a large amount of symmetry. This simple yet far-reaching observation forms the core principle behind the use of symmetry based approaches in the realm of constraint programming [24, 45]. Such methods prune the symmetric parts of the search space to save computational costs. Ideally, they ensure that at most one solution exists per equivalence class of candidate solutions. Over the last two decades, numerous methods have been proposed to exploit symmetries of constraint programs. In particular, many approaches have been developed for Boolean satisfiability solvers [15, 1, 14, 18, 28, 31, 17, 44, 39] as well as mixed integer programming [36, 40, 41]. Symmetry-based solving remains an active and fruitful area of interest, especially from a practical perspective: for example, the defining feature of arguably one of the most successful entries in the SAT competition 2023 was symmetry breaking [12, 11].\nHow symmetries should be used best remains unclear. Approaches can be roughly divided into two different categories: in dynamic and static approaches. In a dynamic approach, symmetries are used during the execution of a solver [44, 19, 17, 39]. A typical example is that the solver incorporates a branching rule that makes use of the symmetries directly [44].\nThe second approach is the static use of symmetries, which is the main focus of this paper. Here, additional constraints, so-called symmetry breaking predicates (SBPs), are added to a given problem instance. The notion of SBPs was first introduced in the seminal paper of Crawford, Ginsberg, Luks and Roy [15]. Their goal was to generate polynomial-sized SBPs for SAT formulas in conjunctive normal form (CNF). However, since their framework is rooted in group theory, many results neatly generalize to other constraint languages.\nThe framework of Crawford et al., as well as the majority of the subsequent work in this area, uses so-called lex-leader predicates to achieve complete symmetry breaking. Using incomplete lex-leader predicates is arguably one of the most successful approaches to symmetry breaking in practice [1, 18]. On a complexity-theoretic level, however, Crawford et al. proved that computing a predicate true of only the lex-leader in each equivalence class of Boolean assignments is NP-hard. Subsequent results showed that this even holds true for restricted classes of groups [35], as well as orders similar to lex-leader [30, 47].\nOne may wonder whether there are other kinds of SBPs that are efficiently computable. Here, other kinds of SBPs simply means that they do not make use of a lexicographic ordering of the assignments. In principle, choosing any canonical representative among symmetric assignments is permissible, lex-leader or otherwise. This question is motivated, for instance, by the realm of graph isomorphism (GI). There, choosing the lex-leader is also known to be NP-hard [7], and the best theoretical and practical approaches make use of other mechanisms.\nConcerning practical symmetry breaking, only a few, though surprisingly different, ap- proaches of generating non-lex-leader SBPs have been explored. In [23], the global cardinality constraint [43] is used in conjunction with lex-leader constraints to efficiently handle (particular) wreath symmetry. In [14], SAT symmetry breaking constraints for graph problems are produced similarly to the canonical labeling algorithm NAUTY [38]. In [26], minimal SAT symmetry breaking constraints are generated for small groups.\nIn general, however, the complexity of SBPs remains largely unexplored, even for fairly restricted kinds of symmetries. Perhaps the most glaring example is the problem of breaking row-column symmetries, which arise in the so-called matrix models [21]. These models allow the decision variables to be arranged in a matrix such that interchanging any two rows or any two columns is a symmetry of the model. Matrix models arise in multiple areas of constraint programming such as scheduling, combinatorial problems, and design [22]. Perhaps the most well-known matrix model is the pigeonhole principle problem, for which it is NP-hard to compute the lex-leader or similar assignments [15]. While the problem of devising SBPs for such models has received much attention [21, 30, 24], the known results do not explain the lack of compact SBPs for matrix models."}, {"title": "1.1 Our Results", "content": "The objective of this paper is to further investigate the exact complexity of computing static symmetry breaking predicates. Given a group of symmetries on the variables of a formula, how hard is it to generate a complete symmetry breaking predicate? The ultimate goal of our work is to obtain a classification of symmetry groups, in terms of the complexity of computing SBPs. Such a classification could help inform practitioners as to which cases can be handled easily, and which ones are more challenging.\nIn order to simplify the exposition, our setting of choice is that of Boolean satisfiability testing (SAT). However, in the same vein as [15], our results are founded in a general group- theoretic setting, so they should easily transfer to many branches of constraint programming: we consider computing symmetry breaking predicates for a given permutation group, instead of a particular SAT formula exhibiting such symmetry.\nOur results can be divided into hardness results and upper bounds. The high-level idea for"}, {"title": "2 Preliminaries", "content": "2.1 Boolean Circuits and Satisfiability\nBoolean Circuits. A Boolean circuit $4$ is a circuit consisting of input gates, one output gate, and {AND, OR, NOT}-gates connecting them in the usual way. We refer to the input gates as the variables $\\text{Var}(4)$. The size of a circuit refers to the number of gates.\nAn assignment of $\\psi$ is a function $\\theta$: $V \\rightarrow \\{0,1\\}$ where $V \\subseteq \\text{Var}(4)$. The assignment is complete whenever $V = \\text{Var}(4)$ and partial otherwise. A circuit is evaluated using an assignment $\\theta$: $V \\rightarrow \\{0,1\\}$, by replacing each input gate $v \\in V$ with $\\theta(v)$, with the usual meaning."}, {"title": "2.2 Permutation Groups", "content": "We briefly introduce some notation and results for permutation groups. For further back- ground material on permutation groups, we refer to [20]. Throughout, we use the notation $[n] := \\{1, ..., n\\}$ for $n \\in \\mathbb{Z}_{>0}$ and set $[0] := \\emptyset$.\nLet $\\Omega$ be a nonempty finite set. Let $\\text{Sym}(\\Omega)$ denote the symmetric group on $\\Omega$, i.e., the group of permutations of $\\Omega$. A permutation group is a subgroup $G$ of $\\text{Sym}(\\Omega)$, denoted by $G \\leq \\text{Sym}(\\Omega)$. We also say that $G$ acts on $\\Omega$. A permutation group is always specified by the abstract isomorphism type of $G$ (for instance, $G$ could be cyclic of order 10), together with the action of $G$ on $\\Omega$. For $g \\in G$ and $\\omega \\in \\Omega$, we write $\\omega^g$ for the image of $\\omega$ under $g$ and $\\omega^G = \\{\\omega^g: g \\in G\\}$ for the orbit of $\\omega$ under $G$. The support of $G$ consists of those elements in $\\Omega$ that are moved (i.e., not fixed) by some element of $G$. For a partition $P = (\\Omega_1,..., \\Omega_r)$ of"}, {"title": "2.3 Graph Isomorphism and String Canonization", "content": "Graphs. A finite, undirected graph $\\Gamma = (V,E)$ consists of a set of vertices $V \\subseteq \\mathbb{N}$ and an edge relation $E \\subseteq {V \\choose 2}$. Unless stated otherwise, the set of vertices $V$ is $\\{1, ..., n\\}$ and $m := |E|$ denotes the number of edges. We may refer to the set of vertices of $\\Gamma$ with $V(\\Gamma)$, and to the set of edges with $E(\\Gamma)$. The adjacency matrix of $\\Gamma$ is the $n \\times n$-matrix $A = (a_{ij})$ with $a_{ij} = 1$ if $\\{i,j\\} \\in E(\\Gamma)$, and $a_{ij} = 0$ otherwise. Unless stated otherwise, we assume our graphs are given as adjacency matrices.\nA graph $\\Gamma$ is bipartite if $V(\\Gamma) = A \\cup B$ can be partitioned into two independent sets $A = \\{a_1,...,a_k\\}$ and $B = \\{b_1,...,b_\\ell\\}$. In this case, we may obtain an bipartite adjacency matrix $M = (m_{ij})$ by setting $m_{ij} = 1$ if $a_i$ and $b_j$ are adjacent, and $m_{ij} = 0$ otherwise.\nLexicographic ordering. For $\\{0,1\\}$-strings $\\theta, \\theta'$ of the same length, we write $\\theta \\leq_{\\text{lex}} \\theta'$ if $\\theta$ is smaller or equal to $\\theta'$ with respect to the lexicographic ordering. Likewise, we define a lexicographic ordering of matrices with entries in $\\{0,1\\}$ of a fixed size by interpreting them as strings, reading them row by row.\nRelational Structures. As a generalization of graphs, we define a $t$-ary relational structure $R = (U, A)$, where $U$ is a universe and $A$ is a $t$-ary relation on $U$. A $t$-ary relational structure is symmetric if for every $t$-tuple $(u_1,...,u_t) \\in A$ and for every $\\sigma \\in \\text{Sym}(t)$, it holds that $(u_{\\sigma(1)},..., u_{\\sigma(t)}) \\in A$.\nGraph Isomorphism. Two graphs $\\Gamma_1 = (V_1, E_1), \\Gamma_2 = (V_2, E_2)$ are said to be isomorphic, whenever there exists a bijection $\\varphi$: $V_1 \\rightarrow V_2$ such that $\\varphi(\\Gamma_1) = (V_1^{\\varphi}, E_1^{\\varphi}) = (V_2, E_2) = \\Gamma_2$ holds. Here, $V_1^{\\varphi}$ and $E_1^{\\varphi}$ means applying $\\varphi$ element-wise to each element in $V_1$, and each element of each tuple in $E_1$, respectively. We call $\\varphi$ an isomorphism between $\\Gamma_1$ and $\\Gamma_2$. We may write $\\Gamma_1 \\simeq \\Gamma_2$ to denote isomorphism. A corresponding computational problem follows:"}, {"title": "2.4 Notions of Symmetry Breaking", "content": "Next, we define our notions of symmetry breaking. Let $\\psi$ be a CNF formula. Typically, symmetry breaking is defined specifically for the automorphism group $\\text{Aut}(\\psi)$ of $\\psi$. However, it turns out that often, our symmetry breaking predicates only depend on the structure of $\\text{Aut}(\\psi)$ and its action on the set of variables $\\text{Var}(\\psi)$. In particular, they do not depend on the specific shape of the formula $\\psi$. Hence, we define symmetry breaking only using an arbitrary permutation group $G \\leq \\text{Sym}(\\Omega)$ and without referring to a precise formula $\\psi$.\nSymmetry Breaking Constraints. We begin with a discussion of complete symmetry break- ing. Indeed, we find that in the literature two different notions are in use.\nThe first of these notions is what we will refer to simply as complete symmetry breaking. The idea is that a complete symmetry breaking constraint must ensure that in each orbit of complete assignments, all but one canonical representative is conflicting [15].\nFormally, we let $\\#_{\\text{full}}(\\Omega) := \\{\\theta | \\theta: \\Omega \\rightarrow \\{0,1\\}\\}$ denote the set of all complete assignments to $\\Omega$. We let $G \\leq \\text{Sym}(\\Omega)$ act on $\\#_{\\text{full}}(\\Omega)$ in the natural way. A Boolean circuit $\\varphi$ with $\\text{Var}(\\varphi) \\subseteq \\Omega$ is called a complete symmetry breaking circuit for $G$, whenever for each orbit $\\mathcal{O} \\subseteq \\#_{\\text{full}}(\\Omega)$ under $G$, there is"}, {"title": "3 Row-Column Symmetries", "content": "In this section, we analyze the complexity of computing symmetry breaking predicates for row-column symmetry. Section 3.1 describes the hardness of obtaining SBPs for breaking row-column symmetries. In particular, we provide a proof of Theorem 1.1. Section 3.2 estab- lishes the connection between symmetry breaking and decision string canonization. Lastly, in Section 3.3, we strengthen our results to work for circuit SBPs and SBPs with extra variables."}, {"title": "3.1 Hardness of Breaking Row-Column Symmetries", "content": "We begin with a formal definition of row-column symmetry.\nRow-Column Symmetry. Let $m, n$ be two positive integers, and $\\Omega := [n] \\times [m]$. The row- column symmetry group $G$ is defined to be the group $\\text{Sym}([n]) \\times \\text{Sym}([m])$, where $\\text{Sym}([n])$ naturally acts on the first component of $\\Omega$, and $\\text{Sym}([m])$ on the second component. Informally, we can view $\\Omega$ as a matrix with $n$ rows and $m$ columns. The group $G \\leq \\text{Sym}(\\Omega)$ then consists of all the possible row transpositions and all possible column transpositions, along with their arbitrary compositions."}, {"title": "3.2 A Decision Version of String Canonization", "content": "We now introduce a decision variant of the string canonization problem, which only decides whether a given string is the canonical string:\nLet us consider a CNF formula $\\psi$. We consider the case of the string canonization problem where $\\Sigma = \\{0,1\\}$ and the group $G \\leq \\text{Sym}(\\text{Var}(\\psi))$ consists of symmetries of $\\psi$. Note that any two given assignments $\\theta_1$ and $\\theta_2$ of $\\psi$ can be interpreted as strings, and $\\theta_1 =_G \\theta_2$ holds if and only if they are in the same orbit of $G$.\nWe observe that an algorithm for $\\text{d-sCANON}$ accepts precisely one assignment per orbit of $G$. But this just means that if we translate such an algorithm into a Boolean circuit, the resulting circuit is a symmetry breaking circuit.\nClearly, $\\text{d-SCANON}_F$ Polynomial time reduces to $\\text{S-SCANON}_F$. Since $\\text{s-SCANON}$ can be solved using a quasi-polynomial time algorithm [6], Theorem 1.3 follows immediately.\nAnalogously, we may define a decision version of the graph canonization problem, denoted as $\\text{d-GCanon}_f$. Recall that graph canonization is a special case of string canonization. In the following, we prove that the decision canonization problem is tightly related to graph isomorphism in terms of its non-deterministic complexity."}, {"title": "3.3 Hardness of Symmetry Breaking with Additional Variables", "content": "Consider the situation where one is allowed to use additional variables from a set $\\Omega'$ to write down symmetry breaking constraints. In principle, this expands our domain $\\Omega$ of variables used to $\\Omega \\cup \\Omega'$. Since the introduction of new variables $\\Omega'$ changes the set of assignments, we need to adjust our definition of complete symmetry breaking.\nSymmetry Breaking with Additional Variables. A Boolean circuit $\\varphi$ is called a complete symmetry breaking circuit with additional variables for $G \\leq \\text{Sym}(\\Omega)$, whenever for each orbit $\\tau \\subseteq \\sigma_{\\text{full}}(\\Omega)$ under $G$, there is\nUsing additional variables is typically not considered in the literature, most likely because this might substantially alter the difficulty of the underlying instance. Introducing additional variables is however intriguing: it gives the symmetry breaking predicates access to non- determinism, and hence might enable substantially more powerful constraints.\nHardness with Additional Variables. We show hardness results for symmetry breaking even if we are allowed to introduce new variables."}, {"title": "4 Johnson Actions", "content": "Next, we consider the so-called Johnson groups. Johnson groups are groups which naturally occur in problems encoding graph generation tasks [31]. We begin this section by describing a correspondence between Johnson groups and symmetric relational structures. Then, we provide a formal proof of Theorem 1.2. Lastly, we show how to derive SBPs for a group $G$, given SBPs for a small index subgroup $H < G (Lemma 4.5)."}, {"title": "4.1 Johnson Groups and Relational Structures", "content": "Johnson Families. Let $k$ be a positive integer. For $t \\in [k - 1]$, let $X_t^k$ be the set of variables indexed by $t$-element subsets of $[k]$. In particular, we have $|X_t^k| = {k \\choose t}$. For fixed $t > 1$, we call the group family $S_k^{(t)} \\leq \\text{Sym}(X_t^k)$ the Johnson family of arity $t$.\nJohnson groups form a subclass of the so-called groups of Cameron type. These groups as well as their natural action can be recognized in polynomial time (see [9]).\nRelational Structures and Johnson Groups. To a symmetric $t$-ary relational structure $R$, we associate an assignment $f_R$: $X_t^k \\rightarrow \\{0,1\\}$ with $f(x_S) = 1$ for a $t$-subset $S$ of $[k]$ if $S$ is a hyperedge in $R$, and $f(x_S) = 0$ otherwise. Conversely, given $f$: $X_t^k \\rightarrow \\{0,1\\}$, we define a symmetric $t$-ary relational structure $R_f$ on the universe $[k]$ whose relation is the set of all tuples $(a_1,...,a_t)$ with $f(\\{a_1,...,a_t\\}) = 1$.\nThis defines a one-to-one correspondence between assignments of $X_t^k$ and symmetric $t$-ary relational structures. The following result formalizes the correspondence (see also [34])."}, {"title": "4.2 Johnson Families of Fixed Arity are Hard", "content": "In this section, we show that polynomial time symmetry breaking for Johnson families of fixed arity $t > 2$ implies $GI \\in coNP$."}, {"title": "4.3 Subgroups of Small Index and Large Primitive Groups", "content": "In this section, we consider symmetry breaking for a permutation group $G \\leq \\text{Sym}(n)$ and a subgroup $H$ of $G$. Mostly, we are interested in the case that $H$ has polynomial index in $G$. We first show that a symmetry breaking constraint for $H$ gives rise to symmetry breaking constraint for $G$:"}, {"title": "5 Upper Bounds", "content": "Complementing the results from the previous sections, we show that certain families of groups can be efficiently handled. We begin by recalling three simple cases.\nGroups of Polynomial Order. The first case pertains to groups where the order is polyno- mial in the size of the original formula. For these groups, we can explicitly write a constraint"}, {"title": "6 Conclusion and Future Work", "content": "We laid the foundation for a systematic study of the complexity of symmetry breaking. A central tool in our investigation was the relation to the string canonization problem (see Section 3). In particular, we showed that polynomial time symmetry breaking for the row- column symmetry group, even with circuits and additional variables, implies $GI \\in coNP$ (see Theorem 1.1). The same applies to proper Johnson actions (see Theorem 1.2). On the other hand, we showed that symmetry breaking in polynomial time is possible for several families of groups, including certain classes of wreath products (see Section 5).\nClearly, the dividing line between permutation groups that are \u201chard\u201d instances for sym- metry breaking, and those which admit efficient symmetry breaking, needs to be further explored. Among others, the following questions immediately arise:\n1. Given a permutation group $G$ and a subgroup $H$ of polynomial index, does $H$ admit efficient symmetry breaking if $G$ does (i.e., does the converse of Lemma 4.5 hold)?\n2. How difficult are permutation groups of intermediate size, in particular groups of quasi- polynomial order in the size of the domain?\nA positive answer to Question 1 would not only contribute to further decomposition results, but it is particularly relevant as large primitive permutation groups are known to contain normal subgroups of small index exhibiting a Johnson action."}, {"title": "Funding", "content": "The research leading to these results has received funding from the European Research Coun- cil (ERC) under the European Union's Horizon 2020 research and innovation programme (EngageS: grant agreement No. 820148). Sofia Brenner additionally received funding from the German Research Foundation DFG (SFB-TRR 195 \u201cSymbolic Tools in Mathematics and their Application\u201d)."}]}