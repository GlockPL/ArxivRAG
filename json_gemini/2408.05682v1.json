{"title": "Separate Generation and Evaluation for Parallel Greedy Best-First Search", "authors": ["Takumi Shimoda", "Alex Fukunaga"], "abstract": "Parallelization of Greedy Best First Search (GBFS) has been\ndifficult because straightforward parallelization can result in\nsearch behavior which differs significantly from sequential\nGBFS, exploring states which would not be explored by se-\nquential GBFS with any tie-breaking strategy. Recent work\nhas proposed a class of parallel GBFS algorithms which con-\nstrains search to exploration of the Bench Transition System\n(BTS), which is the set of states that can be expanded by\nGBFS under some tie-breaking policy. However, enforcing\nthis constraint is costly, as such BTS-constrained algorithms\nare forced to spend much of the time waiting so that only\nstates which are guaranteed to be in the BTS are expanded.\nWe propose an improvement to parallel search which decou-\nples state generation and state evaluation and significantly im-\nproves state evaluation rate, resulting in better search perfor-\nmance.", "sections": [{"title": "Introduction", "content": "Parallelization of combinatorial search algorithms is impor-\ntant in order to maximize search algorithm performance\non modern, multi-core CPUs. In the case of cost-optimal\nsearch, parallelization of the standard A* algorithm (Hart,\nNilsson, and Raphael 1968) is somewhat well understood,\nand viable, practical approaches have been proposed. The\noptimality requirement imposes a relatively strong con-\nstraint on the set of states which must be expanded by any\nparallel A* (all nodes with f-values less than the optimal\npath cost C* must be expanded), so previous work has fo-\ncused on approaches for expanding those required states\nwhile minimizing synchronization and communication over-\nheads and avoiding expansion of non-required states (Burns\net al. 2010; Kishimoto, Fukunaga, and Botea 2013; Phillips,\nLikhachev, and Koenig 2014; Fukunaga et al. 2017).\nFor satisficing search where the object is to quickly find\nany valid solution path (regardless of path cost), paral-\nlization is not well understood. Greedy Best First Search\n(GBFS; Doran and Michie (1966)) is a widely used satisfic-\ning search algorithm. However, the performance of straight-\nforward parallelizations of GBFS is non-monotonic with re-\nspect to resource usage \u2013 there is a significant risk that us-\ning k threads can result in significantly worse performance\nthan using fewer than k threads. It has been shown experi-\nmentally that parallel GBFS can expand orders of magnitude\nmore states than GBFS (Kuroiwa and Fukunaga 2019), and\nit has been shown theoretically that KPGBFS, a straightfor-\nward parallelization of GBFS, can expand arbitrarily many\nmore states than GBFS (Kuroiwa and Fukunaga 2020).\nUnlike parallel cost-optimal search, there is no obvious\nset of states which a parallel satisficing search must explore\nin order to be considered a \u201ccorrect\" parallelization of the se-\nquential algorithm. Recent theoretical analysis of GBFS has\nyielded a promising direction for determining which states\nshould be expanded. Heusner, Keller, and Helmert (2017)\nidentified the Bench Transition System (BTS), the set of\nall states that can be expanded by GBFS under some tie-\nbreaking policy (conversely, if a state is not in the BTS, there\ndoes not exist any tie-breaking strategy for GBFS which will\nexpand that state). Limiting search to states in the BTS pro-\nvides a natural constraint for parallel GBFS.\nRecent work has proposed parallel GBFS algorithms\nwhich expand states from Open only if some constraint is\nsatisfied. Kuroiwa and Fukunaga (2020) proposed PUHF, a\nparallel GBFS which guarantees that only states which are in\nthe BTS will be expanded. However, this guarantee comes\nat a cost in performance. Since PUHF prevents expansion\nof any state unless it is certain that the state is in the BTS,\nthreads can be forced to be idle while they wait until a state\nwhich is guaranteed to be in the BTS become available, re-\nsulting in significantly worse performance than KPGBFS.\nImproved versions of PUHF with looser constraints (which\nstill guarantee that only states in the BTS are expanded) have\nbeen proposed (Shimoda and Fukunaga 2023), but these still\nhave a significantly lower state evaluation rate than parallel\nGBFS without expansion constraints.\nIn this paper, we propose Separate Generation and Eval-\nuation (SGE), which decouples state expansion and evalu-\nation so that instead of waiting for a single thread to fully\nexpand a state (generating and evaluating its successors),\nmultiple threads can be used to evaluate the successors. We\nshow that this significantly improves the state evaluation rate\nin parallel GBFS with expansion constraints.\nThe rest of the paper is structured as follows. Section 2\nreviews background and previous work. Section 3 presents"}, {"title": "Preliminaries and Background", "content": "State Space Topology State space topologies are defined\nfollowing Heusner, Keller, and Helmert (2018).\nDefinition 1. A state space is a 4-tuple $S=\n(S, \\text{succ}, S_{\\text{init}}, S_{\\text{goal}})$, where S is a finite set of states, succ :\n$S \\rightarrow 2^S$ is the successor function, $S_{\\text{init}} \\in S$ is the initial\nstate, and $S_{\\text{goal}} \\subseteq S$ is the set of goal states. If $s' \\in \\text{succ}(s)$,\nwe say that $s'$ is a successor of $s$ and that $s \\rightarrow s'$ is a (state)\ntransition. $\\forall s \\in S_{\\text{goal}}, \\text{succ}(s) = \\emptyset$. A heuristic for S is a\nfunction $h: S \\rightarrow \\mathbb{N}_0$ and $\\forall s \\in S_{\\text{goal}}, h(s) = 0$. A state\nspace topology is a pair (S, h), where S is a state space.\nWe call a sequence of states $(s_0, ..., s_n)$ a path from $s_0$\nto $s_n$, and denote the set of paths from s to s' as P(s, s').\n$p_i$ is the $i$ th state in a path p and $|p|$ is the length of p. A\nsolution of a state space topology is a path p from $S_{\\text{init}}$ to\na goal state. We assume at least one goal state is reachable\nfrom $S_{\\text{init}}$, and $\\forall s \\in S, s \\notin \\text{succ}(s)$.\nBest-First Search Best-First Search (BFS) is a class of\nsearch algorithms that use an evaluation function $f : S \\rightarrow\n\\mathbb{R}$ and a tie-breaking strategy $\\tau$. BFS searches states in the\norder of evaluation function values (f-values). States with\nthe same f-value are prioritized by $\\tau$. In Greedy Best-First\nSearch (GBFS; Doran and Michie (1966)), f(s) = h(s).\nK-Parallel GBFS (KPGBFS) K-Parallel BFS (Vidal,\nBordeaux, and Hamadi 2010) is a straightforward, baseline\nparallelization of BFS. All threads share a single Open and\nClosed. Each thread locks Open to remove a state s with the\nlowest f-value in Open, locks Closed to check duplicates\nand add succ(s) to Closed, and locks Open to add succ(s)\nto Open. KPGBFS is KPBFS with f(s) = h(s).\nThe set of states explored by KPGBFS may be very differ-\nent from those explored by GBFS. Kuroiwa and Fukunaga\n(2020) showed that straightforward parallelizations of GBFS\nwith shared Open and/or Closed, including KPGBFS, can\nexpand arbitrarily more states than GBFS.\nBench Transition Systems Heusner et al. (2017) defined\nbench transition system (BTS) in order to characterize the\nbehavior of GBFS, building upon the definition of high-\nwater marks by Wilt and Ruml (2014). The BTS is defined\nas the set of all states which can be expanded by GBFS with\nsome tie-breaking policy, i.e., a state s is in the BTS if there\nexists some tie-breaking policy under which s is expanded.\nConversely, states not in the BTS will not be expanded by\nGBFS under any tie-breaking policy.\nBTS-Constrained Search Restricting the search to only\nexpand states which are in the BTS is a natural constraint\nfor parallel GBFS.\nDefinition 2. A search algorithm is BTS-constrained if it\nexpands only states which are in the BTS (Shimoda and\nFukunaga 2023).\nPUHF: A BTS-Constrained Parallel GBFS Kuroiwa\nand Fukunaga (2020) proposed Parallel Under High-water-\nmark First (PUHF), a BTS-constrained parallel GBFS.\nPUHF marks states which are guaranteed to be in the BTS\nas certain, and only expands states marked as certain. The\ncriterion used by PUHF to mark states as certain was a re-\nstrictive, sufficient (but not necessary) condition for being\nin the BTS. Recently, looser sufficient conditions for mark-\ning states as certain were proposed, resulting in PUHF2\u20134,\nwhich significantly improved performance over PUHF (Shi-\nmoda and Fukunaga 2023)."}, {"title": "Constrained Parallel GBFS", "content": "As described above, the original proposing PUHF and\nPUHF2-4 presented these algorithms as marking states\nguaranteed to be in the BTS as certain, and only expanding\nnodes marked as certain. The stage in the algorithm where\nstates were marked as certain were specific to the specific\nalgorithm (PUHF, PUHF2\u20134). However, the the similarities\nand differences among KPGBFS, PUHF, and PUHF2\u20134 can\nbe clarified by reframing this behavior in terms of satisfying\nan algorithm-specific expansion constraint.\nWe present a unified framework, Constrained Parallel\nGBFS (CPGBFS) (Algorithm 1), which subsumes KPG-\nBFS, PUHF, and PUHF2\u20134. CPGBFS is a schema for a class\nof parallel search algorithms based on KPGBFS, which only\nexpands nodes which satisfy some algorithm-specific con-\nstraint in line 7, where satisfies(s) is a function which re-\nturns true if and only if s satisfies the algorithm-specific\nexpansion constraint.\nKPGBFS is a special case of CPGBFS where satisfies(s)\nalways returns true. The previously proposed BTS-\nconstrained search algorithms (PUHF and PUHF2\u20134) are in-\nstances of CPGBFS where the satisfies(s) function imple-\nments a check for the sufficient constraint which guarantees\nthat s is in the BTS \u2013 the specific implementation details of\nsatisfies depend on whether the algorithm is PUHF, PUHF2,\nPUHF3, or PUHF4. In addition, algorithm-specific auxiliary\ncomputations related to satisfies are omitted for clarity."}, {"title": "State Expansion Bottlenecks in\nConstrained Parallel Search", "content": "Previous work has shown that CPGBFS (all of the PUHF\nvariants) have a significantly lower state evaluation rate than\nunconstrained parallel search (KPGBFS). There are two, re-\nlated reasons for the low state evaluation rate in CPGBFS:\n(1) the expansion constraint, and (2) eager evaluation policy.\nExpansion Constraint Bottleneck Unconstrained paral-\nlel search algorithms such as KPGBFS will unconditionally\nexpand the top states in Open. Threads in unconstrained par-\nallel search algorithms are only idle when waiting for a mu-\ntex lock for the shared Open and Closed structures. If the\nshared Open/Closed data structures are implemented effi-\nciently (e.g., using sharding to internally partition the data"}, {"title": "Separate Generation and Evaluation\n(SGE)", "content": "In this section, we propose SGE, an approach for increasing\nthe state evaluation rate in constrained best-first search al-\ngorithms such as PUHF. SGE alleviates the batch successor\ninsertion bottleneck described above.\nContinuing the example from the previous section, in the\ncase of Figure 1, instead of waiting idly while one thread\nexpands $s_{1,1}$ (which includes computing all of the heuris-\ntic values for $s_{2,1}, s_{2,2}, ..., s_{2,x}$), it would be more efficient to\nparallelize the evaluation of $s_{2,1}, s_{2,2}, ..., s_{2,x}$ among avail-\nable threads.\nWe propose Separate Generation and Evaluation (SGE),\nwhich parallelizes state evaluations in addition to expan-\nsions. The main idea is to decompose the expansion of state\ns into separate units of work which can be parallelized:"}, {"title": "Experimental Evaluation of SGE", "content": "In this section, we experimentally evaluate SGE. We empha-\nsize that the goal of this experimental study is to evaluate and\nunderstand SGE as an implementation technique which can\nbe applied to a wide range of parallel best-first search algo-\nrithms. Thus, we focus on comparing PUHF2 vs. PUHF2s\nto evaluate the effect of SGE on constrained parallel best-\nfirst search, and we compare KPGBFS vs. KPGBFSs to\nevaluate the effect of SGE on unconstrained parallel best-\nfirst search. Comparing constrained parallel search vs. un-\nconstrained parallel search (e.g., PUHF2s vs. KPGBFS) is\nbeyond the scope of this study.\nTo evaluate SGE, we use the satisficing instances of the\nAutoscale-21.11 benchmark set (42 STRIPS domains, 30 in-\nstances/domain, 1260 total instances) (Torralba, Seipp, and\nSievers 2021), an improved benchmark suite based on the\nIPC classical planning benchmarks. All search algorithms\nuse the FF heuristic (Hoffmann and Nebel 2001). Each run"}, {"title": "Discussion and Conclusion", "content": "We proposed SGE, an approach to increase state evaluation\nrates in constrained parallel search algorithm by separating\nsuccessor generation and evaluation. We showed SGE sig-\nnificantly increases the state evaluation rate of PUHF2, re-\nsulting in improved overall performance for PUHF2s com-\npared to PUHF2. Preliminary experiments with PUHF and\nPUHF3 have yielded similar results, suggesting that SGE\nconsistently yields performance improvements for parallel\nGBFS algorithms with state expansion constraints. For un-\nconstrained search such as KPGBFS, SGE results in a de-\ncrease in evaluation rate, as there are no bottlenecks in un-\nconstrained search, and the additional complexity of SGE\nimposes an overhead.\nWe also showed that SGE results in more efficient search\n(fewer expansions to solve an instance) for both PUHF2\n(constrained search) as well as for KPGBFS (unconstrained\nsearch). While we hypothesize that this is because SGE with\nk threads behaves as if there were fewer, faster threads as ex-\nplained in Section 5, a deeper experimental investigation of\nthe expansion order with and without SGE is an avenue for\nfuture work.\nThe batch successor insertion state bottleneck addressed\nby SGE (Section 4) is a byproduct of implementing a par-\nallel search algorithm which is limited to expanding a set\nof states similar to the states expanded by single-threaded\nGBFS with a standard eager evaluation policy, where states\nare evaluated immediately after they are generated and be-\nfore being inserted in Open. In lazy (deferred) evaluation\n(Richter and Helmert 2009), where states are not evaluated\nbefore insertion into Open and are inserted into Open based\non their parent's f-value (and later evaluated when they are\nexpanded), the batch successor insertion bottleneck would"}]}