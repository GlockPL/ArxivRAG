{"title": "Separate Generation and Evaluation for Parallel Greedy Best-First Search", "authors": ["Takumi Shimoda", "Alex Fukunaga"], "abstract": "Parallelization of Greedy Best First Search (GBFS) has been difficult because straightforward parallelization can result in search behavior which differs significantly from sequential GBFS, exploring states which would not be explored by sequential GBFS with any tie-breaking strategy. Recent work has proposed a class of parallel GBFS algorithms which constrains search to exploration of the Bench Transition System (BTS), which is the set of states that can be expanded by GBFS under some tie-breaking policy. However, enforcing this constraint is costly, as such BTS-constrained algorithms are forced to spend much of the time waiting so that only states which are guaranteed to be in the BTS are expanded. We propose an improvement to parallel search which decouples state generation and state evaluation and significantly improves state evaluation rate, resulting in better search performance.", "sections": [{"title": "Introduction", "content": "Parallelization of combinatorial search algorithms is important in order to maximize search algorithm performance on modern, multi-core CPUs. In the case of cost-optimal search, parallelization of the standard A* algorithm (Hart, Nilsson, and Raphael 1968) is somewhat well understood, and viable, practical approaches have been proposed. The optimality requirement imposes a relatively strong constraint on the set of states which must be expanded by any parallel A* (all nodes with f-values less than the optimal path cost C* must be expanded), so previous work has focused on approaches for expanding those required states while minimizing synchronization and communication overheads and avoiding expansion of non-required states (Burns et al. 2010; Kishimoto, Fukunaga, and Botea 2013; Phillips, Likhachev, and Koenig 2014; Fukunaga et al. 2017).\nFor satisficing search where the object is to quickly find any valid solution path (regardless of path cost), parallelization is not well understood. Greedy Best First Search (GBFS; Doran and Michie (1966)) is a widely used satisficing search algorithm. However, the performance of straightforward parallelizations of GBFS is non-monotonic with respect to resource usage \u2013 there is a significant risk that using k threads can result in significantly worse performance than using fewer than k threads. It has been shown experimentally that parallel GBFS can expand orders of magnitude more states than GBFS (Kuroiwa and Fukunaga 2019), and it has been shown theoretically that KPGBFS, a straightforward parallelization of GBFS, can expand arbitrarily many more states than GBFS (Kuroiwa and Fukunaga 2020).\nUnlike parallel cost-optimal search, there is no obvious set of states which a parallel satisficing search must explore in order to be considered a \u201ccorrect\" parallelization of the sequential algorithm. Recent theoretical analysis of GBFS has yielded a promising direction for determining which states should be expanded. Heusner, Keller, and Helmert (2017) identified the Bench Transition System (BTS), the set of all states that can be expanded by GBFS under some tie-breaking policy (conversely, if a state is not in the BTS, there does not exist any tie-breaking strategy for GBFS which will expand that state). Limiting search to states in the BTS provides a natural constraint for parallel GBFS.\nRecent work has proposed parallel GBFS algorithms which expand states from Open only if some constraint is satisfied. Kuroiwa and Fukunaga (2020) proposed PUHF, a parallel GBFS which guarantees that only states which are in the BTS will be expanded. However, this guarantee comes at a cost in performance. Since PUHF prevents expansion of any state unless it is certain that the state is in the BTS, threads can be forced to be idle while they wait until a state which is guaranteed to be in the BTS become available, resulting in significantly worse performance than KPGBFS. Improved versions of PUHF with looser constraints (which still guarantee that only states in the BTS are expanded) have been proposed (Shimoda and Fukunaga 2023), but these still have a significantly lower state evaluation rate than parallel GBFS without expansion constraints.\nIn this paper, we propose Separate Generation and Evaluation (SGE), which decouples state expansion and evaluation so that instead of waiting for a single thread to fully expand a state (generating and evaluating its successors), multiple threads can be used to evaluate the successors. We show that this significantly improves the state evaluation rate in parallel GBFS with expansion constraints.\nThe rest of the paper is structured as follows. Section 2 reviews background and previous work. Section 3 presents"}, {"title": "Preliminaries and Background", "content": "State Space Topology State space topologies are defined following Heusner, Keller, and Helmert (2018).\nDefinition 1. A state space is a 4-tuple $S = (S, succ, S_{init}, S_{goal})$, where S is a finite set of states, $succ : S\u2192 2^S$ is the successor function, $S_{init} \u2208 S$ is the initial state, and $S_{goal} \u2286 S$ is the set of goal states. $\u2200s \u2208 S_{goal}, succ(s) = \u00d8$. A heuristic for S is a function $h: S \u2192 N_0$ and $\u2200s \u2208 S_{goal},h(s) = 0$. A state space topology is a pair (S, h), where S is a state space.\nWe call a sequence of states $(s_0, ..., s_n)$ a path from $s_0$ to $s_n$, and denote the set of paths from s to s' as $P(s, s')$. $p_i$ is the i th state in a path p and |p| is the length of p. A solution of a state space topology is a path p from $S_{init}$ to a goal state. We assume at least one goal state is reachable from $S_{init}$, and $\u2200s \u2208 S, s \u2209 succ(s)$.\nBest-First Search Best-First Search (BFS) is a class of search algorithms that use an evaluation function $f : S \u2192 \\mathbb{R}$ and a tie-breaking strategy \u03c4. BFS searches states in the order of evaluation function values (f-values). States with the same f-value are prioritized by \u03c4. In Greedy Best-First Search (GBFS; Doran and Michie (1966)), $f(s) = h(s)$.\nK-Parallel GBFS (KPGBFS) K-Parallel BFS (Vidal, Bordeaux, and Hamadi 2010) is a straightforward, baseline parallelization of BFS. All threads share a single Open and Closed. Each thread locks Open to remove a state s with the lowest f-value in Open, locks Closed to check duplicates and add succ(s) to Closed, and locks Open to add succ(s) to Open. KPGBFS is KPBFS with $f(s) = h(s)$.\nThe set of states explored by KPGBFS may be very different from those explored by GBFS. Kuroiwa and Fukunaga (2020) showed that straightforward parallelizations of GBFS with shared Open and/or Closed, including KPGBFS, can expand arbitrarily more states than GBFS.\nBench Transition Systems Heusner et al. (2017) defined bench transition system (BTS) in order to characterize the behavior of GBFS, building upon the definition of high-water marks by Wilt and Ruml (2014). The BTS is defined as the set of all states which can be expanded by GBFS with some tie-breaking policy, i.e., a state s is in the BTS if there exists some tie-breaking policy under which s is expanded. Conversely, states not in the BTS will not be expanded by GBFS under any tie-breaking policy.\nBTS-Constrained Search Restricting the search to only expand states which are in the BTS is a natural constraint for parallel GBFS."}, {"title": "Constrained Parallel GBFS", "content": "As described above, the original proposing PUHF and PUHF2-4 presented these algorithms as marking states guaranteed to be in the BTS as certain, and only expanding nodes marked as certain. The stage in the algorithm where states were marked as certain were specific to the specific algorithm (PUHF, PUHF2\u20134). However, the the similarities and differences among KPGBFS, PUHF, and PUHF2\u20134 can be clarified by reframing this behavior in terms of satisfying an algorithm-specific expansion constraint.\nWe present a unified framework, Constrained Parallel GBFS (CPGBFS) (Algorithm 1), which subsumes KPGBFS, PUHF, and PUHF2\u20134. CPGBFS is a schema for a class of parallel search algorithms based on KPGBFS, which only expands nodes which satisfy some algorithm-specific constraint in line 7, where satisfies(s) is a function which returns true if and only if s satisfies the algorithm-specific expansion constraint.\nKPGBFS is a special case of CPGBFS where satisfies(s) always returns true. The previously proposed BTS-constrained search algorithms (PUHF and PUHF2\u20134) are instances of CPGBFS where the satisfies(s) function implements a check for the sufficient constraint which guarantees that s is in the BTS \u2013 the specific implementation details of satisfies depend on whether the algorithm is PUHF, PUHF2, PUHF3, or PUHF4. In addition, algorithm-specific auxiliary computations related to satisfies are omitted for clarity."}, {"title": "State Expansion Bottlenecks in Constrained Parallel Search", "content": "Previous work has shown that CPGBFS (all of the PUHF variants) have a significantly lower state evaluation rate than unconstrained parallel search (KPGBFS). There are two, related reasons for the low state evaluation rate in CPGBFS: (1) the expansion constraint, and (2) eager evaluation policy.\nExpansion Constraint Bottleneck Unconstrained parallel search algorithms such as KPGBFS will unconditionally expand the top states in Open. Threads in unconstrained parallel search algorithms are only idle when waiting for a mutex lock for the shared Open and Closed structures. If the shared Open/Closed data structures are implemented efficiently (e.g., using sharding to internally partition the data"}, {"title": "Separate Generation and Evaluation (SGE)", "content": "In this section, we propose SGE, an approach for increasing the state evaluation rate in constrained best-first search algorithms such as PUHF. SGE alleviates the batch successor insertion bottleneck described above.\nContinuing the example from the previous section, in the case of Figure 1, instead of waiting idly while one thread expands $s_{1,1}$ (which includes computing all of the heuristic values for $s_{2,1}, s_{2,2}, \u2026, s_{2,x}$), it would be more efficient to parallelize the evaluation of $s_{2,1}, s_{2,2},.., s_{2,x}$ among available threads.\nWe propose Separate Generation and Evaluation (SGE), which parallelizes state evaluations in addition to expansions. The main idea is to decompose the expansion of state s into separate units of work which can be parallelized:"}, {"title": "Discussion and Conclusion", "content": "We proposed SGE, an approach to increase state evaluation rates in constrained parallel search algorithm by separating successor generation and evaluation. We showed SGE significantly increases the state evaluation rate of PUHF2, resulting in improved overall performance for PUHF2s compared to PUHF2. Preliminary experiments with PUHF and PUHF3 have yielded similar results, suggesting that SGE consistently yields performance improvements for parallel GBFS algorithms with state expansion constraints. For unconstrained search such as KPGBFS, SGE results in a decrease in evaluation rate, as there are no bottlenecks in unconstrained search, and the additional complexity of SGE imposes an overhead.\nWe also showed that SGE results in more efficient search (fewer expansions to solve an instance) for both PUHF2 (constrained search) as well as for KPGBFS (unconstrained search). While we hypothesize that this is because SGE with k threads behaves as if there were fewer, faster threads as explained in Section 5, a deeper experimental investigation of the expansion order with and without SGE is an avenue for future work.\nThe batch successor insertion state bottleneck addressed by SGE (Section 4) is a byproduct of implementing a parallel search algorithm which is limited to expanding a set of states similar to the states expanded by single-threaded GBFS with a standard eager evaluation policy, where states are evaluated immediately after they are generated and before being inserted in Open. In lazy (deferred) evaluation (Richter and Helmert 2009), where states are not evaluated before insertion into Open and are inserted into Open based on their parent's f-value (and later evaluated when they are expanded), the batch successor insertion bottleneck would"}]}