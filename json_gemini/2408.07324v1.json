{"title": "On-the-fly Synthesis for LTL over Finite Traces: An Efficient Approach that Counts", "authors": ["SHENGPING XIAO", "YONGKANG LI", "SHUFANG ZHU", "JUN SUN", "JIANWEN LI", "GEGUANG PU", "MOSHE Y. VARDI"], "abstract": "We present an on-the-fly synthesis framework for Linear Temporal Logic over finite traces (LTLf) based on top-down deterministic automata construction. Existing approaches rely on constructing a complete Deterministic Finite Automaton (DFA) corresponding to the LTLf specification, a process with doubly exponential complexity relative to the formula size in the worst case. In this case, the synthesis procedure cannot be conducted until the entire DFA is constructed. This inefficiency is the main bottleneck of existing approaches. To address this challenge, we first present a method for converting LTLf into Transition-based DFA (TDFA) by directly leveraging LTLf semantics, incorporating intermediate results as direct components of the final automaton to enable parallelized synthesis and automata construction. We then explore the relationship between LTLf synthesis and TDFA games and subsequently develop an algorithm for performing LTLf synthesis using on-the-fly TDFA game solving. This algorithm traverses the state space in a global forward manner combined with a local backward method, along with the detection of strongly connected components. Moreover, we introduce two optimization techniques - model-guided synthesis and state entailment to enhance the practical efficiency of our approach. Experimental results demonstrate that our on-the-fly approach achieves the best performance on the tested benchmarks and effectively complements existing tools and approaches.", "sections": [{"title": "1 INTRODUCTION", "content": "Formal synthesis aims to generate a system from a specification in a manner that is correct by construction, i.e., ensuring the resulting system satisfies the specification. Compared with formal verification, in which case both a specification and an implementation must be provided, synthesis automatically derives the latter from the former, with a correctness guarantee. Synthesis thus indicates a fundamental paradigm shift, transitioning the construction of reactive systems from the imperative to the declarative level. In situations where a comprehensive specification is available prior to system implementation, synthesis presents a natural and promising endeavor. Furthermore, reactive synthesis emerges as a specialized synthesis process focused on the automatic creation of reactive systems based on given specifications, such that the interactive behaviors between the system and the adversarial environment are guaranteed to satisfy the specification.\nThe decidability of the synthesis problem, i.e., determining the existence of a system that implements a given specification, is called realizability. Synthesis and realizability were initially introduced by Church [11], who used Monadic Second-Order Logic of One Successor (S1S) as a specification language. The S1S synthesis and realizability problems were solved in the 1960s [9, 37], with a non-elementary complexity. In recent years, temporal logics, especially Linear Temporal Logic (LTL) [35], have proven to be a valuable and more modern tool for specifying system behaviors and expressing temporal properties. LTL synthesis and realizability have become an active research area in formal methods, and fruitful works about LTL synthesis have been established on both the theoretical and practical aspects, e.g., [7, 22, 31, 32], to name a few.\nLTL formulas are interpreted over infinite traces, which are suitable for describing the infinite behaviors of non- terminating systems. Meanwhile, reasoning about temporal constraints or properties over a finite-time horizon is useful and important in various areas, such as business processes [34, 43], robotics [29], and user preferences [5]. To this end, a variant of LTL with an adaptation to finite-trace semantics, called LTLf, has emerged as a popular logic, especially in AI-related domains since its introduction [15]. Extensive works have studied fundamental theoretical and practical problems of LTLf, e.g., satisfiability checking [30] and translation to automata [14, 38]. In this work, we focus on the problem of synthesizing systems from specifications in LTLf, which was first introduced in [16].\nWe study the problem of reactive synthesis in the context of synchronous reactive systems, which maintain a constant interaction with the environment. From the perspective of the system, variables involved in the specification can be partitioned into inputs and outputs: outputs are under the control of the system, while inputs are assigned by the environment adversarially. Therefore, at each time point, we need to find some output that can adequately handle all possible inputs. More specifically, given every possible input sequence, solving the synthesis problem is to find an output sequence that induces an execution satisfying the specification.\nAutomata-based approaches play a key role in solving LTLf synthesis, which is the same as in other reactive synthesis problems such as LTL synthesis [6]. Every LTLf formula can be converted into an equivalent Deterministic Finite Automaton (DFA) recognizing the same language [15], and LTLf synthesis and realizability can be solved by reducing to suitable two-player games specified by the corresponding DFA [16]. The process of solving LTLf synthesis can be broken down into two parts. Firstly, we construct an equivalent DFA from the LTLf specification. Secondly, a reachability two-player game on the DFA, which is considered as the game arena, is solved by a backward fixed-point computation. To solve this reachability game, we iteratively refine an under-approximation of the set of winning states (for the system) of the DFA. Initially, the set of winning states is simply the set of accepting states. After that, it is expanded into a larger winning set after each iteration until no more states can be added. Upon reaching the fixed point,"}, {"title": "On-the-fly Synthesis for LTL over Finite Traces: An Efficient Approach that Counts", "content": "if the initial state is in the winning set, we conclude that the LTLf formula is realizable and return a winning strategy; conversely, the LTL\u0192 formula is unrealizable. Hereafter, we refer to this approach as \u2018backward search'. As established in [15, 16], an LTL\u0192 formula can be translated into the corresponding DFA in 2EXPTIME, a reachability game on a DFA can be solved in linear time in the number of states of the automaton, and the asymptotic complexity of LTLf synthesis is 2EXPTIME-complete.\nFollowing the aforementioned theoretical framework, several efforts have been made in developing practical LTLf synthesis approaches, which make various attempts to improve the DFA construction process. S. Zhu et al. [46] transform LTLf formulas into equivalent formulas in first-order logic (FOL) on finite words [42] and employ the off-the-shelf FOL-to-DFA translator MONA [27] for DFA construction. Subsequent works [4, 39] decompose the LTLf formula on the conjunction level and construct the corresponding DFA for the conjuncts, respectively. G. De Giacomo et al. [14] decompose the LTL\u0192 formula on the thorough syntax level, translate LTL\u0192 formulas into formulas in Linear Dynamic Logic over finite traces [15] (LDLf), then build the DFA based on the LDLf semantics. All these studies collectively show that the DFA construction is the main bottleneck of LTLf synthesis in both theory and practice.\nThe primary challenge with the above synthesis techniques is the DFA construction from the LTLf specification, which has a doubly exponential complexity. Consequently, the question arises: is it feasible to solve the LTLf synthesis problem without generating the entire DFA? An intuitive idea is to perform the synthesis procedure on-the-fly. In this work, we introduce an alternative framework for LTLf synthesis, employing direct and top-down automata construction and solving the corresponding automata games in a global forward and local backward manner. In top-down automata construction from LTL\u0192 formulas, the states and transitions computed in the process are parts of the final automaton. This enables us to possibly decide the realizability before reaching the worst-case double-exponential complexity.\nIn detail, we present a technique to create the transition-based DFA (TDFA) from LTLf specifications. This technique produces the automata based on the semantics of LTLf, which utilizes formula progression [2, 17] to separate what happens in the present (edge) and what would happen in the future (successor). It iteratively invokes a 'primitive', which builds a deterministic transition from a current state each time. To determine the realizability of the LTLf specification and synthesize a system, we solve a TDFA game on the fly while generating the TDFA. Solving a TDFA game means to classify the states of the corresponding TDFA into system-winning states and environment-winning states, from which the system/environment can win the game. Once the initial state is determined as a system-winning or environment-winning state, the realizability result of the original problem can be concluded. If realizable, it would also return a winning strategy. Typically, the strategy may be partial, as it does not require traversing the entire state space in the on-the-fly synthesis.\nFrom a global perspective, we perform a forward depth-first search. We search the state space starting from the initial state (the input LTLf formula here) and proceed forward to computing the remaining states of the automata as necessary. For each of the states, we check whether it is system-winning or environment-winning. Once a state is determined, a backtracking procedure is invoked to check whether the predecessors are system/environment-winning accordingly. However, since there may be loops in the automaton transition system, we may not have collected all the necessary information upon the first visit to a state. This results in the occurrences of undetermined states during the global forward search. Consequently, a local backward search is also required. During the depth-first traversal, we employ Tarjan's algorithm [40] to detect strongly connected components (SCCs). We show that we have already obtained all the necessary information required to resolve a current SCC when the forward search of states within the SCC is completed, though there may still be states left undetermined at that time. At this point, a local backward search is conducted within the scope of the current SCC to finalize the states left undetermined by the forward search."}, {"title": "On-the-fly Synthesis for LTL over Finite Traces: An Efficient Approach that Counts", "content": "Furthermore, we propose two optimizations to make the above on-the-fly synthesis framework more practical. Firstly, we guide the synthesis procedure with satisfiable traces of the LTLf specification to achieve a more targeted search. In LTLf synthesis, the potential choices for both the system and the environment can be exponentially many. Hence, a random search in the above on-the-fly synthesis is unlikely to be efficient. Considering the winning condition of the games is reaching accepting states/transitions, we adopt a greedy strategy: each time we need to move forward, we choose the edge that leads to one of the nearest accepting transitions from the current state. Secondly, we investigate the semantic entailment relations among system-winning states, as well as among environment-winning states. If a newly computed state is semantically entailed by a known system-winning state or semantically entails a known environment-winning state, we can accordingly classify it as system-winning or environment-winning.\nWe implement our approach in a tool called Tople and conduct comprehensive experiments by comparing it with state-of-the-art LTL\u0192 synthesis tools. Experimental results show that Tople and the on-the-fly approach achieve the best overall performance, though they cannot completely subsume other tools and approaches. Additionally, we also demonstrate the effectiveness of the two optimization techniques through an ablation study.\nOrigin of the Results. On-the-fly LTLf synthesis was first presented in [44], and model-guided LTLf synthesis was introduced in [45]. Beyond these, the new contributions of this work include:\n\u2022 Providing the full proofs for lemmas and theorems previously introduced in conference papers.\n\u2022 Formulating the (T)DFA game and discussing its relationship with LTLf synthesis in more detail.\n\u2022 Completing the on-the-fly approach by proposing a solution to better handle loops in the automaton transition system - detecting SCCs.\n\u2022 Introducing the optimization technique of state entailment."}, {"title": "2 PRELIMINARIES", "content": "A sequence of some elements is denoted by \\(\u03b6 = \u03b6[0], \u03b6[1],\u00b7\u00b7\u00b7, \u03b6[k], ...\\). The elements can be propositional interpreta- tions, states of an automaton, or elements from a set, and we denote by \\(&\\) the set of elements in general. A sequence can either be finite (i.e., \\(\u03b6\u2208 &*\\)) or infinite (i.e., \\(\u03b6\u03b5 \u0190\u00ae\\)). \\(\u03b6[i]\\) (\\(0 \u2264 i < ||\\)) is the i-th element of \\(\u03b6\\). \\(\u03b6|\\) represents the length of \\(\u03b6\\), and we have \\(|| = \u221e\\) if \\((\u03b6\\) is infinite. We use \\(\u03b6^i\\) to represent \\(\u03b6[0], \u03b6 [1],\u00a8\u00a8\u00a8, \u0163 [i \u2212 1]\\) (\\(i \u2265 1\\)), which is the prefix of up to position i (excluding i), and \\(\u03b6_i\\) to represent \\(\u03b6[i], \u03b6[i + 1],\u00b7\u00b7\u00b7, [n]\\), which is the suffix of \\((\u03b6\\) from position i (including i). The empty sequence is denoted by \\(e\\). We have \\(\u03b6^1= \u0454\\) and \\(\u03b6_j = \u0454\\) when \\(i \u2264 0\\) and \\(j \u2265 |5|\\) hold, respectively."}, {"title": "2.1 Linear Temporal Logic over Finite Traces", "content": "Linear Temporal Logic over finite traces, or LTLf [15], extends propositional logic with finite-horizon temporal connectives. Generally speaking, LTLf is a variant of Linear Temporal Logic (LTL) [35] that is interpreted over finite traces.\n2.1.1 LTLf Syntax. Given a set of atomic propositions P, the syntax of LTLf is identical to LTL, and defined as:\n\\[\u03c6 ::= tt | p | \u00ab\u03c6|\u03c6\u03bb\u03c6|\u03bf\u03c6|\u03c6\u03c5\u03c6, \\]\n(1)\nwhere tt represents the true formula, \\(p \u2208 P\\) is an atomic proposition, represents negation, \\(\u039b\\) represents conjunction, o represents the strong Next operator and \\(U\\) represents the Until operator. We also have the corresponding dual operators ff (false) for tt, V (disjunction) for \\(\u039b\\), (weak Next) for o and R (Release) for U. Moreover, we use the notation G\u03c6 (Global) and F\u03c6 (Future) to represent ff R q and tt U q, respectively. Notably, o is the standard Next (also known as"}, {"title": "On-the-fly Synthesis for LTL over Finite Traces: An Efficient Approach that Counts", "content": "strong Next) operator, while is weak Next; o requires the existence of a successor instant, while does not. Thus \u2022 is always true in the last instant of a finite trace since no successor exists there. A literal is an atom \\(p \u2208 P\\) or its negation (\u00acp). An LTL\u0192 formula is in the negation normal form if the negation operator appears only in front of atomic propositions. Every LTL\u0192 formula can be converted into an equivalent LTL\u0192 formula in negation normal form in linear time. Hereafter, we assume that all LTL\u0192 formulas are in negation normal form.\n2.1.2 LTLf Semantics. A finite trace \\(p = p[0], \u03c1[1],\u00b7\u00b7\u00b7, \u03c1[n] \u2208 (2\u00ba)*\\) is a finite sequence of propositional interpreta- tions. Intuitively, p[i] is interpreted as the set of propositions that are true at instant i. LTL\u0192 formulas are interpreted over finite traces. For a finite trace p and an LTLf formula q, we define the satisfaction relation \\(p = \u03c6\\) (i.e., p is a model of q) as follows:\n\u2022 ptt and pff;\n\u2022 \\(p = p\\) iff \\(p\u2208 p[0]\\), and \\(p = \u00acp\\) iff \\(p \u00a2 p[0]\\), where \\(p \u2208 P\\) is an atomic proposition;\n\u2022 \\(p\u3151 1 ^ 2\\) iff \\(p = 41\\) and \\(p\u3151 \u03c62\\);\n\u2022 \\(p\u3151 1 \u2228 2\\) iff \\(p = 41\\) or \\(p = \u03c62\\);\n\u2022 \\(\u03c1 = 0\u03c6\\) iff \\(|p| > 1\\) and \\(p\u2081 = \u03c6\\);\n\u2022 \\(\u03c1 = \u2022\u03c6\\) iff \\(|p| = 1\\) or \\(p\u2081 = \u03c6\\);\n\u2022 \\(p\u3151 1 U 2\\) iff there exists i with \\(0 \u2264 i < |p|\\) such that \\(pi = 2\\) holds, and for every j with \\(0 \u2264 j < i\\) it holds that \\(pj = 1\\);\n\u2022 \\(p\u3151 1 R 2\\) iff there exists i with \\(0 \u2264 i < |p|\\) such that \\(i = |p| \u2212 1\\) or \\(pi = 1\\) holds, and \u2461 for every j with \\(0 \u2264 j \u2264 i\\) it holds that \\(pj = 42\\).\nThe set of finite traces that satisfy LTLf formula q is the language of q, denoted as \\(L(\u03c6) = {p \u2208 (2\u00ae)+ | \u03c1 = \u03c6}\\). Two LTLf formulas \\(41\\) and \\(42\\) are semantically equivalent, denoted as \\(q1 = 42\\), iff for every finite trace p, \\(p = \u03c61\\) iff \\(p = \u03c62\\). And \\(41\\) semantically entails \\(42\\), denoted as \\(41 \u21d2 42\\), iff for every finite trace p, \\(p = \u03c62\\) if \\(p = \u03c61\\). And \\(41 \u21d2 42\\) denotes that semantic entailment does not hold. From the LTLf semantics, we have the following lemma.\nLEMMA 2.1. For arbitrary LTLf formulas \\(41\\) and \\(42\\), it holds that\n\u2022 \\(1 U 42 = 2 \u2228 (\u03c61^0(41 \u0418 \u03c62))\\);\n\u2022 \\(41 R 2 = 42 \u2227 (41\u2228 \u2022 (41 R \u03c62))\\)."}, {"title": "2.1.3 Propositional Semantics for LTLf", "content": "In addition to the language-based semantics of LTLf, we assign propositional semantics to LTL\u0192 formulas by treating temporal subformulas as propositional variables, which plays a useful role in linear temporal reasoning as in [20, 24, 30]. A formula q is classified as temporal if it is neither a conjunction nor a disjunction, i.e., either it is a literal or the root of its syntax tree is labelled by a temporal operator (0,, U, or R). We represent the set of temporal subformulas of q as tcl(q) (signifying \u2018temporal closure'). Formally, given a set of LTLf formulas I and an LTL\u0192 formula q, the propositional satisfaction relation \\(I \u3151_p q\\) is defined as follows:\n\u2022 \\(I \u3151_p tt\\) and \\(I \u3151_p ff\\);\n\u2022 \\(I \u3151_p l\\) iff \\(l \u2208 I\\), where l is a literal;\n\u2022 \\(I F_p 1 ^ 2\\) iff \\(I \u3151_p 41\\) and \\(I Ep 42\\);\n\u2022 \\(I \u3151_p 1 \u2228 2\\) iff \\(I \u3151_p \u00a21\\) or \\(I \u3151_p 2\\);\n\u2022 \\(I \u3151_p op q\\) iff \\(op q \u2208 I\\), where \\(op \u2208 {0,}\\} ;\n\u2022 \\(I F_p 1 Op 2\\) iff \\(q1 op \u03c62 \u2208 I\\), where \\(op \u2208 {U, R}\\)."}, {"title": "On-the-fly Synthesis for LTL over Finite Traces: An Efficient Approach that Counts", "content": "Two formulas \u03c6, \u03c8 are propositionally equivalent, denoted \\(\u03c6 ~ \u03c8\\), if for arbitrary formula sets I, \\(I \u3151_p q\\) iff \\(I \u3151_p \u03c8\\) holds. The propositional equivalence class of a formula q is denoted by \\([q]~\\) and defined as \\([\u03c6]~ = {\u03c8 | \u03c6 ~ \u03c8}\\). The propositional quotient set of a set of formulas I is denoted \\(\u03a6/~\\) and defined as \\(\u03a6/~= {[q]~ | \u03c6 \u2208 \u03a6}\\). The following are two properties of propositional semantics.\nLEMMA 2.2. Given a function f on formulas such that \\(f(tt) = tt, f(ff) = ff\\), and \\(f(x1 x2) = f(x1) f(x1)\\), \\(f(x1 \u2228 x2) = f(x1) \u2228 f(x2)\\) for all formulas \\(X_1\\) and \\(X_1\\), for every LTLf formulas q and \u03c8, if \\(\u03c6 ~ \u03c8\\), then \\(f(\u03c6) ~ f(\u03c8)\\).\nPROOF. A proof for this lemma within the context of LTL is provided in [20], which can be readily extended to LTLf. We here offer a brief proof sketch. First, for every formula q and every assignment I, we can obtain the following result by a structural induction on \u03c6.\n\\[I \u3151_p f(q) \u21d4 {x \u2208 tcl(q) | I =_p f(x)} F_p q \\]\n(2)\nSecond, we demonstrate that \\(I \u3151_p f(q) \u2192 I =_p f(4)\\) holds for every assignment I, which suffices to support Lemma 2.2 by symmetry.\n\\[I =_p f(q) \u2192 {x \u2208 tcl(q) | I =_p f(x)} =_p q\\].\n\\[\u21d4 {x \u2208 tcl(q) | I =_p f(x)} =_p \u03c8\\].\n\\[\u21d2 {x \u2208 tcl(\u03c6) \u2229 tcl(f) | I =_p f(x)} F_p \u03c8\\].\n\\[\u21d2 {x \u2208 tcl(\u03c8) | I |=_p f(x)} =_p \u03c8\\].\n\\[\u21d4 I =_p f(4)\\].\nLEMMA 2.3. Given two LTLf formulas \\(41\\) and \\(42\\) such that \\(\u03c61 ~ \u03c8\\), p = \u03c6 iff p = \u03c8 holds for every finite trace p.\nPROOF. We here offer a brief proof sketch. First, for every formula q and every finite trace p, we can obtain the following result by a structural induction on \u03c6.\n\\[\u03c1\u3151 \u03c6\u21d4 {x \u2208 tcl(\u03c6) | p = x} =_p q \\]\n(3)\nSecond, we demonstrate that \\(p\u3151 \u03c6\u21d2 p\u3151\\) holds for every finite trace p, which suffices to support Lemma 2.3 by symmetry.\n\\[p = \u03c6\u21d4{x \u2208 tcl(q) | p = X} =_p q \\].\n\\[\u21d4{x \u2208 tcl(\u03c6) | p = x} F_p \u03c8\\].\n\\[\u21d2{x \u2208 tcl(\u03c6) \u2229 tcl(\u03c8) | p = x} F_p \u03c8\\].\n\\[\u21d2{x \u2208 tcl(\u03c8) | \u03c1 = x} F_p \u03c8\\].\n\\[\u03c1\u03c8\\].\nLemma 2.3 indicates that for any finite trace p, if \\(p = q\\) and \\(\u03c8 \u2208 [q]\\), then \\(pholds\\). We then generalize the language-based satisfaction relation to propositional equivalence classes. Given an LTL\u0192 formulas q and a finite trace p, we have \\(p = [q]~\\) iff \\(p = \u03c6\\)."}, {"title": "On-the-fly Synthesis for LTL over Finite Traces: An Efficient Approach that Counts", "content": "2.2 LTLf Synthesis\nIn the context of reactive synthesis, a comprehensive specification should encompass essential information, including the properties that the targeted system is required to satisfy, the partition of variables controlled separately by the system and the environment, and the type of the targeted system, i.e., either Mealy or Moore. Formally, an LTLf specification is a tuple \\((q, X, Y)_t\\), where q is an LTL\u0192 formula over propositions in \\(XUY\\); X is the set of input variables controlled by the environment, Y is the set of output variables controlled by the system, and it holds that \\(X \u2229 Y = 0\\); and t\u2208 {Mealy, Moore} is the type of the target system. In a reactive system, interactions happen in turns where both the system and the environment assign values to their respective controlled variables. The order of assignment within each turn determines the system types: if the environment assigns values first, it creates a Mealy machine; conversely, if the system assigns values first, it results in a Moore machine.\nDefinition 2.4 (LTLf Realizability and Synthesis). An LTLf specification \\((q, X, Y)_t\\) is realizable, iff:\n\u2022 t = Mealy. there exists a winning strategy \\(g : (2^X)^+ \u2192 2^Y\\) such that for an arbitrary infinite sequence \\(\u03bb = X_0, X_1,\u2026\u2026 \u2208 (2^X)^w\\) of propositional interpretations over X, there is \\(k \u2265 0\\) such that \\(p = \u03c6\\) holds, where \\(p = (X_o \u222a g(X_o)), (X_1 \u222a g(X_0, X_1)),\uff65\uff65\uff65, (X_k \u222a g(X_0,..., X_k))\\);\n\u2022 t = Moore. there exists a winning strategy \\(g : (2^X)^* \u2192 2^Y\\) such that for an arbitrary infinite sequence \\(\u03bb = X_0, X_1,\u2026\u2026 \u2208 (2^X)^w\\) of propositional interpretations over X, there is \\(k \u2265 0\\) such that \\(p = q\\) holds, where \\(p = (X_o \u222a g(\u20ac)), (X_1 \u222a g(X_o)),\uff65\uff65\uff65, (X_k \u222a g(X_0,\uff65\uff65\uff65, X_{k-1}))\\).\nThe LTL\u0192 realizability problem is to determine whether an LTLf specification is realizable, and the LTLf synthesis problem for a realizable specification is to compute a winning strategy. An LTLf specification is unrealizable when it is not realizable.\nSynthesis for constructing Mealy systems is also referred to as environment-first synthesis, while synthesis for constructing Moore systems is termed system-first synthesis. The methodologies presented in this paper are applicable to both environment-first and system-first synthesis. For brevity, we only focus on the system-first synthesis in the main text."}, {"title": "2.3 Transition-Based DFA", "content": "The Transition-based Deterministic Finite Automaton (TDFA) is a variant of the Deterministic Finite Automaton [38].\nDefinition 2.5 (TDFA). A transition-based DFA (TDFA) is a tuple \\(A = (2^P, S, init, 8, T)\\) where\n\u2022 \\(2^P\\) is the alphabet;\n\u2022 S is the set of states;\n\u2022 init \u2208 S is the initial state;\n\u2022 \\(\u03b4: S\u00d72^P \u2192 S\\) is the transition function;\n\u2022 \\(T \u2286 (S \u00d7 (2^P))\\) is the set of accepting transitions.\nThe run r of a finite trace \\(p = p[0], p[1],\u00b7\u00b7\u00b7, \u03c1[n] \u2208 (2^P)^+\\) on a TDFA A is a finite state sequence \\(r = S_0, S_1, \u00b7\u00b7\u00b7, S_n\\) such that \\(s_0 = init\\) is the initial state, \\(d(s_i, p[i]) = s_{i+1}\\) holds for \\(0 \u2264 i < n\\). Note that runs of TDFA do not need to include the destination state of the last transition, which is implicitly indicated by \\(s_{n+1} = \u03b4(s_n, p[n])\\), since the starting state (\\(s_n\\)) together with the labels of the transition (p[n]) are sufficient to determine the destination. The trace p is accepted by A iff the corresponding run r ends with an accepting transition, i.e., \\((s_n, p[n]) \u2208 T\\). The set of finite traces"}, {"title": "On-the-fly Synthesis for LTL over Finite Traces: An Efficient Approach that Counts", "content": "accepted by a TDFA A is the language of A, denoted as \\(L(A)\\). According to [38], TDFA has the same expressiveness as DFA.\n2.4 Strongly Connected Components of a Directed Graph\nLet G = (V, E) be a directed graph. A component C C V of G is strongly connected if a directed path exists between any two vertices. C \u2286 V is a Strongly Connected Component, abbreviated as SCC, if C is strongly connected and no proper superset of C is strongly connected. The set of SCCs of G forms a Directed Acyclic Graph (DAG) that has an edge from \\(C_o\\) to \\(C_1\\) when there exists a vertex in \\(C_1\\) reachable from a vertex in \\(C_o\\). Tarjan's algorithm [40] finds all the SCCs of G in a single depth-first traversal of G, visiting each vertex just once, with a complexity of O(|V| + |E|). These components are detected in the reverse order of the topological sort of the DAG formed by the components. Specifically, if (\\(C_o, C_1\\)) is an edge of this DAG, then \\(C_1\\) is found before \\(C_o\\). Omitting the details of Tarjan's algorithm, we assume that it supports the following APIs along with a depth-first traversal:\n\u2022 isSccRoot(v) checks whether \\(v \u2208 V\\) is the root vertex of the current SCC. This function should be invoked when all successors of u have been processed with a depth-first strategy and it backtracks to v for the last time. If it returns true, it indicates that we have just finished traversing a SCC.\n\u2022 getScc() retrieves the SCC that has been detected just now after the isSccRoot(v) call returns true."}, {"title": "3 AUTOMATA CONSTRUCTION", "content": "(T)DFA construction plays a foundamental role in solving the LTLf synthesis problem. We now present a method for converting LTLf into TDFA using formula progression. This approach directly leverages LTLf semantics to expand the transition system. Additionally, the intermediate results generated during the construction process integrate into the final automaton, so that it can support on-the-fly LTLf synthesis.\nFormula progression has been investigated in prior studies [2, 17]. Here we extend this concept specifically to TDFA construction from LTLf. Given an LTLf formula q over P and a finite trace p \u2208 (2P)+, to make p = \u03c6, we can start from q to progress through p. We consider LTLf formula q into a requirement about the present p[0], which can be verified straightforwardly, and a requirement about the future that needs to hold for the yet unavailable suffix p1. Essentially, formula progression looks at q and p[0], and progresses a new formula \\(f_p(\u03c6, p[i])\\) such that \\(p = q\\) iff \\(P_1 = f_p(\u03c6, \u03c1[0])\\). This procedure is analogous to an automaton reading a trace, where it reaches accepting transitions by moving forward step by step.\nDefinition 3.1 (Formula Progression for LTLf). Given an LTL\u0192 formula q and a non-empty finite trace p, the progression formula \\(f_p(\u03c6, \u03c1)\\) is recursively defined as follows:\n\u2022 \\(f_p(tt, p) = tt\\) and \\(f_p(ff, p) = ff\\);\n\u2022 \\(f_p(p, p) = tt\\) if \\(p\u2208 p[0]\\); \\(f_p(p, p) = ff\\) if \\(p \u00a2 p[0]\\);\n\u2022 \\(f_p(\u00acp, p) = ff\\) if \\(p \u2208 p[0]\\); \\(f_p(\u00acp, p) = tt\\) if \\(p \u00a2 \u03c1[0]\\);\n\u2022 \\(f_p(\u03c6_1 ^ \u03c6_2, \u03c1) = f_p(\u03c6_1, p) ^ f_p(\u03c6_2, \u03c1)\\);\n\u2022 \\(f_p(\u03c6_1 \u2228 \u03c6_2, \u03c1) = f_p(\u03c6_1, \u03c1) V f_p(\u03c6_2, \u03c1)\\);\n\u2022 \\(f_p(0\u03c6, \u03c1) = \u03c6\\) if \\(|p| = 1\\); \\(f_p(0\u03c6, \u03c1) = f_p(\u03c6, \u03c1_1)\\) if \\(|p| > 1\\);\n\u2022 \\(f_p(\u2022\u03c6, \u03c1) = \u03c6\\) if \\(|p| = 1\\); \\(f_p(\u2022\u03c6, \u03c1) = f_p(\u03c6, \u03c1_1)\\) if \\(|p| > 1\\);\n\u2022 \\(f_p(\u03c6_1 U \u03c6_2, \u03c1) = f_p(\u03c6_2, p) V (f_p(\u03c6_1, \u03c1) ^ f_p(0(\u03c6_1 U \u03c6_2), \u03c1))\\);\n\u2022 \\(f_p(\u03c6_1 R 4_2, \u03c1) = f_p(\u03c6_2, p) ^ (f_p(\u03c6_1, \u03c1) V f_p(\u2022(\u03c6_1 R \u03c6_2), \u03c1))\\)."}, {"title": "On-the-fly Synthesis for LTL over Finite Traces: An Efficient Approach that Counts", "content": "Notice that a letter \\(\u03c3\u2208 2^P\\) is interpreted as a trace of length 1. So the second parameter of the function \\(f_p(\u03c6", "classes": "n\\[f_p([\u03c6", "\u03c1)": ["f_p(\u03c8, \u03c1)"], "\u03c6": ".", "\u03c1[0": "and\n(2) \\(\u03c1 = [\u03c6", "f_p([q": "\u03c1[0"}]}