{"title": "On-the-fly Synthesis for LTL over Finite Traces: An Efficient Approach that Counts", "authors": ["SHENGPING XIAO", "YONGKANG LI", "SHUFANG ZHU", "JUN SUN", "JIANWEN LI", "GEGUANG PU", "MOSHE Y. VARDI"], "abstract": "We present an on-the-fly synthesis framework for Linear Temporal Logic over finite traces (LTLf) based on top-down deterministic automata construction. Existing approaches rely on constructing a complete Deterministic Finite Automaton (DFA) corresponding to the LTLf specification, a process with doubly exponential complexity relative to the formula size in the worst case. In this case, the synthesis procedure cannot be conducted until the entire DFA is constructed. This inefficiency is the main bottleneck of existing approaches. To address this challenge, we first present a method for converting LTLf into Transition-based DFA (TDFA) by directly leveraging LTLf semantics, incorporating intermediate results as direct components of the final automaton to enable parallelized synthesis and automata construction. We then explore the relationship between LTLf synthesis and TDFA games and subsequently develop an algorithm for performing LTLf synthesis using on-the-fly TDFA game solving. This algorithm traverses the state space in a global forward manner combined with a local backward method, along with the detection of strongly connected components. Moreover, we introduce two optimization techniques - model-guided synthesis and state entailment to enhance the practical efficiency of our approach. Experimental results demonstrate that our on-the-fly approach achieves the best performance on the tested benchmarks and effectively complements existing tools and approaches.", "sections": [{"title": "1 INTRODUCTION", "content": "Formal synthesis aims to generate a system from a specification in a manner that is correct by construction, i.e., ensuring the resulting system satisfies the specification. Compared with formal verification, in which case both a specification and an implementation must be provided, synthesis automatically derives the latter from the former, with a correctness guarantee. Synthesis thus indicates a fundamental paradigm shift, transitioning the construction of reactive systems from the imperative to the declarative level. In situations where a comprehensive specification is available prior to system implementation, synthesis presents a natural and promising endeavor. Furthermore, reactive synthesis emerges as a specialized synthesis process focused on the automatic creation of reactive systems based on given specifications, such that the interactive behaviors between the system and the adversarial environment are guaranteed to satisfy the specification.\nThe decidability of the synthesis problem, i.e., determining the existence of a system that implements a given specification, is called realizability. Synthesis and realizability were initially introduced by Church [11], who used Monadic Second-Order Logic of One Successor (S1S) as a specification language. The S1S synthesis and realizability problems were solved in the 1960s [9, 37], with a non-elementary complexity. In recent years, temporal logics, especially Linear Temporal Logic (LTL) [35], have proven to be a valuable and more modern tool for specifying system behaviors and expressing temporal properties. LTL synthesis and realizability have become an active research area in formal methods, and fruitful works about LTL synthesis have been established on both the theoretical and practical aspects, e.g., [7, 22, 31, 32], to name a few.\nLTL formulas are interpreted over infinite traces, which are suitable for describing the infinite behaviors of non-terminating systems. Meanwhile, reasoning about temporal constraints or properties over a finite-time horizon is useful and important in various areas, such as business processes [34, 43], robotics [29], and user preferences [5]. To this end, a variant of LTL with an adaptation to finite-trace semantics, called LTLf, has emerged as a popular logic, especially in AI-related domains since its introduction [15]. Extensive works have studied fundamental theoretical and practical problems of LTLf, e.g., satisfiability checking [30] and translation to automata [14, 38]. In this work, we focus on the problem of synthesizing systems from specifications in LTLf, which was first introduced in [16].\nWe study the problem of reactive synthesis in the context of synchronous reactive systems, which maintain a constant interaction with the environment. From the perspective of the system, variables involved in the specification can be partitioned into inputs and outputs: outputs are under the control of the system, while inputs are assigned by the environment adversarially. Therefore, at each time point, we need to find some output that can adequately handle all possible inputs. More specifically, given every possible input sequence, solving the synthesis problem is to find an output sequence that induces an execution satisfying the specification.\nAutomata-based approaches play a key role in solving LTLf synthesis, which is the same as in other reactive synthesis problems such as LTL synthesis [6]. Every LTLf formula can be converted into an equivalent Deterministic Finite Automaton (DFA) recognizing the same language [15], and LTLf synthesis and realizability can be solved by reducing to suitable two-player games specified by the corresponding DFA [16]. The process of solving LTLf synthesis can be broken down into two parts. Firstly, we construct an equivalent DFA from the LTLf specification. Secondly, a reachability two-player game on the DFA, which is considered as the game arena, is solved by a backward fixed-point computation. To solve this reachability game, we iteratively refine an under-approximation of the set of winning states (for the system) of the DFA. Initially, the set of winning states is simply the set of accepting states. After that, it is expanded into a larger winning set after each iteration until no more states can be added. Upon reaching the fixed point,"}, {"title": "2 PRELIMINARIES", "content": "A sequence of some elements is denoted by \\( \u03b6 = \u03b6[0], \u03b6[1],\u00b7\u00b7\u00b7, \u03b6[k], ... \\). The elements can be propositional interpretations, states of an automaton, or elements from a set, and we denote by \\( \\mathcal{E} \\) the set of elements in general. A sequence can either be finite (i.e., \\( \u03b6 \\in \\mathcal{E}^* \\)) or infinite (i.e., \\( \u03b6 \\in \\mathcal{E}^\\omega \\)). \\(\u03b6[i]\\) (\\(0 \u2264 i < |\u03b6|\\)) is the i-th element of \\(\u03b6\\). \\(|\u03b6|\\) represents the length of \\(\u03b6\\), and we have \\(|\u03b6| = \\infty \\) if ( is infinite. We use \\(\u03b6^i\\) to represent \\( \u03b6[0], \u03b6 [1],\u00b7\u00b7\u00b7, \u03b6 [i \u2212 1] \\) (\\( i \u2265 1 \\)), which is the prefix of up to position i (excluding i), and \\(\u03b6_i\\) to represent \\(\u03b6[i], \u03b6[i + 1],\u00b7\u00b7\u00b7, \u03b6[n]\\), which is the suffix of ( from position i (including i). The empty sequence is denoted by e. We have \\(\u03b6^0 = \\epsilon \\) and \\(\u03b6_j = \\epsilon \\) when \\(i \u2264 0\\) and \\(j \u2265 |\u03b6|\\) hold, respectively.\n2.1 Linear Temporal Logic over Finite Traces\nLinear Temporal Logic over finite traces, or LTLf [15], extends propositional logic with finite-horizon temporal connectives. Generally speaking, LTLf is a variant of Linear Temporal Logic (LTL) [35] that is interpreted over finite traces.\n2.1.1 LTLf Syntax. Given a set of atomic propositions P, the syntax of LTLf is identical to LTL, and defined as:\n\\[\n\u03c6 ::= tt \\mid p \\mid \u00ac\u03c6\\mid\u03c6\u2227\u03c6\\mid\u03bf\u03c6\\mid\u03c6\u03c5\u03c6,\n\\]\nwhere tt represents the true formula, \\(p \u2208 P\\) is an atomic proposition, \\(\u00ac\\) represents negation, \\(\u2227\\) represents conjunction, o represents the strong Next operator and U represents the Until operator. We also have the corresponding dual operators ff (false) for tt, V (disjunction) for \\(\u2227\\), \\( \\bullet \\) (weak Next) for o and R (Release) for U. Moreover, we use the notation \\(G\u03c6\\) (Global) and \\(F\u03c6\\) (Future) to represent \\(ff R \u03c6\\) and \\(tt U \u03c6\\), respectively. Notably, o is the standard Next (also known as"}, {"title": "3 AUTOMATA CONSTRUCTION", "content": "(T)DFA construction plays a foundamental role in solving the LTLf synthesis problem. We now present a method for converting LTLf into TDFA using formula progression. This approach directly leverages LTLf semantics to expand the transition system. Additionally, the intermediate results generated during the construction process integrate into the final automaton, so that it can support on-the-fly LTLf synthesis.\nFormula progression has been investigated in prior studies [2, 17]. Here we extend this concept specifically to TDFA construction from LTLf. Given an LTLf formula q over P and a finite trace \\(\u03c1 \\in (2^P)^+\\), to make \\(\u03c1 |= \u03c6\\), we can start from q to progress through p. We consider LTLf formula q into a requirement about the present \\(\u03c1[0]\\), which can be verified straightforwardly, and a requirement about the future that needs to hold for the yet unavailable suffix \\(\u03c1_1\\). Essentially, formula progression looks at q and \\(\u03c1[0]\\), and progresses a new formula \\(f_\u03c1(\u03c6, \u03c1[i])\\) such that \\(\u03c1 |= \u03c6\\) iff \\(\u03c1_1 |= f_\u03c1(\u03c6, \u03c1[0])\\). This procedure is analogous to an automaton reading a trace, where it reaches accepting transitions by moving forward step by step.\nDefinition 3.1 (Formula Progression for LTLf). Given an LTLf formula q and a non-empty finite trace p, the progression formula \\(f_\u03c1(\u03c6, \u03c1)\\) is recursively defined as follows:\n* \\(f_\u03c1(tt, \u03c1) = tt\\) and \\(f_\u03c1(ff, \u03c1) = ff\\);\n* \\(f_\u03c1(p, \u03c1) = tt \\) if \\(p \\in \u03c1[0]\\); \\(f_\u03c1(p, \u03c1) = ff \\) if \\(p \\notin \u03c1[0]\\);\n* \\(f_\u03c1(\u00acp, \u03c1) = ff \\) if \\(p \\in \u03c1[0]\\); \\(f_\u03c1(\u00acp, \u03c1) = tt\\) if \\(p \\notin \u03c1[0]\\);\n* \\(f_\u03c1(\u03c6_1 \u2227 \u03c6_2, \u03c1) = f_\u03c1(\u03c6_1, \u03c1) \u2227 f_\u03c1(\u03c6_2, \u03c1)\\);\n* \\(f_\u03c1(\u03c6_1 \u2228 \u03c6_2, \u03c1) = f_\u03c1(\u03c6_1, \u03c1) V f_\u03c1(\u03c6_2, \u03c1)\\);\n* \\(f_\u03c1(\u25cb\u03c6, \u03c1) = \u03c6 \\) if \\(|\u03c1| = 1\\); \\(f_\u03c1(\u25cb\u03c6, \u03c1) = f_\u03c1(\u03c6, \u03c1_1)\\) if \\(|\u03c1| > 1\\);\n* \\(f_\u03c1(\\bullet\u03c6, \u03c1) = \u03c6 \\) if \\(|\u03c1| = 1\\); \\(f_\u03c1(\\bullet\u03c6, \u03c1) = f_\u03c1(\u03c6, \u03c1_1)\\) if \\(|\u03c1| > 1\\);\n* \\(f_\u03c1(\u03c6_1 U \u03c6_2, \u03c1) = f_\u03c1(\u03c6_2, \u03c1) V (f_\u03c1(\u03c6_1, \u03c1) \u2227 f_\u03c1(\u25cb(\u03c6_1 U \u03c6_2), \u03c1))\\);\n* \\(f_\u03c1(\u03c6_1 R \u03c6_2, \u03c1) = f_\u03c1(\u03c6_2, \u03c1) \u2227 (f_\u03c1(\u03c6_1, \u03c1) V f_\u03c1(\\bullet(\u03c6_1 R \u03c6_2), \u03c1))\\)."}, {"title": "4 TDFA GAMES", "content": "We now introduce two-player games on TDFA, which is considered as an invariant of traditional infinite reachabil-ity/safety graph-based games [6]. Moreover, most of the concepts and results presented in this section have their origins in, or correspond to, those found in infinite reachability/safety graph-based games. From a theoretical perspective, this section studies TDFA games in terms of formalism, solution, and their correlation with LTLf synthesis.\n4.1 What a TDFA Game Is\nThe TDFA game is played on a TDFA with the initial state removed. Every TDFA game involves two players, the environment and the system, controlling the variables in sets X and Y respectively. Each round of the game consists of a state and the environment and system setting the values of the propositions they control. The winner is determined by the winning condition, i.e., the accepting transitions T here. The system wins if the play reaches an accepting transition. The parameter \\(t \\in \\{Mealy, Moore\\}\\) specifies the order in which players assign values in each round. In alignment with LTLf synthesis, we focus on the situation of t = Moore in the main text, where the system assigns values first in each round.\nDefinition 4.1 (TDFA Game). A TDFA game is a tuple \\(G = (2^{X \\cup Y}, S, \u03b4, T)_t\\), where\n* \\(2^{X \\cup Y}\\) is the alphabet with \\(X \u2229 Y = 0\\);\n* S is the set of states;\n* \\(\u03b4: S \u00d7 2^\u2192 S\\) is the transition function;\n* \\(T \u2286 S \u00d7 2^\\mathcal{P}\\) is the set of accepting transitions;\n* \\(t \\in \\{Mealy, Moore\\}\\) is the type of the system.\nA play of the game starts in some state and progresses through various states as the system and environment alternately assign values.\nDefinition 4.2 (Play). A play is a sequence of rounds \\(\u03c1 = (s_0, X_0 \u222a Y_0), \u00b7\u00b7\u00b7, (s_n, X_n \u222a Y_n), \u00b7\u00b7\u00b7 \u2208 (S \u00d7 2^{X \\cup Y})^* \u222a (S \u00d7 2^{X \\cup Y})^@\\) such that \\(s_{i+1} = \u03b4(s_i, X_i \u222a Y_i)\\) holds for \\(0 \u2264 i < |\u03c1|\\), where the sequence may be finite or infinite. If the system wins, the play terminates; the play continues infinitely and the environment wins."}, {"title": "5 ON-THE-FLY LTL\u0192 SYNTHESIS", "content": "LTLf synthesis can be decomposed into two tasks: the construction of a TDFA with doubly exponential complexity, and the resolution of the TDFA game in linear time. As detailed in Section 3, we can convert an LTLf formula to an equivalent TDFA through a top-down method, where the intermediate results comprise the final automata directly. This enables us to address both tasks concurrently. In this section, we propose an on-the-fly approach designed to bypass the complete construction of the automaton and its associated doubly exponential complexity. This method conducts a global forward depth-first search along with the TDFA construction. During this process, we dynamically identify system-winning and environment-winning states based on the available information. As the process of depth-first searching progresses, we partition the states into their respective SCCs. Upon identifying each SCC, we perform a local backward fixed-point search to determine the states left unresolved by the forward search.\n5.1 Approach Overview\nRecall Theorem 4.10, solving the problem of LTL\u0192 realizability requires determining the corresponding TDFA games, i.e., determining the winning states for the system/environment in games. Intuitively, to identify a state as system-winning, one needs to find a system choice such that, regardless of the response of the environment, the system can enforce a win. Conversely, to determine an environment-winning state, for every action of the system, the environment must be able to find a winning response.\nGiven an LTLf specification \\((\u03c6, X, Y)_{Moore}\\), we depart from the initial state q and utilize formula progression to incrementally build the automaton \\(A_\u03c6\\) with a depth-first strategy. Figure 1 demonstrates the different scenarios"}, {"title": "6 OPTIMIZATION TECHNIQUES", "content": "In this section, we extend Algorithm 1 by presenting two optimization techniques from different perspectives.\n6.1 Model-guided Synthesis\nOur on-the-fly synthesis approach requires determining whether the states in the corresponding TDFA game are winning states for the system or the environment. In this process, the edges of each state are explored in a random and non-directed manner. By Lemma 5.1, system-winning states are recursively detected with its base case falling on the accepting edges of TDFA. This leads us to intuitively infer that edges associated with some satisfiable traces are more likely to result in the current state being identified as system-winning. Inspired by this insight, we design the"}, {"title": "6.2 State Entailment", "content": "The condition of whether a state is a known system/environment-winning state is checked multiple times in our approach. Here, we attempt to relax this condition. We can establish that it is sufficient to replace the condition mentioned above with a determination of whether a state is semantically entailed by a known system-winning state or semantically entails a known environment-winning state. An LTLf satisfiability solver can help determine the semantic entailment relationship between two LTLf formulas q1 and 42: \\(\u03c6_1 \u21d2 \u03c6_2\\) holds iff \\(\u03c6_1 \u2227 \u00ac\u03c6_2\\) is unsatisfiable.\nLEMMA 6.1. Let \\((\u03c6_1, X, Y)_{Moore}\\) and \\((\u03c6_2, X, Y)_{Moore}\\) be two LTLf specifications sharing the same input and output variables and \\(\u03c6_1 \u21d2 \u03c6_2\\) holds.\n(1) If \\((\u03c6_1, X, Y)_{Moore}\\) is realizable, then \\((\u03c6_2, X, Y)_{Moore}\\) is realizable;\n(2) if \\((\u03c6_2, X, Y)_{Moore}\\) is unrealizable, then \\((\u03c6_1, X, Y)_{Moore}\\) is unrealizable.\nPROOF. The two statements in this lemma are the contrapositives of each other, and therefore, they must both hold simultaneously. Hence, we only prove Statement (1) here.\nBy Definition 2.4, if \\((\u03c6_1, X, Y)_{Moore}\\) is realizable, then there exists a winning strategy \\(g : (2^X)^* \u2192 2^\\mathcal{P}\\) such that for an arbitrary infinite sequence \\(\u03bb = X_0, X_1,\u2026 \u2208 (2^X)^@\\), there is \\(k \u2265 0\\) such that \\(\u03c1 |= \u03c6_1\\) holds, where \\(\u03c1 = (X_0 \u222a g(\u03f5)), (X_1 \u222a g(X_0)),..., (X_k \u222a g(X_{0,\u00b7\u00b7\u00b7, X_{k-1}}))\\). Notice we have \\(\u03c6_1 \u21d2 \u03c6_2\\), so \\(\u03c1 |= \u03c6_2\\) also holds. Thus \\((\u03c6_2, X, Y)_{Moore}\\) is realizable.\nLEMMA 6.2. Let \\(G = (2^{X \\cup Y}, S, \u03b4, T)_{Moore}\\) be a TDFA games, \\(s_1 \u2208 S\\) and \\(s_2 \u2208 S\\) be two states such that \\(s_1 \u21d2 s_2\\).\n(1) If \\(s_1\\) is a system-winning state in G, then \\(s_2\\) is a system-winning state in G;\n(2) if \\(s_2\\) is an environment-winning state in G, then \\(s_1\\) is an environment-winning state in G.\nPROOF. Lemma 4.9 establishes the correspondence between system/environment-winning states and realizability. So we can get this lemma directly from Lemma 6.1."}, {"title": "7 EXPERIMENTAL EVALUATION", "content": "We provide experimental evidence that the on-the-fly approach offers the potential to avoid constructing complete automata and generally outperforms the backward search method. We implement the on-the-fly LTLf synthesis approach, as detailed in Section 5 to 6, in a tool called Tople using C++ 11. The complete experimental setup, including the source code of Tople, the benchmarks, the compared tools, and the original logs produced during the experiment, is available at [1]."}, {"title": "8 RELATED WORK", "content": "Other Attempts at On-the-fly LTLf Synthesis. This work builds upon previous efforts of [44, 45]. Concurrently, other studies follow [44] also employ the on-the-fly approach to solving LTLf synthesis problem. De Giacomo et al. [24] formulates the searched state space of DFA games as And/Or graphs [33], which is widely used in automated planning with nondeterministic models [23]. This study also introduces Sequential Decision Diagrams (SDDs) as a data structure for reasoning through And/Or graphs. Despite the improved performance in certain benchmarks, this approach encounters significant scalability issues. Within the same framework in [24, 44], [21] devise a procedure inspired by the Davis-Putnam-Logemann-Loveland algorithm [12, 13] to improve edge enumeration and introduces a syntactic equivalence check for search states.\nLTL Synthesis. The first work to consider LTL synthesis is [36], which solves the synthesis problem by reducing it to a Rabin game [18]. This approach constructs a non-deterministic B\u00fcchi automaton from the input LTL formula, and then determinizes it to its equivalent Rabin automaton, a process which takes worst-case double-exponential time. The complexity of solving a Rabin game is NP-Complete [18]. Nowadays, the standard approach is to reduce LTL synthesis to the parity game [19], because a parity game can be solved in quasi-polynomial time [10], even though the doubly-exponential process to obtain a deterministic parity automaton cannot be avoided. LTL synthesis tools like Itlsynt [32] and Strix [31], are built using the parity-game approach. Because of the challenge to determinize an w automaton, researchers also consider other possibilities, e.g., by reducing LTL synthesis to the bounded safety game [28]. Acacia+ [8] is a representative tool following the safety-game approach. The annual reactive synthesis competition [26] drives progress in this field, yet the scalability issue is still a major problem."}, {"title": "9 CONCLUDING REMARKS", "content": "We have presented an on-the-fly approach framework for synthesizing LTLf specifications. By concurrently conducting synthesis and constructing automata, we get the chance to bypass the double exponential growth of state space. An empirical comparison of this method to state-of-the-art LTLf synthesizers suggests that it can achieve the best overall performance. Several future research directions are being considered. Firstly, to further reduce state space to be searched,"}]}