{"title": "Conditioned quantum-assisted deep generative surrogate for particle-calorimeter interactions", "authors": ["J. Quetzalcoatl Toledo-Marin", "Sebastian Gonzalez", "Hao Jia", "Ian Lu", "Deniz Sogutlu", "Abhishek Abhishek", "Colin Gay", "Eric Paquet", "Roger Melko", "Geoffrey C. Fox", "Maximilian Swiatlowski", "Wojciech Fedorko"], "abstract": "Particle collisions at accelerators such as the Large Hadron Collider, recorded and analyzed by experiments such as ATLAS and CMS, enable exquisite measurements of the Standard Model and searches for new phenomena. Simulations of collision events at these detectors have played a pivotal role in shaping the design of future experiments and analyzing ongoing ones. However, the quest for accuracy in Large Hadron Collider (LHC) collisions comes at an imposing computational cost, with projections estimating the need for millions of CPU-years annually during the High Luminosity LHC (HL-LHC) run [1]. Simulating a single LHC event with GEANT4 currently devours around 1000 CPU seconds, with simulations of the calorimeter subdetectors in particular imposing substantial computational demands [2]. To address this challenge, we propose a conditioned quantum-assisted deep generative model. Our model integrates a conditioned variational autoencoder (VAE) on the exterior with a conditioned Restricted Boltzmann Machine (RBM) in the latent space, providing enhanced expressiveness compared to conventional VAEs. The RBM nodes and connections are meticulously engineered to enable the use of qubits and couplers on D-Wave's Pegasus-structured Advantage quantum annealer (QA) for sampling. We introduce a novel method for conditioning the quantum-assisted RBM using flux biases. We further propose a novel adaptive mapping to estimate the effective inverse temperature in quantum annealers. The effectiveness of our framework is illustrated using Dataset 2 of the CaloChallenge [3].", "sections": [{"title": "I. INTRODUCTION", "content": "By the end of the decade, the LHC is expected to begin an upgraded \"High Luminosity\" phase, which will ultimately increase the collision rate by a factor of 10 higher than the initial design. Increasing the number of collisions will generate more experimental data, enabling the observation of rare processes and increased precision in measurements, furthering our understanding of the universe. The path toward the HL-LHC presents great technological challenges and commensurate innovations to overcome them. Monte Carlo simulations of collision events at the ATLAS experiment have played a key role in the design of future experiments and, particularly, in the analysis of current ones. However, these simulations are computationally intensive, projected to reach into millions of CPU-years per year during the HL-LHC run [1]. Simulating a single event with GEANT4 [4] in an LHC experiment requires roughly 1000 CPU seconds. The calorimeter simulation is by far dominating the total simulation time [2]. To address this challenge, deep generative models are being developed to act as particle-calorimeter interaction surrogates, with the potential to reduce the simulation overall time by orders of magnitude. The key point to take into consideration is that one particle impacting a calorimeter can lead to thousands of secondary particles, collectively known as showers, to be tracked through the detector, while only the total energy deposit per sensitive element (a cell) is actually measured in the experiment. Hence, through the generation of these showers, non-negligible computational resources are being employed in the detailed recording of the path of these particles. The problem being addressed is whether one can bypass the path-tracing step in the simulation and generate the cell energy deposits directly from a set of well-defined parameters (e.g., type of particle, incidence energy, incidence angle, etc.) via sampling from a deep generative model.\nThere is a large and growing body of literature addressing this critical problem via deep generative models. The earliest methods developed were Generative Adversarial Networks [5-7], which are now an integral part of the simulation pipeline [8, 9] of some experiments. Different deep generative frameworks have been proposed since then, including VAEs [10-12], Normalizing Flows"}, {"title": "II. METHODS", "content": "The CaloChallenge 2022 [3] comprises three distinct datasets, each designed to facilitate research and testing in the field of calorimeter simulations. All three datasets are derived from GEANT4 simulations. The first dataset, referred to as Dataset 1, represent photon and charged pion showers within a specified \u03b7 [26] range. The dataset covers a discrete range of incident energies, ranging from 256 MeV to 4 TeV, logarithmically spaced out evenly with varying sizes at higher energies. The calorimeter geometry is that of the ATLAS detector.\nIn the case of Dataset 2 it is comprised by two files containing 100,000 GEANT4-simulated electron showers each. These showers encompass a wide energy range, spanning from 1 GeV to 1 TeV sampled from a log-uniform distribution. The detector geometry features a concentric cylinder structure with 45 layers as shown in Fig. 1, each consisting of active (silicon) and passive (tungsten) material. The dataset is characterized by high granularity, with 45 \u00d7 16 \u00d7 9 = 6,480 voxels. The cylin-"}, {"title": "A. Data preprocessing", "content": "Before feeding the shower and incident energy data to the model, we apply several transformations to the shower and the incident particle energy on-the-fly. Given an event shower, v, and corresponding incident energy, e, we first reduce the voxel energy, vi, per event by dividing it by the incident energy, e, viz. Ei = vi/e. Notice that Ei \u2208 [0, 1], where the left and right bounds correspond to when the voxel energy is zero and equal to the incident energy, respectively. To remove the strict bounds, we define ui = \u03b4 + (1 \u2013 2\u03b4)Ei, where \u03b4 = 10\u22127, to prevent discontinuities during the logit transformation Specifically, we use the transformation xi = ln ui/(1-ui)-ln \u03b4/(1-\u03b4), where the second term preserves the zero values in the transformed variable, i.e., when the voxel energy is zero, vi = 0, the transformed variable xi = 0.\nThe incident energy is used as a conditioning parameter and we transform it by applying a logarithmic function followed by scaling it between 0 and 1. These transformations have been used before in the same context [13, 16, 19]. However, in our case, we modify the process to preserve the zeroes in the transformed variables, xi, and therefore omit the last step of standardizing the new variables, in contrast with other approaches."}, {"title": "B. 4p-QVAE", "content": "The Calo4pQVAE can be conceptualized as a variational autoencoder (VAE) with a restricted Boltzmann machine (RBM) as its prior. The modularity of our framework allows for the replacement of any component, such as the encoder, decoder, or the RBM, facilitating flexibility in its configuration [30]. The encoder, also referred to as the approximating posterior, is denoted as q(z|x, e), while the latent space prior distribution is denoted as p\u03b8(z). The decoder, responsible for generating data from the latent variables, is represented as p\u03b8(x|z, e). We train the model to generate synthetic shower events given a specific incidence energy. In other words, we are interested in finding p\u03b8(x|z, e), such that \u222b p\u03b8(x|z, e)p\u03b8(z)dz matches the empirical dataset distribution. We use \u03c6 to denote the encoder parameters, \u03b8 for the prior and decoder parameters, and z the latent space vector. We denote as x a one-dimensional vector, such that x \u2208 Rn, and we say each element xi contains the energy measured at the ith voxel for that specific instance (or event), defined by the bijective transformation described in the previous subsection, while e is incidence energy of the event. During training, the model takes as input an instance of x and e. The input data is encoded into the latent space via the encoder. One key difference between VAEs and autoencoders is that in the latter, the same input generally yields the same encoded representation, provided the encoder does not use stochastic filters, such as dropout. In contrast, VAEs generate a different encoded representation with each pass of the same input. This is because the output of a VAE encoder consists of the parameters of a distribution from which the encoded data is sampled. The encoded data is then passed through the decoder which reconstructs the shower event vector, x. The incident particle energy is the label of the event and conditions the encoder and decoder, as depicted in Fig. 3. To condition the encoder and decoder with the incidence energy, we tested two different methods: simple concatenation of the label with the one-dimensional energy per voxel vector, and positional encoding similar to the techniques used by Meta [31] and Google [32]. Despite experimenting with these different encoding schemes, we observed no significant difference in performance. Therefore, we opted to use the simpler concatenation method henceforth and leave the positional encoding methods for future work when dealing with a greater number of features in the dataset.\nThe encoder architecture uses hierarchy levels, as described in [30]. The encoder is composed by three sub-encoders. The first generates one-fourth of the encoded data, which is then fed to the second sub-encoder along with the input data to generate another quarter of the encoded data. This process is repeated with the third sub-encoder, each time integrating all previously generated data and the original input to produce the final encoded output, as depicted in Fig. 3. The purpose of these hierarchy levels is to enforce conditional relationships among latent units by introducing conditioning among latent nodes, viz.\n\n$q(z|x) = q(z_1, z_2, z_3, z_4 | x) = q_{\\phi}^{(1)}(z_1| x) \\prod_{\\alpha=2}^{4} q_{\\phi}^{(\\alpha)}(z_{\\alpha} | \\{ z_i \\}_{i=1}^{\\alpha-1}, x)$  (1)\n\nThe choice of three sub-encoders is designed on mimick-ing the connections between the four partitions in latent space. Our results suggest that this hierarchical approach indeed fosters correlations between latent units, leading to a Boltzmann-like distribution. Additionally, this hierarchical structure introduces multiple paths for gradi-"}, {"title": "C. 4-partite Restricted Boltzmann Machine", "content": "Let us consider a 4-partite restricted Boltzmann machine. For this purpose, we denote each of the four layers as v, h, s and t. The energy function is defined by:\n\n$E(v, h, s, t) = -a_i v_i - b_i h_i - c_i s_i - d_i t_i - v_i W_{ij}^{(0, 1)} h_j - v_i W_{ij}^{(0, 2)} s_j - v_i W_{ij}^{(0, 3)} t_j - h_i W_{ij}^{(1, 2)} s_j - h_i W_{ij}^{(1, 3)} t_j - s_i W_{ij}^{(2, 3)} t_j,$ (12)\n\nwhere we are using the double indices convention for summation.\nThe Boltzmann distribution has the following form:\n\n$p(v, h, s, t) = \\frac{exp(-E(v, h, s, t))}{Z}$ (13)\n\nwhere Z is the partition function,\n\n$Z = \\sum_{\\{v,h,s,t\\}} exp(-E(v, h, s, t)) .$  (14)\n\nSimilar to the 2-partite RBM, we can express the distribution over any one of the layers conditioned to the remaining three in terms of the ratio of the Boltzmann distribution and the marginalized distribution over the layer of interest. Without any loss in generality, let us assume the layer of interest is h, then the probability"}, {"title": "D. Quantum Annealers", "content": "A quantum annealer (QA) is an array of superconducting flux quantum bits with programmable spin-spin couplings and biases with an annealing parameter [42]. The motivation for QAs comes from the adiabatic approximation [43], which asserts that if a quantum system is in an eigenstate of its Hamiltonian (which describes the total energy of the system), and the Hamiltonian changes slowly enough, then the system will remain in an eigenstate of the Hamiltonian, although the state itself may change (see Appendix F1 for a formal derivation). QAswere initially thought of as a faster method to find the ground state of complex problems that could be mapped onto a Hamiltonian H [44]. This can be done by initializing the system in the ground state of some Hamiltonian Ho, which is easy to prepare both theoretically and experimentally. In addition, by design the commutator [H, Ho] \u2260 0. The QA interpolates between the two Hamiltonians via\n\n$H_{QA} = \\frac{A(s)}{2} H_0 + \\frac{B(s)}{2} H$  (20)\n\nwith\n\n$H_0 = - \\sum_i \\sigma_i^{(2)}, \\hspace{5mm} H = \\sum_{<i,j>} \\Delta_i^{(2)} + \\sum_{i>j} J_{ij} \\sigma_i^{(z)} \\sigma_j^{(z)} $  (21)\n\nsuch that the annealing parameters, A(s) and B(s), are two slowly-varying controllable parameters constrained to A(0) \u00bb B(0) and A(1) \u226a B(1) and s \u2208 [0,1] [45]. In practice, quantum annealers have a strong interaction with the environment which lead to thermalization and decoherence. Evidence suggests that the culprit are the \u03c3x operator which couple to the environment [46]. There has been efforts towards mitigating decoherence via zero noise extrapolation methods [47].\nThermalization and decoherence are usually unwanted features in quantum systems as it destroys the quantum state. In our case, these features allows us to replace the RBM with the QA. In other words, RBMs are classical simulations of QAs. A non-desired feature in our framework correspond to system arrest or freeze-out during annealing [48], akin to glass melts subject to a rapid quench [49]. Similar to glasses, the annealing time and protocol can have a dramatic impact on the end state [50]. It has been shown that the distribution in this freeze-out state can be approximated with a Boltzmann distribution [30].\nIn our pipeline we use Dwave's Advantage_system6.4 [51] which is composed by 5627 qubits and are coupled such that it forms a quadri-partite graph. Typically each qubit is coupled with 16 other qubits. In Fig. 4 we show the histogram for number of connections between each of the four partitions."}, {"title": "1. Conditioned Quantum Annealer", "content": "Quantum annealers were designed to find solutions to optimization problems by identifying a Boolean vector that satisfies a given set of constraints. Typically, QAS are not intended to be conditioned or manipulated in terms of fixing specific qubits during the annealing process. However, there are different approaches that can be employed to fix a set of qubits during the annealing process. In this context, we will present two such approaches. For clarity, let us revisit the concept of conditioning in the realm of QAs. Our goal is to utilize QAs in a manner that allows us to fix a subset of qubits, denoted as \u03c3k) (see Eq. (21)), a priori, such that these qubits remain in their predetermined states throughout and after the annealing process.\nReverse annealing with zero transverse field for conditioning qubits. This approach requires control over the biases in Ho from Eq. (21), where Ho = \u2211\u03ba) and {k} are directly specified by the user. Initially, we set the qubits encoding the condition ok) while the rest of the qubits are randomly initialized. We also set the biases Kk = 0 to ensure that the transverse field does not alter the state of ok). Subsequently, we perform reverse annealing, by starting from s = 1 and reversing the annealing process towards s = 0, before completing the annealing process as usual. The primary drawbacks in this approach are:\n*   Speedup compromise: The annealing process is effectively doubled in duration due to the reverse annealing step.\n*   Condition destructed by thermal fluctuations: There is a possibility of the conditioned state being altered due to thermal fluctuations.\nBoth drawbacks can be mitigated by decreasing the annealing time, as this would not only reduce the overall duration but also minimize the destruction of the conditioned-encoding state by thermal fluctuations. However, as previously noted, reducing the annealing time can lead to the issue of dynamical arrest, where the system becomes trapped in a local minimum [48]. Given that our current framework relies on thermodynamic fluctuations, we leave this approach for future exploration and proceed to discuss an alternative method that does not suffer from these drawbacks and is more practical for immediate implementation.\nConditioning qubits through flux biases. This approach relies on using the external flux bias, \u03a6, as"}, {"title": "III. RESULTS", "content": "In this section, we present the results concerning training and evaluating our model on Dataset 2. Therefore, we present as results the training aspects of our framework.\nTraining: We train our model for 220 epochs. Each epoch typically has 625 updating steps. The number of block Gibbs sampling steps was set to 3000. During the first 100 epochs we anneal the model parameters, such as those used in the Gumbel trick, from smooth to a sharp step, to mitigate the discontinuities in the gradient related to the use of discrete variables. After the annealing parameters have reached their final values, we train the model for the next 50 epochs, after which we freeze the encoder and decoder parameters at epoch 150, while the prior distribution parameters keep being updated. We use an Nvidia A100 GPU. Our experiment show that this last step was necessary for the RBM log-likelihood to saturate. In Fig. 6 we show the RBM log-likelihood us epochs. The yellow star point to when the annealed parameters reached their final values, whereas the purple star point to when the encoder and decoder parameter were frozen, after which it is clear the log-likelihood saturates. To estimate the log-likelihood, after training, we used annealed importance sampling and reverse annealed importance sampling methods [58, 59] with a annealed step set to 1/30. As the model updates its parameters, the encoded data used to estimate the log-likelihood will also be modified from epoch to epoch, hence, we stored the validation encoded data for each epoch in order to accurately estimate the RBM log-likelihood. During training we save an instance of the model every ten epochs.\nValidation: To validate our model, we use Fr\u00e9chet physics distance (FPD) and the kernel physics distance (KPD) [21]. These are integral probability metrics for high energy physics, specifically designed to be sensitive to modelling of shower shape variables. In Fig. 6 we show these metrics us epochs. Henceforth, the results are generated using the 220-epoch model, corresponding to the best FPD and KPD metrics, together with a saturated RBM log-likelihood. We further validate our model's reconstruction, classical sampling and QA sampling with GEANT4 data. To sample using the Advantage_system6.4 QA [25], we first estimate the effective \u03b2 by iteratively using Eq. (23) until the absolute difference between the QA's energy and that of the RBM is smaller than the reduced standard error, viz.,\n\n$|<H>_{QA} - <H>_{RBM}| < \\frac{2 \\sigma_{QA} \\sigma_{RBM}}{\\sqrt{N_{QRBM} + N_{QA}}}$ (25)\n\nIn Fig. 7 we show the mean number of iterations to meet the reduced standard error threshold in Eq. (25) using different iterative methods. Method 1 uses the KL divergence as in Eq. (22). Method 2 uses Eq. (23), where Method 2 adaptive adapts the \u03b4 parameter after each iteration such that \u03bb \u2248 0 from Eq. (24). The dashed purple line corresponds to the ratio between final minus initial effective \u03b2 and the number of iterations, such that higher values implies faster convergence.\nIn each API call the user specifies the bias and coupler parameters, as well as the number of samples to be generated. The QA is programmed once using these biases and couplers and then performs the annealing process sequentially for the number of iterations requested, returning samples for each anneal. In addition, the user has the option to specify the flux bias parameters with each API call.\nIn the case of conditioned sampling using the QA, we"}, {"title": "IV. DISCUSSION", "content": "In the previous section we outlined the process of training our conditioned quantum-assisted Calo4pQVAE and described a novel a faster method to estimate the QA's effective inverse temperature before sampling using the QPU. We evaluated the performance of our model by means of the KPD and FPD metrics, achieving results on the same order and one order of magnitude higher than CaloDiffusion, respectively, as shown in Table I [19]. Our results demonstrate that i) our framework is able of reconstructing the showers and preserving sparsity, and ii) the prior is effectively learning the structure of the"}, {"title": "Appendix A: Variational Autoencoder", "content": "In this section we describe the VAE framework first proposed by Kingma and Welling in [34]. Suppose we have a data set {x(i)}D, where each element in the data set lives in RV. The goal in training a Variational Autoencoder (VAE) on this data set is to fit a probability distribution, p(x), to the data. This is done by maximizing the log-likelihood (LL) of p(x) over the data set. A key component in generative models is the introduction of latent variables, z, such that the joint distribution can be expressed as p(x, z) = p(x|z)p(z), where p(z) is the prior distribution of z \u2208 RM. VAEs are composed by an encoder and a decoder, and are trained using the Evidence Lower Bound (ELBO) as a proxy loss function for the LL. To understand the relationship between the LL and the ELBO, we first write the following identity:\n\n$\\ln p_{\\theta}(x) = <\\ln p_{\\theta}(x)>_{q_{\\phi}(z|x)}$  (A1)\n\nwhere <\u2022>q\u03c6(z|x) denotes expectation value of \u2022 over q\u03c6(z|x). Here, q\u03c6(z|x) is the encoding function, also known as the approximate posterior. This function encodes the data \u00e6 into z in the latent space. We can further manipulate the r.h.s. in Eq. (A1), viz.,\n\n$\\ln p_{\\theta}(x) = <\\ln \\frac{p_{\\theta}(x, z)}{p_{\\theta}(z|x)} >_{q_{\\phi}(z|x)} = <\\ln \\frac{p_{\\theta}(x, z)q_{\\phi}(z|x)}{q_{\\phi}(z|x)p_{\\theta}(z|x)} >_{q_{\\phi}(z|x)} = <\\ln \\frac{p_{\\theta}(x, z)}{q_{\\phi}(z|x)} >_{q_{\\phi}(z|x)} + <\\ln \\frac{q_{\\phi}(z|x)}{p_{\\theta}(z|x)} >_{q_{\\phi}(z|x)} = L_{\\phi,\\theta}(x) + D_{KI}(q_{\\phi}(z|x)||p_{\\theta}(z|x)).$ (A2)\n\nIn the last line in the previous Eq., L\u03c6,\u03b8(x) is the ELBO and Dkl(q\u03c6(z|x)||p\u03b8(z|x)) is the Kullback-Liebler (KL) divergence. The KL divergence is a positive functional and equals zero when both distributions are the same. Therefore:\n\n$L_{\\phi,\\theta}(x) = \\ln p_{\\theta}(x) \u2013 D_{kl}(q_{\\phi}(z|x)||p_{\\theta}(z|x)) < \\ln p_{\\theta}(x)$  (A3)\n\nThe previous Eq. shows that maximizing the ELBO implies maximizing the LL (since the LL is the upper bound), as well as to minimizing the KL divergence between q\u03c6(z|x) and p\u03b8(z|x).\nWe can express the ELBO in a more tractable way:\n\n$L_{\\phi,\\theta}(x) = <\\ln \\frac{p_{\\theta}(x, z)}{q_{\\phi}(z|x)} >_{q_{\\phi}(z|x)} = <\\ln p_{\\theta}(x|z)>_{q_{\\phi}(z|x)} - <\\ln \\frac{q_{\\phi}(z|x)}{p_{\\theta}(z)} >_{q_{\\phi}(z|x)}$ (A4)\n\nThe first term in the last equality is called the reconstruction term since it is a measure of how well the model is able to reconstruct the input x from a latent vector z. The second term in the last equality is called a regularizer and measures the divergence between the prior and the approximate posterior.\nThe legacy VAE [34] assumes the functional forms:\n\n$p_{\\theta}(x|z) = \\prod_{i=1}^{N} \\frac{1}{\\sqrt{2 \\pi \\sigma_i^2}} exp{\\frac{(x_i - \\tilde{x}_i)^2}{2 \\sigma_i^2}}$ (A5a)\n\n$p_{\\theta}(z) = \\prod_{i=1}^{M} \\frac{1}{\\sqrt{2 \\pi}} exp{\\tilde{z}_i^2 / 2}$ (A5b)\n\n$q_{\\phi}(z|x) = \\prod_{i=1}^{M} \\frac{1}{\\sqrt{2 \\pi \\sigma_i^2}} exp{\\frac{(\\tilde{z}_i - \\mu_i)^2}{2 \\sigma_i^2}}$ (A5c)\n\nThis leads to the following expression for the ELBO:\n\n$L_{\\phi,\\theta}(x) = -\\sum_{i=1}^{N} <\\frac{(x_i - \\tilde{x}_i)^2}{2 \\sigma_i^2}>_{q_{\\phi}(z|x)} - \\sum_{i=1}^{M} \\frac{1}{2}(\\mu_i^2 + \\sigma_i^2 - 1 - \\ln \\sigma_i) + const .$ (A6)"}, {"title": "Appendix B: Discrete Variational Autoencoder", "content": "Discrete Variational Autoencoders (DVAEs) are a type of VAE where the latent space is discrete. The main two challenges with DVAEs are i) how does one backpropagate the gradient since the latent space is discrete? ii) what reparameterization can be employed to enable gradient-based optimization? To address the former, one can simply relax the discrete condition by introducing annealed sigmoids. Specifically, we replace the Heaviside function \u0398(x) with the sigmoid function \u03c3(x\u03b2), where \u03b2 is the annealing parameter. Notice that lim\u03b2\u2192\u221e \u03c3(x\u03b2) = \u0398(x). To address the latter issue one can employ the Gumbel trick. The Gumbel trick has become an umbrella term which refers to a set of methods to sample from discrete probabilities or to estimate its partition function. In our case, we simply generate latent variables via\n\n$\\zeta = \\sigma((l(\\phi, x) + \\sigma^{-1}(\\rho))\\beta),$ (B1)\n\nwhere p is a uniform random number, and l(\u03c6, x) is a logit, i.e., the inverse of a sigmoid function, such that in the discrete regime of \u03da (i.e., \u03b2 \u2192 \u221e) P(\u03b6 = 1) = \u03c3(l(\u03c6, x)). Notice that in this approach, we generate the random variable \u03b6 using a deterministic equation, \u03c3; a logit, l(\u03c6, x); and a uniformly-distributed random number, p. The connection with Gumbel distributed random numbers is due to the fact that \u03c3\u22121(\u03c1) ~ G1 \u2013 G2, where G1 and G2 are two Gumbel distributed random numbers [36-38]."}, {"title": "Appendix C: Bipartite Restricted Boltzmann Machines", "content": "Suppose a data set {v(i)}D and each element in the data set lives in {0, 1}N. The goal behind training a Restricted Boltzmann Machine (RBM) over this data set consists on fitting a probability mass function, p(v), that models the distribution of the data. This is achieved by maximizing the log-likelihood (LL) of p(v) over the data set. We denote the joint probability of the dataset as PD = (\u03a0v\u2208Dp(v))1/|D|. Maximizing the LL corresponds to:\n\n$\\underset{\\Omega}{argmax} \\ln P_D$ (C1)"}, {"title": "Appendix D: High temperature gradient approximation", "content": "The previous section shows the derivation of the block Gibbs sampling Eqs. used to trained RBM. A quite common approach to training RBMs consists in replacing ln Z with the average energy before computing the gradient. The basis comes from noticing that the gradient of the logarithm of the partition function w.r.t. the RBM parameters is equal to the average value of the gradient of the energy w.r.t. the RBM parameters, viz.,\n\n$\\frac{\\partial \\ln Z}{\\partial \\phi} = <\\frac{\\partial E}{\\partial \\phi}>$ (D1)"}, {"title": "Appendix E: Quadripartite RBM numerical verification", "content": "We considered different number of nodes ranging from for 4-partite RBMs. This setting allows for the explicit enumeration of all feasible states, facilitating the precise computation of the partition function. To rigorously assess the accuracy of our approach, we conducted a comparative analysis of the density of energy states. This entailed a direct comparison between the utilization of all feasible states and the implementation of the 4-partite Gibbs sampling method, as elaborated upon in Section II C. In Figure E1, we present a detailed visual comparison of the density of states obtained through both methodologies, across various iterations of the Gibbs sampling process. This comparison shows the convergence and consistency of these two approaches."}, {"title": "Appendix F: Quantum Annealers", "content": "Here we derive the adiabatic approximation following [43], which is the theoretical foundation of quantum annealers. Let us suppose a time-dependent Hamiltonian H(t), we denote the time-dependent eigenstates as |n;t) and the eigenvalues as En(t), such that,\n\n$H(t)|n;t) = E_n(t)|n,t),$ (F1)\nwhich simply states that at any particular time t, the eigenstate and eigenvalue may change. Notice that one can write the general solution to Schr\u00f6dinger's Eq., viz.,\n\n$ih\\frac{\\partial}{\\partial t} |a; t> = H(t)|a;t)$ (F2)"}, {"title": "Appendix G: Incident energy conditioning", "content": "In the conditioned Calo4pQVAE framework, we condition the latent space RBM using the incident energy. We perform the condition as follows:\n1.  By applying a floor function on the incident energy in MeV, bin the incident energy, e, ebin = floor(e); the logarithm of the incident energy multiplied by 10, elne = floor(10 \u00b7 lne); and the square root of the incident energy multiplied by 10, e\u221ae = floor(10\u00b7 \u221ae).\n2.  Convert to binary number the three previous binned numbers, Be = binary(ebin), Blne = binary(elne), B\u221ae = binary(e\u221ae). We allocate 20 bits for each of these binary numbers.\n3.  Concatenate the three binary numbers, B = cat(Be, Blne, B\u221ae).\n4.  Use one partition to fit as many repetitions of the concatenated binary number B.\n5.  Set residual nodes to zero.\nWe fixed the number of nodes per partition to 512, hence the binary number B fits 8 times and the number of residual nodes is 32."}, {"title": "Appendix H: Gaussian approximation to shower logits", "content": "In the main text we describe the data transformation used to train our model, where we first reduce the voxel energy per event by dividing it by the incident energy and we afterwards construct logits based on the reduced energy random variable. The number of particles in the electromagnetic shower follows approximately a Poisson distribution. Furthermore, via the saddle point approximation, for large number of particles in the shower the multivariate Poisson distribution becomes a multivariate Gaussian distribution with the mean equal to the variance. Here we show that to zeroth approximation, the logits are Gaussian distributed.\nLet us consider a Gaussian positive distributed random variable r with mean and variance \u039b, i.e.,\n\n$f(r) = \\frac{N(r|\\Lambda, \\Lambda)}{\\Omega}, \\forall r > 0$  (H1)\n\nwhere \u03a9 is a normalization constant. We define u = ln , with x = r/R and R \u226b r. To zeroth order approximation, u \u2248 Inr \u2013 In R. To obtain the distribution of u we first introduce an auxiliary random variable z = lnr with distribution g(z). By equating the cumulatives of r and z we obtain:\n\n$g(z) = e^{z} f(e^{z}).$ (H2)\n\nThe distribution of u, h(u), is simply the distribution of z shifted by ln R, namely, h(u) = g(u + ln R):\n\n$h(u) = \\frac{R e^{u}}{\\Omega} \\frac{1}{\\sqrt{2\\pi\\Lambda}}e^{-\\frac{(Re^{u} - \\Lambda)^2}{2\\Lambda}}$ (H3)\n\nThe previous distribution is highly sensitive to u and the main contribution comes from Reu \u2248 \u039b. Hence, we can expand lnr around ln \u039b:\n\n$\\ln r \\approx \\ln \\Lambda + \\frac{r-\\Lambda}{\\Lambda}$ (H4)\n\nwhich translates to u \u2248 ln + . Notice that since ~ N(0, 1), then:\n\n$u \\sim N(ln \\frac{\\Lambda}{R}, \\frac{1}{\\Lambda})$ (H5)"}]}