{"title": "Quantifying over Optimum Answer Sets", "authors": ["Giuseppe Mazzotta", "Francesco Ricca", "Mirek Truszczynski"], "abstract": "Answer Set Programming with Quantifiers (ASP(Q)) has been introduced to provide a natural extension of ASP modeling to problems in the polynomial hierarchy (PH). However, ASP(Q) lacks a method for encoding in an elegant and compact way problems requiring a polynomial number of calls to an oracle in  (that is, problems in ). Such problems include, in particular, optimization problems. In this paper we propose an extension of ASP(Q), in which component programs may contain weak constraints. Weak constraints can be used both for expressing local optimization within quantified component programs and for modeling global optimization criteria. We showcase the modeling capabilities of the new formalism through various application scenarios. Further, we study its computational properties obtaining complexity results and unveiling non-obvious characteristics of ASP(Q) programs with weak constraints.", "sections": [{"title": "1 Introduction", "content": "Answer set programming (ASP) (Brewka et al. 2011; Gelfond and Lifschitz 1991) has been proposed over two decades ago as a variant of logic programming for modeling and solving search and optimization problems (Marek and Truszczynski 1999; Niemel\u00e4 1999). Today it is among the most heavily studied declarative programming formalisms with highly effective processing tools and an ever-growing array of applications (Brewka et al. 2011; 2016). Focusing on decision problems, the scope of applicability of ASP is that of the class \u03a3? (Dantsin et al. 2001). This class includes a vast majority of problems of practical interest. However, many important decision problems belong to higher complexity classes (Schaefer and Umans 2002; Stockmeyer 1976). For this reason, many language extensions have been proposed that expand the expressivity of ASP (Bogaerts et al. 2016; Fandinno et al. 2021; Amendola et al. 2019). Among these, Answer Set Programming with Quantifiers (ASP(Q)) (Amendola et al. 2019) has been recently introduced to offer a natural declarative means to model problems in the entire Polynomial Hierarchy (PH). Roughly speaking, the definition of a problem in En can be often reformulated as \u201cthere is an answer set of a program P\u2081 such that for every answer set of a program P2, there is an answer set of Pn, so that a stratified program with constraint C, modeling admissibility of a solution, is coherent,\u201d (and a similar sentence starting with \u201cfor all answer set of program P\u2081\" can be used to encode problems \u03a0\u03a1).\nBoth the original paper (Amendola et al. 2019) on ASP(Q), and the subsequent one (Amendola et al. 2022) presented several examples of problems outside the class"}, {"title": "2 Answer Set Programming", "content": "We now recall Answer Set Programming (ASP) (Brewka et al. 2011; Gelfond and Lifschitz 1991) and introduce the notation employed in this paper.\nThe Syntax of ASP. Variables are strings starting with uppercase letters, and constants are non-negative integers or strings starting with lowercase letters. A term is either a variable or a constant. A standard atom is an expression of the form p(t1,..., tn), where pis a predicate of arity n and t1,...,tn are terms. A standard atom p(t1,...,tn) is ground if t1,...,tn are constants. A standard literal is an atom p or its negation ~p. An aggregate element is a pair t1,..., tn : conj, where t1,..., tn is a non-empty list of terms, and conj is a non-empty conjunction of standard literals. An aggregate atom is an expression f{e1;...;en} < T, where f \u2208 {#count,#sum} is an aggregate function symbol, < \u2208 {<,<, >, >, =} is a comparison operator, T is a term called the guard, and e1,..., en are aggregate elements. An atom is either a standard atom or an aggregate atom. A literal is an atom (positive literal) or its negation (resp. negative literal). The complement of a literal l is denoted by \u012b, and it is ~a, if l = a, or a, if l = ~a, where a is an atom. For a set of literals L, L+ and L- denote the set of positive and negative literals in L, respectively. A rule is an expression of the form:\nh \u2190 b\u2081, ..., bk, ~bk+1,..., ~bm.\nwhere m \u2265 k \u2265 0. Here h is a standard atom or is empty, and all bi with i \u2208 [1,m] are atoms. We call h the head and b\u2081,..., bk, ~bk+1,..., ~bm the body of the rule (1). If the head is empty, the rule is a hard constraint. If a rule (1) has a non-empty head and m = 0, the rule is a fact. Let r be a rule, hr denotes the head of r, and Br = B+UB- where B+ (resp. B-) is the set of all positive (resp. negative) literals in the body of r. A weak constraint (Buccafurri et al. 2000) is an expression of the form:\n\u2190w b1,..., bk, ~bk+1,...,~bm [w@l,T],"}, {"title": "3 Quantified Answer Set Programming with Weak Constraints", "content": "In this section, we introduce an extension of Answer Set Programming with Quantifiers (ASP(Q)) (Amendola et al. 2019) that explicitly supports weak constraints (Buccafurri et al. 2000) for modeling optimization problems.\nIt is worth noting that ASP(Q) can be used to model problems with model preferences and optimization criteria; however, this comes at the price of non-elegant and somehow redundant modeling. For this reason, in analogy to what has been done for ASP, it makes sense to contemplate weak constraints in ASP(Q).\nA quantified ASP program with weak constraints (ASP\u0190(Q) program) II is of the form:\n1P12P2\nnPn:C:CW,\nwhere, for each i = 1, ..., n, \u25a1\u00a1 \u2208 {\u2203st,\u2200st}, P; is an ASP program possibly with weak constraints, C is a (possibly empty) stratified program (Ceri et al. 1990) with constraints, and Cw is a (possibly empty) set of weak constraints such that Bcw \u2286 BP\u2081. The number of quantifiers in II is denoted by nQuant(\u03a0).\nAs it was in the base language, ASP\u0190(Q) programs are quantified sequences of subprograms ending with a constraint program C. Differently from ASP(Q), in ASPW(Q) weak constraints are allowed in the subprograms Pi (1 \u2264 i \u2264 n), that is, quantification is over optimal answer sets. Moreover, the global weak constraints subprogram C\u2122 is introduced to specify (global) optimality criteria on quantified answer sets.\nFormally, the coherence of ASP\u0190(Q) programs is defined as follows:\n\u2022 \u2203stP : C: C\u2122 is coherent, if there exists M \u2208 OptAS(P) such that CU fixp(M) admits an answer set;\n\u2022\u2200stP : C : C\u2122 is coherent, if for every M\u2208 OptAS(P), CU fixp(M) admits an answer set;\n\u2022 \u2203stP II is coherent, if there exists M \u2208 OptAS(P) such that IP,M is coherent;\n\u2022 \u2200st P II is coherent, if for every M \u2208 OptAS(P), \u041f\u0420,\u041c is coherent.\nwhere fixp(M) denotes the set of facts and constraints {a | a \u2208 M \u2229 HBp}\u222a{\u2190a | a \u2208 HBp \\ M}, and IP,M denotes the ASP\u5ddb(Q) program of the form (D1), where P\u2081 is replaced by P\u2081 U fixp(M), that is, IP,M = \u25a11(P\u2081 \u222a fixp(M)) \u25a12P2\uff65\uff65\uff65\u25a1nPn:C:Cw.\nFor an existential ASP\u0190(Q) program \u03a0, \u039c \u2208 OptAS(P\u2081) is a quantified answer set of II, if ((2P2\uff65\uff65\uff65\u25a1nPn:C):CW)P\u2081,M is coherent. We denote by QAS(II) the set of all quantified answer sets of \u041f.\nTo illustrate the definitions above, let us consider the following ASP\u0190(Q) program II = \u2203stP\u2081\u2200st P2\u2022\u2022\u2022\u2203st Pn\u22121\u2200stPn:C:Cw. \u201cUnwinding\u201d the definition of coherence yields that I is coherent if there exists an optimal answer set M\u2081 of P' such that for every optimal answer set M2 of P\u2082 there exists an optimal answer set M3 of P3, and so"}, {"title": "4 Modeling examples", "content": "We showcase the modeling capabilities of ASP (Q) by considering two example scenarios where both global and local weak constraints play a role: the Minmax Clique problem (Cao et al. 1995), and Logic-Based Abduction (Eiter and Gottlob 1995a).\nMinmax clique problem. Minimax problems are prevalent across numerous research domains. Here, we focus on the Minmax Clique problem, as defined by Ko (1995), although other minimax variants can be also modeled.\nGiven a graph G = (V, E), let I and J be two finite sets of indices, and (Ai,j)i\u2208I,jeJ a partition of V. We write JI for the set of all total functions from I to J. For every total function f: I \u2192 J we denote by Gf the subgraph of G induced by Uier Ai,f(i). The MINMAX CLIQUE optimization problem is defined as follows: Given a graph G, sets of indices I and J, a partition (Ai,j)i\u2208I,jej, find the integer k (k \u2264 |V|), such that\nk = min max{|Q| : Q is a clique of Gf}.\nfEJI\nThe following program of the form II = \u2203P\u2081\u2203P2 : C : C\u2122, encodes the problem:\n{valK (1); . . . ; valK(|V|)} = 1\nv(i, j, a)\ninI(i)\ninJ(j)\ne(x, y)\n{\nf(i, j) : inJ(j)} = 1 \u2190 inI(i)\nsf (I, J), v(I, J, X)\nnf(X), nf(Y), e(X, Y)\nnf(X)\nef (X, Y)\n{inClique(X): nf(X)}\ninClique(X), inClique(Y), X < Y, ~ef (X, Y)\nnf(X), ~inClique(X) [1@1, X]"}, {"title": "5 Rewriting into plain ASP(Q)", "content": "In this section, we describe a mapping that transforms an ASPW(Q) program II into a plain (i.e., without weak constraints) quantifier-alternating ASP(Q) program I' that is"}, {"title": "6 Complexity issues", "content": "In this section, we investigate the complexity of problems related to ASP~(Q) programs. We first study the complexity of the coherence problem. For that problem, global constraints can be ignored. Interestingly, the presence of local constraints leads to some unexpected phenomena. Next, we study the complexity of problems concerning membership of atoms in optimal answer sets. For this study, we restrict attention to existential programs with only global constraints."}, {"title": "7 Related Work", "content": "Disjunctive ASP programs can be used to model problems in the second level of the PH using programming techniques, such as saturation (Eiter and Gottlob 1995b; Dantsin et al. 2001), but it is recognized that they are not intuitive. As a consequence, many language extensions have been proposed that expand the expressivity of ASP (Bogaerts et al. 2016; Fandinno et al. 2021; Amendola et al. 2019). This paper builds on one of these, namely: Answer Set Programming with Quantifiers (ASP(Q)) (Amendola et al. 2019). ASP(Q) extends ASP, allowing for declarative and modular modeling of problems of the entire PH (Amendola et al. 2019). We expand ASP(Q) with weak constraints to be able to model combinatorial optimization problems. In Section 4, we show the efficacy of ASP\u0190(Q) in modeling problems that would require cumbersome ASP(Q) representations.\nThe two formalisms most closely related to ASP(Q) are the stable-unstable semantics (Bogaerts et al. 2016), and quantified answer set semantics (Fandinno et al. 2021). We are not aware of any extension of these that support explicitly weak constraints or alternative optimization constructs. Amendola et al. (2019) and Fandinno et al. (2021) provided an exhaustive comparison among ASP extensions for problems in the P\u0397.\nIt is worth observing that ASP(Q) extends ASP(Q) by incorporating weak constraints, a concept originally introduced in ASP for similar purposes (Buccafurri et al. 2000). Clearly, ASP\u0190(Q) is a strict expansion of ASP, indeed it is easy to see that any ASP program P is equivalent to a program of the form (D1) with only one existential quantifier, where P\u2081 = R(P), CW = W(P), C = (). Related to our work is also a formalism that has been proposed for handling preferences in ASP, called asprin (Brewka et al. 2023). asprin is very handy in defining preferences over expected solutions, nonetheless, the complexity of main reasoning tasks in asprin is at most (Brewka et al. 2023), with optimization tasks belonging at most to A33 (Brewka et al. 2023); thus, in theory, ASP(Q) can be used to model more complex optimization problems (unless P=NP)."}, {"title": "8 Conclusion", "content": "We proposed an extension of ASP(Q) enabling the usage of weak constraints for expressing complex problems in An, called ASP(Q). We demonstrated ASP~(Q)'s modeling capabilities providing suitable encodings for well-known complex optimization problems. Also, we studied complexity aspects of ASP\u0190(Q), establishing upper and lower bounds for the general case, and revealing intriguing completeness results. Future work involves tightening the bounds from Theorem 9 for arbitrary n, extending ASP\u0190(Q) to support subset minimality, and design a complexity-aware implementation for ASP\u0190(Q) based on the translation of Section 5 and extending the system PyQASP (Faber et al. 2023)."}, {"title": "Appendix A Preliminaries on complexity classes", "content": "In this section, we recall some basic definitions of complexity classes that are used to study the complexity of the introduced formalism. For further details about NP-completeness and complexity theory we refer the reader to dedicated literature (Papadimitriou 1994). We recall that the classes \u0394\u0395, \u03a3\u03a1, and I of the polynomial time hierarchy (PH)(Stockmeyer 1976) are defined as follows (rf. Garey and Johnson (1979)):\n\u0394\u0395 = \u03a3\u0395 = \u03a0 = P\nand, for all k > 0\n\u0394+1 = \u03a1\u03a3, \u03a3 , \u03a3+1 = \u039d\u03a1\u03a3, \u03a0\u03a1 \u039d\u03a1\u03a3, \u03a0+1 = CoNPE\nwhere, NP = \u03a3\u2191, coNP = IP, and \u22062 = PNP\u0375\nIn general, PC (resp. NPC) denotes the class of problems that can be solved in poly- nomial time on a deterministic (resp. nondeterministic) Turing machine with an oracle in the class C. Note that, the usage of an oracle O \u2208 C for solving a problem \u03c0is referred to as a subroutine call, during the evaluation of \u03c0, to O. The latter is evaluated in a unit of time. Among such complexity classes, the classes \u2206, with k \u2265 2, have been refined by the class [O(log n)] (also called ), where the number of oracle calls is bounded by O(log n), with n being the size of the input (Krentel 1992; Wagner 1990)."}, {"title": "Appendix B Modeling A in ASP(Q)", "content": "According to the complexity study carried out by Eiter and Gottlob (1995a), given a PAP A = (V,T, H, M) and a set S \u2286 H, the task of verifying if S \u2208 sol(A) is in A.\nIn particular, this task can be modeled with an ASP\u0190(Q) II of the form \u2203P : C, where Pis not plain. More in detail, the program C contains only one constraint, which is \u2190 notEntail whereas the program P is defined as follows:"}, {"title": "Appendix C Stratified definition assumption", "content": "In this section, we demonstrate that we can assume without loss of generality that ASP(Q) programs satisfy the stratified definition assumption.\nDefinition 6\nLet II = \u25a11P1...\u25a1nPn be an ASPW(Q) program. I satisfies the stratified definition assumption if for each 1 \u2264 i \u2264n, H(Pi) \u2229at(P;) = (\u00d8), with 1 \u2264 j < i.\nWe demonstrate in the following that any ASP (Q) program II can be transformed into a program \u03a0' such that \u03a0' satisfies the stratified definition assumption and is coherent whenever I is coherent.\nTo this end, we recall that for an ASP expression e and an alphanumeric string s, clones(e) is the expression obtained by substituting all occurrences of each predicate p in e with ps that is a fresh predicate ps of the same arity."}, {"title": "Appendix D Rewriting into plain ASP(Q)", "content": "In this section, we are going to prove the correctness of the transformation outlined in the corresponding section of the main paper. In what follows we assume that I is an ASP (Q) program of the form\n1P12P2\nnPn:C:CW, where, for each i = 1, ..., n, \u25a1\u00bf \u2208 {\u2203st,\u2200st}, P; is an ASP program possibly with weak constraints, C is a (possibly empty) stratified program with constraints, and Cw is a (possibly empty) set of weak constraints such that Bcw \u2286 BP1\u00b7\nWe recall some useful definitions introduced in the main paper. Given program II of the form (D1) we say that two consecutive subprograms Pi and Pi+1 are alternating if \u25a1i \u2260 i+1, and are uniform otherwise. A program II is quantifier-alternating if \u25a1i \u2260 [i+1 for 1 < i < n. A subprogram P\u2081 is plain if it contains no weak constraints W(P\u00bf) = \u00d8, and II is plain if both all Pi are plain, and Cw = \u00d8.\nD.1 Rewriting uniform plain subprograms.\nFirst of all, we show how two plain uniform subprograms can be absorbed in a single equi-coherent subprogram. This is done by the transformation col\u2081(\u00b7) as follows.\nD.2 Rewriting uniform notplain-plain subprograms.\nNext transformations apply to pairs of uniform subprograms P1, P2 such that P\u2081 is not plain and P2 is plain. To this end, we recall the definition of or(\u00b7,\u00b7) transformation.\nD.3 Rewrite subprograms with weak constraints.\nThe following transformations have the role of eliminating weak constraints from a sub- program by encoding the optimality check in the subsequent subprograms. To this end, we recall the definition of check(\u00b7) transformation that is useful for simulating the cost comparison of two answer sets of an ASP program P.\nD.4 Translate ASP (Q) to ASP(Q).\nAlgorithm 2 defines a procedure for rewriting an ASPW(Q) program I into an ASP(Q) program \u03a0', made of at most n + 1 alternating quantifiers, such that I is coherent if and only if I' is coherent. We recall that in Algorithm 2, we make use of some (sub)procedures and dedicated notation. More precisely, for a program I of the form (D1), I\u2265 denotes the i-th suffix program iPi...\u25a1nPn:C, with 1 \u2264 i \u2264 n. (i.e., the one obtained from I removing the first i \u2013 1 quantifiers and subprograms). More- over, procedure removeGlobal(II) builds an ASP(Q) program from a plain one in input (roughly, it removes the global constraint program C\u00b2). Given two programs \u03a0\u2081 and I2, replace(\u041f1, \u0456, \u041f2) returns the ASP\u0190(Q) program obtained from I\u2081 by replacing program"}]}