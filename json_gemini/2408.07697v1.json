{"title": "Quantifying over Optimum Answer Sets", "authors": ["GIUSEPPE \u039c\u0391\u0396\u0396\u039f\u03a4\u03a4\u0391", "FRANCESCO RICCA", "MIREK TRUSZCZYNSKI"], "abstract": "Answer Set Programming with Quantifiers (ASP(Q)) has been introduced to provide a natural\nextension of ASP modeling to problems in the polynomial hierarchy (PH). However, ASP(Q)\nlacks a method for encoding in an elegant and compact way problems requiring a polynomial\nnumber of calls to an oracle in $\\Delta_2^P$ (that is, problems in $\\Sigma_2^P \\cap \\Pi_2^P$). Such problems include, in\nparticular, optimization problems. In this paper we propose an extension of ASP(Q), in which\ncomponent programs may contain weak constraints. Weak constraints can be used both for\nexpressing local optimization within quantified component programs and for modeling global\noptimization criteria. We showcase the modeling capabilities of the new formalism through var-\nious application scenarios. Further, we study its computational properties obtaining complexity\nresults and unveiling non-obvious characteristics of ASP(Q) programs with weak constraints.", "sections": [{"title": "Introduction", "content": "Answer set programming (ASP) (Brewka et al. 2011; Gelfond and Lifschitz 1991) has\nbeen proposed over two decades ago as a variant of logic programming for modeling and\nsolving search and optimization problems (Marek and Truszczynski 1999; Niemel\u00e4 1999).\nToday it is among the most heavily studied declarative programming formalisms with\nhighly effective processing tools and an ever-growing array of applications (Brewka et al.\n2011; 2016). Focusing on decision problems, the scope of applicability of ASP is that of\nthe class $\\Sigma_2^P$ (Dantsin et al. 2001). This class includes a vast majority of problems of prac-\ntical interest. However, many important decision problems belong to higher complexity\nclasses (Schaefer and Umans 2002; Stockmeyer 1976). For this reason, many language ex-\ntensions have been proposed that expand the expressivity of ASP (Bogaerts et al. 2016;\nFandinno et al. 2021; Amendola et al. 2019). Among these, Answer Set Programming\nwith Quantifiers (ASP(Q)) (Amendola et al. 2019) has been recently introduced to offer\na natural declarative means to model problems in the entire Polynomial Hierarchy (PH).\nRoughly speaking, the definition of a problem in $\\Sigma_n^P$ can be often reformulated as\n\"there is an answer set of a program P\u2081 such that for every answer set of a program P2,\nthere is an answer set of Pn, so that a stratified program with constraint C, modeling\nadmissibility of a solution, is coherent,\u201d (and a similar sentence starting with \u201cfor all\nanswer set of program P\u2081\" can be used to encode problems $\\Pi_n^P$).\nBoth the original paper (Amendola et al. 2019) on ASP(Q), and the subsequent one\n(Amendola et al. 2022) presented several examples of problems outside the class $\\Sigma_2^P$\""}, {"title": "Answer Set Programming", "content": "We now recall Answer Set Programming (ASP) (Brewka et al. 2011;\nGelfond and Lifschitz 1991) and introduce the notation employed in this paper.\nThe Syntax of ASP. Variables are strings starting with uppercase letters, and constants\nare non-negative integers or strings starting with lowercase letters. A term is either a\nvariable or a constant. A standard atom is an expression of the form p(t1,..., tn), where\npis a predicate of arity n and t1,...,tn are terms. A standard atom p(t1,...,tn) is\nground if t1,...,tn are constants. A standard literal is an atom p or its negation ~p.\nAn aggregate element is a pair t1,..., tn : conj, where t1,..., tn is a non-empty list of\nterms, and conj is a non-empty conjunction of standard literals. An aggregate atom is\nan expression f{e1;...;en} < T, where f \u2208 {#count,#sum} is an aggregate function\nsymbol, < \u2208 {<,<, >, >, =} is a comparison operator, T is a term called the guard, and\ne1,..., en are aggregate elements. An atom is either a standard atom or an aggregate\natom. A literal is an atom (positive literal) or its negation (resp. negative literal). The\ncomplement of a literal l is denoted by $\\bar{l}$, and it is ~a, if l = a, or a, if l = ~a, where a\nis an atom. For a set of literals L, L+ and L- denote the set of positive and negative\nliterals in L, respectively. A rule is an expression of the form:\nh \u2190 b\u2081, ..., bk, ~bk+1,..., ~bm.\nwhere m \u2265 k \u2265 0. Here h is a standard atom or is empty, and all bi with i \u2208 [1,m]\nare atoms. We call h the head and b\u2081,..., bk, ~bk+1,..., ~bm the body of the rule (1). If\nthe head is empty, the rule is a hard constraint. If a rule (1) has a non-empty head and\nm = 0, the rule is a fact. Let r be a rule, hr denotes the head of r, and B\u2081 = B+ U B-\nwhere B+ (resp. B-) is the set of all positive (resp. negative) literals in the body of r.\nA weak constraint (Buccafurri et al. 2000) is an expression of the form:\n\u2190w b1,..., bk, ~bk+1,...,~bm [w@l,T],"}, {"title": "Quantified Answer Set Programming with Weak Constraints", "content": "In this section, we introduce an extension of Answer Set Programming with\nQuantifiers (ASP(Q)) (Amendola et al. 2019) that explicitly supports weak con-\nstraints (Buccafurri et al. 2000) for modeling optimization problems.\nIt is worth noting that ASP(Q) can be used to model problems with model preferences\nand optimization criteria; however, this comes at the price of non-elegant and somehow\nredundant modeling. For this reason, in analogy to what has been done for ASP, it makes\nsense to contemplate weak constraints in ASP(Q).\nA quantified ASP program with weak constraints (ASP\u0190(Q) program) II is of the form:\n1P12P2...\u25a1nPn:C:Cw,\nwhere, for each i = 1, ..., n, \u25a1\u00bf \u2208 {\u2203st,\u2200st}, P; is an ASP program possibly with weak\nconstraints, C is a (possibly empty) stratified program (Ceri et al. 1990) with constraints,\nand Cw is a (possibly empty) set of weak constraints such that Bcw \u2286 BP1\u00b7 The number\nof quantifiers in II is denoted by nQuant(\u03a0).\nAs it was in the base language, ASP\u0190(Q) programs are quantified sequences of subpro-\ngrams ending with a constraint program C. Differently from ASP(Q), in ASPW(Q) weak\nconstraints are allowed in the subprograms Pi (1 \u2264 i \u2264 n), that is, quantification is over\noptimal answer sets. Moreover, the global weak constraints subprogram C\u2122 is introduced\nto specify (global) optimality criteria on quantified answer sets.\nFormally, the coherence of ASP\u0190(Q) programs is defined as follows:\n\u2022 \u2203stP : C : C\u2122 is coherent, if there exists M \u2208 OptAS(P) such that CU fixp(M)\nadmits an answer set;\n\u2022\u2200stP : C : C\u2122 is coherent, if for every M\u2208 OptAS(P), CU fixp(M) admits an\nanswer set;\n\u2022 \u2203stP II is coherent, if there exists M \u2208 OptAS(P) such that IP,M is coherent;\n\u2022 \u2200st P II is coherent, if for every M \u2208 OptAS(P), IP,M is coherent.\nwhere fixp(M) denotes the set of facts and constraints {a | a \u2208 M \u2229 HBp}\u222a{\u2190a |\na \u2208 HBp \\ M}, and IP,M denotes the ASP\u5ddb(Q) program of the form (D1), where P\u2081 is\nreplaced by P\u2081 U fixp(M), that is, IP,M = \u25a11(P\u2081 \u222a fixp(M)) \u25a12P2\uff65\uff65\uff65\u25a1nPn:C:Cw.\nFor an existential ASP\u0190(Q) program \u041f, \u039c \u2208 OptAS(P\u2081) is a quantified answer set of\nII, if ((2P2\uff65\uff65\uff65\u25a1nPn:C):CW)P\u2081,M is coherent. We denote by QAS(II) the set of all\nquantified answer sets of \u041f.\nTo illustrate the definitions above, let us consider the following ASP\u0190(Q) program\nII = \u2203stP\u2081\u2200st P2\u2022\u2022\u2022\u2203st Pn\u22121\u2200stPn:C:Cw. \u201cUnwinding\u201d the definition of coherence\nyields that I is coherent if there exists an optimal answer set M\u2081 of P' such that for\nevery optimal answer set M2 of P\u2082 there exists an optimal answer set M3 of P3, and so"}, {"title": "Modeling examples", "content": "We showcase the modeling capabilities of ASP (Q) by considering two example sce-\nnarios where both global and local weak constraints play a role: the Minmax Clique\nproblem (Cao et al. 1995), and Logic-Based Abduction (Eiter and Gottlob 1995a).\nMinmax clique problem. Minimax problems are prevalent across numerous research do-\nmains. Here, we focus on the Minmax Clique problem, as defined by Ko (1995), although\nother minimax variants can be also modeled.\nGiven a graph G = (V, E), let I and J be two finite sets of indices, and (Ai,j)i\u2208I,jeJ\na partition of V. We write JI for the set of all total functions from I to J. For every\ntotal function f: I \u2192 J we denote by Gf the subgraph of G induced by Uier Ai,f(i).\nThe MINMAX CLIQUE optimization problem is defined as follows: Given a graph G, sets\nof indices I and J, a partition (Ai,j)i\u2208I,jej, find the integer k (k \u2264 |V|), such that\nk = min max{|Q| : Q is a clique of Gf}.\nfEJI\nThe following program of the form II = \u2203P\u2081\u2203P2 : C : C\u2122, encodes the problem:\n\\begin{aligned}\nP_1 = \\left\\{\\begin{array}{l}\n\\{\\text {valK }(1) ; \\ldots ; \\text {valK }(|V|)\\} = 1 \\leftarrow \\\\\nv(i, j, a) \\leftarrow \\text { inI }(i), \\text { inJ }(j), a \\in A_{i, j} \\\\\ninI(i) \\leftarrow \\quad \\forall i \\in I \\\\\ninJ(j) \\leftarrow \\quad \\forall j \\in J \\\\\ne(x, y) \\leftarrow \\quad \\forall(x, y) \\in E \\\\\n\\{\\mathrm{f}(i, j): \\operatorname{inJ}(j)\\} = 1 \\leftarrow \\text { inI }(i) \\\\\n\\leftarrow \\mathrm{f}(I, J), v(I, J, X) \\\\\n\\leftarrow n f(X), n f(Y), e(X, Y)\n\\end{array}\\right.\n\\\\\nP_2=\\left\\{\\begin{array}{l}\n\\{\\text {inClique}(X): n f(X)\\} \\leftarrow \\\\\n\\leftarrow \\operatorname{inClique}(X), \\operatorname{inClique}(Y), X<Y, \\sim e f(X, Y) \\\\\n\\leftarrow n f(X), \\sim \\text {inClique}(X) \\leftarrow w n f(X)[1 @ 1, X]\n\\end{array}\\right.\n\\\\\n\\mathrm{C}=\\left\\{\\leftarrow \\operatorname{valK}(K), \\# \\operatorname{count}\\{X: \\operatorname{inClique}(X)\\} \\neq K\\right\\} \\\\\n\\mathrm{C}^{\\mathrm{w}}=\\left\\{\\leftarrow \\operatorname{wval}(K)[K @ 1]\\right\\}\n\\end{aligned}"}, {"title": "Rewriting into plain ASP(Q)", "content": "In this section, we describe a mapping that transforms an ASPW(Q) program II into a\nplain (i.e., without weak constraints) quantifier-alternating ASP(Q) program I' that is"}, {"title": "Appendix A Preliminaries on complexity classes", "content": "In this section, we recall some basic definitions of complexity classes that are used to study\nthe complexity of the introduced formalism. For further details about NP-completeness\nand complexity theory we refer the reader to dedicated literature (Papadimitriou\n1994). We recall that the classes $\\Delta_k^P$, $\\Sigma_k^P$, and $\\Pi_k^P$ of the polynomial time hierarchy\n(PH)(Stockmeyer 1976) are defined as follows (rf. Garey and Johnson (1979)):\n$\\Delta_0^P = \\Sigma_0^P = \\Pi_0^P = P$\nand, for all k > 0\n$\\Delta_{k+1}^P = P^{\\Sigma_k^P}$, $\\Sigma_{k+1}^P = NP^{\\Sigma_k^P}$, $\\Pi_{k+1}^P = coNP^{\\Sigma_k^P}$,\nwhere, NP = $\\Sigma_1^P$, coNP = $\\Pi_1^P$, and $\\Delta_2^P = PNP$.\nIn general, $P^C$ (resp. $NPC$) denotes the class of problems that can be solved in poly-\nnomial time on a deterministic (resp. nondeterministic) Turing machine with an oracle\nin the class C. Note that, the usage of an oracle O \u2208 C for solving a problem \u03c0is referred\nto as a subroutine call, during the evaluation of \u03c0, to O. The latter is evaluated in a unit\nof time. Among such complexity classes, the classes $\\Delta_k^P$, with k \u2265 2, have been refined\nby the class $\\Theta_k^P[O(log n)]$ (also called $\\Theta_k^P$), where the number of oracle calls is bounded\nby O(log n), with n being the size of the input (Krentel 1992; Wagner 1990)."}, {"title": "Appendix B Modeling A in ASP(Q)", "content": "According to the complexity study carried out by Eiter and Gottlob (1995a), given a\nPAP A = (V,T, H, M) and a set S \u2286 H, the task of verifying if S \u2208 sol(A) is in A.\nIn particular, this task can be modeled with an ASP\u0190(Q) II of the form \u2203P : C, where\nPis not plain. More in detail, the program C contains only one constraint, which is\n\u2190 notEntail whereas the program P is defined as follows:"}, {"title": "Appendix C Stratified definition assumption", "content": "In this section, we demonstrate that we can assume without loss of generality that\nASP(Q) programs satisfy the stratified definition assumption."}, {"title": "D Rewriting into plain ASP(Q)", "content": "In this section, we are going to prove the correctness of the transformation outlined in\nthe corresponding section of the main paper. In what follows we assume that I is an\nASP (Q) program of the form\n1P12P2...\u25a1nPn:C:CW,\nwhere, for each i = 1, ..., n, \u25a1\u00bf \u2208 {\u2203st,\u2200st}, P; is an ASP program possibly with weak\nconstraints, C is a (possibly empty) stratified program with constraints, and Cw is a\n(possibly empty) set of weak constraints such that Bcw \u2286 BP1\u00b7\nWe recall some useful definitions introduced in the main paper. Given program II of the\nform (D1) we say that two consecutive subprograms Pi and Pi+1 are alternating if \u25a1i \u2260\ni+1, and are uniform otherwise. A program II is quantifier-alternating if \u25a1i \u2260 [i+1 for\n1 < i < n. A subprogram P\u2081 is plain if it contains no weak constraints W(P\u00bf) = \u00d8, and\nII is plain if both all Pi are plain, and Cw = \u00d8.\nD.1 Rewriting uniform plain subprograms.\nFirst of all, we show how two plain uniform subprograms can be absorbed in a single\nequi-coherent subprogram. This is done by the transformation col\u2081(\u00b7) as follows."}, {"title": "Rewrite subprograms with weak constraints", "content": "The following transformations have the role of eliminating weak constraints from a sub-\nprogram by encoding the optimality check in the subsequent subprograms. To this end,\nwe recall the definition of check(\u00b7) transformation that is useful for simulating the cost\ncomparison of two answer sets of an ASP program P."}]}