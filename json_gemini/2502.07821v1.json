{"title": "Amnesia as a Catalyst for Enhancing Black Box Pixel Attacks in Image Classification and Object Detection", "authors": ["Dongsu Song", "Daehwa Ko", "Jay Hoon Jung"], "abstract": "It is well known that query-based attacks tend to have relatively higher success rates in adversarial black-box attacks. While research on black-box attacks is actively being conducted, relatively few studies have focused on pixel attacks that target only a limited number of pixels. In image classification, query-based pixel attacks often rely on patches, which heavily depend on randomness and neglect the fact that scattered pixels are more suitable for adversarial attacks. Moreover, to the best of our knowledge, query-based pixel attacks have not been explored in the field of object detection. To address these issues, we propose a novel pixel-based black-box attack called Remember and Forget Pixel Attack using Reinforcement Learning(RFPAR), consisting of two main components: the Remember and Forget processes. RFPAR mitigates randomness and avoids patch dependency by leveraging rewards generated through a one-step RL algorithm to perturb pixels. RFPAR effectively creates perturbed images that minimize the confidence scores while adhering to limited pixel constraints. Furthermore, we advance our proposed attack beyond image classification to object detection, where RFPAR reduces the confidence scores of detected objects to avoid detection. Experiments on the ImageNet-1K dataset for classification show that RFPAR outperformed state-of-the-art query-based pixel attacks. For object detection, using the MS-COCO dataset with YOLOv8 and DDQ, RFPAR demonstrates comparable mAP reduction to state-of-the-art query-based attack while requiring fewer query. Further experiments on the Argoverse dataset using YOLOv8 confirm that RFPAR effectively removed objects on a larger scale dataset. Our code is available at https://github.com/KAU-QuantumAILab/RFPAR.", "sections": [{"title": "1 Introduction", "content": "Deep learning models are susceptible to adversarial attacks, which involve subtle modifications of input data that are imperceptible to humans but lead to incorrect predictions by the model[1]. As deep learning technologies become commercialized in the real world, the issue of adversarial attacks has garnered increasing attention.\nBlack-box attacks can be broadly categorized into white-box attacks and black-box attacks[2]. In white-box attacks[3-5], attackers devise attack strategies based on internal information about deep learning models, such as training data, gradients of the outputs with respect to the weights, and other details about the learning process for given samples. Conversely, in black-box attacks[6, 7], attackers can access only limited information such as the probability of the correct prediction for a given sample. Given that real-world attackers typically only possess limited information about the model, black-box attacks are more realistic than white-box attacks. In other words, research on black-box attacks and their defenses is crucial in order to develop robust and secure machine learning systems.\nBlack-box attacks are also categorized into query-based methods[8-11] and transfer-based methods[12]. Query-based attacks are generating adversarial examples by repeatedly querying the victim model with modified images[13]. Transfer-based attacks involve generating adversarial ex-amples for a surrogate model that successfully deceive another model[14]. Transfer-based attacks are highly efficient since they do not require knowledge of the victim model. However, the discrepancies in model architecture, training data, and training methodologies between the surrogate and victim models often result in a lower success rate for these attacks compared to query-based attacks[13].\nConversely, although query-based attacks achieve higher success rates, they require a significant number of queries to the victim model. Therefore, reducing the number of queries in query-based attacks is a critical issue."}, {"title": "2 Remember and Forget Pixel Attack Using Reinforcement Learning", "content": "In this section, we introduce our proposed method. In Section 2.1, we define the problem mathe-matically. Section 2.2 details the Remember process, which is the internal iterative structure of our algorithm, including agent, environment, and memory. Finally, we explain the Forget process, which serves as the external iterative structure in Section 2.3."}, {"title": "2.1 The Problem Formalization", "content": "We consider an image classifier as $f : \\mathbb{R}^{C\\times H \\times W} \\rightarrow \\mathbb{R}^{c}$, where $C$, $H$, and $W$ represent the channel, height, and width of a given sample $x$, respectively, and $c$ denotes the number of classes. The classifier $f$ computes probabilities for each class for a sample $x$. Furthermore, $f_l(x)$ is defined as the probability of a sample $x$ being predicted as the $l$-th class. The prediction of the classifier can be expressed as $\\arg \\max_l f_l (x)$. For an image classification attack, the objective is to minimize a pixel perturbation $\\delta$ such that the classifier's prediction for an input $x$ diverges from its true label $y$. This problem can be formalized as:\n$\\min_\\delta \\qquad \\arg \\max f_i (x + \\delta) \\neq y$$\ns.t.$\\qquad ||x - x'||_0 = ||\\delta||_0 \\leq \\epsilon, \\epsilon \\in \\mathbb{Z}^+$.    (1)\nHere, $\\epsilon \\in \\{1,2,...\\}$ and $||\\cdot||_0$ denotes the attack level and the $L_0$ norm. $x'$ is the perturbed image, defined as $x + \\delta$. Notably, the attack levels are positive integers, which implies that the perturbations are at the pixel level.\nSimilarly, the object detector is defined by the function $f : \\mathbb{R}^{C\\times H \\times W} \\rightarrow \\mathbb{R}^{B\\times 6}$, where $B$ represents the maximum number of objects that can be detected by the model. The information about each bounding box location, object's class, and confidence score (indexed by $l_o$) is encapsulated in 6-dimensional vectors. To prevent the attack from targeting objects that are incorrectly predicted, we establish a confidence threshold of 0.5. If $n$ objects surpass this threshold from among $B$ candidates, then only these $n$ objects are classified as detected. Furthermore, $f_o (x)$ indicates the confidence score that the model identifies the $o$-th object as belonging to the predicted class from a sample $x$. In this context, the number $n(x)$ of detected objects from a sample $x$ is $\\sum 1\\{ f_o(x) > 0.5\\}$, where 1 signifies the indicator function that takes the value one if the inequality holds and the value zero otherwise.\nThe goal of the object detector attack is to reduce the number of detected objects by modifying the minimum number of pixels, which is formally expressed as:"}, {"title": "2.2 Remember Process", "content": "Agent. We construct an environment where an attacking agent interacts to generate adversarial images. The agent's policy utilizes a CNN-based architecture, where given a sample $x \\in \\mathbb{R}^{C\\times H \\times W}$, the agent observes the image and takes actions to determine the location (X, Y coordinates) and brightness (R, G, B) to modify, then generates perturbed images. We define two types of actions for brightness: \"Write\" and \"Erase.\" The \"Write\" action overwrites the pixel with the maximum brightness, while the \"Erase\" action sets the brightness to zero. This configuration is chosen because, based on our experience, the attack success rate is higher when applying maximum changes to the pixels. The agent generates the actions through random sampling of normal distributions, where the means and standard deviations are trained by the neural networks. The set of actions $A_t$, where $t$ represents the training epoch of RL, contains $N$ subsets corresponding to the number of attack pixels in each Remember process. These subsets are composed of the X, Y coordinates, and brightness values for each channel. The set $A_t$ is defined as $\\{a_1, a_2, a_3, ..., a_{C+2},..., a_1^N, a_2^N, a_3^N,..., a_{C+2}^N\\}$, where $a_1$ and $a_2$ represent the X and Y coordinates, respectively, and $a_3$ to $a_{C+2}$ represent the brightness values for each channel. For the \"Write\" action, the brightness values are set to the maximum value, whereas for the \"Erase\" action, they are set to 0. For each pixel, the perturbed image $x'$ is generated as follows:\n$\\tilde{x}_{i,j,k} = \\begin{cases} a_{i+2} & \\text{if } j = a_1 \\text{ and } k = a_2, \\\\ x_{i,j,k} & \\text{otherwise} \\end{cases}$    (3)\nwhere $i$, $j$, and $k$ are indices for channel, height, and width, respectively. In other words, $x_{i,j,k}$ represents the brightness at position (j, k). Adding a pixel to the image is repeated for $d$ from 1 to $N$. Hence, the image is perturbed by $N$ pixels. The equation describes the generation of $\\tilde{x}$ by repeatedly altering the brightness of each channel at the position $(a_1, a_2)$ in the given sample $x$. The agent trains by using the gradient of the reward and the log probability of the sampled actions.\nEnvironment. The environment evaluates the image generated by the agent and assigns a reward. The reward $r$ is defined as:\nr = $\\sum_{o=1}^{n} f_o(\\tilde{x}) - f_o(x) + \\Omega(x)$,    (4)\nwhere $n$ represents the number of detected objects in the image $x$ for object detection, while $\\Omega(x) = (n(x) - n(\\tilde{x}))$ signifies the number of removed objects after the adversarial attack. $l_o$ is the index for the confidence score of the detected object. Hence, the reward is defined as the sum of the differences in confidence scores for each object plus the number of objects removed.\nFor classification, $l_o$ is the index for the correct class, and $n$ is set to 1. $\\Omega(x)$ is set to 1 if the adversarial image generation is successful and 0 otherwise. In essence, the reward is calculated as the sum of the differences in the probability of the correct class between the perturbed and original image, along with an additional component indicating whether the model successfully created an adversarial example.\nMemory. The role of memory is to save the best reward value and its corresponding perturbed images. The stored information is also used to determine when the Forget process should start. Without memory, RL models tend to identify universally shared vulnerabilities in the clean images provided to the victim model. In contrast, our objective is to generate adversarial attacks regardless of these common vulnerabilities. To minimize unnecessary queries that converge on such vulnerabilities, we have incorporated memory concepts into the RL approach. In our approach, memory stores the maximum reward values $r^*$ and their corresponding perturbed images $\\tilde{x}^*$ by selectively saving the"}, {"title": "2.3 Forget Process", "content": "The goal of the Forget process is to reset the trained RL model and its memory, and to feed the image $\\tilde{x}^*$ as a new input for the reset RL model. Additionally, the maximum $L_0$ increase for the reset RL model, as it is determined by the number of reward convergences, attack pixels, and channels. This process is implemented to prevent the agent from overfitting, which can hinder effective exploration of new inputs. The impact of memory and initialization is discussed in Section 3.5."}, {"title": "3 Experiments", "content": "Section 3.1 details the dataset, evaluation metrics, victim models, and hyperparameters used in our experiments. In Section 3.2, we evaluate our proposed attack on image classification by comparing it with previous attack methods. Section 3.3 compares the performance of our method on object"}, {"title": "3.1 Experimental Details", "content": "Datasets, Metrics and Hardware. For image classification, we use the validation dataset from ImageNet-1K[30]. To reduce computational costs, we extract one correctly classified image per category from the victim model, resulting in a total dataset of 1000 images for adversarial attack attempts. We evaluate our methods with respect to different victim models by calculating the success rate, $L_0$ norm, and the number of queries. The success rate represents the percentage of successful adversarial attacks out of the 1000 images, with higher values indicating better performance. The $L_0$ norm refers to the number of non-zero elements in perturbation $\\delta$, with lower values indicating better performance. The number of queries indicates how often the victim model is queried to generate an adversarial example, with fewer queries indicating better performance. The ATA (ATtacked Area) refers to the proportion of pixels in the image that were attacked, a lower value indicates fewer changes. For object detection, we use the 2017 validation set from the MS-COCO dataset[31] and Argoverse-1.1 validation set[32]. To facilitate comparison with PRFA [16] and GARSDC [17], we use mAP to evaluate the attacks. The mAP is calculated as the average over thresholds ranging from IOU = 0.5 to 0.95. Additionally, RM indicates the average percentage of objects removed from the clean image, while RD refers to the decrease in mAP. Both a lower mAP and a higher RM indicate greater success. Lastly, we used an AMD Ryzen 9 5900X, RTX 3090TI, and 64.0GB of RAM, running on Windows 11 with CUDA version 12.1.\nVictim Models. For image classification, we select six pre-trained models on the PyTorch platform as victim models: VIT[24], ResNeXt50[25], RegNetX-32GF[26], DenseNet161[27], MNASNet[28], and MobileNet-V3[29]. We compare the performance of our attack with OnePixel[8], ScratchThat[9], and Pixle[11]. For object detection, we use the pre-trained YOLOv8n model from the YOLOv8[22] platform and the pre-trained DDQ DETR-4scale model[33] from the MMDetection platform.\nHyperparameter. Our attack method utilizes four hyperparameters: the maximum number of iterations, the pixel attack rate a, the bound threshold $\\eta$, and the duration $T$ for maintaining the convergence condition. In the Remember process, a is a hyperparameter that determines the number of pixels to attack, proportional to the image size. The number of pixels $N$ to be attacked is defined as $(H +W)/2 \\times a$. By default, we set the maximum number of iterations to 100 and $\\eta$ to 0.05. For image classification, we use $T = 3$ and $a = 0.01$. For object detection, we experiment with $T = 20$ and a values ranging from 0.01 to 0.05."}, {"title": "3.2 Evaluation of Classification Attacks", "content": "Table 1 presents a performance comparison of various adversarial attack methods on different victim models for image classification. RFPAR consistently achieves the highest success rate, significantly outperforming the other three attack methods. For instance, for the VIT model, RFPAR achieves a success rate of 64.1%, compared to OnePixel's 9.3%, ScratchThat's 40.9%, and Pixle's 51.4%. The trend is similar for other models, with RFPAR showing substantial improvements in success rate. Regarding the $L_0$ norm, which measures the sparsity of the perturbations, RFPAR generally achieves a lower $L_0$ norm than ScratchThat and Pixle but higher than OnePixel. For example, in the case of ResNeXt50, RFPAR has an $L_0$ norm of 138, compared to OnePixel's 15, ScratchThat's 95, and Pixle's 538. While OnePixel has the lowest $L_0$ norm, its success rate is significantly lower than RFPAR's, indicating a trade-off between perturbation sparsity and attack effectiveness. In terms of the number of queries, RFPAR requires fewer queries than the other methods, except for OnePixel in some cases. This demonstrates that RFPAR is more efficient in terms of query cost, which is crucial for practical adversarial attacks. Overall, RFPAR exhibits superior performance across all victim models in terms of success rate while maintaining competitive $L_0$ norms and requiring fewer queries compared to other methods, making it an effective and efficient approach."}, {"title": "3.3 Evaluation of Object Detection Attacks", "content": "Attacking object detection models is more challenging than attacking image classification models because there are more objects to consider in the object detection task. More pix-els need to be modified, adjusted by $a$ from 0.01 to 0.05, to deceive the victim models. Table 2 compares the per-formance of different $a$ values of the RFPAR method on two object detection models, YOLOv8 and DDQ. The RM rate for YOLOv8 increases from 0.65 (RFPAR0.01) to 0.91 (RFPAR0.05) and for DDQ from 0.60 to 0.83, indicating that stronger attacks remove more detected objects. The mAP also decreases from 0.218 to 0.111 for YOLOv8 and from 0.125 to 0.054 for DDQ. At $a$ = 0.05, our attack successfully reduced the mAP by an average of 0.301 and achieved a RM of 0.87. The number of queries remains relatively stable, ranging from 1254 to 1427 for YOLOv8 and from 1450 to 1690 for DDQ, suggesting a consistent query cost despite increasing perturbation intensity. Overall, the results indicate that the RFPAR method is highly effective in generating adversarial attacks on object detection models, balancing perturbation sparsity, and attack effectiveness while maintaining query efficiency.\nTo demonstrate the effectiveness of our method, we compared it with other query-based black-box attacks. Table 3 shows the performance of three different attack methods - PRFA, GARSDC, and RFPAR - on the YOLO object detection model. In this table, RD refers to the decreased mAP value, and Query indicates the average number of queries. The RFPAR method shows strong performance by achieving the highest RD (tied with GARSDC) and requiring the fewest queries. This indicates that RFPAR is not only effective in reducing the YOLO model's performance but also efficient in terms of the number of queries needed to achieve this reduction. GARSDC also demonstrates high effectiveness with the same reduction as RFPAR but requires more than twice the number of queries. Overall, RFPAR stands out as the most balanced and efficient attack method in this comparison."}, {"title": "3.4 Experiments on a Larger Scale Data", "content": "To verify the effectiveness of our proposed method on larger dimensions 1920\u00d71200, we randomly selected one video sample from the Argoverse dataset and conducted experiments using YOLOv8. The experi-mental results are presented in Table 4. The RM achieved 0.94, indicating a successful reduction in the number of detected objects. Argoverse achieved a RM of 0.94, similar to the RM observed for MS-COCO. The ATA for these datasets was 0.1% and 0.02%, re-spectively, indicating that only a very small portion of the image area was attacked. However, the"}, {"title": "3.5 Ablation study", "content": "In this section, we analyze the impact of Initialization (I) and Memory (M) on our model's perfor-mance. If Initialization is ablated in the Forget process, the Agent is not reinitialized and retains information from the previous Remember process. On the other hand, if Memory is ablated, the Agent's reward, instead of the reward stored in Memory, serves as a bound condition. We conduct ablation experiments under similar query conditions and present the results in Appendix G. As shown in Figure 3, RFPAR denotes the baseline state without I and M, while RFPAR* indicates the inclusion of specific processes. Comparing RFPAR and RFPARM, it is evident that the introduction of memory significantly enhances the attack success rate. This result suggests that the RL method benefits from storing the highest-reward images of restricted pixels during each Forget process. When comparing RFPAR1 and RFPARM+1, we observe that initialization prevents RL model from overfitting to spe-cific patterns and escaping local optima, thereby improving performance. Conversely, the comparison between RFPAR and RFPAR, indicates that Initialization alone, without memory, has a negligible impact. This finding implies that RL model without memory fails to generate meaningful adversarial attacks. In summary, memory supports RL model in generating effective adversarial attacks, while Initialization prevents overfitting and enhances overall performance."}, {"title": "4 Conclusion", "content": "In this paper, we propose the Remember and Forget Pixel Attack using Reinforcement Learning (RFPAR) for attacking neural network models with limited pixels. Traditional pixel-based attacks have been confined to image classification, but our method extends this approach to include object detection as well. For image classification, we compared the performance of RFPAR against OnePixel, ScratchThat, and PIXLE across six victim models using the ImageNet-1K dataset, and RFPAR demonstrated superior performance. In object detection, we evaluated RFPAR on the MS-COCO dataset using YOLOv8 and DDQ models, comparing it with PRFA and GARSDC attacks. RFPAR achieved performance comparable to the state-of-the-art query-based attack GARSDC, while reducing the number of queries by 52.8%, proving its efficiency. Additionally, we showed that RFPAR is capable of performing pixel attacks on larger datasets, specifically the Argoverse dataset with dimensions, surpassing the sizes of the ImageNet and MS-COCO datasets. Our findings may enable malicious individuals to compromise real-world AI systems. Consequently, research on defenses against adversarial attacks is becoming increasingly important.\nBroader Impacts. Defects in camera sensors, such as hot pixels or dead pixels, can impact image quality and degrade the performance of neural network models. Our approach mimics these camera defects. In this paper, RFPAR simulates real-world issues by replacing specific pixels with values"}, {"title": "Limitations.", "content": "In this work, the pixel values are either zero or one. While the meaning remains unchanged, this can still make it noticeable in certain cases. Additionally, the Forget process is quite simple. The time complexity of RFPAR is worse than that of other pixel attacks. However, at the ImageNet scale, RFPAR outperforms others in speed. This result is presented in Appendix H. In future work, we will apply meta-learning to the Forget process and aim to reduce not only $L_0$, but also L$\\infty$.\nNegative Impacts. In applications like defective product detection [34] and disease prediction systems [35], adversarial attacks could degrade product quality or lead to incorrect diagnoses, which may have serious, or even fatal, consequences. Our proposed approach increases the effectiveness of query-based black-box attacks, making them more applicable to real-world scenarios. As a result, vision AI systems may face significant threats to their functionality and reliability. Therefore, it is crucial for these systems to proactively identify potential vulnerabilities and implement robust defenses.\nMitigation of Risks. Our method requires an average of over 1000 queries to successfully deceive an object detection model. Similarly, as shown in Table 7 in the Appendix E, transformer-based models also require an average of over 1000 queries to achieve a high success rate. If we limit the number of queries to around 1000 in a short period of time, our method can easily defend the model. For CNN-based models, since fewer queries are needed, limiting the queries to 400 can effectively defend the model. Additionally, according to the attack results on adversarially trained models shown in Table 8 in the Appendix F, adversarial training effectively reduces the attack success rate and increases the number of queries needed. Therefore, by adversarially training the models and appropriately limiting the queries, this attack can be defended against."}, {"title": "A Related Work", "content": "Adversarial Attack. Adversarial attacks manipulate clean images with imperceptible modifications to fool Deep Neural Networks (DNNs) into making incorrect predictions. These attacks are broadly divided into black-box and white-box attacks. White-box attacks leverage detailed information about the target model, including training data and gradients, to craft adversarial images. In contrast, black-box attacks, which do not rely on any internal information about the victim model, are divided into transfer-based and query-based strategies. Transfer-based attacks create adversarial images using a surrogate model, aiming for these examples to also be effective against the target model. Query-based attacks iteratively modify clean images and query the victim model, using the resulting confidence scores to refine the attack. Typically, attack strategies are evaluated using the $L_p$ norm to restrict the perturbation to remain imperceptible to humans[3\u20135, 36].\nBlack-box Pixel Attack in Image Classification. Unlike other metrics, the $L_0$ norm, also known as pixel norm, targets only a small subset of pixels in a clean image rather than attacking all of them. The pioneering pixel attack method, OnePixel[8], employed Differential Evolution (DE) to generate adversarial images. An advanced approach, ScratchThat[9], used DE to create curves and applied a parametric model to perturbations, reducing parameters and improving performance. A more recent study, PIXLE[11], enhanced query efficiency and attack success rate by using a simple algorithm instead of DE. Briefly, PIXLE generates adversarial images by selecting arbitrary patches in a clean image and applying the brightness of these pixels to others. Although this method improved performance, it ignored pixel independence due to its reliance on patches and exhibited inefficiencies stemming from randomness in brightness mapping. The previous study, PatchAttack[15], utilized RL to embed textures in specific regions of the clean image, discovering vulnerable patches and reducing randomness, which significantly decreased the number of queries and improved attack success rates. Unfortunately, this method still depended on patches, requiring at least 3% of the image area to be attacked. Our research focuses on eliminating patch dependency by attacking individual pixels and reducing randomness through RL. Extensive experiments demonstrate that our proposed attack outperforms the state-of-the-art methods in both query efficiency and attack success rate.\nQuery-based Adversarial Attack in Object Detection. Adversarial attacks in object detection are more challenging than those in image classification. The first query-based attack in object detection, PRFA[16], generates adversarial images using a parallel rectangle flipping strategy. Recent research, GARSDC[17], employs a genetic algorithm to create adversarial images, improving optimization efficiency by using adversarial examples generated from transfer-based attacks as the initial population. We extend our proposed attack from image classification to object detection. Experiments show that our method achieves a comparable mAP reduction on YOLO[22] to state-of-the-art methods while significantly reducing the number of queries, demonstrating its effectiveness in object detection."}, {"title": "B Theoretical Insight.", "content": "We initially used a multi-step REINFORCE approach but identified issues, leading us to propose the Forget and Remember processes using one-step REINFORCE. Generating adversarial examples with multi-step REINFORCE involves the objective function U = \u0395 [\u03a3 $y^{t-1}$ R[$s_t$, $a_t$|$\\pi_\\theta$]], where y is the discount factor, $s_t$ is the image at step t, $a_t$ is the action at $s_t$, and the reward is R[$s_t$, $a_t$|$\\pi_\\theta$] = $f_{o,y}(s_0)$ \u2013 $f_{o,y}(s_{t+1})$, where $f_{o,y}$ is the confidence score of the true label y. Here, $a_t$ is a single pixel perturbation. We find that significant oscillations can be observed in the objective function. Let T* be the minimum number of steps to create an adversarial example. The sequence of pixels does not matter, leading to variations in the value of the objective function due to different orderings of $a_t$. Thus, for it \u2208 {0,1,2,\u2026\u2026\u2026, \u03c4*} and $i_j$ \u2260 $i_k$, the optimal objective function value is U* = \u0395[\u03a3$R[s_t, a_{i_1}|\\pi_\\theta]$]], with \u03c4*! permutations. This complicates training and increases the queries and $L_0$. To address this, we proposed the Forget and Remember process using one-step REINFORCE.\nPixel perturbations at 7* are defined as $A_\\tau*$ = \u2211 $a_t$. By the intermediate value theorem, there exists a C in [$x$, $x$ + $A_\\tau*$] such that $f_{o,y}(x)$ > $f_{o,y}(C)$ > $f_{o,y}(x + A_\\tau*)$. We propose a Forget and Remember process using one-step REINFORCE to iteratively find this C, assuming C\u2208 {$x$+$a_0$, $x$+$a_1$,\u2026\u2026\u2026, $x$ + $a_\\tau*$ }. This one-step approach avoids the fluctuations of multi-step methods, offering better query efficiency and lower $L_0$."}]}