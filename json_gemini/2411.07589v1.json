{"title": "Overhead-free User-side Recommender Systems", "authors": ["Ryoma Sato"], "abstract": "Traditionally, recommendation algorithms have been designed for service developers. But recently, a new paradigm called user-side recommender systems has been proposed. User-side recommender systems are built and used by end users, in sharp contrast to traditional provider-side recommender systems. Even if the official recommender system offered by the provider is not fair, end users can create and enjoy their own user-side recommender systems by themselves. Although the concept of user-side recommender systems is attractive, the problem is they require tremendous communication costs between the user and the official system. Even the most efficient user-side recommender systems require about 5\u00d7 more costs than provider-side recommender systems. Such high costs hinder the adoption of user-side recommender systems. In this paper, we propose overhead-free user-side recommender systems, RECCYCLE, which realizes user-side recommender systems without any communication overhead. The main idea of RECCYCLE is to recycle past recommendation results offered by the provider's recommender systems. The ingredients of RECCYCLE can be retrieved \u201cfor free,\" and it greatly reduces the cost of user-side recommendations. In the experiments, we confirm that RECCYCLE performs as well as state-of-the-art user-side recommendation algorithms while RECCYCLE reduces costs significantly.", "sections": [{"title": "1 INTRODUCTION", "content": "Recommender systems have been used in many web services [12, 21]. It was estimated that 35 % of purchases on Amazon and 75 % of watches on Netflix came from recommender systems [23]. Recommender systems are indispensable both for businesses and users.\nAlthough traditional recommender systems aim only at conversion, many fine-grained demands for recommender systems have emerged. Users may want to receive fair recommendations [4, 18, 26] or serendipitous recommendations [1, 8, 27, 42, 49], or users may want recommender systems to be transparent [2, 41] and steerable [2, 13]. For example, on LinkedIn, recruiters may want to receive account recommendations that are fair in terms of gender and race to avoid (implicit) discrimination. A citizen who gathers information for election may want to receive both Republican and Democrat news equitably to avoid filter bubbles [29]. Cinema enthusiasts may want to receive recommendations that involve minor movies instead of popular movies that enthusiasts already know.\nHowever, there are too many kinds of demands, and the service provider cannot cope with all of them. Besides, service provider may not implement such functionalities on purpuse. For example,"}, {"title": "2 NOTATIONS", "content": "For every positive integer $n \\in \\mathbb{Z}_+$, $[n]$ denotes the set $\\{1, 2, . . . n\\}$. Let $I = [n]$ denote the set of items, where n is the number of items. Without loss of generality, we assume that the items are numbered with 1, . . ., n. $K \\in \\mathbb{Z}_+$ denotes the length of a recommendation list. The notations are summarized in Table 2."}, {"title": "3 PROBLEM SETTING", "content": "We follow the basic setting of user-side recommender systems [33, 35]. Suppose we are an end user of the service (e.g., Twitter). The goal is to build our own recommender system without accessing privileged information stored in the service's database."}, {"title": "3.1 Provider Recommender System", "content": "In this paper, we focus on item-to-item recommendations, following Sato [33, 35]\u00b9. Specifically, when we visit the page associated with item i. The official recommender system of the service presents K items $P_{prov}(i) \\in I^K$, i.e., for $k = 1, 2, \u2026\u2026\u2026, K$, $P_{prov}(i)_k \\in I$ is the k-th relevant item to item i according to the service's recommender system. For example, $P_{prov}$ is observed in the \u201cCustomers who liked this also liked\" panel in e-commerce platforms. We call $P_{prov}$ the service provider's official recommender system. We assume that $P_{prov}$ provides relevant items but is unfair and is a black-box system. The goal is to build a fair and white-box recommender system by leveraging the provider's recommender system."}, {"title": "3.2 Sensitive Attributes", "content": "We encode the functionalities we call for by sensitive attributes following [33, 35]. We assume that each item i has a discrete sensitive attribute $a_i \\in A$, where $A$ is the set of sensitive groups. For example, in a talent market service, each item represents a person, and $A$ can be gender or race. In a news recommender system, each item represents a news article, and $A$ can be {Republican, Democrat}. In news recommender systems, A can also be { \u2265 10 000 views, \u2265 1000 & < 10 000 views, < 1000 views }, which leads to a recommender system that includes minor news articles as well. Many functionalities, including fairness, diversity, and serendipity, can be realized by leveraging the sensitive attributes. What sensitive attributes to use is up to the user's demand, and users can choose the sensitive attributes they want to use. In other words, each user can customize their own recommender system by choosing the sensitive attribute. In the following, we generalize the sensitive attributes as $a_i \\in A$, and the user can substitute $A$ with the sensitive attributes they want to use.\nWe want a user-side recommender system that offers items from each group in a certain proportion, e.g., so that each group is shown equally, or demographic parity holds. The proportion can also be specified by the user. We assume that sensitive attribute $a_i$ can be observed, which is the common assumption in [33, 35]. Admittedly, this assumption does not necessarily hold in practice. However, when this assumption is violated, one can estimate $a_i$ from auxiliary information, and the estimation of the attribute is an ordinary supervised learning task and can be solved by off-the-shelf methods, such as neural networks and random forests. As the attribute estimation process is not relevant to the core of user-side recommender system algorithms, this study focuses on the setting where the true $a_i$ can be observed."}, {"title": "3.3 Communication Cost", "content": "Existing user-side recommender systems [33, 35] incur high communication costs. When the user accesses the page associated with item i, these methods retrieve recommendations $P_{prov} (i_1), . . ., P_{prov} (i_c)$ for some items $i_1, . . ., i_c$ and make a fair recommendation for item i by combining these lists. These ingredients are retrieved by directly calling the API if available or crawling the service site otherwise. It means that these methods require downloading c item pages to build a single recommendation list and incur c times more communication costs than the official recommender system. Such a high communication cost leads to a long loading time, and it becomes impossible to obtain recommendation results in real time. Worse, such methods significantly increase the load on the service, and the service provider may prohibit such activities. In this paper, we aim to build a user-side recommender system that realizes fair recommendations with little or no communication overhead."}, {"title": "3.4 Problem Setting", "content": "The problem setting can be summarized as follows:\nUser-side Recommender System Problem.\nGiven: Oracle access to the official recommendations $P_{prov}$. Sensitive attribute $a_i \\in A$ of each item i eI.\nOutput: A user-side recommender system $Q: I \\rightarrow I^K$ that is fair with respect to A.\nQ should be obtained with as few evaluations of $P_{prov}$ as possible."}, {"title": "4 PROPOSED METHOD", "content": "We introduce our proposed method, RECCYCLE. The main idea of RECCYCLE is to store the past recommendations shown by the provider's recommender systems and utilize them to create new recommendations on the user's side. However, it is not straightforward to use the past recommendations directly as we will see in the following because the past recommendations are not fair."}, {"title": "4.1 Challenge", "content": "Simple postprocessing of the past recommendations fails. Suppose we want to build an account recommender system on X (Twitter). We set A = {man, woman}. We visit the page of i = Tom Hanks, and the official recommender system shows K = 6 items as follows:\n$P_{prov} (i = Tom Hanks)_1 = Seth Macfarlane (man) (1)\n$P_{prov} (i = Tom Hanks)_2 = Danny Devito (man) (2)\n$P_{prov} (i = Tom Hanks)_3 = Leonardo Dicaprio (man) (3)\n$P_{prov} (i = Tom Hanks)_4 = Jason Bateman (man) (4)\n$P_{prov} (i = Tom Hanks)_5 = Patrick Stewart (man) (5)\n$P_{prov} (i = Tom Hanks)_6 = Tom Cruise (man). (6)\nWe want to build fair recommendations for the Tom Hanks page, but it is impossible to create a fair recommendation list that contains woman by just preprocessing this list. We need to retrieve relevant woman accounts from other sources than $P_{prov} (i = Tom Hanks)$.\nTo overcome this challenge, we use the recommendation network."}, {"title": "4.2 Recommendation Network", "content": "A recommendation network is a graph where nodes represent items and edges represent recommendation relations. Recommendation networks have been traditionally utilized to investigate the properties of recommender systems [6, 7, 39]. They were also used to construct user-side recommender systems [33]. Recommendation network G = (V, E) we use in this study is defined as follows:\n\u2022 Node set V is the item set I.\n\u2022 Edge set E is defined by the recommendation results of the provider's recommender system. There exists a directed edge from i \u2208 V to j \u2208 V if item j is included in the recommendation list in item i, i.e., \u2203k \u2208 [K] s.t. $P_{prov}(i)_k = j$.\n\u2022 We do not consider edge weights.\nIt should be noted that G can be constructed solely by accessing $P_{prov}$. In other words, an end user can observe G.\nRecommendation networks have been used in user-side recommender systems [33, 35]. However, there is a clear distinction on how to build user-side recommender systems between RECCYCLE and the previous methods. Previously, the recommendation network was constructed by issuing queries to the official recommender system API or crawling the service site, which incurs a high communication cost. RECCYCLE does not issue additional queries to the official recommender system. Rather, RECCYCLE monitors the recommendations presented by the official recommender system when we use the service as usual and partially builds the recommendation network in an online manner. The regions of the network the user has never visited are not available in this manner, but it is not a problem as we will see in the following. RecCYCLE utilizes this recommendation network to build fair recommendations."}, {"title": "4.3 RecCycle", "content": "RECCYCLE can be combined with standard user-side recommender algorithms and turn them into overhead-free. The central idea is to cache the past recommendations.\nSuppose we are using the service as usual and visit item page i \u2208 I. The official recommender system shows $P_{prov} (i) = (r_{i1}, r_{i2}, . . ., r_{iK})$ and we can observe this list $(r_{i1}, r_{i2}, ..., r_{iK})$ by seeing the recommendation slot in the page. RECCYCLE stores this list into the cache $P(i) \\leftarrow (r_{i1}, r_{i2}, ..., r_{iK})$. In a practical implementation, RecCycle monitors the Document Object Model (DOM) of the service page by, e.g., a content script of a web browser, and extracts the list of items shown in the recommendation slot. This is a passive process, and it does not issue additional API queries to the official system but just monitors the web page. Some of the official recommendations may not catch the user's eye due to the position or the timing of the presentation, even if the recommendation is attractive to the user. RECCYCLE caches all of them, including ones the user misses, and utilizes them for future recommendations. The list can be extracted, and the cache P can be constructed \"for free\", i.e., without any additional communication cost. Note that strictly speaking, P is not a standard cache because the original queries are not issued by us but by the official system. We extract the results by scraping the DOM and store them as a cache. If we cached the API queries of traditional user-side recommender systems, we would incur API costs at least for the first query. We avoid the communication overhead even for the first recommendation by recycling the results emitted by the official system. When RecCYCLE creates a recommendation list on the user's side afterward, RECCYCLE uses P(i) instead of issuing queries to the official recommender system. This does not incur any communication overhead as P(i) is stored locally.\nThe core idea of RecCYCLE is simple. RECCYCLE uses any user-side recommender algorithm A that uses recommendation networks as a backbone algorithm. Many fair user-side recommender"}, {"title": "4.4 Properties of RecCycle", "content": "The properties of user-side recommender systems are defined as follows:\nConsistency. A user-side recommender system Q is consistent if nDCG of Q with $\\tau$ = 0 is guaranteed to be the same as that of the official recommender system. In other words, a consistent user-side recommender system does not degrade the performance if we do not impose the fairness constraint.\nSoundness. We say a user-side recommender system is sound if the minimum number of items from each sensitive group is guaranteed to be at least t provided $0 \\le t \\le K/|A|$ and there exist at"}, {"title": "5 EXPERIMENTS", "content": "We answer the following questions through the experiments.\n\u2022 (RQ1) How good a trade-off between performance and efficiency does RecCYCLE strike?\n\u2022 (RQ2) IS RECCYCLE robust to sparse cache?\n\u2022 (RQ3) Does RECCYCLE work in the real world?"}, {"title": "5.1 (RQ1) Performance", "content": "Setup. We use MovieLens100k [15], Adult dataset, Amazon Home and Kitchen [16, 24], and LastFM3 datasets following the existing work [33, 35].\nMovieLens dataset. In this dataset, an item represents a movie. We consider two ways of creating protected groups, (i) oldness: We regard movies released before 1990 as a protected group, and (ii) popularity: We regard movies with less than 50 reviews as the protected group. We use Bayesian personalized ranking (BPR) [31] for the provider's recommender system, where the similarity of items is defined by the inner product of the latent vectors of the items, and the top-K similar items are recommended. We use the default parameters of Implicit package for BPR. We measure nDCG@K and recall@K as performance metrics following previous works [17, 20, 31, 33]. Note that we use the full datasets to compute nDCG and recall instead of employing negative samples to avoid biased evaluations [20].\nAdult dataset. In this dataset, an item represents a person, and the sensitive attribute is defined by sex. We use the nearest neighbor recommendations with demographic features, including age, education, and capital-gain, as the provider's official recommender system. The label of an item (person) represents whether the income exceeds $50 000 per year. The accuracy for item i represents the ratio of the recommended items for item i that have the same label as item i. The overall accuracy is the average of the accuracy of all items.\nLastFM and Amazon dataset. In these datasets, an item represents a music and a product, respectively. We regard items that received less than 50 interactions as a protected group. We extract 10-cores for these datasets by iteratively discarding items and users with less that 10"}, {"title": "5.2 (RQ2) Robustness against Sparsity", "content": "We investigate the robustness of RecCycle against sparse history. RECCYCLE relies on the cache stored in the user's device. The cache may be sparse when the user has interacted with few items, i.e., the cold start problem in the user-side recommender systems. We evaluate the performance of RECCYCLE with different lengths of user histories.\nThe problem setup is the same as in Section 5.1, but we vary the lengths of random walks, i.e., the length of user histories. A shorter random walk indicates the user is newer or less active and has interacted with fewer items. We show the results for MovieLens + popularity fairness as the tendency is the same for all datasets. Figure 2 shows the performance of RecCycle with different lengths of user histories. We observe that the performance of RecCycle is robust against the sparsity of interaction. Note that the y-axis starts at around 0.102 for recall and 0.058 for nDCG, and the relative difference in performance is within a few percent. The performance is slightly worse when the cache is sparse, but the drop is marginal. Overall, 100 items are sufficient to achieve"}, {"title": "5.3 (RQ3) Case Study in the Real World", "content": "Finally, we show that RECCYCLE is applicable to real-world services via a case study. We use the user recommender system on X (Twitter), which is in operation in the real world. We stress that we are not employees of X Corp. and do not have any access to the hidden data stored in X. We run the experiments as an ordinary end user. The sensitive attribute is defined by gender in this experiment. Table 4 shows the results for the account of \u201cTom Hanks.\u201d The official recommender system shows only man accounts and is not fair with respect to gender. By contrast, RECCYCLE'S recommendations are completely balanced. In addition, RECCYCLE is overhead-free, i.e., it requires only the information of the one page that the user is currently viewing, and is more efficient than PRIVATEWALK and CONSUL, which require several additional queries to the official system of X. The results show that we can build a fair recommender system for X with respect to gender and realize the functionality we call for even though we are not employees but ordinary end users."}, {"title": "6 RELATED WORK", "content": "User-side Realization. User-side realization [33, 37] aims to help end users of services realize the functionalities they want, whereas traditional methods are designed for the developers of the services. Since the service is not tailor-made for a user, it is natural for dissatisfaction to arise. User-side realization provides proactive solutions to this problem. There have been many algorithms for user-side realization, including user-side search engines [32, 34], user-side privacy protection [36], user-side watermarking of large language models [38].\nAmong them, user-side recommender systems [33, 35] are the most relevant to this study. PRIVATEWALK and PrivateRank are the first user-side recommender systems [33]. However, they are not practical because they require a large number of accesses to the official recommender system or degrade the performance. CONSUL is the state-of-the-art user-side recommender system that strikes an excellent trade-off between performance and efficiency. CONSUL is also theoretically grounded and is the first user-side recommendation algorithm that is proven to hold three desired properties: consistency, soundness, and locality. Although CONSUL is the best user-side recommender system in the literature, it still incurs non-negligible communication overhead and is not practical in the real world."}, {"title": "Fairness in Recommender Systems", "content": "As fairness has become a major concern in society [28, 30], many fairness-aware machine learning algorithms have been proposed [14, 19, 47]. In particular, fairness with respect to gender [40, 45, 48], race [45, 48], financial status [10], and popularity [25, 44] is of great concern. In light of this, many fairness-aware recommendation algorithms have been proposed [4, 18, 26, 46]. Some of them aim to ensure fairness for users [5] and others aim to ensure fairness for items (such as products and accounts) [3, 9, 11, 22, 25], and some aim to ensure fairness for both users and items [5]. In this study, we focus on fairness for items following [33, 35], but the proposed method can also be applied to fairness for users when the official system is not fair for the very user that uses the user-side system. The user can overcome the unfairness of the official system by creating their own recommender system. Note that fairness is closely related to topic diversification [50] by regarding the topic as the sensitive attribute, and we considered the diversity of recommended items in this study as well."}, {"title": "Steerable Recommender Systems", "content": "The reliability of recommender systems has attracted a lot of attention [2, 43], and steerable recommender systems that let the users modify the behavior of the system have been proposed [2, 13]. User-side recommender systems also allow the users to modify the recommendation results. However, the crucial difference between steerable and user-side recommender systems is that steerable recommender systems must be implemented by a service provider, whereas user-side recommender systems can be built by arbitrary users even if the official system is an ordinary (non-steerable) one. Therefore, user-side recommender systems can expand the scope of steerable recommender systems by a considerable margin [33]."}, {"title": "7 CONCLUSION", "content": "We proposed RECCYCLE, the first overhead-free user-side recommender system. RecCYCLE realizes the functionalities a user wants on the user's side without communication overhead to the official system, which is in stark contrast to the existing user-side recommender systems, which require additional queries to the official system. This property is beneficial both for the users and the service providers. The users can enjoy the user-side system in real-time as if it were the official system, and the service providers can reduce the load of the servers. In the experiments, we confirmed that RECCYCLE is as effective as existing user-side recommender systems while it is much more efficient. We also carried out a case study on the real-world Twitter environment and showed that RECCYCLE can be applied to real-world services. We believe that RECCYCLE will be a practical and useful tool for end users to build their own recommender systems."}]}