{"title": "TIMETABLE NODES FOR PUBLIC TRANSPORT NETWORK", "authors": ["ANDRII ROHOVYI", "PETER J. STUCKEY", "TOBY WALSH"], "abstract": "ABSTRACT. Faster pathfinding in time-dependent transport networks is an important and challenging problem in navigation systems. There are two main types of transport networks: road networks for car driving [3, 20] and public transport route network [8]. The solutions that work well in road networks, such as Time-dependent Contraction Hierarchies and other graph-based approaches, do not usually apply in transport networks [13]. In transport networks, non-graph solutions such as CSA [8] and RAPTOR [7] show the best results compared to graph-based techniques. In our work, we propose a method that advances graph-based approaches by using different optimization techniques from computational geometry to speed up the search process in transport networks. We apply a new pre-computation step, which we call timetable nodes (TTN). Our inspiration comes from an iterative search problem in computational geometry. We implement two versions of the TTN: one uses a Combined Search Tree (TTN-CST), and the second uses Fractional Cascading (TTN-FC). Both of these approaches decrease the asymptotic complexity of reaching new nodes from O(kx log |C|) to O(k + log(k) +log(|C|)), where k is the number of outgoing edges from a node and C is the size of the timetable information (total outgoing edges). Our solution suits any other time-dependent networks and can be integrated into other pathfinding algorithms. Our experiments indicate that this pre-computation significantly enhances the performance on high-density graphs. This study showcases how leveraging computational geometry can enhance pathfinding in transport networks, enabling faster pathfinding in scenarios involving large numbers of outgoing edges.", "sections": [{"title": "1. INTRODUCTION", "content": "The transportation problem is a ubiquitous challenge in today's modern world, driving fierce competition within the market. Every company tries to achieve more efficient transport routing, which should be calculated quickly. The speed of response for pathfinding can be critical for business applications and plays a crucial role in competitiveness for routing services. In contrast to other fields in AI, such as Machine Learning and Deep Learning, development in this field has mostly lacked transparency. For instance, it is not easy to find open-source solutions in this area to compare results and iteratively improve them.\nThe transportation problem involves two main areas: the challenge of car travel on road networks and the issue of public transportation on transport graphs. It's interesting to note that completely different classes of algorithms are used to solve these two problems [13]. Routing in road networks typically uses graph-based approaches like Time-dependent Contraction Hierarchy, whereas transit routing"}, {"title": "2. PRELIMINARIES", "content": "This section establishes basic terminology and introduces foundational algorithms"}, {"title": "2.1. Terminology.", "content": "Transport Network. A Transport Network is a complex system of interconnected infrastructure that facilitates people's movement from one location to another. It provides essential connections between various places, enabling efficient and effective transportation and communication. Instead of classical graphs, the edges in the transport network are modelled as functions of time f(t).\nIn its mathematical formulation, this graph can be presented as $G = (V, E, F,T)$, where V is the set of nodes, E is the set of edges, where $E \u2286 V \u00d7 V$, $f\u2208 F$ is a set of functions, where for edge e = (v, v'), given start time t at node v, $f_e(t)$ returns the arrival time at v' using edge e.\nMultimodal Transport Network. One type of Transport Network is the Multimodal Transport Network. It is a system where each function f(t) represents different modes of transportation, such as cars, buses, trains, walking, etc.\nIn our study, we focused on a system that depicted transportation modes for public transport and walking."}, {"title": "Arrival Time Functions (ATF).", "content": "ATF [18] are a way of representing the travel time functions f(t) in a Multimodal Transport Network. The arrival time function provides information about the expected or actual arrival (and implicitly departure) times of transportation services at specific nodes in the transport network.\nThese functions have the next set of features:\n\u2022 \u2200f \u2208 F, \u2200x, y \u2208 T, x > y = f(x) \u2265 f(y)\n\u2022 \u2200f \u2208 F, \u2200t \u2208 T, f(t) \u2265 t\n\u2022 \u2200 f, g\u2208 F, f \u00b0 g \u2208 F\n\u2022 \u2200 f, g\u2208 F, min(f, g) \u2208 F"}, {"title": "Walk profile.", "content": "The walk profile function calculates the arrival time for pedestrians trying to get from one node (e.g., bus stop, train station) to another node within the network by foot. This information is essential for passengers who need to transfer between different transportation services or modes of transport during their journey.\nThe classical walk profile function looks the following way:\n$f_{v_1,v_2} (t) = t + w(v_1, v_2)$\nwhere $w(v_1, v_2)$ is the walk duration to walk from node $v_1$ to node $v_2$. Note that we may disallow walking along edges which are too long, by setting $w(v_1, v_2) = \u221e$."}, {"title": "Timetable.", "content": "The timetable is the set of departure and arrival times from one stop to another, where the arrival time is greater than or equal to the departure time.\n$C = {(d, a)|d, a \u2208 T, a \u2265 d}$"}, {"title": "Bus profile.", "content": "The bus profile function calculates the arrival time for pedestrians trying to get from one node (e.g., bus stop, train station) to another node within the network by bus, train, or any other public transport that uses timetables. The classical bus profile function looks as follows:\n$f_{v_1,v_2}(t) = min{a|\u2203(d, a) \u2208 C_{v_1, v_2}, d \u2265 t}$,\nwhere $C_{v_1,v_2}$ are the timetable connections along edge $(v_1, v_2)$, given as pairs (d, a) of departure time d and arrival time a."}, {"title": "Size of ATF.", "content": "The size of the ATF functions is determined by the number of elements in the timetable.\nLet's take a look at the example graph segment shown in Figure 1. In this graph, the node A has 3 outgoing arcs. The edge A \u2192 B is denoted by a walking connection with a 40-minute duration and a bus with a timetable size of two $size(f_{A,B}) =$ $size(C_{A,B}) = 2$. Similarly, the edge A \u2192 C is represented by the timetable size of three, but it is not feasible to reach it by walking, as the walking duration is set to infinity $size(f_{A,C}) = size(C_{A,C}) = 3$. The edge A \u2192 D is depicted by the size of timetable four, along with a walking connection of 20 minutes $size(f_{A,D}) = size(C_{A,D}) = 4$."}, {"title": "ATF evaluation.", "content": "To evaluate the Arrival Time Function, we employ a binary search over the timetable with bus profiles and then compare the resulting arrival time with the walking profile. The complexity of this operation is $O(log(size(f_{v_1,v_2})))$, where $size (f_{v_1, v_2})$ represents the size of the timetable for this edge.\n$f_{v_1,v_2}(t) = min(t + w(v_1, v_2), min(a|\u2203(d, a) \u2208 C_{v_1, v_2}, d \u2265 t))$\nLet's analyze the asymptotic complexity of such evaluation: Assuming the search over timetable $C_{v_1,v_2}$ is binary, the complexity of evaluation is we have the next $O(min{1, log(|C|)}) = O(log(|C_{v_1, v_2}|))$."}, {"title": "Chaining.", "content": "Chaining in the transport network is an operation of computation of the new function, which covers a path over two edges. For instance, we have an edge from node u to node v, which is represented as a function $f_{uv}$ and an edge from node v to node w, which is defined as a function $f_{vw}$, then chaining is a new function from node u to w, which is equal to $f_{uw}(t) = f_{vw} \u00b0 f_{uv}(t) = f_{vw}(f_{uv}(t))$."}, {"title": "Merging.", "content": "Merging in a Transport Network minimises two functions $f_{uv}(t)$ and $f_{uv'}(t)$ over the same edge uv. In this case, we have two parallel edges and need to build a new function $f_{uv'}(t) = min(f_{uv}(t), f_{uv'}(t))$, which will preserve the shortest path traversal across this edge."}, {"title": "Path.", "content": "A path P in a transport graph between node s and node d is a sequence of nodes $(v_0, v_1, ..., v_k)$, where $k\u2208N^+$vo = s and $v_k = d$ and $\u2200i \u2208 {0,1,2..., k \u2212 1}\u2203v_{i,i+1} \u2208 E,\u2203v_i \u2208 V,\u2203v_{i+1} \u2208 V.\nIn the transport network the length or cost for path |P| = $f_P(t)$, where $f_{v_0,v_k} (t) = f_{v_{k-1},v_k} (f_{v_{k-2},v_{k-1}} (..f_{v_1, v_2} (f_{v_0, v_1} (t))...))$ is dependent on start time $t \u2208 T$.\nLet $sp(s, d, t)$ denote the shortest path from node s to node d, when we start our movement from node s at the time $t\u2208T$."}, {"title": "Merged timetable.", "content": "A merged timetable is another way of representing the public transport system and is used in non-Dijkstra algorithms, such as the Connection Scan Algorithm (CSA). The merged timetable ($C_m$) is a tuple of (V, C, W, Tr), where V represents the set of stops (similar to the set of nodes in the previous representation), C represents the timetable between two stops, W represents footpath connections between stops, and Tr represents scheduled transport between stops. The size of the merged timetable is the number of elements in $C_m$."}, {"title": "2.2. Algorithms.", "content": "Connection Scan Algorithm (CSA). The Connection Scan Algorithm (CSA) [8] efficiently answers queries for timetable information systems. It is a non-graph approach that is specialized for timetable systems. We used it for a comparison analysis. The algorithm puts all information into one merged timetable $C_m$, runs a binary search once over the whole timetable to find the closest connection, and then iteratively checks if the next connections could be a part of our journey. It"}, {"title": "Dijkstra (Dij.)", "content": "Dijkstra's algorithm [9] is a graph-based pathfinding algorithm used to find the shortest path between two nodes in a weighted graph. The time complexity of Dijkstra's algorithm is O(|E| + |V| \u00d7 log(|V|)) [10]."}, {"title": "Contraction Hierarchies (CH).", "content": "Contraction Hierarchies is a graph augmentation method that helps speed up future pathfinding [12]. The idea of this algorithm is to iteratively contract nodes from the graph and insert new edges that represent shortest paths through the contracted node. In broad strokes:\n(1) Set up hierarchical order L of the nodes contraction. While preprocessing and query algorithms work for any contraction ordering, it is preferable to use one that produces as few shortcuts as possible. This leads to a small space requirement and faster query time. The problem of minimizing the number of edges of a given graph's Contraction Hierarchies is APX-hard, so it is computed using heuristics [17]. In our research, we used linear combinations of the following factors as heuristics to determine the order of contraction:\n(a) Edge difference. The immediate cost of the number of edges is calculated as the number of shortcuts inserted minus the number of edges removed.\n(b) Depth. When starting off, the depth of a vertex u is 0. When a vertex u is contracted, the depth of its neighbour v is updated to be the maximum of its current depth and the depth of u plus 1. This updated depth value serves as an upper limit for the length of a path when making queries, and it helps in choosing vertices more evenly.\n(2) Iteratively select the lowest node v in the hierarchy L, which hasn't been previously contracted.\n(3) Contract selected node v, adding a new shortcut edges $e_{uw}$, which will cover paths from each in-neighbor u to each out-neighbor w passing through v. Obviously, v is lower in the hierarchy than u or w.\n(4) After contracting all nodes, in order to limit the number of shortcuts added, we perform a shortest path search to determine if a shortcut may be unnecessary. This procedure is called witness search, and it is used to exclude shortcuts that do not represent the optimal path.\nEvery contracted graph has two types of edges:\n\u2022 Upward edge $e_{uw} \u2191$, if node w lexically larger then node u, $L_u < L_w$\n\u2022 Downward edge $e_{uw}\u2193$, if node u lexically large then node w, $L_u > L_w$"}, {"title": "Time-dependent Contraction Hierarchies (TCH).", "content": "TCH [3] is an adaptation of CH for the transport network, where every edge is represented as a function f(t) over the time t\u2208 T. In our TCH implementation, we omitted a witness search due to its computational expense on the graph with the ATF functions we use.\nIn CH and TCH, a new shortcut edge $e_{uw}$ is added if both nodes u and w appear later in the hierarchy than the intermediate node v, and $e_{uw}$ is optimal and equivalent to the path (u; v; w). Therefore, for every pair of edges $(e_{uv}; e_{vw})$, there must exist a cost-equivalent upward edge $e_{uw} \u2191$ (i.e., $u < L_w$) or downward edge $e_{uw} \u2193$ (i.e., $u > L_w$) if (u; v; w) is a shortest path from u to w for some t\u2208T.\nThe following results, paraphrased here, are due to [12]:\nLemma 1 (TCH-path). For every optimal path $sp(s;d;t)$ in G, there is a cost equivalent TCH-path (s; . . . ; k...; d) whose prefix (s; ... ; k) is an up path (i.\u0435., s <"}, {"title": "Forward search (FS).", "content": "FS [14] is a pathfinding algorithm using forward (A* [15]) search over the contraction hierarchy graph, which utilizes CH-graph characteristics to optimize query runtimes. Usually search in CH-graphs uses bi-directional search [3], the use of forward search means we can use heuristics to reduce the search.\nFor Forward Search we can precompute down-reachable bounding boxes for every node v that are large enough to contain all the nodes reachable from v by only down edges. During the search, before taking a down edge from v we can check if the target node is contained in the down-reachable bounding box of v, if not we do not need to consider taking any down edge from v. These pruning rules significantly improve the search process [14, 20]."}, {"title": "3. TIMETABLE NODES (TTN)", "content": "To speed up the edge evaluation process, we modify the pathfinding algorithm and move the evaluation process to the node level [5]. The idea behind this is to store information about departure time not on the edge level, as is the case in a graph with timetable edges (TTE), but on the node level and, during the pathfinding process, evaluate this level.\nThis idea is inspired by an iterative search problem in computational geometry [19]. This problem could be formulated in the following way. Let's assume that we have k catalogues and query value x, and we try to simultaneously to find the least value larger than or equal value to x in all k catalogues. This task appears in computational geometry problems [6], such as:\n\u2022 Given a collection of intervals on the line, how many of them intersect an arbitrary query interval?\n\u2022 Given a polygon P, which sides of P intersect an arbitrary query line?\n\u2022 Given a collection of rectangles, which of them contains an arbitrary query point?"}, {"title": "3.1. Combined Search Tree.", "content": "One of the approaches in resolving iterative search problems is called the Combined Search Tree [19]. The concept behind this method is to combine all departure times from schedules for edges leaving node v. This allows us to find connections by performing a binary search on this combined list of departure times. After this step, we can refer to the precomputed matrix k times. This matrix contains data about the connections between departure times in the combined list and the departure times in the outgoing edges, with k representing the number of outgoing edges.\nThis idea finds good application in search over the transport network graph. Recall the graph segment shown in Figure 1 that we have the graph with nodes A, B, C and D and edges between nodes A and nodes B, C and D.\nWe can created the sorted concatenation of departures connections from node A as: 12:00, 12:45, 13:30, 14:00, 15:15, 16:05, 18:00, 20:10.\nIn a pre-computation step, we calculate a matrix with information about the connection between the node and edges departure times. For the graph segment of"}, {"title": "3.2. Fractional Cascading.", "content": "We now introduce an advanced technique from computational geometry called Fractional Cascading [6] which allows us to find the next connection for all outgoing edges with just O(k \u00d7 |C| \u00d7 n) of additional space but retaining the same time complexity $O(k+log(k) +log(|C|))$ as the combined search tree.\nGiven a series of ordered lists $D_0, D_1,..., D_k$ where each $D_i$ is a list of elements sorted in increasing order, the goal of Fractional Cascading is to preprocess these lists into a tree structure that allows for efficient search queries. A search query involves finding the position of a given value t in each of the lists $D_0, D_1,..., D_k$.\nThe preprocessing should enable search operations such that if we find the position of t in $D_i$ in time O(log size($D_i$)), we can find the positions of t in $D_{i+1}, D_{i+2},..., D_k$ in total time O(k), where k is the number of subsequent lists.\nThe preprocessing involves the following steps:\n(1) Initiation: Set up augmented list $M_k$ equal to original list $D_k$, where k is amount of lists.\n(2) Lists Augmentations: For each list $D_i$ create an augmented list $M_i$ by adding a fraction of elements from the subsequent list $M_{i+1}$. Specifically, for each element in $C_i$, merge it with every second element in $M_{i+1}$.\n(3) Bridges Setup:\n\u2022 For each element $d_{in}$ in the augmented list $M_i$, we build a linker, which is called a \"bridge\u201d to the element $d_{i+1,k}^{arg}$ in $M_{i+1}$, where $d_{i+1,k} ="}, {"title": "3.2.1. Sorting strategies.", "content": "Different sorting strategies are used for setting up lists in Fractional Cascading. The main ones involve sorting lists in ascending order (ASC) and placing smaller lists at the bottom of the fractional cascading hierarchy or sorting in descending order (DSC) and placing larger lists at the bottom of the fractional cascading hierarchy.\nContraction Hierarchical Sorting. We have developed a special adaptation of the Timetable Nodes using the Fractional Cascading (TTN FC) technique for the Forward Search algorithm called Contraction Hierarchical Sorting (CHHIER). We reverse the sequence of Fractional Cascading trees to match the hierarchy of nodes connected through edges in the TCH graph. This means that the list of departure times of the outgoing edges, which is connected to the nodes with the highest hierarchy, will be located at the bottom of the Fractional Cascading tree. This approach enables us to streamline the Forward Search while moving downward. For example, when the augmented list is linked to the edge connected to the node higher in the hierarchy than the current node, we can end the extraction of departure times over the Fractional Cascading tree.\nFor instance, in Figure 1, if node A has a hierarchy of 54, node B has a hierarchy of 60, node C has a hierarchy of 52, and node D has a hierarchy of 15, the Fractional Cascading tree will look as follows:"}, {"title": "4. EXPERIMENTS", "content": "All calculations and research have been done using Python on the MacBook Pro with Apple M3 Max chip, which has a 16-core CPU, 40-core GPU, and 128GB Unified Memory. For reproducibility, all of our implementations are available 1.\n4.1. Real city analysis. Our research used a public dataset of about 25 cities published by Kujala et al [16]. The complete list of cities is as follows: Kuopio (KUO), Belfast (BFS), Turku (TKU), Grenoble (GNB), Luxembourg (LUX), Canberra (CBR), Palermo (PMO), Nantes (NTE), Rennes (RNS), Detroit (DTW), Venice (VCE), Toulouse (TLS), Bordeaux (BOD), Winnipeg (YWG), Dublin (DUB), Adelaide (ADL), Brisbane (BNE), Lisbon (LIS), Prague (PRG), Berlin (BER), Melbourne (MEL), Helsinki (HEL), Sydney (SYD), Rome (FCO), Paris (CDG).\nThe researchers collected General Transit Feed Specification (GTFS) from various public transport agencies, which provide their data in open-source. For walking connections, they used information from OpenStreetMap. They compute pair-to-pair connections, limiting walking connections to less than 1km distance. In our experiments, we implemented a more stringent walking limit of 600 meters due to memory errors encountered while computing the TCH-graph without these limitations. As an average walking speed, we took 1 meter per second.\nIn our experiment, we used information about public transport schedules on extraction date provided in the dataset [16].\nIt is essential to admit that in our realization we store string information about public transport in our graph, which we will use to move from one station to another. In the production-ready service, this data should be converted to an integer, and the name should be stored separately, reducing memory usage.\n4.1.1. Query Processing Time. For comparing query times, we picked 1000 random combinations of stops and times between extractions dates in the dataset [16].\nResults in average runtime in microseconds for the different precomputation techniques are presented in Table 5.\nIn our dataset, we have connections with zero length, where the departure and arrival times are equal. The classical CSA algorithm cannot handle such cases. Therefore, we modified the CSA algorithm to reiterate each time all connections with zero length, in case some of the arrival times have been updated.\nIt is important to note that graph-based approaches can move multiple times by walking along edges. With CSA, we can only allow walking connections from one"}, {"title": "4.2. Synthetic graph analysis.", "content": "To further investigate why TTN-CST performs better for TCH and TTN-FC performs better for the original graph, we created a synthetic random graph with 60 nodes and varying numbers of outgoing edges. In the first scenario, we established each edge to have both a walking connection and a transport connection. Specifically, we chose the connection in Sydney City between \"High St Near Prince Of Wales Hospital\" and \"Coogee Bay Rd Near Perouse Rd\". The timetable representing this connection has a size of 59, with a walking duration of 404 seconds. We build our experiment applying different modification of Dijkstra algorithm. As we varied the number of edges in the graph, we observed a correlation between duration time and algorithm selection, as depicted in Figure 4.\nIn the chart Figure 4, we can see that TTN-CST outperforms other solutions, and the more outgoing edges we have, the better the performance. This situation is similar to what we observe for the TCH graph in Table 1, except for large graphs larger than 10Gb, for which each preprocessing technique does not yield significant results. We note that TTN-FC-ASC and TTN-FC-DSC produce the same results, which is expected since our graphs are synthetic with the same timetable.\nAfter this observation, the logical question is: under what circumstances does TTN-FC work faster than TTN-CST? To answer this question, we left all walking connections between the nodes but decreased the percentage of nodes with public transport connections to 20% and repeated the experiment. The results are depicted in the Figure 5.\nIn Figure 5, we notice that as the average amount of outgoing edges increases, the TTN approach shows higher improvement. However, in this instance, TTN-CST demonstrates better performance. This trend is also evident in experiments involving real cities. In the original graph, TTN-FC outperformed the TCH graph, except in the case of Berlin, where the percentage of timetable outgoing edges in the original graph was 65%."}, {"title": "5. CONCLUSION AND FUTURE WORK", "content": "TTN is a good approach to solving multimodal pathfinding problems over high-density transport graphs. This algorithm takes a step forward in speeding up graph-based algorithms over the transport graph. The reason for it is the decreasing of asymptotic complexity of node evaluation from O(k \u00d7 log |C|) to O(k + log(k) + log(|C|)). In the meantime, in the case of cities with large amounts of outgoing edges, it is still better to use non-graph approaches, such as the Connection Scan Algorithm.\nIn our future work, we plan to rewrite our solution in C++. We believe that this may lead to faster processing and better memory control. It will help that each Fractional Cascading tree be located in a compact memory region, consequently speeding up the search process.\nWe plan to test our solution on the traditional road network problem in our future research. We want to see how well it performs in this context. Our approach could speed up the Time-Dependent Contraction Hierarchies with Compressed Database heuristic [4, 20]. Additionally, we're interested in comparing TTN with the method of splitting times into different buckets, which is currently widely used for dealing with the search over large time frames."}]}