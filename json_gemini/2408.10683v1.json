{"title": "Rejection in Abstract Argumentation: Harder Than Acceptance?", "authors": ["Johannes K. Fichte", "Markus Hecher", "Yasir Mahmood", "Arne Meier"], "abstract": "Abstract argumentation is a popular toolkit for modeling, evaluating, and comparing arguments. Relationships between arguments are specified in argumentation frameworks (AFs), and conditions are placed on sets (extensions) of arguments that allow AFs to be evaluated. For more expressiveness, AFs are augmented with acceptance conditions on directly interacting arguments or a constraint on the admissible sets of arguments, resulting in dialectic frameworks or constrained argumentation frameworks. In this paper, we consider flexible conditions for rejecting an argument from an extension, which we call rejection conditions (RCs). On the technical level, we associate each argument with a specific logic program. We analyze the resulting complexity, including the structural parameter treewidth. Rejection AFs are highly expressive, giving rise to natural problems on higher levels of the polynomial hierarchy.", "sections": [{"title": "1 Introduction", "content": "Argumentation is a popular area of AI [3, 40]. An important computational framework, also known as abstract argumentation is Dung's argumentation framework (AF) [18]. AFs are widely used for modeling, evaluating, and comparing arguments. The semantics is based on sets of arguments that satisfy certain conditions such as being admissible, stable, or preferred. Such sets of arguments are then called extensions of a framework.\nOver time, various weaknesses of the somewhat simple modeling of arguments via AFs have been dictated, followed by proposed extensions, thereby providing another layer of \"acceptance\" conditions for arguments. For instance, Constrained Argumentation Frameworks (CAFs) [16] or Abstract Dialectical Frameworks (ADFs) [12]. But what happens, if we are interested in rejecting conditions? Some semantics implicitly define the concept of rejection by (subset-)maximality conditions, e.g., preferred or stage semantics. However, real-life is more complicated and goes beyond simple maximization (see Example 6).\nIn this paper, we extend argumentation frameworks by flexible concepts of rejection. Since in knowledge representation (KR) global constraints are oftentimes expressed by means of propositional logic, we pursue our line of work in this direction. Naturally, we attach logical formulas to arguments, which is common in argumentation [12, 16, 32]. The models of these formulas form counterclaims to arguments being accepted. As a result the presence of such counterclaims forms the concept of rejection in AFs, which we call rejection framework (RCF). Interestingly, under reasonable complexity-theoretic assumptions, it turns out that it is harder to express rejection than acceptance. Indeed, compared to other approaches to model acceptance (e.g., CAFs), the concept of rejection increases computational hardness by one level already when we allow auxiliary variables. To express even harder rejection constraints, we study the case where CCs can be represented as the models (answer sets) of a logic program [29], since ASP is commonly used for argumentation [28]. Specifically, we associate each argument a with a logical program as its rejection condition (RC). When computing extensions, these RCs must be altogether invalidated and thus no longer counter-attack their arguments. This results in a compact and natural representation of rejection in AFs. Further, we depict via an example (Ex. 6) a scenario where such rejection conditions can not be modeled in AFs without losing the extensions."}, {"title": "2 Preliminaries", "content": "We assume familiarity with complexity [39], graph theory [9], and logic [6]. For a set X, we denote X' := { x' | x \u2208 X }.\nAbstract Argumentation. We use Dung's AF [18] and consider only non-empty and finite sets of arguments A. An (argumentation) framework (AF) is a directed graph F = (A, R) where A is a set of arguments and R \u2286 A\u00d7A a pair of arguments representing direct attacks of arguments. An argument s \u2208 S, is called defended by S in F if for every (s', s) \u2208 R, there exists s'' \u2208 S such that (s'', s') \u2208 R. The set defF (S) is defined by defF(S) := {s | s \u2208 A, s is defended by S in F}.\nIn abstract argumentation, one strives for computing so-called extensions, which are subsets S \u2286 A of the arguments that have certain properties. The set S of arguments is called conflict-free in S if (S\u00d7S) \u2229R = \u00d8; S is admissible in F if (1) S is conflict-free in F, and (2) every s \u2208 S is defended by S in F. Let \\Bar{S} := S \u222a {a | (b,a) \u2208 R, b \u2208 S } and S be admissible. Then, S is a) complete in F if defF(S) = S;\nb) semi-stable in F if no admissible set S' \u2286 A in F with S \u2286 (S')\\Bar{} exists; and c) stable in F if every s \u2208 A \\setminus S is attacked by some s' \u2208 S. A conflict-free set S is stage in F if there is no conflict-free set S' \u2286 A in F with S \u2286 (S')\\Bar{}. Let S* := {conf, adm, comp, stab} and S := S* \u222a {semiSt, stag}. For a semantics \u03c3 \u2208 S, we write Ext\u03c3(F) for the set of all extensions of \u03c3 in F.\nLet AF F = (A, R) be an additionally given framework. Then, the problem cons\u03c3 asks if Ext\u03c3(F) \u2260 \u00d8, and cred(\u03c3) asks for given c \u2208 A, whether c is in some S \u2208 Ext\u03c3(F) (\u201ccredulously accepted\u201d).\nExample 1. Consider an AF that models aspects of a conference submission, . If we have noSubmission, we cannot Travel to a conference and Present. Having a paper Written up attacks noSubmission. Hence, a stable extension is E = {W,T, P}.\nAnswer Set Programs (ASP). We consider a universe U of propositional atoms; a literal is an atom a \u2208 U or its negation \u00aca. A program P is a set of rules of the form a\u2081 \u2228 ... \u2228 a\u2097 \u2190 b\u2081, ..., b\u2099, ~c\u2081, ..., ~c\u2098 where a\u2081, ..., a\u2097, b\u2081, ..., b\u2099, c\u2081, ..., c\u2098 are atoms. We write H(r)={a\u2081, ..., a\u2097}, called head of r, B+(r)={b\u2081, ..., b\u2099}, called positive body r, and B\u207b(r)={c\u2081, ..., c\u2098}, called negative body of r. The atoms in a ruler or program P are given by var(r)=H(r)\u222aB+(r)\u222aB\u207b(r) and var(P)=\\bigcup_{r\u2208P} var(r), respectively. We sometimes view a ruler \u2208 P as a set H\u222aB+\u222a\\bigcup_{x\u2208B\u207b} {\u00acx} of literals. Consider digraph D\u209a of a program P which has vertices var(P) and a directed edge (x, y) between any two atoms x, y \u2208 var(P) if there is r\u2208 P with x \u2208 H(r) and y \u2208 B+(r). Then, P is tight if there is no cycle in D\u209a [4, 35]. We refer by Disj to the class of (disjunctive) programs. By Normal we mean programs containing only rules r with |H(r)| \u2264 1, so called normal rules. The class Tight refers to tight programs.\nA set M of atoms satisfies a rule r if (H(r) \u222a B\u207b(r)) \u2229 M \u2260 \u00d8 or B+(r) \\setminus M \u2260 \u00d8. M is a model of P if it satisfies all rules of P, we write M \u22a8 P for short. The (GL) reduct of a program P under a set M of atoms is program P^{M} := { H(r) \u2190 B+(r) | r \u2208 P, M \u2229 B\u207b(r) = \u00d8 } [30]. M is an answer set program P if M is a \u2286-minimal model of P^{M}. For tight programs this is equivalent to M \u22a8 P such that every a \u2208 M is justified by P, i.e., there has to exist r \u2208 var(P) with a \u2208 H(r), M \u2287 B+(r) and M \u2229 B\u207b(r) = \u00d8 [37]. Deciding whether a program has an answer set (consistency problem) is \u03a3_{2}^{P}-complete [24].\nQBFs. Let l be a positive integer, called (quantifier) rank, and \u22a5 and \u22a4 be the constant always evaluating to 0 and 1, respectively. A conjunction or disjunction of literals is called a term or clause, respectively. For a Boolean formula F, we write var(F) for the variables occurring in F and F(X\u2081, ..., X\u2097) to indicate that X\u2081, ..., X\u2097 \u2286 var(F). A quantified Boolean formula (QBF) \u03a6 is of the form \u03a6 = Q\u2081X\u2081.Q\u2082X\u2082.\u2026\u2026\u2026Q\u2097X\u2097.F(X\u2081, ..., X\u2097), where for 1 < i < l, we have Q\u1d62 \u2208 {\u2200,\u2203} and Q\u1d62 \u2260 Q\u1d62\u208a\u2081, the X\u1d62 are disjoint, non-empty sets of Boolean variables, and F is a Boolean formula. We let matr(\u03a6) := F and we say that \u03a6 is closed if var(F) = \\bigcup_{i\u2208[l]} X\u1d62. We evaluate \u00a2 by \u2203x.\u00a2 = \u03c6[x\u2192 1] \u2228 \u03c6[x\u21920] and \u2200x.\u0444 = [x - 1]\u2227[x\u21920] for a variable x. We assume that matr($) = \u03c8^{CNF} \u2227 \u03c8^{DNF}, where \u03c8^{CNF} is in CNF (conjunction of clauses) and \u03c8^{VDNF} is in DNF (disjunction of terms).\nSyntactically, we often view a Boolean CNF formula \u03c8^{CNF} and a DNF formula \u03c8^{DNF} as a set of sets of literals. Then, depending on Q\u2097, either \u03c8^{VCNF} or \u03c8^{VDNF} is optional, more precisely, \u03c8^{VCNF} might be \u22a4, if Q\u2097 = \u2200, and \u03c8^{DNF} is allowed to be \u22a4, otherwise. The problem l-QSAT asks, given a closed QBF \u03a6 = \u2203X\u2081.\u03a6' of rank l, whether \u03a6 = 1 holds.\nTree Decompositions and Treewidth. For a rooted (directed) tree T = (N, A) with root rt(T) and a node t \u2208 N, let children(t) be the set of all nodes t*, which have an edge (t, t*) \u2208 A.\nLet G = (V, E) be a graph. A tree decomposition (TD) of a graph G is a pair T = (T, \u03c7), where T is a rooted tree, and \u03c7 is a mapping that assigns to each node t of T a set \u03c7(t) \u2286 V, called a bag, such that: (1.) V = \\bigcup_{t of T} \u03c7(t) and E \u2286 \\bigcup_{t of T}{{u, v} | u, v \u2208 \u03c7(t)}, (2.) for each s lying on any r-t-path: \u03c7(r) \u2229 \u03c7(t) \u2286 \u03c7(s). Then, define width(T) := max_{t of T} |\u03c7(t)| - 1. The treewidth tw(G) of G is the minimum width(T) over all TDs T of G. Observe that for every vertex v \u2208 V, there is a unique node t* with v \u2208 \u03c7(t*) such that either t* = rt(T) or there is a node t of T with children(t)={t*} and v \u2209 \u03c7(t). We refer to the node t* by last(v). We assume TDs (T, \u03c7), where for every node t, we have |children(t)| \u2264 2, obtainable in linear time without width increase [7].\nFor a given QBF \u03a6 with matr(\u03a6) = \u03c8^{CNF} > \u03c8^{DNF}, we define the primal graph G_{\u03a6} = G_{matr(\u03a6)}, whose vertices are var(matr(\u03a6)). Two vertices of G_{\u03a6} are adjoined by an edge, whenever corresponding variables share a clause or term of \u03c8^{CNF} or \u03c8^{DNF}. Let tower(i,p) be tower(i \u2013 1,2^{p}) if i > 0 and p otherwise. Further, we assume that poly(n) is any polynomial for given positive integer n.\nProposition 2 ([15]). For any arbitrary QBF \u03a6 of quantifier rank l > 0, the problem l-QSAT can be solved in time tower(l, O(tw(G_{\u03a6}))) \u00b7 poly(|var(\u03a6)|).\nUnder exponential time hypothesis (ETH) [33], this cannot be significantly improved.\nProposition 3 ([26]). Under ETH, for any QBF 4 of quantifier rank l > 0, l-QSAT cannot be solved in time tower(l, o(tw(G_{\u03a6}))) \u00b7 poly(|var(4)|).\nTDs for AFs. Consider for AF F = (A, R) the primal graph GF, where we simply drop the direction of every edge, i.e., GF = (A, R') where R' := {{u, v} | (u, v) \u2208 R}. For any TD T = (T, \u03c7) of GF and any node t of T, we let A_{t} := A \u2229 \u03c7(t) be the bag arguments of t and R_{t} := R \u2229 {(a, b) | a, b \u2208 \u03c7(t)} be the bag attacks of t."}, {"title": "3 Rejection Augmented AFs (RCFs)", "content": "Next, we provide a definition for the syntax and semantics of rejection conditions in abstract argumenta-tion frameworks.\nDefinition 4. A rejection augmented AF (RCF) is a triple G = (A, R, C) where (1.) (A, R) is an AF, and (2.) C: A \u2192 I is a labeling, called rejection conditions (RCs), that maps every argument in the framework to a constraint P\u2208 I where I is a set of ASP programs.\nFor brevity, we lift, for a set E \u2286 A of arguments, the RCs of E to C(E) := \\bigcup_{e\u2208E} C(e).\nWe say that C is propositional, if II is a set of CNF formulas instead of programs. We say C is simple if var(C(A)) = A and C is propositional. If C(A) is a tight or normal program, C is called tight or normal, respectively; otherwise C is disjunctive.\nSemantics. For an argumentation semantics, we naturally extend the notion to an extension for RCFS G = (A, R, C). Intuitively, the mapping C gives rise to a program/formula that specifies the RCs for each argument. Ultimately, RCs of an extension must be invalidated.\nDefinition 5. Let G=(A, R,C) be a RCF and \u03c3 \u2208 S. Then, E \u2286 A is a \u03c3-extension (of G) if E \u2208 Ext(A, R) and C(E) \u222a E \u222a \\bigcup_{a\u2208A\\setminus E}{\u00aca} is inconsistent.\nA counterclaim is a formula that prohibits the choice of an argument unless it is false, meaning that the counterclaim is not true. Note that arguments with \u22a4 counterclaims could also be accepted, as long as the extension's combined counterclaims vanish (are invalidated)."}, {"title": "3.1 Simulating Frameworks", "content": "To understand RCFs and their expressivity, we simulate AFs [18] and CAFs [16]. Therefore, we require a notation with only reasonable overhead.\nDefinition 8. Let F \u2208 {AF, CAF} be an argumentation formalism. Then, we say that RCFs simulate F, in symbols RCFs > F, if for every semantics \u03c3 \u2208 S and for every framework F \u2208 F, there is an RCF F' such that Ext\u03c3(F) \\setminus {\u00d8} = Ext\u03c3(F') and F' can be constructed in polynomial time. We write \u226f if the relation is strict.\nClearly, RCFs \u2267 AFs, e.g., by setting the RCs to false.\nObservation 9. RCFs \u2267 AFs.\nLater, we will see in Thm. 16 that unless NP = \u03a3_{2}^{P}, RCFs > AFs. Moreover, for an RCF G = (A, R, C') and AF F = (A, R), it is easy to observe that Ext\u03c3(G) \u2286 Ext\u03c3(F)\\setminus{\u00d8} for each \u03c3 \u2208 S. The converse does not hold (see Example 7). By definition, the following relation between semantics manifests for RCFs.\nObservation 10. Given an RCF G, then Ext_{stab}(G) \u2286 Ext_{semiSt}(G) \u2286 Ext_{pref}(G) \u2286 Ext_{comp}(G) \u2286 Ext_{adm}(G) \u2286 Ext_{conf}(G) and Ext_{stab}(G) \u2286 Ext_{stag}(G) \u2286 Ext_{conf}(G).\nComparison to CAFs. We briefly recall CAFs [16]. A CAF is a triple CF := (A, R, \u03a6) where (A, R) is an AF and \u03a6 is a propositional formula over A. For E \u2286 A, the completion of E is \u00ca = E\u222a{\u00aca | a \u2208 A\\setminus E}.\nLet E \u2286 A, then E is CF-admissible if E is admissible for (A, R) and \u00ca \u22a8 \u03a6, CF-preferred if E is maximal for set-inclusion among the CF-admissible sets, and CF-stable if E is conflict-free, \u00ca \u22a8 \u03a6 and attacks all"}, {"title": "4 How Hard is Rejection?", "content": "In this section, we study the hardness of rejection. Interestingly, already the use of auxiliary variables makes the problem significantly harder.\nTheorem 16. The problem cons_{conf} is \u03a3_{2}^{P}-complete, for simple (i = 1), propositional/tight (i = 2), and disjunctive (i = 3) RCs.\nProof (Idea). Membership: It suffices to nondeterministically guess a conflict-free set E and then evaluate C(E) \u222a E directly. The evaluation of C(E) \u222a E is done in polynomial time (case simple) that can be processed directly yielding NP, in NP-time (case propositional/tight) yielding \u03a3_{2}^{P}, and in \u03a3_{2}^{P}-time (case disjunctive) yielding membership in \u03a3_{2}^{P}.\nNext, we show hardness. \"propositional\": Reduce from \u03a3_{2}^{P}-QSAT, where for any Q = \u2203X.\u2200Y.\u03c6(X, Y) with \u03c6 being in 3-DNF; assume only terms over both X and Y. Then, we construct the following RCF G := (X \u222a X', R, C) (see Example 18): R := {(x, x'), (x',x)) | x \u2208 X}, C(v) := {\u00acc | c \u2208 \u03c6, v \u2208 var(c)} for v = x with x \u2208 X, and v = x' with x' \u2208 X'. Clearly, Q is valid iff cons_{conf}(G)\u2260\u00d8.\n\"simple\": Reduce from SAT, where we let \u03c6 to be any CNF with X = var(\u03c6). Assume for a variable x and a set X of variables that x' is the \u201ccopy\u201d of x. Construct the RCF G := (X \u222a X'\u222a {v_{c} | c \u2208 \u03c6}, R, C):\nR := {(x, x'), (x',x)) | x \u2208 X }, C(x) := {v_{c} \u2192 \u00acc | c \u2208 \u03c6, x \u2208 var(c)} for v = x with x \u2208 X, and v = x' with x' \u2208 X'. Show that \u03c6 is satisfiable iff G has a conflict-free extension.\n\"tight\": Reduce from \u03a3_{2}^{P}-QSAT, where for any Q = \u2203X.\u2200Y.\u03c6(X, Y) with \u03c6 in DNF, assume only terms over both X and Y. Then, construct the RCF G := (X \u222a X', R,C): R := {(x,x'), (x',x)) | x \u2208 X}, C(a) := {y \u2190 \u00acy', y' \u2190 \u00acy, \u2190 B | c\u2208\u03c6, B = \\bigcup_{\u00acx\u2208c\u2229X} X' \u222a \\bigcup_{y\u2208c\u2229var(c)\u2229Y} y, a \u2208 var(B), y \u2208 var(c) \u2229Y} for a \u2208 X\u222aX'. Thus Q is valid iff G has a conflict-free extension.\n\"disjunctive\": We reduce from \u03a0_{3}^{P}-QSAT, where for any Q = \u2203X.\u2200Y.\u2203Z.\u03c6(X, Y, Z) with \u03c6 in CNF, we assume only terms over X and Y. We let RCF G := (X \u222a X', R,C): R := {(x,x'), (x',x)) | x \u2208 X}, C(a) := {y \u2190 \u00acy', y' \u2190 \u00acy, z\u2228z' \u2190, z \u2190 s, z' \u2190 s, \u2190 \u00acs, s \u2190 B \\setminus c \u2208 \u03c6, B = \\bigcup_{\u00acx\u2208c\u2229X} X \u222a \\bigcup_{y\u2208c\u2229var(c)\u2229Y} Y', a \u2208 var(B), z \u2208 var(c) \u2229 Z, y \u2208 var(c) \u2229 Y} for a \u2208 X\u222a X'. Q is valid iff cons_{conf}(G)\u2260\u00d8.\nConsequently, hardness follows for semantics with conditions stronger than conflict-freeness."}, {"title": "4.1 Tight Complexity Bounds for Treewidth", "content": "To avoid this high complexity, we consider treewidth, which has been used to efficiently solve argumenta-tion [36]. First, we define a graph representation.\nDefinition 21. Let G = (A, R, C) be an RCF and let (V_{a}, E_{a}) = G_{C(a)} be given for every a \u2208 A. Then, the primal graph GG of G is defined by G_{G} := (\\bigcup_{a\u2208a} V_{a} \u222a A, \\bigcup_{a\u2208a} E_{a} \u222a R \u222a {{a, v} | a \u2208 A, c \u2208 C(a), v \u2208 var(c)}."}, {"title": "5 Conclusion and Future Work", "content": "We study flexible rejecting conditions (RCs) in abstract argumentation, which provide more fine-grained conditions to commonly studied rejection such as maximality. It allows for scenarios where we are interested in not accepting certain arguments in combination with others. We establish under which situations rejection is harder than its counterpart of acceptance conditions. We provide valuable insights into the differences and interactions between rejection and acceptance in general, which by itself improves the understanding of abstract argumentation. In fact, we present a detailed analysis of expressiveness and complexity when RCs consist of propositional formulas or ASP programs. Table 1 gives an overview of our complexity results. Our results show that rejection gives rise to natural problems for the third and fourth levels of the polynomial hierarchy.\nIt is notable that the higher expressivity and complexity for RCFs can be attributed to the shift from \"acceptance\" to \"rejection\". Furthermore, although our results on simulating CAFs with RCFs utilize additional variables, this generalization is not the primary source of complexity increase. This can be observed by noting that extending CAFs with auxiliary variables does not alter their reasoning complexity. The high-level idea is that CAFs model a formalism according to \"Exists Extension, Exists Assignment\", whereas our concept based on rejection follows the pattern \"Exists Extensions, Forall Assignments\", which makes RCFs more expressive (assuming P \u2260 NP).\nInvestigations of RCFs with additional semantics and RCs are interesting for future work. For example, for RCs with nonground programs of fixed arity, we expect complexity results up to the fifth level of the polynomial hierarchy. We are also interested in implementing RCFs and comparing their performance with AF solvers [36]. There are also meta-frameworks for treewidth, e.g. [14, 31], which are relevant for the implementation of RCFs using treewidth.\nImproving the modeling with a stronger language (ASP) is not only natural, but also necessary for certain properties, based on standard assumptions in complexity theory. While we understand that some"}]}