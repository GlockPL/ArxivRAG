{"title": "Rejection in Abstract Argumentation: Harder Than Acceptance?", "authors": ["Johannes K. Fichte", "Markus Hecher", "Yasir Mahmood", "Arne Meier"], "abstract": "Abstract argumentation is a popular toolkit for modeling, evaluating, and comparing arguments. Relationships between arguments are specified in argumentation frameworks (AFs), and conditions are placed on sets (extensions) of arguments that allow AFs to be evaluated. For more expressiveness, AFs are augmented with acceptance conditions on directly interacting arguments or a constraint on the admissible sets of arguments, resulting in dialectic frameworks or constrained argumentation frameworks. In this paper, we consider flexible conditions for rejecting an argument from an extension, which we call rejection conditions (RCs). On the technical level, we associate each argument with a specific logic program. We analyze the resulting complexity, including the structural parameter treewidth. Rejection AFs are highly expressive, giving rise to natural problems on higher levels of the polynomial hierarchy.", "sections": [{"title": "Introduction", "content": "Argumentation is a popular area of AI [3, 40]. An important computational framework, also known as abstract argumentation is Dung's argumentation framework (AF) [18]. AFs are widely used for modeling, evaluating, and comparing arguments. The semantics is based on sets of arguments that satisfy certain conditions such as being admissible, stable, or preferred. Such sets of arguments are then called extensions of a framework.\nOver time, various weaknesses of the somewhat simple modeling of arguments via AFs have been dictated, followed by proposed extensions, thereby providing another layer of \"acceptance\" conditions for arguments. For instance, Constrained Argumentation Frameworks (CAFs) [16] or Abstract Dialectical Frameworks (ADFs) [12]. But what happens, if we are interested in rejecting conditions? Some semantics implicitly define the concept of rejection by (subset-)maximality conditions, e.g., preferred or stage semantics. However, real-life is more complicated and goes beyond simple maximization (see Example 6). In this paper, we extend argumentation frameworks by flexible concepts of rejection. Since in knowledge representation (KR) global constraints are oftentimes expressed by means of propositional logic, we pursue our line of work in this direction. Naturally, we attach logical formulas to arguments, which is common in argumentation [12, 16, 32]. The models of these formulas form counterclaims to arguments being accepted. As a result the presence of such counterclaims forms the concept of rejection in AFs, which we call rejection framework (RCF). Interestingly, under reasonable complexity-theoretic assumptions, it turns out that it is harder to express rejection than acceptance. Indeed, compared to other approaches to model acceptance (e.g., CAFs), the concept of rejection increases computational hardness by one level already when we allow auxiliary variables. To express even harder rejection constraints, we study the case where CCs can be represented as the models (answer sets) of a logic program [29], since ASP is commonly used for argumentation [28]. Specifically, we associate each argument a with a logical program as its rejection condition (RC). When computing extensions, these RCs must be altogether invalidated and thus no longer counter-attack their arguments. This results in a compact and natural representation of rejection in AFs. Further, we depict via an example (Ex. 6) a scenario where such rejection conditions can not be modeled in AFs without losing the extensions."}, {"title": "Preliminaries", "content": "We assume familiarity with complexity [39], graph theory [9], and logic [6]. For a set X, we denote X' := { x' | x \u2208 X }.\nAbstract Argumentation. We use Dung's AF [18] and consider only non-empty and finite sets of arguments A. An (argumentation) framework (AF) is a directed graph F = (A, R) where A is a set of arguments and R \u2286 A \u00d7 A a pair of arguments representing direct attacks of arguments. An argument s \u2208"}, {"title": "Rejection Augmented AFs (RCFs)", "content": "Next, we provide a definition for the syntax and semantics of rejection conditions in abstract argumenta- tion frameworks.\nDefinition 4. A rejection augmented AF (RCF) is a triple G = (A, R, C) where (1.) (A, R) is an AF, and (2.) C : A \u2192 I is a labeling, called rejection conditions (RCs), that maps every argument in the framework to a constraint P \u2208 I where I is a set of ASP programs.\nFor brevity, we lift, for a set E \u2286 A of arguments, the RCs of E to C(E) := \u222ae\u2208E C(e).\nWe say that C is propositional, if I is a set of CNF formulas instead of programs. We say C is simple if var(C(A)) = A and C is propositional. If C(A) is a tight or normal program, C is called tight or normal, respectively; otherwise C is disjunctive.\nSemantics. For an argumentation semantics, we naturally extend the notion to an extension for RCFS G = (A, R, C). Intuitively, the mapping C gives rise to a program/formula that specifies the RCs for each argument. Ultimately, RCs of an extension must be invalidated.\nDefinition 5. Let G = (A, R, C) be a RCF and \u03c3 \u2208 S. Then, E \u2286 A is a \u03c3-extension (of G) if E \u2208 Ext\u03c3(A, R) and C(E) \u222a E \u222a \u222aa\u2208A\\E {\u00aca} is inconsistent.\nA counterclaim is a formula that prohibits the choice of an argument unless it is false, meaning that the counterclaim is not true. Note that arguments with \\top counterclaims could also be accepted, as long as the extension's combined counterclaims vanish (are invalidated)."}, {"title": "Simulating Frameworks", "content": "To understand RCFs and their expressivity, we simulate AFs [18] and CAFs [16]. Therefore, we require a notation with only reasonable overhead.\nDefinition 8. Let F \u2208 {AF, CAF} be an argumentation formalism. Then, we say that RCFs simulate F, in symbols RCFs \u2265 F, if for every semantics \u03c3 \u2208 S and for every framework F \u2208 F, there is an RCF F' such that Ext\u03c3(F) \\ {\u2205} = Ext\u03c3(F') and F' can be constructed in polynomial time. We write > if the relation is strict.\nClearly, RCFs \u2265 AFs, e.g., by setting the RCs to false.\nObservation 9. RCFs \u226f AFs.\nLater, we will see in Thm. 16 that unless NP = \u03a3P, RCFs > AFs. Moreover, for an RCF G = (A, R, C) and AF F = (A, R), it is easy to observe that Ext\u03c3(G) \u2286 Ext\u03c3(F) \\ {\u2205} for each \u03c3 \u2208 S. The converse does not hold (see Example 7). By definition, the following relation between semantics manifests for RCFs.\nObservation 10. Given an RCF G, then Extstab(G) \u2286 ExtsemiSt(G) \u2286 Extpref (G) \u2286 Extcomp(G) \u2286 Extadm(G) \u2286 Extconf(G) and Extstab(G) \u2286 Extstag(G) \u2286 Extconf(G).\nComparison to CAFs. We briefly recall CAFs [16]. A CAF is a triple CF := (A, R, \u03a6) where (A, R) is an AF and \u03a6 is a propositional formula over A. For E \u2286 A, the completion of E is \\hat{E} = E \u222a {\u00aca | a \u2208 A \\ E}. Let E \u2286 A, then E is CF-admissible if E is admissible for (A, R) and \\hat{E} |= \u03a6, CF-preferred if E is maximal for set-inclusion among the CF-admissible sets, and CF-stable if E is conflict-free, \\hat{E} |= \u03a6 and attacks all"}, {"title": "How Hard is Rejection?", "content": "In this section, we study the hardness of rejection. Interestingly, already the use of auxiliary variables makes the problem significantly harder.\nTheorem 16. The problem consconf is \u03a3P2-complete, for simple (i = 1), propositional/tight (i = 2), and disjunctive (i = 3) RCs.\nProof (Idea). Membership: It suffices to nondeterministically guess a conflict-free set E and then evaluate C(E) \u222a E directly. The evaluation of C(E) \u222a E is done in polynomial time (case simple) that can be processed directly yielding NP, in NP-time (case propositional/tight) yielding \u03a3P2, and in \u03a3P2-time (case disjunctive) yielding membership in \u03a3P2.\nNext we show hardness. \"propositional\": Reduce from \u03a3P2-QSAT, where for any Q = \u2203X.\u2200Y.\u03c6(X, Y) with \u03c6 being in 3-DNF; assume only terms over both X and Y. Then, we construct the following RCF G := (X \u222a X', R, C) (see Example 18): R := {(x, x'), (x', x)) | x \u2208 X}, C(v) := {\u00acc | c \u2208 \u03c6, v \u2208 var(c)} for v = x with x \u2208 X, and v = x' with x' \u2208 X'. Clearly, Q is valid iff consconf(G) \u2260 \u2205.\n\"simple\": Reduce from SAT, where we let \u03c6 be any CNF with X = var(\u03c6). Assume for a variable x and a set X of variables that x' is the \u201ccopy\u201d of x. Construct the RCF G := (X \u222a X' \u222a {vc | c \u2208 \u03c6}, R, C): R := {(x, x'), (x', x)) | x \u2208 X }, C(x) := {vc \u2192 \u00acc | c \u2208 \u03c6, x \u2208 var(c)} for v = x with x \u2208 X, and v = x' with x' \u2208 X'. Show that \u03c6 is satisfiable iff G has a conflict-free extension.\n\"tight\": Reduce from \u03a3P2-QSAT, where for any Q = \u2203X.\u2200Y.\u03c6(X, Y) with \u03c6 in DNF, assume only terms over both X and Y. Then, construct the RCF G := (X \u222a X', R, C): R := {(x, x'), (x', x)) | x \u2208 X}, C(a) := {y \u2190 \u00acy', y' \u2190 \u00acy, \u2190 B | c \u2208 \u03c6, B = \u222a\u00acx\u2208c X' \u222a \u222ay\u2208c \u2229 var(c) Y, a \u2208 var(B), y \u2208 var(c) \u2229 Y} for a \u2208 X \u222a X'. Thus Q is valid iff G has a conflict-free extension.\n\"disjunctive\": We reduce from \u03a3P3-QSAT, where for any Q = \u2203X.\u2200Y.\u2203Z.\u03c6(X, Y, Z) with \u03c6 in CNF, we assume only terms over X and Y. We let RCF G := (X \u222a X', R, C): R := {(x, x'), (x', x)) | x \u2208 X}, C(a) := {y \u2190 \u00acy', y' \u2190 \u00acy, z \u2228 z' \u2190, z \u2190 s, z' \u2190 s, \u2190 \u00acs, s \u2190 B | c \u2208 \u03c6, B = \u222a\u00acx\u2208c X \u222a \u222ay\u2208c \u2229 var(c) Y', a \u2208 var(B), z \u2208 var(c) \u2229 Z, y \u2208 var(c) \u2229 Y} for a \u2208 X \u222a X'. Q is valid iff consconf(G) \u2260 \u2205.\nConsequently, hardness follows for semantics with conditions stronger than conflict-freeness."}, {"title": "Tight Complexity Bounds for Treewidth", "content": "To avoid this high complexity, we consider treewidth, which has been used to efficiently solve argumenta- tion [36]. First, we define a graph representation.\nDefinition 21. Let G = (A, R, C) be an RCF and let (Va, Ea) = GC(a) be given for every a \u2208 A. Then, the primal graph GG of G is defined by GG := (\u222aa\u2208A Va \u222a A, \u222aa\u2208A Ea \u222a R \u222a {{a, v} | a \u2208 A, c \u2208 C(a), v \u2208 var(c)}."}]}