{"title": "Community-Aware Temporal Walks: Parameter-Free Representation Learning on Continuous-Time Dynamic Graphs", "authors": ["He Yu", "Jing Liu"], "abstract": "Dynamic graph representation learning plays a crucial role in understanding evolving behaviors. However, existing methods often struggle with flexibility, adaptability, and the preservation of temporal and structural dynamics. To address these issues, we propose Community-aware Temporal Walks (CTWalks), a novel framework for representation learning on continuous-time dynamic graphs. CTWalks integrates three key components: a community-based parameter-free temporal walk sampling mechanism, an anonymization strategy enriched with community labels, and an encoding process that leverages continuous temporal dynamics modeled via ordinary differential equations (ODEs). This design enables precise modeling of both intra- and inter-community interactions, offering a fine-grained representation of evolving temporal patterns in continuous-time dynamic graphs. CTWalks theoretically overcomes locality bias in walks and establishes its connection to matrix factorization. Experiments on benchmark datasets demonstrate that CTWalks outperforms established methods in temporal link prediction tasks, achieving higher accuracy while maintaining robustness. The implementation of our proposed method is publicly available at https://github.com/leonyuhe/CTWalks.", "sections": [{"title": "1 Introduction", "content": "Continuous-Time Dynamic Graphs (CTDGs) [1-4] provide a comprehensive framework for modeling temporal interactions in real-world systems. By representing entities and their time-stamped interactions as nodes and edges, CTDGs capture the evolving dynamics of diverse systems, including social networks, biological processes, knowledge graphs, and recommendation platforms [5-9]. Among the myriad tasks supported by CTDGs, temporal link prediction [10,11] -predicting future interactions based on historical data-stands out as a fundamental problem. Success in this task not only enhances our understanding of dynamic systems but also drives practical applications such as personalized recommendations and anomaly detection. Despite significant advancements in dynamic graph representation learning [12-14], existing methods face three critical challenges that limit their flexibility, adaptability, and expressiveness."}, {"title": "3 Preliminaries", "content": "Definition 1: Continuous-Time Dynamic Graph. A continuous-time dynamic graph G is represented as a sequence of non-decreasing chronological interactions:\nG = {((u1, v1), t1), ((u2, v2), t2),...}, 0 \u2264 t\u2081 \u2264t2 <... (1)\nHere, each pair (ui, vi) represents an undirected link between nodes ui and vi, with a corresponding timestamp ti.\nDefinition 2: Temporal Link Prediction. Temporal link prediction is the task of predicting whether an interaction between two nodes will occur at a specific time, based on historical interactions in the graph. Given the set of historical"}, {"title": "4 The Proposed Method: CTWalks", "content": "CTWalks comprises three key components: sampling, anonymization, and encoding. The complete notation system used throughout CTWalks is detailed in Appendix A, while the algorithm's computational complexity is analyzed in Appendix C.3."}, {"title": "4.1 Sampling", "content": "Weighted Temporal Graph Construction. We propose an innovative method for community detection in CTDGs by introducing the concept of a weighted temporal graph Gw, which is derived from the input CTDG G. The set of nodes in Gw includes all nodes appeared in G, and the edge weights Wuv in Gw encode the frequency of interactions between nodes u and v, defined as:\nWuv = \u03a3 I(u, v), (6)\n(u,v,t)\u2208G\nwhere I is an indicator function counting occurrences of (u, v) in G. This transformation aggregates temporal interactions into a static graph while retaining the structural essence of the CTDG, thereby enabling efficient processing and community detection. By applying modularity optimization algorithms, such as Louvain [38,39], on Gw, the graph is partitioned into k communities C = {C1, C2,..., Ck}."}, {"title": "Sampling Strategy", "content": "To effectively capture the temporal and structural patterns in G, nodes are categorized based on their roles within the community structure:\n\u2022 Non-Bridging Nodes: Nodes confined within a single community Ci. Their temporal walks are restricted to the neighbors within the intra-community subgraph Gc\n\u2022 Bridging Nodes: Nodes that connect multiple communities. Their temporal walks are restricted to the neighbors within the inter-community subgraph G1, ensuring transitions only occur between bridging nodes.\nAt each step of a temporal walk, the next node u is sampled based on its temporal relationship with the current node v under the constraint t' < t, where t is the current timestamp. The transition probability is defined as:\nP(u,t'|v,t) =  e\u2212(t\u2212t')\u03a3u'\u2208Nvalid(v) e\u2212(t\u2212t')  ,(7)\nwhere:\n\u2022 Nvalid (v) represents the valid neighbor set of v, determined by its type:\n= \nFor non-bridging nodes v \u2208 VC\u2081, Nvalid(v) N(v) \u2229 Gc, where N(v) is the neighbor set of v.\n= \nFor bridging nodes v \u2208 VI, Nvalid (v) N(v) \u2229G1.\n\u2022 t' is the timestamp associated with the interaction be- tween v and u."}, {"title": "4.2 Anonymization", "content": "CTWalks replaces node identities with position-based representations while embedding both directionality and community context. For a temporal interaction ((u, v), ti), the anonymization process operates on nodes appearing in temporal walk sets originating from the source node u and target node v.\nCommunity- and Direction-Aware Representation. The anonymized representation for a node w, based on temporal walk sets from the source node u and target node v, integrates both directionality and the community labels of the root nodes. This is defined as:\nA(w; Su, Sv, Cu, Cv) = [A(w; Su)||Cu||A(w; Sv)||Cv],(8)\nwhere:\n\u2022 Su and Su are the sets of temporal walks originating from u and v, respectively.\n\u2022 A(w; Su) and A(w; S) aggregate w's position-based occurrence information across all walks in Su and Su, respectively.\n\u2022 Cu and Cv are the community labels of the root nodes u and v, directly appended to their respective anonymization vectors.\nAnonymized Walk Construction. For a single temporal walk W = {W1,W2,...,w} with ascending timestamps t1 < t2 < ... < t1, the anonymized walk representation is defined as:\nWanon = {(A(wi), ti) | i = 1, 2, . . ., l},(9)\nwhere A(wi) is the community- and direction-aware anonymized representation of node wi, incorporating information from the sets of temporal walks Su and Su, as well as the community labels Cu and Cr."}, {"title": "4.3 Encoding", "content": "The encoding mechanism in CTWalks processes anonymized temporal walks Wanon by combining continuous temporal evolution and instantaneous updates, while integrating community-aware information. This ensures the final state hi captures temporal, structural, and community-aware information for downstream tasks.\nThe process begins by initializing the cumulative hidden state h = 0. Before the first step, the instantaneous hidden state h1 is computed as:\nh1 = g(ho, A(w1)).(10)\nFor each subsequent step i (1 < i < l), the encoding alternates between:\n1. Continuous Integration: Update h\u2081 by integrating the temporal evolution function f(h, t) over [ti, ti+1]:\nhi =  \u222btt+1 f(hi,t) dt.(11)\n2. Instantaneous Update: Compute hi+1, incorporating h' and A(wi+1):\nhi+1 = g(hi, A(wi+1)).(12)\nWe define g and f as parameterized models, g updates instantaneous states, while f governs continuous temporal integration."}, {"title": "4.4 Extension for Attributed Graphs", "content": "To encode node and edge attributes, the encoding process can be extended by modifying the instantaneous update function g as follows:\nhi = g(hi-1, A(wi)||Xwi||Xei),(13)\nwhere:\n\u2022 Xw; represents the attributes of node wi,\n\u2022 Xe\u2081 represents the attributes of edge ei = {Wi\u22121, Wi},\n\u2022 || denotes the concatenation operation.\nIn this extended formulation, node attributes Xw\u2081 and edge attributes Xe, introduce additional context for real-world at- tributed dynamic graphs. Several methods [40-42] focus on community detection in attributed graphs, leveraging node at- tributes to improve accuracy. This extension enhances the model's flexibility and expressiveness, enabling it to capture not only the structural and temporal information but also the rich attributes associated with nodes and edges."}, {"title": "5 Theoretical Analysis", "content": "Dynamic graph sampling inherently involves both spatial structures and temporal sequences. To isolate the impact of temporal sequences and focus on spatial sampling, it is essential to establish an unbiased spatial sampling environment as a foundation. To this end, we analyze the potential biases introduced by traditional random walks on unweighted, undirected static graphs, which may limit their ability to comprehensively explore the graph structure. Furthermore, we examine whether a parameter-free walk strategy, guided by community partitions and distinguishing intra-community and inter- community transitions, can effectively address these biases.\nBy simplifying the problem to static graphs, we aim to eliminate the confounding effects of temporal dynamics and concentrate on evaluating the locality bias and the theoretical advantages of community-guided walks in an idealized spatial context."}, {"title": "Analysis 1: Overcoming Locality Bias", "content": "Let a traditional random walk generate a sequence {wo, W1, ..., WLw-1}, where wt \u2208 V. At step t + 1, the walk transitions to a neighbor of wt with probability 1/d(wt), where d(wt) is the degree of node wt. Let Puv denote the one-step transition probability from node u to v, defined as:\nPuv = (1/d(u), if (u, v) \u2208 \u0415,  0, otherwise.(14)\nSuppose wo = u and wt = v, where u, v \u2208 V and wo, W1, ..., Wt-1 \u2260 v. The probability that the walk starts at u and visits v for the first time at time t is given by:\nrtuv = \u03a3 Puvrjt\u22121 =  1d(u) \u03a3rjt\u22121, (15) where N(u) is the set of neighbors of node u. This equation shows that rtuv is the mean of the (t - 1)-step probabilities r\u00b9 over all neighbors of u. The reliance on all neighbors dilutes the transition probability towards distant nodes, reinforcing locality bias."}, {"title": "Lemma 1.", "content": "In CTWalks, let nodes u and v belong to two different communities, and u, v \u2208 V are bridging nodes. The probability that the walk starts from u and visits v for the first time at time t satisfies:\nrtuv >  1d(u) \u03a3rjt\u22121 (16) j\u2208N(u)\nwith equality when all neighbors of u are bridging nodes (N(u) = Ninter(u)).\nProof. Partition N(u) into two disjoint subsets:\n\u2022 Ninter(u) = N(u) \u2229 Vc, the set of inter-community neighbors (bridging nodes),\n\u2022 Nintra(u) = N(u)-Ninter(u), the set of intra-community neighbors.\nThe total probability of transitioning to neighbors of u can be expressed as:\n\u03a3rjv = \u03a3rjv + \u03a3rjv(17) j\u2208N(u) j\u2208Ninter (u) j\u2208Nintra (u)\nIn CTWalk, intra-community transitions cannot reach nodes in different communities. Thus, for any j \u2208 Nintra(u), rpt\u22121 jv = 0. The total probability simplifies to:\n\u03a3rjv = \u03a3rjt\u22121 (18) j\u2208N(u) j\u2208Ninter (u)\nThe transition probability run from u to v in CTWalks is:\nrtuv =  1|Ninter(u)| \u03a3rjt\u22121(19) j\u2208Ninter (u)\nSince |Ninter(u)| \u2264 d(u), it follows that:\n1 |Ninter(u)| \u2265  1 d(u).(20)\nSubstituting this into the Eq.(19) for rtuv, we obtain:\nrtuv =  1|Ninter(u)| \u03a3rjt\u22121 \u2265 1d(u) \u03a3rjt\u22121. (21)\nEquality holds when all neighbors of u are bridging nodes (N(u) = Ninter(u)).\nLemma 1 demonstrates that CTWalks reduces locality bias by prioritizing inter-community transitions for bridging nodes. Unlike traditional random walks, which distribute transition probabilities evenly among all neighbors, CTWalks separates intra- and inter-community contributions, enabling effective exploration of global structures.\nWe also theoretically establish the connection between CT- Walks and matrix factorization, details are provided in Ap- pendix F."}, {"title": "6 Experiments", "content": "6.1 Experimental Setting\nBaselines and Datasets. CTWalks is evaluated against six state-of-the-art baselines for continuous-time dynamic"}, {"title": "6.3 Ablation Study", "content": "We conducted an ablation study to evaluate the contributions of key components in CTWalks, with results presented in Table 3. The study involved systematically removing essential mechanisms to understand their impact on the performance of CTWalks.\nThe first three experiments assess the influence of the community-aware sampling mechanism. When the restrictions on intra-community and inter-community walks are removed, nodes are allowed to perform unrestricted temporal walks, with the selection of the next node determined by time-biased probabilities that prioritize temporally closer events. The resulting performance degradation across these variants underscores the significance of preserving community boundaries. This highlights the effectiveness of the proposed community-aware sampling strategy in capturing both local and global temporal dynamics. To further validate the advantages of community walks in enhancing network embedding learning, we conducted experiments on purely static graphs and compared against classical graph node embedding algorithms. Detailed analyses are provided in Appendix E.\nThe fourth experiment removes the use of community labels during the anonymized walk encoding. This change prevents the model from distinguishing between structurally similar walks based on their community context, reducing its ability to effectively generalize across different network structures."}, {"title": "7 Discussion and Conclusion", "content": "The effectiveness of our model relies heavily on modularity- based community detection methods, such as Louvain, which ties its performance to the quality of the initial community partitions. In networks with overlapping or poorly-defined communities, this dependency may hinder the efficacy of the community-aware sampling mechanism. To address this, fu- ture work could explore adaptive sampling techniques that dynamically refine community boundaries or integrate multi- scale community detection methods to enhance robustness.\nAdditionally, incorporating continuous temporal dynamics via ODE solvers poses scalability challenges for extremely large graphs. To address these issues, approximate solutions such as logarithmic normalization of time intervals and parallel batch processing (see Appendix C.2) have been employed to reduce computational overhead. Nonetheless, future re- search should prioritize the development of lightweight inte- gration techniques or hybrid approaches that strike a balance between computational efficiency and modeling fidelity.\nCTWalks represents a community-aware, parameter-free framework for representation learning on CTDGs. Unlike ex- isting methods, CTWalks simultaneously incorporates intra- and inter-community dynamics, enabling the effective mod- eling of mesoscopic structures within graphs. Our contri- butions span several dimensions: (1) a novel temporal walk sampling strategy that adaptively captures community-driven dynamics without requiring extensive parameter tuning, (2) an anonymized encoding process augmented with community labels for generalization, and (3) a continuous temporal integration mechanism to capture nuanced spatiotemporal depen- dencies. Experimental results on diverse datasets consistently demonstrate the superiority of CTWalks in both inductive and transductive tasks.\nThis work lays the groundwork for future research in dy- namic graph learning. Directions for future exploration in- clude designing scalable methods for handling larger and more complex CTDGs, developing robust community detec- tion mechanisms, and addressing challenges associated with data bias and ethical use in real-world applications. With its potential to generalize across domains, CTWalks represents a significant step forward in understanding and modeling the evolving dynamics of complex systems."}, {"title": "A Notations and Definitions", "content": ""}, {"title": "B Community Detection Algorithms", "content": "B.1 Louvain Method\nThe Louvain method [38, 39] is an efficient modularity optimization algorithm widely used for community detection in undi- rected weighted graphs. It operates in two iterative phases:\n1. Local Optimization Phase: Initially, each node is treated as a separate community. The algorithm iteratively moves nodes between neighboring communities to maximize the modularity gain AQ, defined as:\n\u0394Q =  \u03a3in+2kin2m \u2212(\u03a3tot+kin2m )2,(23)\nwhere \u2211in is the sum of edge weights within a community, kin and ktot are the total weights of edges connected to the node inside the community and in the entire graph, respectively, and m is the total edge weight in the graph.\n2. Community Aggregation Phase: Once no further modularity improvement is possible, each community is treated as a supernode, forming a new graph. The process is repeated until the modularity Q no longer improves significantly.\nThe Louvain method is highly scalable and effective, making it suitable for large-scale graphs."}, {"title": "B.2 Other Community Detection Algorithms", "content": "Several alternative community detection methods exist, each with unique strengths and weaknesses:\n\u2022 Spectral Clustering: Based on the eigenvectors of the graph Laplacian, this method identifies k communities.\nAdvantages: Effective for small-scale graphs and capable of capturing complex community structures.\nDisadvantages: Computationally expensive for large graphs.\n\u2022 Random Walk-Based Methods (e.g., Infomap): These minimize the description length of random walks to identify communities.\nAdvantages: Naturally handle weighted graphs and hierarchical community structures.\nDisadvantages: High computational resource requirements.\n\u2022 Label Propagation: Communities are formed through the iterative propagation and convergence of node labels.\nAdvantages: Simple and fast, well-suited for dynamic graphs.\nDisadvantages: Susceptible to local optima and instability.\n\u2022 Modularity Maximization: A family of algorithms that optimize modularity Q. The Louvain method is a prominent example.\n\u2022 Deep Learning-Based Methods: Algorithms like DeepWalk and Node2Vec learn node embeddings to capture community structures.\nAdvantages: Integrate node attributes and graph topology information.\nDisadvantages: Require significant computational resources and are sensitive to hyperparameters.\nIn our framework, the Louvain method is employed for community detection due to its efficiency and suitability for weighted graphs. This method provides a solid foundation for subsequent node community classification and boundary node detection. Future work may explore advanced algorithms tailored to dynamic weighted graphs for more accurate and robust community detection."}, {"title": "C Batching and Complexity Analysis", "content": "C.1 Function Definitions: g and f\nIn the CTWalks framework, two key functions, g and f, are defined to model discrete updates and continuous temporal evolu- tion, respectively. Their complementary roles enable precise representation of both instantaneous and time-dependent dynamics within continuous-time dynamic graphs.\n1. Instantaneous Update Function g The function g handles the discrete, step-wise state updates at specific nodes along a temporal walk. For each node wi, the hidden state hi is computed as:\nhi = g(hi-1, A(wi)),(24)\nwhere:\n\u2022 h\u2081 is the cumulative hidden state from the previous step.\n1\n\u2022 A(wi) is the anonymized representation of node wi.\n\u2022 g is instantiated as a Gated Recurrent Unit (GRU) [47], designed to capture both structural and temporal information.\nThe GRU-based formulation of g is given by:\nzt = \u03c3(Wzht-1 + Uzxt + bz),(25)\nrt = \u03c3(Wrht-1 + Urxt + br),(26)\nht = tanh(Wh(rt \u00a9 ht\u22121) + Uhxt + bh),(27)\nht = zt \u00a9 ht + (1 \u2212 zt) ht\u22121,(28)\nwhere:\n\u2022 zt, rt, and ht are the update gate, reset gate, and candidate hidden state, respectively.\n\u2022 xt = A(wi) represents the input node features.\n\u2022 \u03c3(\u00b7) and tanh(\u00b7) denote the sigmoid and hyperbolic tangent activation functions, respectively.\n\u2022 represents element-wise multiplication."}, {"title": "2. Continuous Temporal Evolution Function f", "content": "The function f models the continuous evolution of the hidden state over time intervals between nodes. Unlike g, which incorporates node-specific input features, f focuses solely on temporal dynamics and acts on the output of g. The cumulative hidden state h at step i is computed by integrating f over the time interval [ti, ti+1]:\nhi =  \u222btihi+1 f(hi,t) dt,(29)\nwhere:\n\u2022 hi is the instantaneous hidden state computed by g,\n\u2022 ti and ti+1 are the timestamps associated with the current and next nodes in the temporal walk,\n\u2022 f(h, t) is parameterized as a GRU-like model, similar to g, but without external inputs xt.\nThe formulation of f is as follows:\nzt = \u03c3(Wzht-1 + bz),(30)\nrt = \u03c3(Wrht-1 + br),(31)\nht = tanh(Wh(rt ht\u22121) + bh),(32)\nht = zt ht+ (1 \u2212 zt) ht\u22121,(33)\nwhere:\n\u2022 zt, rt, and ht are the update gate, reset gate, and candidate hidden state, respectively,\n\u2022 Wz, Wr, and Wh are weight matrices,\n\u2022 bz, br, and bh are biases,\n\u2022 \u03c3(\u00b7) and tanh(\u00b7) denote the sigmoid and hyperbolic tangent activation functions.\nBy removing external inputs xt, f focuses purely on modeling the temporal continuity of the hidden state, allowing it to integrate spatiotemporal dependencies over time intervals.\nTogether, g and f enable CTWalks to seamlessly integrate spatial and temporal dynamics, delivering a robust framework for learning representations on continuous-time dynamic graphs."}, {"title": "C.2 Batching Analysis", "content": "Efficiently encoding temporal walks poses a significant challenge due to the irregular timestamps and varying lengths of walks. For C temporal walks, each consisting of l steps, solving C \u00d7 l independent ordinary differential equations (ODEs) is computationally expensive. To address this, we employ a time reparameterization strategy, unifying the integration intervals of all walks into a standard range [0, 1]. This unification allows batch processing of the walks, enabling significant computational efficiency[48].\nReparameterization for Unified Time Intervals Consider the c-th walk with timestamps [tstart, tend], where tstart is the time of the first node in the walk, and tend is the time of the last node. We reparameterize the time t within this interval using a new variable s \u2208 [0, 1], defined as:\ns = tt\u2212tstarttend\u2212tstart thus, t = s.(tend - tstart) + tstart(34)\nUnder this transformation, the instantaneous hidden state ht at time t is reformulated as hs, such that:\nhs = ht = hs.(tand-start)+t start(35)\nThis allows all walks, regardless of their original time intervals, to operate within a common temporal scale of [0, 1].\nReformulated ODE for Batch Processing The cumulative hidden state for the c-th walk is computed by solving an ODE over the interval [tstart, tend]. After reparameterization, the ODE is reformulated for \u0127s as follows:\ndhdst = f(ht,t) = f(hs, s. (tend - tstart) + start) (tend - tstart),(36)\nwhere dtds = tend - tstart.\nThe initial and final states are transformed as:\nh0 = htstart,hend= htrend(37)\nThe solution for the cumulative hidden state at the end of the walk becomes:\nhtc = ODESolve(ho, f, start, tend) = ODESolve(ho, f, 0, 1).(38)\nHere, the reparameterized function f ensures that all walks are solved over a common interval, enabling efficient batch compu- tation."}, {"title": "Parallelism Across Walks", "content": "While each walk still involves step-wise computations within the reparameterized interval, the unification of time intervals to [0, 1] allows a single solver instance to process multiple walks in parallel. This is achieved by stacking the dynamics of all walks into a joint system:\ndhjointds =   f1(h1, s. \u0394t1 + tstart) \u00b7 \u0394t1f2(h2, s.\u0394t2 + t tart) \u00b7 \u0394t2 :LfC(hc, s. \u0394tc + tstart). \u0394tc\u300d,(39)\nwhere \u0394tc = tendt start. The solver processes this joint system, reducing the computational overhead from C independent solver calls to a single batched solver call.\nBatch Processing Efficiency For walks with l = 1, the reparameterization directly enables batch processing since the time interval for all walks is normalized to [0, 1]. However, for walks with l > 1, each step within the walk corresponds to a distinct interval, making true parallelism challenging. Solving multiple sub-intervals within each walk requires sequential processing. To fully enable parallel processing for l > 1, further strategies, such as normalizing intermediate step intervals or discretizing the ODE solutions, could be employed. These approaches remain an open area for further optimization.\nHandling Large Time Intervals In real-world scenarios, large time intervals Ate can cause numerical instability. To mitigate this, we normalize the intervals while preserving relative temporal differences using a logarithmic transformation:\n\u0394tscaled = log10(\u0394t + 1),(40)\nensuring that smaller intervals retain fine-grained dynamics while larger intervals are compressed to a manageable scale. This batching mechanism combines time reparameterization and joint ODE solving, significantly improving computa- tional efficiency and enabling scalable representation learning on dynamic graphs."}, {"title": "C.3 Complexity Analysis", "content": "We analyze the time complexity of the main components in CTWalks, including community detection, temporal walk sampling, anonymization, continuous evolution, and instantaneous updates. The detailed breakdown is as follows:\nCommunity Detection. Community detection is performed using a modularity-based algorithm, such as Louvain, which has a time complexity of O(|E|log n), where |E| is the number of edges and n is the number of nodes. This step is executed once as preprocessing.\nTemporal Walk Sampling. In each batch, BC walks are generated, where B is the batch size (number of root nodes) and C is the number of walks per root node. The sampling process involves l steps per walk, with each step querying neighbors at a complexity of O(ks), where ks is the average number of neighbors. The total complexity for temporal walk sampling is O(BCks).\nWalk Anonymization. For anonymization, each walk requires O(l) operations to identify unique nodes and assign positional encodings. Across BC walks, the total complexity becomes O(BCI).\nContinuous Evolution. Continuous evolution integrates the temporal evolution function over time intervals using an ODE solver, requiring F function evaluations per step. For BC walks with l steps, the total complexity is O(BClFd). Using the batch processing optimization introduced in Section B.1, this is reduced to O(lFd).\nInstantaneous Updates. The instantaneous updates compute the hidden state at each step using a parameterized function, resulting in a complexity of O(ld).\nSubtotal (Sampling and Anonymization).\nThe combined complexity for sampling and anonymization, including temporal walk sampling and walk anonymization, is:\nO(BC(ks +l)).(41)\nSubtotal (Encoding).\nThe combined complexity for continuous evolution and instantaneous updates is:\nO(lFd).(42)\nTotal Complexity. Combining all components, the total time complexity of CTWalks per epoch is:\nO(|E|log n) + O(BC(ks + l)) + O(lFd).(43)"}, {"title": "D Additional Experimental Details", "content": "D.1 Dataset Details and Preprocessing\nWe evaluate our method on five real-world datasets across diverse domains. The details are as follows:\n\u2022 UCI: Contains 1,899 nodes and 59,835 temporal edges, representing message interactions in a university social forum. No additional preprocessing is required.\u00b9\n\u2022 MOOC: Logs 7,145 nodes and 411,749 temporal edges, capturing student interactions with course units over one month.2\n\u2022 Enron: Includes 184 nodes and 125,235 temporal edges, recording email communications over several years.3\n\u2022 Taobao: Contains 987,994 nodes and 2,099,520 temporal edges, representing user-item interactions with encoded action types (e.g., clicks, purchases).4\n\u2022 Wikipedia: Bipartite graph with 9,227 nodes and 157,474 temporal edges, representing editor-page interactions encoded with LIWC features.5\nData Preprocessing: The following steps ensure consistency and facilitate evaluation:\n1. All temporal edges are sorted chronologically to maintain temporal consistency.\n2. Edges are split into training (70%), validation (15%), and testing (15%) sets.\n3. Negative sampling is performed to generate edges absent in the original graph, ensuring a balanced dataset.\nD.2 Baselines and Hyperparameter Tuning\nBaseline Methods: To evaluate the performance of our proposed method, we compare it with six state-of-the-art baselines specifically designed for continuous-time dynamic graphs (CTDGs):\n\u2022 CTDNE: CTDNE extends static network embedding techniques to CTDGs by leveraging temporal random walks and a skip-gram model to learn node representations. This method captures the temporal dependency of interactions.6\n\u2022 JODIE: JODIE employs two mutually influenced recurrent neural networks (RNNs) to update the latent states of interact- ing nodes. The model is capable of predicting future embedding trajectories based on past interactions.7\n\u2022 DyRep: DyRep integrates sequence modeling with an attentive message-passing mechanism, incorporating 2-hop tem- poral neighborhood information to produce time-aware embeddings. The loss function is built upon temporal point pro- cesses.8\n\u2022 TGAT: TGAT applies temporal encoding via random Fourier time encodings and attentively aggregates temporal neigh- borhood information to generate embeddings. The model supports multi-hop temporal message aggregation.9\n\u2022 TGN: TGN proposes a memory-based message-passing framework, which updates node memories dynamically while combining key designs from JODIE and TGAT to enhance its capability to model temporal interactions.10"}, {"title": "D.3 Implementation Details", "content": "Code Availability: Our implementation of CTWalks is publicly available at https://github.com/leonyuhe/CTWalks. The repository includes detailed instructions for dataset preparation, model training, and hyperparameter tuning.\nGeneral Training Settings: CTWalks is trained across all datasets using the following settings:\n\u2022 Optimizer: Adam with a learning rate of 10\u20134 and batch size of 32.\n\u2022 Early Stopping: Training stops if validation performance does not improve for three consecutive epochs.\n\u2022 Epoch Limit: Maximum 50 epochs.\nHyperparameter Tuning: To ensure optimal performance, key hyperparameters controlling walk sampling are tuned via grid search. The following summarizes the hyperparameter configurations for all datasets:\n\u2022 Walk Length (l): {1, 2, 3}\n\u2022 Number of Walks per Node (C): {16, 32, 64}\n\u2022 ODE Solver: Fixed-step Runge-Kutta 3/8 method with a step size of 0.125."}, {"title": "E Experiment on Purely Static Graphs", "content": "To further validate the benefits of community walks in enhancing network embedding learning, we conducted experiments on purely static graphs, focusing on the community structure without considering temporal information. Specifically, we ap- plied our method, CTWalks, which incorporates community walks to generate node sequences, and subsequently used the word2Vec [49] framework to generate embeddings from these sequences. By deliberately excluding temporal data and leverag- ing word2Vec, our approach aims to highlight the effectiveness of CTWalks in capturing community structures and achieving competitive performance on static graphs compared to classical graph embedding algorithms."}, {"title": "Experimental Setup", "content": "We evaluated CTWalks (CTW) against six widely recognized baseline methods: node2vec (N2V) [50], DeepWalk (DW) [51], LINE [52], Struc2Vec (S2V) [53], GraphSage (GS) [54], and M-NMF (MN) [55]. To ensure a fair comparison, the implemen- tations of these methods were obtained from publicly available repositories. Specifically, Node2vec, DeepWalk, and M-NMF were implemented using the Karate Club library12. The implementation of LINE was sourced from its official repository13. Similarly, Struc2Vec14 and GraphSage15 were obtained from their respective repositories. This approach ensured the use of standardized and well-maintained implementations for each baseline."}, {"title": "E.1 Results and Analysis", "content": "Link Prediction. The results of the link prediction task are presented in Table 9 (AUC) and Table 10 (AP). CTW consistently outperformed baseline methods across all datasets. Notably, CTW demonstrated significant improvements on datasets with strong community structures, such as soc-hamsterster and fb-pages-food. For instance:\n\u2022 On bio-WormNet-v3, CTW achieved an AUC of 0.9915, outperforming the second-best method, M-NMF, by 3.2%.\n\u2022 On ego-Facebook, CTW achieved an AP of 0.9891, showcasing robust performance in large-scale social networks.\n\u2022 On datasets with smaller community structures, such as aves-weaver-social, CTW achieved a notable improvement, with AUC gains of up to 5.1% over the best baseline."}, {"title": "F Theoretical Analysis", "content": "We interpret CTWalks from the perspective of matrix factorization. We demonstrate that the two-layer random walk process in CTWalks corresponds to a novel matrix factorization form, integrating intra- and inter-community dynamics through a hierarchical transition mechanism. These analyses highlight CTWalks' theoretical advantages in encoding community-aware structures, providing insights into its effectiveness in network representation learning."}, {"title": "Analysis 2: Matrix Factorization Perspective of CTWalks", "content": "The Skip-Gram with negative sampling (SGNS) framework [57] in network embedding methods such as DeepWalk [51] and node2vec [50] has been shown to implicitly factorize a pointwise mutual information (PMI) matrix [58,59]. CTWalks extends this perspective by incorporating a hierarchical, two-layer random walk that explicitly encodes both intra-community and inter- community transitions, resulting in a novel matrix factorization form.\nCTWalks Transition Matrices\nIn CTWalk, the probability of transitioning between two nodes during the random walk is governed by two distinct components: intra-community transitions (within communities) and inter-community transitions (across communities). To model this, we introduce two matrices: 1) a block-diagonal matrix M\u2081 \u2208 R|V|\u00d7|V| that represents transitions within individual communities, and 2) an extended matrix Mc \u2208 R|V|\u00d7|V| that captures transitions between communities via bridging nodes."}, {"title": "Intra-community transition matrix (M1).", "content": "The matrix M\u2081 represents the normalized intra-community transitions", "where": "n\u2022 Ai \u2208 R|Vi|\u00d7|"}]}