{"title": "Smart Cubing for Graph Search: A Comparative Study", "authors": ["Markus Kirchweger", "Hai Xia", "Tom\u00e1\u0161 Peitl", "Stefan Szeider"], "abstract": "Parallel solving via cube-and-conquer is a key method for scaling SAT solvers to hard in-stances. While cube-and-conquer has proven successful for pure SAT problems, notably thePythagorean triples conjecture, its application to SAT solvers extended with propagators presentsunique challenges, as these propagators learn constraints dynamically during the search.We study this problem using SAT Modulo Symmetries (SMS) as our primary test case, wherea symmetry-breaking propagator reduces the search space by learning constraints that eliminateisomorphic graphs. Through extensive experimentation comprising over 10,000 CPU hours, wesystematically evaluate different cube-and-conquer variants on three well-studied combinatorialproblems. Our methodology combines prerun phases to collect learned constraints, various cub-ing strategies, and parameter tuning via algorithm configuration and LLM-generated design sug-gestions.The comprehensive empirical evaluation provides new insights into effective cubing strate-gies for propagator-based SAT solving, with our best method achieving speedups of 2-3x fromimproved cubing and parameter tuning, providing an additional 1.5-2x improvement on harderinstances.", "sections": [{"title": "Introduction", "content": "Propositional satisfiability (SAT) solvers based on conflict-driven clause learning can solve hugeinstances with millions of variables and clauses [Fichte et al., 2023a]. However, for hard instances,particularly in combinatorial problems, parallelization becomes necessary. The cube-and-conquertechnique has proven highly effective for such problems, most notably in resolving the Pythagorean triples conjecture [Heule et al., 2016].In cube-and-conquer, a look-ahead solver first partitions the search space into disjoint sub-problems via cubes (partial assignments), which are then solved independently by CDCL solvers.This independence enables efficient parallel solving.When encoding combinatorial problems into SAT, particularly those involving graphs, we oftenencounter highly symmetric search spaces. Many mutually isomorphic graphs satisfy the sameconstraints, but a solver needs to check only one representative, the canonical element, from eachisomorphism class. Standard CDCL solvers cannot leverage these symmetries, and static symmetrybreaking methods cannot break all symmetries [Codish et al., 2019].SAT Modulo Symmetries (SMS) [Kirchweger and Szeider, 2021; Kirchweger and Szeider, 2024]addresses this limitation through dynamic symmetry breaking, using a custom propagator that learnssymmetry-breaking predicates during the search. SMS has been successfully applied to several"}, {"title": "Preliminaries", "content": "For a positive integer $n$, we write $[n] = \\{1,2,..., n\\}$. Below we review basics from propositionallogic and graph theory.SAT. A literal is a propositional variable $x$ or its negation $\\overline{x}$. A clause (cube) is a disjunction(conjunction) of literals. A CNF (DNF) formula is a conjunction (disjunction) of clauses (cubes).We sometimes interpret clauses/cubes as sets of literals and CNF (DNF) formulas as sets of clauses(cubes). For a clause (cube) $C$, the cube (clause) $\\{ x | x \\in C\\}$ is denoted by $\\overline{C}$. We writewrite $var(x) = var(\\overline{x}) := x$ for the variable of a literal, $var(C) = \\{ var(x) | x \\in C$ for a clause/cube $C$,and $var(F) = \\bigcup_{C\\in F} var(C)$ for a CNF/DNF formula $F$. An assignment to a set of variables $V$ isa mapping $\\tau : V \\rightarrow \\{0, 1\\}$, and is extended to literals by $\\tau(\\overline{x}) = 1-\\tau(x)$. An assignment $\\tau$ satisfies aclause $C$ if it maps at least one of its literals to 1. An assignment to $var(F)$ that satisfies every clauseof $F$ is called a satisfying assignment or a model. The set of models of a formula $F$ is denotedby $mod(F)$. If $mod(F) \\neq \\emptyset$ we say that $F$ is satisfiable, otherwise it is unsatisfiable. If every"}, {"title": "SAT Modulo Symmetries (SMS)", "content": "Modern propositional satisfiability (SAT) solvers are primarily based on conflict-driven clause learn-ing (CDCL) [Fichte et al., 2023b; Marques-Silva et al., 2021]. CDCL is a backtracking exhaustive search algorithm which decides the satisfiability of an input CNF as follows. In a loop, a CDCLsolver runs unit propagation until fixpoint (all forced assignments), then picks a variable to branchon when there is nothing left to propagate, and learns new clauses from conflicts obtained throughunit propagation when they occur (when both $x$ and $\\neg x$ is forced). When a model is found, the solver reports it; when it learns the empty clause, it reports unsatisfiability.SMS is a framework that augments a CDCL SAT solver\u00b2 with a custom propagator that canreason about graph isomorphisms (symmetries), allowing the SAT solver to search modulo isomor-phisms for graphs with a given number $n$ of vertices and which satisfy constraints specified by apropositional formula. The SMS propagator is a routine which checks whether the currently ex-plored branch of the search tree contains a canonical graph. A canonical graph is a distinguishedmember of its isomorphism class-in SMS, it is the isomorphic copy with a lexicographically min-imal adjacency matrix, where matrices are compared as row-wise concatenated vectors: the vectorof $\\begin{pmatrix}0 \\1 \\0 \\0\\end{pmatrix}$ is $\\begin{pmatrix}0100\\end{pmatrix}$. This routine is thus referred to as the minimality check. The minimality checkis called by the CDCL solver after unit propagation reaches fixpoint, and can trigger an additional conflict on top of ordinary CDCL and consequently learn a symmetry-breaking clause, which is aclause that excludes non-canonical graphs.In order for SMS to check minimality, a graph from the current partial assignment of the CDCLsolver has to be constructed. This is done by looking at the values of the specially designated edgevariables, which, by convention, are the first $\\binom{n}{2}$ variables of the formula (when searching for graphswith $n$ vertices; the value $n$ must be passed to SMS). These variables map to the upper triangle ofthe adjacency matrix in row-major order $\\begin{pmatrix}1\\2\\4\\3\\5\\6\\end{pmatrix}$ and from their assignment one can extract apartially defined graph, which is a graph in which the presence of some edges is unknown (whose"}, {"title": "Cube-and-Conquer", "content": "Assume that a hard CNF formula $F$ is to be solved by a SAT solver, and let $x$ be a variable of $F$.Consider the formulas $F[x]$ and $F[\\overline{x}]$ where $x$ is assigned true or false, respectively. Clearly, $F$ issatisfiable if, and only if, at least one of $F[x]$ and $F[\\overline{x}]$ is satisfiable. Therefore, instead of solving $F$,one can solve $F[x]$ and $F[\\overline{x}]$, the point being that these sub-problems can be solved in parallel, andwill hopefully be easier to solve than the original formula $F$. This reasoning applies equally forenumeration problems: in order to enumerate the models of $F$, one can separately enumerate themodels of $F[x]$ and $F[\\overline{x}]$, and take the union of the two.This basic splitting idea can, of course, be applied recursively: by re-splitting the sub-problem$F[\\overline{x}]$ we obtain the collection of sub-problems $F[x], F[x, y]$, and $F[x, \\overline{y}]$. In general, given an inputformula $F$, and a DNF tautology $\\Gamma = C_1 \\vee \\cdots \\vee C_r$ over (some of) the variables of $F$, the setof models of $F$ is obtained as $mod(F) = \\bigcup_{i=1}^r mod (F[C_i])$. The $C_i$ are called cubes, and themethod that solves $F$ by designing a suitable cube set $\\Gamma$ to divide into sub-problems and solvingeach sub-problem separately (typically in parallel) is called cube-and-conquer [Heule et al., 2016;Heule et al., 2018].Note that $\\Gamma$ does not have to be a tautology. For satisfiability checking in ordinary SAT (noSMS or other special propagators), it is sufficient that $F \\wedge \\Gamma$ is equisatisfiable to $F$. In our context,we add symmetry-breaking clauses on the fly, and we enumerate models instead of just checkingsatisfiability. We thus must require preservation of all models, i.e., that $F \\models \\Gamma$, or, equivalently, that$F \\wedge \\overline{\\Gamma}$ is unsatisfiable.A fundamental optimization problem emerges: how to find a good splitter $\\Gamma$ in order to optimize solve (conquer) performance? The standard answer to this question is look-ahead solving. A look-ahead solver constructs a branching tree whose nodes are variables. At every node, the solver tries assigning each as yet unassigned variable in both possible ways and performs the associated formula reduction (repeated removal of falsified literals and satisfied clauses followed by unit propagation).It then collects information about the reduced formula in each branch into a numerical value andcombines both values into a variable score using a scoring function. The goal of the scoring functionis to produce a single number on which all variables can be compared, which reflects both the totalamount of reduction resulting from the two assignments as well as how balanced the reduction isbetween the two branches. The variable that scores highest on this aggregate score is picked asthe next branching variable, and two subproblems are created, on which the solver can be calledrecursively until a cutoff threshold is reached (typically specified as the number of variables to beassigned in total)."}, {"title": "Cubing with SMS", "content": "The main contribution of this paper is the design and experimental evaluation of various cube-and-conquer pipelines for SMS. We start with an encoder that produces a propositional CNF $F$. Intraditional cube-and-conquer, one would start cubing $F$ directly, but in our scenario, this wouldresult in poor performance. Instead, we start with the prerun phase, in which $F$ is enriched withadditional clauses to obtain a formula $F^*$.During the prerun, we run SMS, i.e., CaDiCaL and its attached propagators, for a boundedamount of time. The point of this prerun phase is to improve the performance of the cubing phaseby collecting a set $\\Sigma$ of symmetry-breaking clauses, a set $\\Pi$ of propagator clauses as well as a set $\\Lambda$of important learned clauses from CDCL. The most important learned clauses for $\\Lambda$ are unit clauses,but we also store and reuse learned clauses with up to 5 literals. We may find models during prerun;we simply store them and block in $F^*$. The enriched formula $F^*$ is obtained as $F \\wedge \\Sigma \\wedge \\Lambda \\wedge \\Pi \\wedge \\Lambda$.After the prerun, we save the enriched CNF $F^*$ and pass it on to the cuber. The cuber producesa set $\\Gamma$ of cubes to be solved by the final-phase solver.The final solver is the same one as the one used for the prerun, up to the configuration of param-eters.Within this general framework, we evaluate a number of possible choices for each of the com-ponents and for the ways the components interact."}, {"title": "Prerun", "content": "For prerun, we always run CaDiCaL with SMS, and with a suitable domain-specific propagatoras necessary for a benchmark problem (see Section 6 for details on the benchmark problems andpropagators). When the prerun phase is followed by a cubing phase that uses CaDiCaL, the solver simply switches from prerun to cubing mode, and continues to run, preserving all learned clausesand any other acquired state. When cubing is done externally, the solver dumps $\\Sigma$, $\\Pi$, and $\\Lambda$ into afile and stops."}, {"title": "Cuber", "content": "For the cubing component, we evaluate several different methods:CDCL with a cutoff. In this method, we continue running SMS as in prerun, but whenever thenumber of assigned edge variables reaches a predefined threshold, we collect all assigned edge literals, output them as a cube, and add the negation as an irredundant learned clause. Thus, thegeneration of cubes blindly follows whatever path the CDCL solver takes. This method has beenfruitfully employed in previous applications of SMS [Kirchweger et al., 2023a]. When using thismethod, we run SMS only once: after the amount of time given for prerun has elapsed, the solver simply switches to cubing mode and continues to run. Note that this also means that the resulting cubes highly depend on the solver state at the end of prerun, meaning that different runs can resultin very different cubes. The process can be depicted in this diagram."}, {"title": "Conquering solver", "content": "For the final solver, we take CaDiCaL again, but this time we configure its parameters with the state-of-the-art automatic algorithm configuration tool SMAC [Lindauer et al., 2022]. The final solver is thus the same one as used for prerun, up to possibly changed search strategies. However, there aremore than 100 various adjustable strategies according to the exposed parameter list of CaDiCaL,and it is quite challenging to configure them together. Therefore, we first run a sensitivity analysis toidentify promising parameters for configuring: we switch each parameter individually to an extremevalue and compare the changed configuration to the default configuration on a set of cubes sampled"}, {"title": "Benchmark Problems and Encoding", "content": "In this section, we introduce the graph search problems and present encodings on which we evaluate our methods. For most problems, we only sketch the encoding and refer to the original source, as our main focus is on comparing the solving approaches. See Section 7 for a link to generator scripts and details of the formulas.Our benchmark set consists of three different problems. In the first two cases (Subsections 6.1 and 6.2), the problems cannot be efficiently encoded into propositional logic, and external propaga-tors (already implemented and available in the SMS library) are required. For these two problems, we describe what the propagator does. The last problem (Subsection 6.3) is encoded fully in propo-sitional logic.On top of the individual encoding (and propagators if necessary) for each problem, we also use incomplete static symmetry breaking constraints proposed by Codish et al. [[2019]]. These con-straints are compatible with SMS in the sense that they are satisfied by the lexicographically minimalgraph, but they are incomplete because they are satisfied by non-minimal graphs as well. We use these constraints to increase the amount of information about graph minimality in the formula (inaddition to symmetry-breaking clauses found during the prerun phase)."}, {"title": "Coloring Triangle-Free Graphs", "content": "A proper $k$-coloring of a graph $G$ is a mapping $c : V(G) \\rightarrow \\{1, ...,k\\}$ such that $uv \\in E(G)$implies $c(u) \\neq c(v)$. The chromatic number of a graph $G$ is the smallest integer $k$, for which aproper $k$-coloring exists. If a graph contains a complete subgraph on $k$ vertices, then its chromaticnumber must clearly be at least $k$. The opposite is not true: Mycielski [[1955]] explicitly constructed triangle-free graphs (without triangle subgraphs) with unbounded chromatic number. Erd\u0151s [1967]asked about the values $f(k)$, which denote the smallest number of vertices in a triangle-free non-$(k-1)$-colorable graph. Mycielski's construction provides upper bounds on $f(k)$, and these aretight up to $k = 4$; for $k = 5$, minimal graphs are also known [Goedgebeur, 2020], but none of themis a Mycielskian. The cases $k \\geq 6$ are open."}, {"title": "Kochen-Specker Graphs", "content": "Kochen-Specker (KS) vector systems are special sets of vectors in at least 3-dimensional space thatform the basis of the Bell-Kochen-Specker Theorem, demonstrating quantum mechanics' conflictwith classical models due to contextuality [Budroni et al., 2022]. Kochen and Specker [[1967]]originally came up with a 3D KS vector system of size 117. The smallest known system (in 3D)has 31 vectors [Peres, 1991], while the best lower bound is 24 [Kirchweger et al., 2023a; Li et al., 2024]. These lower bounds were obtained with computer search for KS candidate graphs: non-010-colorable graphs with additional restrictions. A graph is 010-colorable if its vertices can be coloredred and blue such that no two adjacent vertices are both red and no triangle is all blue."}, {"title": "Diameter-2-Critical Graphs", "content": "The diameter of a graph $G$ is the largest distance between a pair of vertices in $G$, where the distanceof two vertices is the length of a shortest path between them. A disconnected graph has diameter$\\infty$.A graph is diameter-$d$-critical if its diameter is $d$ and deletion of any edge increases the diameter.The study of extremal properties of graphs with prescribed diameter was initiated by Erd\u0151s andR\u00e9nyi [1962] and has been the subject of intensive research. An important topic in the field isthe characterization of diameter-$d$-critical graphs [Chen and F\u00fcredi, 2005; Haynes et al., 2015;Loh and Ma, 2016]; in particular the case $d = 2$. The Murty-Simon Conjecture [Caccetta andH\u00e4ggkvist, 1979] states that for a diameter-2-critical graph with $n$ vertices and $m$ edges, $m \\leq\\lfloor n^2/4 \\rfloor$, with equality attained only by the complete bipartite graph $K_{\\lfloor n/2\\rfloor,\\lceil n/2\\rceil}$ (the related classictheorem of Mantel [[1907]] postulates the same for $C_3$-free graphs).Using Nauty [McKay and Piperno, 2014], Radosavljevi\u0107 and \u017divkovi\u0107 [[2020]] computed alldiameter-2-critical graphs with up to 10 vertices. Dailly et al. [[2019]] reported on a \u201ccomputersearch\" for graphs with up to 11 vertices, focusing on graphs with a certain number of edges. Kirch-weger and Szeider [[2024]] enumerated all diameter-2-critical graphs up to 13 vertices with SMS.We use the SAT encoding from this last work\u2014a CNF formula $D2(n, m)$ which is satisfiableif and only if there is a diameter-2-critical graph $G$ with $n$ vertices and $m$ edges. By a theorem ofFan [[1987]], the bound holds for all diameter-2-critical graphs with up to 24 vertices. We therefore set $m = \\lfloor n^2/4 \\rfloor$ to enumerate diamater-2-critical graphs that attain equality."}, {"title": "Results", "content": "In this section, we will present the technical details of our experiments and the results. The over-arching goal is to minimize the time taken for the entire pipeline, from encoding to obtaining thesolutions. However, since the entire setup is quite complicated, we decided to simplify some aspects.We optimize the cubing and the conquering solver separately from each other. For each bench-mark problem, we create a training and a test instance. The training instance is an easier instanceof the problem with a smaller number of vertices, and the test instance is a harder instance with one more vertex. While this might not sound like a big step, the search space generally grows exponen-tially in the number of edges, so roughly like $exp(\\Omega(n^2))$. We want to note that for our selectedcombinatorial problems, the increment of the number of vertices from $n$ to $n + 1$ typically makes the problem by orders of magnitude harder. Sometimes, in these problems, the solution is knownfor a particular $n$ but not for $n + 1$ so far. For Kochen-Specker and triangle-free graphs, we train on21 and test on 22 vertices; for the Murty-Simon conjecture, we train on 15 and test on 16 vertices.Details on how to produce the encodings and cubes can be found in the supplementary material."}, {"title": "SMS Configuration", "content": "Let us for a moment fix the cubing component at the beginning of the default cuber CDCL. Ourgoal is to optimize the search strategies of the conquering solver. We first list all parameters ofCaDiCaL, and pick those that are relevant to solver performance. We run a sensitivity analysis foreach parameter. This means we take the default configuration, and for each parameter, we toggle itto a different value. In the case of numerical parameters, we change the value to the extreme endof the admissible range. We evaluate each thus obtained configuration on the set of cubes producedwith the default cuber on each of the three training instances. With this, we identify a set of 10parameters that seem promising for further automated tuning with SMAC. Along with the other two parameters for SMS itself (\u2018frequency' and 'cutoff'), the total 12 parameters are listed in thesupplementary material."}, {"title": "Configuration of \u03c3", "content": "We optimize the scoring function $\\sigma$ through an iterative process using GPT-01. As explained inSection 5, starting with the default function, we run five rounds where GPT-01 is asked to gen-erate four variant scoring functions of the current performing one. The new functions are thenevaluated by solving the cubes (generated by the full-variable look-ahead with the new functions)with the CaDiCaL with default configurations. This process yields specialized scoring functions foreach benchmark problem whose intricate balance of terms defies intuitive human interpretation, yetdemonstrates improved performance, as shown in the below. Finally, we pick the best-performing scoring functions among training instances for testing instances (harder instances), here are the topthree.$\\sigma_{ks}(a, b) = 8 min(a, b) + 2 \\frac{min(a, b)}{max(a, b) + 1} + a + b$$\\sigma_{te}(a, b) = min(a, b) + 10 \\frac{min(a, b)}{max(a,b)+1}$$\\sigma_{smc}(a,b) = ab + a + b$."}, {"title": "Test performance", "content": "We compare different pipelines on the total solving time for all cubes, or in other words on the timethat it would take to solve all cubes on a single processor. Since cubes are typically to be solved inparallel, we also report the time taken to solve the hardest cube for each pipeline, but this is not themain metric. This information is shown in Table 2, for all cubers and for Def and Tun, on the test instances.In Figure 2 we show more detailed information about the distribution of running times over individual cubes. For each benchmark problem we show 4 plots: the rows differ in the cuber, thecolumns differ in the conquering solver. We compare default and best cuber, and also default and bestconfiguration of CaDiCaL. The plots show the total running time for cubes, grouped by individual"}, {"title": "Conclusion", "content": "Our experimental evaluation of cube-and-conquer pipelines with SMS revealed several key insights.March_cu emerged as the best-performing cuber in our setup for handling propagator-generated clauses, effectively balancing global search coverage with local constraint propagation. Our runtimeanalysis showed that harder instances benefit disproportionately from parameter tuning, suggestingdefault solver heuristics may be suboptimal for specialized subproblems. This relationship betweencube characteristics and solving strategies merits further investigation.Several promising directions emerge from these findings. First, applying our LLM-guided scor-ing optimization to march_cu could yield additional improvements. Second, while march_cu gener-ates well-balanced subproblems, our analysis suggests potential for specialized splitting strategiesthat account for propagator behavior. Finally, our success with automatic configuration raises inter-esting questions about parameter space structure, as the preliminary analysis indicates cube clustersthat might benefit from targeted approaches. Our methodology demonstrates how carefully handlingdynamically learned constraints can substantially improve parallel SAT-solving performance."}]}