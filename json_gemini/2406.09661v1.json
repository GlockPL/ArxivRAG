{"title": "Temporal Planning via Interval Logic Satisfiability for Autonomous Systems", "authors": ["Miquel Ramirez", "Anubhav Singh", "Peter J. Stuckey", "Chris Manzie"], "abstract": "Abstract-Many automated planning methods and formulations rely on suitably designed abstractions or simplifications of the constrained dynamics associated with agents to attain computational scalability. We consider formulations of temporal planning where intervals are associated with both action and fluent atoms, and relations between these are given as sentences in Allen's Interval Logic. We propose a notion of planning graphs that can account for complex concurrency relations between actions and fluents as a Constraint Programming (CP) model. We test an implementation of our algorithm on a state-of-the-art framework for CP and compare it with PDDL 2.1 planners that capture plans requiring complex concurrent interactions between agents. We demonstrate our algorithm outperforms existing PDDL 2.1 planners in the case studies. Still, scalability remains challenging when plans must comply with intricate concurrent interactions and the sequencing of actions.", "sections": [{"title": "I. INTRODUCTION", "content": "Temporal planning is an optimization problem where solutions are given by sets of actions, or plans, which need to be chosen in such a way that certain requirements are met. Actions abstract the set of possible behaviours that are available to steer a given dynamical system. We distinguish three types of requirements on actions. The first is that of suitability and relevance of an action to bring about some task or goal. For instance, we may need to transport cargo between locations, using as efficiently as possible a given set of automated vehicles. Actions that move vehicles between locations are relevant as long as a vehicle has been tasked with running cargo between those locations. Other actions that abstract the handling of cargo become relevant as well for the same reason. The second requirement is that of sequencing, where there are restrictions on the ordering of the temporal extent of an action. For instance, the actions for handling cargo and moving the vehicle need to be ordered in causally and temporally consistent way. The action to move the vehicle cannot temporally overlap with cargo handling activities, and clearly loading cargo at the source must happen before unloading it at the destination. The third and last requirement is that of concurrency, in which some action in a plan requires some formal property of vehicle or other entities \"states\u201d (a fluent)"}, {"title": "A. Related Work", "content": "Our work belongs to the line of inquiry into temporal planning that decomposes the problem into a causal reasoning task over suitably defined knowledge graphs [10], to identify what actions are present in the plan, and a numerical optimization task over (disjunctions of) linear constraints, that define the set of valid schedules for the chosen actions. Early work focused on directly applying Blum and Furst planning graphs in temporal settings [11], [12], [13]. The atemporal, partially-ordered plans that result from reachability analysis are then mapped onto a temporal constraint satisfaction problem (TCSP). The resulting TCSP can then be solved off-the-shelf with standard Optimization and Satisfiability technology for scheduling problems [14]. The flow of information between the procedures for reachability analysis in planning graphs search and solving TCSPs is limited in these early approaches. This issue is compounded by the inability of Blum and Furst planning graphs, designed for the STRIPS assumptions on action structure, to capture plans with non-trivial concurrent interactions between actions [12], [15].\nResearch split into three major approaches in response: Heuristic Search methods that hybridize approximate dynamic programming, using heuristics for reachability analysis over relaxed planning graphs [16], and consistency checking of TCSPs [17], [18], [19], Constraint Programming (CP) algorithms [20] that integrate planning graph analysis into constraint propagation and backtracking search, and Satisfiability Modulo Theory (SMT) approaches [21], [22], [23], [24], [25] that propose their own or use off-the-shelf lazy or eager versions of the DPLL(T) algorithm for SMT [26]. In these, the satisfiability of a Boolean theory in Conjunctive Normal Form (CNF) captures Blum and Furst reachability analysis [27], and sub-theories, usually linear arithmetic over the rationals or the integers, are used to represent the TCSPs that follow from selecting actions in plans. All of the above provides integrated reasoning over planning graphs and TCSPs, tackling some limitations of early decomposition approaches.\nNotable works that rely on formulations of temporal planning distinct from the ones above include timeline-based planners [3] such as NASA's EUROPA [28], or more recently, the work led by A. Bit-Monnot [4]. All of these approaches use expressive temporal logic [29] to represent and reason over properties of plans and rely on Optimization or SMT technology. Still, they struggle to scale up as \"larger\" plans are required to solve instances, and their ability to capture complex concurrent interactions is limited. Our ideas to represent complex temporal structures are inspired by this line of research while taking note of lessons learned from existing research into action-centric PDDL 2.1 formulations of temporal planning. Also reliant on Allen's are works is the work on the representation and analysis of plans defined over timelines [30], [31]. We acknowledge the novelty of the timeline-based representations discussed in these papers with respect with to earlier works discussed above, based on the same representation paradigm. We note that our approach formulates key concepts such as frame axioms in a very different manner as these works, and we are focus on the problem of synthesizing plans from given specifications, rather than assuming that the plan is obtained from an oracle and analyzing whether certain properties hold throughout their execution."}, {"title": "B. Contributions", "content": "This paper proposes a novel formulation of temporal planning that is aligned and consistent with the theoretical foundations and established engineering practices [9] to design and analyze dynamical systems like those in Figure 1. Our formulation relies on discrete timelines. This ensures that the resulting optimization problem is a decidable one [32], yet intractable in general, so the challenge lies in proposing algorithms that scale up. We assume that the minimum duration of any time period considered in a plan matches that of the control cycle set for the control system. We propose a novel notion of planning graphs, encoded as a CP model, that results from the synthesis of Van den Briel et al. [33] Integer Programming formulation of classical planning, and Allen's Interval Logic. Crucially, our notion of planning graphs, or rather, timing diagrams [34], overcome the long-standing limitations [12] of Blum & Furst's seminal approach to express concurrent interactions between the preconditions and effects of actions in the plan."}, {"title": "II. BACKGROUND", "content": "Allen's Interval Logic (IL) [35], [29] is a temporal logic whose atoms follow from pairing two classes of abstract objects pieces of time, or intervals, and Boolean predicates. The latter are atoms in some decidable first-order theory [36] we will refer to as domain theory, and we denote by T. Theories T are given by a signature \u2211 that specifies constant, predicate and function symbols, and their axioms, sets of closed well-formed first-order formulas which only use symbols in \u2211 and standard logical connectives. The domain theory signature is augmented, if necessary, with the signature of the Theory of the Integers Tz, with standard interpretation [36, Chapter 3]. Along with a domain theory T we will also consider a finite"}, {"title": "1) Syntax and Semantics:", "content": "An IL sentence \u03c6 is a quantifier-free first-order formula that includes both TQAs and atoms of predicates in Table I, which we will refer to as temporal constraints, using variables in V and constants in \u2211 to denote the bounds of intervals in T. IL formulas are interpreted over some subset I of half-open intervals in T, and a history h: T\u00d7 \u03a6\u2192 {T, \u22a5} [39, Chapter 3], where \u03a6 = Atoms(\u03a3). We say that the interpretation given by pairing set I with history h satisfies an IL formula \u03c6, denoted by I, h |= \u03c6, when\nI, h |= \u03c61 \u2227 \u03c62, iff I, h |= \u03c61 and I, h |= \u03c62\nI, h |= \u03c61 \u2228 \u03c82, iff I, h |= \u03c61, or I, h |= \u03c62, or both\nI, h |= @X iff h(t, \u03c6)\u2192 T, for all t \u2208 X\nI, h |= X ~ Y iff rX = lY\nI, h |= X < Y, iff rX < lY\nI, h |= X > Y, iff lX > rY\nI, h |=X \u2283 Y, iff lX < lY, rY < rX\nI, h |= X \u2191 Y, iff lX = lY and rX < rY\nI, h |=X \u2193 Y, iff rX = rY and lX < lY\nI, h |= X = Y, iff lX = lY and rX = rY\nI, h |=X ) Y, iff lX < lY, lY < rX and rX < rY\nI, h |= @X \u2283 @Y, iff I, h |= @X, I, h |= @Y,\nI, h |= X \\ Y"}, {"title": "B. Motion Description Languages", "content": "We now introduce the notion of Motion Description Language (MDL) following the presentation due to Egerstedt [5] for the most part, and we note below the changes we propose. Given a finite set, or alphabet, A, we define a generic sequence by a = a1 a2 ... am, which can be interpreted as partial"}, {"title": "C. Supervisory Control", "content": "In order to address systems with more than one actor, we propose two modest changes to Egerstedt's system model [5]. First, we introduce the notion of a controller function g : Y \u00d7 A \u2192 U that is defined as g(y,a) = \u03ba\u03b1(\u03b6, \u03bc\u03b1) where \u03ba\u03b1 and \u03bc\u03b1 are the closed-loop and open-loop components of skill a. Secondly, we have a explicit component that acts as"}, {"title": "III. THEORIES OF TEMPORAL PLANNING", "content": "In this section we describe a framework to interpret a planning problem as that of determining the satisfiability of an Interval Logic theory, such as the ones described in section II-A. We will denote the theory whose models describe the structure of plans and their executions by Tp. We also observe that these theories do not exist in a vacuum, but rather are suitable abstractions of other, more complex theories, which we denote by Ts, or system theories. Section II-B introduces the signature and some of the axioms that define such theories. We note that more general and expressive theories can be built for complex control systems, but for the purposes of this paper we think that Egerstedt's framework strikes the right balance between being rigorous enough to justify our modeling choices when describing Tp, and being sufficiently flexible to account for robotic systems of real-world interest. Clearly, for any given system S and theory Ts, many planning theories Tp are possible, all related by several common components and differing on choices of axioms or some elements of their signature. Hence, what follows is best understood as a collection of axiom and symbol schemata [36], that are instantiated as it best suits to account for the particular characteristics of Ts."}, {"title": "A. Assumptions", "content": "We start by introducing some assumptions on the structure of Egerstedt's MDL framework, which will facilitate our discussion. We start defining the duration of skills a\nAssumption 1: We will assume that \u03b4(\u03b1) is always finite and furthermore, \u03b4(\u03b1) \u2208 Z+ for all a \u2208 A.\nBy adopting the above all the intervals I will have positive and finite size |I|. It does also imply that the plans for Tp will be conservative when it comes to quantify the efficiency of plans with respect to their makespan [14], and that skill control functions \u03ba\u03b1 will steer S to states where \u03bea is true in finite time.\nEgerstedt's framework does not interrogate the structure of skill triggers \u03be\u03b1. We observe that it is commonly the case that triggers are defined by combining simpler Boolean functions, that are used by several skills a. We formalize this observation with the following\nAssumption 2: Let a \u2208 A be a skill in a MDL alphabet, with trigger \u03be\u03b1. We assume that \u03bea is as follows\n$\\xi_{\\alpha}(Y) = \\prod_{i=1}^{n_{\\alpha}} \\Phi_i(y), \\Phi_i(y) = [y \\in Y_{\\phi}], \\Phi \\epsilon \\Phi_A$\nThat is, each trigger \u03bea is the product of n\u03b1 > 0 Boolean functions \u03a6 \u0395 \u03a6\u0391, which we will refer to as fluents, and are defined to be the Iverson bracket [42] for the property that output y belongs to set Y \u2282 Y. We note that the sets Yo need not be disjoint.\nThe third assumption we make is the alphabet A is partitioned in the following way\nAssumption 3: Let A an MDL alphabet. We assume that there exist subsets of A, Ap and Ae, that satisfy the following conditions: (1) A = Ap \u222a Ae, (2) Ap \u2229 Ae = 0, and (3) for every a \u2208 Ap it holds that \u03bc\u03b1 = 0 and \u03ba\u03b1(y, u) = 0 for all y \u2208 Y and u\u2208 U.\nThe above condition establishes two types of skills, those belonging to Ap, one whose purpose is to monitor the evolution of system outputs over time until \u0121 evaluates to 1, and those belonging to Ae, which actually provide input into the system dynamics steering them towards states in which & evaluates to 1. We will refer to the former set as precondition timers, and we denote their elements by p, while we refer to the latter set as effect delays, which we denote with the letter e.\nThe fourth and final assumption places restrictions on the structure of control strings in Ls\nAssumption 4: Let Ls be MDL for system S. We assume that (1) \u20ac \u00a3 Ls and (2) that for every a \u2208 Ls, a(1) \u2208 Ap.\nThe above introduces the almost universal assumption in the planning literature that actions in plans are defined in terms of a precondition and one or more effects, where the first skill in every control string essentially \"waits for\" trigger \u00a71 to become true. Doing so becomes very useful to account for periods of time an agent must be idle while waiting for other agents to accomplish some task [43], or coasting between two equilibrium points of its dynamics [44] as part of the execution of some maneuver. We note that any MDL Ls can be easily mapped into another language L's that satisfies Assumption 4."}, {"title": "B. Signature", "content": "Temporal planning theories Tp are Interval Logic theories, hence they inherit the non-logical symbols introduced in"}, {"title": "C. Connecting Planning and System Theories", "content": "We now make the satisfiability of TPN and Ts to be connected by means of the following two axioms, which use the symbols in the signature of TP,N UTS\n$\\phi(t) = 1 \\leftrightarrow (\\phi@I \\land l_I < t < r_I)$\n$a_j(t) = a \\leftrightarrow (a_j@I \\land l_I < t < r_I)$\nBy introducing the two logical equivalences above, a corre-spondence between the models of TPN and Ts is established trivially, as it is easy to see that by forcing the truth values of the left-hand sides the rest of functions and variables in Ts become all uniquely determined. From the above it is trivial to see that there is a bijection between system output functions y \u2208 YR and histories h (see section II-A). We assume that there exists at least one such function y that satisfies the system theory Ts dynamic constraints discussed in sections II-B and II-\u0421.\nThe intuitive interpretation for the above is that the planner component, which is tasked with finding satisifying assignments for TP,N that in turn encode plans, is able to choose what events and temporal evolutions occur. Plan existence thus is proof of, from the point of view of Control Theory, weak controllability as in the possibility of steering the controlled system to the set of desired terminal states, rather than certifiying the certainty of a plan execution doing so. Such a global liveness property is known as controllability in Control Theory and an example analysis for a special type of MDL languages can be found in the work of Emilio Frazzoli et al. on the Maneuver Automata framework [44]. We next describe the three types of axioms to be found on theories TP,N."}, {"title": "D. Type I Axioms: Actions", "content": "The first set of axioms we consider address the relation (if any) between skills a \u2208 A being executed, that is, axiom (11) holding for some actor j at time t, and changes in the values assigned by Boolean functions \u03a6 \u20ac \u03a6\u0391 to system outputs y(t) \u2208 Y, that is, axiom (10) truth changing between two time instants t and t' where t < t'. These axioms are not universal, as applying to every system S, but depend on the suitability of the MDL alphabet to a wide variety of control systems, such as wheeled robots or other human-designed vehicles [44]."}, {"title": "F. Type III Axioms: Temporal Structures", "content": "The third set of axioms describe temporal structures that must be satisfied by all assignments to fluent and action TQA symbols. In contrast with actions and domain constraints, these axioms are universal to all planning theories TP,N. Time intervals in fluent TQAs must cover dateline intervals It (see section III-B) and correspond to a partition each of these into two distinct, non-overlapping sub-intervals. This property is formalised by requiring that for every fluent symbol \u03c6 and intervals I\u03c6,0,t, I\u03c6,1,t in SP,N, the following holds\n$(I_{\\phi,0,t} \\sim I_{\\phi,1,t}) \\land (I_{\\phi,0,t} \\uparrow I_t) \\land (I_{\\phi,1,t} \\downarrow I_t)$\nTime intervals in action TQAs must also cover the dateline intervals, but do so from the \u201coutside\u201d as in aggregating several of them where each Ia,k is\n$I_{a,k} := \\cup_{l_{a,k}<t<r_{a,k}} I_t$\nlak and rak above are integer constants with domain [1, N] that define the interval Iak (see section II-A). The size of intervals I \u2208 KPN are subject to constraints on their size I. Intervals Ia,k where a \u2208 Ap must be satisfy the condition that Ia,k\u2265 1, while intervals Ia',k where a' \u2208 Ae must in turn satisfy |Ia,k| = \u03b4(\u03b1\u0384). We note that the constraints above for intervals I\u03c6,0,t, I\u03c6,1,t, and Ia,k are trivial consequences of Allen's Homogeneity Axiom (3). To wit, for every IL sentence \u03a6 using TQAs @I there is a finite\u00b3 number of equisatisfiable IL sentences \u03a6' where each occurrence of @I is replaced by\n$\\stackrel{n}{\\land} @I_i \\stackrel{n-1}{\\land}(I_1 \\sim I_{i+1}) \\land I_1 \\uparrow I \\land I_n \\downarrow I$\nImportantly, intervals I and I are arbitrarily chosen con-stants, and we require the following\n$I \\sim I_1...I_n \\sim I$\nfrom dateline intervals I1, In \u2208 DP,N. Associated with in-tervals I and I we have initial and terminal conditions \u03a6\u03bf, \u0424. \u0421 \u03a6\u0391, so for each \u03c6 \u2208 \u03a6\u03bf and \u03c6' \u0395 \u03a6 the following must be true\n$\\stackrel{}{\\triangle} \\phi@I_< \\land \\stackrel{}{\\triangle} \\phi\\prime@I>$"}, {"title": "G. Plan Existence and Satisfiability", "content": "With the signature and axioms of TP,N we can now discuss its satisfiability. The latter is contingent on the existence of plans, objects with the following structure\nDefinition 2: Let TQAP,N be the set of TQAs for a theory TP, N. A plan is a partial function \u03c0 : TQAP,N \u2192 BXZ+XZ+ so, given TQA \u03c81 then \u03c0(\u03c81) = (b,l,r) where b is a Boolean value that gives the truth value of of fluent or atom 4, and l and r are non-negative integers that define l\u2081 and r1. We say that a TQA 41 is in the plan if and only if \u03c0(\u03c81) is defined. We will denote by IPN the set of all objects that satisfy the Definition above. TP,N is thus satisfiable if there"}, {"title": "IV. SATISFIABILITY OF TEMPORAL PLANNING THEORIES VIA CONSTRAINT PROGRAMMING", "content": "We now give algorithms for (1) determining the least value for the parameter N so that TPN is satisfiable, and (2) to determine whether a theory TP,N is satisfiable, via an encoding into Constraint Programming[46], [14], [26], or CP for short. As observed in section III-B in order to articulate the notion of plan, it is required first to make a commitment on the \u201csize\u201d of the set of candidate plans to consider. While one aspect of this size parameter is fixed by defining fluent F and action A predicate, the number N of \"moments in time\" or \"stages\" in the dateline structure of the plan [39] to consider is not given and needs to be calculated. We search for the value of parameter N in the framework of planning as SAT [27], by considering a sequence of theories TP,N\u2081, TP, N2,..., TP, Nk, defined as covered in section III. For each theory TP, Ne we check if there exists some plan \u03c0\u2208 \u03a0\u03a1,N\u2081\u2082 that satisfies all theory axioms and constraints, and stop as soon as we found one such plan. It is easy to see that this algorithm is complete provided that there exists a satisfiable theory TPN where N > 0 and finite. Several algorithms have been proposed to accelerate this basic linear search procedure [47], [48], at the expense of accepting parameters Nk larger than strictly necessary, and we do not claim any specific contribution in this regard.\nTo determine the satisfiability of theories TP,N, for some suitably chosen N, either directly or via a suitably defined search procedure, we give an encoding of TP,N into a CSP with variables and constraints supported by state-of-the-art Constraint Programming solvers, such as Google OR-Tools [49]. Importantly, the variables and constraints of the CSP are representations of the uninterpreted symbols and axioms of the theory TP,N chosen to maximize the performance of state-of-the-art CP solvers, rather than a direct compilation.\nLet us recall Definition 2 where plans are defined as partial functions that map TQAs in TPN into triples (b,l,r) of Boolean and integer values. The fact that not all TQAs may be part of a plan is a non-trivial complication that we address in different ways for fluent and action TQAs, each having associated several variables of the CSP that allow to choose which TQAs are in the plan and what values they have.\nFor each fluent \u03c6 \u2208 F and dateline index 1 \u2264 t \u2264 n we define Boolean variables \u03c6\u03c5\u03c9, where \u03c5,\u03c9 \u2208 {0,1}. These Boolean variables determine the structure of timing diagrams (see Figure 4) by asserting pairs TQAs\n$\\phi_{v0} = 1 \\leftrightarrow ((\\varphi)@I_{0t} \\land (\\neg \\varphi)@I_{1t}$\nIn words, setting \u0ed0 to 1 indicates that the o is false for the entirety of It. The pair of TQAs for 43 given in Figure 4 would be thus asserted by setting 43.01 = 43,10 = 1. The approach to choose action TQAs follows directly from (17)."}, {"title": "A. Flow Constraints", "content": "Changes of truth are regulated with flow constraints [33]\n$\\phi_v^{i0} + \\phi_v^{i1} = 1,   \\hspace{1cm} \\varphi \\in \\Phi_o$\n$\\phi_{0v} + \\phi_{00} = 1,   \\hspace{1cm} \\varphi \\epsilon \\Phi_o$\n$\\Sigma_{v \\epsilon \\{0,1\\}} \\phi^v_{tt} = 1,   \\hspace{1cm} \\Phi \\epsilon \\Phi$\n$\\gamma_{ow} + \\phi_{it} = \\gamma_{i+1}^t + \\varphi_{iw},   \\hspace{1cm} 1 < t < h$\nwhere w \u2208 {0,1}. Constraint (23d) requires continuity of truth values at the boundary of intervals It \u2208 DP,N, disallowing truth-value to change from 1 to 0. Changes in truth values are only allowed within intervals It and must be justified by an action TQA, as per the action axioms given in TP,N (section III-D)."}, {"title": "B. Precondition and Effect Constraints", "content": "Assumption 3 partitions the set of skills A into sets of pre-condition timers Ap and effect delays, Ae, while Assumption 4 places a restriction on the structure of the control strings in Ls. While we do not place any restrictions on the structure of action axioms (12), clearly not all possible combinations of temporal constraints are generally useful for control systems based on MDLs. For any given skill a \u2208 A, TCa can clearly only consist of constraints @I \u2283 aj@Io or aj@Io \u2227 \u03c6@I, as it can only be the case that (1) y(t) was true before a started and continues to do so until the trigger \u03be\u03b1 evaluates to true, or (2) \u03c6\u03bfy(t) is true for some time t after a has started."}, {"title": "C. Operational Constraints", "content": "Constraints (25a)-(25b) and (26a)-(26b) suffice to account for action axioms necessary to account for the dynamics of control systems in the MDL framework. Nevertheless, it is very common that one would like to consider only a subset of the set of plans that satisfy TP,N. For instance, it may be the case that not all plans are convenient or desirable given some contextual information that is not available as axioms of TP,N regardless of any loss of performance due to ruling out otherwise valid output functions y(t). One example for this is when system operators wants plans to comply with given structures, like those formalized as hierarchical task networks [50]. Another example is that of having two or more skills a1, a2,..., an that cannot be executed concurrently due to being desired that plans conform to some global resource constraint [23], [51], [52].\nA trivial case for skills being arranged according to some hierarhical structure are the concepts of temporal action present in representation frameworks such as PDDL 2.1 [1] or NDL [23]. Temporal actions simply aggregate skills in a sequential fashion. Let us extend the signature of TP,N with a finite set of uninterpreted symbols \u03c4\u2208 T, and consider additional axioms\n$\\tau@I  \\rightarrow \\stackrel{N}{\\triangle} a_i@I_i \\land I_1 \\uparrow I \\land I_n \\downarrow I \\land \\stackrel{n-1}{\\triangle} I_i \\sim I_{i+1}$$\nwhere I is an interval from KPN extended to accommodate TQAs for temporal actions \u03c4. These constraints are directly implemented by setting trivial constraints on CSP variables Ua,k, la,k and ra,k.\nHandling resource constraints on plans requires too to extend the signature of TP,N with uninterpreted logical symbols p\u2208 R, and extending SP,N accordingly. Rather than intro-ducing new axioms we extend action axioms, since resource constraints can be implemented with temporal constraints\nstart(a, k, t) \u2192 Pro > (It\u22121 ~ Ia,k) \u2227 |Ip,0,t| = 1\nends(a, k, t') \u2192 Pro(Ia,k ~ P10 It') \u2227 |Ip,1,t' | = 1\nspans(a, k,t,t') \u2192 pro\nNamely, the TQA for resource p is required to \"expand\" covering all the dateline intervals spanned by the action TQA. We also require the intervals I,0,t and I,1,t to span exactly 1 time unit. We note that to be consistent with the hybrid dynamics in (6c), the TQA for this effect must start on the first control cycle after the skill a starts being applied and finishing on the control cycle before a ceases to be active. As per the definition of MDL skills a, one or more functions \u03c6 will need to be observed to change from false to true for a execution to finish, hence why we allow for some minimum amount of time separation."}, {"title": "D. Frame and Interference Constraints", "content": "Frame axioms ensure that no atom \u03c6 changes truth value without proper justification, as per the frame axioms (14) of the theory\n$\\varphi_{it}  \\rightarrow \\vee contains(a,k,t)$\n$\\varphi_{it}  \\rightarrow \\vee contains(a,k,t)$\nwhere a \u2191 was defined in section III-D, and a \u2193 is the relation that holds whenever we have a \u2191 ' and Int d'. We note that when ra,k = t, we are implying that Io,k ~ It, and therefore It cannot be contained in Iak, since we want only to allow actions to explain those changes that occur strictly during their intervals.\nDomain constraint axioms III-E are implemented as follows. Let 41 42 and t be s.t. 1 \u2264 t \u2264 N. We need to ensure that sub-intervals I41,0,t, I41,1,t, I\u00a52,0,t, and I42,1,t do not overlap when they are referenced by a TQA in the plan, as per the definition of X || Y in Eq. (1)\n$\\psi_1^0(t)  \\rightarrow (I_{2,0,t} \\sim I_{1,1,t} \\vee I_{2,0,t} < I_{1,1,t})$\n$\\psi_1^0(t)  \\rightarrow (I_{1,0,t} \\sim I_{2,1,t} \\vee I_{1,0,t} < I_{2,1,t})$\nConstraints (30a) and (30b) intuitively account with the \u201cpush-ing and shoving\" amongst intervals depicted in Figure 3. We also add the following constraints\n$\\phi_{v1} + \\phi_{w1} \\le 1,  v, w \\in \\{0,1\\}$\n$\\psi_{iv} + \\psi_{iw} \\le 1,  v, w \\in \\{0,1\\}$\nConstraints (31a)-(31b) are meant to leverage Boolean unit propagation to discover conflicts early due to the instance Int relation."}, {"title": "E. Objective Functions", "content": "Beyond finding plans for theories TP,N one would like also to consider the optimization problem in which, for a set value of N, we seek a plan that satisfies TPN that also minimizes some given measure of performance f: II \u2192 RU {+\u221e}, that assigns positive real values to satisfying plans and +8 to plans that do not satisfy all axioms and constraints. To do so we consider two classic objective functions from the literature on Optimization methods for scheduling [14]: the so-called sum of task costs, and makespan. We replace the notion of task from the literature in scheduling with that of skill and thus assume that we have a function c: A\u2192 R+ that assigns to every skill a \u2208 A some positive real number. The \u201csum of skill costs\" objective function fssc is thus defined\n$f_{ssc}(\\pi) := \\sum_{a \\epsilon A} \\sum_{1leq k leq N} c(a)u_{a,k}$\nFormalizing the makespan objective function fm is less straightforward and requires the introduction of an auxiliary variable \u2206 and auxiliary constraints\n$u_{a,k} \\rightarrow (\\Delta \\geq r_{I_{a,k}}), 1 \\leq k \\leq N, a \\epsilon A$\n$\\Delta \\geq 0$\nwith fm(\u03c0) := \u2206. We also note that subsets of satisfying plans can be selected by setting deadlines for plan completion. This would amount to set suitable constraints on \u2206."}, {"title": "V. EVALUATION", "content": "We have tested the previous algorithm on several benchmarks, of which we report the one we find more significant: a generalization of the \"required concurrency\" gadget discussed by Cushing et al. [15] to analyze the ability of temporal planning algorithms to reason with concurrency requirements. Cushing's gadget is crafted to only admit plans like that in Figure 6. The gadget is requires to coordinate the execution of three skills a1, a2 and a3, with the requirement that the action TQAs intervals must have the configuration given in Figure 6. We note that there are many ways to enforce such structure in plans. In our framework, this can be achieved in two ways. One is to do so directly by having axioms that are conditional on the presence of any combination of action TQAS ai,k@Ii\u00bf for i = 1,2,3 in the plan. We note that doing so would result in having to generate O(N\u00b3) CSP constraints. A more compact modeling approach is to introduce resource fluents (section IV-C) pi where i = 1,2, and action axioms\n$a_1@I_1 \\rightarrow p_1@I = a_1@I_1$\n$a_2@I_2 \\rightarrow (p_2@I\\prime = a_2@I_2) \\land (p_1@I > a_2@I_2)$\n$a_3@I_3 \\rightarrow (p_1@I > a_3@I_3) \\land (p_2@I\\prime > a_3@I_3)$\nWe observe that the last constraint above is not handled by many otherwise highly performant solvers [20], [18], [19],"}, {"title": "VI. DISCUSSION", "content": "Figure 7 clearly shows the CP-SAT implementation of our algorithm to scale up for Type I instances, and solve mid-size Type II instances in tens of seconds. Larger Type II instances and Type III instances do challenge our algorithm and present a motivation for further research on the search and inference algorithms used by CP-SAT, as well as on the formulation III and encodings [?", "47": "and existing lower-bounding, con-straint propagation, and decomposition techniques in Opti-mization [51", "14": ".", "17": [18]}]}