{"title": "Microservice Deployment in Space Computing Power Networks via Robust Reinforcement Learning", "authors": ["Zhiyong Yu", "Yuning Jiang", "Xin Liu", "Yuanming Shi", "Chunxiao Jiang", "Linling Kuang"], "abstract": "With the growing demand for Earth observation, it is important to provide reliable real-time remote sensing inference services to meet the low-latency requirements. The Space Computing Power Network (Space-CPN) offers a promising solution by providing onboard computing and extensive coverage capabilities for real-time inference. This paper presents a remote sensing artificial intelligence applications deployment framework designed for Low Earth Orbit satellite constellations to achieve real-time inference performance. The framework employs the microservice architecture, decomposing monolithic inference tasks into reusable, independent modules to address high latency and resource heterogeneity. This distributed approach enables optimized microservice deployment, minimizing resource utilization while meeting quality of service and functional requirements. We introduce Robust Optimization to the deployment problem to address data uncertainty. Additionally, we model the Robust Optimization problem as a Partially Observable Markov Decision Process and propose a robust reinforcement learning algorithm to handle the semi-infinite Quality of Service constraints. Our approach yields sub-optimal solutions that minimize accuracy loss while maintaining acceptable computational costs. Simulation results demonstrate the effectiveness of our framework.", "sections": [{"title": "I. INTRODUCTION", "content": "Remote sensing (RS) satellite system, with multiple downstream tasks such as environmental and disaster monitoring, plays a significant part in Earth observation missions through global coverage, all-weather, and full-spectrum detection capacities. However, the vast volume of high-resolution raw data captured by the RS satellites raises a challenge: directly downloading raw data to ground stations for processing would result in critical latency issues [1]. The Space Computing Power Network (Space-CPN) is a promising solution to address this problem by integrating communication and inference capabilities into satellite constellation networks [2]. In particular, the Space-CPN is a multilayer satellite-based distributed computing platform, enabling RS tasks to perform similarly to ground-based data centers. Recent studies [3], [4], [5] focus on the Low Earth Orbit (LEO) onboard inference within the Space-CPN, and the objective is to minimize the total service latency and to achieve the better inference performance.\nAlthough the Space-CPN enables onboard inference capabilities for the RS applications, monolithic inference still faces multiple challenges. On the one hand, RS tasks such as land use category classification and disaster monitoring require high computation ability that a single LEO satellite cannot afford [6]. On the other hand, these downstream tasks often involve redundant module deployment and computation, which results in inefficiencies [7]. We adopt the microservice architecture in our on-board inference framework to address these challenges, which divides the monolithic application into multiple low-coupled modules (i.e., microservices) [8]. These microservices are deployed on suitable satellite nodes to perform the monolithic application's function. This architecture takes advantage of the portability, scalability, and resilience in software engineering. As illustrated in Fig. 1, the Space-CPN's satellite will receive image data from the RS satellite and start the on-board inference to send the result to the ground station. Thus, an efficient microservice deployment strategy is necessary for the inference to proceed smoothly.\nHowever, the challenge arises from the inherent heterogeneity of satellites because each satellite has different computing and communication capacities [9]. In particular, several satellites in Space-CPN serve as the communication relay with few computing and storage resources, and several satellites with high-performance hardware enable high computation demand tasks. Therefore, the heterogeneity property necessitates the deployment algorithm to select the most suitable satellite for each microservice to maximize resource utilization and ensure efficient inference (i.e., reduce latency punishment) [10], [11]. Consequently, the onboard microservice deployment problem becomes NP-hard with numerous local optima due to the LEO network's mesh topology, non-convex objectives, and integer constraints [7], [12]. The articles [13], [14], [15] use reinforcement learning (RL) based algorithms to solve the microservice deployment problem on the base station with powerful computing ability. [16] formulated a fractional polynomial problem caused by multiple instances of a single microservice and proposed a greedy-based heuristic algorithm to solve it. [17] considered the interference between microservices competing for the same resources and proposed a low-complexity heuristic algorithm with parallel deployment ability to minimize the use of the servers. However, these works did not consider LEO satellite constellation properties, i.e., low computing power and few resources. [18], [19], [20] try deploying microservice on edge devices such as Nvidia Jetson to meet the load balance, low latency, and security constraints. Although these works take advantage of low-power platforms, they cannot meet the LEO satellite constellation's topology properties and may receive critical resource waste and service latency punishment. [21], [22] proposed the satellite onboard deployment framework and algorithm to meet the constraints of LEO satellite constellation, but deterministic modeling cannot meet the uncertainty of user requests from different regions. Thus, an efficient, robust microservice deployment algorithm is necessary to reduce total resource consumption with Quality of Service (QoS) constraints and meet resource requirements.\nThe main challenge for the deterministic model when inference in the natural environment is that satellites need to complete the pre-assigned tasks established at launch and be ready to process emergency tasks such as earthquake and forest fire monitoring. These emergency tasks often occur unexpectedly with uncertainties in time and frequency [23]. To tackle this, we employ the Robust Optimization (RO) approach to capture the uncertainty in the data amount [24]. However, the dependency relationships between microservices complicate the deployment problem by increasing the coupling between optimization variables. Moreover, the semi-infinite QoS constraints complicate the optimization problem. As a result, traditional solvers like Complex or Gurobi cannot solve this problem directly. To address this, we reformulate the deterministic problem as a Partially Observable Markov Decision Process (POMDP) and solve it with reinforcement learning (RL) because of its MDP characteristics, which allows us to make decisions with partial knowledge of the optimization problem. [25], [26], [27] using adversaries to perturb the state the protagonist agent observes to receive a robust strategy. [28], [29], [30] derived the agent's updating equation with R-contamination uncertainty set on the transition kernel. [31] introduced uncertainty modeling into multi-agent reinforcement learning and analyzed the two agents' adversarial equilibrium conditions. Therefore, it is necessary to propose an efficient and robust deployment algorithm based on robust RL to minimize resource consumption and enhance the system's inference ability."}, {"title": "A. Contributions", "content": "In this paper, we proposed a robust reinforcement learning-based inference framework for resource consumption minimization in satellite onboard microservice deployment. The major contributions are summarized as follows:\n\u2022 A robust on-board microservice deployment focusing on the user request uncertainty is proposed to minimize the LEO satellite constellation resource consumption and the QoS punishment. It uses a box uncertainty set on the data amount from each region to control the robust level (i.e., the number of microservices deployed), thereby making a trade-off between minimizing the resource consumption and avoiding the QoS punishment. Moreover, we incorporate explicit QoS constraints for each request to ensure that all inference tasks are processed within low latency.\n\u2022 We first decompose the original problem into two parts, based on the redeployment costs associated with each microservice. We use the traditional reinforcement learning approach in the first stage to deploy the core microservices on the LEO satellite as the data center. In the second stage, we reformulate the optimization problem into a Partly Observable Markov Decision Process (POMDP) and solve it by using robust reinforcement learning. Due to the unexpected perturbation of POMDP, we use robust adversarial reinforcement learning to solve this robust microservice deployment problem. We analyze the equilibrium of this adversarial game and prove the existence of Nash equilibrium in this game. Simulation results will demonstrate the effectiveness of our proposed robust microservice deployment framework in minimizing resource consumption and avoiding QoS punishment."}, {"title": "B. Organization", "content": "The remainder of this paper is organized as follows. Section II proposes the microservice model, LEO satellite model, and deterministic deployment problem of LEO satellite constellation and microservice. In Section III, the robust optimization problem with semi-infinite QoS constraints is proposed to formulate the microservice deployment with data amount uncertainty. In Section IV, we transfer the original problem into two MDPs and propose two microservice deployment algorithms to solve this problem. Simulations and discussions are given in Section V. Finally, conclusions are presented in Section VI."}, {"title": "C. Preliminaries and Notations", "content": "In this paper, we use bold uppercase letters to represent matrices, while bold lowercase letters represent vectors. For a given set X, we use notation |X| to denote its cardinality. I(\u00b7) is the indicator function which equals to 1 when equation in (\u00b7) is true and equal to 0 for others, vec(\u00b7) denotes the vectorization operation. Besides, the most commonly used notations are listed as Table II. For a given two-player zero-sum game, we denote it by G = {{1,2}, {S1, S2}, {Yt, Zt}, C}, where S1 and S2 denote two players' strategy set respectively, Yt and Zt denote probability set of each strategy in S1 and S2 respectively, C\u2208 R^{|Yt|\u00d7|Zt|} denotes the reward matrix of two players. Let\n$\\begin{aligned}\n  01 &= \\max_{y\\in Yt} \\min_{z\\in Zt} \\sum_{i=1}^{[Y]} \\sum_{j=1}^{[Z]} C_{ij}Y_iz_j, \\\\\n  02 &= \\min_{z\\in Zt} \\max_{y\\in Yt} \\sum_{i=1}^{[Y]} \\sum_{j=1}^{[Z]} C_{ij}Y_iz_j,\n\\end{aligned}$$\nwe can have the following definition for Minmax Equilibrium."}, {"title": "Definition 1 (Minimax Equilibrium)", "content": "A minimax equilibrium existing in the two-player zero-sum game is equivalent to v1 = v2."}, {"title": "II. SYSTEM MODEL", "content": "In our onboard inference system, it is necessary to consider the topology of the LEO satellite constellation and the inference scheme. To this end, Section II-A and II-B present the model of the microservice and the LEO constellation. The latency model, cost model, and constraint of microservices are introduced in Section II-C, II-D, and II-E, respectively. Then we propose the deterministic optimization problem in Section II-F."}, {"title": "A. Microservice Model", "content": "Microservice architecture (MSA) is a programming paradigm for decomposing applications into a collection of light, independent microservices (MS). Each MS runs in its own process and communicates with other modules. In a monolithic architecture, we must redeploy several components multiple times for all tasks, resulting in inefficient resource consumption. Additionally, the high coupling of monolithic systems makes it difficult to update individual components, as any update requires redeploying the entire application. To address this, the remote sensing microservice inference system we considered in this paper is shown in Fig. 2. In particular, there exist 3 tasks: segmentation, classification, and multimodal interpretation and 9 microservices: precoding, byte pair encoding, projection, segmentation backbone, classification backbone, multimodal interpretation backbone, and output module 1~3. Thus, the inference tasks are shown as: \u2460 segmentation (\u2192\u2192\u2192\u21927), \u2461 classification (\u2192\u2192\u2192\u21920), and \u2462 multimodal interpretation (0,2\u2192\u2192\u21920) where \u2192 denotes the data flow between the microservices. Due to the low coupling, we can update the core components such as with no system shutdown and reduce the service waiting latency. Due to the tasks 1, 2, and 3 are using the same microservices and, the MSA system reuses these microservices to reduce the resource consumption."}, {"title": "B. LEO Constellation Model", "content": "A LEO satellite constellation functions similarly to a ground-based data center, providing real-time support for onboard remote sensing applications. A typical LEO constellation with Walker Star construction, such as Iridium, consists of O orbital planes, and each orbital contains L satellites. It can be depicted as a grid graph GD = (D, E2), where D is the set of available satellites (i.e., D = |D| = O \u00d7 L), and E2 is the set of ISLs between two satellites. Each satellite in the constellation has 4 inter-satellite links (ISLs), connecting two satellites within the intra-plane and two satellites in the inter-plane. Due to the Earth's obstruction and limited ISLs, one satellite can only transfer data by multi-hop with satellites without ISLs. Distance Du,v (kilometers) between satellite u and v is determined by the latitudes, longitudes, and altitudes of two satellites. Du,v can be depict as follows [34]:\n$\\begin{aligned}\n  D_{u,v} &= \\sqrt{2r^2[1 - \\cos{\\phi_u} \\cos{\\phi_u} \\cos{(\\Lambda_u - \\lambda_v)} - \\sin{\\phi_u} \\sin{\\phi_v}]}, \\tag{3a} \\\\\n  \\phi &= \\arcsin{\\left( \\sin{i} \\sin{\\mu} \\right)}, \\tag{3b} \\\\\n  \\lambda &= \\Omega + \\arctan{\\left(\\cos{i} \\tan{\\mu} \\right)} - w_2t, \\tag{3c} \\\\\n  \\mu &= w_1t + \\gamma, \\tag{3d}\n\\end{aligned}$$\nwhere r denotes the sum of the Earth's radius and the satellite's orbit altitude (in kilometers), i is the inclination of the LEO satellite orbit, and \u03a9 is the position of the ascending node, measured in degrees. Additionally, w1 represents the satellite's angular velocity as it orbits the Earth, with units of degrees per millisecond. \u03b3 is the initial phase angle of the satellite. w2 is the angular velocity of the earth's rotation in degrees/milliseconds. t is the current time. Let R be the set of available satellite resources (e.g., CPU core, GPU core, memory, power). For each satellite d\u2208 D, we userd(i) \u2265 0, i = 0,1, ..., R to denote the satellite's providing capacity of the corresponding resource i. We use cd > 0 to denote the computing ability (bits/ms) of satellite d and C = {f1, f2, ..., fD} denote the set of satellites' computing ability (bits/ms) with D = |D|."}, {"title": "C. Latency Model", "content": "Due to the dependency of microservices, the total latency (milliseconds) of microservice v at time slot t, which includes processing, propagation, and transmission latency, is influenced by the performance of its preceding microservice u [35]. Therefore, the latency of microservice v is defined as\n$T_v (u, i, j) = T_{u,i,j}^{DC} + T_{u,i,j}^{TP} + T_v^{PC}$,\nwhere u, v deployed on satellite i, j respectively. and denote the transmission latency and the propagation latency of microservice u from satellite i to satellite j respectively. The denotes the processing latency of microservice v deploy on satellite j.\nSpecifically, the propagation latency occurring from microservice u to v is associated with the spatial distance between the satellites of u and v, as well as the speed of light. Thus, the propagation latency can be defined by\n$T_{u,i,j}^{pp} = D_{i,j}/L,$\nwhere denotes the propagation latency of microservice u from satellite i to satellite j, Di,j represents the distance (kilometers) between i and j at the time the message is sent, L denotes the speed of light (kilometers/ms). The transmission latency is related to the distance between two satellites and the total data generated by microservice u. The transmission latency from microservice u to v can be depicted by\n$T_{u,i,j}^{tr} = b_i/W_{i,j},$\nwhere Wij denotes the data transmission rate (bits/ms) between satellite i and j. Besides, if microservice u is the first microservice of an application, the propagation latency = 0. The processing latency is related to the total amount of computation generated and the satellites' computational ability (CPU frequency, GPU float ability, and so on). So, the processing latency of microservice v deployed on the satellite i can be defined as\n$T_v^{PC} = a_v/f_i,$\nwhere fi \u2208 C is the computation ability (bits/ms) of satellite i. Therefore, the total latency of the application is defined as\n$1=\\sum_{m\\in M}T_m.$\nBesides, if microservice m has a dependency relation with more than one microservice, Tm will choose the arrival time of the last received microservice u's data to compute the and ."}, {"title": "D. Microservice Cost Model", "content": "We denote the microservice deployment scheme of time slot t as two matrixes Xt \u2208 R^{Mc\u00d7D}, Yt \u2208 R^{M\u2081\u00d7D}, where each entry is the deployment count of microservice m on satellite s, Mc denote the number of microservices deployed on core satellites, M\u2081 |M\u2081, Mc |. Let X = [X\u2070, X\u00b9, ..., XT], Y = [Y\u2070, Y\u00b9, ..., YT] denote the deployment scheme of core microservices and light microservices, respectively, where T = |T|, T denotes the total service time set. The total cost (i.e. money) of the whole inference system during T time slots can be divided into four partitions: money cost of core microservices C1(X), deployment money cost of light microservices C2(Y), maintenance money cost of light microservices C3(Y), and parallel computing money cost of light microservices C4(Y) [36]. The money cost of core microservices is influenced by the deployment counts, which are shown as follows:\n$C_1(X) = \\sum_{m \\in Mc} \\sum_{s \\in D} \\sum_{t \\in T} {p_m^k x_{m,s}^t + p_m^k x_{m,s}^t},$\nwhere, denote the deployment price and a time slot's maintenance price of microservice m on satellite s at time slot t, respectively. The deployment money cost of light microservices for a time slot can be depicted as follows:\n$C_2(Y) = \\sum_{m \\in M_l} \\sum_{s \\in D} \\sum_{t \\in T, t \\ne 0} {p_m max(0, y_{m,s}^t - y_{m,s}^3)},$\nwhere denotes the deployment price of microservice m on satellite s at time slot t. The maintenance money cost of light microservices for a time slot is shown as follows:\n$C_3(Y) = \\sum_{m \\in M_l} \\sum_{s \\in D} \\sum_{t \\in T} p_m y_{m, s}^t,$\nwhere pm denotes the deployment price of microservice m on satellite s at time slot t. The parallel computing money cost of light microservices for a time slot is:\n$C_4(Y) = \\sum_{m \\in M_l} \\sum_{s \\in D} \\sum_{t \\in T} p_m y_{m,s}.$"}, {"title": "E. Deterministic Constraint", "content": "To meet the resource and QoS limitation, the deployment scheme will deal with the following constraints.\n1) Function Completeness Constraint: To simulate the function of a monolithic service, each microservice should be deployed at least one time. In particular, for xms, the completeness constraint and the integer constraint is:\n$\\sum_{s \\in D} x_{m,s} \\geq 1, x_{m,s} \\in N$\nfor all m \u2208 Mc, s \u2208 D. For ym,s, it was shown as:\n$\\sum_{s \\in D} y_{m,s}^t \\geq 1, y_{m,s} \\in N$\nfor all m\u2208 M\u2081, s\u2208 D, te T.\n2) Parallel Computing Constraint: We use the relationship between area requests and parallel accessing ability km of each microservice to model the deterministic parallel constraint. We use Zt \u2208 R^{M\u00d7D} to denote the request in time slot t. Each microservice can only process at most km requests during a time slot, i.e., each task request zms \u2208 Zt from all areas needs to find a microservice that still can process one more task request (i.e. one more raw image), which can be formulated as\n$\\sum_{s \\in D} y_{m,s}^t k_m \\geq \\sum_{s \\in D} z_{m,s}^t$\nfor all t \u2208 T, m\u2208 M\u2081."}, {"title": "3) QoS Constraint:", "content": "To ensure each request can be responded to efficiently, we defined QoS (Quality of Service) in our system as the total latency of each task. We use z \u2208 Zt to denote the index of request at time slot t with\n$Z^t = \\{ z\\in N | 0 \\leq z \\leq \\frac{D}{2\u03c3_{0,s}} \\}.$\nTo track the inference routing of each task, we use Rt \u2208 R^{Zt\u00d7 M} to denote the place of microservices used by each task where Zt Zt, elements in Rt denotes the microservice's deployment place. In our system, each task will try to use the microservices routing path with the shortest distance if processing ability exists. In particular, we define the chosen Rt* by Rt* :=\n$\\begin{aligned}\n  &\\underset{R_t \\in \\mathbb{N}^{Z_t \\times M_i}}{\\arg \\min} \\{\n  A_p \\cdot \\max_z (\\sum_{p=1}^{Z_t-1} \\sum_{l=1}^{M_i-1} |F(r_{z,p-1}) - F(r_{z,p})||_2) \n  +\n  \\max(\\sum_{m=0}^{M_i-1} \\sum_{d=0}^{D-1} \\sum_{z=0}^{Z_t-1} I(r_{m}^{z} = d) - Y_{m,d} ) \\}\n\\end{aligned}$$\nwhere \u2208 Rt denotes the microservice m's deployment place used by task z at time slot t, ap is a large factor which denotes the overload punishment, and (C1, C2) = F(r1) is the satellite's coordinate in the mesh topology defined as C1 = r1/L, C2 = r1 mod L. With the microservice routing matrix Rt* and equations (3), (4), and (8), we can formulate the QoS constraint for each task as:\n$l_z = \\sum_{m=1}^{M_i-1} T_v (m - 1,r_{m-1}^{z},r_{m}^{z}) \\leq QoS,$\nfor all z \u2208 Zt, \u2208 Rt*, where QoS is a scalar denotes the maximum service time, l\u2082 denotes service time of request z according to equation (8)."}, {"title": "4) Core Microservices Resource Constraint:", "content": "The total resource consumption of the core microservices deployed on one satellite cannot exceed the resource capacity of this satellite:\n$\\sum_{m\\in M_c}r_m(j)x_{m,s} \\leq r_s(j)$\nfor all j\u2208 R, s \u2208 D."}, {"title": "5) Light Microservices Resource Constraint:", "content": "Due to the core microservices, the light microservices are restricted by the satellite's resource capacity and the core microservices' resource consumption:\n$\\sum_{m\\in M_l} \\{r_m(j)x_{m,s}+r_m(j)y_{m,s} \\} <r(j)$\nfor all j\u2208 R, te T, se D."}, {"title": "F. Microservice Deployment Problem Formulation", "content": "Microservice deployment in Space-CPN is to allocate microservices in the finite time slots (i.e., T time slots) to appropriate satellites based on task load statistics, server latency, and resource (i.e., CPU, GPU, memory) constraints, which is shown in Fig. 3. In particular, the deployment system will use the statistics: task load Zt and satellite's resource rm(i) to decide which microservice will deploy on the current satellite. The objective is to minimize the overall money cost of all microservices in any time slot t with no QoS violation. By the cost model and the constraints proposed in Section II-D and Section II-E, we formulate the deterministic optimization problem as follows:\n$\\begin{aligned}\n&\\min_{X,Y} C_1(X) + C_2(Y) + C_3(Y) + C_4(Y) \\tag{20a} \\\\\n&\\text{subject to constraints (13) \u2013 (19)}, \\tag{20b}\n\\end{aligned}$$\nwhere X \u2208 R^{M_c\u00d7D},Y \u2208 R^{RT\u00d7M\u2081\u00d7D denote the deployment scheme of two kinds of microservice."}, {"title": "III. ROBUST MICROSERVICE DEPLOYMENT PROBLEM", "content": "Due to the uncertainty of inference tasks, the deterministic model is hard to meet the situation in the real world because task amount matrix Zt is assumed to be known in deterministic modeling. It is necessary to use approaches such as uncertainty modeling and robust optimization to model this dynamic problem. Therefore, we introduce the uncertainty model and the uncertainty set in Section III-A. The robust optimization of the microservice deployment problem is proposed in Section III-B."}, {"title": "A. Uncertainty Model", "content": "In reality, there can be fluctuations in \u2208 Zt for microservice m and satellite s due to factors such as emergency tasks like earthquake [23]. It can be depicted as Fig. 4. In particular, the deployment scheme of each time slot is related to 1) the uncertainty data amount, 2) the nominal data amount, and 3) the deployment scheme of the previous time slot. At time slot t2, we only know there should be 27 requests in the usual time but have no idea if there are any request fluctuations or not. It may cause significant resource waste or QoS punishment and interfere with the deployment scheme of the following time slots [36]. We introduce uncertainty into the user's request to meet the perturbation of the number of requests. In particular, we build the box uncertainty set on Zt by\n$\\Omega^t(Z^t) = \\{Z^* | ||Z^t - Z^*||_{\\infty} \\leq \\Phi \\}$\nfor all t \u2208 T, where \u03a6 denotes the robustness level (i.e. width of the uncertainty set) of the current model, Z denotes the nominal request count matrix. Then, we can reformulate the constraint (15) into an uncertainty constraint:\n$\\underset{Z \\in \\Omega(Z)}{\\min} \\{ \\sum_{s \\in D} y_{m,s}k_m - z_{m,s} \\} \\geq 0$\nfor all m \u2208 M\u2081, t \u2208 T. Constraint (22) indicates that the accessing ability of microservices must be larger than the number of user requests. Due to the difference in each status, simply adding or removing microservices from the deterministic solution won't resolve this issue due to the different deployment schemes in each time slot. For instance, if\n$\\sum_{s \\in D} y_{m,s}k_m \\geq \\sum_{s \\in D}(z_{m,s} + |\\Phi|)$\nfor all Zm.s \u2208 Zt, the worst-case scenario is that there aren't enough requests for the microservices to handle, leading to resource wastage and associated penalties. Conversely, if\n$\\sum_{s \\in D} y_{m,s}k_m < \\sum_{s \\in D}(z_{m,s} + |\\Phi|),$\nthe worst-case scenario shifts to having too many requests to handle, resulting in latency penalties."}, {"title": "B. Robust Microservice Deployment Problem Formulation", "content": "Given the QoS constraints (17) and the robust constraint (22), we can formulate the robust optimization problem as follows:\n$\\underset{X \\in F_1}{\\min} C_1(X)+\\underset{Z \\in \\Omega}{\\max} \\underset{Y \\in F_2 (X,Z)}{\\min} C_2(Y)+C_3(Y)+C_4(Y)$\nwith \u03a9 = Ut\u2208T \u03a9(Z). Here Z \u2208 R^{T\u00d7M\u2081\u00d7D has the request count of all time slot, Y \u2208 R^{RT\u00d7M\u2081\u00d7D denotes the light microservice's deployment scheme of all time slot, F1 and F2(X, Z) is the feasible set of X and Y which are shown as:\n$F_1 = \\{ X | (13), (18) \\},$\n$F_2(X, Z) = \\{ Y | (14), (16), (17), (19), (22) \\}.$\nWhile Problem (23) incorporates lots of elements of the real world, such as chain deployment schemes and data amount uncertainty, it raises critical challenges compared with the deterministic works. To show that the optimization problem (23) we proposed is challenging to solve with the simple approach, we will analyze this optimization problem in two parts: NP-hard problem and semi-infinite constraint.\n\u2022 NP-hard Problem: Suppose that the min max min structure is used in the objective function and arg min used in the constraint (17), we have the non-convex optimization problem. Moreover, because the total latency function includes a quadratic component, the quadratic constraint (17) increases the complexity of solving this optimization problem. Thus, the objective makes it unsolvable in polynomial time by using traditional optimization algorithms.\n\u2022 Semi-Infinite Constraint: This challenge poses significant interference for global optimization algorithms to solve this problem by introducing an uncertain amount of constraints (17) into the optimization problem [37]. Due to the uncertain set deployed on the number of tasks, the number of quadratic QoS constraints remains unknown. So using the B&B method to solve this problem is extremely difficult.\nThe analysis reveals that problem (23) cannot be efficiently solved by existing optimization algorithms. Sub-optimal methods like greedy algorithms (e.g., K8S's Horizon Pod Autoscaling [38]) are viable but often yield overly conservative strategies (Section III-A). RL's Markov property makes it promising for precise decisions without global information. However, deterministic RL struggles with environmental uncertainty. To address this, we propose a robust RL-based approach that retains the Markov property while enhancing robustness."}, {"title": "IV. ROBUST ADVERSARIAL REINFORCEMENT LEARNING ALGORITHM", "content": "To address the non-convex robust optimization problem (23) in Section III, we introduce a robust adversarial reinforcement learning algorithm. Our approach first decomposes the problem (23) into two components based on its inherent properties. We then apply distinct algorithms to solve each part separately."}, {"title": "A. Problem Decomposition", "content": "The traditional two-stage robust optimization framework faces significant challenges due to the high computing complexity caused by the optimal approach such as Benders Decomposition [39]. Due to core microservices' high deployment cost and importance in the problem (23), only xm,s influence yms. Therefore, we can decompose the problem in equation (23) into two stages: deploying Mc (first stage) and deploying M (second stage). Given the substantial resource consumption of core microservices, each microservice in Me is deployed only once to avoid excessive resource use. Thus, with the infinite accessing ability, like the computing center, the first stage problem can be transformed into a new form: finding a deployment scheme that minimizes total latency. There are multiple works about how to deploy core microservices in Space-CPN. The first stage's deployment algorithm we adopt is shown as follows."}, {"title": "B. First Stage Deployment Approach", "content": "To address the static microservice deployment problem in the first stage, we adopt an RL-based algorithm to solve it. The standard PPO-based training algorithm is shown in Algorithm 1.\n1) State and Action: The state at step i is a vector s where cardinality is Me \u00d7 D, which means each microservice deploys on each satellite or not. For the first stage, the action a at step i is to deploy microservice i on a satellite. With D satellites for each time slot, there are D actions: a \u2208 {0, 1, 2, ..., D}."}, {"title": "C. Second Stage Deployment Approach", "content": "1) Robust Adversarial Reinforcement Learning: As discussed in Section III", "25": "shown in Fig. 5. In this framework"}, {"25": "agents can perform multiple actions until their allotted step.\n2) Partially-Observable Markov Decision Process: Different from the MDP used in the first stage", "T": "S'\u00d7A \u2192 S'", "R": "S' \u00d7 A1 \u00d7 A2 \u2192 R", "O": "S' \u00d7 A1 \u00d7 A2 \u2192 S denote the transition function", "u": "nwhere i and u denote the protagonist agent's time slot and the current microservice", "follows": "ns = [vec(Pori)", "j": "nwhere j denotes the adversary agent's step", "Action": "The action space A1 and A2 of the second stage is a discrete space. For the second stage, the action a at step i for microservice u is a vector whose cardinality is D. Each element in a is a non-negative integer up to a denotes how many microservice u will be deployed"}]}