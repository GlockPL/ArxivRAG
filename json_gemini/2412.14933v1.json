{"title": "Cirbo: A New Tool for Boolean Circuit Analysis and Synthesis", "authors": ["Daniil Averkov", "Tatiana Belova", "Gregory Emdin", "Mikhail Goncharov", "Viktoriia Krivogornitsyna", "Alexander S. Kulikov", "Fedor Kurmazov", "Daniil Levtsov", "Georgie Levtsov", "Vsevolod Vaskin", "Aleksey Vorobiev"], "abstract": "We present an open-source tool for manipulating Boolean circuits. It implements efficient algorithms, both existing and novel, for a rich variety of frequently used circuit tasks such as satisfiability, synthesis, and minimization. We tested the tool on a wide range of practically relevant circuits (computing, in particular, symmetric and arithmetic functions) that have been optimized intensively by the community for the last three years. The tool helped us to win the IWLS 2024 Programming Contest. In 2023, it was Google DeepMind who took the first place in the competition. We were able to reduce the size of the best circuits from 2023 by 12% on average, whereas for some individual circuits, our size reduction was as large as 83%.", "sections": [{"title": "Introduction", "content": "Boolean circuits is a mathematical model with applications in various branches of Computer Science such as Complexity Theory, Computer Engineering, and Cryptography. The two most important related computational problems are circuit analysis and circuit synthesis.\nCircuit analysis: given a circuit, check whether it possesses a certain property. A ubiquitous property is satisfiability (whether it is possible to assign 0/1 values to the inputs such that the circuit evaluates to 1). The corresponding problem is known as Circuit SAT. On the one hand, many circuit analysis problems (such as logical equivalence checking and verification) are equivalent to Circuit SAT. On the other hand, Circuit SAT is a generalization of SAT (satisfiability of formulas in conjunctive normal form) and many hard combinatorial problems are reduced to SAT via Circuit SAT. At the same time, Circuit SAT can be reduced to SAT in a natural way. This way, Circuit SAT shares a wide range of applications, both practical and theoretical, with SAT.\nCircuit synthesis: given a specification of a Boolean function, synthesize a small circuit computing this function."}, {"title": "New Tool", "content": "The focus of the this paper is on practical aspects of the two problems mentioned above: we present a new tool, called Cirbo, for solving a wide range of problems on Boolean circuits. The tool implements a variety of algorithms, both known and novel ones. The tool allowed us to win the IWLS 2024 Programming Contest.\u00b9 The goal of the competition is to synthesize efficient circuits for 100 Boolean functions (specified by their truth tables), in two bases, XAIG and AIG. For each of the two bases, for more than half of the functions, the circuits synthesized by our tool turned out to be the smallest among the circuits produced by all teams. Moreover, the datasets in 2024 contest were the same as in 2023, giving us a possibility to track the progress of reducing the circuit size for these datasets. Table 1 shows the corresponding circuit size for a selection of datasets and highlights that in some cases our size reduction was as large as 83%. Later in the text, we define all the functions from the table formally, provide more statistics as well as detailed steps that led to improved circuits."}, {"title": "Related Work", "content": "There is a number of packages providing a similar functionality: ABC and mockturtle are general pur-pose tools for working with Boolean circuits implemented in C++, whereas CLI and CIOPS are circuit minimization tools based on SAT/QBF solvers implemented in Python. As our experiments show, our tool is capable of solving various datasets better than the tools mentioned above. At the same time, for some of these datasets, the best results have been achieved by combining our tool with the existing ones."}, {"title": "General Setting", "content": "For a predicate P, [P] is the Iverson bracket: $[P] = 1$ if P is true and $[P] = 0$ otherwise. For a non-negative integer q, bin(q) is the binary representation of q (padded with a number of leading zeroes if needed). Conversely, for a bit-string $b = (b_0,..., b_k)$, int(b) = $\\sum_0^k 2^i b_i$; is the corresponding integer."}, {"title": "Boolean Functions", "content": "Let $B_{n,m} = \\{f: \\{0,1\\}^n \\rightarrow \\{0,1\\}^m\\}$ be the set of all Boolean functions with n inputs and m outputs and let $B_n = B_{n, 1}$ be the set of all n-input single-output functions (that is, predicates). A function of the form $f: \\{0,1\\}^n \\rightarrow \\{0,1, *\\}^m$ is called partially defined: * is known as don't care symbol and means an undefined Boolean value.\nBelow, we define a number of specific Boolean func-tions studied in this paper. By $x = (x_1,...,x_n)$ and $y = (y_1,..., y_n)$ we denote input n-bit strings and $sum(x) = x_1 + ... + x_n$.\n$\\bullet$ $MAJ_n \\in B_n$ is the majority function, that is, it is equal to 1 if and only if more than half of the n input bits are 1's: $MAJ_n(x) = [sum(x) > n/2]$.\n$\\bullet$ $SUM_n \\in B_{n, [log_2(n+1)]}$ computes the binary representation of the sum of n input bits: $SUM_n(x) = bin(sum(x))$.\n$\\bullet$ $SORT_n \\in B_{n,n}$ sorts the given n bits: $SORT_n(x) = (x'_1,...,x'_n)$, where $x'_1 \\leq ... \\leq x'_n$ and $sum(x) = sum(x')$.\n$\\bullet$ $MULT_n \\in B_{2n,2n}$ computes the product of the given two n-bit integers: $MULT_n(x, y) = bin(int(x)\\cdot int(y))$.\n$\\bullet$ $SQR \\in B_{n,2n}$ computes the square of the given n-bit integer: $SQR(x) = MULT_n(x,x)$.\n$\\bullet$ $SQRT_n \\in B_{n,n/2}$ computes the square root of the given n-bit integer: $SQRT(x) = bin([\\sqrt{int(x)}])$.\n$\\bullet$ $DIV_n \\in B_{2n,n}$ and $MOD_n \\in B_{2n,n}$ functions compute, respectively, the quotient and the remainder of the first input integer divided by the second input integer:\n$DIV_n (x, y) = bin([int(x)/int(y)])$,\n$MOD_n (x, y) = bin(int(x) mod int(y))$."}, {"title": "Boolean Circuits", "content": "A circuit is a natural way of computing Boolean func-tions. It is an acyclic directed graph of in-degree at most 2 whose n source nodes are labeled with input variables $x_1,..., x_n$ and all other nodes (called internal) are labeled with Boolean operations from $B_1 \\cup B_2$ (that is, unary and bi-nary Boolean predicates). The nodes of the circuit are called gates and each gate computes a (single-output) Boolean function of $x_1,..., x_n$. Thus, if m gates of the circuit are marked as outputs, it computes a function from $B_{n,m}$. The size of a circuit is its number of internal binary gates (it is common to assume that unary gates are given for free)."}, {"title": "Tool Features", "content": "The tool has been implemented with a goal of being efficient and easy to use and extend: the code is open source2 and written in Python (making the code compact and easy to read). Below, we describe the main features of the tool.\nAnalysis\nThe tool allows to analyze Boolean functions and circuits.\nFunction Analysis Analyzing the properties of a given Boolean function is important for subsequent synthesis of an efficient circuit computing this function. Currently, the tool allows to check whether a Boolean function is monotone or symmetric (these checks are performed via enumerating all $2^n$ input assignments and hence are only practical when the number n of inputs is small enough). A function can be passed either as a truth table or as a Python function, see Listing 1.\nCircuit Analysis A circuit is a particular way of representing a Boolean function. For this reason, the Circuit class implements Function interface allowing one to use all the checks described in the previous section for circuits also. Additionally, one can check whether a circuit is satisfiable. This is done by transforming a circuit into a CNF (via Tseitin transformation) and invoking a SAT solver via the pysat module , see Listing 2.\nCircuit satisfiability is a ubiquitous problem as many other hard problems can be reduced to it naturally. For ex-ample, to verify whether two circuits $C_1, C_2: \\{0,1\\}^n \\rightarrow \\{0,1\\}^m$ compute the same function, one combines them into"}, {"title": "Synthesis", "content": "Using the tool, one can synthesize Boolean circuits using the following three regimes.\nManual Synthesis out of Presynthesized Blocks The tool contains generators of various circuits that are fre-quently used in circuit synthesis: comparators, summators, multipliers, etc. One can use them as building blocks to syn-thesize efficient circuits for various functions. We give an ex-ample for the majority function of six input bits. This is a symmetric function, so one can first compute the binary representation (bo, b1, b2) of the sum of the input bits and then output $(b_0 \\wedge b_1) \\vee b_2$. Listing 5 shows how to achieve this in the tool.\nAutomated SAT-based Synthesis When the number n of inputs is small (say, n < 10), one can synthesize an ef-"}, {"title": "Minimization", "content": "In the circuit minimization problem, one is given a circuit and is asked to come up with a smaller circuit computing the same function.\nLow Effort Minimization The cleanup method performs straightforward cleaning of a circuit: for example, removes dangling and duplicate gates.\nHigh Effort Minimization A more powerful, but significantly less efficient minimizing method is the following: try to minimize small subcircuits of a given circuit . For each subcircuit, we compute a partial function computed by it and try to synthesize a more efficient circuit computing the same function using the SAT-based approach. If a more efficient circuit is found, we replace the corresponding subcircuit in the original subcircuit and iterate."}, {"title": "Experimental Evaluation", "content": "Recall that a Boolean function $f(x_1,...,x_n) \\in B_{n,m}$ is called symmetric if its value depends on $(x_1+...+x_n)$ only (equivalently, the function value never changes when one permutes the inputs). On the one hand, many interesting functions are symmetric (for example, SUM, MAJ, and SORT). On the other hand, even if a function is not symmetric, a circuit for it can rely on symmetric functions: for example, to compute the product of two n-bit integers, one first computes pairwise products of input bits and then computes the sums of these products.\nSUM Since the value of a symmetric function depends on $(x_1+...+x_n)$, SUM is a fundamental symmetric function: below, we demonstrate that to get an efficient circuit computing a symmetric function, it makes sense to first compute $(b_0,..., b_k) = SUM_n(x_1,...,x_n)$ (that is, to compress n input bits into about k + 1 = $[log_2(n + 1)]$ bits) and then to compute the result out of $(b_0,..., b_k)$. For this reason, it is important to have efficient circuits for SUM. A well known way to compute $SUM_n$ is to apply blocks computing $SUM_3$ and $SUM_2$ iteratively: in particular, this leads to upper bounds\n$size_{XAIG} (SUM_n) \\leq 5n$ and $size_{AIG} (SUM_n) \\leq 7n$.\nNo better construction is known for AIG, whereas for XAIG, a better upper bound is known :\n$size_{XAIG} (SUM_n) \\leq 4.5n + o(n)$.\nOur tool allows to generate best known circuits computing $SUM_n$ for all n. In Table 3, we show the size of the corresponding circuits.\nMAJ and SORT For MAJ and SORT, our tool improved greatly the best known circuits following the hybrid approach outlined in Listing 7:\n1. first, compute $(b_0,...,b_k) = SUM(x_1,...,x_n)$ (here, k = $[log_2(n + 1)] - 1$);\n2. then, using a SAT-based approach, find a circuit that computes the required function out of $(b_0, ..., b_k)$;\n3. finally, minimize the composition of the two circuits.\nMultipliers As mentioned above, efficient circuits for SUM allow to synthesize circuits for various arithmetic functions as many of them use bit summation, one way or another. A prominent example is $MULT_n$. With respect to circuit size, efficient long integer multiplication algo-rithms (like the ones by and ) start to outperform the"}, {"title": "Arithmetic Functions", "content": "In the IWLS 2024 Programming Contest, it is the arithmetic functions category where we were able to achieve the most dramatic improvement in circuit size compared to the best results of 2023 (see the first four rows of Table 1). For each of the arithmetic benchmarks, we followed the same two-step approach:\n1. Convert a known algorithm for computing the corresponding function to a circuit. When doing this, optimize individual parts of the circuit whenever possible.\n2. Minimize the resulting circuit.\nWe illustrate the first step of this approach for the DIV function. Assume that\n$DIV_n(x_0,..., x_{n-1}, y_0,..., y_{n-1}) = (z_0,..., z_{n-1})$, where xo, Yo, 20 are the least significant bits of the corresponding integers. Let also\n$X = int(x_0,...,x_{n-1})$,\n$Y = int(y_0,...,y_{n-1})$,\n$Z = int(z_0,...,z_{n-1})$ be the corresponding integers. Thus, $0 \\leq X,Y,Z < 2^n$ and $Z = \\lfloor X/Y \\rfloor$. We assume also that Y > 0. We follow the grade-school division algorithm: determine the bits of Z one by one starting from the most significant bit, each time try subtracting $2^{i}z_iY$ from X. Since $z_i$ is either 0 or 1, one does not even need to multiply by $z_i$: $2^{i}z_iY$ is either 0 or Y shifted by i positions. Moreover, all iterations of the algo-rithm perform similar checks and one can precompute the\n$Y < 2^{n-i}$ and $\\geq int(y_0,...,y_{n-i-1})$."}, {"title": "Minimizing Existing Circuits", "content": "We have been able to synthesize efficient circuits for various symmetric and arithmetic functions, partly due to the fact that we knew the exact structure of these functions. At the same time, in the IWLS 2024 Programming Competition, there were many benchmarks whose structure was unclear: for example, 32 benchmarks correspond to three-output neu-rons from the LogicNets project . In such cases, we were trying to optimize either a known circuit or some inefficient circuit for the corresponding func-tion. To do this, we combined our SAT-based minimiza-tion tool with other efficient tools like ABC and CIOPS : for a given circuit, we applied the three tools repeatedly. This strategy allowed us to further improve about half of the circuits synthesized for the neuron benchmarks, see Table 6."}]}