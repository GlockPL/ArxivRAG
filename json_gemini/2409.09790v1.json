{"title": "Multiple Rotation Averaging with Constrained Reweighting Deep Matrix Factorization", "authors": ["Shiqi Li", "Jihua Zhu", "Yifan Xie", "Naiwen Hu", "Mingchen Zhu", "Zhongyu Li", "Di Wang"], "abstract": "Multiple rotation averaging plays a crucial role in computer vision and robotics domains. The conventional optimization-based methods optimize a nonlinear cost function based on certain noise assumptions, while most previous learning-based methods require ground truth labels in the supervised training process. Recognizing the handcrafted noise assumption may not be reasonable in all real-world scenarios, this paper proposes an effective rotation averaging method for mining data patterns in a learning manner while avoiding the requirement of labels. Specifically, we apply deep matrix factorization to directly solve the multiple rotation averaging problem in unconstrained linear space. For deep matrix factorization, we design a neural network model, which is explicitly low-rank and symmetric to better suit the background of multiple rotation averaging. Meanwhile, we utilize a spanning tree-based edge filtering to suppress the influence of rotation outliers. What's more, we also adopt a reweighting scheme and dynamic depth selection strategy to further improve the robustness. Our method synthesizes the merit of both optimization-based and learning-based methods. Experimental results on various datasets validate the effectiveness of our proposed method.", "sections": [{"title": "I. INTRODUCTION", "content": "Multiple rotation averaging (MRA) [1], which is also known as rotation synchronization, is a fundamental problem in 3D computer vision and robotics. It finds wide application in various domains such as Structure from Motion (SfM) [2], [3], pose graph optimization (PGO) in visual Simultaneous Localization and Mapping (SLAM) system [4], multiview point cloud registration [5], [6], [7], and sensor network localization [8].\nThe MRA problem belongs to the broader category of group synchronization problems, specifically centered on the Special Orthogonal Group SO(3). The primary goal of this task is to estimate the absolute orientation of individual nodes (camera, Lidar, etc.) from the relative rotation measurements between them. Typically, the relative measurements in practice are contaminated by the noise and outlier introduced by the imperfect pairwise matching or registration, which further makes the problem more challenging.\nThe majority of previous methods formulate the MRA as an optimization problem [9], [10], [11]. In order to satisfy the condition of nonlinear SO(3) space, these methods typically need to impose extra constraints during the optimization. This challenging process often entails local linearization or iterative optimization techniques. Furthermore, addressing outliers requires the application of robust loss functions that rely on assumptions about sensor noise and outlier distribution. However, these assumptions may not accurately reflect real-world conditions. Moreover, it frequently involves manually adjusting parameters, a task that can be nontrivial.\nRecent learning-based methods [12], [13], [14] have harnessed the power of neural networks to address the MRA problem. These methods employ Graph Neural Network (GNN) to model the pose graph. Relative rotations and absolute orientations are encoded as edge messages and node features. Diverse message passing and aggregation schemes are designed for learning noise and outlier distributions from training data. While these supervised methods demonstrate impressive performance, they continue to grapple with data scarcity and domain gaps.\nIn this study, we directly recover the absolute orientation of every node in linear space via the deep matrix factorization technique. All target absolute orientations are stacked and represented as a product of several factor matrices using a linear neural network. The network is deliberately designed to possess an explicitly low-rank and symmetric structure, aligning with the background of the MRA problem. We employ the observed relative measurements as constraints for network optimization to facilitate unsupervised learning. Additionally, we employ a spanning tree-based edge filtering and reweighting scheme to enhance the robustness. In contrast to traditional optimization-based methods, our approach embraces a data-driven method to extract information from observed relative measurements, significantly reducing the need for noise distribution assumption and manual adjustment of threshold parameters. Despite being a learning-based approach, our method is distinct from previous works in that it is unsupervised, liberating us from the laborious dataset acquisition. Furthermore, our method eliminates the need to address adaptation challenges across different domains. Finally, unlike previous work [15], we apply more sophisticated designs based on prior knowledge to considerably aid the learning process and bypass eigen decomposition to retrieve the absolute orientations directly. Extensive experiments on datasets with various scales and modalities demonstrate the accuracy and generalization ability of our proposed method and our code will be available upon acceptance.\nIn conclusion, our contribution can be summarized as: 1) We introduce a spanning tree-based edge filtering to effectively and efficiently detect and remove outliers in relative measurements. 2) We design a network with explicit low-rank and symmetric constraints to directly calculate absolute orientations in unrestricted linear space using deep matrix factorization. 3) We propose a reweighing scheme and a depth selection mechanism to enhance the robustness."}, {"title": "II. RELATED WORK", "content": "a) Conventional MRA Method: Multiple rotation averaging is an extensively researched problem that was first introduced by Govindu and addressed using a linear model in [16]. To obtain more accurate results, many approaches iteratively optimize robust cost functions to suppress the impact of outliers. Hartley et al. [9] employ single rotation averaging under the l\u2081 norm to update absolute orientations and introduce a rotation averaging method based on the Weiszfeld algorithm. Chatterjee and Govindu [10] present a method that initialized with a spanning tree and then uses an iteratively reweighted least squares (IRLS) procedure to minimize la loss, which yields the best empirical accuracy. Arrigoni et al. [17] likewise employ the IRLS technique to bolster the robustness of the spectral decomposition method outlined in [18]. Shi and Lerman [11] introduce a message passing least squares (MPLS) framework as an alternative approach to IRLS. Zhang et al. [19] propagate the uncertainty from the correspondences into the rotation averaging to better model the underlying noise distributions.\nBesides, some approaches concentrate on spotting outliers within the input graph. Govindu [20] introduces a RANSAC-style sampling approach to eliminate outliers. Zach et al. [21] present a Bayesian framework for classifying edges as either inliers or outliers. Arrigoni et al. [22] propose heuristic methods based on cycle bases to improve cycle consistency check. HARA [23] introduces a heuristic method that incrementally constructs a spanning tree based on triplet support.\nAdditionally, some incremental estimation-based approaches also demonstrate impressive performance. Among them, the IRA [24] series is particularly representative.\nb) Learning-based MRA Method: In recent years, deep learning-based algorithms have been proposed to tackle the multiple rotation averaging problem. NeuRoRA [12] pioneers neural network architectures on multiple rotation averaging, the proposed network is a combination of cleaning and fine-tuning sub-networks. LITS [13] proposes a weight-shared message passing neural network to predict an incremental in each iteration. PoGO-Net [25] designs a de-noising layer to achieve implicit edge-dropping. MSP [26] integrates differentiable multiple sources initialization and optimization procedure in a unified GNN. RAGO [14] decouples the MRA to multiple single rotation averaging problems and use a gated recurrent unit module to enhance robustness. The majority of these solutions are based on the GNN paradigm and need ground truth orientation labels to supervise network training. However, collecting accurate realistic MRA dataset is tricky, and such data scarcity will impede the development of these supervised methods.\nA recent work, DMF-SYNCH [15], proposes to utilize the deep matrix factorization to solve the multiple rotation averaging problem in an unsupervised way. While there is still a lot of room for improvement in performance, this method provides a new view for multiple rotation averaging. In this paper, we use a similar technique but integrate additional prior knowledge to solve the problem more straightforwardly."}, {"title": "III. PRELIMINARY", "content": "A. Notation and Problem Statement\nA rotation is denoted by a rotation matrix R, the Riemannian distance between two rotations R\u2081 and R2 can be straightforwardly determined as the angular difference between them, i.e.,\n$d(R_1, R_2) = ||Log(R_1R_2^T)||,$\nwhere $Log()$ is logarithm map function and $||\\cdot||$ is the Euclidean norm.\nWe also introduce the chordal distance, which is akin to the Riemannian distance when two rotations are proximate to each other. The chordal distance between R\u2081 and R2 is defined as:\n$d_{chord}(R_1, R_2) = ||R_1 - R_2||_F,$\nwhere $|| \\cdot ||_F$ represents the Frobenius norm.\nGiven a 3D scene with multiple frames, each frame can be considered as a camera in SfM or a point cloud in multiview registration, the geometric relationships within the 3D scene can be represented by a view-graph $G = {\\mathcal{V}, \\mathcal{E}}$. Each vertex $v_i$ in $\\mathcal{V}$ stands for a frame with unknown absolute orientation $R_i$, the cardinality of vertex set $|\\mathcal{V}|$, i.e., the number of frames is denoted as N. An edge $e_{ij}$ in $\\mathcal{E}$ indicates the existence of pairwise relative rotation $R_{ij}$ between vertex $v_i$ and $v_j$. Ideally, the relative rotation and absolute orientation should satisfy the constraint that $R_{ij} = R_iR_j^T$. However, this condition is often not met due to the noise and outliers in practical relative measurement $\\tilde{R}_{ij}$.\nConsequently, we derive the definition of multiple rotation averaging as seeking a set of absolute orientation $R_V$ that best align with the observed relative rotations, i.e.,\n$R_V = \\underset{\\{R_1,R_2,..., R_N\\}}{argmin} \\sum_{e_{ij} \\in \\mathcal{E}} d(\\tilde{R}_{ij} - R_iR_j^T)^\\rho,$\nwhere $\\rho$ is typically set to 1 or 2.\nB. Eigen Decomposition and Matrix Reconstruction\nLet's start with a simpler case. Assume $\\mathcal{I}$ is a complete graph, with all relative rotations known. We can construct a 3N \u00d7 3N block matrix G by concatenating all pairwise rotation matrices. Additionally, we create a 3N \u00d7 3 matrix X by stacking all absolute orientations,\n$G = \\begin{bmatrix} I & R_{12} & \\cdots & R_{1N} \\\\ R_{21} & I & \\cdots & R_{2N} \\\\ : & : & \\cdots & : \\\\ R_{N1} & R_{N2} & \\cdots & I \\end{bmatrix}, X = \\begin{bmatrix} R_1 \\\\ R_2 \\\\ : \\\\ R_N \\end{bmatrix}$\nGiven that G can be expressed by $XX^T$ (i.e., $G = XX^T$), we can deduce that matrix G has a rank of 3. To estimate X from G, we can operate eigen decomposition on G and stack three eigenvectors to get a 3N \u00d7 3 matrix, then we project each 3\u00d73 submatrix to SO(3) to obtain valid orientation. For more details, we refer to the original work [18].\nBased on the eigen decomposition method, we can cast the MRA problem as a matrix reconstruction problem [27],"}, {"title": "IV. METHOD", "content": "Fig. 1 illustrates the pipeline of our method, which includes the spanning tree-based edge filtering and a constrained neural network with reweighting scheme. The spanning tree is constructed from all pairwise rotations to filter rotation outliers. Under the reweighting scheme, reliable pairwise rotations are used as supervision of a constrained neural network to compute absolute orientations with defined loss function.\nA. Spanning Tree-based Edge Filtering\nAlgorithm 1 Spanning tree-based edge filtering\nInput: pose graph $G = {\\mathcal{V}, \\mathcal{E}}$ and filter threshold \u03c3\nOutput: filtered pose graph $G'$\n1: set \u03a6 = {}\n2: for $e_{ij}$ in $\\mathcal{E}$ do\n3: set $\u0398_{ij}$ = {}\n4: for $v_k$ in $\\mathcal{V}$ do\n5: if $e_{ik}$ \u2208 $\\mathcal{E}$ and $e_{kj}$ \u2208 $\\mathcal{E}$ then\n6: add $\u03b4_{ij,k}$ to $\u0398_{ij}$ and \u03a6\n7: E = median(\u03a6)\n8: for $e_{ij}$ in $\\mathcal{E}$ do\n9: $\u03b4_{ij}$ = \u03a3$\u0398_{ij}$/|$\u0398_{ij}$| and $s_{ij}$ = 0\n10: for $\u03b4_{ij,k}$ in $\u0398_{ij}$ do\n11: $s_{ij} = s_{ij} + \\mathbb{1}(\u03b4_{ij,k} < \u03b5)$\n12: run greedy algorithm to build tree and generate $R^{tree}$\n13: for $e_{ij}$ in $\\mathcal{E}$ do\n14: if $d_{chord}(R_{ij}, R_{ij}^{tree}) > \u03c3$ then\n15: remove $e_{ij}$ from $\\mathcal{E}$\nThe pairwise rotations are usually provided by the upstream procedure, which are inevitably noisy. Although the further deep matrix factorization module is capable of denoising the input pose graph, it can still benefit from detection and exclusion of incorrect relative rotations.\nTo identify the outliers, we first construct a spanning tree of the input pose graph. This spanning tree provides pairwise rotation estimates between arbitrary vertices, and then we eliminate observed rotations that are inconsistent with the tree. Constructing the tree necessitates the assignment of attributes to each edge and the definition of comparison operations between them. With attributes and comparative relationships, we can apply the minimum spanning tree algorithm to construct the desired tree. The design of the edge attributes directly determines the selection of the final tree. We aim to assign attributes that entitle inlier edges with high priority and outlier edges with lower priority. In pose graph data, loop consistency serves as the most intuitive way for identifying anomalous edges. In this work, for simplicity, we utilize a triple loop. Consider three vertices i, j, and k, where all relative rotations between them are known, we define the loop error composed of edge $e_{ij}$ and vertex k as:\n$\u03b4_{ij,k} = d_{chord}(R_{ij}, R_{ik}R_{kj}).$\nIn an ideal, noise-free setting, for any loop, the \u03b4 should be close to zero. However, when at least one edge in the loop is an outlier, such deviation has a high probability of being significant. We use statistical information about the error \u03b4 among the graph to establish the attributes of each edge. Specifically, for each edge $e_{ij}$, we collect all loop errors composed by it to $\u0398_{ij}$, and the mean of $\u0398_{ij}$ is assigned to edge $e_{ij}$ as an attribute. However, the topological structure of input pose graph is unknown, and the degree of each vertex is typically not normally distributed. Therefore, using only the mean of loop errors is inappropriate, so we further count the support count $s_{ij}$ of each edge, i.e.,\n$s_{ij} = \\sum_{\u03b4_{ij,k}\\in\\Theta_{ij}} \\mathbb{1} (\u03b4_{ij,k} < \u03b5),$\nwhere $1(.)$ is indicator function. The threshold \u03b5 is set to the median of all triplet loop errors in the graph, making the method adaptable to varying input data.\nDuring the edge comparison, we first prioritize edges based on their support counts, with higher s values receiving higher priority. In cases where edges have the same support count, we arrange them in ascending order of mean error. Based on the comparison operations defined above, we can employ the Prim [28] or Kruskal [29] algorithm to construct the spanning tree.\nOnce we have obtained the desired spanning tree, it can be used to filter the outliers in the input pose graph. Following [23], we eliminate edges that do not conform with the relative rotations $R^{tree}$ provided by the tree, i.e.,\n$d_{chord}(R_{ij}, R_{ij}^{tree}) > \u03c3,$\nwhere \u03c3 is a predefined threshold.\nAlg. 1 summarizes our edge filtering method.\nB. Deep Matrix Factorization\nAs discussed in Sec. III, we have transformed the multiple rotation averaging into a matrix reconstruction problem. Here, we elucidate vanilla matrix reconstruction via deep matrix factorization and subsequently derive our proposed solution, which is more straightforward and applicable to the MRA problem.\nThe objective of the matrix reconstruction is to recover the complete matrix from a partially observed subset. Directly solving this problem is infeasible due to the existence of infinitely many valid solutions. To render this under determined problem manageable, certain assumptions must be introduced. Typically, matrix reconstruction is carried out under the assumption of low-rank. The low-rank assumption has a number of beneficial characteristics. For instance, it encourages cooperative relationships between columns and rows, which aids in understanding. In the context of our"}, {"title": "V. EXPERIMENTS", "content": "A. Baseline and Metric\nWe compare our method with the following methods: IRLS-l3 [10], EIG-IRLS [36], CEMP [37], MPLS [11], HARA [23], DMF-SYNCH [15]. The code of these algorithms are released by the authors.\nTo evaluate the accuracy, the predicted absolute camera orientations $R^{pred}$ are compared with ground truth camera orientations $R^{gt}$ in terms of mean(mn) and median(md) of angular errors $A = {d(R^{pred}_i, R^{gt}_iR^{align})}_1^N$. It is worth noting that the output camera rotations need to align with the ground truth by $R^{align}$ to resolve the gauge ambiguity.\nB. Results\nAll quantitative experiment results are shown in Tab. I. 1DSfM dataset [33] contains 15 outdoor scenes with ground-truth camera poses and relative orientations computed by Bundler [38], in our experiments, only the cameras with ground-truth orientations and the edges between these cameras are used. It can be seen that our approach achieves great performance in almost all scenes, with particular strength in the median metric where we achieved the best results on 13 of the 15 scenarios.\nETH dataset [39] is an outdoor point cloud dataset containing 4 scenes, each scene has about 33 scans, and the ground truth orientations of scans are provided. The input pose graphs are based on the pipeline in SGHR [6]. Our method continues to provide impressive results on this dataset, particularly on the challenging scene Wood summer. Stanford 3D dataset [40] is a famous object-level point cloud dataset, each object contains 10 to 15 frames and the ground truth orientations are also provided.\nFollowing the protocol in prior works [41], [42], we use Generalized-ICP [43] to obtain pairwise registration results. We can see that our method also provides distinguished or comparable results in this experiment, especially on Armadillo and Bunny. Qualitative results are shown in Fig. 4.\nC. Ablation Study\nTo assess the effectiveness of each component, we conduct ablation studies on the 1DSfM dataset. Tab. II provides a summary of the ablation results. We first assess the impact of spanning tree-based edge filtering in Exp. (a). Additionally, we evaluate a spanning tree based solely on the mean triplet error in Exp. (b), highlighting the importance of support count s, particularly on the mean error metric. In Exp. (c), we remove the low-rank and symmetric constraints and use a vanilla network architecture, the results illustrate that our bottleneck design effectively prevents network overfitting. Finally, in Exp. (d), we demonstrate that the reweighting scheme can further enhance accuracy."}, {"title": "VI. CONCLUSION", "content": "In this paper, we introduce a novel method for solving the multiple rotation averaging problem. Our approach begins with the utilization of a spanning tree-based edge filtering to mitigate the influence of outliers in input relative rotations. We then employ an explicitly low-rank and symmetric linear neural network to directly recover absolute orientations in a deep matrix factorization manner. Our model achieves unsupervised learning by relying solely on observed relative rotations as guidance. Additionally, we apply a reweighting scheme and a dynamic depth selection mechanism to further enhance the robustness. Experiments on various datasets validate the effectiveness of our method."}]}