{"title": "Hybrid Quantum-Classical Multi-Agent Pathfinding", "authors": ["Thore Gerlach", "Loong Kuan Lee", "Fr\u00e9d\u00e9ric Barbaresco", "Nico Piatkowski"], "abstract": "Multi-Agent Path Finding (MAPF) focuses on determining conflict-free paths for multiple agents navigating through a shared space to reach specified goal locations. This problem becomes computationally challenging, particularly when handling large numbers of agents, as frequently encountered in practical applications like coordinating autonomous vehicles. Quantum computing (QC) is a promising candidate in overcoming such limits. However, current quantum hardware is still in its infancy and thus limited in terms of computing power and error robustness. In this work, we present the first optimal hybrid quantum-classical MAPF algorithm which is based on branch-and-cut-and-prize. QC is integrated by iteratively solving QUBO problems, based on conflict graphs. Experiments on actual quantum hardware and results on benchmark data suggest that our approach dominates previous QUBO formulations and baseline MAPF solvers.", "sections": [{"title": "1 Introduction", "content": "Emerging domains of large-scale resource allocation problems, such as assigning road capacity to vehicles, warehouse management or 3D airspace to unmanned aerial vehicles (UAVs), often require multi-agent pathfinding (MAPF) [Stern et al., 2019; Choudhury et al., 2022; Li et al., 2021b] to determine feasible allocations. MAPF involves calculating non-colliding paths for a large number of agents simultaneously, presenting significant computational challenges in realistically sized scenarios. These challenges are becoming increasingly relevant in case of large-scale real-world applications. E.g., future UAV traffic in urban environments, driven by parcel delivery demands, is expected to involve the management of tens of thousands of flight paths [Doole et al., 2020].\nThe scalability of optimal state-of-the-art MAPF solvers is limited, since finding optimal solutions is NP-hard [Sharon et al., 2012]. Thus one often falls back to sub-optimal methods, with the most prominent one being Local Neighborhood Search (LNS) [Li et al., 2021a; Li et al., 2022; Huang et al., 2022a]. Even though such methods are computationally efficient in finding a feasible solution, the solution quality can be insufficient which implies the urge for optimal solution methods. By reformulating MAPF as a multi-commodity flow problem, it can be solved optimally via Integer Linear Programming (ILP). However, the reduction uses an inefficient representation of the problem setting in terms of space complexity and is only effective on small instances. More popular techniques for optimal MAPF include Conflict-based Search [Sharon et al., 2012] and Branch-and-Cut-and-Price (BCP) [Lam et al., 2019]. CBS is a two-level procedure, with splitting a search tree based on detected conflicts between agents and subsequent replanning. This tree is explored with best-first search until a collision-free node is found. BCP takes a different approach of considering a (possibly infeasible) solution which is then refined iteratively by successively adding paths and constraints. Similarly to CBS, BCP is a two-level algorithm: on the low level it solves a series of single-agent pathfinding problems, while the high level uses ILP to assign feasible paths to agents. While low level single agent pathfinding can be performed efficiently, the high level problems of both CBS and BCP remain NP-hard.\nQuantum computing (QC) is considered promising for tackling certain NP-hard combinatorial optimization (CO) problems. This is due to its potential to leverage quantum phenomena to solve certain types of problems faster than classical methods. The quantum mechanical effect of superposition enables exploration of a vast solution space in parallel, which is particularly advantageous for finding the best solution from a large set of possibilities. During this exploration quantum entanglement allows the encoding of high-order relationships among problem variables, leading to an effective exploration of the solution space. In particular, QC is suited for solving Quadratic Unconstrained Binary Optimization (QUBO) problems [Punnen, 2022]\n$$min \\ z^T Q z,\\ \\ z\\in\\{0,1\\}^n$$\nwhere Q is an n \u00d7 n real matrix and n is the number of qubits. Despite this simple problem structure, it is NP-hard and hence encompasses a wide range of real-world problems, such as chip design [Gerlach et al., 2024], flight gate assignment [Stollenwerk et al., 2019a] and trajectory planning [Stollenwerk et al., 2019b].\nQC's ability to address these problems stems from the adiabatic theorem [Albash and Lidar, 2018]: The Schr\u00f6dinger"}, {"title": "2 Related Work", "content": "Our algorithms are based on the BCP idea from [Lam et al., 2019]. Despite their optimality, such algorithms require a sophisticated branching strategy and are not guaranteed to find a good solution in reasonable time. An anytime adaption of MAPF BCP has been investigated [Lam et al., 2023], however further investigation of optimal anytime algorithms is of great interest. Heuristics are used for avoiding exponentially many branching steps, leading to efficient sub-optimal algorithms [Sadykov et al., 2019]. However, such rounding heuristics can lead to unsatisfying results, making the investigation of QC for this task intriguing.\nQC is a promising candidate for large-scale planning problems [Stollenwerk et al., 2019a; Li et al., 2024]. In the area of multi-agent problems, flow-problem formulations have been investigated [Ali et al., 2024; Zhang et al., 2021; Tarquini et al., 2024; Davies and Kalidindi, 2024]. These methods are edge-based, that is each edge in the spatio-temporal graph is represented by a qubit. Even though certain constraints can be conveniently integrated into the quantum state in this framework, the problem size is way beyond current quantum hardware capabilities and also infeasible for near-term devices.\nInstead of representing all edges in the given graph, [Mart\u00edn and Martin, 2023] takes a different approach considering which path to choose as decision variables. They introduce a QUBO formulation for the Unsplittable Multi-Commodity Flow problem by directly integrating the inequality constraints. Similar to BCP, they iteratively add paths to their problem. However, they present no theoretically sound criterion on when to stop, but have to rely on sub-optimal heuristics. Furthermore, the large amount of constraints have to be incorporated into the QUBO formulation which either leads to a huge number of auxiliary variables or the need for an iterative optimization scheme to adapt Lagrangian parameters [M\u00fccke and Gerlach, 2023]. [Stollenwerk et al., 2019b; Huang et al., 2022b] circumvent this problem by using conflict graphs for representing possible constraints. Their methods are not directly applicable to the MAPF setting, since only the starting times of pre-planned trajectories are optimized.\nWe combine the ideas of an iteratively expanding path-based approach with the concept of conflict graphs. A pricing criterion tells us when all variables are included which are part of an optimal solution. The proof is based on [R\u00f6nnberg and Larsson, 2019], which however assumes negativity on reduced costs. We loosen this assumption and adapt it for general applicability to MAPF."}, {"title": "3 Background", "content": "The following sections will formalize the MAPF (Sec. 3.1) problem and give a formulation of an optimization problems to solve it (Sec. 3.2). For notational convenience, we onforth denote matrices as bold capital letters (e.g. A), vectors as bold lowercase letters (a) and define B := {0, 1}.\n3.1 Multi-Agent Pathfinding\nThe input to the MAPF problem is a set of agents A, a weighted undirected graph G = (V, E) and an origin-destination pair for each agent. The graph G captures the underlying environment, where all possible agent states (e.g. location) are represented by V and E can be regarded as valid transitions from one state to another, with an underlying cost. V already captures environmental constraints, such as possible obstacles, while E captures motion constraints of the agents, e.g., velocity and maximum turning rates of UAVs. The goal of MAPF is now to find optimal paths from the origin to the destination for each agent, s.t. they avoid pairwise conflicts. For rating optimality, we use the objective of the sum of all weighted path lengths. We here consider classical collision conflicts, that is the vertex conflict and the (swapping) edge conflict. A vertex conflict between two agents exists if they move to the same node at the same time, while an edge conflict prohibits two agents to use the same edge at the same time. Introducing the time component, we also force the agents to start at different points in time, while also giving them the opportunity to wait a certain location.\nFor finding a solution to the MAPF problem, a spatio-temporal directed graph formulation is typically used. That is, we define GT = (Vr, Er) as the graph, with nodes v = (s, t) \u2208 V \u00d7 [T] and edges e = (v, v') = ((s,t), (s',t+1)) \u2208 VT \u00d7 Vr with weights we = W(s,s'), where (s, s') \u2208 E and T \u2208 N is a maximum allowed time horizon. We define the reverse edge of e = (s,t), (s', t + 1) as \u0113 := (s', t), (s, t + 1) for representing edge conflicts. Gr is an acyclic weighted directed graph with |Vr| = T|V| and |ET| = O (ST |V|), where S is the average number of possible state transitions. For example, if we consider the classical two-dimensional grid environment, an agent has five possible state transitions, i.e., wait, go north, go east, go south and go west.\nEvery agent a \u2208 A is obliged to find a path in Gr from origin (oa, ta) \u2208 Vr to destination (da, ta + Ta) \u2208 Vr for a starting time ta \u2208 [T] and Ta\u2264 T-ta. A path p is a sequence of edges p := (e1,..., eTa\u22121), s.t. et = ((x, ta + t), (y, ta+t+1)), et+1 = ((y,ta+t+1), (z,ta+t+2)), e\u2081 = ((oa,ta), (s, ta + 1)) and e\u0442\uff61 = ((s, ta + Ta \u2212 1), (da, ta + Ta)). The cost/length cp of a path p is defined as the sum of all its edge weights, i.e., Cp := \u2211eep We. Specifically, we go over to the mathematical description of the MAPF objective.\n3.2 Path-Based Formulation\nWe encode each possible path p \u2208 P for every agent by zp \u2208 B. An ILP formulation is given by:\nMP: min $$\\sum_{a\\in A} \\sum_{p\\in P_a} C_p z_p$$\n$$\\sum_{p\\in P_a} z_p = 1, \\ \\forall a \\in A$$\n$$\\sum_{a\\in A} \\sum_{p\\in P_a} x_p^v z_p \\leq 1, \\ \\forall v \\in V_T$$\n$$\\sum_{a\\in A} \\sum_{p\\in P_a} (y_p^e + y_p^{\\bar{e}}) z_p \\leq 1, \\ \\forall e \\in E_T,$$\nwhere x_p^v, y_p^e \u2208 B indicate whether path p visits vertex v \u2208 Vr / edge e \u2208 \u0415\u0442, Pa indicates the set of all possible paths for agent a and N = |P|, P = Ua\u2208A |Pa|. Note that x_p^v, y_p^e are constant and we just optimize over zp. The constraint in (2b) ensures that exactly one path is chosen for every agent, while (2c) and (2d) avoid conflicts. We denote (2) as the master problem (MP).\nWe have VT constraints for avoiding vertex conflicts and |ET| constraints for avoiding swapping conflicts,. The number of our decision variables representing possible solutions now corresponds to the number of all possible paths for all agents, which is exponential in the maximum time horizon, N = O(|A|ST). A large maximum time T or number of agents |A| can make the problem size increase very quickly, making it infeasible to solve it with current NISQ devices."}, {"title": "4 Methodology", "content": "Not only the huge number of decision variables poses a challenge for current quantum computers, but also the number of constraints strongly impacts the QUBO formulation. We overcome this issue by considering the restricted master problem (RMP) which optimizes over a subset of decision variables\nRMP: min $$c^T x$$\ns.t. $$Dx \\leq 1,$$\n\u03bb\u2208 R and the LR of the RMP is defined as\nLR : L(A) := min L(x, A) = min c(x) \u2013 A1, (4)\nwhere c(x) := c + XTD is the Lagrangian reduced cost vector. Note that L(A) \u2264 v(RMP), where v(\u00b7) indicates the optimal value of the optimization problem.\nTheorem 1. Let \u00fb be the objective value of a feasible solution to RMP, A \u2208 Rr. If v(RMP) \u2260 v(MP) then\n\u039e\u03b1\u2208 A : min \\ min p(x) < \u00fb \u2013 L(A). (5)\nProof. We give a proof by showing that v(RMP) = v(MP) holds if (5) does not hold. The path variables not in RMP are implicitely assumed to take the value 0. Assume now, that one variable not included in the RMP takes value 1 for agent \u03b1 \u20ac \u0391, i.e., \u03a3\u03c1\u03b5Pa\\Pa Xp \u2265 1. It follows that\nv (MP) = min x_p Dx \u2264 1, x_p\u2265 1 \nminx\u2211 cpXp + minx\u2211 cpXp \u2212 \u03bbT1\u2211 xp\u22651\nminx c(x)x + minx c(x) \u2013 \u03bbT1 (6d)\nmin (c(x) + min (x) \u2013 1 (6e)\nminxp x+ minxp\u2212\u03bbT1(6f)\nwith Pa = Pa \\ Pa and X = {x \u2208 BN | \u03a3p\u03b5\u03c1\u03b1 Xp = 1, \u03bd\u03b1 \u2208 A}. (6g) holds since we assume that (5) does not hold. We follow that no feasible solution to MP with \u03a3p\u20acPa\\PaXp \u2265 1 can be better than an optimal solution to RMP for each a \u2208 A. As all paths not included in the RMP are in the set Ua\u2208 A Pa \\ Pa and v(MP) \u2264 v(RMP) is always true, we conclude v(MP) = v(RMP). Hence, if v(MP) \u2260 v(RMP) then (5) holds.\nThis theorem leads to an optimality criterion, telling us when the variables in the RMP contain the ones for an optimal solution to the MP. The PP aims to find a path not already included in the RMP with optimal reduced costs not included\nPP: min p(x). (7)\nEven though Pa \\ Pa can be exponentially large, (7) can be solved efficiently. It boils down to a k shortest path problem (kPa) on the graph Gr with updated edge weights\u2014e is added to the cost of we and we for conflicted edges and \u03bb\u03c5 is added to all incoming edges to conflicted vertices. This is"}, {"title": "4.3 Solving RMP with QUBO", "content": "It remains to clarify how to obtain a solution of (3). Since we want the solutions to be solvable with QC, we reformulate the constrained problems into QUBO formulations. We have a look at three different approaches, which all rely on using penalty factors to integrate constraints. The one-hot constraint given in X (2b) can be integrated (see [Lucas, 2014]). It remains to incorporate the inequality constraints.\nSlack Variables\nThe first approach inserts slack variables for every inequality constraint, similar to [Davies and Kalidindi, 2024]. This is often pursued in practice but can lead to large number of variables, especially when the number of constraints is large. The linear inequality constraint in (3) can be reformulated with using an auxiliary vector s \u2208 Bn with binary entries Dx < 1 \u21d4 Dx \u2212 1 + s = 0, where < denotes entry-wise inequality. This leads to the slightly different but equivalent problem min\u2208x c\u00afx, s.t. Dx \u2212 1 + s = 0, s\u2208 Bm This constrained problem can then be reformulated to an equivalent unconstrained problem by introducing a penalty parameter ws > 0\nmin $$c^T x + w_s ||Dx - 1 + s||^2$$,\nUsing this formulation, however, comes with the overhead of introducing m additional binary variables, one for every\nSince D\u2208 Bmxn, we can avoid using slack variables by using the equivalence\nmin ||Dx \u2212 1 + s|| min Dx 12 (9)\nThus, we do not optimize over any slack variables and reduce the corresponding QUBO size.\nConflict Graph\nAs a third concept, we have a look into conflict graphs (CG). The vertices of such a graph correspond to all paths considered in the problem and the edges indicate whether there is at least one conflict between a pair of paths. An examplary schematic visualization of a conflict graph is given in Fig. 2. We denote the adjacency matrix of CG graph as C. The problem in (3) has the equivalent formulation\nmin $$c^T x + w_c x^T C x,$$\nwhere wc \u2208 R+ penalizes potential conflicts. Note that it is square and the dimension is only dependent on the number of considered paths and not on the number of constraints. Since the structure of the CG depends on the underlying problem, it may contain several connected components. Thus, the graph of the QUBO matrix can have multiple connected components, dependent on C. These connected components can be seen as smaller instances, giving us the ability to solve them independently. This can lead to large reduction of the considered problem sizes, which is very vital for current QCs, due to the limited number of available qubits. Furthermore, a lower density and well-behaved problem structure can have a huge effect on current quantum hardware.\nThis leads to two different hybrid quantum-classical MAPF algorithms. QUBO-and-Price (QP) describes generating new paths and stopping when (5) is violated (inner loop in Fig. 1)."}, {"title": "5 Experiments", "content": "We compare our algorithms QP and QCP with two state-of-the-art MAPF solvers: BCP [Lam et al., 2019] and LNS2 [Li et al., 2022]. BCP is an optimal algorithm but has also been adapted to anytime, while the sub-optimal LNS2 can quickly generate a good solution. The code was taken from their respective public repositories23. We kept all standard parameters and set a maximum time limit of 180 s for both solvers. The experiments were conducted on a single core of the type Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz.\nFor QP and QCP we generate the initial paths with prioritized path planning (PPP) [Ma et al., 2019], i.e., every agent is planned successively, with removing edges and nodes of previously planned paths. No clever priorization heuristic is followed, we randomly sample which agent to be chosen next. We us a maximum limit of 30 pricing steps in total and compute optimal Lagrangian parameters \u5165* with LP in every iteration. We compare the optimal solution of the RMP obtained by an ILP Brach-and-Bound method with the solutions obtained by two different QUBO solvers. As a classical baseline, we use the Simulated Annealing (SA) implementation of D-Wave and for real quantum hardware, we run experiments on a D-Wave Advantage_system5.4 quantum annealer (QA).\nSince both solvers are probabilistic, we generate 1,000 samples each and use default parameters. We compare the three different QUBO formulations from Sec. 4.3 and denote them by SLACK (8), HALF (9) and CONFLICT (10).\nAs maps and instances, we use the in the MAPF community well-known MovingAI benchmark [Stern et al., 2019]. This benchmark includes 33 maps and 25 random scenarios, some of which were utilized in our experiments. Each scenario on each map (with some exceptions) consists of 1, 000 start-goal position pairs. To evaluate a solver on a given scenario, we run it on the first 20, 40, 60, 80 and 100 start-goal pairs.\nAlgorithm Performance In Fig. 3, we depict the performance of our two algorithms QP and QCP for four different maps, namely random-32-32-10, maze-32-32-4, room-64-64-8 and den312d. All performances are shown relative to the best and worst performing configuration, i.e., Vrel :=(v - Ubest)/(Uworst - Ubest) and averaged over all 25 scenarios. This maps all obtained values to the range [0, 1], where 0 indicates the best and 1 the worst performance, respectively. For QC-QUBO and QCP-QUBO we use the CONFLICT formulation and the SA solver.\nThe top plot row shows the upper bound \u00ee v(LD) on the optimality gap for a different number of agents. It is not only a measure of solution quality, but it also quantifies the problem size. The higher this gap is, the more new paths are added to our problem during pricing, since it corresponds to the RHS in our optimality criterion (5). We can see that optimally solving the RMP (QCP-ILP and QP-ILP) has a smaller gap than generating a possibly sub-optimal solution a QUBO solver. However, the QUBO methods largely improve upon the base PPP method. Even though QP clearly outperforms QCP for optimal solving (ILP) of RMP, QCP takes way less constraints into account and is thus computationally more efficient. This is also beneficial for the QUBO solvers, since they can easier generate good solutions for a\nmore well-behaved problem (less constraints).\nThe mean relative total path cost for the single MAPF instances are depicted in the bottom plot row. We compare the baselines PPP, BCP and LNS2 with QP solving the RMP optimally (QP-ILP) and with QUBO (QP-QUBO). If BCP does not return any solution in the given time window, we set its performance to the worst other performing method (PPP), allowing for a naive anytime comparison. It is evident that QP-ILP is nearly almost optimal, while LNS2 is able to outperform it for 80 and 100 agents for maze-32-32-4. BCP is always outperformed by our methods and LNS2 due to its bad anytime performance. However, it is interesting that for no map it is able to find all optimal solutions. QP-QUBO is able to outperform LNS2 in many cases, making our method already applicable without the need of exactly solving the RMP.\nThe most time consuming step in our algorithm is to solve the QUBO problem. However, a wall-clock time comparison is difficult for quantum devices nowadays, since there is a large communication overhead when using real quantum hardware over cloud services. Nevertheless, assuming perfect communication with the QA, we can generate solutions to a QUBO with an annealing time of 50\u00b5s. Due to its probabilistic nature, we have to generate a only few thousand samples. In the near future, this could also lead to very good wall-clock time performance.\nQUBO Comparison The effect of using different QUBO formulations for solving the RMP is depicted in Fig. 4.\nWe consider four different maps (maze-32-32-4, empty-32-32, random-32-32-10, room-32-32-4) and compare the results of QP (Fig. 4a) and QCP (Fig. 4b) for 20 agents. This leads to varying QUBO sizes between 20 and 400, depending on the underlying map and scenario. We use SA and QA for solving HALF and CONFLICT for QP and HALF and SLACK for QCP.\nIn the top row, we show the cost of the best sample obtained by SA and QA over all 25 scenarios, along with the optimal solution (ILP). Only feasible samples are indicated here, that is only those who adhere the constraints. For QP, we can see that finding a feasible solution with the HALF QUBO is nearly almost optimal while the solution quality of CONFLICT slightly deteriorates. Comparing HALF and SLACK for QCP, we find that both solvers are able to find optimal solutions. However, QA has problems finding feasible solutions for the first map for all QUBO formulations.\nThe number of infeasible solutions returned by SA and QA is depicted in the bottom row. While SA always finds feasible solutions for HALF, it is easier for QA to obtain feasibility with CONFLICT. This is due to the sparsity advantage of CONFLICT over HALF and the corresponding decomposition into independent sub-problems. Since the hardware topology of current quantum computers is strongly limited, such properties have a large effect on the solution quality obtained. For QCP, we find that QA finds slightly more feasible solutions with HALF than SLACK. However, we note that only a few separation steps happened and thus only a small number of constraints have been generated. Using more pricing steps or scaling up the problem size would lead to way more included constraints, making the SLACK QUBO infeasible to solve."}, {"title": "6 Conclusion", "content": "In this paper, we presented two novel optimal hybrid quantum-classical MAPF algorithms. Extending the classical approach of Branch-and-Price-and-Cut, we circumvent exponentially many branching steps. On an ideal adiabatic quantum processor, the QUBO sub-problems are solved to global optimality. We proof a generalization of the classically known criterion telling us that our currently available path set is optimal. Experiments indicate good performance of our algorithm compared to state-of-the-art MAPF algorithms. Evaluating different QUBO formulations indicates the superiority of our approaches over previously presented methods. The hardware-aware design of the QUBO problems can already lead to an advantage on near-term quantum devices."}]}