{"title": "Double-Ended Synthesis Planning with Goal-Constrained Bidirectional Search", "authors": ["Kevin Yu", "Jihye Roh", "Ziang Li", "Wenhao Gao", "Runzhong Wang", "Connor W. Coley"], "abstract": "Computer-aided synthesis planning (CASP) algorithms have demonstrated expert-level abilities in planning retrosynthetic routes to molecules of low to moderate complexity. However, current search methods assume the sufficiency of reaching arbitrary building blocks, failing to address the common real-world constraint where using specific molecules is desired. To this end, we present a formulation of synthesis planning with starting material constraints. Under this formulation, we propose Double-Ended Synthesis Planning (DESP), a novel CASP algorithm under a bidirectional graph search scheme that interleaves expansions from the target and from the goal starting materials to ensure constraint satisfiability. The search algorithm is guided by a goal-conditioned cost network learned offline from a partially observed hypergraph of valid chemical reactions. We demonstrate the utility of DESP in improving solve rates and reducing the number of search expansions by biasing synthesis planning towards expert goals on multiple new benchmarks. DESP can make use of existing one-step retrosynthesis models, and we anticipate its performance to scale as these one-step model capabilities improve.", "sections": [{"title": "1 Introduction", "content": "Synthesis planning\u2014proposing a series of chemical reactions starting from purchasable building blocks to synthesize one or more target molecules is a fundamental task in chemistry. For decades, chemists have approached the challenge of synthesis planning with retrosynthetic analysis [1, 2], the strategy by which a target molecule is recursively broken down into simple precursors with reversed reactions. In recent years, advances in machine learning have enabled a multitude of computer-aided synthesis planning (CASP) algorithms [3-6] that navigate a combinatorially large space of reactions to propose chemically sensible routes to a variety of drug-like molecules within seconds to minutes. However, fully data-driven algorithms still underperform when generalizing to realistic use cases such as planning for more complex targets or in constrained solution spaces. In practice, expert chemists may plan syntheses with specific starting materials in mind, called \"structure-goals\" [1], that constrain the solution space. For instance, efficient syntheses of highly complex drugs are often most practical when synthesized from naturally-occurring starting materials that share complex features with the target, a practice known as \u201csemi-synthesis\" [7, 8]. There is also immense interest in identifying pathways from waste or sustainable feedstocks to useful chemicals [9\u201311], but existing methods have thus far relied on heuristics and brute-force enumeration of reactions.\nThough algorithms for planning synthetic routes from expert-specified starting materials have been proposed [12, 13], the vast majority of CASP algorithms today cannot address starting material-"}, {"title": "2 Background", "content": ""}, {"title": "2.1 Related work", "content": "Computer-aided retrosynthetic analysis Retrosynthetic analysis has traditionally been formulated as a tree search problem, where each step involves searching for chemically feasible transformations and corresponding reagents to derive the product molecule. In defining the feasible transformation,"}, {"title": "2.2 Formulation of general and starting material-constrained synthesis planning problems", "content": "General synthesis planning In this work, we only consider template-based retrosynthesis methods, though any single-step model is compatible with our algorithm. Let M be the set of all valid molecules, R be the set of all valid reactions, and T be the set of all valid reaction templates. A reaction \\(R_i \\in R\\) is a tuple \\((r_i, p_i, t_i)\\), comprising a set of reactants \\(r_i \\subset M\\), a single product \\(p_i \\in M\\), and a retro template \\(t_i \\in T\\). A retro template t is a function \\(t : M \\rightarrow 2^M\\) that maps a product to precursors such that \\(\\forall i : r_i \\in t(p_i)\\). Likewise, a forward template \\(t' \\in T'\\) is a function \\(t' : 2^M \\rightarrow M\\) where \\(\\forall i : p_i \\in t'(r_i)\\).\nGiven target molecule \\(p^* \\in M\\) and set of building blocks (BBs) \\(B \\subset M\\), synthesis planning finds a valid synthetic route-a set of reactions \\(S = \\{R_1,... R_n\\}\\) that satisfies the following constraints.\nConstraint 1 (Synthesize all non-BBs). \\(\\forall i : m \\in r_i, m \\notin B \\Rightarrow \\exists j s.t. m = p_j;\\)\nConstraint 2 (Target is final molecule synthesized). \\(\\exists i s.t. p_i = p^*, \\forall i : p^* \\notin r_i;\\)"}, {"title": "3 Methods", "content": "DESP is built on the Retro* algorithm [6] and recent advances that enable conditional generation of synthetic routes from the bottom up [41, 42]."}, {"title": "3.1 Definition of synthetic distance, a goal-conditioned cost function", "content": "Like Retro* [6], DESP is an A*-like search and thus requires a method of evaluating the expected cost of various frontier nodes. We follow Retro* and use the notation of \\(V_t(m|T)\\), \\(V_m\\), and \\(r_n\\) functions (Section A.2 details Retro* and these functions). We also define a function \\(c : R \\rightarrow R\\) which maps a reaction to a scalar cost. For a valid synthetic route \\(S = \\{R_1,..., R_n\\}\\), the total cost of S is \\(\\sum_{i=1}^{n} c(R_i)\\). \\(V_m\\) represents the minimum total cost across every valid synthetic route to molecule m, and is learned in Retro* and DESP to bias the search towards B.\nHowever, to maintain consistency in guiding A* search in the starting material-constrained setting, we require not only an estimate of the cost of synthesizing molecule m from arbitrary building blocks, but also an estimate of the cost of synthesizing molecule \\(m_2\\) from \\(m_1\\) specifically (in addition to other arbitrary building blocks). As such, we define a new function \\(D : M \\times M \\rightarrow R\\), which we term synthetic distance, as it effectively represents the minimum cost distance between two molecules in G, the graph constructed from the set of all possible reaction tuples R. More precisely, the synthetic distance from \\(m_1\\) to \\(m_2\\) is the difference between the minimum cost of synthesizing \\(m_2\\) across all valid synthetic routes containing \\(m_1\\) and the minimum cost of synthesizing \\(m_1\\) across all valid synthetic routes in general. Learning D then allows for the guidance of both top-down search towards the starting material and bottom-up search towards the target with rapid node comparisons."}, {"title": "3.2 DESP algorithm overview", "content": "In practice, synthesis planning problems are generally approached by simulating a search through the complete reaction graph G. We follow Xie et al. [30] in considering an AND-OR graph structure for search graphs, in which molecules are represented by OR nodes (only one child must be solved) and reactions are represented by AND nodes (all children must be solved). In implementing most synthesis planning algorithms [3, 6], one initializes the search graph \\(G = \\{p^*\\}\\). With DESP, we instead initialize two search graphs \\(G_R = \\{p^*\\}, G_F = \\{r^*\\}\\) and introduce two expansion policies, one for \"top-down\" retrosynthesis expansions on \\(G_R\\) and another for \u201cbottom-up\" forward expansions on \\(G_F\\). This allows us to perform a bidirectional graph search between the target and goal molecules by interleaving retro and forward expansions, with the goal of the two search graphs converging to more efficiently find a valid synthetic route. In this work, we implement F2E and F2F variants of DESP. Notably, our implementation of F2F performs node comparisons to all nodes in the opposing search graph rather than just frontiers. For \\(m\\in G_R\\), we define a goal function \\(\\gamma : M \\rightarrow M\\) such that \\(\\gamma(m) = r^*\\) in F2E and \\(\\gamma(m) = arg\\min_{g' \\in G_F} D(g', m)\\) in F2F. Likewise, for \\(m \\in G_F\\), let \\(\\gamma(m) = p^*\\) in F2E and \\(\\gamma(m) = arg\\min_{g' \\in G_R} D(m, g')\\) in F2F.\nThe following quantities or functions are relevant in the algorithm: \\(r_n\\), \\(V_t(m|G)\\), and \\(V_m\\) from Retro*, and somewhat analogously \\(d_n\\), \\(D_t(m|G_R)\\), and \\(D_m\\). We briefly define the new quantities: (1) \\(D_m\\) represents \\(D(\\gamma(m), m)\\). (2) \\(d_n(m|G_R)\\) represents the \u201cdistance numbers\" of a top node m.\""}, {"title": "4 Experiments", "content": "Our experiments are designed to answer the following: (1) Does DESP significantly improve the performance of starting material-constrained synthesis planning compared to baseline methods? (2) To what extent do D and bidirectional search account for the performance of DESP? (3) Can DESP find routes to more complex targets than baseline methods? (4) What empirical differences do we see between F2E and F2F strategies?"}, {"title": "4.1 Experimental setup", "content": "Datasets Few public datasets of multi-step synthetic routes exist. Previous works in multi-step synthesis planning have widely used the USPTO-190 dataset [6], a set of 190 targets with corre-sponding routes extracted from the USPTO-Full dataset. Others have tested on targets sampled from databases such as ChEMBL or GDB17 [57, 27, 31], but their lack of ground truth routes precludes the systematic selection of starting materials for our task. PaRoutes [58] has been proposed as an evaluation set, but they do not provide a standardized training set to prevent data leakage.\nIn addition to USPTO-190, because of its large proportion of out-of-distribution and redundant reactions (Table 1), we create and release two additional benchmark sets, which we call Pistachio Reachable and Pistachio Hard. Details of their construction are provided in Section A.6. To obtain the ground-truth goal molecules for each of our test sets, we find the longest path from target to leaf node in each route DAG and pick the leaf node with more heavy atoms. For the building block set B, we canonicalize all SMILES strings in the set of 23 million purchasable building blocks from eMolecules used by Chen et al. [6].\nModel training As in [6], we train a single-step retrosynthesis MLP (NeuralSym) and Retro* cost network on our processed training split of USPTO-Full. The synthetic distance and forward expansion models are trained as described in Sections 3.4 and A.4.\nMulti-step algorithms Because we utilize an AND-OR search graph with no duplicate molecule nodes, our implementation of Retro* is more comparable to RetroGraph [30], but we do not employ"}, {"title": "4.2 Results", "content": "Though it is notoriously difficult to quantita-tively evaluate synthetic routes proposed in sil-ico without expert evaluation, there are widely-used metrics thought to correlate with successfulalgorithms, such as higher solve rate (under vary-ing computational budgets), lower average num-ber of expansions, and lower average number ofreactions in found routes [59, 57]. We focus onthese metrics, as they are arguably most relatedto a search algorithm's efficiency. Because allmethods employ the same one-step model and"}, {"title": "5 Conclusion", "content": "In this work, we introduce DESP, a novel framework for bidirectional search as applied to computer-aided synthesis planning. DESP biases searches towards user-specified starting materials with a combination of a learned synthetic distance network and bottom-up generation of part of the synthetic route. This represents a task that aligns with a common use case in complex molecule synthesis planning. We demonstrate the efficiency of DESP on the USPTO-190 dataset and two new test sets derived from the Pistachio database. When compared to existing methods, both variants of DESP"}, {"title": "A Appendix / supplemental material", "content": ""}, {"title": "A.1 Summary of notation", "content": ""}, {"title": "A.2 Retro* algorithm details", "content": "Retro* defines the following quantities:\n1. \\(V_m\\). For a molecule m, \\(V_m\\) is an unconditional estimate of the minimum cost required to synthesize m. It is estimated by a neural network.\n2. \\(r_n(m|G)\\). For a molecule m, given search graph G, the \u201creaction number\" \\(r_n(m|G)\\) represents the estimated minimum cost of synthesizing m.\n3. \\(V_t(m|G)\\). For a molecule m, given search graph G with goal p*, \\(V_t(m|G)\\) represents the estimated minimum cost of synthesizing p* using m.\nRetro* also cycles between selection, expansion, and update phases. We implement Retro* as follows.\nSelection The molecule in the set of frontier nodes F that minimizes the expected cost of synthe-sizing p* given the current search graph G is selected:\n\\[m_{select} = arg\\min_{m \\in F} V_t(m|G) \\]\nExpansion As in Alg. 2, a one-step retrosynthesis model is called on the selected node and the resulting reactions and precursors are added to G. Each molecule node is then initialized with \\(r_n(m|G) \\leftarrow V_m\\)."}, {"title": "A.3 Reaction pre-processing", "content": "Reactions in the USPTO-Full dataset are represented with simplified molecular-input line-entry system (SMILES) [62] strings, where the SMILES string of reactants, reagents, and products are separated by '>' as REACTANTS>REAGENTS>PRODUCTS. Each field can have one or more chemical species delineated with a dot (.) or be left blank in the case of reagents.\nFor processing reaction SMILES, multi-product reaction SMILES are first separated into single-product reaction SMILES by creating separate entries for each product species with the same reactants and reagents. Each single-product reaction SMILES then undergoes the following process:\n1. Reagents in the SMILES string are moved to the reactant side.\n2. Chemical species with identical atom mapped SMILES in both reactants and products are moved to reagents.\n3. Any products that do not contain at least one mapped atom or have fewer than 5 heavy atoms are removed.\n4. Any atom mapping numbers that exist exclusively on either the reactant side or product side are removed.\n5. Any reactants without atom mapping are moved to the reagent side.\nResulting reaction SMILES without either reactants or products are then filtered out."}, {"title": "A.4 Model training details", "content": ""}, {"title": "Dataset construction", "content": "To learn \\(f_t\\) and \\(f_b\\), a full enumeration of all pathways (until reaching nodes in B) rooted at \\(p^*\\) is performed for each molecule node \\(p^*\\) in \\(G_{FWD}\\). For learning \\(f_t\\), each reaction node \\(R_i = (r_i, p_i, t_i)\\) is then used as a training example for each reactant \\(m_j \\in r_i\\) with input \\(z_m(m_j) \\oplus z_m(p^*)\\) and one-hot encoded label \\(t_i\\). Likewise, for learning \\(f_b\\), each reaction node \\(R_i = (\\{m_1, m_2\\}, p_i, t_i)\\) that is bimolecular and involves at least one building block yields a training example with input \\(z_m(m_1) \\oplus z_m(p^*)\\oplus z_t(t_i)\\) and output \\(z_{m_2}(m_2)\\) if \\(m_2 \\in B\\) and with input \\(z_m(m_2) \\oplus z_m(p^*)\\oplus z_t(t_i)\\) and output \\(z_{m_2}(m_1)\\) if \\(m_1 \\in B\\). The procedure for such training example generation is illustrated in Fig. 5. With \\(n_1 = 2048\\), \\(n_2 = 256\\), we use the RDKit implementation of the Morgan Fingerprint [63] with radius 2 for \\(z_m\\) and the Atom Pair fingerprint [64] for \\(z_t\\).\nBecause D is used to bias both the top-down and bottom-up searches, we perform the same pathway enumeration for all molecule nodes \\(p^* \\notin B\\), \\(p^* \\in G_{USPTO}\\). In this case, however, we only consider \\(p^*\\) for which we find valid synthetic routes. Training examples are then extracted for all other molecule nodes \\(m_i\\) in a solved search graph, with input \\(z_m(m_i) \\oplus z_m(p^*)\\) and label \\(V_{p^*}(m_i|G_R)-r_n(m_i|G_R)\\), with \\(n = 512\\). For calculating this label, we propagate the Retro* functions as described in Section A.2 such that D can be calculated as the minimum cost of synthesizing \\(p^*\\) subtracted by the minimum cost of synthesizing \\(m_i\\). Here, we set \\(c(R_i) = 1\\) for all \\(R_i\\), as a synthetic route's number of steps is an important metric in evaluating the route cost, and it is otherwise difficult to objectively quantify the cost of a reaction. This training example generation is also depicted in Fig. 5. Finally, to obtain additional training examples, we also recover pairs of \\((m,p^*)\\) where \\(p^*\\) was not \u201csolved\u201d by the enumerative search but would have been solved if \\(m\\in B\\).\nFor validation of the \\(f_t\\) and \\(f_b\\) models, we construct the graph \\(G_{val}\\) corresponding to all reactions across both the training and validation splits. We perform the same pathway enumeration described above, and each \u201ctraining example\u201d that corresponds to a reaction not in the original training split is used as a validation example. For validation of the D model, we construct \\(G_{val}\\) from \\(R_{USPTO}\\) and perform the pathway enumeration only on \\(p^* \\notin G_{USPTO}\\) to obtain validation examples."}, {"title": "Model hyperparameters", "content": "All models are MLPs trained with the Adam optimizer, early stopping (patience 2), and decayed learning rate on plateau with factor 0.3 and patience 1 on a single NVIDIA RTX 4090. The following table summarizes the hyperparameters and details of each model used in experiments."}, {"title": "A.5 DESP additional details", "content": "Algorithm 2: RETRO_EXPAND(M, GR, N)\nm: expanded molecule node, GR: top search graph, N: num. templates to propose\nt \u2190 TOP_N(\\(\\sigma(MLP_R(z_m(m)))\\)); /* Get top N templates from retro model */\nfor i \u2190 1 to N do\nr \u2190 t[i](m); /* Apply retro template to m */\nGR.ADD_RXN(r, m, t[i]); /* Add reaction and precursors to GR */\nend\nDesign of new quantities and update rules We recall that the minimum total cost of synthesizing the target p* from a molecule m under the Retro* framework is estimated as:\n\\[V_t(m|G_R) = \\sum_{r \\in A_r (m|G_R)} c(r) + \\sum_{m' \\in V_m (G_R), pr(m') \\in A_r(m|G_R)} r_n(m'|G_R)\\]\nwhere \\(A(m|G_R)\\) represents the set of reaction node ancestors of m and \\(V_m(G_R)\\) represents the set of molecule nodes in the search graph. This is equivalent to\n\\[V_t(m|G_R) = g(m|G_R) + \\sum_{m' \\in N(m|G_R)} V_{m'}\\]\nwhere \\(g(m|G_R)\\) aggregates the current cost from all reaction nodes in \\(G_R\\) contributing to \\(V_t(m|G_R)\\), and \\(N(m|G_R) \\subseteq F_R\\) accordingly represents the set of frontier top nodes for the subgraph of \\(G_R\\) corresponding to nodes contributing to \\(V_t(m|G_R)\\). If we add the constraint that one frontier node must implicitly be the ancestor of r*, the estimate of the minimal cost then becomes:\n\\[\\begin{aligned}\nV_t(m|G_R) &= g(m|G_R) + \\min_{m_j \\in N(m|G_R)} \\bigg(\\sum_{m_i \\in N(m|G_R), m_i \\neq m_j} V_{m_i} + D(r^*, m_j)\\bigg) \\\\\n&= g(m|G_R) + \\sum_{m_i \\in N(m|G_R)} V_{m_i} + \\min_{m_j \\in N(m|G_R)} \\big(D(r^*, m_j) - V_{m_j}\\big) \\\\\n&= V_t(m|G_R) + \\min_{m_j \\in N(m|G_R)} D_{m_j}\n\\end{aligned}\\]\nOur update rules are implemented such that \\(D_t(m|G_R) = \\min_{m_j \\in N(m|G_R)} D_{m_j}\\), thus justifying our design of the selection and update procedures. Note that this design relies on the assumption that \\(N(m|G_R)\\) remains static upon adding the goal node constraint, when in reality the introduction of D may change the optimal set of frontier nodes to consider in the search graph. To avoid the combinatorial complexity of this situation and retain the efficiency from dynamic programming for our update policy, we maintain this assumption and find that introducing D in this way empirically works well (Section 4.2)."}, {"title": "A.6 New benchmark set details", "content": "We follow the test set extraction procedure of Chen et al. [6], applied within patents of the Pistachio dataset [14] (version: 2023Q4) to obtain 1,004,092 valid synthetic routes. We randomly sample synthetic routes from this set until we obtained 150 routes that satisfied the following constraints: (1) No reactions in the route are found in the training data. (2) No reactions are shared between any routes within the test set. (3) All reactions are found in the top 50 proposals of our single-step retrosynthesis model. (4) No two targets in the test set have a Tanimoto similarity of more than 0.7. (5) We enforce a minimum number of routes for different route lengths (Fig. 7, Fig. 8). We term this set of 150 routes Pistachio Reachable. We perform the same procedure but modify condition (2) to require only 50% or more of the reactions to be reproducible (in-distribution) and obtain 100 routes which we term Pistachio Hard. Due to a bug in our implementation of criterion (2), a small number of routes share the same reaction in the final datasets, but the degree of inter-route reaction duplication is still significantly less than that of USPTO-190 for both benchmark sets (Table 1)."}, {"title": "A.7 Additional experimental details", "content": "Implementation details For random search, all node selections were performed at random among frontier molecule nodes. For BFS, the molecule with the lowest depth was selected at each step, with precedence for nodes whose parent reactions had the highest plausibility scores from the retro one-step model. MCTS was run by integrating our one-step model into the open-source ASKCOS code base [65]. For Retro*, we removed the synthetic distance network and bottom-up expansions from our DESP implementation. Notably, reaction costs for Retro* and DESP are both calculated"}, {"title": "A.8 Limitations and Outlook", "content": "Convergent syntheses Convergent synthetic routes, in which multiple non-BBs are combined, are often desirable in chemistry due to their relative efficiency. The top-down search has no problems proposing convergent routes. However, the bottom-up searcher in DESP only performs forward expansions and thus cannot handle convergent routes by adding and merging new synthetic trees. Resultantly, the bottom-up search can only plan one branch if the final route requires convergent steps. Implementing additional modules of SynNet [42] into the bottom-up search would enable planning of convergent synthetic routes and potentially further reduce the average number of reactions in solutions and improve solve rates.\nGPU reliance and computational overhead DESP requires GPU acceleration to tractably perform a k-NN search over ~ 23 million building blocks in the forward expansion policy. DESP-F2F also requires GPU inference to rapidly perform node comparisons at each iteration. In all, forward expansions take around 50% more time than retro expansions, though this is in part because our implementation of forward synthesis applies retro templates to each product proposed by the forward model to ensure template reversibility (i.e., to confirm that the increased success in finding routes during the bidirectional search is not an artifact of having access to \u201cdifferent\u201d transformations), which creates additional overhead. Overall, we view these limitations primarily as engineering problems that do not take away from the empirical benefits demonstrated in the paper. In principle, one could also implement DESP-F2E as a parallel bidirectional search in pursuit of additional efficiency gains.\nBuilding block specification Though DESP is designed to address starting material-constrained synthesis planning, we envision that future work could optimize bidirectional search to improve general retrosynthesis capabilities by conditioning on one or more starting materials instead of constraining the solution space. These starting materials could be expert-designed or predicted algorithmically as in Gao et al. [42].\nDESP-F2F implementation Our implementation of DESP-F2F does not take into account the total known cost of the opposing graph's nodes \\(V_t(m'|G_F) - r_n(m'|G_F)\\) when calculating \\(d_n(m|G_R)\\), and likewise the value of \\(r_n(m|G_F)\\) does not take into account \\(V_t(m'|G_R) - r_n(m'|G_R)\\). As a result, the selection policy DESP-F2F selects nodes that minimize the lowest expected cost of reaching the opposing search graph, but does not select to minimize the lowest expected cost of the final route directly. This is likely a primary contributor to DESP-F2F finding longer routes on average than DESP-F2E. As the values of \\(V_t(m|G)\\) change after each expansion, it would be computationally expensive to re-compare nodes across the search graphs at each iteration. We have not devised an efficient means of handling the number of re-comparisons that would be required and leave such optimizations to future exploration."}]}