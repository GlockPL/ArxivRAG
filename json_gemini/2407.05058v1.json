{"title": "Advancing Algorithmic Approaches to Probabilistic Argumentation under the Constellation Approach", "authors": ["Andrei Popescu", "Johannes P. Wallner"], "abstract": "Reasoning with defeasible and conflicting knowledge in an argumentative form is a key research field in computational argumentation. Reasoning under various forms of uncertainty is both a key feature and a challenging barrier for automated argumentative reasoning. It was shown that argumentative reasoning using probabilities faces in general high computational complexity, in particular for the so-called constellation approach. In this paper, we develop an algorithmic approach to overcome this obstacle. We refine existing complexity results and show that two main reasoning tasks, that of computing the probability of a given set being an extension and an argument being acceptable, diverge in their complexity: the former is #P-complete and the latter is # NP-complete when considering their underlying counting problems. We present an algorithm for the complex task of computing the probability of a set of arguments being a complete extension by using dynamic programming operating on tree-decompositions. An experimental evaluation shows promise of our approach.", "sections": [{"title": "1 Introduction", "content": "The field of computational argumentation is nowadays a cornerstone of approaches to automated and rational argumentative reasoning within Artificial Intelligence (\u0391\u0399). Application avenues for this field include legal reasoning, medical applications, and multi-agent systems, see, e.g., the overview given by Atkinson et al. (2017).\nCentral to computational argumentation are formal approaches that define how reasoning is carried out. Common to many forms of argumentative reasoning is the utilization of argumentation frameworks (AFs), in which arguments are represented as vertices and directed edges among arguments represent a directed conflict, or attack, relation. Importantly, it oftentimes suffices to abstract the internal structure of arguments, in order to find acceptable (sets of) arguments\nArgumentation semantics specify which arguments can be deemed acceptable, and several such semantics exist for different purposes. A prominent property of such semantics is that of admissibility. A set of arguments is admissible if there are no attacks between two arguments in the set (i.e., they are conflict-free), and for each attack from outside the set onto the set there is a counter-attack from within, defending each argument in the set. An admissible set containing all arguments defended is called a complete extension.\nTowards offering advanced forms of argumentative reasoning, AFs have been extended in several directions. Recently, approaches that incorporate forms of uncertainty gained traction in research, e.g., by incorporating weights or allowing for forms of incompleteness. In probabilistic argumentation, uncertainty is captured by probabilities of, e.g., arguments and attacks, making them uncertain. Two main approaches to formalization of probabilities in AFs are the epistemic approach and the constellation approach.\nIn the constellation approach, subframeworks of a given AF constitute possible scenarios, thereby including only a part of the given AF. Each such subframework is associated with a probability, stating how probable this particular sub-framework (argumentative scenario) is. Two main reasoning tasks are then to compute the probability that a set is an extension under a specified semantics, such as complete semantics, and (credulous) acceptability of an argument. The former is defined as the sum of probabilities of subframeworks where the set is an extension, and the latter as the sum of probabilities of subframeworks where there is an extension containing the specified argument.\nFazzinga, Flesca, and Furfaro (2019) showed that these two problems are FP#P-complete, e.g., for the complete semantics and when the probabilities are compactly represented as marginal probabilities of arguments and attacks with independence assumptions. Intuitively, their complexity results indicate that it is very challenging to compute the results: #P (or FP#P) hard problems are presumed to be very difficult problems to solve. For instance, the archetypical #P-complete problem is that of counting the number of satisfying truth-value assignments of a Boolean formula. Counting and probabilities are indeed connected, e.g., if each subframework has the same probability, the reasoning tasks above amount to counting the subframeworks satisfying the chosen criteria."}, {"title": "2 Background", "content": "We recall main definitions of argumentation frame-works (AFs) and probabilistic argumentation under the constellation approach. Moreover, we recap the notion of tree-width and tree-decompositions required for our work.\nDefinition 1. An argumentation framework (AF) is a pair (A, R) where A is a finite set of arguments and R \u2286 A \u00d7 A is an attack relation.\nFor a given AF F = (A, R), if (a, b) \u2208 R, then a attacks b (in F). Similarly, a set S \u2286 A attacks b \u2208 A if there is an a \u2208 S that attacks b (in F).\nFor specifying possible AFs, we make use of the notion of subframeworks. A subframework of an AF F = (A, R) is an AF F' = (A', R') with A' \u2286 A and R' \u2286 R. Note that F' is an AF, thus R' \u2286 A' \u00d7 A' holds. The set of all subframeworks is denoted by F(F) = {F' | F' a subframework of F}.\nArgumentation semantics on AFs are defined via functions \u03c3(F), for a given AF F = (A, R), that assign subsets of the arguments as o-extensions, i.e., \u03c3(F) \u2286 2^A. Central to AF semantics is the notion of defense.\nDefinition 2. Let F = (A, R) be an AF. A set of arguments S \u2286 A defends an argument a \u2208 A if it holds that whenever (b, a) \u2208 R there is a c \u2208 S with (c, b) \u2208 R.\nWe next define main semantics on AFs.\nDefinition 3. Let F = (A, R) be an AF. A set S \u2286 A is conflict-free (in F), if there are no a, b \u2208 S, s.t. (a, b) \u2208 R. We denote the collection of conflict-free sets of F by cf (F). For a conflict-free set S \u2208 cf (F), it holds that\n\u2022 S\u2208 stb(F) iff S attacks each a \u2208 A \\ S;\n\u2022 S\u2208 adm(F) iff S defends each a \u2208 S;\n\u2022 S\u2208 com(F) iff S \u2208 adm(F) and whenever a \u2208 A is defended by S, then a \u2208 S; and\n\u2022 S\u2208 grd(F) iff S \u2208 com(F) and there is no T \u2208 com(F) with T \u2286 S.\nWe refer to subsets of arguments that are in \u03c3(F) as \u03c3- extensions and also as an extension under a semantics \u03c3, for \u03c3\u2208 {stb, adm, com, grd}.\nFor developing our algorithms later on it will be useful to also consider the labeling-based definitions of the argumentation semantics.\nDefinition 4. Let F = (A, R) be an AF. A labeling L : A \u2192 {I,O,U} in F is a function assigning a label to each argument in F.\nIntuitively, I (\u201cin\u201d) signals accepting the argument in a labeling, O (\u201cout\u201d) is interpreted as attacked by accepted arguments, and U (\u201cundecided\u201d) takes neither stance. We sometimes use partial labelings, which are labelings where L is partial. To distinguish extensions and labelings under a semantics, we use & and \u2112ab, respectively, unless clear from the context. We sometimes view labelings as triples, arguments assigned I, O, and U, respectively.\nDefinition 5. Let F = (A, R) be an AF. For a labeling L in F it holds that\n\u2022 L\u2208 adm \u2112ab(F) iff for each a \u2208 A we find that\nL(a) = I implies that L(b) = O if (b, a) \u2208 R and\nL(a) = O implies \u2203(b,a) \u2208 R with L(b) = I,\n\u2022 L\u2208 com \u2112ab(F) iff L \u2208 adm \u2112ab(F) and for a \u2208 A\nL(a) = U implies \u2203(b,a) \u2208 R with L(b) = U and\n\u2203(b,a) \u2208 R with L(b) = I, and\n\u2022 L\u2208 stb \u2112ab(F) iff for all a \u2208 A it holds that L(a) \u2260 U and L \u2208 adm \u2112ab(F)."}, {"title": "3 Complexity Results for Probabilistic AFs", "content": "We investigate the complexity of probabilistic reasoning. In particular, we present novel results for counting variants of probabilistic reasoning. Fazzinga, Flesca, and Furfaro (2019) proved the results that, e.g., it is FP#P-complete to compute the probability of a set of arguments being a complete extension and to compute the probability of accepting an argument under complete semantics.\nWe refine their results, and show that the complexity of problems of computing the probability of a set of arguments and acceptability of an argument diverges on their underlying counting problems. Towards our result, we also consider the counting complexity classes #P and #NP. These \u201cdot\u201d classes are from a hierarchy of counting complexity classes, and are defined as follows. A counting problem is defined via a witness function w : \u03a3* \u2192 P<\u03c9(\u0393*) that assigns, given a string from alphabet \u03a3 a collection of (finite) subsets from alphabet \u0393. The task is to count |w(x)], given x. Additionally, we require that each witness y \u2208 w(x) is polynomially bounded by |x|. A counting problem is in #C, for a class of decision problems C, if given x and y the problem to decide whether y \u2208 w(x) is in C. For illustration, the archetypical #P- complete (as for #P) is #SAT, with the witness function assigning satisfying truth-value assignments to a formula. It holds that #P = # \u00b7 P, i.e., we can interchangeably use these two classes.\nLet us consider the following counting problems, for a given PAF F = (A, R, P) and semantics \u03c3:\n\u2022 given a set of arguments S \u2286 A, count the number of subframeworks F' \u2208 Fp(F) for which we find that S is a \u03c3-extension in F', and\n\u2022 given an argument a \u2208 A, in how many subframeworks F' \u2208 Fp(F) is it the case that there is an S \u2208 \u03c3(F') with a \u2208 S?\nAs the example suggests, counting the number of sub- frameworks that satisfy the above criteria acts as special case of computing probabilities of a set being an extension or of the acceptability of an argument.\nWe start with the problem of counting the number of subframeworks where a given set is an extension. While we will show #P-completeness (# \u00b7 P-completeness), we first argue that this problem is not #P-hard under parsimonious reductions. The type of reductions is important for counting complexity classes, since closure of counting classes under some types of reductions is not immediate. A reduction is parsimonious if a counting problem is transformed to another in polynomial time and the number of solutions (cardinality of their respective witness sets) is preserved exactly.\nBy a result of Fazzinga, Flesca, and Furfaro, Theorem 2 (2020), it holds that one can check in polynomial time whether some subframework has a queried set as a complete extension. This directly prevents existence of a par- simonious reduction in our case, under complexity theoretic assumptions. If there were a parsimonious reduction from #SAT to this problem, one could solve SAT in polynomial time: one can reduce a Boolean formula to the current problem and in polynomial time find one suitable subframework, which in turn implies that there is a satisfying truth value assignment of the formula."}, {"title": "4 Preprocessing Probabilistic AFs", "content": "Here we look at preprocessing for PAFs. In general, preprocessing is seen as a vital component for solving hard prob-"}, {"title": "5 Tree-Decomposition-based Algorithm", "content": "In this section we develop our algorithm for computing the probabilities of a given set being an extension (P-Ext). We illustrate our algorithms mainly on the complete semantics, yet our algorithms can be utilized also for admissible sets and stable semantics. Nevertheless, under complete seman- tics the considered problem is FP#P-complete.\nOur algorithm operates on tree-decompositions, more specifically so-called nice tree- decompositions for a given PAF F = (A, R, P). A nice tree-decomposition is a tree-decomposition where, additionally, we find that each node is one of the following types:\n\u2022 a root node or a leaf node with empty bags,\nFor a given (input) PAF F = (A, R, P), we make use of some auxiliary definitions and shorthands. The main datastructure of our algorithms is a row (s, w, p) in a table, which is composed of a structure s, a witness w, and a probability p\u2208 [0, 1]. A structure s = (F', L') is a pair of a subframework F' of FP(F) and a labeling L' in F'. What we call a witness w contains a labeling-witness lw, which is a partial labeling in F'.\nIntuitively, if a row (s, w, p) is computed in a table Tt for node t and bag Bt, this means that the sum of probabilities of all \u201ccompletions\u201d of s to arguments in B is equal to p. With B<t = Ut'\u2208T' Bt' we define the union of all bags in the subtree T' with root t. For instance, B<4 of Figure 3 is {a, b, c}. A completion of a structure s to B<t (all arguments \u201cseen\u201d) are all completions of the current subframework to subframeworks containing arguments and attacks in B<t, as well as all labelings that extend the one in s up to B<t. These labelings have to satisfy that those arguments in S that are in B<t are labeled I, and for all arguments already seen but not in the current bag Bt the conditions of being complete are satisfied. For the arguments inside the bag, whenever the label-witness assigns \u201cout\u201d or \u201cundecided\u201d to an argument, there must be a reason. This means, if one extends the structure s in all possible ways up to B<t that still adhere to the conditions of sub-frameworks of PAFs and complete labelings for those arguments outside the bag, all these structures are \u201cvalid\u201d sub-frameworks to sum. Since, by construction, the root node has an empty bag, and all arguments have been traversed before, all subframeworks have been considered and their labelings where S is complete (there is exactly one such labeling in each subframework), the result in the root node is the probability of S being a complete extension.\nA witness w is used to \u201cremember\u201d facts that decide whether the row can be associated to a complete labeling.\nWe next make the above intuition more formal. Let r = (s,w,p) be a row in \u03c4t for node t with s = (F', L')\nWhen adding an argument a, the probability is updated by multiplying with P(a) and considering the factors for each added attack in the structure (Add(s, a)) and attack from R not added (Rem(s, a)).\nThe witnesses are updated as follows: UpW(s,w) = w \u222a {x \u2192 O | (y, x) \u2208 R, L(y) = I} \u222a {x \u2194 U | (y,x) \u2208 R, L(y) = U}. In brief, we store whenever an argument can be assigned to \u201cout\u201d or \u201cundecided\u201d: if there is an attacked argument that is \u201cundecided\u201d then its attacker must also be \u201cundecided\u201d, as required for the complete semantics. An \u201cin\u201d attacker is taken care of by requiring in introduction nodes all adjacent arguments to be \u201cout\u201d, as specified in the following.\nThe condition intro(s) ensures that the labelings in s are conflict-free, i.e., not adjacent arguments are labeled \u201cin\u201d and arguments adjacent to ones labeled I are labeled O. For a resulting set of rows T, the function checkAcceptance(T) filters those rows where S is not labeled I. In practice, this filter can be applied earlier (during row construction). For the sake of readability, we opted to show this filter here.\nLet us move to forget nodes (Algorithm 3). The main idea here is that an argument a is \u201cforgotten\u201d in a bag (compared to the bag of the unique child in the nice tree-decomposition). This is the point in the algorithm where we can verify that the label assigned to a does not violate the conditions for being complete, since all adjacent arguments were traversed already. The witness-label lw for a enables us to check conditions for a."}, {"title": "6 Experimental Evaluation", "content": "We evaluate our algorithm for P-Ext, focusing on the FP#P-complete variant for complete semantics.\nImplementations We implemented our algorithm in a Python (3.9.7) prototype. As suggested by Dewoprabowo et al. (2022), we partially make use of database tools: the most expensive operations (join and forget) make use of a Python library for database management.\nDue to operations on small numbers, we implemented two variants, one using floating-point numbers dubbed TD-Ext-f, and one using rational numbers, called TD-Ext-r. For computing a nice tree-decompositions, we used the htd library. To the best of our knowledge, there are no com- peting systems available that are tailored towards performance. For a baseline comparison, we implemented two more systems: (i) a naive brute-force al- gorithm enumerating pairs of subframeworks and exten- sions in Python and (ii) and answer set programming (ASP) based implementation ASP-#Ext for counting subframeworks where S is complete. Note that this implementation does not solve the same problem, but a simpler one, and is intended mainly as a basis for comparison.\nInstances There is currently no standard benchmark set for PAFs. We constructed PAFs with a controlled tree-width and focused on instances not solved via preprocessing, i.e., do not contain many certain arguments and attacks. We constructed PAFs based on grids (k,n) with possible attacks (bidirectional, one-directional, or no attack) for each hori- zontal or vertical neighbour. Direction or no attacks was chosen with uniform probability. Argument and attack prob- abilities are picked from {0.1, 0.2, ..., 1}, with probabilities \\u03c1 for uncertain and 1 \u2212 \u03c1 for 1. We let k \u2208 {3,4,5,6,7} and \u03b7\u2208 {5, 10, 20, 50, 75, 100, 150}. Tree-width of such grid- graphs is bounded by min(k, n). For each (k, n) we gener- ated 4 PAFs and a set S to be checked by selecting a \u2208 A with probability 0.04.\nSetup and Results The experiments were carried out on a Linux machine (64-bit), with an 8-core i5 Intel CPU and 16 GB of memory. We enforced a runtime of maximum 300 seconds and a memory limit of 8192 MB per run.\nAs expected, the brute-force algorithm enumerating sub- frameworks and extensions timed out on most instances. In Table 1 we show the number of timeouts and median running times of solved instances. In the results, our approach scales with tree-width: no timeouts were reported with instances having tree-width at most 5. Note that PAFs with k = 5 in- clude ones with n = 150 and |A| = 750. For a baseline comparison, ASP-#Ext showed significantly more time- outs. We speculate this is due to the high number of such subframeworks, e.g., one instance reported more than 6 \u00b7 107 subframeworks.\nRegarding precision, using floats the results, in fact, differ to fractions: in four instances the former reported 0, while the result is higher than 0 (although low). Moreover, in one PAF TD-Ext-f reported 9.6 \u00b7 10\u221215 and TD-Ext-r re- turned 7 \u00b7 10\u221215. While the absolute difference is low, the percentage the former approach is off is roughly one-third. On the other hand, in many runs the results reported were close. We speculate that this is due to having many opera- tions summing or multiplying in the dynamic programming algorithms. Due to similar performance of TD-Ext-f and TD-Ext-r, it does appear to give TD-Ext-r an edge."}, {"title": "7 Extensions", "content": "Our algorithm presented in Section 5 can be extended, and we discuss here possible extensions.\nFirst, in addition to enforcing arguments to be \u201cin\u201d (as in the P-Ext problem), we can also directly enforce arguments to be O or U.\nThis is direct in the algorithm: in introduction nodes we can restrict generation of rows to exactly those fitting the chosen criteria. For instance, only constructing labelings with a chosen argument assigned \u201cout\u201d or \u201cundecided\u201d.\nSecond, as discussed by Fazzinga, Flesca, and Furfaro (2019), we can introduce dependencies between arguments. For instance, consider the case that whenever a subframework contains an argument a then such a subframework also must contain an argument b. Then, as discussed by Fazzinga, Flesca, and Furfaro, one can specify marginal probabilities of the three different cases: containing neither argument, containing only b and containing both.\nThis can be achieved, by considering, in the tree- decomposition generation, an additional edge between a and b, representing an additional dependency. This additional edge ensures that a or b can only be forgotten if the other argument was already seen.\nThen computation of probabilities must be deferred un- til both arguments a and b are in a bag (only then can we compute the marginal probability of this case). As discussed earlier , implication dependencies such as these can be important for representing internal structure of arguments, while at the same time, as discussed by Fazzinga, Flesca, and Furfaro, allowing for compact rep- resentation of probabilities by marginal probabilities. For instance, if an argument a is a sub-argument of b, when con- sidering the internal structure of these arguments, then hav- ing b but not a might be unwarranted. Or, for instance, if the contents of arguments a and b together imply existence of an argument c, then dependency edges between all can be added, and marginal probabilities of the different cases considered.\nFinally, to adapt Algorithm 1 to admissible sets or sta- ble extensions, the condition for semantics can be directly adapted: for admissibility the checks for undecidedness can be omitted, while for stable semantics, introduction nodes are not allowed to assign arguments to undecided."}, {"title": "8 Discussion", "content": "In this work we revisited computationally complex prob- lems in probabilistic argumentation under the constellation approach. We refined earlier complexity results, showing a divergence between complexities of two main reasoning tasks. For the problem of computing the probability of a set of arguments being complete, we developed a dynamic programming algorithm. Our experimental evaluation shows promise of the approach: PAFs with up to 750 arguments were solved regularly, depending on the attack-structure and tree-width.\nAlgorithmic approaches utilizing tree-decompositions were investigated before for formal argu- mentation also for counting extensions containing queried arguments in AFs and, e.g., for model counting in Boolean logic and weighted model counting. In con- trast, we present a novel dynamic programming algorithm for probabilistic argumentation under the constellation approach.\nFor future work, an interesting avenue is to extend our work for acceptability of arguments in PAFs, under the con- stellation approach. We think that our Algorithm 1 provides a useful basis for computing acceptability. The main barrier is to avoid over-computation, or over-summation. For in- stance, by slightly relaxing our algorithm to have a queried argument to be assigned \u201cin\u201d, and allowing also other argu- ments to be \u201cin\u201d we can extend the algorithm to consider also other extensions that contain a queried argument. How- ever, directly counting all pairs of subframeworks and la- belings assigning a queried argument to be \u201cin\u201d over-counts, since there might be many such labelings in a particular sub- framework.\nWe think that this way of over-counting can be ad- dressed in a dynamic programming way operating on tree- decompositions, but requires more work for a detailed in- vestigation. We remark that Theorem 5 (hardness of acyclic PAFs) does not prevent existence of algorithms for accept- ability using tree-decompositions: acyclic PAFs may have a tree-width higher than one.\nAs a more general direction, we think that future work, to advance complex reasoning in probabilistic argumenta- tion further, should include also different forms of optimiza- tions. For instance, an (NP-hard) preprocessing might be beneficial for dynamic programming algorithms that can re- strict the number of rows in tables, e.g, by pre-computing impossible combinations (e.g., argument a is never \u201cin\u201d in any subframework). While these problems can be complex themselves, we think that they can overall be used to opti- mize tree-decomposition-based algorithms."}]}