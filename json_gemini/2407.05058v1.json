{"title": "Advancing Algorithmic Approaches to Probabilistic Argumentation under the Constellation Approach", "authors": ["Andrei Popescu", "Johannes P. Wallner"], "abstract": "Reasoning with defeasible and conflicting knowledge in an argumentative form is a key research field in computational argumentation. Reasoning under various forms of uncertainty is both a key feature and a challenging barrier for automated argumentative reasoning. It was shown that argumentative reasoning using probabilities faces in general high computational complexity, in particular for the so-called constellation approach. In this paper, we develop an algorithmic approach to overcome this obstacle. We refine existing complexity results and show that two main reasoning tasks, that of computing the probability of a given set being an extension and an argument being acceptable, diverge in their complexity: the former is #P-complete and the latter is # NP-complete when considering their underlying counting problems. We present an algorithm for the complex task of computing the probability of a set of arguments being a complete extension by using dynamic programming operating on tree-decompositions. An experimental evaluation shows promise of our approach.", "sections": [{"title": "1 Introduction", "content": "The field of computational argumentation is nowadays a cornerstone of approaches to automated and rational argumentative reasoning within Artificial Intelligence (\u0391\u0399). Application avenues for this field include legal reasoning, medical applications, and multi-agent systems, see, e.g., the overview given by Atkinson et al. (2017).\nCentral to computational argumentation are formal approaches that define how reasoning is carried out. Common to many forms of argumentative reasoning is the utilization of argumentation frameworks (AFs), in which arguments are represented as vertices and directed edges among arguments represent a directed conflict, or attack, relation. Importantly, it oftentimes suffices to abstract the internal structure of arguments, in order to find acceptable (sets of) arguments.\nArgumentation semantics specify which arguments can be deemed acceptable, and several such semantics exist for different purposes. A prominent property of such semantics is that of admissibility. A set of arguments is admissible if there are no attacks between two arguments in the set (i.e., they are conflict-free), and for each attack from outside the set onto the set there is a counter-attack from within, defending each argument in the set. An admissible set containing all arguments defended is called a complete extension.\nTowards offering advanced forms of argumentative reasoning, AFs have been extended in several directions. Recently, approaches that incorporate forms of uncertainty gained traction in research, e.g., by incorporating weights or allowing for forms of incompleteness. In probabilistic argumentation, uncertainty is captured by probabilities of, e.g., arguments and attacks, making them uncertain. Two main approaches to formalization of probabilities in AFs are the epistemic approach and the constellation approach.\nIn the constellation approach, subframeworks of a given AF constitute possible scenarios, thereby including only a part of the given AF. Each such subframework is associated with a probability, stating how probable this particular sub-framework (argumentative scenario) is. Two main reasoning tasks are then to compute the probability that a set is an extension under a specified semantics, such as complete semantics, and (credulous) acceptability of an argument. The former is defined as the sum of probabilities of subframeworks where the set is an extension, and the latter as the sum of probabilities of subframeworks where there is an extension containing the specified argument.\nFazzinga, Flesca, and Furfaro (2019) showed that these two problems are FP#P-complete, e.g., for the complete semantics and when the probabilities are compactly represented as marginal probabilities of arguments and attacks with independence assumptions. Intuitively, their complexity results indicate that it is very challenging to compute the results: #P (or FP#P) hard problems are presumed to be very difficult problems to solve. For instance, the archetypical #P-complete problem is that of counting the number of satisfying truth-value assignments of a Boolean formula. Counting and probabilities are indeed connected, e.g., if each subframework has the same probability, the reasoning tasks above amount to counting the subframeworks satisfying the chosen criteria.\nThe high computational complexity was likely so far a major barrier for development of algorithmic approaches and systems for solving tasks in probabilistic argumentation. To the best of our knowledge, there are not many algorithms and systems for the constellation approach for AFs for the computationally hard tasks. As an exception, Fazzinga et al. (2019) provide algorithms for bipolar frameworks, yet for probabilistic AFs their results do not apply to FP#P-complete reasoning tasks. In this paper we take up this challenge and develop an algorithmic approach to probabilistic argumentation frameworks under the constellation approach.\nOur main contributions are as follows.\n\u2022 We first refine the complexity results by Fazzinga, Flesca, and Furfaro (2019), who showed that computing the probability of a set being an extension and acceptability share the same complexity. We show, using counting complexity classes, that their underlying counting problems differ in their complexity: the former problem is #P-complete, for the complete semantics, and the latter is # NP-complete for admissible, complete, and stable semantics, indicating a jump in the counting complexity hierarchy. Moreover, even when restricting to acyclic attack structures, the latter problem remains #P-complete.\n\u2022 Next we look into algorithms to solve these tasks. Towards efficient reasoning, we give results in preprocessing probabilistic AFs to simplify given instances.\n\u2022 Inspired by their capability of solving #P-hard problems, we develop a dynamic programming algorithm for probabilistic AFs utilizing tree-decompositions. Our algorithm is capable of solving the FP#P-complete problem of computing the probability of a set being a complete extension.\n\u2022 We experimentally evaluate a prototype of our algorithm, which will be publicly available under an open license, and show promise of our approach that solves PAFs up to 750 arguments, depending on the attack-structure.\n\u2022 Finally, we discuss extensions of our approach, e.g., to incorporate dependencies among arguments, relaxing independence assumptions.\nWe give further (proof) details in the supplement."}, {"title": "2 Background", "content": "We recall main definitions of argumentation frameworks (AFs) and probabilistic argumentation under the constellation approach. Moreover, we recap the notion of tree-width and tree-decompositions required for our work.\nDefinition 1. An argumentation framework (AF) is a pair (A, R) where A is a finite set of arguments and $R \\subseteq A \\times A$ is an attack relation.\nFor a given AF F = (A, R), if (a, b) \u2208 R, then a attacks b (in F). Similarly, a set S \u2286 A attacks b \u2208 A if there is an a \u2208 S that attacks b (in F).\nFor specifying possible AFs, we make use of the notion of subframeworks. A subframework of an AF F = (A, R) is an AF F' = (A', R') with A' \u2286 A and R' \u2286 R. Note that F' is an AF, thus R' \u2286 A' \u00d7 A' holds. The set of all subframeworks is denoted by $F(F) = {F' \\mid F' \\text{ a subframework of } F}$.\nArgumentation semantics on AFs are defined via functions \u03c3(F), for a given AF F = (A, R), that assign subsets of the arguments as \u03c3-extensions, i.e., \u03c3(F) \u2286 2A. Central to AF semantics is the notion of defense.\nDefinition 2. Let F = (A, R) be an AF. A set of arguments S \u2286 A defends an argument a \u2208 A if it holds that whenever (b, a) \u2208 R there is a c \u2208 S with (c, b) \u2208 R.\nWe next define main semantics on AFs.\nDefinition 3. Let F = (A, R) be an AF. A set S \u2286 A is conflict-free (in F), if there are no a, b \u2208 S, s.t. (a, b) \u2208 R. We denote the collection of conflict-free sets of F by cf(F). For a conflict-free set S \u2208 cf(F), it holds that\n\u2022 S\u2208 stb(F) iff S attacks each a \u2208 A \\ S;\n\u2022 S\u2208 adm(F) iff S defends each a \u2208 S;\n\u2022 S\u2208 com(F) iff S \u2208 adm(F) and whenever a \u2208 A is defended by S, then a \u2208 S; and\n\u2022 S\u2208 grd(F) iff S \u2208 com(F) and there is no T \u2208 com(F) with T\u2286S.\nWe refer to subsets of arguments that are in \u03c3(F) as \u03c3-extensions and also as an extension under a semantics \u03c3, for \u03c3\u2208 {stb, adm, com, grd}.\nFor developing our algorithms later on it will be useful to also consider the labeling-based definitions of the argumentation semantics.\nDefinition 4. Let F = (A, R) be an AF. A labeling $L : A \\rightarrow {I, O, U}$ in F is a function assigning a label to each argument in F.\nIntuitively, I (\"in\") signals accepting the argument in a labeling, O (\"out\") is interpreted as attacked by accepted arguments, and U (\u201cundecided\u201d) takes neither stance. We sometimes use partial labelings, which are labelings where L is partial. To distinguish extensions and labelings under a semantics, we use & and $Lab$, respectively, unless clear from the context. We sometimes view labelings as triples, arguments assigned I, O, and U, respectively.\nDefinition 5. Let F = (A, R) be an AF. For a labeling L in F it holds that\n\u2022 $L\\in adm^{Lab}(F)$ iff for each a \u2208 A we find that\n$L(a) = I$ implies that L(b) = O if (b, a) \u2208 R and\n$L(a) = O$ implies \u2203(b,a) \u2208 R with L(b) = I,\n\u2022 $L\\in com^{Lab}(F)$ iff $L \\in adm^{Lab}(F)$ and for $a \\in A$ $L(a) = U$ implies \u2203$(b,a) \\notin R$ with $L(b) = U$ and\n$\u2203(b,a) \\notin R$ with L(b) = I, and\n\u2022 $L\\in stb^{Lab}(F)$ iff for all a \u2208 A it holds that L(a) \u2260 U and $L \\in adm^{Lab}(F)$."}, {"title": "3 Complexity Results for Probabilistic AFs", "content": "We investigate the complexity of probabilistic reasoning. In particular, we present novel results for counting variants of probabilistic reasoning. Fazzinga, Flesca, and Furfaro (2019) proved the results that, e.g., it is FP#P-complete to compute the probability of a set of arguments being a complete extension and to compute the probability of accepting an argument under complete semantics.\nWe refine their results, and show that the complexity of problems of computing the probability of a set of arguments and acceptability of an argument diverges on their underlying counting problems. Towards our result, we also consider the counting complexity classes #P and #NP. These \"dot\" classes are from a hierarchy of counting complexity classes, and are defined as follows. A counting problem is defined via a witness function $w : \\Sigma^* \\rightarrow P_{<w}(\\Gamma^*)$ that assigns, given a string from alphabet \u03a3 a collection of (finite) subsets from alphabet \u0393. The task is to count |w(x)], given x. Additionally, we require that each witness $y \\in w(x)$ is polynomially bounded by x. A counting problem is in #C, for a class of decision problems C, if given x and y the problem to decide whether $y \\in w(x)$ is in C. For illustration, the archetypical #P-complete (as for #P) is #SAT, with the witness function assigning satisfying truth-value assignments to a formula. It holds that #P = # \u00b7 P, i.e., we can interchangeably use these two classes.\nLet us consider the following counting problems, for a given PAF F = (A, R, P) and semantics \u03c3:\n\u2022 given a set of arguments $S \\subseteq A$, count the number of subframeworks $F' \\in F_p(F)$ for which we find that S is a \u03c3-extension in F', and\n\u2022 given an argument a \u2208 A, in how many subframeworks $F' \\in F_P(F)$ is it the case that there is an $S \\in \\sigma(F')$ with a \u2208 S?\nAs the example suggests, counting the number of sub-frameworks that satisfy the above criteria acts as special case of computing probabilities of a set being an extension or of the acceptability of an argument.\nWe start with the problem of counting the number of subframeworks where a given set is an extension. While we will show #P-completeness (# \u00b7 P-completeness), we first argue that this problem is not #P-hard under parsimonious reductions. The type of reductions is important for counting complexity classes, since closure of counting classes under some types of reductions is not immediate. A reduction is parsimonious if a counting problem is transformed to another in polynomial time and the number of solutions (cardinality of their respective witness sets) is preserved exactly.\nBy a result of Fazzinga, Flesca, and Furfaro, Theorem 2 (2020), it holds that one can check in polynomial time whether some subframework has a queried set as a complete extension. This directly prevents existence of a parsimonious reduction in our case, under complexity theoretic assumptions. If there were a parsimonious reduction from #SAT to this problem, one could solve SAT in polynomial time: one can reduce a Boolean formula to the current problem and in polynomial time find one suitable subframework, which in turn implies that there is a satisfying truth value assignment of the formula."}, {"title": "4 Preprocessing Probabilistic AFs", "content": "Here we look at preprocessing for PAFs. In general, preprocessing is seen as a vital component for solving hard problems, e.g., in SAT solving to simplify instances.\nFormally, let us define A(F), for a given PAF F = (A, R, P) and a given partial labeling L, that returns a partial labeling L' as follows. L'(a) is I if for all attacks of (b, a) in F it holds that L(b) = O. L'(a) is O if there is an attack (b, a) in F we find that P(b) = 1, P(b,a) = 1 and L(b) = I. We have to label an argument \"in\" if the argument is present in a subframework and for all attacks (if existing) it is clear that they are \"defeated\". An argument is \"out\" if a certain argument labeled I and attack designate it to be out. Let L be the least-fixed point of this function. It holds that for P-Ext and a given set S, the probability is 0 if S contains an argument labeled \"out\" in L. Moreover, if an argument a \u2209 S is labeled \u201cin\u201d by L, then (i) if a is certain, the probability is 0 and (ii) if a is uncertain only subframeworks without a can have S as a complete extension. For P-Acc an argument a labeled \"out\" in L has 0 probability."}, {"title": "5 Tree-Decomposition-based Algorithm", "content": "In this section we develop our algorithm for computing the probabilities of a given set being an extension (P-Ext). We illustrate our algorithms mainly on the complete semantics, yet our algorithms can be utilized also for admissible sets and stable semantics. Nevertheless, under complete semantics the considered problem is FP#P-complete.\nOur algorithm operates on tree-decompositions, more specifically so-called nice tree-decompositions, for a given PAF F = (A, R, P). A nice tree-decomposition is a tree-decomposition where, additionally, we find that each node is one of the following types:\n\u2022 a root node or a leaf node with empty bags,\n\u2022 a join node t with exactly two children, t\u2081 and t\u2082, such that Bt = Bt\u2081 = Bt2,\n\u2022 an introduction node t with exactly one child t' such that Bt = Bt \u222a {x} and x \u2208 A, or\n\u2022 a forget node t with exactly one child t' such that Bt = Btv \\ {x} and x \u2208 A.\nThe first condition (empty bags for the root and leaf nodes) is not in the original definition of nice tree-decompositions, but can be imposed directly and is useful for developing our algorithm. A join node has two children and all share the same bag, introduction and forget nodes each have one child and either introduce exactly one or forget exactly one argument. Given a (not nice) tree-decomposition, a nice tree-decomposition can be obtained in linear time.\nFor a constant k, there is a linear-time algorithm that checks whether a given undirected graph has tree-width k, and if reporting positively, also can return a tree-decomposition of minimum width. Practically, we employ a library using heuristics for generation for any given PAF.\nThe algorithm we develop performs a bottom-up computation on a nice tree-decomposition. Starting from the leaves, for each bag a table of rows is computed. Each row can be seen as a partial solution, applicable to the part of the PAF that was visited so far.\nAlgorithm 1 is the main algorithm, which calls sub algorithms depending on the type of the current node. In Line 1 we construct a nice tree-decomposition of the given PAF and initialize an empty table (set) for each bag in Line 2. We go over all bags in post-order in the loop in Line 3. After the case distinction for each type of nodes, we return the probability given in (0, 0, p) in the root of the tree-decomposition. There is only one such row in each computation.\nFor a given (input) PAF F = (A, R, P), we make use of some auxiliary definitions and shorthands. The main datastructure of our algorithms is a row (s, w, p) in a table, which is composed of a structure s, a witness w, and a probability p\u2208 [0, 1]. A structure s = (F', L') is a pair of a subframework F' of Fp(F) and a labeling L' in F'. What we call a witness w contains a labeling-witness lw, which is a partial labeling in F'.\nIntuitively, if a row (s, w, p) is computed in a table Tt for node t and bag Bt, this means that the sum of probabilities of all \"completions\" of s to arguments in $B_{<t}$ that respect the witness w is equal to p. With $B_{<t} = \\cup_{t'\\in T'} B_{t'}$ we define the union of all bags in the subtree T' with root t. For instance, $B_{<4}$ of Figure 3 is {a, b, c}. A completion of a structure s to $B_{<t}$ (all arguments \"seen\") are all completions of the current subframework to subframeworks containing arguments and attacks in $B_{<t}$ (and taking certain parts into account), as well as all labelings that extend the one in s up to $B_{<t}$. These labelings have to satisfy that those arguments in S that are in $B_{<t}$ (i.e., S \u2229 $B_{<t}$) are labeled I, and for all arguments already seen but not in the current bag ($B_{t} \\setminus B_{<t}$) the conditions of being complete are satisfied. For the arguments inside the bag, whenever the label-witness assigns \"out\" or \"undecided\" to an argument, there must be a reason. This means, if one extends the structure s in all possible ways up to $B_{<t}$ that still adhere to the conditions of sub-frameworks of PAFs and complete labelings for those arguments outside the bag, all these structures are \"valid\" subframeworks to sum. Since, by construction, the root node has an empty bag, and all arguments have been traversed before, all subframeworks have been considered and their labelings where S is complete (there is exactly one such labeling in each subframework), the result in the root node is the probability of S being a complete extension.\nA witness w is used to \"remember\" facts that decide whether the row can be associated to a complete labeling.\nWe next make the above intuition more formal. Let r = (s,w,p) be a row in $\u03c4_{t}$ for node t with s = (F', L') and w = lw, for a given PAF F = (A, R, P). Define that F\" = (A\", R\") is an expansion of F' and Bt if A' \u2286 A\", R'\u2286 R\", (Bt \\ A') \u2229 A\" = 0, and no attacks possible via arguments in Bt that are not in R' are in R\". Let $F_{<t} = (A_{<t}, R_{<t}) \\in F_p(F)$ be the sub-framework s.t. $A_{<t} = B_{<t}$ and $R_{<t} = R \\cap A_{<t}$. Then $F_t(F) = {F\" \\in F_p(F_{<t}) \\mid F\" \\text{ expands } F' \\text{ and } B_t}$ is the set of all subframeworks with contents restricted to $B_{<t}$ expanding F'.\nFor L', its completion to A\" \u2283 A' is a labeling that assigns the same labels to those in A' as L' and some labeling to those in A\" \\ A'. A labeling L\" on a subframework F\" is said to be partially complete w.r.t. bag Bt, set S, and labeling-witness lw if for each argument a in F\" the following holds. If a \u2208 B<t \\ Bt then L(a) = I implies all attackers in F\" are O, L(a) = O implies there is an attacker in F\" that is I, and L(a) = U implies no attacker is I and there is an U attacker. For arguments a \u2208 Bt, we require that L(a) = I implies that all adjacent arguments are O, lw(a) = O iff there is an attacker that is I in F\", and lw(a) = U iff there is an U attacker und no attacker is I. Finally each argument in S must be assigned \u201cin\u201d. That is, the conditions for complete labelings is satisfied for arguments already \u201cseen\u201d but forgotten, and for arguments in the current bag, we only require (i) conflict-freeness and (ii) if the labeling-witness specifies an argument to be \"out\" or \"undecided\", there is a justification.\nLet X be the set of pairs (F\", L\") such that F\" \u2208 F(F) and L\" is partially complete in F\" w.r.t. bag Bt, set S and lw. It holds that p is the sum of all subframeworks in X (restricted to components in B<t. Intuitively, X contains all \u201ccompatible\u201d subframeworks that respect the witness, the current labeling, and the queried set S, but relaxing the conditions for the arguments inside the bag, since adjacent arguments might not be traversed yet.\nAlgorithm 2 presents our approach to introduction nodes t. The child node of t is t' and T' contains the rows for t'. Intuitively, for each row r' = (s, w,p) from t' we compute new rows r, by either adding the introduced argument a or not to the subframework in s (Line 2 and Line 5). If the argument was added, then for each possible way of labeling the new argument (Line 3) we compute new labelings and update witnesses.\nGiven a PAF F = (A, R, P), as a shorthand, we define $S_{s+a}(F)$, for a structure s = (F', L') with F' = (A', R'), an argument a, to be all structures that may extend s with a new argument a. We define the set of AFs extending F' by adding a and possibly incident attacks.\n$F'_{+a} = {F'' = (A'', R'') \\in F_p(F) \\mid A'' = A' \\cup {a}, \\newline R' \\subseteq R'' \\subseteq R' \\cup ({(a, x), (x, a) \\mid x \\in A''} \\cap R)}$\nThen $S_{s+a}(F)$ is equal to {(F\",L\") | $F'' \\in F'_{+a}$, L\" completion to F\"}. That is, Ss+a contains all pairs with an AF F\" and labeling L\" such that F\" additionally contains a, all arguments and attacks from F', and may add attacks of a (restricted to those originally in R).\nWhen adding an argument a, the probability is updated by multiplying with P(a) and considering the factors for each added attack in the structure (Add(s, a)) and attack from R not added (Rem(s, a)).\n$UpP(s, a, p) = p \\cdot P(a) \\cdot Atts(s, a)$\n$Atts(s, a) = \\frac{\\prod_{r\\in Add(s,a)} P(r)}{\\prod_{r \\in Rem(s,a)} (1 - P(r))}$\nThe witnesses are updated as follows: UpW(s,w) = w\u222a {x \u2192 O | (y, x) \u2208 R,L(y) = I} \u222a {x \u2194 U | (y,x) \u2208 R, L(y) = U}. In brief, we store whenever an argument can be assigned to \"out\" or \"undecided\": if there is an attacked argument that is \"undecided\" then its attacker must also be \"undecided\", as required for the complete semantics. An \"in\" attacker is taken care of by requiring in introduction nodes all adjacent arguments to be \"out\", as specified in the following.\nThe condition intro(s) ensures that the labelings in s are conflict-free, i.e., not adjacent arguments are labeled \"in\" and arguments adjacent to ones labeled I are labeled O. For a resulting set of rows T, the function checkAcceptance(T) filters those rows where S is not labeled I. In practice, this filter can be applied earlier (during row construction). For the sake of readability, we opted to show this filter here.\nLet us move to forget nodes (Algorithm 3). The main idea here is that an argument a is \"forgotten\" in a bag (compared to the bag of the unique child in the nice tree-decomposition). This is the point in the algorithm where we can verify that the label assigned to a does not violate the conditions for being complete, since all adjacent arguments were traversed already. The witness-label lw for a enables us to check conditions for a.\nSay we are in node t with child node t'. Consider a row from t' as r' = (s', w', p') with s' = (F', L'). If we assume that p' is the sum of probabilities of subframeworks in X, then to compute a new row r = (s, w,p), based on r', we need to make sure that for all subframeworks and labels associated with X we get that (i) the now forgotten argument satisfies the complete conditions and (ii) that we capture all subframeworks with the new row.\nTo check the conditions for partial completeness, if L'(a) = I, then all attackers in subframeworks in X are labeled \"out\", by assumption of correctness of the child node. If L'(a) = O, we need to make sure that there is an \u201cin\u201d attacker. This is the case for all subframeworks in X if lw(a) = O. Analogously, we verify the partial completeness condition for L'(a) = U. If one of the checks fails, the row r' is discarded, which we denoted by $\u03c3_{forget}(s, w, a)$. By s-a and w- a we denote the removal of a from structure (and incident attacks) and witness.\nFinally, after forgetting a node in rows r', multiple rows can coincide on their (s, w) part: these need to be summed (\"collapse\" now to one row).\nAlgorithm 4 Join(\u03c41, \u03c42, B)\n1: T := {(s, w1 \u222a w2, comp(p1,p2,s)) | (s,w1,p1) \u2208 \u03c41, (s, w2, p2) \u2208 \u03c42}\n2: T := Merge(T)\n3: return T"}, {"title": "6 Experimental Evaluation", "content": "We evaluate our algorithm for P-Ext, focusing on the FP#P-complete variant for complete semantics.\nImplementations We implemented our algorithm in a Python (3.9.7) prototype. As suggested by Dewoprabowo et al. (2022), we partially make use of database tools: the most expensive operations (join and forget) make use of a Python library for database management.\nDue to operations on small numbers, we implemented two variants, one using floating-point numbers dubbed TD-Ext-f, and one using rational numbers, called TD-Ext-r. For computing a nice tree-decompositions, we used the htd library. To the best of our knowledge, there are no competing systems available that are tailored towards performance. For a baseline comparison, we implemented two more systems: (i) a naive brute-force algorithm enumerating pairs of subframeworks and extensions in Python and (ii) and answer set programming (ASP) based implementation ASP-#Ext for counting subframeworks where S is complete. Note that this implementation does not solve the same problem, but a simpler one, and is intended mainly as a basis for comparison.\nInstances There is currently no standard benchmark set for PAFs. We constructed PAFs with a controlled tree-width and focused on instances not solved via preprocessing, i.e., do not contain many certain arguments and attacks. We constructed PAFs based on grids (k,n) with possible attacks (bidirectional, one-directional, or no attack) for each horizontal or vertical neighbour. Direction or no attacks was chosen with uniform probability. Argument and attack probabilities are picked from {0.1, 0.2, ..., 1}, with probabilities $\\frac{\\aleph}{10}$ for uncertain and $\\frac{10 - \\aleph}{10}$ for 1. We let k \u2208 {3,4,5,6,7} and \u03b7\u2208 {5, 10, 20, 50, 75, 100, 150}. Tree-width of such grid-graphs is bounded by min(k, n). For each (k, n) we generated 4 PAFs and a set S to be checked by selecting a \u2208 A with probability 0.04.\nSetup and Results The experiments were carried out on a Linux machine (64-bit), with an 8-core i5 Intel CPU and 16 GB of memory. We enforced a runtime of maximum 300 seconds and a memory limit of 8192 MB per run.\nAs expected, the brute-force algorithm enumerating subframeworks and extensions timed out on most instances. In Table 1 we show the number of timeouts and median running times of solved instances. In the results, our approach scales with tree-width: no timeouts were reported with instances having tree-width at most 5. Note that PAFs with k = 5 include ones with n = 150 and |A| = 750. For a baseline comparison, ASP-#Ext showed significantly more timeouts. We speculate this is due to the high number of such subframeworks, e.g., one instance reported more than 6.107 subframeworks.\nRegarding precision, using floats the results, in fact, differ to fractions: in four instances the former reported 0, while the result is higher than 0 (although low). Moreover, in one PAF TD-Ext-f reported 9.6. 10-15 and TD-Ext-r returned 7.10-15. While the absolute difference is low, the percentage the former approach is off is roughly one-third. On the other hand, in many runs the results reported were close. We speculate that this is due to having many operations summing or multiplying in the dynamic programming algorithms. Due to similar performance of TD-Ext-f and TD-Ext-r, it does appear to give TD-Ext-r an edge."}, {"title": "7 Extensions", "content": "Our algorithm presented in Section 5 can be extended, and we discuss here possible extensions.\nFirst, in addition to enforcing arguments to be \u201cin\u201d (as in the P-Ext problem), we can also directly enforce arguments to be O or U.\nThis is direct in the algorithm: in introduction nodes we can restrict generation of rows to exactly those fitting the chosen criteria. For instance, only constructing labelings with a chosen argument assigned \u201cout\u201d or \u201cundecided\".\nSecond, as discussed by Fazzinga, Flesca, and Furfaro (2019), we can introduce dependencies between arguments. For instance, consider the case that whenever a subframework contains an argument a then such a subframework also must contain an argument b. Then, as discussed by Fazzinga, Flesca, and Furfaro, one can specify marginal probabilities of the three different cases: containing neither argument, containing only b and containing both.\nThis can be achieved, by considering, in the tree-decomposition generation, an additional edge between a and b, representing an additional dependency. This additional edge ensures that a or b can only be forgotten if the other argument was already seen.\nThen computation of probabilities must be deferred until both arguments a and b are in a bag (only then can we compute the marginal probability of this case). As discussed earlier (Wallner 2020), implication dependencies such as these can be important for representing internal structure of arguments, while at the same time, as discussed by Fazzinga, Flesca, and Furfaro, allowing for compact representation of probabilities by marginal probabilities. For instance, if an argument a is a sub-argument of b, when considering the internal structure of these arguments, then having b but not a might be unwarranted. Or, for instance, if the contents of arguments a and b together imply existence of an argument c, then dependency edges between all can be added, and marginal probabilities of the different cases considered.\nFinally, to adapt Algorithm 1 to admissible sets or stable extensions, the condition for semantics can be directly adapted: for admissibility the checks for undecidedness can be omitted, while for stable semantics, introduction nodes are not allowed to assign arguments to undecided."}, {"title": "8 Discussion", "content": "In this work we revisited computationally complex problems in probabilistic argumentation under the constellation approach. We refined earlier complexity results", "approach": "PAFs with up to 750 arguments were solved regularly", "in": "and allowing also other arguments to be \u201cin\u201d we can extend the algorithm to consider also other extensions that contain a queried argument. However"}, {"in": "ver-counts", "tree-decompositions": "acyclic PAFs may have a tree-width higher than one.\nAs a more general direction", "title": "Advancing Algorithmic Approaches to Probabilistic Argumentation under the Constellation Approach", "authors": ["Andrei Popescu", "Johannes P. Wallner"], "abstract": "Reasoning with defeasible and conflicting knowledge in an argumentative form is a key research field in computational argumentation. Reasoning under various forms of uncertainty is both a key feature and a challenging barrier for automated argumentative reasoning. It was shown that argumentative reasoning using probabilities faces in general high computational complexity, in particular for the so-called constellation approach. In this paper, we develop an algorithmic approach to overcome this obstacle. We refine existing complexity results and show that two main reasoning tasks, that of computing the probability of a given set being an extension and an argument being acceptable, diverge in their complexity: the former is #P-complete and the latter is # NP-complete when considering their underlying counting problems. We present an algorithm for the complex task of computing the probability of a set of arguments being a complete extension by using dynamic programming operating on tree-decompositions. An experimental evaluation shows promise of our approach.", "sections": [{"title": "1 Introduction", "content": "The field of computational argumentation is nowadays a cornerstone of approaches to automated and rational argumentative reasoning within Artificial Intelligence (\u0391\u0399). Application avenues for this field include legal reasoning, medical applications, and multi-agent systems, see, e.g., the overview given by Atkinson et al. (2017).\nCentral to computational argumentation are formal approaches that define how reasoning is carried out. Common to many forms of argumentative reasoning is the utilization of argumentation frameworks (AFs), in which arguments are represented as vertices and directed edges among arguments represent a directed conflict, or attack, relation. Importantly, it oftentimes suffices to abstract the internal structure of arguments, in order to find acceptable (sets of) arguments.\nArgumentation semantics specify which arguments can be deemed acceptable, and several such semantics exist for different purposes. A prominent property of such semantics is that of admissibility. A set of arguments is admissible if there are no attacks between two arguments in the set (i.e., they are conflict-free), and for each attack from outside the set onto the set there is a counter-attack from within, defending each argument in the set. An admissible set containing all arguments defended is called a complete extension.\nTowards offering advanced forms of argumentative reasoning, AFs have been extended in several directions. Recently, approaches that incorporate forms of uncertainty gained traction in research, e.g., by incorporating weights or allowing for forms of incompleteness. In probabilistic argumentation, uncertainty is captured by probabilities of, e.g., arguments and attacks, making them uncertain. Two main approaches to formalization of probabilities in AFs are the epistemic approach and the constellation approach.\nIn the constellation approach, subframeworks of a given AF constitute possible scenarios, thereby including only a part of the given AF. Each such subframework is associated with a probability, stating how probable this particular sub-framework (argumentative scenario) is. Two main reasoning tasks are then to compute the probability that a set is an extension under a specified semantics, such as complete semantics, and (credulous) acceptability of an argument. The former is defined as the sum of probabilities of subframeworks where the set is an extension, and the latter as the sum of probabilities of subframeworks where there is an extension containing the specified argument.\nFazzinga, Flesca, and Furfaro (2019) showed that these two problems are FP#P-complete, e.g., for the complete semantics and when the probabilities are compactly represented as marginal probabilities of arguments and attacks with independence assumptions. Intuitively, their complexity results indicate that it is very challenging to compute the results: #P (or FP#P) hard problems are presumed to be very difficult problems to solve. For instance, the archetypical #P-complete problem is that of counting the number of satisfying truth-value assignments of a Boolean formula. Counting and probabilities are indeed connected, e.g., if each subframework has the same probability, the reasoning tasks above amount to counting the subframeworks satisfying the chosen criteria.\nThe high computational complexity was likely so far a major barrier for development of algorithmic approaches and systems for solving tasks in probabilistic argumentation. To the best of our knowledge, there are not many algorithms and systems for the constellation approach for AFs for the computationally hard tasks. As an exception, Fazzinga et al. (2019) provide algorithms for bipolar frameworks, yet for probabilistic AFs their results do not apply to FP#P-complete reasoning tasks. In this paper we take up this challenge and develop an algorithmic approach to probabilistic argumentation frameworks under the constellation approach.\nOur main contributions are as follows.\n\u2022 We first refine the complexity results by Fazzinga, Flesca, and Furfaro (2019), who showed that computing the probability of a set being an extension and acceptability share the same complexity. We show, using counting complexity classes, that their underlying counting problems differ in their complexity: the former problem is #P-complete, for the complete semantics, and the latter is # NP-complete for admissible, complete, and stable semantics, indicating a jump in the counting complexity hierarchy. Moreover, even when restricting to acyclic attack structures, the latter problem remains #P-complete.\n\u2022 Next we look into algorithms to solve these tasks. Towards efficient reasoning, we give results in preprocessing probabilistic AFs to simplify given instances.\n\u2022 Inspired by their capability of solving #P-hard problems, we develop a dynamic programming algorithm for probabilistic AFs utilizing tree-decompositions. Our algorithm is capable of solving the FP#P-complete problem of computing the probability of a set being a complete extension.\n\u2022 We experimentally evaluate a prototype of our algorithm, which will be publicly available under an open license, and show promise of our approach that solves PAFs up to 750 arguments, depending on the attack-structure.\n\u2022 Finally, we discuss extensions of our approach, e.g., to incorporate dependencies among arguments, relaxing independence assumptions.\nWe give further (proof) details in the supplement."}, {"title": "2 Background", "content": "We recall main definitions of argumentation frameworks (AFs) and probabilistic argumentation under the constellation approach. Moreover, we recap the notion of tree-width and tree-decompositions required for our work.\nDefinition 1. An argumentation framework (AF) is a pair (A, R) where A is a finite set of arguments and $R \\subseteq A \\times A$ is an attack relation.\nFor a given AF F = (A, R), if (a, b) \u2208 R, then a attacks b (in F). Similarly, a set S \u2286 A attacks b \u2208 A if there is an a \u2208 S that attacks b (in F).\nFor specifying possible AFs, we make use of the notion of subframeworks. A subframework of an AF F = (A, R) is an AF F' = (A', R') with A' \u2286 A and R' \u2286 R. Note that F' is an AF, thus R' \u2286 A' \u00d7 A' holds. The set of all subframeworks is denoted by $F(F) = {F' \\mid F' \\text{ a subframework of } F}$.\nArgumentation semantics on AFs are defined via functions \u03c3(F), for a given AF F = (A, R), that assign subsets of the arguments as \u03c3-extensions, i.e., \u03c3(F) \u2286 2A. Central to AF semantics is the notion of defense.\nDefinition 2. Let F = (A, R) be an AF. A set of arguments S \u2286 A defends an argument a \u2208 A if it holds that whenever (b, a) \u2208 R there is a c \u2208 S with (c, b) \u2208 R.\nWe next define main semantics on AFs.\nDefinition 3. Let F = (A, R) be an AF. A set S \u2286 A is conflict-free (in F), if there are no a, b \u2208 S, s.t. (a, b) \u2208 R. We denote the collection of conflict-free sets of F by cf(F). For a conflict-free set S \u2208 cf(F), it holds that\n\u2022 S\u2208 stb(F) iff S attacks each a \u2208 A \\ S;\n\u2022 S\u2208 adm(F) iff S defends each a \u2208 S;\n\u2022 S\u2208 com(F) iff S \u2208 adm(F) and whenever a \u2208 A is defended by S, then a \u2208 S; and\n\u2022 S\u2208 grd(F) iff S \u2208 com(F) and there is no T \u2208 com(F) with T\u2286S.\nWe refer to subsets of arguments that are in \u03c3(F) as \u03c3-extensions and also as an extension under a semantics \u03c3, for \u03c3\u2208 {stb, adm, com, grd}.\nFor developing our algorithms later on it will be useful to also consider the labeling-based definitions of the argumentation semantics.\nDefinition 4. Let F = (A, R) be an AF. A labeling $L : A \\rightarrow {I, O, U}$ in F is a function assigning a label to each argument in F.\nIntuitively, I (\"in\") signals accepting the argument in a labeling, O (\"out\") is interpreted as attacked by accepted arguments, and U (\u201cundecided\u201d) takes neither stance. We sometimes use partial labelings, which are labelings where L is partial. To distinguish extensions and labelings under a semantics, we use & and $Lab$, respectively, unless clear from the context. We sometimes view labelings as triples, arguments assigned I, O, and U, respectively.\nDefinition 5. Let F = (A, R) be an AF. For a labeling L in F it holds that\n\u2022 $L\\in adm^{Lab}(F)$ iff for each a \u2208 A we find that\n$L(a) = I$ implies that L(b) = O if (b, a) \u2208 R and\n$L(a) = O$ implies \u2203(b,a) \u2208 R with L(b) = I,\n\u2022 $L\\in com^{Lab}(F)$ iff $L \\in adm^{Lab}(F)$ and for $a \\in A$ $L(a) = U$ implies \u2203$(b,a) \\notin R$ with $L(b) = U$ and\n$\u2203(b,a) \\notin R$ with L(b) = I, and\n\u2022 $L\\in stb^{Lab}(F)$ iff for all a \u2208 A it holds that L(a) \u2260 U and $L \\in adm^{Lab}(F)$."}, {"title": "3 Complexity Results for Probabilistic AFs", "content": "We investigate the complexity of probabilistic reasoning. In particular, we present novel results for counting variants of probabilistic reasoning. Fazzinga, Flesca, and Furfaro (2019) proved the results that, e.g., it is FP#P-complete to compute the probability of a set of arguments being a complete extension and to compute the probability of accepting an argument under complete semantics.\nWe refine their results, and show that the complexity of problems of computing the probability of a set of arguments and acceptability of an argument diverges on their underlying counting problems. Towards our result, we also consider the counting complexity classes #P and #NP. These \"dot\" classes are from a hierarchy of counting complexity classes, and are defined as follows. A counting problem is defined via a witness function $w : \\Sigma^* \\rightarrow P_{<w}(\\Gamma^*)$ that assigns, given a string from alphabet \u03a3 a collection of (finite) subsets from alphabet \u0393. The task is to count |w(x)], given x. Additionally, we require that each witness $y \\in w(x)$ is polynomially bounded by x. A counting problem is in #C, for a class of decision problems C, if given x and y the problem to decide whether $y \\in w(x)$ is in C. For illustration, the archetypical #P-complete (as for #P) is #SAT, with the witness function assigning satisfying truth-value assignments to a formula. It holds that #P = # \u00b7 P, i.e., we can interchangeably use these two classes.\nLet us consider the following counting problems, for a given PAF F = (A, R, P) and semantics \u03c3:\n\u2022 given a set of arguments $S \\subseteq A$, count the number of subframeworks $F' \\in F_p(F)$ for which we find that S is a \u03c3-extension in F', and\n\u2022 given an argument a \u2208 A, in how many subframeworks $F' \\in F_P(F)$ is it the case that there is an $S \\in \\sigma(F')$ with a \u2208 S?\nAs the example suggests, counting the number of sub-frameworks that satisfy the above criteria acts as special case of computing probabilities of a set being an extension or of the acceptability of an argument.\nWe start with the problem of counting the number of subframeworks where a given set is an extension. While we will show #P-completeness (# \u00b7 P-completeness), we first argue that this problem is not #P-hard under parsimonious reductions. The type of reductions is important for counting complexity classes, since closure of counting classes under some types of reductions is not immediate. A reduction is parsimonious if a counting problem is transformed to another in polynomial time and the number of solutions (cardinality of their respective witness sets) is preserved exactly.\nBy a result of Fazzinga, Flesca, and Furfaro, Theorem 2 (2020), it holds that one can check in polynomial time whether some subframework has a queried set as a complete extension. This directly prevents existence of a parsimonious reduction in our case, under complexity theoretic assumptions. If there were a parsimonious reduction from #SAT to this problem, one could solve SAT in polynomial time: one can reduce a Boolean formula to the current problem and in polynomial time find one suitable subframework, which in turn implies that there is a satisfying truth value assignment of the formula."}, {"title": "4 Preprocessing Probabilistic AFs", "content": "Here we look at preprocessing for PAFs. In general, preprocessing is seen as a vital component for solving hard problems, e.g., in SAT solving to simplify instances.\nFormally, let us define A(F), for a given PAF F = (A, R, P) and a given partial labeling L, that returns a partial labeling L' as follows. L'(a) is I if for all attacks of (b, a) in F it holds that L(b) = O. L'(a) is O if there is an attack (b, a) in F we find that P(b) = 1, P(b,a) = 1 and L(b) = I. We have to label an argument \"in\" if the argument is present in a subframework and for all attacks (if existing) it is clear that they are \"defeated\". An argument is \"out\" if a certain argument labeled I and attack designate it to be out. Let L be the least-fixed point of this function. It holds that for P-Ext and a given set S, the probability is 0 if S contains an argument labeled \"out\" in L. Moreover, if an argument a \u2209 S is labeled \u201cin\u201d by L, then (i) if a is certain, the probability is 0 and (ii) if a is uncertain only subframeworks without a can have S as a complete extension. For P-Acc an argument a labeled \"out\" in L has 0 probability."}, {"title": "5 Tree-Decomposition-based Algorithm", "content": "In this section we develop our algorithm for computing the probabilities of a given set being an extension (P-Ext). We illustrate our algorithms mainly on the complete semantics, yet our algorithms can be utilized also for admissible sets and stable semantics. Nevertheless, under complete semantics the considered problem is FP#P-complete.\nOur algorithm operates on tree-decompositions, more specifically so-called nice tree-decompositions, for a given PAF F = (A, R, P). A nice tree-decomposition is a tree-decomposition where, additionally, we find that each node is one of the following types:\n\u2022 a root node or a leaf node with empty bags,\n\u2022 a join node t with exactly two children, t\u2081 and t\u2082, such that Bt = Bt\u2081 = Bt2,\n\u2022 an introduction node t with exactly one child t' such that Bt = Bt \u222a {x} and x \u2208 A, or\n\u2022 a forget node t with exactly one child t' such that Bt = Btv \\ {x} and x \u2208 A.\nThe first condition (empty bags for the root and leaf nodes) is not in the original definition of nice tree-decompositions, but can be imposed directly and is useful for developing our algorithm. A join node has two children and all share the same bag, introduction and forget nodes each have one child and either introduce exactly one or forget exactly one argument. Given a (not nice) tree-decomposition, a nice tree-decomposition can be obtained in linear time.\nFor a constant k, there is a linear-time algorithm that checks whether a given undirected graph has tree-width k, and if reporting positively, also can return a tree-decomposition of minimum width. Practically, we employ a library using heuristics for generation for any given PAF.\nThe algorithm we develop performs a bottom-up computation on a nice tree-decomposition. Starting from the leaves, for each bag a table of rows is computed. Each row can be seen as a partial solution, applicable to the part of the PAF that was visited so far.\nAlgorithm 1 is the main algorithm, which calls sub algorithms depending on the type of the current node. In Line 1 we construct a nice tree-decomposition of the given PAF and initialize an empty table (set) for each bag in Line 2. We go over all bags in post-order in the loop in Line 3. After the case distinction for each type of nodes, we return the probability given in (0, 0, p) in the root of the tree-decomposition. There is only one such row in each computation.\nFor a given (input) PAF F = (A, R, P), we make use of some auxiliary definitions and shorthands. The main datastructure of our algorithms is a row (s, w, p) in a table, which is composed of a structure s, a witness w, and a probability p\u2208 [0, 1]. A structure s = (F', L') is a pair of a subframework F' of Fp(F) and a labeling L' in F'. What we call a witness w contains a labeling-witness lw, which is a partial labeling in F'.\nIntuitively, if a row (s, w, p) is computed in a table Tt for node t and bag Bt, this means that the sum of probabilities of all \"completions\" of s to arguments in $B_{<t}$ that respect the witness w is equal to p. With $B_{<t} = \\cup_{t'\\in T'} B_{t'}$ we define the union of all bags in the subtree T' with root t. For instance, $B_{<4}$ of Figure 3 is {a, b, c}. A completion of a structure s to $B_{<t}$ (all arguments \"seen\") are all completions of the current subframework to subframeworks containing arguments and attacks in $B_{<t}$ (and taking certain parts into account), as well as all labelings that extend the one in s up to $B_{<t}$. These labelings have to satisfy that those arguments in S that are in $B_{<t}$ (i.e., S \u2229 $B_{<t}$) are labeled I, and for all arguments already seen but not in the current bag ($B_{t} \\setminus B_{<t}$) the conditions of being complete are satisfied. For the arguments inside the bag, whenever the label-witness assigns \"out\" or \"undecided\" to an argument, there must be a reason. This means, if one extends the structure s in all possible ways up to $B_{<t}$ that still adhere to the conditions of sub-frameworks of PAFs and complete labelings for those arguments outside the bag, all these structures are \"valid\" subframeworks to sum. Since, by construction, the root node has an empty bag, and all arguments have been traversed before, all subframeworks have been considered and their labelings where S is complete (there is exactly one such labeling in each subframework), the result in the root node is the probability of S being a complete extension.\nA witness w is used to \"remember\" facts that decide whether the row can be associated to a complete labeling.\nWe next make the above intuition more formal. Let r = (s,w,p) be a row in $\u03c4_{t}$ for node t with s = (F', L') and w = lw, for a given PAF F = (A, R, P). Define that F\" = (A\", R\") is an expansion of F' and Bt if A' \u2286 A\", R'\u2286 R\", (Bt \\ A') \u2229 A\" = 0, and no attacks possible via arguments in Bt that are not in R' are in R\". Let $F_{<t} = (A_{<t}, R_{<t}) \\in F_p(F)$ be the sub-framework s.t. $A_{<t} = B_{<t}$ and $R_{<t} = R \\cap A_{<t}$. Then $F_t(F) = {F\" \\in F_p(F_{<t}) \\mid F\" \\text{ expands } F' \\text{ and } B_t}$ is the set of all subframeworks with contents restricted to $B_{<t}$ expanding F'.\nFor L', its completion to A\" \u2283 A' is a labeling that assigns the same labels to those in A' as L' and some labeling to those in A\" \\ A'. A labeling L\" on a subframework F\" is said to be partially complete w.r.t. bag Bt, set S, and labeling-witness lw if for each argument a in F\" the following holds. If a \u2208 B<t \\ Bt then L(a) = I implies all attackers in F\" are O, L(a) = O implies there is an attacker in F\" that is I, and L(a) = U implies no attacker is I and there is an U attacker. For arguments a \u2208 Bt, we require that L(a) = I implies that all adjacent arguments are O, lw(a) = O iff there is an attacker that is I in F\", and lw(a) = U iff there is an U attacker und no attacker is I. Finally each argument in S must be assigned \u201cin\u201d. That is, the conditions for complete labelings is satisfied for arguments already \u201cseen\u201d but forgotten, and for arguments in the current bag, we only require (i) conflict-freeness and (ii) if the labeling-witness specifies an argument to be \"out\" or \"undecided\", there is a justification.\nLet X be the set of pairs (F\", L\") such that F\" \u2208 F(F) and L\" is partially complete in F\" w.r.t. bag Bt, set S and lw. It holds that p is the sum of all subframeworks in X (restricted to components in B<t. Intuitively, X contains all \u201ccompatible\u201d subframeworks that respect the witness, the current labeling, and the queried set S, but relaxing the conditions for the arguments inside the bag, since adjacent arguments might not be traversed yet.\nAlgorithm 2 presents our approach to introduction nodes t. The child node of t is t' and T' contains the rows for t'. Intuitively, for each row r' = (s, w,p) from t' we compute new rows r, by either adding the introduced argument a or not to the subframework in s (Line 2 and Line 5). If the argument was added, then for each possible way of labeling the new argument (Line 3) we compute new labelings and update witnesses.\nGiven a PAF F = (A, R, P), as a shorthand, we define $S_{s+a}(F)$, for a structure s = (F', L') with F' = (A', R'), an argument a, to be all structures that may extend s with a new argument a. We define the set of AFs extending F' by adding a and possibly incident attacks.\n$F'_{+a} = {F'' = (A'', R'') \\in F_p(F) \\mid A'' = A' \\cup {a}, \\newline R' \\subseteq R'' \\subseteq R' \\cup ({(a, x), (x, a) \\mid x \\in A''} \\cap R)}$\nThen $S_{s+a}(F)$ is equal to {(F\",L\") | $F'' \\in F'_{+a}$, L\" completion to F\"}. That is, Ss+a contains all pairs with an AF F\" and labeling L\" such that F\" additionally contains a, all arguments and attacks from F', and may add attacks of a (restricted to those originally in R).\nWhen adding an argument a, the probability is updated by multiplying with P(a) and considering the factors for each added attack in the structure (Add(s, a)) and attack from R not added (Rem(s, a)).\n$UpP(s, a, p) = p \\cdot P(a) \\cdot Atts(s, a)$\n$Atts(s, a) = \\frac{\\prod_{r\\in Add(s,a)} P(r)}{\\prod_{r \\in Rem(s,a)} (1 - P(r))}$\nThe witnesses are updated as follows: UpW(s,w) = w\u222a {x \u2192 O | (y, x) \u2208 R,L(y) = I} \u222a {x \u2194 U | (y,x) \u2208 R, L(y) = U}. In brief, we store whenever an argument can be assigned to \"out\" or \"undecided\": if there is an attacked argument that is \"undecided\" then its attacker must also be \"undecided\", as required for the complete semantics. An \"in\" attacker is taken care of by requiring in introduction nodes all adjacent arguments to be \"out\", as specified in the following.\nThe condition intro(s) ensures that the labelings in s are conflict-free, i.e., not adjacent arguments are labeled \"in\" and arguments adjacent to ones labeled I are labeled O. For a resulting set of rows T, the function checkAcceptance(T) filters those rows where S is not labeled I. In practice, this filter can be applied earlier (during row construction). For the sake of readability, we opted to show this filter here.\nLet us move to forget nodes (Algorithm 3). The main idea is that an argument a is \"forgotten\" in a bag (compared to the bag of the unique child in the nice tree-decomposition). This is the point in the algorithm where we can verify that the label assigned to a does not violate the conditions for being complete, since all adjacent arguments were traversed already. The witness-label lw for a enables us to check conditions for a.\nSay we are in node t with child node t'. Consider a row from t' as r' = (s', w', p') with s' = (F', L'). If we assume that p' is the sum of probabilities of subframeworks in X, then to compute a new row r = (s, w,p), based on r', we need to make sure that for all subframeworks and labels associated with X we get that (i) the now forgotten argument satisfies the complete conditions and (ii) that we capture all subframeworks with the new row.\nTo check the conditions for partial completeness, if L'(a) = I, then all attackers in subframeworks in X are labeled \"out\", by assumption of correctness of the child node. If L'(a) = O, we need to make sure that there is an \u201cin\u201d attacker. This is the case for all subframeworks in X if lw(a) = O. Analogously, we verify the partial completeness condition for L'(a) = U. If one of the checks fails, the row r' is discarded, which we denoted by $\u03c3_{forget}(s, w, a)$. By s-a and w- a we denote the removal of a from structure (and incident attacks) and witness.\nFinally, after forgetting a node in rows r', multiple rows can coincide on their (s, w) part: these need to be summed (\"collapse\" now to one row).\nAlgorithm 4 Join(\u03c41, \u03c42, B)\n1: T := {(s, w1 \u222a w2, comp(p1,p2,s)) | (s,w1,p1) \u2208 \u03c41, (s, w2, p2) \u2208 \u03c42}\n2: T := Merge(T)\n3: return T"}, {"title": "6 Experimental Evaluation", "content": "We evaluate our algorithm for P-Ext, focusing on the FP#P-complete variant for complete semantics.\nImplementations We implemented our algorithm in a Python (3.9.7) prototype. As suggested by Dewoprabowo et al. (2022), we partially make use of database tools: the most expensive operations (join and forget) make use of a Python library for database management.\nDue to operations on small numbers, we implemented two variants, one using floating-point numbers dubbed TD-Ext-f, and one using rational numbers, called TD-Ext-r. For computing a nice tree-decompositions, we used the htd library. To the best of our knowledge, there are no competing systems available that are tailored towards performance. For a baseline comparison, we implemented two more systems: (i) a naive brute-force algorithm enumerating pairs of subframeworks and extensions in Python and (ii) and answer set programming (ASP) based implementation ASP-#Ext for counting subframeworks where S is complete. Note that this implementation does not solve the same problem, but a simpler one, and is intended mainly as a basis for comparison.\nInstances There is currently no standard benchmark set for PAFs. We constructed PAFs with a controlled tree-width and focused on instances not solved via preprocessing, i.e., do not contain many certain arguments and attacks. We constructed PAFs based on grids (k,n) with possible attacks (bidirectional, one-directional, or no attack) for each horizontal or vertical neighbour. Direction or no attacks was chosen with uniform probability. Argument and attack probabilities are picked from {0.1, 0.2, ..., 1}, with probabilities $\\frac{\\aleph}{10}$ for uncertain and $\\frac{10 - \\aleph}{10}$ for 1. We let k \u2208 {3,4,5,6,7} and \u03b7\u2208 {5, 10, 20, 50, 75, 100, 150}. Tree-width of such grid-graphs is bounded by min(k, n). For each (k, n) we generated 4 PAFs and a set S to be checked by selecting a \u2208 A with probability 0.04."}, {"title": "7 Extensions", "content": "Our algorithm presented in Section 5 can be extended, and we discuss here possible extensions.\nFirst, in addition to enforcing arguments to be \u201cin\u201d (as in the P-Ext problem), we can also directly enforce arguments to be O or U.\nThis is direct in the algorithm: in introduction nodes we can restrict generation of rows to exactly those fitting the chosen criteria. For instance, only constructing labelings with a chosen argument assigned \u201cout\u201d or \u201cundecided\u201d.\nSecond, as discussed by Fazzinga, Flesca, and Furfaro (2019), we can introduce dependencies between arguments. For instance, consider the case that whenever a subframework contains an argument a then such a subframework also must contain an argument b. Then, as discussed by Fazzinga, Flesca, and Furfaro, one can specify marginal probabilities of the three different cases: containing neither argument, containing only b and containing both.\nThis can be achieved, by considering, in the tree-decomposition generation, an additional edge between a and b, representing an additional dependency. This additional edge ensures that a or b can only be forgotten if the other argument was already seen.\nThen computation of probabilities must be deferred until both arguments a and b are in a bag (only then can we compute the marginal probability of this case). As discussed earlier (Wallner 2020), implication dependencies such as these can be important for representing internal structure of arguments, while at the same time, as discussed by Fazzinga, Flesca, and Furfaro, allowing for compact representation of probabilities by marginal probabilities. For instance, if an argument a is a sub-argument of b, when considering the internal structure of these arguments, then having b but not a might be unwarranted. Or, for instance, if the contents of arguments a and b together imply existence of an argument c, then dependency edges between all can be added, and marginal probabilities of the different cases considered.\nFinally, to adapt Algorithm 1 to admissible sets or stable extensions, the condition for semantics can be directly adapted: for admissibility the checks for undecidedness can be omitted, while for stable semantics, introduction nodes are not allowed to assign arguments to undecided."}, {"title": "8 Discussion", "content": "In this work we revisited computationally complex problems in probabilistic argumentation under the constellation approach. We refined earlier complexity results, showing a divergence between complexities of two main reasoning tasks. For the problem of computing the probability of a set of arguments being complete, we developed a dynamic programming algorithm. Our experimental evaluation shows promise of the approach: PAFs with up to 750 arguments were solved regularly, depending on the attack-structure and tree-width.\nAlgorithmic approaches utilizing tree-decompositions were investigated before for formal argumentation, also for counting extensions containing queried arguments in AFs, and, e.g., for model counting in Boolean logic and weighted model counting. In contrast, we present a novel dynamic programming algorithm for probabilistic argumentation under the constellation approach.\nFor future work, an interesting avenue is to extend our work for acceptability of arguments in PAFs, under the constellation approach. We think that our Algorithm 1 provides a useful basis for computing acceptability. The main barrier is to avoid over-computation, or over-summation. For instance, by slightly relaxing our algorithm to have a queried argument to be assigned \u201cin\u201d, and allowing also other arguments to be \u201cin\u201d we can extend the algorithm to consider also other extensions that contain a queried argument. However, directly counting all pairs of subframeworks and labelings assigning a queried argument to be \u201cin\u201d over-counts, since there might be many such labelings in a particular sub-framework.\nWe think that this way of over-counting can be addressed in a dynamic programming way operating on tree-decompositions, but requires more work for a detailed investigation. We remark that Theorem 5 (hardness of acyclic PAFs) does not prevent existence of algorithms for acceptability using tree-decompositions: acyclic PAFs may have a tree-width higher than one.\nAs a more general direction, we think that future work, to advance complex reasoning in probabilistic argumentation further, should include also different forms of optimizations. For instance, an (NP-hard) preprocessing might be beneficial for dynamic programming algorithms that can restrict the number of rows in tables, e.g, by pre-computing impossible combinations (e.g., argument a is never \u201cin\u201d in any subframework). While these problems can be complex themselves, we think that they can overall be used to optimize tree-decomposition-based algorithms."}]}]}