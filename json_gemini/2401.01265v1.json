{"title": "Optimal Synthesis of Finite State Machines with Universal Gates using\nEvolutionary Algorithm", "authors": ["Noor Ullah", "Khawaja M. Yahya", "Irfan Ahmed"], "abstract": "This work presents an optimization method for the synthesis of finite state machines. The focus is on the reduction in the on-chip area and the cost of the circuit. A list of finite state machines from MCNC91 benchmark circuits have been evolved using\nCartesian Genetic Programming. On the average, almost 30% of reduction in the total number of gates has been achieved. The\neffects of some parameters on the evolutionary process have also been discussed in the paper.", "sections": [{"title": "1. INTRODUCTION", "content": "Circuit size and cost are among the main issues in\ndigital circuit design these days. Finite State Machines (FSMs)\nare considered as the heart of sequential systems. FSMs are\ngenerally referred to the two models of sequential digital\ncircuits namely Mealy and Moore models. Mealy model\ndescribes the output of a system as a function of both the input\nand current state. Moore model expresses it in terms of the\ncurrent state only. These sequential systems consist of\ncombinational logic circuits, which are connected to the\nstorage elements making feedback path. Designing of FSMs\ninvolves seven crucial steps [1]. One of the most vital steps is\nto obtain optimal state equations, which include input and\noutput variables. This is an indispensable step towards an\nefficient, small and cost effective hardware design.\nThis paper focuses on the objective to obtain an optimal\ncombinational logic circuit for the FSM. The primary goal is\nto reduce the number of gates as much as possible. This leads\nto a reduction in total number of MOSFETs, which saves the\non-chip area of FSMs and reduces the cost of circuit as well.\nMany researchers have worked on the optimization of\nFSMs using different techniques. A symbolic description of\nFSMs has been considered for logic minimization in PLA\nbased machines [2]. S. Devadas introduced algorithms using\nmigration and utilization of don't-care sequences [3]. Cellular\nautomata based synthesis scheme for sequential circuits has\nbeen described [4]. Different genetic algorithms have been\nproposed in the area [5-9]. Heuristic algorithms for two level\nlogic and two-hot encoding have been introduced [10],[11]. R.\nS. Shelar et. al., have decomposed FSMs into two interactive\nmachines [12]. Mean Field Annealing based solution of graph-\nembedding problem has been given [13]. L. Yuan et. al., have\ndevised a state splitting technique for FSMs [14]. The\naforementioned research work is mainly aimed at one of the\ntwo goals or both: First to reduce the number of states that\ndescribe the behavior of FSMs. Secondly, to encode the states\nwith such binary sequences that the switching between the\nstates is minimized. In any case the purpose is a reduction in\ntotal area either as a primary objective or secondary. Three\nMCNC benchmark FSMs have also been evolved using a\nGenetic Programming (GP) [15]. However the above research\nevolves FSMs using many types of logic gates. Shanti et. al.,\nhave presented the evolution of asynchronous sequential\ncircuits using developmental Cartesian Genetic Programming\n[16]. The research was carried out to evolve the combinational\npart for each memory element individually.\nIn this paper, the evolution of combinational logic part of\nFSMs has been proposed using Cartesian Genetic\nProgramming (CGP). The circuits are evolved with universal\ngates (NAND and NOR) only. The evolution encompasses all\nthe state elements and the outputs of the system together in the\nsame program. The benefit of the combined evolution is that\nmany redundant nodes are removed. This results in very\ncompact circuit architecture. The rest of the paper is organized\nin the following manner. Section 2 gives an overview of CGP.\nSection 3 describes the detailed experimental setup. Section 4\nis about the simulation process and results of the experiments.\nSection 5 concludes the paper."}, {"title": "2. CARTESIAN GENETIC PROGRAMMING", "content": "CGP is a variant of GP, which was invented for the\nevolution of digital circuits by Miller and Thompson [17]. In\nCGP programs are represented as directed acyclic graphs in\ncontrast to the conventional tree-based GP. This allows the\nindirect reuse of the nodes. In start the CGP graphs were\nrepresented by two-dimensional grid of nodes. Any number of\nrows, columns and level backs could be chosen by the user,\ncreating a number of different topologies. Later work showed\nthat a special case, having a single row with level backs equal\nto the number of columns was more effective [18].\nA list of integers called genes represents a fixed-length\ngenotype in CGP. It encodes all the incoming and outgoing\nconnections and the function of each node. The decoded\ngenotype is called phenotype. Its size can vary from zero\nnodes to the maximum number of nodes in the genotype. This\nis due to the fact that all the nodes in genotype may not be\nused in the phenotype. Such nodes and their genes that have\nno influence on phenotype are called non-coding. They have a\nneutral effect on the fitness of genotype often called as\nneutrality, which is discussed in detail in [17]. Each\ncomputational node in the genotype represents a function from\na user defined list in a function look-up table and is encoded\nby two types of genes:\ni. The address of a node-function in the function look-\nup table is called a function gene. It decides the\noperation of the node and is always the first gene in\nthe node.\nii. Connection genes are determined by the arity of any\nfunction. They encode the input connections of the\nnodes and are basically indices in an array.\nIn the special case topology described above, a program\ninput or any previous node's output can become the input of\nthe nodes in a feed forward manner. Absolute values are\nassigned to program inputs from 0 to n\u2081-1 where ni is the\nnumber of inputs. The nodes' outputs are also ordered in a\nsequential manner from 0 to ni+m-1, where m is the maximum\nnumber of nodes. At the end of the genotype, as many integers\nas the required number of outputs are added representing the\noutputs, where Each integer represents the address of the node\nfrom where the output is taken. The general form of Miller's\nCGP is shown in figure 1.\nIn CGP, some constraints must be obeyed at the\ninitialization or mutation of genotype. The function gene's\nallele fi for a total number of functions nf must obey the\nfollowing relation:\n$0 \u2264 fi\u2264 ni$  (1)\nThe connection genes' alleles Cij for all nodes in column j\nmust follow the given relations, where I is the value of level-\nbacks:\n$n\u2081 + (j \u2013 l)n, \u2264 Cij \u2264 ni + jnr, if j \u2265 1$ (2)\n$0 \u2264 Cij \u2264 ni + jnr, if j < l$ (3)\nIn CGP, a point mutation operator is used, in which a\nrandomly chosen gene's value is changed with another valid\nrandom value. A valid value for a function gene is any index\nin the function look-up table. For an input gene it is the index\nof any previous node's output or any program input. For an\noutput gene it can take the output index of any node or\nprogram input. Mutation rate, ur is a user defined value (a\npercentage of total number of genes), which gives the number\nof mutations per application of mutation. All the off-springs\ngo through the mutation process.\nIn any CGP program, a fitness criterion must be set, based\non which the decision of when to stop the evolution process is\ntaken. This is determined by the magnitude of error between\nthe evolved output and the desired output. In order to achieve\n100% accuracy, the magnitude of error must be equal to 0.\nDuring the process among the parent and all the off-springs,\nthe one with the least error is considered as the fittest and is\npromoted as a parent for the next iteration. If a parent and an\noff-spring have the same least error then the off-spring is\nconsidered as the fittest. If all of them have the same\nmagnitude of error then any one of the randomly chosen off-\nsprings is considered as the fittest. CGP evolution is\nperformed normally with a simplified form of 1+\u03bb\nevolutionary algorithm, where a is the number of off-springs.\nCGP decoding is done from the output to the input to yield the\nphenotype. The non-coding nodes are ignored in this process."}, {"title": "3. EXPERIMENTAL SETUP", "content": "A one dimensional CGP graph is used for all the\nexperiments, which consists of a single row and m number of\ncolumns and level-backs. The input array in the program\ncontains all the possible combinations of the system inputs\nand the current state values of all the flip flops of FSM. An\narray stores the desired outputs for all the combinations of\ninput array. These outputs are comprised of the system outputs\nand the next state output values of all the flip flops. Another\narray contains the outputs that are created per iteration by the\nCGP program, for all combinations of input array. A\nsimplified form of 1+1 evolutionary algorithm is used for the\nevolution purpose. Two values of \u03bb (4 and 8) are used to\nevolve each FSM separately. The maximum number of nodes\nin the program varies according to the requirement of each\nFSM. The function lookup table contains only NAND and\nNOR functions (which make the universal gates), taking only\ntwo inputs each. The root mean square error between the\ndesired outputs and the CGP evolved outputs, decides the\nfitness of the parent and off-springs. To achieve 100%\naccuracy in the design, the least error must become zero. Point\nmutation operator creates the randomly mutated off-springs. A\nmutation rate ranging from 3% to 10% is used, which depends\non the size of each circuit. The CGP code is written in C++."}, {"title": "4. SIMULATION AND RESULTS", "content": "The CGP evolved circuit design is compared with the\nespresso based architecture of six MCNC91 benchmark FSMs.\nThe same comparison is done for four custom made Moore\ntype sequence detectors also. First, the state transition tables\nare fed into the espresso based software, logic Friday for logic\nminimization. The minimized logic equations are mapped into\nuniversal gates in Logic Friday. The obtained combinational\ncircuit is connected with D flip flops, constructing complete\nFSM. To get the optimized design, the same logic tables are\nused to evolve the circuit in CGP. The evolved circuits have\nbeen tested for all combinations of inputs and yield accurate\noutputs.\nAlmost 30% reduction in number of gates has been\nachieved in CGP evolved MCNC91 FSMs as compared with\nthe conventional espresso based design. Similarly 34%\nreduction in custom made Moore type sequence detectors has\nbeen achieved. This is a significant amount of reduction in the\ntotal number of MOSFETS used to construct the FSMs. So a\nlot of on-chip area can be saved using CGP evolved FSMs.\nAlso smaller design reduces the total cost of the circuit\nespecially in larger FSMs. From the above data it is also\nevident that the reduction in total number of gates using CGP\nis independent of the number of states of FSMs. To\ndemonstration the above results, the circuit diagrams of dk27\nfor the espresso based design and CGP evolved circuit are\nshown in Fig. 3a and b.\nAs mentioned in section 3 that two different values of \u03bb\nare used for CGP evolution, different circuit architectures have\nbeen evolved for each value.\nIn the above results, it is observed that the evolution\nprocess is much faster with a smaller value of \u03bb. \u03bb=4 needs\nlesser number of generations to converge into the desired\ncircuit than 2=8. On the other hand, the later value of \u03bb\nevolves circuits with lesser number of gates than the former.\nSo a simplified version of (1+8) evolutionary algorithm is a\nbetter choice for more compact circuits, which is the primary\ngoal of the paper.\nIt is also observed that for most of the time, a smaller\nvalue of m in the genotype creates much smaller circuits.\nHowever there is a bound on the least value of m, below\nwhich simulation will take forever to converge into a\nparticular FSM. As an example bbara can be evolved with\nm=89 and m=64, where the first case uses 53 nodes to\nconstruct the circuit while the second needs only 43 nodes.\nAnother parameter of CGP that plays a great role in the\nsimulation time and up to some extent on the circuit size is\nmutation rate. A smaller value of u, evolves the FSMs much\nfaster but with a slightly bigger size. So in case of smaller\nFSMs like dk27 and s8 a mutation rate of 10% is used while\n3% in bigger circuits like bbara. Also finding suitable value of\nm could get extremely difficult in bigger circuits with higher\nmutation rate.\nThe circuit diagrams for other evolved MCNC91\nbenchmark FSMs used in the research are given below:"}, {"title": "5. CONCLUSION", "content": "CGP based design shows that a significant reduction in\nthe size of FSMs can be achieved as compared with the\nconventional K-Map or espresso based design hence saving a\nlot of on-chip area and money which is the need of the day in\ndigital electronics industry. To achieve this goal, suitable\nselection of certain CGP parameters is of great importance\ndetermining the trade-off with simulation time.\nIn future this work can be extended to design and\noptimize more complex sequential circuits in terms of power,\ncost, size and propagation delay using either the proposed\nfunctions or other Boolean functions. Different CGP\nparameters can also be evaluated to achieve the required goal."}]}