{"title": "Fast Inference for Probabilistic Answer Set Programs via the Residual Program", "authors": ["Damiano Azzolini", "Fabrizio Riguzzi"], "abstract": "When we want to compute the probability of a query from a Probabilistic Answer Set Program, some parts of a program may not influence the probability of a query, but they impact on the size of the grounding. Identifying and removing them is crucial to speed up the computation. Algorithms for SLG resolution offer the possibility of returning the residual program which can be used for computing answer sets for normal programs that do have a total well-founded model. The residual program does not contain the parts of the program that do not influence the probability. In this paper, we propose to exploit the residual program for performing inference. Empirical results on graph datasets show that the approach leads to significantly faster inference. The paper has been accepted at the ICLP2024 conference and under consideration in Theory and Practice of Logic Programming (TPLP).", "sections": [{"title": "1 Introduction", "content": "Statistical Relational Artificial Intelligence (Raedt et al. 2016) is a subfield of Artificial Intelligence aiming at representing uncertain domains with interpretable languages. One of these languages is Probabilistic Answer Set Programming (PASP) under the credal semantics, i.e., Answer Set Programming (ASP, and we use the same acronym to denote answer set programs) extended with probabilistic facts. Inference in PASP often requires grounding the whole program, due to the model driven ASP solving approach. However, other formalisms based on query driven languages, such as PITA (Riguzzi and Swift 2011) and ProbLog2 (Dries et al. 2015), only ground the relevant part of the program. For a specific class of ASP, namely normal programs without odd loops over negation, we propose to extract the relevant program using SLG resolution (Chen and Warren 1996), that offers the possibility of returning the residual program, which can then be used to compute the answer sets of the program. At a high level, the process is the following: first, we convert a PASP into a Prolog program that is interpreted under the Well-founded semantics. Then, we leverage SLG resolution via tabling to compute the residual program for a given query. Lastly, we convert the residual program into a PASP, often smaller than the original PASP, and call a solver to compute the probability of the query. In this way we reduce the size of the program that should be grounded, consistently speeding up the execution time, as demonstrated by different experiments on graph datasets.\nThe paper is structured as follows: Section 2 provides some background knowledge, Section 3 introduces our solution to extract the residual program, which is tested in Section 4. Section 5 discusses related works and Section 6 concludes the paper."}, {"title": "2 Background", "content": "In this paper, we consider normal logic programs, i.e., programs composed of normal rules of the form r = h : - b\u2081, ..., bm, not c1,..., not cm, where h, b\u1d62 for i = 1, . . ., m and c\u2c7c for j = 1,...,n are atoms. Given a rule r, we call H(r) = h, B\u207a(r) = {b\u2081, ..., b\u2098}, B\u207b(r) = {c\u2081, ..., c\u2099}, B(r) = {b\u2081, ..., b\u2098, not c\u2081, ..., not c\u2099} the head, positive body, negative body and body of r. A rule with an empty body is called fact. We indicate the Herbrand base of a program P with B\u209a and its grounding with ground(P). We use the standard notation name/arity to denote a predicate with name name and arity, i.e., number of arguments, arity. The call graph of a program P is a directed graph with one node for each predicate in the program. There is an edge between a predicate p/n and a predicate q/m if p/n is the predicate of the head atom of a rule and q/m is the predicate of a literal in the body of that rule. The edge is labeled as positive (+) or negative (-) depending on whether the literal is positive or negative in the body of the considered rule. A program P includes Odd Loops Over Negation (OLON) if its call graph contains a cycle with an odd number of negations. Figure 1 shows examples of programs with and without OLON, together with their call graphs. The dependency graph of a program P is a directed graph with one node for each atom in the Herbrand base of the program. There is an edge between an atom a and an atom b if a is the head of a rule in the grounding of P and b is the atom of a literal in the body of that rule. A semantics is relevant (Dix 1995) if the truth value of an atom a depends only from the truth value of the atoms of the relevant sub-graph of the dependency graph, i.e., the sub-graph that contains the nodes that are reachable from a."}, {"title": "2.1 Stable Model Semantics", "content": "The Stable Model Semantics (SMS) (Gelfond and Lifschitz 1988) associates zero or more stable models to logic programs. An interpretation is a subset of B\u209a. The reduct of a ground program P w.r.t. an interpretation I, P\u1d35, also known as Gelfond-Lifschitz reduct, is the set of rules in the grounding of P that have their body true in I, that is P\u1d35 = {r \u2208 ground(P) | B\u207a(r) \u2286 I, B\u207b(r) \u2229 I = \u2205}. A stable model or answer set (AS) of a program P is an interpretation I such that I is a minimal model under set inclusion of P\u1d35. With AS(P) we denote the set of answer sets of a program P. We also consider projected answer sets (Gebser et al. 2009) on a set of ground atoms V, defined as ASv(P) = {A \u2229 V | A \u2208 AS(P)}. Answer Set Programming (ASP) (Brewka et al. 2011) considers programs under the SMS.\nExample 1"}, {"title": "2.2 Well-founded Semantics", "content": "The Well-founded Semantics (WFS) (Van Gelder et al. 1991) assigns a three valued model to a program. A three valued interpretation I is a pair I = (IT; IF) where both IT and IF are disjoint subsets of B\u209a and represent the sets of true and false atoms, respectively. Given a three valued interpretation I = (IT; IF) for a program P, an atom a is i) true in I if a \u2208 IT and ii) false in I if a \u2208 IF while an atom not a is i) true in I if a \u2208 IF and ii) false in I if a \u2208 IT. If a does not belong neither to IT nor IF it is undefined. Furthermore, we define the functions t(I), f(I), and u(I) returning the true, false, and undefined atoms, respectively. Lastly, we can define a partial order on three valued interpretations as (IT; IF) \u2264 (JT; JF) if IT \u2286 JT and IF \u2286 JF.\nWe recall here the iterated fixpoint definition of the WFS from Przymusinski (1989). Consider two sets of ground atoms, T and F, a normal logic program P, and a three valued interpretation I. We define the following two operators:\n\u2022 OTF(T) = {a | a is not true in I and there exist a clause h \u2190 l\u2081,..., lm of P such that a = h\u03b8 for a grounding substitution \u03b8 of the clause and l\u1d62 \u2208 {1, . . ., m}, l\u1d62\u03b8 is true in I or l\u1d62\u03b8 \u2208 T} and\n\u2022 OFF(F) = {a | a is not false in I and for every clause h \u2190 l\u2081,..., l\u2098 and every grounding substitution \u03b8 of the clause of P such that a = h\u03b8 there exist an i \u2208 {1,..., m} such that l\u1d62\u03b8 is false in I or l\u1d62\u03b8 \u2208 F}.\nIn other words, OTF(T) is the set of atoms that can be derived from P knowing I and T while OFF(F) is the set of atoms that can be shown false in P knowing I and F. Przymusinski (1989) proved that both operators are monotonic and so they have a least and greatest fixpoint (lfp and gfp, respectively). Furthermore, the iterated fix- point operator IFPP(I) = I \u222a \u27e8lfp(OTF), gfp(OFF)\u27e9 has also been proved monotonic by Przymusinski (1989). The Well-Founded model (WFM) of a normal program P is the least fixpoint of IFPP, i.e., WFM(P) = lfp(IFPP). If u(WFM(P)) = \u2205 (i.e., the set of undefined atoms of the WFM of P is empty), the WFM is two-valued and the program is called dynamically stratified. The WFS enjoys the property of relevance, and the SMS and WFS are related since, for a normal program P, the WFM of P is a subset of every stable model of P seen as a three-valued interpretation, as proven by Van Gelder et al. (1991)."}, {"title": "2.3 SLG Resolution and Tabling", "content": "SLG resolution was proposed by Chen and Warren (1996) and was proven sound and complete for the WFS under certain conditions. Its implementation in the most common Prolog systems, such as XSB (Swift and Warren 2012) and SWI (Wielemaker et al. 2012), is based on tabling. In the forest of tree model of SLG resolution (Swift 1999), a tree is generated for each sub-goal encountered during the derivation of a query. Nodes are of the form fail or\nAnswerTemplate :- GoalList|DelayList\nwhere AnswerTemplate is a (partial) instantiation of the sub-goal and GoalList and DelayList are lists of literals. DelayList contains a set of literals that have been de- layed, which is needed to allow the evaluation of a query under the WFS (where the computation cannot follow a fixed order for literal selection) with a Prolog engine (where the computation follows a fixed order for selecting literals in a rule). An answer is a leaf with an empty GoalList. It is named unconditional if the set of delayed atoms is empty; conditional otherwise.\nThe XSB and SWI implementations of SLG allow mixing it with SLDNF resolution. To obtain the SLG behavior on a predicate, the user should declare the predicate as tabled via the directive table/1, and use tnot instead of not or \\+ to express negation. After the full evaluation of a query, a forest of trees is built where each leaf node is either fail or an answer. If there are conditional answers, we also get the residual program Pr, i.e., the program where the head of rules have the AnswerTemplate of answer nodes and the body contains the literals of the delay list. SLG resolution is sound and complete with respect to the WFS in the sense that atoms that are instantiations of unconditional answers have value true, those that are instantiations of sub-goals whose tree has only fail leaves are false, and those that are instantiations of conditional answers are undefined in the WFM of the program. Let us now show an example.\nExample 3"}, {"title": "2.4 Probabilistic Answer Set Programming", "content": "The Credal Semantics (CS) (Cozman and Mau\u00e1 2020) allows the representation of un- certain domains with ASP extended with ProbLog probabilistic facts (De Raedt et al. 2007) of the form p\u1d62 :: a\u1d62 where p\u1d62 \u2208 [0,1] is a probability and a\u1d62 is a ground atom. Such programs are called Probabilistic ASP (PASP, and we use the same acronym to denote Probabilistic Answer Set Programs). A world is obtained by adding to the ASP a subset of the atoms a\u1d62 where p\u1d62 :: a\u1d62 is a probabilistic fact. Every PASP with n probabilistic facts has thus 2\u207f worlds. The probability of a world w is computed as: P(w) = \u220fa\u1d62\u2208w p\u1d62 \u00b7 \u220fa\u1d62\u2209w(1 \u2013 p\u1d62). Each world is an ASP and it may have 0 or more answer sets but, for the CS to be defined, it is required that each world has at least one AS. If the ASP is normal without OLON, then the CS exists."}, {"title": "3 Extracting the Residual Program for PASP", "content": "From Example 4, we can see that the probability of the query path(a,d) is not in- fluenced by the probabilistic fact e(a, c). Let us call P(e(a,b)) = p\u2080, P(e(a,c)) = p\u2081, and P(e(b,d)) = p\u2082, for brevity. The upper probability of path(a,d) is computed as P(w\u2085) + P(w\u2087) = p\u2080\u00b7 (1 \u2212 p\u2081) \u00b7p\u2082 + p\u2080\u00b7p\u2081\u00b7p\u2082 = (p\u2080\u00b7p\u2082) \u00b7 ((1 \u2212 p\u2081) + p\u2081) = p\u2080\u00b7 p\u2082, so, the value of p\u2081 is irrelevant, and the probabilistic fact e(a, c) can be removed from the program. However, during the grounding process, the probabilistic fact is still considered, increasing the size of the grounding. The same happens with rules that do not influence the probability of a query. While the programmer should take care of writing a compact program, encoding exactly the minimal information needed to answer a query, this is usu- ally difficult to do. Consider again Example 4: here it is difficult to immediately spot that e(a, c) is irrelevant to the computation of the probability of path(a, d). To overcome this, the PLP systems PITA (Riguzzi and Swift 2011) and ProbLog2 (Dries et al. 2015) build a proof for a query containing only the rules that are actually involved in the probability computation. This is possible in PLP since it enjoys the property of relevance. However, the SMS for normal programs without OLON also enjoys the property of relevance, so we aim to do the same in PASP by exploiting the residual program.\nWe first provide a definition and two results regarding the residual program.\nDefinition 1\nGiven a normal program P, the WF reduct of P, indicated with PWF, is obtained by removing from ground(P) the rules with the body false in WFM(P) and by removing from the body of the remaining rules the literals that are true in WFM(P).\nLemma 1\nGiven a normal program P, AS(P) = AS(PWF).\nProof\nConsider an A \u2208 AS(P). Then t(WFM(P)) \u2286 A and f(WFM(P)) \u2286 (Bp \\ A) (see Section 2.2). Consider a rule r \u2208 PA (i.e., the reduct of P w.r.t. A). Then (PWF)A contains a rule r' that differs from r because the body does not contain literals that are true in all answer sets and so also in A. Since r is satisfied in A, r' is also satisfied in A. So A is a model of (PWF)A. Moreover, A is also a minimal model of (PWF)A, because otherwise there would be at least one atom a that could be removed from A leading to a set A' that would still be a model for (PWF)A. However, since A was minimal for PA, this means that there is a rule r = a :- body with body true in A. Since there would be a rule r' = a : - body' in (PWF)A with body' still true, then a cannot be removed from A against the hypothesis. So A\u2208 AS(PWF).\nOn the other hand, consider an A \u2208 AS(PWF) and a rule r \u2208 (PWF)A. Then ground(P) contains a rule r' that differs from r because the body contains other lit- erals that are true in all answer sets of P. Since r is satisfied in A, r' is also satisfied in A. So A is a model of PA. Moreover, A is also minimal, because otherwise there would be at least one atom a that could be removed from A leading to a set A' that would still be a model for PA. However, since A was minimal for (PWF)A, this means that there is a rule r = a : \u2013 body with body true in A. Since there would be a rule r' = a : - body' in (PWF)A with body' still true, then a cannot be removed from A against the hypothesis.\nSo A \u2208 AS(P). \u25fb\nTheorem 1\nGiven a normal program P without OLON together with its residual program Pr for a query q, the answer sets projected onto the Herbrand base B\u209a\u1d63 of Pr coincide with the answer sets of Pr, i.e.,\nASBp\u1d63(P) = AS(Pr).\nProof\nAS(PWF) = AS(P) by Lemma 1, so we prove that ASBp\u1d63(PWF) = AS(Pr). For the soundness of SLG resolution and the fact it analyses the whole relevant sub-graph, the truth of the body of each rule r \u2208 Pr is not influenced by the truth value of atoms outside B\u209a\u1d63. Therefore, an A \u2208 AS(Pr) can be extended to an A' \u2208 AS(PWF) such that A = A' \u2229 B\u209a\u1d63. Thus, A \u2208 ASBp\u1d63(PWF). In the other direction, if A' \u2208 AS(PWF), consider A = A' \u2229 B\u209a\u1d63. Since B\u209a\u1d63 contains all the atoms in the relevant sub-graph, the truth of the body of each rule r \u2208 Pr is not influenced by the truth value of atoms outside B\u209a\u1d63 and A must be an AS of Pr. \u25fb\nTo consider PASP, we first translate a PASP into a normal program. We convert each probabilistic fact p :: a into a pair of rules:\na:- tnot(na).\nna:- tnot(a).\nwhere na is a fresh atom not appearing elsewhere in the program. This pair of rules encode the possibility that a probabilistic fact may or may not be selected. Then, we replace the negation symbol applied to each atom b with tnot(b) and declare as tabled all the predicates appearing in the program. We extract the residual program and we replace the pair of rules mimicking probabilistic facts with the actual probabilistic fact they represent (i.e., the two rules listed in the previous box are replaced with p :: a). Then, we call a standard solver such as aspmc (Eiter et al. 2021; 2024) or PASTA (Azzolini et al. 2022).\nTheorem 2\nGiven a PASP P together with its residual program Pr for a query q, let P(q) be the upper probability of q in P and P'(q) be the upper probability of q in Pr. Then\nP(q) = P'(q).\nThe same is true for the lower probability.\nProof\nIf the clauses generated for some probabilistic fact are absent from the residual program, they will not influence the probability. Let us prove it by induction on the number n of probabilistic facts whose clauses are absent. If n = 1 and the fact is p\u2081 :: a\u2081, consider an AS A in ASBp\u1d63(Pr), associated to a world w of Pr. Then, there are going to be two subsets of AS(P), A' and A", "A": "I \u2287 A, \u2200I \u2208 A\u2032 : a\u2081 \u2208 I and \u2200I \u2208 A"}, {"A": "s the set of AS of a world v", "v": "However, if q \u2208 A, then \u2200I \u2208 A' \u222a A"}, {"v": "ither both contribute to one of the probability bounds or neither does. The contribution, if present, would be given by P(w) \u00b7 p\u2081 + P(w) \u00b7 (1 \u2212 p\u2081) = P(w), so the fact p\u2081 :: a\u2081 does not influence the probability of q. Now suppose the theorem holds for n \u2013 1 probabilistic facts whose clauses are not present and consider the n-th fact pn :: an. Let us call P* the program P without the fact pn :: an. Then (P*)\u1d63 = Pr and we can repeat the reasoning for n = 1. \u25fb"}, {"title": "4 Experiments", "content": "We ran the experiments on a computer running at 2.40 GHz with 32 GB of RAM with cutoff times of 100, 300, and 500 seconds\u00b9."}, {"title": "4.1 Datasets Description", "content": "We considered two datasets with two variations each and with an increasing number of instances. The reachability (reach) dataset models a reachability problem in a proba- bilistic graph. All the instances have the rules (here we model negation with \\+, since it is the symbol adopted in aspmc):\nedge(X,Y):- e(X,Y), \\+ nedge(X,Y).\nnedge(X,Y):- e(X,Y), \\+ edge(X,Y).\npath(X,Y) :- edge(X,Y).\npath(X,Z) :- edge(X,Y), path(Y,Z).\nwhere the e/2 facts are probabilistic with probability 0.1. We developed two variations for this dataset: reachBA and reachGrid. The difference between the two is in the generation of the e/2 facts: for the former, they are generated by following a Barabasi-Albert model with initial number of nodes equal to the size of the instance and 2 edges to attach from a new node to existing nodes (these two values are respectively the values of the n and m parameters of the method barabasi_albert_graph of the NetworkX Python library (Hagberg et al. 2008) we used to generate them). The query is path(0, n \u2212 1). For the latter, the e/2 facts are such that they form a two-dimensional grid. In this case, the query is path(0, i), where i is a random node (different for every dataset).\nThe smokers dataset contains a set of programs modeling a social network where some people smoke and others are influenced by this behavior. Each person is indexed with a number, starting from 0. The base program is:\ninfluences(X,Y):- e(X,Y), \\+ ninfluences(X,Y).\nninfluences(X,Y):- e(X,Y), \\+ influences(X,Y).\nsmokes(X) :- stress(X).\nsmokes(X) :- smokes(Y), influences(Y,X).\nEach stress/1 atom is probabilistic with probability 0.1 and each influences/2 atom is probabilistic with associated probability 0.2. Also for this dataset we consider two variations, smokersBA and smokersGrid, that are generated with the same structure as for reachBA and reachGrid, respectively. For smokersBA the query is smokes(n - 1) where n is the number of person in the network, while for smokersGrid the query is smokes(i) where i is a random person (different for every dataset). For all the instances, the probability associated with probabilistic facts does not influence the time required to compute the probability of the query."}, {"title": "4.2 Results", "content": "In the following, aspmc denotes the results obtained by applying aspmc directly on the considered instance while aspmc* denotes the results obtained by first computing the residual program and then passing it to aspmc. For all the experiments the extraction of the residual program was done using the predicate call_residual_program/2 available in SWI. The extraction takes less than one second, so we decided to report only the total execution times, without indicating the two components for aspmc*. This is also the motivation behind the decision of testing only one Prolog system, namely SWI. We could have also used XSB but the results would have been much different given the almost instantaneous extraction of the residual program. Given the probabilistic nature of the generation of Barabasi-Albert graphs and of the query for grid graphs, the results are averaged over 10 runs. For reachBA and smokersBA, the query is the same in every run but the structure of the graph changes in every run (i.e., each instance has a different graph structure). For reachGrid and smokersGrid, the grid graph is the same in each of the 10 runs but the query changes in each attempt. Figure 2 and 3 show the"}, {"title": "5 Related Works", "content": "The residual program extraction is at the heart of PITA (Riguzzi and Swift 2011) and ProbLog2 (Dries et al. 2015), the first adopting Prolog SLG resolution to caching the part of the programs that has already been analyzed. There are other semantics to represent uncertainty with an answer set program such as LPMLN (Lee and Yang 2017), P-log (Baral et al. 2009) or smProbLog (Totis et al. 2023). LPMLN allows defin- ing weighted rules and assigns weights to answer sets while P-log adopts probabilistic facts but requires normalization for the computation of the probability. Furthermore, P-log has an interface built on top of XSB (Anh et al. 2008) leveraging its tabling mechanisms to speed up inference. The relation between the two has been studied in detail (Balai and Gelfond 2016; Lee and Yang 2017). Another possibility to associate weights to rules is via weak constraints, available in all ASP solvers, that however cannot be directly interpreted as probabilities. smProbLog is the semantics closest to the CS: both support probabilistic facts added on top of an ASP. The probability of a stable model in smProbLog is the probability of its corresponding world w divided by the number of answer sets of w. The CS has also been extended by Rocha and Gagliardi Cozman (2022) to also handle worlds without answer sets, but it requires three truth values (true, false, and undefined). The residual program extraction may help to speed up inference also in these alternative semantics: exploring this is an interesting future work. We consider the SLG resolution implemented in SWI Prolog. However, as already discussed in Section 2.3, it was initially proposed and implemented in the XSB system (Swift and Warren 2012). Our approach is general and can be built on top of any Prolog system that supports SLG resolution.\nThe problem of grounding in ASP has also been addressed by the s(ASP) (Marple et al. 2017) and s(CASP) Arias et al. (2018) systems, which are top-down goal-driven ASP interpreters (the latter also allowing constraints). The result of a query in these systems is a subset of the stable models of the whole program containing only the atoms needed to prove the query. Furthermore, the evaluation of a query does not need to ground"}, {"title": "6 Conclusions", "content": "In this paper we proposed to speed up inference in PASP via extraction of the residual program. The residual program represents the part of the program that is needed to compute the probability of a query and it is often smaller than the original program. This allows a reasoner to ground a smaller portion of the program to compute the probability of a query, reducing the execution time. We extract the residual program by applying SLG resolution and tabling. Empirical results on graph datasets shows that i) the time spent to extract the residual program is negligible w.r.t. the inference time and ii) querying the residual program is much faster than querying the original program."}]}