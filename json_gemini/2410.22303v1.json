{"title": "OPA: One-shot Private Aggregation with Single Client Interaction and its Applications to Federated Learning", "authors": ["Harish Karthikeyan", "Antigoni Polychroniadou"], "abstract": "Our work aims to minimize interaction in secure computation due to the high cost and challenges associated with communication rounds, particularly in scenarios with many clients. In this work, we revisit the problem of secure aggregation in the single-server setting where a single evaluation server can securely aggregate client-held individual inputs. Our key contribution is the introduction of One-shot Private Aggregation (OPA) where clients speak only once (or even choose not to speak) per aggregation evaluation. Since each client communicates only once per aggregation, this simplifies managing dropouts and dynamic participation, contrasting with multi-round protocols and aligning with plaintext secure aggregation, where clients interact only once.\nWe construct OPA based on LWR, LWE, class groups, DCR and demonstrate applications to privacy-preserving Federated Learning (FL) where clients speak once. This is a sharp departure from prior multi-round FL protocols whose study was initiated by Bonawitz et al. (CCS, 2017). Moreover, unlike the YOSO (You Only Speak Once) model for general secure computation, OPA eliminates complex committee selection protocols to achieve adaptive security. Beyond asymptotic improvements, OPA is practical, outperforming state-of-the-art solutions. We benchmark logistic regression classifiers for two datasets, while also building an MLP classifier to train on MNIST, CIFAR-10, and CIFAR-100 datasets.\nWe build two flavors of OPA (1) from (threshold) key homomorphic PRF and (2) from seed homomorphic PRG and secret sharing. The threshold Key homomorphic PRF addresses shortcomings observed in previous works that relied on DDH and LWR in the work of Boneh et al. (CRYPTO, 2013), marking it as an independent contribution to our work. Moreover, we also present new threshold key homomorphic PRFs based on class groups or DCR or the LWR assumption.", "sections": [{"title": "Introduction", "content": "Minimizing interaction in Multiparty Computation (MPC) stands as a highly sought-after objective in secure computation. This is primarily because each communication round is costly, and ensuring the liveness of participants, particularly in scenarios involving a large number of parties, poses significant challenges. Unlike throughput, latency is now primarily constrained by physical limitations, making it exceedingly difficult to substantially reduce the time required for a communication round. Furthermore, non-interactive primitives offer increased versatility and are better suited as foundational building blocks. However, any non-interactive protocol, which operates with a single communication round, becomes susceptible to a vulnerability referred to as the \u201cresidual attack\u201d [55] where the server can collude with some clients and evaluate the function on as many inputs as they wish revealing the inputs of the honest parties.\nThis work explores a natural \"hybrid\" model that sits between the 2-round and 1-round settings. Specifically, our model allows for private aggregation, aided by a committee of members, where the client only speaks once. This approach brings us closer to achieving non-interactive protocols while preserving traditional security guarantees. Our specific focus is within the domain of secure aggregation protocols, where a group of $n$ clients $P_i$ for $i \\in [n]$ hold a private value $x_i$, wish to learn the sum $\\sum_i x_i$ without leaking any information about the individual $x_i$. In this model, clients release encoded versions of their confidential inputs $x_i$ to a designated committee of ephemeral members and they go offline, they only speak once. Later, any subset of the ephemeral members can compute these encodings by simply transmitting a single public message to an unchanging, stateless evaluator or server. This message conveys solely the outcome of the secure aggregation and nothing else. Of significant note, the ephemeral members are stateless, speak only once, and can change (or not) per aggregation session. With that in mind, the committee members can be regarded as another subset of clients who abstain from contributing input when they are selected to serve on the committee during a current aggregation session. Each client/committee member communicates just once per aggregation, eliminating the complexity of handling dropouts commonly encountered in multi-round secure aggregation protocols. The security guarantee is that an adversary corrupting a subset of clients and the committee members learn no information about the private inputs of honest clients, beyond the sum of the outputs of these honest clients. We present a standard simulation-based security proof against both a malicious server and a semi-honest server. We present extensions that offer stronger security guarantees. See Section 3 for a comparison to other models.\nOur main application is Federated Learning (FL) in which a server trains a model using data from multiple clients. This process unfolds in iterations where a randomly chosen subset of clients (or a set of clients based on the history of their availability) receives the model's current weights. These clients update the model using their local data and send back the updated weights. The server then computes the average of these weights, repeating this cycle until model convergence is achieved. This approach enhances client privacy by only accessing aggregated results, rather than raw data."}, {"title": "Our Contributions", "content": "We introduce OPA designed to achieve maximal flexibility by granting honest parties the choice to speak once or remain silent, fostering dynamic participation from one aggregation to the next. This diverges from prior approaches [17, 13, 63, 69, 53], which necessitate multiple interaction rounds and the management of dropout parties to handle communication delays or lost connections in federated learning.\nCryptographic Assumptions: We construct OPA protocols providing a suite of six distinct versions based on a diverse spectrum of assumptions:\n\u2022 Learning With Rounding (LWR) Assumption\n\u2022 Learning with Errors (LWE) Assumption\n\u2022 Hidden Subgroup Membership (HSMM) assumption where $M$ is a prime integer.\n\u2022 HSMM assumption where $M = p^k$ for some prime $p$ and integer $k$.\n\u2022 HSMM assumption where $M = 2^k$\n\u2022 HSMM assumption where $M = N$ where $N$ is an RSA modulus (i.e., the DCR assumption)\nThreat Model: OPA does not require any trusted setup for keys and for M being either a prime or an exponent of prime, or the LWR assumption, we do not require any trusted setup of parameters either. We allow the server to be maliciously corrupted, maliciously corrupt clients, and corrupt up to a certain threshold t of the committee members where t is the corruption threshold for secret reconstruction. Based on the CL framework we additionally strengthen the security to allow for the compromise of all the committee members (while ensuring the server is not corrupt).\nVariants:  We offer two variants:\n\u2022 OPA: A variant that uses a seed-homomorphic PRG \u00b9 and secret sharing, with committee work independent of vector length, but leaks the sum of honest parties' keys (requiring simulatable leakage)"}, {"title": "Detailed Contributions in Federated Learning", "content": "Next, we compare our protocol with all efficient summation protocols listed in Table 3, with a specific focus on those that accommodate dynamic participation, a key feature shared by all federated learning methodologies. Asymptotically, we look at the performance of OPA. In Tables 1 and 2, we list the communication complexity, computational complexity, and round complexity per participant. Notably, our protocols are setup-free, eliminating any need for elaborate initialization procedures. Furthermore, they are characterized by a streamlined communication process, demanding just a single round of interaction from the participants.\nAsymptotic Comparison. More concretely, based on Table 1, our approach stands out by signifi cantly reducing the round complexity, ensuring that each participant\u2019s involvement is limited to a single communication round i.e. each participant speaks only once. That is, users speak once and committee members speak once too. On the contrary previous works[17, 13] require 8 rounds and the work of [69] requires 7 rounds in total, including the setup. This reduction in round complexity serves as a significant efficiency advantage.\nDespite our advantage in the round complexity, our advantages extend beyond just round complexity (see Table 1). Notably, as the number of participants (n) grows larger, our protocol excels in terms of computational complexity. While previous solutions exhibit complexities that are quadratic [17, 66] or linearithmic [69] in n, our approach maintains a logarithmic complexity for the users which is noteworthy when considering our protocol\u2019s concurrent reduction in the number of communication rounds. Furthermore, our committee framework demonstrates a linear relationship with n for the committee members, a notable improvement compared to the linearithmic complexity and setup requirement in the case of [69] which considers a stateful set of decryptors (committee), as opposed to our stateless committee."}, {"title": "Overview of OPA", "content": "While we defer a rigorous exposition on the technical overview of our construction to Section 4, we now present the intuition behind our protocol. The communication flow is described in Figure la.\nEvery client needs to ensure the privacy of their input, therefore a client has to mask their input. In iteration l, if client i has input $x_{i,l}$, then it chooses a mask of the same length to \"add\" to the inputs. Let the mask be $mask_{i,l}$ and the ciphertext is defined as $ct_{i,l} = x_{i,l} + mask_{i,l}$. To ensure privacy, we need the mask to be chosen, uniformly at random, from a large distribution. Furthermore, by performing the addition with respect to a modulus $M$, we get the property that for a random $mask_{i,l}$, $ct_{i,l}$ is identically distributed to a random element from $Z_M$. The client i sends $ct_{i,l}$ to the server. This is Message la in Figure la.\nThe server, upon receiving the ciphertexts, can simply add up the ciphertexts. This leaves it with $\\sum_i ct_{i,l} = \\sum_i x_{i,l} + \\sum_i mask_{i,l}$. The goal of the server is to recover $\\sum_i x_{i,l}$. Therefore, it requires $\\sum_i mask_{i,l}$ to complete the computation. In works on Private Stream Aggregation [84, 15, 57, 48], the assumption made is that $\\sum_i mask_{i,l} = 0$. However, this requires all the clients to participate which is a difficult requirement in federated learning. Instead, we enlist the committee's help to provide the server with $\\sum_i mask_{i,l}$, for only the participating clients.\nWorking with the Committee. Each client i, therefore, has to communicate information about its respective $mask_{i,l}$ to the committee members. This is what we refer to as \u201cAux info\u201d, and we route it through the server, to the committee member, and the information is encrypted under the public key of the respective committee member. This is Message 1b in Figure la. This ensures that the server cannot recover the auxiliary information. Eventually, each committee member \u201ccombines\" the aux info it has received to the server (Message 2 in Figure 1a), with the guarantee that this is sufficient to reconstruct $\\sum_i mask_{i,l}$. We rely on Shamir's secret-sharing [83] to distribute a secret s to a committee of m such that as long as r number of them participate, the server can learn the secret s. The security of the secret is guaranteed even if the server colludes with t committee members. We require $t < m - 1$. We also rely on the homomorphism property which ensures that if a committee member receives shares of two secrets $s_1$, $s_2$. Then, adding up these shares will help reconstruct the secret $s_1 + s_2$.\nOptimizing Committee Performance in Variant 1. The solution laid out above requires the clients to \"secret-share\" $mask_{i,l}$. However, note that $mask_{i,l}$ is as long as $x_{i,l}$. Therefore, each committee member will receive communication $O(nL)$ where n is the number of clients and L is the length of the vector. It also has to perform computations proportional to $O(nL)$. OPA reduces the burden of the committee by introducing a succinct communication that is independent of L to the committee. We do so by relying on a structured pseudorandom generator (PRG) which is"}, {"title": "Technical Overview", "content": "In this work, we focus on building a primitive, One-shot Private Aggregation (OPA), that enables privacy-preserving aggregation of multiple inputs, across several aggregation iterations whereby a client only speaks once on his will, per iteration.\nSeed-Homomorphic PRG (SHPRG). A PRG $G : K \\rightarrow Y$ is said to be seed-homomorphic if $G(s_1 \\oplus s_2) = G(s_1) \\otimes G(s_2)$ where $(\\oplus, K)$ and $(\\otimes, Y)$ are groups. We show how to build SHPRG from LWR and LWE Assumption. Note that the former was known but the latter was not. For ease of exposition, we will focus on the LWR construction. For a randomly chosen $A \\leftarrow^s Z_q^{n \\times n}$, $PRG_{LWR,A}(s) = [As]_p$ where $p < q$. Unfortunately, this construction is only almost seed-homomorphic in that there is an induced error. This is formally defined in Construction 1.\nr-1\nSecret Sharing over Finite Fields. In standard Shamir secret sharing [83], one picks a secret s and generate a polynomial $f(X) = \\sum_{i=0} a_i X^i$ where $a_0 = s$ and $a_1, ..., a_{r-1}$ are randomly chosen from the field. Assuming there are m parties, the share for party i\u2208 [m] is f(i), and any subset of at least r parties can reconstruct s and any subset of r 1 shares are independently random. We can lower the corruption threshold from r \u2013 1 to t to obtain additional properties from the scheme. In packed secret sharing [49], one can hide multiple secrets using a single polynomial.\nOne-shot Private Aggregation (based on SHPRG). With the needed background in place, we are ready to build the new primitive called One-shot Private Aggregation. Critically, we want to empower a client to speak once, per iteration, and help the server successfully aggregate long vectors (of length L, say). To this end, we have the client communicate at the same time with the server and to a set of committee members, via the server. We will assume that there is a PKI or a mechanism to retrieve the public key of these committee members so that the communication to the committee can be encrypted. These are m ephemerally chosen clients who are tasked with helping the server aggregate, for that iteration.  presents an approach on how to sample these committee members using a randomness beacon such as [47]. Observe that the one-shot communication can be leveraged to successfully avoid the complex setup procedures that were reminiscent of prior work. Instead, the client i samples a seed from the seed space of the PRG, i.e., $sd_i \\leftarrow^$ PRF.K. Then, the PRG is expanded under this seed sd and effectively serves as a mask for input $x_{i,l}$. Here l is the current iteration number. In other words, it computes $ct_{i,l} = x_{i,l} + PRG.Expand(sd)$. Intuitively, the PRF security implies that the evaluation is pseudorandom and is an effective mask for the input. Then, the client secret shares using standard Shamir's Secret Sharing, $sd_i$, to get shares $(sd_i^{(j)})_{j\\in[m]}$\nShare $sd_i^{(j)}$ is sent to committee member j, via the server through an appropriate encryption algorithm. Each committee member simply adds up the shares, using the linear homomorphism property of Shamir's secret sharing. After receiving from the clients for that round, the committee member j sends the added shares, which corresponds to $\\sum_{i=1}^n sd_i^{(j)}$. The server can successfully reconstruct from the information sent by the committee to get $\\sum_{i=1}^n sd_i$. Note that adding up the ciphertext from the clients results in $\\sum_{i=1}^n ct_{i,l} = \\sum_{i=1}^n x_{i,l} + \\sum_{i=1}^n PRG.Expand(sd_i)$. Key Homomorphism of the PRF implies that $\\sum_{i=1}^n PRG.Expand(sd_i) = PRG.Expand (\\sum_{i=1}^n sd_i)$. Note that the server, with the reconstructed information, can compute $PRG.Expand (\\sum_{i=1}^n sd_i)$ and subtract it from $\\sum_{i=1}^n ct_{i,l}$ to recover the intended sum. This is the core idea behind our construction. However, there are a few caveats. First, the server recovers the sum of the keys $\\sum_{i=1}^n sd_i$, which constitutes a leakage on the seed of the PRG. In other words, we require a leakage-resilient, seed homomorphic PRG. Second, LWR and the LWE based construction of seed homomorphic PRG are only almost seed homomorphic. Thus, care needs to be taken to encode and decode to ensure that the correct sum is recovered. We show that the LWR and LWE based schemes are key-homomorphic and leakage-resilient while describing the necessary encoding and decoding algorithms for the input. A key benefit of this construction is that the key shared with the committee is usually independent of the vector length. Our proof of security is in the simulation-based paradigm against both a semi-honest and an active server.\nOne-shot Private Aggregation against Malicious Clients. Prior work to ensure the detection of client misbehavior such as ACORN [12] requires the usage of verifiable secret sharing. Unfortunately, this is an expensive process as the committee member is required to do at $r$ exponentiations, per client. Instead, we take an alternative route by designing a publicly verifiable secret-sharing scheme. This employs SCRAPE [27] and combines it with a simple $\\Sigma$-protocol. As a result, the server can verify that given the commitment to shares, the shares are indeed a valid Shamir Secret Sharing."}, {"title": "Seed Homomorphic PRG", "content": "5.1 Syntax and Security\nDefinition 1 (Seed Homomorphic PRG (SHPRG)). Consider an efficiently computable function PRG : X \u2192 Y where (K, \u2295), (V,\u2297) are groups. Then (PRG,\u2295,\u2297) is said to be a secure seed homomorphic pseudorandom generator (SHPRG) if:\n\u2022 PRG is a secure pseudorandom generator (PRG), i.e., for all PPT adversaries A, there exists a negligible function negl such that:\n$Pr \\left[\\begin{array}{l} P P P R G \\leftarrow P R G . G e n, b \\leftarrow^s \\{0,1\\}, s d \\leftarrow^s K \\ Y_0=P R G . E x p a n d(s d), Y_1 \\leftarrow^s c Y \\  b \\leftarrow^s A\\left(Y_b\\right) \\end{array} : b=b^{\\prime}\\right] \\leq \\frac{1}{2}+n e g l(\\kappa)$\n\u2022 For every $sd_1, sd_2 \\in K$, we have that $PRG.Expand(sd_1) \\otimes PRG.Expand(sd_2) = PRG.Expand (sd_1 \\oplus sd_2)$\nIn the construction below, we abuse notation and simply write PRG(sd) as a shorthand for PRG.Expand(sd)\n5.1.2 Construction from LWR Assumption\nConstruction 1 (SHPRG from LWR Assumption). Let $A \\leftarrow^s Z_q^{n1\\times L}$ be the output of PRG.Gen, then consider the following seed homomorphic PRG $PRG_{LWR}:\\{0,1\\}^{n1} \\rightarrow {0,1}^L$ where $L > n_1$ is defined as $PRG_{LWR, A}(s d=s) =[A s]_p$ where $q>p$ with $[x]_p =[x \\cdot p / q]$ for $x\\in Z_q$.\nThis is almost seed homomorphic in that: $PRG(s_1 + s_2) = PRG(s_1) + PRG(s_2) + e$ where $e\\in\\{-1, 0, 1\\}^L$\nTheorem 1 (Leakage Resilience of Construction 1). Let PRG_{LWr} be the PRG defined in Construction 1. Then, it is leakage resilient in the following sense:\n$\\{P R G_{L W R}(s d) \\bmod p, s d+s d^{\\prime} \\bmod q: s d, s d^{\\prime} \\leftarrow^s Z_q^{n_1}\\} \\approx_c \\{y, s d+s d^{\\prime} \\bmod q: y \\leftarrow^s Z_p^L, s d, s d^{\\prime} \\leftarrow^s Z_q^{n_1}\\}$\nProof. The proof proceeds through a sequence of hybrids.\nHybrid0(\u03ba): The left distribution is provided to the adversary. In other words, the adversary gets:\n$\\{P R G_{L W R}(s d) \\bmod p, s d+s d^{\\prime} \\bmod q: s d, s d^{\\prime} \\leftarrow^s Z_q^{n_1}\\}$\nHybrid1(\u03ba): In this hybrid, we replace $s d+s d^{\\prime} \\bmod q$ with a uniformly random value $s d^{\\prime \\prime} \\leftarrow^s Z_q^{n_1}$.\n$\\{P R G_{L W R}(s d) \\bmod p, s d^{\\prime \\prime} : s d, s d^{\\prime \\prime} \\leftarrow^s Z_q^{n_1}\\}$\nNote that $(s d+s d^{\\prime}) \\bmod q$ and $s d^{\\prime \\prime}$ are identically distributed. Let us assume that there exists a leakage function oracle L that can be queried with an input sd, for which it either outputs $s d+s d^{\\prime} \\bmod q$ for a randomly sampled $s d^{\\prime} \\leftarrow^s Z_q^{n_1}$ or outputs $s^{\\prime} \\leftarrow^s Z_q^{n_1}$. If one could distinguish between hybrids Hybrid, Hybrid1, then one could distinguish between the outputs of the leakage oracle, but the outputs are identically distributed. Therefore, the Hybrid, Hybrid1 are identically distributed. Therefore, the Hybrid, Hybrid1 are identically distributed.\nHybrid2(\u03ba): In this hybrid, we will replace the PRG computation with a random value from the range.\n$\\left\\{y, s d^{\\prime \\prime}: y \\leftarrow^s Z_p^L, s d^{\\prime \\prime} \\leftarrow^s Z_q^{n_1}\\right\\}$\nUnder the security of the PRG, we get that Hybrid1, Hybrid2 are computationally indistinguishable.\nHybrid3(\u03ba): We replace $s d^{\\prime \\prime}$ with $(s d+s d^{\\prime}) \\bmod q$.\n$\\left\\{y,(s d+s d^{\\prime}) \\bmod q: y \\leftarrow^s Z_p^L, s d, s d^{\\prime} \\leftarrow^s Z_q^{n_1}\\right\\}$\nAs argued before Hybrid2, Hybrid3 are identically distributed.\nNote that Hybrid3 is the right distribution from the theorem statement. This completes the proof."}, {"title": "Construction from LWE Assumption", "content": "Construction 2 (SHPRG from LWE Assumption). Let $A \\leftarrow^s Z_q^{L\\times L}$ be the output of PRG.Gen. Then, consider the following seed homomorphic PRG $P R G_{L W E}: Z_q^L \\times X^L \\rightarrow Z_q^L$ is defined as $P R G_{L W E, A}(s, e) = As + e$\nThe proof of security is a direct application of the LWE Assumption. However, we now prove the (almost) seed homomorphic property.\n$\\begin{aligned} &P R G_{L W E, A}(s 1, e 1)=A s 1+e 1 \\\\ &P R G_{L W E, A}(s 2, e 2)=A s 2+e 2 \\\\ &P R G_{L W E, A}(s 1, e 1)+P R G_{L W E, A}(s 2, e 2)=A(s 1+s 2)+(e 1+e 2)=A(s 1+s 2)+e \\end{aligned}$\nwhere $e \\leftarrow e_1 + e_2 + 1$.\nLooking ahead, when we use this PRG to mask the inputs, we will do the following: $P R G_{L W E, A}(s i, e i)=A s i+e i+[q / p] \\cdot X_i$ where $x \\in Z_m$. Upon adding n such ciphertexts (modq), we get:\n$\\sum_{i=1}^n A s i+e+[q / p] \\cdot \\sum_{i=1}^n X_i$\nwhere $e \\leq 1+\\sum_{i=1}^n e_i$. Therefore, to eventually recover $\\sum_{i=1}^n x_i \\bmod p$ from just the value of $\\sum_{i=1}^n s i$, we will require $\\|e\\|_{\\infty} <\\frac{q}{2 p}$. Looking ahead, we will rely on the Hint-LWE Assumption 6 to show that it is leakage resilient when we use it to build our aggregation tool.\nRemark 1 (Construction based on Ring-LWE). One can also extend the above LWE construction to the Ring-LWE [68] setting.\nRecall the R-LWE Assumption. Let N be a power of two, and let $m>0$ be an integer. Let R be a cyclotomic ring of degree N, and let $R_q$ be its residue ring modulo $q>0$. Then, the following holds:\n$\\{(a, a \\cdot k+e): a \\leftarrow^s R_m, k \\leftarrow^s R_q, e \\leftarrow^s x^m\\} \\approx_c \\{(a, u): a \\leftarrow^s R_m, u \\leftarrow^s R_m\\}$\nThis gives us the following construction: $PRG_{R-L W E}((k, e)): a k+e$"}, {"title": "One-shot Private Aggregation", "content": "In this section, we begin by introducing the syntax and security of our primitive which we call One-shot Private Aggregation (OPA). Broadly speaking, the goal of this primitive is to support a server (aka aggregator) to sum up the clients' inputs encrypted to a particular label (which can be a tag, timestamp, etc.), without it learning any information about the inputs beyond just the sum.\n6.1 Simulation-Based Privacy\nOur proof approach is based on the standard simulation-based framework [52, 64] where we demonstrate that any attacker against our protocol can be simulated by an attacker Sim in an ideal world where a trusted party T computes a function F on the clients' inputs X. In our case, this function is that of vector summation. We consider an attacker A, that controls at most \u03b7\u00b7 \u03b7 clients and possibly the server. In our construction, we will consider these \u03b7\u00b7 n clients to possibly include those belonging to the committee. The ideal world consists of the following steps which are adapted to the simpler setting where only one party, i.e., the server has the output:\n(a) The honest clients provide the inputs to the trusted party T.\n(b) Sim chooses which corrupted clients send the input and which ones abort.\n(c) If the server is corrupted, then Sim can either choose to abort the protocol or continue.\n(d) If the protocol is not aborted, then T computes the function F(X) and sends to the server.\n(e) Finally, if the server is not corrupted, it outputs what it has received from T."}, {"title": "Our Construction of One-shot Private Aggregation Scheme", "content": "The key idea behind our construction is that a seed-homomorphic PRG allows us to have a single seed, much shorter than L, to mask all the L inputs. Then, one can simply secret-share the seed, which reduces computation and communication. Our seed-homomorphic PRGs are in the standard model. However, it is important to note that for the intended application of Federated Learning one might have to rely on the random oracle model to thwart attacks such as those pointed out by Pasquini et al. [75]. Though the underpinning idea of OPA is the combination of seed-homomorphic PRG and an appropriate secret-sharing scheme, there are technical issues with presenting a generic construction. We begin by presenting the construction based on the Learning with Rounding Assumption.\n6.2.1 Construction of OPALWR\nWe now present OPALWR and prove its correctness and security. We rely on the seed-homomorphic PRG (Construction 1) and combine it with Shamir\u2019s Secret Sharing Scheme over Fq (Construction 6). Construction 3. We present our construction in Figure 2.\nCorrectness. First, recall that Construction 1 is only almost seed homomorphic. In other words, $PRG(sd_1 + sd_2) = PRG(sd_1) + PRG(sd_2) + e$ where $e \\in \\{0,1\\}$.\nFor ease of presentation, our correctness proof is for $L = 1$, but it extends to any arbitrary L. Therefore, while the correctness of the Shamir\u2019s Secret Sharing scheme guarantees that sd\u2113, computed in S-Combine, is indeed $\\sum_{i=1}^n sd_i \\bmod q$, there is an error growth in AUX\u2113. Specifically, we get that:\n$\\begin{aligned} A U X_\\ell &:=P R G . E x p a n d\\left(\\sum_{i=1}^n s d_i, \\ell\\right)= \\\\ &= \\sum_{i=1}^n P R G . E x p a n d\\left(s d_{i, \\ell}\\right)+e_1 \\end{aligned}$\nwhere $e_1 \\in \\{0, ..., n-1\\}$. We know that $Encode(x_{i, \\ell}):= n \\cdot x_{i, \\ell}+1$.\n$\\begin{aligned} \\sum_{i=1}^n c t_{i, \\ell}-A U X_\\ell &=\\left(\\sum_{i=1}^n p x_{i, \\ell} \\cdot n+1\\right)+E x p a n d\\left(s d_{i, \\ell}\\right)-\\left(E x p a n d\\left(\\sum_{i=1}^n s d_{i, \\ell}\\right)\\right) \\bmod p \\\\ &=n \\cdot \\sum_{i=1}^n x_{i, \\ell}+n+\\sum_{i=1}^n E x p a n d\\left(s d_{i, \\ell}\\right)-E x p a n d\\left(\\sum_{i=1}^n s d_{i, \\ell}\\right) \\bmod p \\\\ &=n \\cdot \\sum_{i=1}^n x_{i, \\ell}+n+E x p a n d\\left(\\sum_{i=1}^n s d_{i, \\ell}\\right)-E x p a n d\\left(\\sum_{i=1}^n s d_{i, \\ell}\\right)-e_1 \\bmod p \\\\ &=n \\cdot \\sum_{i=1}^n x_{i, \\ell}+n-e_1 \\bmod p \\\\ X_\\ell &=n \\cdot \\sum_{i=1}^n x_{i, \\ell}+n-e_1 \\end{aligned}$\nTo make the last jump in the proof, we require:\n$0 \\leq n \\cdot \\sum_{i=1}^n x_{i, \\ell}+n-e_1<p$\nFirst, $e_1 \\leq n-1$. This guarantees that: $0 \\leq n \\cdot \\sum_{i=1}^n x_{i, \\ell}+n-e_1$. Now, if $\\sum_{i=1}^n x_{i, \\ell}<\\frac{(p-n)}{n}$ then we also get:\n$n \\cdot \\sum_{i=1}^n x_{i, \\ell}+n-e_1<p$"}, {"title": "Construction of", "content": "As alluded to before, OPALWE is largely similar to OPALWR with the following\ndifferences:\n\u2022 While the seed of PRGLWE is (sd, e), we will only secret share sd. We will argue below that\nthe correctness still holds, for suitable definition of \u03c7.\n\u2022 The plaintext space for OPALWE, like the one for OPALWR, is $Z_p$. Meanwhile the seed space\nfor both OPALWE and OPALWr will be $Z_q$. Let $\u2206 := [q/p]$.\n\u2022 We will use Shamir\u2019s Secret Sharing over q, as before, which is the seed space.\n\u2022 There is a change in S-Combine. To compute AUX, the server uses the reconstructed seed\nsd\u2113, and additionally sets the error component of the PRG seed to be 0.\n\u2022 $Encode(x_{i, \\ell}) := \u2206 \\cdot x_{i, \\ell}$\n\u2022 $Decode(X) := [X_i/\u2206] \u2212 1$\nDue to the similarities, we do not present the construction in its entirety. Meanwhile, we present the\nproof of correctness and proof of security.\nCorrectness. First, observe that Construction 1 is only almost seed-homomorphic, i.e.\n$PRG((s d_1 + s d_2, e), \\ell)=P R G((s d_1, e_1), \\ell)+P R G((s d_2, e_2), \\ell)+e^{\\prime}$\nfor some error $e^{\\prime}$. Indeed, assuming the correctness of Shamir\u2019s Secret Sharing, we get that the server\ncomputes:\n$\\begin{aligned} \\left.A U X_\\ell:=P R G . E x p a n d\\left(\\left(\\sum_{i=1}^n s d_i, 0\\right)\\right)\\right) &:=A s d_1+B \\end{aligned}$\nMeanwhile,\n$\\sum_{i=1}^n c t_{i, \\ell}=\\sum_{i=1}^n\\left(A s d_i+e_i+A x_{i, \\ell}\\right)$\n$\\begin{aligned} Let X_\\ell &=\\frac{\\sum_{i=1}^n c t_{i, \\ell}-A U X_\\ell}{\\Delta}=\\frac{\\sum_{i=1}^n e_i+ \\sum_{i=1}^n A x_{i, \\ell}}{A} \\\\ &=\\frac{\\sum_{i=1}^n e_i}{\\Delta}+\\sum_{i=1}^n x_{i, \\ell} \\end{aligned}$\nIf $\\sum_{i=1}^n e < \\frac{A}{\\pi}$, then $\\left[\\frac{X_\\ell}{\\Delta}\\right]=\\sum_{i=1}^n x_{i, \\ell}+1$. This shows the correctness of our algorithm."}, {"title": "Security Against Malicious Clients", "content": "In this section, we will focus on a misbehaving client. Observe that the client can send"}]}