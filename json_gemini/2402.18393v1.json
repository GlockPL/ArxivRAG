{"title": "Evaluating Decision Optimality of Autonomous Driving via Metamorphic Testing", "authors": ["Mingfei Cheng", "Yuan Zhou", "Xiaofei Xie", "Junjie Wang", "Guozhu Meng", "Kairui Yang"], "abstract": "Autonomous Driving System (ADS) testing is crucial in ADS development, with the current primary focus being on safety. However, the evaluation of non-safety-critical performance, particularly the ADS's ability to make optimal decisions and produce optimal paths for autonomous vehicles (AVs), is equally vital to ensure the intelligence and reduce risks of AVs. Currently, there is little work dedicated to assessing ADSs' optimal decision-making performance due to the lack of corresponding oracles and the difficulty in generating scenarios with non-optimal decisions. In this paper, we focus on evaluating the decision-making quality of an ADS and propose the first method for detecting non-optimal decision scenarios (NoDSs), where the ADS does not compute optimal paths for AVs. Firstly, to deal with the oracle problem, we propose a novel metamorphic relation (MR) aimed at exposing violations of optimal decisions. The MR identifies the property that the ADS should retain optimal decisions when the optimal path remains unaffected by non-invasive changes. Subsequently, we develop a new framework, Decictor, designed to generate NoDSs efficiently. Decictor comprises three main components: Non-invasive Mutation, MR Check, and Feedback. The Non-invasive Mutation ensures that the original optimal path in the mutated scenarios is not affected, while the MR Check is responsible for determining whether non-optimal decisions are made. To enhance the effectiveness of identifying NoDSs, we design a feedback metric that combines both spatial and temporal aspects of the AV's movement. We evaluate Decictor on Baidu Apollo, an open-source and production-grade ADS. The experimental results validate the effectiveness of Decictor in detecting non-optimal decisions of ADSs. It generates 46.0 NoDSs from 4 initial scenarios, while the best-performing baseline only detects 19.7 NoDSs. Our work provides valuable and original insights into evaluating the non-safety-critical performance of ADSs.", "sections": [{"title": "1 INTRODUCTION", "content": "Autonomous Driving Systems (ADSs) have been a revolutionary technology with the potential to transform our transportation system into an intelligent one. ADSs aim to enable vehicles to operate without human intervention, relying on a combination of different sensors (e.g., camera, radar, lidar, and GPS) and artificial intelligence algorithms to perceive the environment, make decisions, and navigate safely. Even though the development of ADSs has seen significant progress over the past few decades, it is still a great challenge to guarantee that the ADSs can satisfy all performance requirements under different situations due to the existing vulnerabilities in ADSs [13]. Therefore, before their real-world deployment, ADSs should be sufficiently tested [24].\nUsually, the requirements of ADSs can be classified as safety-critical and non-safety-critical. Safety-critical requirements are those essential for ensuring safe operations and performance of the autonomous vehicle and the environment. For example, an ADS should guarantee that the ego vehicle (i.e., the autonomous vehicle controlled by the ADS) should arrive at its destination without causing collisions or violating traffic rules. Non-safety-critical requirements refer to aspects that do not directly impact safety performance but are important for positive user experiences and optimal vehicle performance, such as motion efficiency, passenger comfort, and energy consumption.\nCurrently, various testing technologies have been proposed to evaluate the safety-critical requirements of ADSs (referred to as 'safety testing'), such as data-driven methods [4, 8, 28, 40] and guided searching methods [1, 6, 12, 16, 18, 23, 42]. They aim to generate safety-critical scenarios, under which the ego vehicle will cause safety issues, such as collisions and traffic rule violations. Some ADS testing works [20, 25] consider simple non-safety-critical requirements, such as comfort measured by acceleration. However, to the best of our knowledge, there is scant research on evaluating the decision optimality of ADSs (referred to as 'optimal decision testing'). This aspect is an important non-safety-critical requirement and is crucial in generating optimal paths and guaranteeing motion efficiency for the ego vehicle in complex traffic scenarios. This type of testing aims to explore scenarios where safety risks are not present but remain crucial for assessing the overall intelligence and decision quality of the ADS.\nFigure 1 showcases two examples of non-safety-critical violations where the ADS does not generate optimal paths. Note that these violations are not safety violations, as they still enable the ego vehicle to reach its destination safely. An intelligent ADS is expected to accurately appraise the traffic conditions and select"}, {"title": "2 BACKGROUND AND NOTATION", "content": "ADSs control the behavior of autonomous vehicles, i.e., the ego vehicles. Existing ADSs mainly contain two categories: End-to-End (E2E) systems [19, 41], and module-based ADSs [3, 21]. E2E systems use united deep learning models to generate control decisions from sensor data directly. Recently, the rapid development of Deep Learning and Large Models have led to high-performance E2E systems in close-loop datasets, such as UniADS [19] and OpenPilot [7]. However, these E2E systems still perform poorly on unseen testing data, such as easily colliding with obstacles. In contrast, module-based ADSs have better performance in various scenarios. A typical module-based ADS, such as Baidu Apollo [3] and Autoware [21], usually consists of localization, perception, prediction, planning, and control modules to generate decisions from rich sensor data. The localization module provides the location of the ego vehicle by fusing multiple input data from GPS, IMU, and LiDAR sensors. The perception module takes camera images, LiDAR point clouds, and Radar signals as inputs to detect the surrounding environment (e.g., traffic lights) and objects (e.g. other vehicles and pedestrians) by mainly using deep neural networks. The prediction module is responsible for tracking and predicting the trajectories of all surrounding objects detected by the perception module. Given the results of perception and prediction modules, the planning module then generates a local collision-free trajectory for the ego vehicle. Finally, the control module converts the planned trajectory"}, {"title": "2.1 Autonomous Driving Systems", "content": ""}, {"title": "2.2 Scenario", "content": "ADS testing necessitates a collection of scenarios as inputs. Each scenario is characterized by a specific environment (e.g., road, weather, and illumination) and the scenery and objects (static obstacles, Non-Player Character (NPC) vehicles, and pedestrians). In essence, a complex scenario can be generated by combining relevant attributes from the Operational Design Domains (ODDs) [35]. However, it is impractical to encompass all attributes with all possible values due to the vastness of the attribute space. Consequently, existing studies select different subsets of attributes for specific testing purposes. In this paper, we focus on evaluating the non-safety-critical performance of the motion generated by the ADS under test. As a result, we primarily employ traffic cones as static obstacles and NPC vehicles as dynamic objects to formulate our scenarios.\nPScenario. A scenario can be described as a tuple $s = \\{A, P\\}$, where $A$ is the motion task of the ADS under test, including the start position and the destination, $P$ is a finite set of participants, including the set of static obstacles and dynamic NPC vehicles. Scenario observation is a sequence of scenes, and each scene represents the states of the ego vehicle and other participants at a timestamp. Formally, given a scenario $s = \\{A, P\\}$, its observation is denoted as $O(s) = \\{s_0, s_1, ..., s_k \\}$, where $k$ is the length of the observation and $s_i$ is a scene at timestamp $i$. In detail, $s_i = \\{y_i^1, y_i^2, ...., y_i^n\\}$ where $y_i^j = \\{p, \\theta, v, a\\}$ denotes the waypoint of a participant $j \\in P$ at timestamp $i$, including the center position $p$, the heading $\\theta$, the velocity $v$ and the acceleration $a$. A driving path of the participant $j$ can be defined as $\\tau_j(s) = \\{p_0^j, ..., p_k^j\\}$. By default, we use $\\tau(s)$ to represent the driving path of the ego vehicle in the scenario $s$. Unless otherwise specified, the driving path in the following context refers to the path of the ego vehicle in $s$, i.e., $\\tau(s)$."}, {"title": "3 OVERVIEW", "content": "This paper deviates from conventional evaluation of ADSs that typically focus on safety-related requirements. Instead, we aim to assess the optimization capability of the decision-making process in ADSs. Given a scenario s and its associated potential optimal path for the ego vehicle, denoted as $t^*(s)$, our optimal decision testing endeavors to determine the ADS's ability to consistently navigate along $t^*(s)$.\nUnfortunately, it is hard to evaluate the ego vehicle's driving path $t(s)$ is an optimal one due to the lack of testing oracles; that is, we do not know $s$'s optimal path of $t^*(s)$. Despite the possibility of manually assessing the driving path in each scenario, it becomes overwhelming, especially considering the multitude of scenarios involved in optimal decision testing. To address this, we employ metamorphic testing to detect the basic decision strategies. The metamorphic relation (MR) is defined as follows:"}, {"title": "3.1 Problem Definition", "content": ""}, {"title": "Definition 1 (Metamorphic Relation)", "content": "Given an ODS s = {A,P},\nwe formalize the metamorphic relation as:\n$\\forall P \\subset P, \\epsilon(\\tau(s), \\tau(\\delta(s, P))) = True$ (1)\nwhere $P(\\subseteq P)$ is the set of all possible participants in a scenario, the function $\\tau$ retrieves the path that the ego vehicle takes in a scenario, and $\\delta$ is a mutation function that modifies the behaviors of participants in $P$. It is crucial to note that the mutation function $\\delta$ is designed in such a manner that even in the new scenario (i.e., $s' = \\delta(s, P)$), the ego vehicle can still take the driving path in the scenario $s$. The function $\\epsilon$ is an equality function that assesses the equivalence of two paths.\nThe MR essentially posits that, within a specified new scenario (i.e., $s' = \\delta(s, P)$), the ADS should exhibit the ability to select the original optimal path. NoDSs can be identified by detecting violations of the MR. Note that the decision optimality of an initial scenario $\\hat{s}$ can be manually confirmed while the mutated scenarios can be automatically checked by the MR.\nChallenges. Implementing the MR presents several challenges, particularly concerning the functions $\\delta$ and $\\epsilon$. Not all mutated scenarios, i.e., $\\delta(s, P)$, are suitable for the MR. One challenge lies in ensuring the ego vehicle can still traverse the original optimal path in the mutated scenario. For instance, if obstacles are introduced into the original optimal path, the ego vehicle may select a different path for safety considerations. While this new path differs from the original (i.e., $\\tau(s)$), it may still be optimal within the context of the new scenario. The second challenge involves determining the path equivalence of two scenarios. The behavior of the ego vehicle may differ slightly between a NoDS and its corresponding ODS, such as minor differences between two paths. Even if they are not strictly identical, both paths could be optimal. Therefore, defining the function $\\epsilon$ presents another challenge. Furthermore, once the MR is implemented, efficiently generating NoDSs that violate the MR remains challenging. To address these issues, this paper focuses on the development of the MR and the test generation algorithm."}, {"title": "3.2 Approach Overview", "content": "Figure 2 provides a high-level depiction of our testing framework Decictor, designed to detect non-optimal decisions using the metamorphic relation. The basic idea underlying our method involves generating a scenario $s'$, where the ego vehicle opts for a path that is far from the optimal path in $s$. It can be formulated as an optimization problem aiming to maximize the difference between the driving paths or behaviors of $s$ and $s'$:\n$\\Delta_s = \\arg \\max_\\Delta D(\\tau(s), \\tau(s')), s.t., s' = \\delta(s, \\Delta),$\n(2)\nwhere $\\Delta$ symbolizes the metamorphic relation-compliant perturbation on the scenario $s$, and $D$ represents a feedback function used to measure the distance or difference between the driving paths or behaviors of the two scenarios. Therefore, we can generate the NoDS from $s$: $s' = \\delta(s, \\Delta_s)$.\nDecictor adopts a search-based method to solve the optimization problem. The process initiates with an initial ODS $\\hat{s}$ and aims to output a set of MR failure tests, i.e., NoDSs. We first initialize a population $Q$ based on $\\hat{s}$. Decictor then optimizes this population"}, {"title": "4 APPROACH", "content": "Algorithm 1 presents the main algorithmic procedure of Decictor. Decictor receives a seed ODS s as the input and outputs a set of NoDSs violated the metamorphic relation. Parameters N and B can be adjusted to configure the population size and testing budget, respectively. The algorithm begins by creating an initial population with the given initial ODS $\\hat{s}$ (Lines 2-3). In each iteration, the algorithm first generates the offspring by mutating each scenario in the population Q (Lines 6-7). Each new scenario s' is first executed by the virtual testing (Line 8) and verified by the task checking (Line 9). The new scenario passed the task checking is then evaluated for the satisfiability of the MR (Lines 10-14). If the MR is violated, a NoDS is identified and added to the set $F_n$ (Line 14). If no MR violation is detected, the new scenario is added to the offspring Q'. The scenario selection process then commences, which involves picking the top N scenarios from the union of Q and Q' based on their fitness scores (Line 15). The algorithm ends by returning detected NoDSs $F_n$ (Line 17).\nIn the following sections, we introduce the key components of Decictor: the Non-invasive Mutation ($\\delta$), the Metamorphic Relation Check ($\\epsilon$), and the Feedback ($D$)."}, {"title": "4.1 Non-invasive Mutation $\\delta$", "content": "The main challenge of the mutation is to ensure that in the mutated scenario, the optimal path of the ego vehicle from the seed ODS is not affected. However, existing mutation techniques for ADS safety testing typically alter the waypoints of NPC vehicles [6, 16, 23, 34], which could significantly impact the ego vehicle's optimal path in the original ODS. To address these limitations, we propose a non-invasive mutation that effectively generates mutated scenarios without disrupting the optimal path of the ODS. The non-invasive mutation mainly includes adding new participants within the non-invasive feasible areas and removing existing added participants.\nNon-invasive Feasible Area. To guarantee non-invasion, we aim to compute a set of non-invasive feasible areas such that the"}, {"title": "Algorithm 2: Non-invasive Mutation Operators", "content": "newly added participant $P_m$ will not affect the motion of the ego vehicle and other participants if $P_m$ moves around in these non-invasive feasible areas. Note that it is essential that the motions of other participants remain unaffected, as their behaviors could indirectly alter the motion of the ego vehicle.\nGiven an ODS $s = \\{A, P\\}$ and the observation $O(s) = \\{s_0, s_1, ..., s_k\\}$ with a sampling time step $\\Delta t$, we define the non-invasive feasible area regarding to $p \\in \\{P \\cup P_o\\}$ for the next timestamp $t + \\Delta t$ as $R_p(s, t, \\Delta t)$, where $P_o$ is the ego vehicle.\nFigure 3 illustrates the basic idea about the computation of $R_p(s, t, \\Delta t)$, taking the ego vehicle as an example. First, the new participant should move in the feasible motion area, denoted as $R(y_t)$, according to its kinematic constraints (e.g., the maximal speed and steering angle) and the position $y_t$ at timestamp $t$, i.e., the sector in Figure 3(a). Second, suppose the motion area of the ego vehicle $P_o$ between $[t, t + \\Delta t]$ is $R^{P_o}(s_t, s_{t+\\Delta t})$, e.g., the dashed light orange area in Figure 3(b). $R^{P_o}(s_t, s_{t+\\Delta t})$ can be determined as $P_o$'s motion area from $s_t$ to $s_{t+\\Delta t}$ in the ODS $s$. Clearly, the new participant should not move into $R^{P_o}(s_t, s_{t+\\Delta t})$ during $[t, t + \\Delta t]$. Therefore, we have\n$R_{p_o}(s, t, \\Delta t) = R(y_t) \\backslash R^{P_o}(s_t, s_{t+\\Delta t}),$ (3)\ni.e., the light green area in Figure 3(b).\nConsequently, the non-invasive feasible area for the newly added participant at timestamp $t + \\Delta t$ is:\n$R(s, t, \\Delta t) = \\bigcap_{p \\in \\{ P \\cup P_o \\}} R_p(s, t, \\Delta t)$ (4)\nwhere $R_p(s, t, \\Delta t)$ is the non-invasive feasible area regarding to participant $p$, and $P_o$ is the ego vehicle.\nIt is worth noting that the time step $\\Delta t$ will affect the computation of the non-invasive area and the detection of NoDSs significantly. As $\\Delta t$ increases, the non-invasive area becomes more conservative, leading to fewer detected NoDSs."}, {"title": "Mutation Operations", "content": "Algorithm 2 outlines the specific mutation operations: Adding (Lines 1-11) and Removing (Lines 12-15). The non-invasive mutation takes as input $P_s$ (the participants in the initial ODS $\\hat{s}$), $P_s$ (the participants in the current ODS $s$) and $O(s)$ (the observation of $s$). The observation consists of a sequence of scenes $\\{s_0, ..., s_k\\}$ with an equal time step $\\Delta t$. In each iteration, the non-invasive mutation randomly chooses one operation to change participants in the scenario $s$, resulting in a new scenario $s'$.\nAdding. Adding operation aims to introduce complexity to the scenario by adding a new participant to $s$ without influencing the optimal path. In detail, this operation initializes an empty waypoint set $P_m$ and a collision-free waypoint $y_o$ (Lines 2-3). Waypoints for"}, {"title": "4.2 MR Check $\\epsilon$", "content": "Given an ODS $s$ and a mutated scenario $s'$, we require a criterion $\\epsilon$ to determine whether $s'$ remains an ODS. A direct approach might be checking if the driving path in $s'$ (i.e., $\\tau(s')$) and the original path of $s$ (i.e., $\\tau(s)$) are the same. However, it can be overly strict, as $\\tau(s')$ can still be considered optimal even if it slightly deviates from the original path $\\tau(s)$ (e.g., the path in Figure 4(b) can still be regarded as an optimal one). To address this, we propose an abstraction-based method to quantify the similarity between the two driving paths.\nFigure 4 illustrates the basic idea of our method. We define an optimal area around the optimal path $\\tau(s)$ in terms of the grid map. Any driving path falling or mostly falling within this area is considered optimal and satisfies the MR. For example, the green area in Figure 4(a) defines the optimal area of the driving path in the ODS. The driving path in Figure 4(b) lies in the optimal area, resulting in the highest similarity, and thus meets the MR"}, {"title": "Specifically", "content": "the comparison between the driving path $\\tau(s)$ and\nthe driving path $\\tau(s')$ is implemented by a grid-based approach, as\nshown in Figure 4. The map is divided into grids, and each driving\npath is mapped to a set of grids. Technically, a driving path of the ego\nvehicle is represented as a sequence of locations $\\tau(s) = \\{p_0, ..., p_k\\}$,\nwhere $p_i$ is the position at frame $i$. To collect the covered grids, a\nfunction $g$ is used to map each position $p$ to the grid where it is\nlocated. The covered grids for the path $\\tau(s)$ can be denoted as:\n$C_{\\tau(s)} = \\{g(p)|p \\in \\tau(s)\\}$ (5)\nTo check the MR, the similarity between the covered grids of\n$\\tau(s)$ and $\\tau(s')$ is computed. The MR checking is defined using a\npredefined threshold $\\epsilon$ as follows:\n$\\epsilon(\\tau(s), \\tau(s')) = \\frac{C_{\\tau(s)} \\cap C_{\\tau(s')}}{C_{\\tau(s)} \\cup C_{\\tau(s')}} > \\epsilon$ (6)\nIf the similarity between the covered grids is greater than the thresh-\nold $\\epsilon$, the MR is satisfied and $s'$ is recognized as an ODS."}, {"title": "4.3 Feedback D", "content": "To guide the search of NoDSs, a feedback is necessary to select high-quality individuals from the candidate population (Line 15 of Algorithm 1). The grid similarity $\\epsilon(\\tau(s), \\tau(s'))$ (in Equation 6) provides a direct choice for the feedback. However, the calculation of grid similarity is relatively coarse-grained as it only considers the spatial perspective of the ego vehicle's motion. While this coarse-grained calculation is beneficial for MR checking, as it considers different possible optimal paths, it may not be as specific and effective for guiding the testing process to generate NoDSs (see the evaluation results in Section 5.2.2). To address this, another fitness is proposed that incorporates more fine-grained feedback from both the driving path and the behavior of the ego vehicle. The former focuses on the spatial characteristics of the ego vehicle's motion, while the latter more on the temporal ones.\nDriving Path Feedback. The main objective of Decictor is to maximize the difference between the driving paths such that MR is not satisfied. Considering the potential different lengths of $\\tau(s)$ and $\\tau(s')$, we use the shortest distance between $\\tau(s)$ and $\\tau(s')$ in the spatial space to measure their difference. A larger distance indicates a higher likelihood that the MR will be violated. The distance is"}, {"title": "calculated based on the point-wise distance", "content": "$f_p(s, s') = \\frac{1}{n_{s'}} \\sum_{i=1}^{n_{s'}} min(\\{||p_i - p|| \\mid \\forall p \\in \\tau(s)\\})$. (7)\nwhere $p_i \\in \\tau(s')$ and $n_{s'}$ is the total number of points in $\\tau(s')$.\nBehavior Feedback. In some cases, optimizing only the driving path feedback might be insufficient (see the experimental results in Section 5.2.2), so an additional feedback mechanism is provided, which relies on the behavior of the ego vehicle. This behavior feedback considers factors such as the ego's velocity, acceleration, and heading. By analyzing the ego's behavior, it becomes possible to gain insights into how slight changes in behavior could lead to variations in the driving path and increase the overall difference between $\\tau(s)$ and $\\tau(s')$. For example, if the heading of the ego vehicle changes slightly, it may not directly cause a significant increase in driving path differences. However, such a change could serve as a valuable indicator, as altering the heading or acceleration of the ego vehicle could lead to adjustments in the driving path, potentially resulting in an increased difference between paths.\nTo implement this behavior feedback, the ego's behavior is collected from its waypoints in the scenario $s$, denoted as\n$X_s = \\{(v_0, a_0, \\theta_0), (v_1, a_1, \\theta_1), ..., (v_k, a_k, \\theta_k)\\}$\nwhere $v_i$, $a_i$, and $\\theta_i$ represent the velocity, acceleration, and heading at timestamp $i$, respectively. To compare the behavior differences between two scenarios s and s', the Maximum Mean Discrepancy (MMD) is used as the measure of distance between their behavior distributions. The MMD is a widely used statistical metric for comparing distributions and can effectively quantify differences between two sets of data. The behavior feedback function $f_b(s, s')$ is defined as follows:\n$f_b(s, s') = f_{MMD}(X_s, X_{s'}).$ (8)\nFinally, the fitness of s' in relation to the ODS s is calculated as:\n$D(\\tau(s), \\tau(s')) = f_p(s, s') + f_p(s, s').$ (9)"}, {"title": "5 EMPIRICAL EVALUATION", "content": "In this section, we aim to empirically evaluate the capability of Decictor on NoDS generation. In particular, we will answer the following research questions:\nRQ1: Can Decictor effectively find NoDSs for ADSs in comparison to the baselines?\nRQ2: How useful are the Non-invasive Mutation and the feedback designed in Decictor?\nRQ3: How does Decictor perform from the perspective of time efficiency?\nTo answer these research questions, we conduct experiments using the following settings:\nEnvironment. We implement Decictor with Baidu Apollo 7.0 [3] and its built-in simulation environment SimControl. Baidu Apollo 7.0 is an open-source and industrial-level ADS that supports a wide variety of driving supports.\nDriving Scenarios. We evaluate Decictor on a real-world Map Sunnyvale Loop, provided as part of Baidu Apollo. Similar to [6, 23], we manually choose four basic representative scenarios and build the initial ODSs, the inputs of Algorithm 1. These basic scenarios"}, {"title": "5.1 RQ1: Effectiveness of Decictor", "content": "Table 1 compares %Mutation, #NoDS,\nand #NoDS-Hum across four initial ODSs: S1, S2, S3, and S4, and\nFigure 5 shows the distribution of #NoDS, where the median and\nthe average are represented by an orange bar and a green triangle,\nrespectively. From the results, we can find that Decictor outperforms\nthe baselines in #NoDS and #NoDS-Hum. In detail, on average of\n#NoDS, Decictor outperforms the best baseline (i.e., Random-$\\delta$): S1\n(9.4 vs. 3.0), S2 (11.9 vs. 5.1), S3 (9.0 vs. 4.4), and S4 (15.7 vs. 7.2).\nAmong all the detected NoDSs by Decictor, we finally identified\n3.9, 8.6, 9.0, and 6.7 NoDS-Hum in S1, S2, S3, and S4, respectively.\nEven with very rigorous manual filtering, Decictor still significantly\noutperforms the best baseline (Random-$\\delta$). The results indicate the\neffectiveness of Decictor in identifying NoDSs and NoDS-Hum. We\nfurther observed that Random-$\\delta$ outperforms both the Random\n(19.7 vs. 5.4 for the total number of NoDSs) and other three safety-\noriented baselines (19.7 vs. 3.3, 5.2, and 10.4 in Sum of #NoDS). This\nis attributed to the effectiveness of the non-invasive mutation used\nin Random-$\\delta$ and Decictor. Regarding %Mutation (Avg. column),\nTable 1 reveals that Random and safety-oriented baselines produce\na maximum of 73.3% valid mutations (i.e., the original optimal path"}, {"title": "5.1.1 Comparative Results", "content": ""}, {"title": "5.1.2 Case Study", "content": "Figure 6 showcases four NoDS examples generated from the four initial ODSs. Each example includes three scenarios: the initial ODS, the identified NoDS, and the reproduced scenario (i.e., the optimal decision in the NoDS). The examples illustrate that the ego vehicle takes non-optimal paths in the detected NoDSs, even though the optimal ones are still available. Details are explained as follows:\nCase 1. Inaccurate Prediction on Vehicle Status. Decictor adds a new NPC vehicle with a low initial speed in the NoDS. Despite being initially placed on the ego vehicle's optimal path and far away, the NPC vehicle will have moved by the time the ego"}, {"title": "Case 2", "content": "Inaccurate Prediction on Obstacle Impact. Decictor introduces two obstacles along the lane boundaries near the exit of the junction. These two obstacles do not influence the optimal path. In this NoDS, the ego vehicle incorrectly assesses that the target lane is impassable. Consequently, it chooses to approach the destination from an adjacent, external lane. This choice is not optimal and introduces significant risks within the context of real-world traffic."}, {"title": "Case 3", "content": "Inaccurate Prediction on Safe Regions. Decictor introduces five static obstacles in the NoDS, without disrupting the optimal path (as shown in the reproduced scenario). However, the ego vehicle deviates from the optimal path and chooses an alternative path to reach the destination. It involves navigating around the obstacles and changing lanes four times, leading to a non-smooth and dangerous motion. This scenario illustrates the ADS's insufficient intelligence, resulting in non-optimal decisions."}, {"title": "Case 4", "content": "Inaccurate Prediction on Vehicle Intention. Decictor introduces a new NPC vehicle in the NoDS. Note that this NPC vehicle does not intersect with the optimal path of the ego vehicle. The NPC vehicle travels along the blue path at a low speed. However, the ego vehicle incorrectly predicts that the NPC vehicle intends to change to the left lane. This misinterpretation causes the ego"}, {"title": "5.2 RQ2: Usefulness of Mutation and Feedback", "content": "We assess the usefulness of the key components in Decictor, i.e., the non-invasive mutation and the feedback mechanism. To achieve this, we conducted a thorough evaluation by configuring a series of variants of Decictor and then proceeded to evaluate their usefulness."}, {"title": "5.2.1 Mutation", "content": "For mutation, we compared Decictor with its three variants: (1) w/o Cons applies a random mutation instead of the non-invasive mutation in Decictor, aiming to evaluate the effectiveness of the non-invasive mutation; (2) w/o Mot sets the time step to 0s in the calculation of non-invasive feasible areas (i.e., only considering the motion constraint at each timestamp), aiming to measure the influence of the motion constraint between two successive timestamps. (3) w/o Rem uses only the adding operation in Decictor under the constraint of non-invasive mutation, aiming to assess the effectiveness of the combination of the two mutation operations, i.e., adding and removing participants. As shown in Table 2, we find that w/o Cons generates the fewest valid mutations (70.8%) and detects the smallest number of NoDSs (14.5), underlying the importance of the non-invasive mutation. Comparing w/o Mot with Decictor, we observed that only considering the motion constraint at each timestamp is insufficient, and the continuous-time motion constraint plays a significant role in calculating the non-invasive feasible area. Our preliminary experiments revealed that %Mutation increases while the #NoDS decreases as the time step increases. The reason is that a long time step will yield scenarios with reduced interactivity between the ego vehicle and the added participant, thus exerting a lower impact on the decision-making process of the ADS. Comparing w/o Rem and Decictor, we found that mutation with only the adding operation is more likely to induce more invalid mutations and a lower number of NoDSs. This is because the adding operation brings too many obstacles and may cause the failure of the motion task. Thus, the removing operation is also important for generating NoDSs."}, {"title": "5.2.2 Feedback", "content": "For feedback, we implemented four variants: 1)\nF-Random replaces the feedback of Decictor with a random selec-\ntion (from Q $U$ Q') to evaluate the effectiveness of our feedback\nstrategy. 2) F-MR replaces the feedback of Decictor with the grid\nsimilarity used in our MR checking (see Equation 6) to compare the\nperformance between using a coarse-grained grid distance and a\nfme-grained path distance. 3) F-Path and F-Behavior consider only\nthe driving path feedback and the behavior feedback, respectively,\nto evaluate the usefulness of either feedback type.\nTable 3 shows the experimental results of #NoDSs. The compar-\native results between F-Random and Decictor (19.7 vs. 46.0 in total)\nillustrate the effectiveness of the feedback used in Decictor. The\nresults of F-MR (18.4) indicates that the grid similarity is not an\neffective feedback metric, as it may overlook some scenarios with\na high probability of inducing NoDSs. From the ablation results\nof F-Path and F-Behavior (30.7 and 31.2, respectively), we see that\nboth behavior feedback and driving path feedback are beneficial for\ndetecting NoDSs. Their combination achieves the best performance."}, {"title": "Answer to RQ2", "content": "Both the non-invasive mutation and the two\ntypes of feedback are useful for Decictor to detect non-optimal\ndecisions."}, {"title": "5.3 RQ3: Test Efficiency of Decictor", "content": "Figure 7 shows the cumulative number of NoDSs over the execution time of different methods. We can find that as Decictor continues its execution, the detection of NoDSs steadily increases, whereas other methods quickly reach a stable state. We further assess the time performance of different components in Decictor, including the overhead of mutation, oracle checking, feedback calculation, and simulation. Specifically, we analyze the average time to handle a scenario. The results are"}]}