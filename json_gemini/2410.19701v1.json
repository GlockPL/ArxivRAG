{"title": "Enhancing Resilience and Scalability in Travel Booking Systems: A Microservices Approach to Fault Tolerance, Load Balancing, and Service Discovery", "authors": ["Biman Barua", "M. Shamim Kaiser"], "abstract": "This paper investigates the inclusion of microservices architecture in the development of scalable and reliable airline reservation systems. Most of the traditional reservation systems are very rigid and centralized which makes them prone to bottlenecks and a single point of failure. As such, systems do not meet the requirements of modern airlines which are dynamic. Microservices offer better resiliency and scalability because the services do not depend on one another and can be deployed independently.\nThe approach is grounded on the Circuit Breaker Pattern to maintain fault tolerance while consuming foreign resources such as flight APIs and payment systems. This avoided the failure propagation to the systems by 60% enabling the systems to function under external failures. Traffic rerouting also bolstered this with a guarantee of above 99.95% uptime in systems where high availability was demanded.\nTo address this, load balancing was used, particularly the Round-Robin method which managed to enhance performance by 35% through the equal distribution of user requests among the service instances. Health checks, as well as monitoring in real-time, helped as well with failure management as they helped to contain failures before the users of the system were affected.\nThe results suggest that the use of microservices led to a 40% increase in system scalability, a 50% decrease in downtime and a support for 30% more concurrent users than the use of monolithic architectures. These findings affirm the capability of microservices in the development of robust and flexible airline ticket booking systems that are responsive to change and recover from external system unavailability.", "sections": [{"title": "1. Introduction", "content": ""}, {"title": "1.1. Background", "content": "The evolution of information and communications technologies in the tourism sector has changed the way customers interact with travel services. For the sake of real-time availability and tailored customer journey, coupled with millions of travel platform users, it is obvious that simply implementing a traditional monolithic structure is not sufficient to cater for the increasing complexity and scale which modern travel systems mandate. As for monolithic systems, all flight reservations, hotel bookings, payment services and customer interactions are inter-linked within one system posing scalability and maintenance issues. Such architectures are ill-suited for adaptive traffic patterns, damage containment, or incorporation of new features in a staggered approach [11].\nMicroservices architecture has become a standard solution in developing a robust and extensible travel booking system. Microservices decompose a monolithic application into smaller self-contained applications that communicate with each other using lightweight protocols, thus improving agility, scalability and fault tolerance [5]. Each service handles one aspect of the system such as flight searching,"}, {"title": "1.2. The Significance of Resilience and Scalability", "content": "A travel booking system must demonstrate reliability and a level of performance at all times, especially when there are high levels of expected use e.g. at peak holiday seasons or anytime most customers are making a buying decision due to promotions; Such periods tend to attract large amounts of traffic [6].\nResilience is the ability of a system to operate in the presence of certain failure conditions whilst load scaling capabilities of a system is based on its performance and how much resources dynamic allocation is possible [3].\nSurgically deal only with the affected service without affecting the other services within the architecture [4]. Such is the case if the Payment Service is down the system can still allow users to search for flights and hotels while offering other options of making the payment at later times [9].\nAdditionally, while designing a microservices-based application, it becomes easy to provide individual system components the power to scale in response to the volume of traffic directed towards them. For example, suppose there are a lot of flight searches going on, in that case, the Flight Search Service can scale up on its own without seeking extra capacity for dissimilar services like hotel booking or user management."}, {"title": "1.3. Microservices-based Travel Systems \u2013 Key Challenges and Solutions", "content": "Despite the opportunities presented by the shift to microservices from monolithic systems, implementing them still brings challenges, especially on the issues of fault tolerance, deployability, and load balancing [10]. Such issues are imperative especially in a travel booking system since a large number of the services rely on external APIs for example to get the flight available, or to charge the client [14]. If they are not managed profoundly, such challenges may lead to service degradation, service unavailability, and a bad experience to the users.\nIn order to achieve a high degree of fault tolerance, various techniques have been employed such as circuit breakers, rate limited retries, and bulkheads [12]. These serve to contain the failure within a predetermined boundary and therefore, allow continued operation of the services even when some of them are operating in a degraded mode [15]. Such hurt in such services would be managed effectively especially if the Hotel Booking Service goes down for a while due to issues connecting to the relevant API since it will be able to manage that by performing retries over time [7].\nAn additional important aspect in the microservices architecture based travel system is Load balancing. It makes sure incoming traffic is spread out over the service instances to prevent any one instance from becoming too busy [8]. Techniques like round robin, least connection, and weighted load balancing are applied to enhance resource use and time responsiveness [1]. For instance, in travel booking systems, load management helps ensure service availability for the often over requesting features such as flight searching functionality as well as booking service [2].\nEqually important is service discovery because microservices interact with each other through the means of internal IP addresses which are dynamically assigned. Systems implementing service discovery would include implements such as Netflix Eureka, Consul, and K8s DNS by which services can register and/or discover one another [16]. By way of illustration, in a travel booking system, if the hotel recommendation service goes into load shedding by creating additional instances of itself then the system needs to be able to discover and redirect the traffic to these new instances automatically."}, {"title": "2. Problem Analysis", "content": "The existing traditional travel booking systems constructed on monolithic architecture layout have some major drawbacks explained below:"}, {"title": "2.1. The Problems of Scalability and Flexibility", "content": "In the events of scaling out monolithic systems, entire system with application and other related components has to be added increasing resource wastage on infrastructure and operational expenditure particularly during peak traffic periods."}, {"title": "2.2. Single Points of Failure", "content": "Failure with any one of the components will have an effect on the whole system thus causing downtime which defeats the purpose of a high availability service like travel booking."}, {"title": "2.3. Load Management Concerns", "content": "There are no proper mechanisms to balance loads in the monolithic type systems. This leads to network delays and excessive errors in the traffic that is severely high, which affects the quality of service rendered."}, {"title": "2.4. Dependency and Discoverability Issues", "content": "Services are hard to add or existing ones to maintain due to dependencies reducing the evolution of the system and the rate of new features added."}, {"title": "2.5. Security and Reliability Risks", "content": "With lack of modularity, it becomes hard to protect configurable elements which end ups increasing the chances of attack being successful, such cases are most common when there are issues of sensitive users and operations data.\nAll these problems indicate that microservices is the way to practically implement system architecture for modularity resilient and scalable systems that allow for optimal load distribution so as to meet the requirements of the travel booking systems."}, {"title": "3. Literature Review", "content": "Microservices architectures have grown in popularity due to their ability to improve the robustness and scalability of applications that are high in demand such as the travel booking system. These architectures provide the possibility of independently deployable and fault-isolated services, relieving problems associated with rough separators like system scaling, high failure consequences and longer provisioning timeframes [18]."}, {"title": "3.1. Scalability and Resilience", "content": "Recent studies up to date microservices allow the scaling of some components without the need to scale others optimizing the usage of resources and dealing with peak load conditions [19]. This is beneficial in travel booking systems that experience fluctuations in user loads due to the provision of microservices that allow scaling for superior delivery performances on request and on time [20]."}, {"title": "3.2. Availability and Fault Tolerance", "content": "As already mentioned, in cases of microservices, fault tolerance is important to avoid systemic crisis, and this is important in these days' systems in which microservices are integrated with other external systems (for instance payment systems) [21]. Such practices as the Circuit Breaker Pattern have been proven to help in managing faults and increasing the up time by over 99.95% in some of the mission critical applications where requests to faulty services are not sent but rather rerouted to other services [22]. These approaches enable controlled rendering of services even with undue pressure on the system [23]."}, {"title": "3.3. Load Balancing and Service Discovery", "content": "Load balancing in the client side entails the distribution of the requests among the service instances through the use of techniques such as Least Connections and Round Robin rotation resulting in minimal latency and optimal performance [24]. On top of that, there are service discovery mechanisms that ensure healthy instances are known and registered thereby facilitating more reliable communication in such system arrangements [25]."}, {"title": "3.4. Security and Data Management", "content": "It's a well-known fact that data security and management are critical factors to be considered in any software development process [26]. The sophisticated governance structure enveloping the microservices calls for advanced security means including access control tailored to individual services, and safe data practices [27]. This is due to the fact that, in travel systems, integrity of transactions and protection of users' data are of importance; these risks help in protecting against unpleasant surprises from a distributed system."}, {"title": "4. Fault Tolerance Mechanisms in Microservices", "content": ""}, {"title": "4.1. Importance of Fault Tolerance", "content": "Fault tolerance is a critical task in microservices based architecture because any travel booking system must necessarily be complex and make use of many inter-related services including third-party integrations for flight, hotel, and payment processing services, which are also external agencies [28]. Moreover, these systems are created in a way that enables them to operate normally even when one or more external services that the system relies on fails, most times these service external to the platform are out of its authority. For example, when the user is making a travel reservation, the website usually calls an API of the airline and hotel to get the current availability and rates. Whenever there is an accessed external service or the one accessed is responding slowly or worse is giving intermittent connections, it affects the customers experience greatly, such that bookings do not go through, the transactions are not completed, or the information provided is inaccurate. Strategies to enhance fault tolerance such as retries, circuit breakers, and fallback strategies are also put in place in order to ensure that the booking platform can in most circumstances either come back to full functionality after a temporary helplessness or reduce the inflow of users in an orderly way without bringing down the entire system.\nIn all online systems that accept payment, processing payments in the normal way would be the least of the issues. This simply because any breakdowns in processing payments that lead to failed orders could represent loss of income and even disappointment to the customer. In this sense avoiding losses by enabling customer's complete payment deteriorates the system's efficacy as it ensures every form of technical failure e.g. cutoff of a payment gateway does not stop customers from completing their bookings. In these situations, and systems that are constantly driven by external factors that are subject to change suddenly, no matter how irrelative it may seem, there will always be a need for such a tolerance to faults and disturbances."}, {"title": "4.2. Health Checks", "content": "Liveness Tests:\n\u2022\tThese tests establish if the service instance is functioning or responding to requests.\n\u2022\tWhere a liveness test fails, that instance is automatically classified as unhealthy and is either restarted or taken off active duty.\n\u2022\tFor instance, in the case of booking a flight a service which goes down due to memory issues, if that check fails then is liveness a check who will take care of restarting the service or redirecting the traffic."}, {"title": "Readiness Tests:", "content": "\u2022\tEvery test is a test of all existing components in order to traffic a service.\n\u2022\tThis is very important at the time of starting a service or in the situations when the service is up but in the process of bootstrapping (for example, when it is waiting for some resources to be available).\n\u2022\tIn a travel booking engine, the m payment service would pass liveness check but fail readiness check because it is not able to reach the external payment processing system."}, {"title": "Startup Tests:", "content": "\u2022\tThe service startup tests will confirm that the service has started as expected and will be in a position to receive requests.\n\u2022\tIn the event that this specific check does not pass, the instance is deemed to be in a failed startup condition and will be scheduled for termination or for reboot.\n\u2022\tFor instance, a flight search service may need certain third-party APIs to be available during its startup phase, and the startup tests ensure that all the API's requirements are satisfied before the service is declared 'ready.'"}, {"title": "5. How Health Checks Work in Microservices?", "content": "Microservices health checks may be internal as in self-monitoring, or external as in being performed with the help of the orchestrator/ load balancer. They are discussed below:"}, {"title": "3.1 Each Service Instance Monitors Itself:", "content": "\u2022\tEvery service instance (for instance in this case a flight booking service or payment service) performs liveness and readiness checks continuously.\n\u2022\tThese checks are made available through dedicated health endpoints (for example /healthz, or /readiness)."}, {"title": "3.2 Service Registry/Orchestrator Performs Health Checks:", "content": "\u2022\tIn a service discovery system (for example Service Registries such as Eureka, Consul, Kubernetes), the service registry does regular health checks by calling the health endpoints of every registered service after some time.\n\u2022\tA instance of a service is taken off from the services available list for re-direction of requests if it fails the health check, in this way no more requests are redirected to him until he regains his health status."}, {"title": "3.3 Health checks performed at the Load Balancer:", "content": "Also, the load balancer (otherwise called client when in client-side load balancing) carries out health checks so that only the suitable instances get the traffic.\n\u2022\tFor instance, if one of the flight booking service instances fails, the load balancer will remove the server from the pool and give all its traffic to the other instances.\n\u2022\tHealth Check Example in a Travel Booking System\n\u2022\tConsider we have a travel booking application that consists of 3 instances of a flight search micro service.\n\u2022\tThe service registry calls the /healthz endpoint of each flight search service instance every ten seconds.\n\u2022\tInstance A returns a 200 OK status, meaning it is healthy.\n\u2022\tInstance B fails to respond owing to excessive consumption of CPU resources hence timing out. The service registry thus considers it unhealthy and takes it out of the active pool."}, {"title": "6. Health Check Features and Advantages", "content": ""}, {"title": "4.1 Prevention of Problems", "content": "Health checks enable the system to find faults before the users notice them. For example, it can identify that a payment service is failing before it reaches the point of transaction failures."}, {"title": "4.2 Autonomous recovery of systems", "content": "For example, if a service has failed to pass the liveness or readiness check it can be taken out of service or restarted without any intervention, allowing self-healing and minimal service disruption."}, {"title": "4.3 System Performance Improvement", "content": "In that only health service instances serve the request, the service tolerance to failures is improved and therefore downtime is less."}, {"title": "4.4 Adaptive Load Balancing", "content": "Health checks assist in dynamic traffic management. Traffic is only sent to up instances which avoids user traffic being sent to unhealthy services."}, {"title": "7. Circuit Breaker Pattern", "content": "The microservices approach in the development of an airline reservation system consists of several services dealing within themselves and with external ones as well; for example flight search, booking, payment services, etc. Such external dependencies may be unreliable due to a number of factors including, but not limited to, network disconnections, increased volume of clients for the service, or maintenance timeout which might result in poor performance whole system and on all services. To avoid such scenarios, the Circuit Breaker Pattern is used as a fault tolerance mechanism.\nThe handy Circuit Breaker Pattern only helps not to pound failed services with futility due to the \"circuit\" being broken after a preset number of failures. This allows the system to be kept more responsive, reduces the amount of resources being wasted and even allows services to heal properly without being active."}, {"title": "5.1 Circuit Breaker in a Microservices Context", "content": "A microservices-based airline reservation system is composed of many services that coordinate to solve discrete parts of the booking tasks. Some of the common services and their possible dependencies are provided below."}, {"title": "5.1.1 Flight Search Service:", "content": "Fetches available flight data from third-party airline APIs or internal flight data services."}, {"title": "5.1.2 Booking Service:", "content": "Handles user reservation while interfacing other services like payment and notifications."}, {"title": "5.1.3 Payment Service:", "content": "Facilitates funds transfer through different payment processing vendors."}, {"title": "5.1.4 Notification Service:", "content": "Delivers booking updates and reminders as emails and text messages."}, {"title": "5.2 How the Circuit Breaker Pattern Works in Airline Reservation Systems?", "content": "The Circuit Breaker Pattern operates in three states: Closed, Open, and Half-Open, which are implemented as part of a microservice's logic to monitor communication with other services."}, {"title": "5.2.1 Closed State:", "content": "In the process the system works perfectly and processes requests towards some other external services, such as Payment Service, Flight Search Service, etc.\nIn this phase, the system counts how many requests have led to failures. If the number of failures is lower than a specific limit, the system continues to issue requests.\nExample: The Booking Service makes requests to the Flight Search Service to ascertain if flights are available for booking. As long as the service is available, the circuit remains closed, allowing for regular activities to take place."}, {"title": "5.2.2 Open State:", "content": "Whenever the number of occurrences of failures (e.g. timouts or errors) surpasses the set level (e.g. 5 failed requests within certain period), the circuit is said to open in this state, there is no requesting to the problematic service for some time, and an error or some fallback response is received by users of the system."}, {"title": "5.2.3 Half- Open State:", "content": "Subsequent to the cool-down period, the circuit half-open state. At this point, the system makes a limited number of 'test' requests to the service to ascertain if it has come back to its functional state.\nIn the event that the service is found responding satisfactorily to the given test requests, the circuit is said to close, and operations go back to normal.\nIn the event that the failures persist, the circuit will be re opened, and the cool-down cycle will begin again. Example: Within a few minutes, the Booking Service, to evaluate whether the inoperative Flight Search Service is now active, sends a series of queries designated as test requests."}, {"title": "5.3 Microservices and Circuit Breaker Pattern: Implementation", "content": "In most microservices-based airline reservation systems, patterns like the Circuit Breaker are implemented using tools such as Netflix Hystrix, Resilience4j, or internal Kubernetes features [12]. Here is how it can be applied in a typical airline reservation system."}, {"title": "5.3.1 Booking Service Circuit Breaker Example (Along with Payment Service)", "content": "Let us examine a Booking Service which makes it possible for users to make bookings and also provides access to a Payment Service to facilitate processing of payments [13]."}, {"content": "```latex\n@HystrixCommand(fallbackMethod = \"paymentFallback\", commandProperties = {\n    @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"5\"),\n    @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"10000\"),\n    @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"50\")\n})\npublic String processBooking(BookingRequest request) {\n    // Calls the Payment Service for payment processing\n    return paymentService.processPayment(request.getPaymentDetails());\n}\n```"}, {"title": "5.3.2 Flight Search Service Circuit Breaker Example", "content": "```latex\n@HystrixCommand(fallbackMethod = \"flightSearchFallback\", commandProperties = {\n    @HystrixProperty(name = \"circuitBreaker.requestVolumeThreshold\", value = \"10\"),\n    @HystrixProperty(name = \"circuitBreaker.sleepWindowInMilliseconds\", value = \"5000\"),\n    @HystrixProperty(name = \"circuitBreaker.errorThresholdPercentage\", value = \"40\")\n})\npublic FlightSearchResponse searchFlights(FlightSearchRequest request) {\n    // Call to external airline API to retrieve available flights\n    return flightApi.searchFlights(request);\n}\npublic FlightSearchResponse flightSearchFallback(FlightSearchRequest request) {\n    // Fallback logic for failed flight search\n    return new FlightSearchResponse(\"Service Unavailable\", Collections.emptyList());\n}\n```"}, {"title": "5.4 Working of Circuit Breaker: Sample Process", "content": "Let's take an example of a customer trying to book a flight."}, {"title": "5.4.1 Booking Enquiry:", "content": "The user sends in a booking request using the booking service. The booking service then checks for available flight seats using the flight service and also check whether payment can be made using the payment service."}, {"title": "5.4.2 Flight Search Service Circuit Breaker:", "content": "The Flight Search Service tries to get the available flights from an external airlines API. If the API is not reachable (i.e., there is no response for a long time or the service is down), then the circuit breaker will be triggered.\nAfter constant attempts and failures, the circuit opens, and the system stops the external API calls and presents a static message \"Currently no flights available. Please check back later.\""}, {"title": "5.4.3 Payment Service Circuit Breaker:", "content": "In case a flight is booked, the next step is to make the Payment, which entails the involvement of the Payment Service. Specifically, should the payment gateway experience a breakdown or critical errors perpetrated, suspension of the payment service's circuit breaker occurs.\nIn this case, rather than trying once again to send the failing payment service a request or two, such an action will not be required since a message indicates the user: \u201cPayment service is out of order at the moment\" appears."}, {"title": "5.4.4 Circuit Breaker Recovery:", "content": "After some time, the above changes, and the system passes to the intermediate state known as half-open. It makes a few test calls to the Flight Search Service and Payment Service to ascertain if they have come back online.\nIn case it works, normal activities are resumed. In case it does not work, the circuit is broken again."}, {"title": "5.5 Benefits of using Circuit Breaker Pattern in Airline Systems based on Microservices", "content": ""}, {"title": "5.5.1 Increases Availability:", "content": "The system survives and does not get affected by other failures by disconnecting with the services that have become unresponsive. Thus enhancing resilience."}, {"title": "5.5.2 Minimizes Resource Stress:", "content": "Keeps the services from being flooded by requests that are bound to fail preventing a possible system-wide hang or shutdown."}, {"title": "5.5.3 Facilitates graceful failing:", "content": "Graceful failure management is provided to users with alternative services or options to retry during such partial failure."}, {"title": "5.5.4 Service Restoration:", "content": "Health check of failed services can be undertaken to see if they have come back to life allowing for recovery processes to take place without the administrator doing anything."}, {"title": "5.6 Challenges", "content": ""}, {"title": "5.6.1 Configuration Complexity:", "content": "Adjustment of circuit breaker settings like request count, fault threshold, circuit breaker timeouts is necessary to prevent unplanned outages or inefficient fault management."}, {"title": "5.6.2 Fallback Management:", "content": "Fallback responses are not easy to implement particularly for service areas like payments and bookings where treatment of customers is of great concern."}, {"title": "6. Load Balancing Strategies", "content": ""}, {"title": "6.1. Client-Side Load Balancing", "content": "In view of travel booking systems based on microservice architecture, client-side load balancing has a crucial significance in managing the volume of traffic being serviced by many instances of a service. Client-side load balancing however does not have a central component (which in the case of server-side load balancing would be NGINX, HAProxy or other load balancing solutions) which controls the traffic to the backend servers. This mechanism is very useful in highly variable traffic conditions such as in travel booking operations where services including flight search, hotel search, payments and many others tend to horizontally scale in and out depending on the incoming traffic patterns.\nUsing client-side load balancing, the client (which in turn can be another microservice) holds the service stubs of each available service instance and picks one with a specific policy in mind (for example, round-robin, least connections or random policy). This is often realized with the help of service discovery systems like Netflix Eureka or Consul, which let the clients employ the system without being aware of the current set of service instances as their status changes, namely added, removed and updated. For instance, in the architecture of online portals for ticket booking there could be several instances of the Flight Search Service in order to cope with the demand during rush hours. When the client sends a request to this service, it can use client-side load balancing in such a way that the requests are made to different instances of the service, thereby enhancing both efficiency and reliability.\nIn microservices architecture, client-side load balancing proves to be useful as it eliminates the possible bottleneck associated with the centralized load balancers thus improving scalability. It is also more practical as every client gets to choose how to distribute its requests to its servers without having to rely on any other third party. This facilitates fine-tuned management of traffic. On the downside however, this demand constant illumunation on the available instances making sure that the clients do sink their routing operations with the traffic to be handled. Client-side load balancing works great for travel booking systems enabling economies of scale and on-demand strategies that are necessary for providing users with quality service during peak hours."}, {"title": "6.1.1. Role of Client-Side Load Balancing:", "content": "\u2022\tThe responsibility of distributing the traffic across all the running instances of a target service rests with the client (either the API gateway or another microservice).\n\u2022\tWithin the client service, client-side load balancing takes place, thus obviating the need for an external centralized load balancer."}, {"title": "6.2. Service Discovery:", "content": ""}, {"title": "6.2.1. Service Registry:", "content": "Employ a service discovery platform such as Netflix Eureka, Consul, Kubernetes DNS, or some other tool, to register all the microservice instances. The service registry contains the up-to-date list of all the instances and provides the clients with the information regarding the presence of a particular service."}, {"title": "6.2.2. Dynamic Updates:", "content": "As fresh replicas of a service (for example Flight Search Service) get released whilst old ones are taken out, the registry automatically refreshes the number of active instances."}, {"title": "6.2.3. Client Integration:", "content": "Each client either regularly reads from the service registry or subscribes for service notifications, to maintain an up to date cache of the available instances on the client."}, {"title": "6.3. Round-Robin:", "content": "Round-Robin is one of the most basic yet widely accepted load balancing methods integrated primarily in microservices based structures as used in travel reservation systems. It provides simple and practical"}, {"title": "6.3.1. Concept of Round-Robin Load Balancing", "content": "In round-robin load balancing system, incoming requests are made to every available service instance in turn. At the most basic level, whenever a request comes in, the load balancer (or the client in clientside load balancing) takes the particular request to the Nth instance where N is the current value of the counter that indicates the position in the service instance list. When the counter becomes greater than the last index of the service instance list, the counter returns to zero. This repetitive cycle helps in better traffic management by ensuring that all the instances are used and no single instance is inundated with too much traffic."}, {"title": "6.3.2. Algorithm of Round-Robin Load Balancing for Travel Booking Systems", "content": "Round-Robin load balancing algorithm is a technique for distributing the load evenly among a number of service instances by directing incoming requests to each service instance in a predefined order. This method guarantees that every instance gets a load that is relatively equal to the rest of the other instances. This is especially handy in microservice based systems such as travel booking systems. Below is a detailed algorithm of how to implement Round-Robin load balancing in such a system."}, {"title": "Algorithm Overview", "content": "Goal: For the same service when requested by the client to avoid overloading, incoming requests for the same service (e.g. flight search service) are assigned to several service replicas."}, {"title": "Inputs:", "content": "List of all active services like flightInstances[].\nWhich instance to send the next request, current index to track (initialized to 0)"}, {"title": "Outputs:", "content": "For each incoming requests service instance is selected."}, {"title": "Algorithm Steps", "content": "Step-1 Initialization:\nListing every services instances that are available. flightInstances[],with every instance of the flight search service in it.\nInitialize a variable currentIndex to 0."}, {"title": "Step-2 Incoming Request Handling:", "content": "For every incoming request"}, {"title": "Check Availability:", "content": "In the case if no instances are available in flightInstances[], return an error or a fallback response."}, {"title": "Select Instance:", "content": "To select the next service instance, use the current index\nselectedInstance = flightInstances[currentIndex]"}, {"title": "Send Request:", "content": "Have to forward the request to the selectedInstance."}, {"title": "Update Current Index:", "content": "Increment the currentIndex by 1\ncurrentIndex = (currentIndex + 1) % size_of(flightInstances)\nIt will confirm, when the end list is reached. It will wraps back to the beginning."}, {"title": "Step-3 Repeat:", "content": "For each incoming connection repeat the step-2"}, {"title": "Step -4 Consider Instance Skipping (Optional):", "content": "In case one of the scheduled instances is skipped:\nSchedules the deletion of the lost instance from flightInstances[].\nWhether to also update the currentIndex and when the currentIndex points to the removed instance of flightInstances[]."}, {"title": "Algorithm (Pseudocode)", "content": "initialize flightInstances[] // Will show the list of available flight service instances\ncurrentIndex = 0 // Initialize index to track next instance\nfunction handleRequest(request):\n if length(flightInstances) == 0:\n return \"There are No available instances\"\n selectedInstance = flightInstances[currentIndex]\n // request is sent to the selected instance\n response = sendRequestToInstance(request, selectedInstance)\n // Current index updation\n currentIndex = (currentIndex + 1) % length(flightInstances)\n return response\nfunction sendRequestToInstance(request, instance):\n // Technique to send request to the specified instance and return the response\n return response"}, {"title": "6.4. Implementation in Travel Booking Systems", "content": "In the case of a microservices travel booking system which may involve a wide spectrum of activities such as buying air tickets with processing of credit cards, round-robin strategy can be implemented on some services in which load tends to seasonally vary. This is how the structural implementation can be carried out. In figure 3, round-robin load balancing implementations are shown."}, {"title": "6.4.1. Service Instances:", "content": "There can be several instances providing each of the core services (for instance, Flight Search Service, Payment Service).\nA good example is the Flight Search Service, which may have three instances (A, B, C) for responding to incoming flight search queries."}, {"title": "6.4.2. Request Distribution:", "content": "Consider the situation in which a client, .i.e. a user application or any other micro-service, makes a request to the Flight Search Service. Such requests are then channeled by the round-robin load balancer as follows\nRequest 1 \u2192 Instance A\nRequest 2 \u2192 Instance B\nRequest 3 \u2192 Instance C\nRequest 4 \u2192 Instance A (again)."}, {"title": "6.5. Advantages of Round-Robin Load Balancing", "content": "Simplicity: The round-robin method is quite simple to"}]}