{"title": "FuncGenFoil: Airfoil Generation and Editing Model in Function Space", "authors": ["Jinouwen Zhang", "Junjie Ren", "Aobo Yang", "Yan Lu", "Lu Chen", "Hairun Xie", "Jing Wang", "Miao Zhang", "Wanli Ouyang", "Shixiang Tang"], "abstract": "Aircraft manufacturing is the jewel in the crown of industry, among which generating high-fidelity airfoil geometries with controllable and editable representations remains a fundamental challenge. While existing deep-learning-based methods rely on predefined parametric function families, e.g., B\u00e9zier curves and discrete point-based representations, they suffer from inherent trade-offs between expressiveness and resolution flexibility. To tackle this challenge, we introduce FuncGenFoil, a novel function-space generative model that directly learns functional airfoil geometries. Our method inherits both the advantages of arbitrary resolution sampling and the smoothness of parametric functions, as well as the strong expressiveness of discrete point-based functions. Empirical evaluations on the AFBench dataset demonstrate that FuncGenFoil improves upon state-of-the-art methods in airfoil generation by achieving a relative -74.4% label error reduction and +23.2% diversity increase on the AF-200K dataset. Our results highlight the advantages of function-space modeling for aerodynamic shape optimization, offering a powerful and flexible framework for high-fidelity airfoil design. Our code will be released.", "sections": [{"title": "Introduction", "content": "The airfoil inverse design problem serves as a central aspect of aircraft manufacturing. Traditionally, given geometric requirements, engineers first select the most similar airfoils from well-known airfoil datasets (e.g., NACA [Cummings et al., 2015]) and leverage the trial-and-error strategy [Sharma et al., 2021]. Considering the mission of the aircraft, an initial airfoil design that meets the design conditions is preliminarily created. Then, through rounds of physical analysis, such as aerodynamics and mechanics, the airfoil is iteratively optimized to achieve better performance until the requirements are met. In practice, such direct design procedures are highly inefficient and time-consuming, often taking months. To minimize development and design time, as well as associated costs, automatic design methods have been introduced as efficient alternatives in aircraft manufacturing engineering. In particular, machine learning-based design and optimization techniques have gained significant attention. However, before applying algorithms to airfoil design, it is crucial to determine appropriate methods for representing airfoils within these algorithms.\nExisting methods for airfoil representation can generally be divided into two categories: parametric-model-based approaches [Xie et al., 2024] and discrete-point-based methods [Liu et al., 2024; Sekar et al., 2019]. First, parametric-model-based methods predefine function families, e.g., B\u00e9zier curves [Chen and Fuge, 2021], Hicks-Henne curves, and NURBS, and leverage mathematical optimization techniques or generative models to determine the parameters of these functions for a new airfoil. These methods rigorously preserve key geometric properties of the defined functional families, e.g., high-order smoothness. Furthermore, such functional representations of airfoils allow for arbitrary sampling of control points in real manufacturing, given the constraints of engineering precision. Despite these benefits, parametric-model-based methods suffer from a significantly reduced design space, i.e., selecting a specific function family excludes the possibility of other shapes, which limits the upper bound of airfoil design algorithms. Second, discrete-point-based methods directly generate multiple points to represent airfoil shapes. These methods maximize the design space of airfoils but cannot maintain some important mathematical properties, e.g., continuity. Furthermore, they cannot directly generate control points at arbitrary resolutions because the number of generated points is typically fixed for each model after training.\nTo address the trade-offs between these two mainstream approaches, we ask: Can we design an algorithm that leverages the advantages of both?\nIn this paper, we answer this question by proposing FuncGenFoil, a novel function-space generative model for airfoil representation (see Fig. 1). Different from previous data-driven and generative methods, e.g., cVAE [Kingma, 2013] and CGAN [Mirza, 2014], which directly generate discrete points, our approach models airfoil geometry using a general continuous function approximator [Anandkumar et al., 2019; Li et al., 2021; Kovachki et al., 2023; Azizzadenesheli et al., 2024], i.e., neural operator architectures. Simultaneously, it leverages recent advances in generative methods, e.g., diffusion models [Ho et al., 2020a] and flow matching models [Lipman et al., 2022], to generate diverse airfoils beyond the design space of any predefined geometry function. Our method has the advantages of both parametric-model-based approaches and discrete-point-based methods. Due to its functional representation, the generated airfoil is continuous and can be sampled at arbitrary resolutions, making it easier to manufacture. Moreover, thanks to the general functional approximator nature of neural operators, our method can explore a broader design space beyond predefined functional families.\nSpecifically, we leverage the flow matching framework [Lipman et al., 2022], an improved alternative to diffusion models, and FNO [Li et al., 2021], a resolution-free neural operator, as the backbone of our generative model to design FuncGenFoil. In the forward process, we perturb the airfoil into a noise distribution through straight flows. In the backward process, we reconstruct the airfoil by reversing the flow direction. By minimizing the distance between the reconstructed airfoils and actual airfoils, we learn the neural operators that enable us to generate airfoils from functions of Gaussian process. Beyond generation, our method also supports airfoil editing by incorporating the airfoils to be edited as conditions for the generative model.\nIn summary, our main contributions are threefold: (1) We propose generating airfoil shapes in the functional space to achieve important properties for the aircraft engineering, i.e., arbitrary-resolution control point sampling and maximal design space; (2) We design FuncGenFoil, the first controllable airfoil generative model in the functional space, which effectively incorporates neural operator architectures into the generative model; (3) We further enhance FuncGenFoil with airfoil editing capabilities through minimal adaptations. Experimental results on the AFBench dataset indicate that our proposed method achieves state-of-the-art airfoil generation quality, reducing label error by 74.4% and increasing diversity by 23.2% on the AF-200K dataset, as validated by aerodynamic simulation analysis. In addition, our method is the first to successfully perform airfoil editing by fixing and dragging at any position, achieving nearly zero MSE error (less than 10-7)."}, {"title": "Related Works", "content": "Generative Models. Generative models based on score matching [Ho et al., 2020b; Song et al., 2021] and flow matching [Lipman et al., 2023; Tong et al., 2024] have significantly advanced machine learning, achieving state-of-the-art results in areas such as image generation [Rombach et al., 2022], text generation [Gat et al., 2024], and video generation [Ho et al., 2022; Polyak et al., 2024]. However, most of these models operate in finite-dimensional spaces and rely on fixed discretizations of data. Such formulations hinder transferability across discretizations and ignore function-level constraints (e.g., continuity, smoothness), motivating the need for function-space generative modeling.\nNeural Architecture for Functions space Designing neural architectures to handle function spaces remains a major research challenge. Standard networks typically assume fixed-size inputs, making them unsuitable for arbitrary resolutions. Implicit Neural Representations like SIREN [Sitzmann et al., 2020] harness random Fourier features [Rahimi and Recht, 2007] to represent continuous and differentiable objects through position embeddings. Similarly, NeRF [Mildenhall et al., 2021] treats input coordinates as continuous variables, offering flexible resolution for function outputs. Neural operators [Anandkumar et al., 2019; Li et al., 2021; Kovachki et al., 2023; Azizzadenesheli et al., 2024] and Galerkin transformers [Cao, 2021] further generalize neural architectures to process sets of points as functional inputs, enabling function-space learning.\nGenerative Models in Function Space. In generative modeling, early Neural Processes [Garnelo et al., 2018b; Garnelo et al., 2018a] drew on Gaussian Processes [Rasmussen, 2003], and later methods such as GASP [Dupont et al., 2022b], Functa [Dupont et al., 2022a], and GANO [Rahman et al., 2022] treat data as function evaluations to enable discretization-independent learning. Energy-based and diffusion models [Lim et al., 2023; Kerrigan et al., 2023; Lim et al., 2025; Pidstrigach et al., 2023; Franzese et al., 2024] along with flow-based approaches like FFM [Kerrigan et al., 2024] and OpFlow [Shi et al., 2024] further extend these ideas. Ultimately, creating comprehensive generative models in function space requires defining suitable stochastic processes, score operators, and consistent neural mappings with specialized training for numerical stability-challenges that remain largely unresolved.\nAirfoil Design and Optimization. Airfoil design is critical for aerodynamic performance in systems such as aircraft, race cars, and wind turbines. Geometric parameterization enables efficient modeling and optimization of air-"}, {"title": "FuncGenFoil: Function-space Generative Model for Airfoils", "content": "Different from existing airfoil generation methods, FuncGenFoil is constructed as a function-space generative model, capable of producing airfoil geometries as continuous functions instead of discrete points, leveraging the advantages of both parametric-model-based and discrete-point-based methods. We detail the process for airfoil generation and editing tasks, respectively."}, {"title": "Airfoil Generation", "content": "The entire FuncGenFoil is essentially an ordinary differential equation (ODE) generative model that generates airfoil by solving an ODE continuous time $t \\in [0, 1]$ as follows:\n$\\frac{du_t}{dt} = v_t \\qquad (1)$\nwhere $v_t$ is a velocity that gradually transforms an assumed latent coding $u_0$ ($u_t$ at $t = 0$) sampled from stochastic process $P$ into an airfoil function $u_1$ belonging to the target airfoil distribution $Q$.\nVelocity Operator. Obviously, the velocity $v_t$ is the key, we achieve it by establishing a parameterized velocity operator $v_\\theta(u_t, c, t)$ with model weights $\\theta$, i.e., $v_t = v_\\theta(u_t, c, t)$. To enable the velocity operator $v_\\theta$ an ability to take the airfoil shape function as input, we build $v_\\theta$ as a function-space generative model by Operator Flow Matching [Shi et al., 2025] as shown in Fig. 2. Specifically, $v_\\theta$ consists of stacked multiple Fourier Neural Operator layers and it takes noised airfoil $u_t$ (at any resolution $d$), condition variables (optional) and a timestamp $t$ as inputs, deriving $v_t$.\nAirfoil Geometry Parametrization. Since an airfoil has circular topology, we introduce the variable $\\alpha \\sim [0, 2\\pi]$ for convenience. We denote $y(\\alpha) = u_1(\\alpha)$ and $x(\\alpha) = \\frac{\\cos(2\\pi \\alpha) + 1}{2}$, achieving the function of airfoil $u_0 = (x(\\alpha), y(\\alpha))$.\nTraining. We train $v_\\theta$ under the denoising training process. Given an airfoil geometry $u_1$, we compute its corresponding noised sample at time $t$ as follows:\n$u_t = t \\times u_1 + (1 - t) \\times u_0\\qquad (2)$"}, {"title": "Airfoil Editing", "content": "The airfoil editing task enables the user to modify parts of the geometry of a given airfoil, effectively generating a new airfoil geometry while preserving the user-edited sections, denoted as $u_s$. We achieve this by an optimization method that maximum a posteriori (MAP) estimation, $\\max_{u_1} p(u_1 | u_s)$ where $p(u_1 | u_s)$ is a probabilistic model that constrains the optimized airfoil $u_1$ fulfilling the editing requirements and following the generation prior.\nTo achieve the constraint probability model, we disentangled it with Bayes' Rule:\n$\\max_{u_1} p(u_1 | u_s) = \\frac{p(u_s | u_1)p(u_1)}{p(u_s)} \\\\ \\Rightarrow \\max \\log p(u_s | u_1) + \\log p(u_1) - \\log p(u_s), \\qquad (6)$\nwhere $p(u_s | u_1)$ is a Gaussian measure, so its log term becomes a Mean Square Error (MSE) between $u_s$ and $u_1$, constraining the user edited parts in $u_1$ keeping consistent with $u_s$. $p(u_1)$ is the prior supported by the trained generative model so its log value is derived by Hutchinson trace estimator [Hutchinson, 1990; Grathwohl et al., 2019] effectively. $p(u_s)$ is the marginal likelihood, which does not depend on $u_1$. The final optimization target could be written as:\n$\\max_{u_1} \\frac{1}{\\sigma} \\sum_{i \\in \\Delta} (u_{s,i} - u_{1,i})^2 + \\log p(u_1), \\qquad (7)$\nwhere $\\sigma$ is noise, $\\Delta$ denotes point indices in edited part $u_s$.\nFor more realistic generation results, the optimization does not directly adjust $u_1$; instead, we optimize $u_1$ indirectly by fine-tuning the entire generative model for a few iterations. The fine-tuning process is illustrated in Fig. 4, while its details are provided in Alg. 1 in the main text. Specifically, we first initialize $u_1$ as a resample data of $u_1$, by extracting its latent code, denoted as $\\alpha_\\theta$, via the inverse of our generative model and re-generating $u_1$ from this code. Then we treat Equation 7 as the loss function to train $\\theta$ of the velocity operator and $\\alpha_\\theta$ simultaneously. After the model training, the new $u_1$ is the new edited generation results."}, {"title": "Experiments", "content": "Experiment Settings\nTasks. We evaluate two tasks in the airfoil inverse design problem: conditional airfoil generation and freestyle airfoil editing. In the conditional generation task, the model is given a set of 11 geometric parameters that describe the airfoil geometry. The model must generate airfoils that satisfy these geometric constraints. In the freestyle editing task, the model takes an original airfoil and a target modification, such as adjusting the position of a specific point on the airfoil. The selected point can be any location on the airfoil surface. The model must generate an airfoil that reflects the specified modification.\nMetrics. We adopt the metrics introduced in AFBench [Liu et al., 2024] to evaluate the generated airfoils:\nLabel Error measures the difference between the physical parameters of the generated or edited airfoil and the intended target parameters, calculated as $o_i = |p_i - p_i|$, where i is the label error for the i-th parameter, $p_i$ is the i-th geometric parameter from the generated airfoil, and $p_i$ is the corresponding target parameter. Smaller values indicate better alignment with the target parameters.\nDiversity quantifies the variety of generated airfoils, calculated as $D = \\sum_{i=1}^{n} \\log \\det (L_{S_i})$, where n is the number of samples, and $L_{S_i}$ is the similarity matrix of the i-th subset, computed based on Euclidean distances between airfoils in the subset. Higher values indicate greater diversity among generated airfoils.\nSmoothness measures the geometric smoothness of the generated airfoils, calculated as:\n$M = \\sum_{i=1}^{N} \\text{Distance}(P_n, \\overline{P_{n-1}P_{n+1}}), \\qquad (8)$"}, {"title": "Ablation Study", "content": "We first ablate the use of the Mat\u00e9rn kernel $K$ with different parameters as the kernel function for the sampled Gaussian process. As shown in Table 4, we compare the cases of Mat\u00e9rn kernel $\\nu = 1.5, l = 0.01$, and Mat\u00e9rn kernel $\\nu = 2.5, l = 0.03$, where the latter is smoother due to the combined effect of both parameters. Notably, the limits of $l = 0$ and $\\nu \\rightarrow \\infty$ correspond to pure white noise and the RBF kernel, respectively. To further highlight the importance of kernel function selection, we also test two models of different sizes (by setting different FNO modes). From Table 4, we observe that a smoother kernel improves both the smoothness and accuracy of the generated airfoils. Additionally, the comparison highlights that, under our setup, selecting a smoother kernel leads to a more substantial performance improvement than increasing the model size. This underscores the benefit of modeling the function object in the airfoil generation task rather than modeling discrete points.\nIn Table 5, we compare the MSE of constraint condition calculations in the airfoil editing task using two initialization schemes: (1) using the latent variables obtained through ODE inversion of the original airfoil as the prior, and (2) using a zero prior $u_0 = 0$ without ODE inversion. Both schemes"}, {"title": "Conclusion", "content": "In this work, we tackle the critical challenge of generating high-fidelity airfoil geometries that effectively balance expressiveness, smoothness, and resolution flexibility. We introduce FuncGenFoil, a function-space generative model leveraging neural operators and flow matching, which represents airfoils as continuous, smooth geometries without resolution constraints while preserving the expressiveness of data-driven methods. Comprehensive experimental results show"}]}