{"title": "Automated Code Fix Suggestions for Accessibility Issues in Mobile Apps", "authors": ["Forough Mehralian", "Titus Barik", "Jeff Nichols", "Amanda Swearngin"], "abstract": "Accessibility is crucial for inclusive app usability, yet developers often struggle to identify and fix app accessibility issues due to a lack of awareness, expertise, and inadequate tools. Current accessibility testing tools can identify accessibility issues but may not always provide guidance on how to address them. We introduce FixAlly, an automated tool designed to suggest source code fixes for accessibility issues detected by automated accessibility scanners. FixAlly employs a multi-agent LLM architecture to generate fix strategies, localize issues within the source code, and propose code modification suggestions to fix the accessibility issue. Our empirical study demonstrates FixAlly's capability in suggesting fixes that resolve issues found by accessibility scanners with an effectiveness of 77% in generating plausible fix suggestions\u2014and our survey of 12 iOS developers finds they would be willing to accept 69.4% of evaluated fix suggestions.", "sections": [{"title": "I. INTRODUCTION", "content": "The increasing reliance on mobile apps for everyday tasks underscores the necessity of ensuring accessibility for all. Despite the existence of guidelines aimed at assisting developers in creating more accessible apps [1]-[3], research shows that many apps are still released with numerous accessibility issues [4]\u2013[7]. Developers often struggle with building accessible apps because they lack awareness of accessibility requirements [4] or have limited knowledge and expertise in effectively addressing accessibility issues [8].\nExisting accessibility scanning tools\u2014such as Accessibility Scanner [9] for Android and Accessibility Inspector [10] for iOS\u2014helpfully verify compliance of each app screen with rules derived from accessibility guidelines. In addition to these rule-based techniques, some automated tools dynamically examine apps using assistive technologies to detect issues that manifest during real-time interactions [11], [12]. However, current tools provide insufficient support for maintaining app accessibility [8] because fixing the large number of issues reported by these tools remains a significant challenge. While single-issue fix techniques address problems like color issues [13], missing labels [14], text scaling problems [15], and touch target size [16], these single-issue fix techniques have notable limitations.\nAccording to documentation, Accessibility Inspector reports 7 categories of issues [10], and these single-purpose approaches can fix only a small subset.\nTo bridge this gap in tooling between single-purpose fix approaches and source code, we investigate an automated plan-localize-fix technique implemented as a tool called FIXALLY to fix various types of accessibility issues reported by scanners such as the Accessibility Inspector [10]. To understand the challenges of fixing issues detected by accessibility scanners in source code, we first conducted formative interviews with five developers. Our developers indicated that: 1) multiple strategies can address a single issue, 2) appropriate fixes must consider not only accessibility guidelines, but also the integrity of the app's design and functionality, 3) implementing a fix frequently requires modifications beyond the problematic element, and 4) identifying these relevant locations in the code to apply fixes is the most time-consuming step.\nTo address these needs, FIXALLY employs a multi-agent LLM architecture capable of proposing plausible fix suggestions for issues reported by an accessibility scanner. In this context, a plausible fix is defined as a modification that passes the accessibility checks of the automated scanner for the target issue without introducing new ones or removing functionality. FIXALLY analyzes an open-source mobile app to detect various accessibility issues. FIXALLY localizes issues within the source code and proposes fix suggestions to resolve the issue using a suggestion generation engine. Each proposed fix suggestion aims to resolve the targeted accessibility issue without introducing new ones or compromising app functionalities. FIXALLY also assists the developer in the decision-making process to select the strategy that best aligns with the app's design and requirements.\nThe contributions of this paper are:\n\u2022 A novel plan-localize-fix technique operationalized as an automated tool using a multi-agent LLM architecture that generates code suggestions to fix accessibility issues in mobile apps.\n\u2022 An empirical evaluation on 205 issues from 14 iOS apps built using SwiftUI, a declarative framework that allows developers to define the desired UI attributes and behavior [17]. Our evaluation demon-"}, {"title": "II. BACKGROUND: COMPARING ANDROID AND IOS", "content": "Many of the existing approaches focus on Android applications which require different techniques than iOS applications. Declarative programming languages, such as SwiftUI, represent a contemporary paradigm for building GUIs in mobile apps by enabling developers to define the desired UI and its behavior using concise syntax. This approach contrasts with traditional imperative methods, where developers must meticulously specify attributes of each UI element and manage its state. For example, in Android, the UI specification is defined using an XML file, with Java classes binding behavior to each element. Developers can also modify UI attributes dynamically through specified behavior in declarative languages. Therefore, properly locating GUI problems in the project cannot be effectively achieved through analysis or modification of the static GUI specification alone. The dynamic specification of UI attributes, which is the core of declarative programming languages, introduces additional challenges in identifying GUI problems, such as accessibility issues, within the source code.\nConsider the color contrast failure issue for the annotated dropdown list in Figure 1, as reported by Accessibility Inspector. Developers typically employ various strategies to address such issues, such as adjusting background colors, modifying text colors, or increasing font sizes. However, these strategies cannot be applied in the provided code snippet that demonstrates the element's implementation. Instead, the appropriate place to adjust the color for this element is within the ThemeView called from the ThemePicker. Locating this correct position necessitates navigating through the UI hierarchy, understanding the semantics of the GUI, and comprehending the structure of the source code required for implementing these elements. This complexity has made localization a challenging task."}, {"title": "III. FORMATIVE STUDY", "content": "To elicit the process developers follow to fix accessibility bugs found by an accessibility scanner in iOS apps, we conducted formative interviews with five iOS app developers in our company. The developers had at least 1 year of experience in developing SwiftUI apps and median of intermediate accessibility familiarity (1 \u2013 No Experience to 5 Expert). During the study, the developers used the Accessibility Inspector and Xcode to detect issues in the Landmarks app\u00b9 running on an iOS simulator. We asked them to think-aloud while they detected and fixed as many issues as they could within 1 hour. At the end, we asked them follow-up questions about their experiences and their ideas on any tools that could improve their process in finding and fixing the accessibility issues. All sessions took place virtually over Webex. Some developers built and tested the app locally while sharing their screen and some developers remotely controlled the screen of the lead researcher who also had the app and simulator built and running in Xcode. A second researcher observed and took notes for four out of five sessions. We recorded audio, video, and notes for each session.\nTo analyze the data, we annotated the transcripts and built an affinity diagram [18] where one paper author led the annotation and initial grouping, and another author read and also validated the themes.\n1) Accessibility Bug Fixing Phases: We examined the developers' overall process in fixing the accessibility bugs with two goals: first, understanding the varied activities (e.g., localizing an issue, fixing it in the code) within the whole process, and second, understanding inefficiencies within each of those activities where an automated tool could help. We found that developers accessibility bug fixing workflow can be grouped into the following phases: hypothesis formation & fix planning, localization, and code editing and validation. We ultimately designed the architecture of FIXALLY around these three phases.\nHypothesis formation and fix planning: All developers in our study had at least intermediate accessibility knowledge and could understand the issues reported by Accessibility Inspector. They were all able to propose hypotheses to"}, {"title": "IV. APPROACH", "content": "shows an overview of FIXALLY, with its three main modules: Data Processing, Suggestion Generation Engine, and Suggestion Assessment.\nFIXALLY takes as input an app with GUI tests, each designed to navigate to different screens of the app. The XCTest framework [19], integrated into Xcode IDE, allows iOS developers to create automated test scenarios that navigate the app to the screens targeted for accessibility assessment. Additionally, existing automated app crawlers can help developers generate these test scenarios automatically. These crawlers either perform random actions on the screen [20] or analyze UI elements to systematically explore all possible actions on those elements [21].\nAutomated testing frameworks recommend that developers use unique identifiers for each element, serving as a bridge between testing frameworks and apps. To ensure every UI element is associated with an identifier, the Data Processing module statically analyzes the source code, restores the UI hierarchy, and instruments the app to insert a unique accessibility identifier for each UI element [22] in the input SwiftUI app. To find accessibility issues, the Data Processing module runs GUI tests to navigate to varied screens in the app. It then uses Accessibility Inspector [10] to obtain a report of accessibility issues on an app screen navigated to by a GUI test. The output of the scanner includes a description of each issue, the identifier of the impacted UI element or its parent elements"}, {"title": "V. SUGGESTION GENERATION ENGINE", "content": "The Suggestion Generation Engine (Figure 3.2) is suggests fix strategies for each reported accessibility issue. Figure 1 shows the Suggestion Generation Engine, illustrating three agents in this module: Planner, Localizer, Fixer. These agents are responsible for performing specific steps that developers take in fixing an accessibility bug, as we observed in our Formative Study (Section III). The details of each agent are below. For each agent,\nEach accessibility issue may be resolved in various ways. According to our Formative Study III, developers prefer solutions that not only fix the issue without introducing new issues, but also align with the design decisions of the app and work well in different modes, such as dark mode or horizontal mode. Providing different options for fixing an issue allows the developer to choose the one that best fits the overall design and functionality. The Planner agent facilitates this by generating natural language suggestions of strategies to fix each issue. For example, agent may suggest a plan of \"adjust background color for better contrast\" to fix a \"contrast failed\" issue for a UI element.\nFIXALLY provides the Planner agent with an annotated screenshot of the app along with the issue description from the Accessibility Inspector. Its task is to identify the most relevant accessibility guideline related to the reported issue and list techniques to resolve it in natural language. FIXALLY aims to leverage the language model's knowledge of accessibility fixes across various platforms, such as the web, to provide suggestions that can be adapted for mobile apps on specific platforms like iOS. FIXALLY instructs the agent to avoid suggesting solutions that are not applicable to the source code, filtering out recommendations such as using third-party tools to test the app. In our evaluation, FIXALLY instructs the Planner to return three alternative plans for each issue, though this number can be configured.\nLocalizing an issue involves identifying the precise location in the source code where the fix plan should be applied. Source code projects often span numerous files with thousands of lines, potentially exceeding the token limits that language models can effectively query in one request or retain in their context window. To manage this complexity, we employ a multi-level localization approach using static code analysis and LLM code analysis. Figure 4 illustrates the different levels of localization, including one static code analysis step and two LLM-based steps for issue-to-code mapping.\nFirst, the Localizer identifies all of the View files of the project, identifiable by the \u2018import SwiftUI' statement and structures extending the View class. Then, it extracts candidate code snippets from these view files through static code analysis. The key insight that the Localizer uses to optimize this process is that the behavior and design of UI elements are predominantly influenced by their descendants or ascendants. The Static Analysis module takes the accessibility identifier of the problematic element and traverses the pre-analyzed UI structure to return all descendant views and the parent of that element to form a set of candidate code snippets. FIXALLY adds these accessibility identifiers to each view in the code in the Data Processing phase, where it also captures the UI hierarchy (Recall Section IV).\nNext, the Localizer generates an LLM-based rating for the code snippets filtered by the static analysis module. It matches each snippet to the modification plan for the issue and the screenshot highlighting the problem. Due to the limited context window of LLMs, it may not be feasible to consider and compare all candidate snippets simulta-"}, {"title": "VI. EVALUATION", "content": "We evaluated FIXALLY through the following research questions:\nRQ1. (Effectiveness) How effective is FIXALLY in generating code fixes for accessibility issues detected by an accessibilty scanner?\nRQ2. (Efficiency) What is the efficiency of FIXALLY in terms of time, the number of attempts, and the cost?\nRQ3. (Helpfulness) How helpful are the proposed fixes for developers?\nWe evaluated our approach using 14 open-source apps sourced from GitHub. Specifically, we randomly selected apps from two GitHub repositories that catalog open-source iOS apps [24], [25], excluding apps not built using SwiftUI. For each app, one of the authors attempted to build the app successfully within a 30 minute window. We also excluded apps with build errors due to dependencies, external packages, or very old iOS versions from the dataset. Table I provides a list of the apps included in our study. The list of apps with their corresponding GitHub links is also available in our supplementary materials. FIX-ALLY'S implementation leverages LLM agents based on GPT-40, which features a 128K context window and has a knowledge cut-off date of October 2023. We conducted the experiments on a MacBook M1 Pro equipped with 32GB of RAM, a typical computer setup for development. We used Xcode 15.0, the latest available version, to build the apps, and we installed and tested them on an iPhone 12.\nWe assessed the efficacy of FIXALLY by evaluating its ability to propose fix suggestions for 204 issues across 22 screens of SwiftUI iOS apps. Table I presents the outcomes of FIXALLY in generating fix suggestions. We use the term plausible to indicate that the generated fix resolved the targeted issue while maintaining app functionality and without introducing new issues.\nFIXALLY demonstrated a 77% effectiveness in automatically generating fix suggestions for accessibility issues, where effectiveness means it successfully produced at least one plausible suggestion out of three suggestions for 157 out of 204 issues. Furthermore, for 129 (63%) of these issues, FIXALLY generated two or three plausible fix suggestions, providing developers multiple options to consider.\nWe also assessed the categories of issues that FIXALLY can generate fix suggestions for. Our dataset contains nine different types of issues as shown in Table II. According to the documentation for Accessibility Inspector [26], these issues encompass the categories of Element description, Element detection, Hit region, Contrast, Clipped text, Traits, and Dynamic type. However, our dataset does not contain trait issues: we found that even when modifying-"}, {"title": "VII. THREATS TO VALIDITY", "content": "External Validity: One limitation of FIXALLY is that it assesses issues individually, even though many issues may be interconnected. For example, fixing one issue might resolve others, or altering the appearance of one element might require adjustments to other related elements. To address this, we have designed the Fixer prompt to cascade design changes across elements to maintain design integrity. As Figure 5(c) shows, the model can consider this aspect in some cases. However, without a clear definition of relevant elements and design integrity, the tool's limitations and capabilities are unknown. Future work could focus on developing metrics to assess design integrity or grouping related issues to propose unified solutions and enhance the performance of the tool.\nAdditionally, FIXALLY focuses on single-view files for localizing and generating fixes for issues, which means it cannot address problems that require changes across multiple files. Although the issues in our test set could be resolved within single files, studying more complex, cross-file issues-albeit less common-remains a compelling area for future research. This limitation also impacts the consideration of overall app design integrity beyond a single screen. While providing multiple suggestions allows developers to choose the most suitable one based on app design decisions, incorporating techniques to group issues across different app screens would enhance the tool.\nLastly, the tool has been implemented and tested on iOS apps. We believe that the benefits of FIXALLY can be generalized to other platforms by using appropriate tools to build, instrument, and audit apps on those platforms. The system definitions for agents can also be adjusted according to the platform, such as specifying expertise in SwiftUI for iOS or in Android development for Android apps. However, this generalizability needs to be further evaluated.\nInternal Validity: We implemented FIXALLY using various tools and libraries, including XCTest, Accessibility Inspector, and the Tree-sitter library for code parsing [28]. These external tools may introduce defects into the system, and the prototype itself may contain implementation bugs. To mitigate these issues, we tested the tool on a variety of apps at different stages and ensured that we used the latest updates of the external tools."}, {"title": "VIII. RELATED WORK", "content": "Our work fits into the space of automated accessibility testing and repair tools, which have advanced the state-of-the-art for automated detection and reported of accessibility issue. Our work is among the first to localize and suggest fixes in code for these issues. We also review work LLM-based program repair and fault localization which use similar multi-agent architecture, but do not address GUI or accessibility issues."}, {"title": "IX. CONCLUSION", "content": "Fixing accessibility issues in mobile apps is a challenging task for developers. While automated scanners can identify these issues, they often fall short in guiding developers to the exact location in the code and suggesting appropriate fixes. Towards addressing these needs, we proposed a plan-localize-fix technique, operationalized through a multi-agent LLM architecture called FIXALLY. Evaluations on FIXALLY demonstrate its capabilities in suggesting plausible fix suggestions and highlight how the tool assists the developer in the decision-making process for selecting and applying accessibility-related fixes. Our results suggest that applying LLMs to fix accessibility issues in source code is an encouraging direction."}]}