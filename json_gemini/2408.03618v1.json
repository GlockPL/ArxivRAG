{"title": "A Logical Fallacy-Informed Framework for Argument Generation", "authors": ["Luca Mouchel", "Debjit Paul", "Shaobo Cui", "Robert West", "Antoine Bosselut", "Boi Faltings"], "abstract": "Despite the remarkable performance of Large Language Models (LLMs), they still struggle with generating logically sound arguments, resulting in potential risks such as spreading misinformation. An important factor contributing to LLMs' suboptimal performance in generating coherent arguments is their oversight of logical fallacies. To address this issue, we introduce FIPO, a fallacy-informed framework that leverages preference optimization methods to steer LLMs toward logically sound arguments. FIPO includes a classification loss, to capture the fine-grained information on fallacy categories. Our results on argumentation datasets show that our method reduces the fallacy errors by up to 17.5%. Furthermore, our human evaluation results indicate that the quality of the generated arguments by our method significantly outperforms the fine-tuned baselines, as well as prior preference optimization methods, such as DPO. These findings highlight the importance of ensuring models are aware of logical fallacies for effective argument generation.", "sections": [{"title": "1 Introduction", "content": "Argument generation is crucial in daily life and has many online and offline applications. For instance, legislative bodies often use persuasive arguments to ensure votes for bills to pass. However, generating logically coherent arguments is a challenging task and requires an appropriate combination of reliable evidence and effective logical reasoning (Walton et al., 2008; Wachsmuth et al., 2017). Humans are prone to misconstruing logical argumentation in the real world and often unknowingly adopt flawed reasoning in discussions and decision-making processes (Evans, 2002). Similar to humans, Large Language Models (LLMs) have demonstrated limitations in their logical reasoning capabilities, suffering from logical inconsistencies (Chen et al., 2023b; Jin et al., 2022; Sourati et al., 2023) and producing logically incorrect arguments (Chen et al., 2023a).\nIn this work, we hypothesize that LLMs generate logically incorrect arguments because they lack an understanding of logical fallacies. A logical fallacy is an error in reasoning that undermines the validity of an argument (Tindale, 2007). For example, \"I've never had the flu because I take my vitamins every day.\" is an instance of a false causality fallacy. In our pioneer study, we generate 100 arguments on different topics with ChatGPT and find that 21% of the arguments contain fallacies. We observe that several types of logical fallacy arguments, including false causality, faulty generalization or circular reasoning are commonly generated by different LLMs (such as Llama-2 or Mistral). An example of fallacies is shown in Figure 1.\nOur study explores the relationship between logical fallacy understanding and argument generation. We view models generating logically coherent arguments as a logical alignment problem, i.e., aligning the model responses (arguments) to the given topic and stance. Recent methods, such as Reinforcement Learning with Human or AI feedback, have been shown to bridge the \"alignment gap\u201d between the model responses and the human preference (Lee et al., 2023). These methods help steer models to prefer one response over another based on feedback signals from another (preference) model. However, LLMs fine-tuned with RLHF can still generate arguments that are logically fallacious - e.g. making arguments that sound convincing but are untrue. Hence, to train models to prefer logically correct arguments, it is important to have reliable and diverse error scenarios as training examples. To address this issue, we define 13 categories of logical fallacy errors, drawing inspirations from the history of logic and logical fallacies (Aristotle, 2006; Russell, 2013). We then use ChatGPT to collect 7,872 fallacy arguments spanning different fallacy categories to train a preference model.\nWe first propose to use existing preference optimization methods to instil the ability to generate logically correct arguments. Specifically, we use DPO (Rafailov et al., 2023), PPO (Schulman et al., 2017), KTO (Ethayarajh et al., 2024), and CPO (Xu et al., 2024) on our preference dataset to learn these abilities. These fallacy-informed models demonstrate a notable improvement in argument quality, achieving a higher win-rate (i.e., the proportion of wins over the baseline in terms of argument quality) and reducing the fallacy-rate (i.e., the proportion of fallacies generated) by 8.5%.\nHowever, we hypothesize that models can benefit from additional fine-grained information about logical fallacies. We introduce Fallacy-Informed Preference Optimization (FIPO) that combines the original preference optimization loss with a classification loss in the form of a weighted cross-entropy loss, which penalizes the policy more when fallacies are incorrectly classified during the training phase. We observe FIPO outperforms the SFT baselines by reducing the fallacy-rate from 34.5% to 17% for Llama-2 (7B) and from 32.5% to 19.5% for Mistral (7B). FIPO also outperforms the best preference optimization method (PPO-Llama 2 and KTO-Mistral) by producing 9% and 8.25% fewer logical fallacy errors respectively. Additionally, our human evaluation results show that FIPO generates higher-quality arguments than the baseline. FIPO also performs well on out-of-domain scenarios, indicating its ability to generalize to unseen topics. These findings underscore the importance of making models explicitly aware of logical fallacies for argument generation."}, {"title": "2 Related Work", "content": "Logical Fallacies. Logical fallacies are errors in reasoning that can undermine the validity of an argument (Tindale, 2007). In argumentative discourse, identifying fallacies is crucial to measure the quality of argumentation (Wachsmuth et al., 2017; Nakpih and Santini, 2020). In particular, identifying fallacies can be useful for disinformation detection systems and critical thinking tools. Prior works have shown that LLMs struggle to classify logical fallacies, with the F1 scores being around 66% and merely reaching 27% during transfer learning (Jin et al., 2022; Sourati et al., 2023). More recently, however, Li et al. (2024) demonstrated GPT-4's ability to identify and classify fallacies, achieving over 86% of accuracy in both tasks. Nevertheless, previous works have not explored how a nuanced understanding of logical fallacies might influence argument generation.\nArgument Generation. Argument generation is an important task in natural language processing that requires generating coherent and persuasive arguments on a given topic. Existing argument generation frameworks have made significant strides: Hua and Wang (2018) introduced a generator that generates arguments from key phrases, followed by a separate decoder to produce the final argument text. Hua et al. (2019) developed Candela, a style-controlling counter-argument generation framework. Schiller et al. (2021) presented Arg-CTRL a model that uses control codes for topic, stance, and aspect in sentence-level argument generation. More recently, Saha and Srihari (2023) introduced an argument generator for factual arguments across a limited set of topics. Despite these advances, no study has yet addressed generating arguments from the lens of logical fallacies.\nData Generation and Automatic Evaluation with LLMs. The employment of LLMs like ChatGPT in data generation is supported by their proven effectiveness in a broad spectrum of text generation tasks, including the creation of instructional and relational datasets (Peng et al., 2023; Sun et al., 2023; Wang et al., 2023; Shao et al., 2023; Chia et al., 2022). Notably, Schick and Sch\u00fctze (2021) have demonstrated the utility of LLMs in producing datasets that significantly enhance the training of smaller models. With respect to evaluating automatically generated text, Liu et al. (2023) show that traditional reference-based metrics such"}, {"title": "3 Problem Formulation", "content": "In this work, we address the argument generation task, where a model needs to generate a logically correct argument given a topic and a stance. We denote a dataset as \\(D = \\{x^{(i)}, y_w^{(i)}\\}_{i=1}^N\\), in which x is the input topic and the stance (either supporting or countering), and \\(y_w\\) is the argument. N is the number of instances. One naive approach to address the problem of logical argument generation is prompting LLMs. We use GPT-3.5, Llama-2 (7B), and Mistral (7B) in the zero-shot setting on a set of 100 topics. We also implement a Retrieval Augmented Generation (RAG) model on top of Llama-2 using the wiki-dpr database (Karpukhin et al., 2020). A short description and example are provided in Appendix C.2.\nObservations. In Table 1, we report the performance of all the models in argument generation. We use GPT-4 to assess the logical fallacies of the generated arguments. Among the models evaluated, ChatGPT demonstrated the best performance; however, it still generates arguments containing logical fallacy errors in 21% of the cases. Further, we also observe that open-source models generate higher rates of fallacious arguments. The detailed distributions of the fallacy types across the different approaches in the zero-shot setting are discussed in Table 5."}, {"title": "4 Methodology", "content": "To address the problem of generating fallacy-free and logically sound arguments, we propose using preference learning methods to generate arguments that are logically aligned with the given topic and stance. This involves making models aware of various logical fallacies and teaching them to generate logically correct arguments, by rewarding valid arguments and rejecting dispreferred samples.\nThe process of preference learning typically involves three main steps: (i) supervised fine-tuning (SFT) step (Section 4.1), (ii) preference data collection step (Section 4.2), (iii) reinforcement learning step (Section 4.3). In Section 4.4, we introduce our method (FIPO), which introduces fine-grained information about fallacies in the alignment process. A comprehensive overview of the methodology is presented in Figure 2. To justify our current design and methodology, we perform an ablation study with different training approaches, described in Appendix E. The results show that our design achieves the best results."}, {"title": "4.1 Supervised Fine-Tuning", "content": "We begin by fine-tuning a pre-trained language model (\\(\\pi_{\\beta}\\)) on the argumentation dataset D and use maximum likelihood estimation to obtain a model \\(\\pi_{SFT}\\).\n\\[L_{SFT}(\\pi_{\\beta}) = -E_{(x,y_w)\\sim D}[log \\left(\\pi_{\\beta}(y_w|x)\\right)]\\]"}, {"title": "4.2 Preference Data Collection", "content": "Conventionally, after the SFT phase, \\(\\pi_{SFT}\\) is prompted with input x to produce pairs of outputs \\((y_1, y_2) \\sim \\pi_{SFT}(y|x)\\), which are then presented to human annotators to rank as preferred and dispreferred responses. However, our objective is to reduce logical fallacy errors in the model's outputs. Therefore, it is essential to include a diverse range of fallacy types in the preference data, as these may not be sufficiently represented in the model's outputs.\nDrawing inspirations from the history of logic and logical fallacies (Aristotle, 2006; Russell, 2013), we define 13 categories of logical fallacy errors (see Figure 3). However, there are two key challenges: (i) determining the appropriate distribution of logical fallacy errors in the preference data, and (ii) automatically collecting such fallacy arguments.\nTo address the first concern, we follow the LOGIC dataset Jin et al. (2022), which was carefully curated through extensive web crawling and data collection from diverse online sources. This dataset reflects the distribution of fallacies in real-world scenarios, providing a realistic foundation for mitigating fallacies in everyday argumentative discourse.\nFor the second concern, we collect fallacy arguments using ChatGPT, following the distribution of fallacies in (Jin et al., 2022). To ensure arguments generated by ChatGPT are indeed fallacies, we provide a definition of the specific fallacy being generated as well as examples of that fallacy type. To populate our preference dataset and ensure it spans across the most types of fallacies, We generate four fallacious arguments with different fallacy types for each instance \\(x^{(i)}\\). To emphasize certain fallacy types more than others, we sample the fallacy types to generate according to the LOGIC dataset (Jin et al. (2022), Figure 3).\nThe original dataset D is now augmented with fallacies, denoted as \\(y_l^{(i)}\\), and we define the training dataset as \\(D' = \\{x^{(i)}, y_w^{(i)}, y_l^{(i)}, k^{(i)} \\}_{i=1}^{M}\\), where we have M pairs of preferred (\\(y_w\\)) and dispreferred (\\(y_l\\)) samples, with \\(k^{(i)}\\) being the fallacy type of the dispreferred argument \\(y_l^{(i)}\\). The test set is not augmented with fallacies, as we use only the topics and stance \\(x^{(i)}\\) at inference time to evaluate the quality and logical soundness of the arguments generated with respect to the topic and stance. More details on the generations and our prompt designs for Chat-"}, {"title": "4.3 Reinforcement Learning Phase", "content": "Following the preference data collection phase, we refine and optimize the SFT policy (\\(\\pi_{SFT}\\)) based on the trained reward model (explicit feedback) or the preference data (implicit feedback). In this work, we use four different learning algorithms: PPO, DPO, KTO, and CPO to mitigate the logical fallacy errors. Among these algorithms only PPO requires explicit feedback from a trained reward model. For the other methods, we apply the preference optimization methods directly by using \\(\\pi_{SFT}\\) as a reference model, and the preference data \\(D'\\).\nExplicit Reward Modelling. We use the dataset \\(D'\\) to train the Electra model (Clark et al., 2020) to learn to predict reward values.\nImplicit Reward Modeling. Methods like DPO, KTO, and CPO employ contrastive loss to derive implicit rewards from preference datasets. Note that CPO (Xu et al., 2024) is a reference-free method that does not require a reference policy."}, {"title": "4.4 Fallacy-Informed Preference Optimization (FIPO)", "content": "Despite the reinforcement learning fine-tuning, models persistently generate specific types of logical fallacies, particularly faulty generalization and false causality arguments (Table 3). This can be attributed to the fact that the models do not explicitly learn about the fallacy types. Hence, we propose a fallacy-informed preference optimization method. This is achieved by attaching a classification head on top of the generative model, which calculates a weighted cross-entropy loss for the preferred and dispreferred samples. Recall \\(D' = \\{x^{(i)}, y_w^{(i)}, y_l^{(i)}, k^{(i)} \\}\\) where \\(k \\in [1,13]\\) is the fallacy type. We also label the preferred samples \\(y_w\\) as class 0, 'Not a Fallacy'. Secondly, after a forward pass through the language model, we extract the hidden state from the last layer, denoted as \\(\\pi_{\\theta}(y|x)_L\\), where L represents the number of layers in the base models. This hidden state is then fed into the classification head. The resulting output defines the probability of each fallacy type k:\n\\[p_k(\\pi_{\\theta}(y|x)) = Softmax(W\\pi_{\\theta}(y|x)_L + b)_k\\]\nwhere W is the linear layer's weight matrix, and b is the corresponding bias term. To avoid penalizing the model equally for misclassifying different types of fallacies, we propose to guide the model to prioritize the most frequent fallacy types. This approach ensures that the model accurately identifies common fallacies, aligning its learning process with the real-world distribution (Figure 3). Hence, we define the weight \\(w_k\\) for each fallacy type k as its frequency in \\(D'\\):\n\\[w_k = \\frac{1}{|D'|} \\sum_{i=1}^{|D'|} 1_{k^{(i)}=k}\\]\nwhere 1 is the indicator function. The Fallacy-Informed loss \\(\\mathcal{L}_{FI}\\) is defined as a weighted cross-entropy loss:\n\\[\\mathcal{L}_{FI} = -E_{(x,y_w,y_l,k)\\sim D'} [w_0 log p_0 (\\pi_{\\theta}(y_w|x)_L) + w_k log p_k(\\pi_{\\theta}(y_l|x)_L)]\\]\nwhere \\(w_0\\) is the minimum frequency of all of these fallacy types, which is designed to let the policy focus more on the fallacies in the dispreferred samples rather than the non-fallacy samples during the preference optimization process.\nThe resulting loss function, termed Fallacy Informed Preference Optimization loss, combines the loss from the preference optimization with our classification loss (\\(\\mathcal{L}_{FI}\\)). In our work, CPO (Xu et al., 2024) is the method with which we combine our loss. The resulting loss is:\n\\[\\mathcal{L}_{FIPO} = \\mathcal{L}_{CPO} + \\lambda \\mathcal{L}_{FI}\\]\nwhere \\(\\lambda\\) is a weighting parameter to adjust the fallacy-informed loss with respect to the preference optimization loss. A more detailed description of \\(\\mathcal{L}_{FIPO}\\) is described in Appendix F."}, {"title": "5 Experimental Setup", "content": "We denote \\(\\pi_{SFT}\\) and \\(\\pi_{\\theta}\\) as the policies obtained after the SFT phase and the aligned policy respectively. \\(\\pi_{\\theta}\\) is aligned using method @ which is one of PPO (Schulman et al., 2017), DPO (Rafailov et al., 2023), CPO (Xu et al., 2024), KTO (Ethayarajh et al., 2024) and FIPO."}, {"title": "5.1 Datasets", "content": "We evaluate argument generation based on the EXPLAGRAPHS dataset (Saha et al., 2021) where samples contain a Topic, a Stance, and an Argument, spanning across a wide range of topics such as: Cannabis should be legalized or The government controls people's money. We augment this dataset using ChatGPT by generating equivalent arguments in the form of fallacies using the distribution of the LOGIC dataset (Jin et al., 2022), as described in Section 4.2 and depicted in Figure 2. Our final dataset size is given by Table 2. We also perform out-of-domain analysis on a subset of samples from the Debatepedia dataset, extracted from (Cabrio and Villata, 2012)."}, {"title": "5.2 Settings", "content": "Base Models. We use Llama-2 (7B) (Touvron et al., 2023) and Mistral (7B) (Jiang et al., 2023) as our base models. For each alignment method, we leverage Low-Rank Adaptation (LoRA) (Hu et al., 2021), which is a Parameter Efficient Fine-Tuning method (Xu et al., 2023) that decomposes a large matrix into two smaller low-rank matrices in the attention layers. This drastically reduces the number of parameters that need to be fine-tuned. We reduce the number of trainable parameters down to 8.3M"}, {"title": "Hyperparameter Selection for FIPO.", "content": "To optimize our custom loss function, defined in Equation 5, we conduct a series of experiments manipulating the hyperparameter \\(\\lambda\\) (Equation 5) and the weights for the cross-entropy loss (Equation 3). Our initial step involved tuning the weights for the loss function. Given that our dataset consists of n pairs of preferred and dispreferred arguments as logical fallacies, it is crucial to differentiate different fallacy classes. It is thus more suitable to set the weights for each fallacy type as their frequency in the dataset, given by Equation 3 and the weight for the preferred responses as little as possible, which we set as the minimum of all the fallacy frequencies. We also evaluate different settings of \\(\\lambda\\), testing values of 0.1, 0.3, and 0.6. Our findings indicate that a higher \\(\\lambda\\) effectively reduced the number of fallacies produced by the policies but adversely impacted the argument quality (win-rate). Conversely, a \\(\\lambda\\) of 0.1 had minimal impact on improving the fallacy-rate. After assessing the trade-offs, we determined that a \\(\\lambda\\) value of 0.3 provided the optimal balance between minimizing fallacies and maintaining a reasonable win-rate."}, {"title": "5.3 Evaluation", "content": "In this work, we use two metrics to evaluate argument quality, the win-rate and the fallacy-rate. The win-rate is the proportion of instances where one option is superior or more successful compared to another option in a given set of comparisons. We include 3 options for the win-rate: win, tie, lose. The fallacy-rate is the proportion of fallacies detected in the generated arguments.\nHuman Evaluation. We conduct a human evaluation to validate the relevance and quality of the generated arguments. We randomly select 200 topics and stances (either supporting or opposing), and a pair of arguments generated by different methods. More concretely, human annotators are requested to perform a comparative study by determining which argument is superior or whether both arguments are equally good or equally bad. Despite the subjective nature of this task, as certain arguments may appeal differently to different individuals, we provide instructions to annotators including selecting the argument that most clearly addresses the topic and stance. If both arguments meet this criterion, the annotators should select 'tie'. Refer to Figure 6 for more details. Annotators are recruited from Amazon Mechanical Turk\u00b2 for this task. We limit our selection to native English speakers residing in the United States. The eligibility criteria for annotators include a HIT approval rate of at least 97% and a minimum of 10,000 approved HITs. We present more details, including the annotating instructions in Appendix C.4.\nAutomatic Evaluation. We perform a pairwise comparison between the reference \\(\\pi_{SFT}\\) and the policies \\(\\pi_{\\theta}\\). For the win-rates, we prompt GPT-4 to select which argument is better, as described in Appendix A.2. For the fallacy-rate we prompt GPT-4 to detect a fallacy out of all the ones listed in Table 8. We use GPT-4 to compute the fallacy-rates, as it performs well in identifying fallacies (Li et al., 2024). A description of the GPT-4 evaluation is detailed in Appendix A.2."}, {"title": "6 Experimental Results", "content": "As outlined in Section 5.3, our evaluation of the generated arguments focuses on two primary aspects: (i) pairwise comparison of argument quality between the reference policy \\(\\pi_{SFT}\\) and the aligned policies \\(\\pi_{\\theta}\\), detailed in Section 6.1; and (ii) the analysis of fallacy-rates and types across different preference optimization methods in Section 6.2."}, {"title": "6.1 Pairwise Comparison of Different Preference Optimization Methods", "content": "Each argument sample undergoes a manual and automatic (GPT-4-based) comparative evaluation, whose results are shown in Figure 4 and Table 6. For the human evaluation, each sample receives three assessments. Samples lacking majority consensus among annotators are excluded from further analysis. From the human annotated win-rates, depicted in Figure 4, we address the following research questions:\nRQ1: Are preference optimization methods better than SFT? The aligned policies outperform SFT by several percentage points in terms of win-rates, indicating an improvement in overall argument quality. DPO and CPO are the only methods achieving over 40% win-rates, demonstrating a better ability to generate arguments. \\(\\pi_{FIPO}\\) stands out"}, {"title": "6.2 Results of Fallacy-Rates and Types", "content": "Evaluating text segments to identify logical fallacies poses inherent challenges for humans. Detecting such fallacies demands an extensive understanding of logical principles and argumentative structures. Without a robust grasp of logical fallacies, differentiating between valid and flawed reasoning becomes difficult. Additionally, personal biases and preconceptions can also cloud judgment, leading to overlooked fallacies or biased interpretations of arguments. We report GPT-4's evaluations in Table 3. Based on the results, we make the following observations:\nRQ3: Do preference optimization methods mitigate logical fallacy errors? The aligned policies produce fewer fallacies compared to the SFT baseline. Specifically, every alignment method outperforms \\(\\pi_{SFT}\\) by several percentage points for Llama-2. For both Llama-2 and Mistral, DPO is the method which improves the least, and even produces more fallacies than SFT with Mistral, having a lower frequency of Not a fallacy arguments. The other methods (PPO, CPO and KTO) consistently outperform SFT and produce fewer fallacies.\nRQ4: Does FIPO further reduce logical fallacy errors? The least fallacy producing policy is FIPO, achieving 83% of Not a fallacy arguments with Llama-2 and 80.5% with Mistral, outperforming the previous best score by 9% for Llama-2 (PPO: 74%) and 8.25% for Mistral (KTO: 72.25%), (Figure 5, Table 3). More specifically, FIPO, based on CPO, beats CPO by 11% and 10.5% for Llama-2 and Mistral, respectively. This highlights the utility of the classification loss, indicating the policies have a better understanding of logical fallacies compared to regular preference optimization.\nRQ5: What is the most observed fallacy type? The most frequently observed fallacy produced across all of the policies is Faulty Generalization. For FIPO, the occurrence of this fallacy significantly decreases from approximately 20% to 7%, demonstrating that \\(\\pi_{FIPO}\\) effectively integrates the"}, {"title": "6.3 Out-of-Domain Analysis", "content": "To showcase the effectiveness of alignment methods in argument generation, we evaluate the fallacy-rate and win-rate of 100 arguments generated with each policy on a subset of (Cabrio and Villata, 2012). Topics include Social security should be privatized or Airport security profiling is a good idea. The backbone model for these alignment methods is Llama-2. The results are detailed in Table 4, and we find that \\(\\pi_{FIPO}\\) is the second policy to produce the least amount of fallacies (55%), behind \\(\\pi_{KTO}\\) (56%). Although it is second, it still outperforms all the other policies by several percentage points. We also find that FIPO achieves the highest win-rate, winning 62% of the times against SFT (Table 4)."}, {"title": "7 Conclusion", "content": "In this work, we investigate the impact of logical fallacies on argument generation and introduce FIPO, a novel framework designed to improve the logical soundness of generated arguments by addressing various types of logical fallacies. Both human and automatic evaluations show that our method produces higher-quality arguments compared to the baseline and achieves a significantly lower fallacy rate. These findings underscore the role of including logical fallacies in improving argument generation. Finally, our framework is versatile and can be applied to other text-generation tasks."}, {"title": "Limitations", "content": "Although various preference optimization strategies have shown improvement over the SFT baseline in reducing fallacious arguments, the margin remains modest. This may be attributed to several factors: our assumption that the original dataset (Saha et al., 2021) was free of fallacies, the inherent complexity and diversity of fallacies which complicates effective detection, and the variability in model performance, particularly the weaker results from the Mistral model compared to Llama-2. Additionally, the limited size of our dataset and the brevity of arguments present further challenges, as the lack of contextual cues can hinder the models' ability to identify and avoid fallacies consistently."}, {"title": "Ethics Statement", "content": "In this paper, we experiment with existing datasets that are well-acknowledged. Our framework is designed to improve argument generation in LLMs, which have been shown to potentially encode biases about race, gender, and other demographic attributes (Weidinger et al., 2021; Sheng et al., 2020). Since our work does not offer a way to mitigate these biases, models could still possibly reflect the same harmful behaviors. We recommend anyone deploying our model off-the-shelf should first check whether the model is harmful towards any protected group, and appropriate mitigation should be taken. Moreover, our annotation task is based on arguments generated by these models, which are complex to evaluate in terms of identifying logical fallacies because of the complex nature of fallacious reasoning. Hence, our task was done with English-speaking AMT workers who were paid adequately for the time it took to solve the tasks."}, {"title": "A Data Augmentation and Evaluation with LLMs", "content": "A.1 Generating Arguments with ChatGPT\nOur prompt design for ChatGPT to generate fallacies follows a similar heuristic to (Liu et al., 2023), by introducing the task, defining the fallacy type it must generate, along with two examples of that particular fallacy type. Following the distribution in Figure 3, we generate four fallacies for the same topic and feed the following prompt to ChatGPT to generate fallacies as negative preference data:\nYou are given a topic T. Your task is to generate a {'supporting' or 'counter'} argument in the form of a f-type\u201c logical fallacy in the context of the topic. It should not be longer than 25 words.\nf-type fallacy is defined as: {definition}\nexamples of fallacy type are:\nexample 1\nexample 2\nHere is an example of a supporting f-type fallacy:\n{example of an argumentative fallacy}\n{\n\"topic\": T, \"fallacy\": f-type, \"argument\": <...>\"\n}\n\"Fallacy type that can be any of the thirteen types described in Table 8\nSome examples of generated logical fallacies include: \"I know someone who smoked cannabis and became successful. Therefore, everyone who smokes cannabis will be successful.\", \"I know a few people who spend too much time on social media and have no real-life friends. Therefore, social media is terrible for society.\". Table 9 presents examples of samples in our preference dataset. Our augmented fallacy argument dataset consists of the train-test split in Table 2.\nA.2 Prompting GPT-4 for Evaluation\nTo evaluate whether \\(\\pi_{\\theta}\\) for a given method @ generates logical arguments compared to \\(\\pi_{SFT}\\), we use GPT-4 and evaluate the win-rate (e.g., how often does \\(\\pi_{\\theta}\\) produce better arguments) by prompting GPT-4 with:\nWhich of these arguments is better for the topic x:\n1. \\(\\pi_{SFT}(y|x)\\)\n2. \\(\\pi_{\\theta}(y|x)\\)\nIf both arguments are equally good, return 3 (Tie). The better argument is: <response>\nWe also evaluate how often both models produce logical fallacies, which we call fallacy-rate, by prompting ChatGPT with:\nConsider the following topic and {supporting or counter} argument:\nTopic: T\nArgument: t\nOut of all the following logical fallacy types {list of types from Table 8}\nwould you qualify t as one of these logical fallacies? If not - return \"None\".\nIf yes, which logical fallacy type is it? Let f-type be your answer. Return\n{\"topic\": T, \"text\": t, \"fallacy type\": f-type }"}, {"title": "B Preference Optimization", "content": "Preference optimization is a crucial step in aligning language models to generate outputs that meet user preferences and objectives effectively. It involves the process of ensuring that the goals and preferences of AI systems align with those of their human users. To demonstrate models are capable of learning to distinguish logically sound text from logical fallacies, we assess the performance of four different preference optimization techniques, including PPO (Schulman et al., 2017), DPO (Rafailov et al., 2023), CPO (Xu et al., 2024) and KTO (Ethayarajh et al., 2024).\nPPO. One widely used reinforcement learning optimization algorithm within RLHF is Proximal Policy Optimization (PPO). PPO (Schulman et al., 2017) is particularly favored due to its stability and efficiency. It iteratively updates the model's policy parameters by maximizing the expected cumulative reward while constraining the policy updates to a proximity threshold, preventing large policy changes that could destabilize learning.\nDPO. More recently, Rafailov et al. (2023) introduced Direct Preference Optimization, which skips the reward modelling part that is necessary for PPO. DPO leverages an analytical mapping from reward functions to optimal policies, to transform a loss function over reward functions into a loss function over policies and avoids fitting a reward model, while still optimizing under given preferences."}, {"title": "CPO.", "content": "Another recently introduced method is Contrastive Preference Optimization (CPO). Xu et al. (2024) introduced CPO as a derivation of DPO, to address some shortcomings of DPO, including memory and speed inefficiencies. (Xu et al., 2024) focuses mainly on machine translation, but the method can also be adapted to regular preference optimization for other tasks. They also incorporate a behaviour cloning regularizer to ensure that the policy does not deviate from the preferred data distribution."}, {"title": "KTO.", "content": "Finally, the last method we evaluate is Kahneman-Tversky Optimization (KTO) (Ethayarajh et al., 2024). The authors introduce the concept of human-aware loss functions (HALOs), which implicitly model human biases and have been shown to perform better than non-HALOs. Their approach directly maximizes the utility of generations instead of maximizing preference likelihood, as is commonly done."}, {"title": "C Details of Experimental Setup", "content": "C.1 Hyperparameters\nTraining Parameters. For both base models, we train \\(\\pi_{SFT}\\) and \\(\\pi_{\\theta}\\) on 2 A100 GPUs for 3 epochs, using an Adam optimizer, with a learning rate of 2-4. For the LORA configuration, we select a rank r = 16, \\(\\alpha\\) = 32 and a dropout of 5-2. Regarding the specific training details of each method, we use \\(\\beta\\) = 0.25 for DPO (Rafailov et al., 2023), which controls how much \\(\\pi_{\\theta}\\) deviates from the reference model \\(\\pi_{SFT}\\). For both CPO (Xu et al., 2024) and KTO (Ethayarajh et al., 2024), we use \\(\\beta\\) = 0.1, which controls the implicit reward. Regarding the reward model for PPO (Schulman et al., 2017), we use a binary logical fallacy classifier we trained using the chosen responses as non-fallacies and the rejected responses as fallacies. The classifier achieves accuracy and F1 over 95% in the detection of fallacy arguments, which makes us confident in using the model as a reward model for this particular task and we use the logits as rewards. Decoding Parameters. At"}]}