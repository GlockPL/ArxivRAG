{"title": "AlphaRouter: Quantum Circuit Routing with Reinforcement Learning and Tree Search", "authors": ["Wei Tang", "Yiheng Duan", "Yaroslav Kharkov", "Rasool Fakoor", "Eric Kessler", "Yunong Shi"], "abstract": "Quantum computers have the potential to outperform classical computers in important tasks such as optimization and number factoring. They are characterized by limited connectivity, which necessitates the routing of their computational bits, known as qubits, to specific locations during program execution to carry out quantum operations. Traditionally, the NP-hard optimization problem of minimizing the routing overhead has been addressed through sub-optimal rule-based routing techniques with inherent human biases embedded within the cost function design. This paper introduces a solution that integrates Monte Carlo Tree Search (MCTS) with Reinforcement Learning (RL). Our RL-based router, called AlphaRouter, outperforms the current state-of-the-art routing methods and generates quantum programs with up to 20% less routing overhead, thus significantly enhancing the overall efficiency and feasibility of quantum computing.", "sections": [{"title": "I. INTRODUCTION", "content": "Quantum computing [20], [41] is an emerging computational paradigm, which has a potential to transform many industries, including optimization [18], machine learning [47], quantum chemistry and material science [2], [3]. A quantum computer comprises quantum bits (qubits) that share quantum edges with each other. Quantum computers perform computation by applying quantum operations (gates) to qubits, akin to classical Boolean circuits. Such quantum gates operate on pairs of qubits, creating correlation in their states. This phenomenon, called entanglement, constitutes the underlying potential advantage of quantum computing.\nHowever, quantum computers face a key challenge in applying quantum gates. Due to physical constraints, quantum gates can only be applied to adjacent pairs of qubits on a quantum computer. In general, quantum computers do not have all-to-all connectivity. As a result, transforming high-level abstract quantum programs (logical circuits) into hardware executable quantum circuits (physical circuits) that satisfy the connectivity constraints is necessary to run quantum programs. Quantum routers hence become a necessary component to tackle the challenge. To accommodate the sparse qubit connectivity in quantum computers, routers must move pairs of remote logical qubits to adjacent physical qubits, so that they can be executed on a quantum computer. To generate physical circuits that comply with specific topologies, routers utilize specialized quantum operations known as SWAP gates. These gates are applied to adjacent pairs of physical qubits to exchange the positions of the corresponding pair of logical qubits, effectively swapping their locations.\nUnfortunately, SWAP insertion is very costly. Quantum operations are inherently non-perfect and error-prone [22]. SWAPs introduce significantly more error to quantum programs, destroys accurate quantum data and makes quantum program outputs wrong. As a result, optimizing routers to minimize their added SWAP overhead is crucial for advancing quantum computing efficiency [38].\nMinimizing SWAP gates in quantum programs is crucial but challenging, as it parallels the token swapping problem [56], recognized as at least NP-hard [12]. Currently, there are two primary approaches to the circuit routing problem: satisfiability solver-based routing algorithms [33] and heuristics-based routing algorithms [1], [12], [24]. However, solver-based algorithms achieve optimal SWAP numbers but suffer from exponential time complexity with more qubits and quantum gates. On the other hand, heuristic routers generally produce a suboptimal solution with a high SWAP overhead. In contrast, machine learning methods for circuit routing problem allow to balance the solution quality and the runtime.\nInstead, quantum circuit routing can be formulated as a sequential decision-making process by employing RL-based methods. Given the recent impressive results of Deep RL [4], [15]\u2013[17], [19], [26], [30], [34], [37], [48], [49], adapting Deep RL frameworks to this problem offers several advantages. Firstly, an RL-based router can adapt to different benchmarks and quantum computer topologies through re-training or fine-tuning, eliminating the need for manual algorithm redesign. Secondly, RL agent models, particularly those utilizing transformers [55], are adept at handling longer input sequences. This capability enhances their potential to achieve better optimization results, thereby significantly improving the efficiency of RL-based routing over traditional heuristic methods.\nWe developed an RL-based quantum circuit router, called AlphaRouter. AlphaRouter is inspired by AlphaZero [48], where it combines MCTS [11], [27] and RL [51]. MCTS excels in exploring a vast space of possible actions and outcomes, enhancing decision-making by balancing exploration and exploitation. Meanwhile, RL contributes by learning from the outcomes of these explorations, continuously improving strategy over time. This synergy allows for more sophisticated and globally optimized quantum compilation solutions. Our contributions hence include:\n1) SWAP reduction: To the best of our knowledge, AlphaRouter is the first to integrate MCTS and RL to optimize for extended circuit sequences, in contrast against traditional methods that focus on single-layer local search. This enables AlphaRouter to reduce the number of SWAP gates by 10 \u2013 20% over state-of-the-art routers.\n2) Unseen Benchmark: AlphaRouter demonstrates robust performance and generalization ability across benchmarks, achieving consistent compilation results even for previously unseen benchmarks.\n3) Scalability AlphaRouter exhibits scalable compilation efficiency, evidenced by a 15% reduction in the linear scaling coefficient for the number of SWAPs as benchmark sizes increase, while retaining a low inference time."}, {"title": "II. BACKGROUND", "content": "Figure 1a shows an example 5-qubit logical circuit visualized as a Directed Acyclic Graph (DAG). Logical quantum gates could apply to any pair of logical qubits. Each logical qubit goes through one or more quantum gates to evolve its quantum state. This is analogues to the classical computing process of applying operations to data stored in registers.\nFigure 1b shows the topology and qubit mapping of a ring quantum computer with a trivial initial mapping, i.e. logical qubit $l_i$ is mapped to physical qubit $p_i$, $\\forall i \\in \\{0,...,4\\}$. Given the logical circuit and the quantum computer mapping, $g_0$ cannot be scheduled since the corresponding physical qubits of $l_0$ and $l_2$ $p_0$ and $p_2$ are not adjacent on the quantum computer. $g_1$ cannot be scheduled for the same reason. In addition, $g_2$ and $g_3$ must wait for $g_1$ to execute first because of data dependency. Instead, inserting a SWAP between $p_1$ and $p_2$ brings pairs of logical qubits $(l_0,l_2)$ and $(l_1,l_3)$ adjacent on the quantum computer. Figure 1c hence shows that both gates $g_0$ and $g_1$ can now be scheduled into the output physical circuit.\nFigure 1d shows the remaining logical circuit after the first SWAP. Since the logical qubit targets of $g_2$ and $g_3$ are not adjacent on the quantum computer, they require an additional SWAP between $p_3$ and $p_4$, as shown in Figure 1e. Consequently, Figure 1f shows that a second SWAP between $p_3$ and $p_4$ brings logical qubits $(l_1,l_4)$ adjacent on the quantum computer, thus enabling $g_2$. With its dependence on $g_2$ fulfilled, $g_3$ is also scheduled, hence completing the routing process.\nRouting strategically inserts SWAPs to reposition logical qubits on a quantum computer so that they become adjacent to execute the required logical gates. A SWAP could be applied to any physical edge on a quantum computer, exchanging the position of the two logical qubits. This process is guided by the quantum computer topology, the current qubit mapping and the remaining sequence of logical gates. Routing carries out a sequential decision making process to apply a SWAP gate and schedule all possible logical gates, given the current state. The routing process terminates once all the logical gates from the input circuit are successfully scheduled into the output physical circuit.\nExisting quantum circuit routing methods [12], [32], [38] adopt local search that only considers the first few gates from the front layer of the circuit, leading to suboptimal routing quality.", "subsections": [{"title": "B. Reinforcement Learning", "content": "In Reinforcement learning (RL), an agent learns to make decisions by interacting with an environment [51]. It involves the agent taking actions in the environment and receiving feedback in the form of rewards. Markov Decision Process (MDP) [43] is a mathematical framework commonly used to model and formalize RL problems. An MDP is defined by a tuple $(S, A, T, r, \\mu_0, \\gamma)$, where $S$ denotes the state space and $A$ is the action space, the function $T : S\\times A\\times S \\rightarrow \\mathbb{R}_+$ encodes the transition probabilities of the MDP, $\\mu_0$ denotes the initial state distribution, $r(s, a)$ is the instantaneous reward obtained by taking action $a \\in A$ in state $s \\in S$, and $\\gamma\\in [0,1]$ is a discount factor for future rewards. The goal of RL is to find a policy, which is a mapping from states to actions $f : S \\rightarrow A$ , that maximizes the cumulative expected reward over time.\nFigure 2 visualizes the standard RL framework. An agent, usually in the form of a neural network, interacts with an environment by taking actions $a_t$ based on the current state $s_t$. Each action then leads to a new state $s_{t+1}$ and produces a reward $r_t$, guiding the agent to learn optimal behaviors through trial and error to maximize cumulative rewards.\nGiven the sequential nature of quantum circuit routing, RL can be an effective tool for finding optimal routing. Section III details the formalization of quantum circuit routing, framing it as an MDP planning problem, and demonstrates how RL can efficiently and adaptively optimize the process."}, {"title": "C. Monte Carlo Tree Search", "content": "MCTS [11] is a search algorithm that progressively builds a search tree by exploring and evaluating potential moves, while focusing on exploring the high value regions. MCTS does not require supervision, but generates values for states iteratively.\nFigure 3 shows the four stages in an MCTS cycle. An MCTS search tree consists of nodes corresponding to states $s$. In addition, each node stores statistics such as the number of visits $N(s)$ and the Monte Carlo valule estimation $Q(s)."}]}, {"title": "III. PROBLEM STATEMENT", "content": "Finding the minimum number of SWAPs to route a logical quantum circuit to a quantum computer can be modeled as an MDP. AlphaRouter focuses training a routing agent for a given quantum computer topology, i.e. with fixed number of qubits and connectivity. A quantum computer is modeled as a set of edges $E = \\{e : p_i,p_j\\}$, where $P = \\{p_i\\}$ represents the physical qubits. Similarly, $L = \\{l_j\\}$ represents the logical qubits in an input quantum circuit.\nThe state space for circuit routing $s_t$ comprises of the remaining logical circuit to be routed and the current qubit mapping. The state space is infinite as there are infinitely many logical cirucits. A logical quantum circuit is expressed as logical gates $G_t = \\{g : l_{g,1},l_{g,2}\\}$, where $l_{g,1}$ and $l_{g,2}$ represent the two logical qubits of a gate $g$. The qubit mapping is a bijective mapping between physical and logical qubits $M_t : P \\leftrightarrow L$.\nThe action space is limited as there are $|E|$ possible SWAPs to insert, one for every quantum computer edge. A SWAP action $A_t$ on edge $\\{p_i, p_j\\}$ exchanges the qubit mapping from $p_i, p_j \\leftrightarrow l_i,l_j$ to $p_i, p_j \\leftrightarrow l_j, l_i$ and updates the mapping $M_t$ to $M_{t+1}$.\nIn addition, gates are sequentially checked for topology compliance and pending dependence on other gates. $g \\in G_t$ satisfying the following conditions are scheduled and removed from $G_t$: (i) $l_{g,1},l_{g,2}$ are adjacent on the quantum computer after the SWAP, i.e. $(M_{t+1}(l_{g,1}), M_{t+1}(l_{g,2})) \\in E$ and (ii) $l_{g,1},l_{g,2}$ have no other pending gates in $G_t$ preceding $g$ that had not been removed in the current time step.\nThe circuit routing problem is hence framed as: Route an input logical quantum circuit $G_0$ to a quantum computer backend $E$ with an initial mapping $M_0$. Find the shortest sequence of actions $\\{s_t, A_t, s_{t+1}\\}_{t=0}^{T-1}$ such that $|G_T| = 0$."}, {"title": "IV. FRAMEWORK", "content": "AlphaRouter combines both RL and MCTS to autonomously train a RL agent to predict the best placement of SWAPs given a logical quantum circuit and a quantum computer."}, {"title": "A. Training", "content": "Our training approach, inspired by AlphaZero, enables autonomous label generation and more efficient exploration for RL via MCTS. Figure 4 visualizes the overall training framework. The environment comprises both the remaining logical circuit to be routed and the current qubit mapping to produce a state observation $s_t$. Section IV-C details the state encoding. In addition, we limit the remaining logical circuit lookahead to be up to 48 logical gates. A transformer-based agent predicts the next SWAP action $A_t$ by feeding the state $s_t$ through its network as shown in Figure 6. A chosen SWAP action is then applied to advance the environment state.\nA replay buffer stores the state experiences $s_t$ and passes a randomly sampled experience batch $\\{s\\}$ to MCTS. MCTS undergoes its value update process in Section II-C for the sampled batch for 200 iterations (rollouts). Rewards $r_t$ are defined to be the number of additional gates scheduled by applying action $A_t$, minus a penalty of incurring one extra SWAP:\n$r_t = |G_t| - |G_{t+1}| - 1$ (2)\nNote that $r_t = -1$ if a SWAP fails to schedule any logical gates at time step $t$.\nMCTS then outputs its action prediction for the sampled states $s' \\in \\{s\\}$.\n$a_{MCTS} = \\arg \\max_{a} Q_{MCTS}(f(s', a))$ (3)"}, {"title": "B. Routing as Inference", "content": "After completing its training, the RL agent employs a standard iterative inference process to perform circuit routing. Figure 5 illustrates AlphaRouter's use of a trained agent for routing via model inference. The RL agent receives an encoded state $s_t$ comprising the remaining logical circuit and current qubit mapping. Based on this, it then predicts and applies the next SWAP action $A_t$ to adjust the qubit mapping. Any logical gates that now satisfy the topology are greedily scheduled. The iteration terminates when the input logical circuit has been fully routed.\nIn the standard AlphaZero [48] implementation, MCTS is utilized alongside the trained agent during the inference phase for additional refinement of predictions. However, this integrated approach tends to be slower compared to using the trained agent alone.\nAlphaRouter, having demonstrated performance improve-ments over existing methods, enables us to omit the use of MCTS during inference to achieve a much faster runtime. Our experiments show that excluding MCTS from the in-ference process significantly improves the runtime without compromising the routing performance. This enhancement in runtime is crucial for quantum computing, particularly because numerous quantum algorithms, such as variational quantum algorithms, necessitate the execution of thousands of distinct circuits to tackle benchmark problems. For context, the operational timeframe for executing a quantum circuit on a quantum processor is typically within the microsecond range. Consequently, the time taken for compilation can quickly emerge as a significant bottleneck in the standard workflow of quantum computing."}, {"title": "C. Agent Network", "content": "Figure 6 depicts the state encoding, beginning with the logical circuit DAG. In this DAG, each quantum gate is represented by its two qubits and a depth based on its topological order. For example, $g_0$ has physical qubit targets of $M_t(l_0)$ and $M_t(l_2)$ based on the mapping $M$. In addition, since $g_0$ does not depend on any other gates, it has a depth of 1. $g_2$ has direct dependency on $g_1$ and hence have depth of 2. Eventually, $g_3$ has depth of 3 as it depends on $g_2$.\nAlphaRouter observes the first few logical gates to limit the lookahead depth with a max number set at 48. Each gate vector then embeds its two physical qubit targets with a trainable lookup table. Each gate vector is subsequently represented as the mean of the two qubit embeddings, together with an extra dimension of depth. Overall, the node embedding process produces a feature matrix of shape Lookahead Length \u00d7 (Embedding Dimension + 1).\nFinally, this matrix is fed into a transformer-based actor-critic [29] network for encoding and decoding, yielding predictions including both SWAP action values and a state value. Figure 7 shows the transformer network architecture. AlphaRouter employs a 4-layer, 6-head transformer encoder architecture, starting with the embedded input shown in Figure 6.\nEach layer comprises two main components: multi-head attention and a feed-forward network, both followed by an \"Add & Norm\" step for residual connections and layer normalization. The multi-head attention, with 6 attention heads, allows the model to focus on different parts of the input sequence simulta-neously, enhancing its ability to capture complex dependencies. This is because self-attention enables each gate to interact with every other gate in the circuit, assessing their relationships and the overall sequence. Such an approach captures not only the individual qubit connections of each gate but also how gates influence one another across the circuit. This nuanced understanding of both local and global gate interactions is crucial for identifying optimal routing paths, as it mirrors the inherently interconnected nature of quantum computations, where the placement and order of gates significantly impact the best routing sequence. This structure repeats across all 4 layers, enabling the encoder to process and transform the input into a high-level, contextually enriched representation. A final linear layer serves as the decoder and outputs the action and state value predictions.\nTable I summarizes AlphaRouter's Tranformer model archi-tecture and hyperparameters.\nThe embedded input is first combined with positional encoding to retain sequence information. The Transformer architecture lacks inherent positional information in its structure because it processes input sequences as sets of elements without considering the order of these elements. To address this, Transformers often incorporate positional encodings [55] to provide the model with information about the position of each element in the sequence.\nPositional encoding involves alternating sine and cosine functions that depend on the position of a quantum gate in the input sequence and the embedding dimension. This positional information is crucial for quantum circuit routing as the order of quantum gates carries physical meaning. Equations 7 shows the sinusoidal wave functions.\n$PE(pos, 2i) = sin(pos/10000^{2i/d})$\n$PE(pos, 2i + 1) = cos(pos/10000^{2i/d})$ (7)"}, {"title": "D. Overall Algorithm", "content": "Algorithm 1 shows the overall training algorithm. The algo-rithm box uses the same notations as Section III. AlphaRouter uses the Adam optimizer [25] to train its transformer network."}, {"title": "V. EXPERIMENT SETTINGS", "content": "We train and test the performance of AlphaRouter on various quantum computers include (i) Tokyo, an IBM quantum computer with 12 qubits arranged in a 3 \u00d7 4 grid; (ii) OQC, an Oxford Quantum Circuits quantum computer with 8 qubits arranged in a circle; and (iii) Guadalupe, an IBM quantum computer with 16 qubits in a heavy hexagon topology [9].\nThe training was performed using AWS SageMaker cloud service. The training runs for 100 episodes on Random benchmarks for all quantum computer topologies."}, {"title": "A. Quantum Computer Backends", "content": "We train and test the performance of AlphaRouter on various quantum computers include (i) Tokyo, an IBM quantum computer with 12 qubits arranged in a 3 \u00d7 4 grid; (ii) OQC, an Oxford Quantum Circuits quantum computer with 8 qubits arranged in a circle; and (iii) Guadalupe, an IBM quantum computer with 16 qubits in a heavy hexagon topology [9].\nThe training was performed using AWS SageMaker cloud service. The training runs for 100 episodes on Random benchmarks for all quantum computer topologies."}, {"title": "B. Initial Mapping", "content": "We employ two distinct strategies for initial qubit mapping: (i) trivial and (ii) random. The trivial initial mapping simply assigns the logical qubits in a numerical order to the physical qubits, i.e. $p_i = l_i$. On the other hand, random initial mapping introduces variability by randomly assigning qubits. AlphaRouter is designed to solve only the circuit routing problem for a given initial mapping. In the future it is viable to extend our approach to simultaneously solve both routing and initial mapping problems using the same RL model. One possible approach is to consider the initial mapping as a sequence of virtual SWAPs in the beginning of the routing."}, {"title": "C. Benchmarks", "content": "The benchmarks listed below are among the most commonly used quantum circuit types. We sample random circuit instances from each circuit class and compute the average SWAP count."}, {"title": "D. Baseline Routers", "content": "We use various Qiskit routers as the baseline comparisons. These are some of the most commonly used heuristics routers. Specifically, Basic is a greedy strategy that finds the shortest path to implement quantum gates sequentially. Stochastic is a randomized algorithm that performs multiple trials for SWAP insertion in each circuit layer. SABRE [32] is the state-of-the-art heuristics router. It performs a bi-directional search and uses a custom objective function, that takes into account SWAPs both in the front layer and the last layer in the circuit."}, {"title": "VI. RESULTS", "content": "We designed 4 experiments to test a specific aspect of the RL compiler, while keeping the other factors constant."}, {"title": "A. Generalizing to Unseen Benchmarks", "content": "AlphaRouter was trained on the Regular benchmark and tested on a variety of benchmarks listed in Section V-C. Figure 8 compares the total number of SWAPs by AlphaRouter and Qiskit baseline routers. On average, the RL agent outperforms the baseline compilers for the majority of the benchmarks. Specifically, RL reduces the SWAP counts by 10 - 20% over the best baseline compiler in SABRE even for previously un-seen benchmarks."}, {"title": "B. Scaling to Larger Benchmarks", "content": "Given a fixed benchmark type and a quantum computer topology, the number of SWAPs is expected to increase linearly with the length of the benchmark. However, this linear growth varies across different routers, indicating their routing efficiency. We route Random benchmarks with an increasing number of gates on the Tokyo quantum computer using random initial mapping. Figure 9 shows that AlphaRouter has better scaling (lower linear coefficient \u03b1 calculated by linear regression), compared to the baseline Qiskit routers by approximately 15%."}, {"title": "C. Adapting to Different Quantum Computers", "content": "Quantum circuit routers must be able to adapt to different quantum computers. We train AlphaRouter on IBM Tokyo (12q), IBM Guadalupe (16q), and OQC (8q) quantum com-puters with Random benchmark and test its performance on all benchmarks. Figure 10 shows the ratio of SWAPs of AlphaRouter versus SABRE. AlphaRouter excels on Tokyo and Guadalupe quantum computers, achieving 10 \u2013 20% SWAP reduction for most benchmarks. Its performance comes close to SABRE on the OQC quantum computer. This is because OQC is a smaller quantum computer and has less room for improvement by RL."}, {"title": "D. Improving Initial Mapping", "content": "The SABRE router utilizes a bidirectional mapping technique to optimize initial qubit mapping. It starts with a forward pass to establish an initial mapping of logical to physical qubits, followed by a backward pass that refines this mapping using the complete circuit layout [32].\nWhile AlphaRouter only solves SWAPs, it could integrate the bidirectional mapping technique to improve its routing overhead. Experiments in Figure 11 compare the AlphaRouter SWAP counts with and without the bidirectional mapping pass. Notably, incorporating bidirectional initial mapping reduces 40% SWAPs on average across all benchmarks for the Tokyo quantum computer."}, {"title": "VII. RELATED WORK", "content": "Graph routing problems are well known problem in computer science and operations research [31]. Graph routing problems can be solved by using provable algorithms with exponential runtime in the worst case, heuristics based on mixed integer programming, or by employing a combination of planning and deep reinforcement learning methods [5], [7], [14], [35], [40], [45]. Routing problems are inherently classical and are not specific to quantum computing.\nIt is widely recognized that even state-of-the-art quantum routers suffer from a significant optimality gap in SWAP count [52]. [42] have implemented a Q-learning based RL approach for quantum circuit routing, utilizing a standard setup comprising an environment and an agent. [50] adopted a structure combining MCTS and RL, but their optimization focuses solely on a single layer of gates. In contrast, [58] employed MCTS without integrating RL, offering a different perspective on quantum circuit optimization. It is important to note, that [42], [50] focused on optimization of the circuit depth which defined the RL reward function, rather than optimizing the SWAP count overhead. Minimizing SWAP count is the most important metric for the efficient utilization of quantum computers rather than the gate depth. Each of these works contributes uniquely to the evolving landscape of quantum circuit compilation methodologies. In addition, several heuristic-based compilers [12], [32], [39] perform local optimizations but lack the scalability to perform global searches."}, {"title": "VIII. CONCLUSION", "content": "In this paper, we incorporate RL and MCTS to develop a quantum circuit router, distinctively free from arbitrary heuristic routing rules. Our approach not only exhibited 10 20% SWAP reduction over existing routers but also demonstrated remarkable abilities in benchmark generalization and scalability. Our pioneering work in integrating MCTS with RL for quantum circuit routing highlights the transformative potential of combining RL and MCTS for complex optimization tasks, advancing the development and practicality of quantum computing."}]}