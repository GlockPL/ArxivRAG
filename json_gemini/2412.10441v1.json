{"title": "Novel 3D Binary Indexed Tree for Volume Computation of 3D Reconstructed Models from Volumetric Data", "authors": ["Quoc-Bao Nguyen-Le", "Tuan-Hy Le", "Anh-Triet Do"], "abstract": "In the burgeoning field of medical imaging, precise computation of 3D volume holds a significant importance for subsequent qualitative analysis of 3D reconstructed objects. Combining multivariate calculus, marching cube algorithm, and binary indexed tree data structure, we developed an algorithm for efficient computation of intrinsic volume of any volumetric data recovered from computed tomography (CT) or magnetic resonance (MR). We proposed the 30 configurations of volume values based on the polygonal mesh generation method. Our algorithm processes the data in scan-line order simultaneously with reconstruction algorithm to create a Fenwick tree, ensuring query time much faster and assisting users' edition of slicing or transforming model. We tested the algorithm's accuracy on simple 3D objects (e.g., sphere, cylinder) to complicated structures (e.g., lungs, cardiac chambers). The result deviated within \u00b10.004cm\u00b3 and there is still room for further improvement.", "sections": [{"title": "1 Introduction", "content": "This research is one pivotal component in our larger research project \"Integration of Deep Learning into automatic cardiovascular dissection and reconstruction in simulated 3D space for medical practice\". Therefore, this research is mostly focused on medical volumetric data, especially human cardiac CT scans. In the contemporary landscape of medical imaging, the conversion of tomographic data into precise three-dimensional (3D) models stands as a burgeoning trend of paramount importance. Since three-dimensional surfaces of anatomy offer a valuable medical tool. The 3D representation helps physicians/radiologists with better interpretation of volumetric data [1]. The evolution in 3D medical imaging necessitates robust post-processing methodologies to ensure the meticulous measurement and analysis of these intricate 3D structures with utmost accuracy and efficiency [2]. Of particular significance is the quantification of various parameters within the cardiovascular system, including but not limited to the diameter, area, and volume of critical structures such as the aortic duct. These metrics serve as crucial indicators for pathologies such as hypertrophy or stenosis, which pose significant risks to patient well-being. Consequently, the accurate assessment and preoperative planning facilitated by such analyses substantially enhance the clinical efficacy and safety of surgical interventions. While existing software proficiently translates medical tomographic data into comprehensive 3D representations, the capability to perform volumetric"}, {"title": "1.1 Data flow in algorithms", "content": "3D medical image reconstruction consists of 6 steps. The last feature is optional since it depends on the software application offering user advanced operations. Our software system starts from the second step to the last one. The post processing in consists of many advanced functions for radiologists to control 3D objects both on computer and in vritual reality environment.\n- Data Acquisition \u2192 Image Processing \u2192 Segmentation \u2192 3D Reconstruction \u2192 Rendering & display \u2192 Post processing"}, {"title": "2 Related works", "content": "Researchers have reported the application of 3D medical images in a variety of areas. The visualization of complex acetabular fractures, craniofacial abnormalities, and intracranial structure illustrate 3D's potential for the study of complex bone structures. Applications in radiation therapy and surgical planning interactive 3D techniques combined with 3D surface images. Cardiac applications include artery visualization and non-graphic modeling applications to calculate surface area and volume. There is non-graphic modeling applications to calculate the surface area and volume of cardiac models in 1985 [3].\nThe Marching Cubes algorithm, proposed by Lorensen in 1987, is commonly used for 3D mesh reconstruction from CT scans. However, it has limitations due to a small lookup table. To address this, Lewiner [4] proposed an improved version with an extended lookup table, resolving the \"cracks\" issue. This development requires efficient automatic post analysis, especially measuring important parameters such as volume, surface area, curvature. [5] presents a system to measure limb volumes using 3D models from an infrared depth sensor. However, this method does not leverage advanced computed imaging (CT, MR) and may be affected by environmental factors. Intrinsic volume measurement techniques directly from digital 3D images have been explored [2], but their computational complexity remains a challenge."}, {"title": "3 Methodology", "content": "Since our main application is in medical imaging, especially cardiac volumetric data, we only focus practical experiment and analysis in this specific field."}, {"title": "3.1 Integral of surface functions", "content": "We can determine whether the arterial duct is hypertrophied by comparing its volume to standard parameters. We intersect the aorta with two planes (P), (Q) using a symmetric ray Casting method. The limits a, b on the Ox axis of an object are (x = a, x = b, a < b). A plane perpendicular to the Ox axis at point x and $a \\leq x \\leq b$ intersects the object with a cross-sectional area of S(x) and the equation S(x) is continuous on the interval [a; b]. Thus, the volume of the upper heart chamber is calculated by the following integral formula:\n$V = \\int_a^b S(x)dx$\nFor a set of n slice images, we have $S_i$ as the area of the ith slice (1 \u2264 i \u2264 n). Approximating a function S(x) is not straightforward. We can use the Lagrange interpolation method. However, this approach has many limitations. Firstly, the approximation is only accurate if $n \\rightarrow \\infty$ to ensure accuracy. This is practically infeasible because the number of slices n is usually not large enough (300 \u2192 512) and is limited. Secondly, approximating a function is also a complex task, increasing algorithm's processing time."}, {"title": "3.2 Inclusion and exclusion principle", "content": "Double integral problem is an combination of multiple single integral problems. Initially, we divide the curved surface $z = f(x, y)$ into surfaces $S_j, S_{j+1},...,S_m$ corresponding to each $y_j, y_{j+1},...,y_m$ where each surface $S_i$ with fixed $y_j$ represents a single integral problem. Finally, we sum up these surfaces $S_i$ to calculate the volume V:\n$V = \\iint_D f(x, y) dx dy$\n$D = \\begin{cases} a\\leq x \\leq b \\\\ c\\leq y \\leq d \\end{cases}$\n$V = \\int_c^d (\\int_a^b f(x, y) dx) dy = \\int_c^d dy \\int_a^b f(x,y) dx$\nWith inclusion and exclusion principal, we can measure the volume of predetermined structure. For example, When calculating the volume of the aortic arch, we divide this vessel into two parts: the upper half 01 and the lower half 02 so the domain D remains the same. The volume of the inner part will be $V = V_{01} - V_{02}$ :\n$V_o = V_{o_1} - V_{o_2}$\n$V_o = \\lim_{\\Delta x, \\Delta y j \\rightarrow 0} \\sum_{j=c}^{Vo_{o_1}} \\sum_{i=a}^{Vo_{o_2}} (x_i^i - (x_i^i)) \\Delta x_i | \\Delta y_j$\nGiven a list of (x, y, z) vertices, the implementation of this approach computed the volume of tube structures accurately. However, we have to find a midsection to divide the object into two parts. Additionally, current software systems allows radiologists to perform surgical operations (e.g. slicing) or modifies the segmentation result leading to changes in the 3D reconstructed polygonal mesh, so algorithm must reprocess again. If denoting Q as the times of slicing or updating operation is performed, the time complexity will be O(Q\u00d7(M\u00d7N+S)), where S represents the complexity of finding midsection path. This issue can be optimized with triple integral combined with binary indexed tree."}, {"title": "3.3 Triple integral", "content": "The concept of triple integration originates from dividing the object volume O into n very small rectangular prisms or cubes $O_i$ with lengths, widths, and heights denoted as dx, dy, dz respectively. Approximating the volume of the original object is straightforward by summing the volumes of all $O_i$ with $1 \\leq i \\leq n$ and as $n \\rightarrow +\\infty$:\n$V = \\lim_{n \\rightarrow +\\infty} \\sum_{i=1}^n \\Delta z_i \\Delta y_i \\Delta x_i$\nThe above formula shows that each cube is processed in three loops of three dimension x, y, z, which is comprehensively compatible with the marching algorithm. Therefore we integrate the approximation idea of triple integral into marching cubes algorithm and store the calculated data into 3D binary indexed tree."}, {"title": "3.4 Volume configurations in Marching Cubes algorithm", "content": "Marching cubes uses a divide-and-conquer approach to locate the surface in a logical cube created from eight pixels; four each from two adjacent slices [1]. In three dimensional space, the relationship between a cube and the 3D model falls into three cases: the cube is totally inside the model, partly intersected by the surface model, or totally located outside the model. The surface can intersect the cube in $2^8 = 256$ cases since a cubes has 8 vertices in total (this can be proved by generation method).\nHowever, [1] reduced the problem from 256 cases to 14 patterns by utilizing symmetrical property, rotational symmetry. From original 3D array, the algorithm create the boolean 3D array with the same size speculating that a vertex is false if locates inside the model and vice versa. Therefore, the volume of the model within a cube is limited from the mesh generated to all False vertices. Although the topologically triangulated mesh is unchanged when performing rotation or symmetrical operations, the volume is changed. Specifically, the volume of case j is equal to 1-Vi with j is the reversed case of i. Finally, we have up to 28 cases of volume plus 2 cases (all vertices are either False or True), which totally is 30 cases. The specified volume of each 30 cases is presented in table 1.\nThe volume is each case easily calculated by dividing the 3D shape into simple shapes such as tetrahedron, prism,... The formulas are:\n$V_{tetrahedron} = \\frac{1}{3}hS_{base}$\n$V_{prism} = hS_{base}$\nWith more complicated reconstructed mesh, we assigned coordinates to the cubes and use vectors operations (e.g. dot-product, cross-product). For example, given 4 points \u0410($\u0425_\u0410, \u0423_\u0410, 2_\u0410$), \u0412($\u0445_B, Y_B, Z_B$), C($xc, YC, ZC$), D($XD,YD, ZD$), we have:\n$V_{ABCD} = \\frac{1}{6} |AB \\times AC|\\cdot AD$\nHowever the Marching Cube method proposed by [1] has limitations. The algorithm can lead to cracks because the same configuration can be tiled in different ways [4]. Lewiner optimized the algorithm by considering more cases (32 base cases instead of 15). However, in our research scope, we only speculate the volume based on Lorensen's lookup table to estimate the practicability of our assumption before further improvement with Lewiner's extended one.\nThe vertex with bold black dot is the false one, which means this vertex possesses value below the threshold level and is totally inside the 3D reconstructed polygonal mesh. The volume of the model within each cube need considering is highlighted from the initial 15 base cases to next 15 reversed cases with calculation formulas, explanation, and results provided simultaneously. Specially, in the last 5 cases (four False vertices and four True vertices), although not only the topological mesh configuration but also the vertices relative position remain unchanged while being reversed, the intrinsic volume essentially changes. Therefore when speculating volume configurations for 256 cases (for fast query), we use the vertex\u2081(x, y, z) as pivot to classify case 26, 27, 28, 29, 30 from case 11, 12, 13, 14, 15.\nConsidering implementation, supposing the volumetric data named is specified in size (N, M, P), we initialize a 3D array named Cube of size (N - 1, \u041c \u2013 1, \u0420 \u2013 1). We take the vertex(x, y, z) as pivot to manage the whole cube or 7 last other vertices (x + 1, y, z), . . ., (x +\n1,y + 1,z + 1). Therefore, Cube[i, j, k] = VolumeLookup(i, j, k) with i < N \u2212 1, j \u2264 M -\n1, k < P-1 and VolumeLookup returns the volume based on above 30 cases.\nFinally, we can sum up all the value in this 3D array to get the total volume of our 3D object. However, this way of storing calculation results is not suitable when updates (e.g slicing, mesh edition) occur. The time complexity is O(Q \u00d7 N \u00d7 M \u00d7 P) with Q is the number of update events."}, {"title": "3.5 Binary indexed tree", "content": "The Binary indexed tree (BIT), also Fenwick Tree, is a widely used data structure in competitive programming, introduced in the research paper \"A new data structure for cumulative frequency tables\u201d by Peter M. Fenwick [6]. The BIT exhibits the following characteristics: querying the result of a subproblem in O(logN), updating the value for one element in O(logN), or a segment in O(NlogN), low memory usage O(N), and fast processing speed (due to bitwise operations). In detail, with each update operation, the last bit is always shifted up at least 1 time, leading to the maximum of logN times of bit shifts.\nIn BIT, the element ith stores the result F[i] of the subproblem containing 2k elements starting/ending at position i, where k is the lowest set bit in the binary representation of i. Observing the representation of the tree above, we can easily see that nodes with odd indices manage only themselves, while nodes with index id will have a parent with index id + 2k. Finding the value of 2k is simply done by performing the bitwise operation: $2^k = -id&id$."}, {"title": "3.5.1 3D Binary indexed tree", "content": "This is a novel application of binary indexed trees into three-dimensional arrays. We employ the principle of inclusion and exclusion to query the sum of elements over a 3D space by excluding surrounding parts, similar to slicing but without data loss). We can perform updates on a 3D space (altering the mesh reconstruction) with minimal complexity of O(logNlogMlogP), where (N, M, P) represent the dimensions of volumetric data. The formula of 3D query is:\nQ(x1, y1, z1, x2, y2, z2) = S(x2, y2, z2)\n-S(x2, y2, z1 \u2013 1) \u2013 S(x2, y1 \u2013 1, z2)\n+S(x2, y1 \u2013 1, z1 \u2212 1) \u2212 S(x1 \u2013 1, y2, z2)\n+S(x1 \u2013 1, y2, z1 \u2212 1) + S(x1 \u2013 1, y1 \u2013 1, z2)\n-S(x1 \u2013 1, y1 \u2013 1, z1 \u2212 1)\nQ, S represent the QueryByRegion and getSum function respectively in the implementation code. In the marching cubes three loops instead of storing data into 3D array Cube, we build cumulatively the BIT by calling update function as BIT[i,j,k] = update(i, j, k, value) with value is the VolumeLookup(i, j, k).\nYou can find the open-source code published online on Github in the Open Source section."}, {"title": "4 Experiments", "content": ""}, {"title": "4.1 Setup experiments", "content": "We experimented our algorithm both on simple shape (sphere) with predetermined radius and complex 3D structure (cardiac model) with predetermined volume. The computed volume and labelled volume is represented in table 2. Also, we compare the time processing of BIT query with bruteforce method. Each case-is computed 5 times to ensure consistency. In medical imaging, especially dealing with volumetric data acquired from CT, MR. We have to consider the pixel spacing value, slick thickness for accurate unit conversion from pixel/voxel world into real world unit (mm3 or ml). We run the algorithm only with CPU."}, {"title": "4.2 Results and evaluation", "content": "Observing Table 2, the Brute Force (BF) computation time increases proportionally with the size of the volumetric data, highlighting its inefficiency for large datasets. In contrast, querying the BIT tree using a Cython implementation maintains a consistent query time of approximately 0.1s, regardless of the data size. The open-source code is available for verification, allowing you to confirm these results independently. Higher-resolution volumetric data enables more accurate approximations of calculated volumes, capturing finer details. For medical volumetric data, such as cardiac structures, the processing time includes both BIT initialization and the Marching Cubes algorithm. Our basic implementation of Marching Cubes contributes to the extended processing time."}, {"title": "4.3 Implementation", "content": "We implemented the Marching Cubes algorithm based on Lorensen's lookup table instead of Lewiner's. We initialized two lookup table volume configurations named VOLUME CASE LOOKUP of size 30 and VOLUME LOOKUP of size 256. We implemented the code with Cython, an efficient Python to C compiler, to optimize performance. This approach allowed us to efficiently handle the volume rendering process, ensuring accurate results while maintaining computational efficiency. We also published the pure Python code of the algorithm. However, the pure Python code should only be used for small-sized 3D arrays. For medical volumetric data, especially high-resolution ones, it's recommended to utilize the C/C++ implementation or use Cython."}, {"title": "5 Conclusion and Future Work", "content": "This study focuses on developing an efficient algorithm for computing the intrinsic volume of 3D structures reconstructed from volumetric data, particularly in the context of medical imaging. The goal is to achieve real-time computation even in cases where the meshes or structures are distorted or sliced functionalities commonly required in medical analysis software. To maximize usability, the algorithm should be implemented as a plugin or developed in various low-level programming languages (e.g., C, Java, Assembly) and compiled into binary libraries for seamless integration with different graphical software."}]}