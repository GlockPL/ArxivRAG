{"title": "Qompose: A Technique to Select Optimal Algorithm- Specific Layout for Neutral Atom Quantum Architectures", "authors": ["Daniel Silver", "Tirthak Patel", "Devesh Tiwari"], "abstract": "As quantum computing architecture matures, it is important to investigate new technologies that lend unique advantages. In this work, we propose, Qompose, a neutral atom quantum computing framework for efficiently composing quantum circuits on 2-D topologies of neutral atoms. Qompose selects an efficient topology for any given circuit in order to optimize for length of execution through efficient parallelism and for overall fidelity. our extensive evaluation demonstrates the Qompose is effective for a large collection of randomly-generated quantum circuits and a range of real-world benchmarks including VQE, ISING, and QAOA.", "sections": [{"title": "1 INTRODUCTION", "content": "Quantum computing architectures are evolving rapidly - with multiple potential technologies (e.g., superconducting, ion-trap, neutral-atom, and photonics-based quantum computing) offering different design trade-offs [10, 11, 22, 26, 29]. Neutral-atom based quantum architecture is among the most promising and emerging quantum computing technology - compared to traditional superconducting and ion-trap technologies, neutral-atom based quantum architecture offers three key advantages: (a) lower cooling requirements, (2) longer coherence times and better scalability, and (3) flexibility to arrange the basic unit of computation (qubits) in an algorithm-specific manner. Physicists and material scientists are making significant strides toward maximizing the first two key advantages [16, 25] including the most notable experimental demonstrations using neutral atoms [9]. While the neutral atom hardware technology is maturing, its third benefit has received limited attention from the computer systems and architecture community.\nIn particular, it has been shown recently that neutral atoms can be arranged in different topologies and the quantum circuit can be mapped on the chosen topology to execute the quantum operations in the circuit [27]. Unfortunately, there is a limited understanding of this flexibility of atom arrangement that can be leveraged to execute different quantum algorithms more efficiently \u2013 for example, produce better answer quality in the presence of error, reduce the number of operations (i.e., physical laser pulses), etc. To explore this space, we performed a series of experiments. Our results (discussed in detail in Sec. 3) reveal that arrangement of atoms (topology) significantly affects the execution of different quantum algorithms. Different quantum algorithms may prefer different topologies of atoms - and, notably, as we show, these topologies are not necessarily very different or complex from each other, but their impact on the overall program execution is significant. Second, we also discovered that the preferred topology is also dependent on the figure of merit the user/system is trying to optimize (e.g., answer fidelity, pulse count, etc.) \u2013 the choice of optimization metric depends on various algorithms and system environment constraints in neutral atom-based quantum computing [27].\nTherefore, motivated by these experimental observations, the goal of this work is to demonstrate how different practically feasible and simple arrangements of neutral atoms can be leveraged to improve the overall execution of quantum circuits in an algorithm-specific way. However, we show, that this problem poses non-trivial challenges due to the inherent complexities of the neutral atom-based quantum computing architecture and execution of quantum circuits. One challenge is selecting a topology from the infinite space of possible topologies. Even when we scope the space to three practical topologies, (square, s-triangle, and t-traingle; details in Sec. 2), each topology offers its own unique advantages and disadvantages. However, selecting the most suitable topology among three related but unique topologies is a challenging task because it is not possible to know apriori the critical execution path of a quantum circuit and the degree of operation parallelism a quantum circuit can exploit when it mapped onto a specific topology.\nTherefore, we build a learning-based solution that determines the most effective topology of atoms for a given quantum algorithm. Some of the features used are quantum-specific (e.g., entanglement variance) and some are classical (e.g., page rank standard deviation). By leveraging a neural network, Qompose combines these quantum and classical features into a prediction model that can anticipate the best topology for a given circuit.\nContributions. This paper makes the following contributions:\nI. First, to the best of our knowledge, this is the first study to demonstrate that, under neutral atom-based quantum computing architecture, the arrangement of atoms (topology) significantly affects the execution and outcome of different quantum algorithms. A single topology (e.g., a traditionally used square topology of atoms) does not necessarily produce the highest answer quality for all quantum algorithms - in fact, even simple but slightly different topologies can produce significantly different answer qualities.\nII. Second, Qompose is the first solution that exploits this opportunity space and builds a learning-based solution that determines the most suitable topology of atoms for a given quantum algorithm from a set of practically-feasible and simple topologies. Qompose builds a new methodology, inspired by the page-rank algorithm [19], that identifies and encodes the properties of quantum circuits that are most critical toward learning and predicting the most suitable topology.\nIII. Finally, our evaluation demonstrates the Qompose is effective in selecting the best neutral-atom topology - for a large collection of randomly-generated quantum circuits and a range of real-world benchmarks including VQE, ISING, and QAOA. In particular, Qompose improves the pulse counts in the critical path by 8.4% and 5.4% for randomly-generated quantum circuits and real-world benchmarks over randomly selecting one of the topology options. Our extensive evaluation shows that Qompose almost always (except"}, {"title": "2 BACKGROUND", "content": "We organize this section into two subsections. We first begin by discussing general information regarding quantum computing, then discuss neutral atom quantum computing in more detail."}, {"title": "2.1 Quantum Computing Background", "content": "2.1.1 Quantum States. Analogous to the \"bit\" of the conventional computing world, which we will hereon refer to as classical computing, the quantum computing world has a building block known as a \"qubit\". A qubit is much more flexible then a bit as while a bit can only exist as a 1 or 0, a qubit may exist as a superposition of these states. This can be well-represented using Dirac notation $|\\Psi\\rangle = \\alpha |0\\rangle + \\beta |1\\rangle$ where a and \u03b2 are complex coefficients bound by $||\\alpha||^2 + ||\\beta||^2 = 1$ [17]. Similarly to how the general equation of a circle centered around the origin is defined as $x^2 + y^2 = r^2$, $||\\alpha||^2 + ||\\beta||^2 = 1$ can be expanded to be visualized as a point on a sphere with radius 1, known as the Bloch Sphere [23]. Additionally, while qubits may exist in a superposition, once they are measured, they probabilistic collapse to a classical state is defined by the complex coefficients of the states.\n2.1.2 Quantum Circuits. Quantum gates can be used to perform logical operations on qubit states. When many quantum gates are placed in sequence to perform desired logical operations, they are referred to as a quantum circuit. While any classical gate has a logical quantum equivalent gate, it must be in the form of a unitary matrix satisfying the condition $U^\\dagger U = I$, where $U^\\dagger$ where $U^\\dagger$ is defined as the complex conjugate transpose of U. Notably, this ensures full reversibility of all quantum circuits. These gates can be built for any number of qubits. An example of a 3-qubit quantum gate is the CCX gate: defined for 3 qubits a, b, and c: $CCX_{a,b,c} = |0\\rangle \\langle 0 | \\otimes II + |1\\rangle \\langle 1| \\otimes CX$, where CX is a two-qubit gate [2]."}, {"title": "2.2 Neutral Atom Quantum Computing", "content": "As practical quantum computing is only at its infancy, it is unclear which technologies will reign as the best standard [3]. Some of the many technologies currently being explored are superconducting qubits, ion traps, photonics, and neutral atom quantum computing [2]. Neutral atom quantum computing comes with many unique qualities that make it a promising technology for quantum computation. Specifically, neutral atom quantum computing allows for arbitrary arrangement of 2D topologies for qubit positioning [27], enabling incredible parallelizability of operations. In these systems, atoms are trapped through optical tweezer arrays, which can then be arranged into any shape where one atom acts as one qubit. The qubits states are based on the energy levels of the valence electrons (typically using Rubidium and Cesium atoms). These arrays have been shown to be loaded on a 100ms timescales on 1D [6] and 2D [4] topologies using the aforementioned tweezer method.\n2.2.1 Neutral Atom Manipulation. Different light pulses are used to excite electrons into states. Single qubit gates are excited using a Raman transition, requiring a single light pulse. Multi qubit gates require Rydberg transitions, which require multiple pulses and are used to perform actions between neighbors, while entangling them with one another.\n2.2.2 Restriction Zones. Rydberg interactions occur within a given radius and affect all atoms within the radius. These interactions entangle all qubits within the radius and effectively block any other operation using the same frequencies from taking place on those qubits at the same time. While these qubits are blocked however, any operation outside of the restriction zone can have the same pulses applied in parallel. Additionally, qubits undergoing operations of the same frequency within this zone are unaffected. For example, a particular qubit may be in a single qubit Raman interaction at the same time as it is undergoing a Rydberg interaction. This restriction zone behavior is visualized in Figure 1."}, {"title": "3 MOTIVATION FOR QOMPOSE", "content": "Quantum computing has the potential to enable exponential speedups over classical algorithms in many problem domains. To enable this, neutral atom quantum computing has many beneficial properties such as topological flexibility, operating at warmer temperatures [33], and long distance interactions [3], which could make it the most reasonable technology for many quantum computing tasks.\nSpecifically the ability to arrange the qubits in arbitrary positions can enable very high degrees of parallelism. By"}, {"title": "4 MODEL TRAINING", "content": "A high-level overview of all of the steps of Qompose is provided in Fig. 4. The design of Qompose is split into two primary main sections: (1) model training, and (2) topology inference and circuit execution. As a summary, the first step is training a neural network on quantum descriptors and page rank feature analysis to learn optimal topologies for reducing pulse count along the critical path, which is described in this section. As described in the following section (Sec. 5), once this model is trained, it is ready to run inference to predict the optimal topology for a given circuit. At this stage, the circuit is ready to be mapped to the topology by assigning logical qubits to physical hardware locations. Once mapping is complete, operations are scheduled and the circuit can be executed.\nQompose learns to anticipate the best topology for a set of quantum instructions to be performed. This model is trained by running multiple circuits with different parameters and learning the patterns of instruction sets that lend to unique best topologies for the total execution time of the circuit. Next, we describe how the predictive model is constructed and trained."}, {"title": "4.1 Building the Model", "content": "Qompose analyzes many static features on our random circuits in order to train the model. These features aim to represent the eventual build of the circuit on different topologies without actually having to map and build the circuit. This process runs a page rank algorithm followed by a forward pass of a few small neural networks as opposed to an entire mapping, and routing procedure.\nWe use a variety of features in our neural networks, including quantum specific circuit descriptors and classical circuit descriptors. The idea is to understand at a high level how circuits that are similar and from there which types of circuits are best suited for different topologies. For example, if one circuit can be described as highly entangled and with a few number of unique qubits and is much"}, {"title": "4.2 Generating Training Data", "content": "The ability to leverage different topologies is one of the most useful aspects neutral atom computing. Qompose works to leverage this feature by identifying unique topologies to best best a circuit on. We identify the most likely best topology out of a set of topologies based on experimental analysis. This experimental analysis is based on curated random instruction set generation and analyzing the effects of composing them on differing topologies. Investigating features in these instruction sets through the lens of a multivariate Gaussian generalizes well for selecting the best topology (Fig. 5).\n4.2.1 Building Randomized Instruction Sets. We generate realistic instruction sets which model real-world benchmarks. The goal is to be able to generalize over these benchmarks based on training on similar benchmarks. A few parameters specify the composition of these instruction sets. Firstly, we define inter-connectivity, whereby at each step of adding a new instruction, the probability to sample from previously used qubits as opposed to selecting a new one. The higher the inter-connectivity, the lower the overall complexity of the circuit and likely the longer the critical path. The second parameter is the three qubit gate rate. The higher this rate, the more SWAP gates are typically necessary, as it is less likely for three gates to be near each other than 2. We also specify the one qubit gate rate as the rate in which one qubit gates are generated. Additionally, the circuit width is specified which outlines the unique number of qubits in the circuit. Finally, the minimum number of instructions is set to give a rough level of instruction count to the circuit. As Qompose is designed to be executable on multiple topologies, these instruction sets are defined by the length of the critical path (without SWAPS as these change from one topology to another), the three qubit gate rate, the one qubit gate rate, and on the circuit width and are tested on all topologies. These instruction sets are then analyzed using the feature analysis previously mentioned, followed by scheduling and execution to label the \"ground truth\" measurements for different topologies. The goal of the neural networks is to match these regressions for new, unseen instruction sets.\n4.2.2 Quantum Descriptors used in Neural Network. The circuit width, W, is the number of unique qubits, q used within the circuit. This metric is useful for understanding the eventual mapping on neutral atom circuits as it dictates how many nodes need to be mapped. This number strongly affects the best topology for the circuit. Circuit width is defined formally as\n$W = q_{active}$"}, {"title": null, "content": "Second, we consider the circuit depth, D, which is the longest critical path of the circuit and is defined as:\n$D = \\sum_{j}^{t} max(Q_{j})$"}, {"title": null, "content": "The critical path is the shortest path the circuit must take in order to complete. Circuit Depth infers the limit to parallelism of the circuit. This serial path cannot be parallelized and is a lower bound for the execution time of the circuit.\nWe then calculate the gate density, p as\n$\\rho = \\frac{G_{1qubit} + 2 * G_{2qubit} + 3 * G_{3qubit}}{W*D}$"}, {"title": null, "content": "where $G_{1qubit}$ represents the total number of single qubit gates, $G_{2qubit}$ represents the total number of 2 qubit gates, and $G_{3qubit}$ represents the total number of 3 qubit gates. The gate density describes the level of occupancy of gates throughout the circuit. This gives insight to the likely occupancy once the circuit is mapped to quantum hardware.\nWe use entanglement variance, EV to encapsulate the level of interconnectedness of the graph, formalized as:\n$EV = \\frac{\\sum_{i=0}^{W log}(G_{qi}(2qubits) - G_{qi}(2qubits))}{W}$"}, {"title": null, "content": "We use program communication, PC, as the normalized average degree of the interaction graph [31] to understand the connection between pairs of qubits.\n$PC = \\frac{\\sum_{i=0}^{W}d(q_{i})}{W(W-1)}$"}, {"title": null, "content": "where d(qi) represents degree of qubit i.\nCritical Depth, CD, measure the shortest possible duration the circuit must take in order to complete in terms of two-qubit gates. This is useful as it correlates highly to circuit fidelity [31].\n$CD = \\frac{n_{ed}}{n_{e}}$"}, {"title": null, "content": "where ned is a count of the two-qubit gates on the critical path and ne is a count of the total two-qubit gates\nEntanglement Ratio, ER, is a rough measure of the amount of entanglement throughout the circuit. It is difficult to measure this throughout every point in the circuit as this would require access to the full state-vector [31]. Instead we measure the ratio of the"}, {"title": null, "content": "count of all two-qubit gate operations ne to the count of all gate operations within the circuit ng.\n$ER = \\frac{n_{e}}{n_{g}}$"}, {"title": "4.2.3 Leveraging Page Rank Features.", "content": "We also use features not specific to quantum circuits. We leverage a few features from Page Rank [19] in order to understand the variance in entanglements within a given circuit. Prior to this, there has been a large effort in using PageRank in quantum computing [15, 20]. We use the page rank variance of the circuit in order to understand the level of dependency between qubits. For this we start by calculating the weighted adjacency matrix of the circuit. This results in a WxW matrix with 0's along the main diagonal. We then run page rank on this matrix until the page rank loss is below a fixed e. This adds rich data to our model in the form of page rank standard deviation, page rank max value, and page rank mean. After initialization, the Page Rank for each qubit U is\n$PageRank(U) = \\sum \\frac{PageRank(V)}{|Out(V)|}$"}, {"title": null, "content": "From the page rank solution vector, we take the Page Rank Mean, \u03bc as\n$\\mu = \\frac{\\sum PageRank(U)}{W}$"}, {"title": null, "content": "We calculate Page Rank Standard Deviation, \u03c3 as\n$\\sigma = \\sqrt{\\frac{\\sum (U - \\mu)^2}{W}}$"}, {"title": null, "content": "The standard deviation of Page Rank provides insights regarding the distribution of central nodes within the circuit. A high standard deviation would indicate for example that much of the complexity within the circuit resides within a fewer number of qubits as opposed to a low standard deviation which would imply otherwise. The maximum Page Rank value, M, informs about the central dependencies of the circuit, where a high value indicates many swaps to interact with the center and less opportunity for parallelism. For all qubits U \u2208 W, the maximum value is defined as below and is bound by (0, 1].\n$M = max(PageRank(U))$"}, {"title": "4.2.4 Gate Size Proportions.", "content": "The final set of features we add is based on the distribution of gate types. We calculate the proportion of 1-qubit gates, 2-qubit-gates, and 3-qubit gates within the circuit. These values are each bounded from [0,1] and all sum to 1."}, {"title": "4.3 Training the Neural Network", "content": "We train our model on randomly generated circuits aimed at emulating realistic quantum circuits. We train on instruction sets varying in size from 20 to 100 operations not including swap operations as these represent a variable amount of additional instructions calculated at run-time. We generate circuits with widths between 5 and 70. The core of this model is a small neural network that transforms these static circuit features to a label representing the optimal topology. In the case of Qompose, only the tessellating shapes are considered, however; this neural network can be expanded to any number of shapes by tweaking the dimensionality of the output layer. 5 fold cross validation is used to split our training and testing data with 80% used for training and 20% used for testing.\n4.3.1 Network Architecture. Due to the small number of features, only a small network is needed for the classification task. The model is composed of the input layer of size 14, followed by two hidden layers each of size 15, and an output layer of size 1. The input layer has one neuron for each feature to be able to encode all of the input information. The hidden layers use relu activation functions to regularize the training. The output layer is of size 1 to perform the regression. We use Adam Optimizer [12] for training with mean absolute loss and train over 400 epochs.\n4.3.2 Shape Specific Networks. For each regression task of estimating the total pulse count, critical pulse count, and fidelity, Qompose uses different sets of neural networks for regression. This ensures that each network has a single objective, allowing it to be smaller and easier to train. For each shape, a separate network is trained in order to learn the mappings from the feature space to each measurement (total pulse count, critical pulse count, and fidelity). The classification is then the shape corresponding to the network that produces the minimum value in the respective measurement. This significantly outperform classification based networks as the actual measurement are important for deciding the optimal shape.\n4.3.3 Hyperparameters. All networks use identical hyperparameters. We set the learning rate to .001. The constant for numerical stability, e, is set to 1e-7. The first order exponential decay variable, \u1e9e1, is set to .9. Additionally, the second order exponential decay variable, \u1e9e2 is set to .999."}, {"title": "5 TOPOLOGY INFERENCE AND CIRCUIT EXECUTION", "content": "Qompose uses a systematic approach driven based on graph analysis methods to represent the neutral atom circuits. By taking into account familiar look-ahead properties, we factor in future circuit operations in building the circuit. The stages required to perform topology inference and circuit execution follow a trained model that informs the optimal shape to be mapped. From here the circuit is mapped to the specified topology, followed by a scheduling procedure to ensure operations do not interfere with one another, are computed in the proper order, and are scheduled as parallel as possible. One the schedule is complete, the circuit has a timing of operations and is ready to be executed or simulated. The overview of Qompose's approach can be found in Figure 4."}, {"title": "5.1 Mapping", "content": "The first step Qompose takes to orchestrate neutral atom circuits after prediction, is to map the logical qubits to physical locations on a 2-D lattice. While previous works have analyzed performance on a single topology such as a square grid, we build our approach to generalize well over multiple topologies (Fig. 2).\nRegardless of the identified shape for the circuit, the first step of the mapping procedure is identical. Based on the analysis of the circuit structure, Qompose first identifies the pair of qubits that are used most commonly together. This count includes qubits present together in operations greater than 2 qubits as well. Identify the center-most position within the grid and assign the first logical qubit to that position. Find the nearest location adjacent to the center and assign the second logical qubit in the pair there. The first location Lo is calculated over all points L where\n$L_{o} = argmin \\sum (P-P_{n})^{2}$"}, {"title": null, "content": "This heuristic is based on the idea of reducing SWAP operations by keeping the commonly used qubits in the center and thus the most easily accessible overall by other qubits. Reducing SWAPs is especially important as they require many more pulses and therefore time to complete then other gates as well as compromising a lower output fidelity.\nThe second stage of the mapping procedure is to build an adjacency map. This adjacency map is comprised of edges as connections of all qubits within the circuit. Each pair of qubits present in the graph has a weight that defines the relationship between the two qubits. This relationship is defined and used to assign weights to each edge between all qubits u and v as the count of the connections between them. This compromises the weight function w(u, v).\nFrom there, one at a time, qubits are assigned to the graph in order based on their weighted interaction to all other qubits currently existing on the graph v. This objective refreshes after each addition to the graph and must be recalculated with the inclusion of the new qubit.\n$Q_{next} = argmax \\sum_{q} \\sum w(u,v)$"}, {"title": null, "content": "Once the new qubit to be added has been decided, the location is assigned to the new qubit according to a weighted sum w(u, v)"}, {"title": null, "content": "$L = argmax \\frac{w(u,v)}{\\sqrt{(i - \\upsilon_{i})^{2} + (j - \\upsilon_{j})^{2}}}$"}, {"title": null, "content": "In the case of a 3 dimensional lattice with an additional z axis, this objective presents itself as follows.\n$L = argmax \\frac{w(u,v)}{\\sqrt{(i - \\upsilon_{i})^{2} + (j - \\upsilon_{j})^{2} + (k - \\upsilon_{k})^{2}}}$"}, {"title": null, "content": "After this procedure, the mapping is complete and the process repeats until all qubits have an assigned.\n5.1.1 Inserting SWAP Gates. Once all qubits have a physical assigned location, it may be necessary to add SWAP operations in order to interact qubits that are too far from one another for a Rydberg interaction to entangle them directly. It is important to note that it is possible for any given operation to require multiple SWAPs to complete. For each instruction in the circuit's instruction set, the locations of the qubits are checked to see if they are all within the effective Rydberg interaction radius for the gate type. If it is the case that these qubits do not all fall within a given interaction radius, then SWAPs are added in a best effort shortest path to connect all of the qubits.\nIn the case of 2 qubits, this procedure seeks to find the shortest path by adding SWAPs one at a time going from point u to v. This is done by swapping u with a new point h that then becomes the new u. Every location up that is within the 2-qubit Rydberg interaction radius is considered to become the new h.\n$h = argmin (u_{i} - \\upsilon)^{2}$"}, {"title": null, "content": "Once all qubits are within the necessary interaction radius, all recorded SWAPs are added to the schedule where each SWAP's previous SWAPs are noted as previous requirements."}, {"title": "5.2 Scheduling", "content": "Once the SWAPs are added, the operations are ready to be scheduled. The goal of this stage is to preserve the necessary order of logical operations while maximizing the operations that can be run in parallel at the same time. Scheduling properly is critical in ensuring well-parallelized circuits that fully take advantage of the given topology in the neutral atom circuit. As this procedure is designed to be neutral atom hardware agnostic, we schedule with abstract time steps. With this, each gate operation i.e., (SWAP, CX, CCX) are assigned a specified amount of time steps for completion that which are defined by the number of pulses required in order to respectively complete each gate operation.\n5.2.1 Scheduling: Creating the DAG. The first step in organizing the circuit operations into a Directed Acyclic Graph is to give all instructions a unique identifier. Once this is complete, it is necessary to build a dependency graph where operations that rely on a specific qubit ensure that the qubit is placed in the proper state by prior operations before scheduling the newer operation. On the same note, all operations that can be parallelized in a given time"}, {"title": "6 EVALUATION AND RESULTS", "content": "Qompose demonstrates highly accurate predictions on diverse random circuits as well as on established benchmarks. We measure performance by the number of pulses required for total critical path as well as the total pulse count and the overall circuit fidelity. These measurements ensure decreased error, lower execution time, and smaller probability of a necessary circuit reset.\nThe benchmarks we include are Walk-Search [28], Decoder [21], Mod5d1 [21], Bernstein-Vazirani [5], Multiply-10 [18], Simon's Algorithm [30], QAOA [7], VQE [24], HLF, 32bitAdder [21], CH [8], XY [18] [1], TFIM [32], BitwiseMajority32 [21], ISING [13], Mult15 [18], SECA [13], QFT15 [13], and MULT25 [18]. These benchmarks are selected to span circuits of various sizes and diverse distributions of one, two, and three-qubit gates. As some benchmarks consist of a large number of qubits, they are not feasible to run error analysis on due to the impossibility to perform ideal classical simulation. We therefore split these benchmarks into small and large circuits where we can run fidelity analysis on the smaller circuits."}, {"title": "6.1 Minimizing Pulse Count for Critical Path", "content": "Here we demonstrate how Qompose is effective at determining effective topologies for reducing the number of pulses in the critical path of a circuit. The pulse count in the critical path is important to neutral atom circuits for a few main reasons. First, the circuit fidelity"}, {"title": "6.2 Minimizing the Total Pulse Count", "content": "While the critical pulse count is important to understanding elements of circuit fidelity and total circuit duration time, total pulse count also measures important aspects of neutral atom circuits. Every time a pulse occurs in a neutral atom circuit, there is a some"}, {"title": "6.3 Circuit Fidelity", "content": "Error rate is an important measure during the NISQ era of quantum computing. Large error rates inherent in quantum circuits consist of state preparation and measurement (SPAM) errors, gate operation errors, and amplitude and phase dampening errors all compound for large error overall. We analyze the bitwise error both on random circuits and established benchmark circuits in Figure 10. For experimental evaluation, we use a noise level of .01 for one-qubit gates, and tesnor this model with itself for two-qubit gates, and once more for three-qubit gates. Each item of training and inference data is generated using the Qiskit Aer simulator with 5000 shots through the circuit. The high amount of shots is used to gain a representative probability distribution of the expected error rates."}, {"title": "7 RELATED WORK AND CONCLUSION", "content": "In this work, we present Qompose, a technique to select optimal algorithm- specific layout for neutral atom quantum architectures. We provide an end-to-end procedure for deciding on topology, mapping, scheduling, and execution for generalized quantum circuits on neutral atom quantum computers. The foundation for this work has been laid by [3] by providing a basis for mapping and routing for neutral atom circuits. However, this work did not explore the design space of optimizing the atom topology; it only explored the widely-used Square topology. In contrast, Qompose shows that other topologies can far outperform the Square topology for certain quantum algorithms.\nOther works have provided thorough review into neutral atom quantum computing [10, 27, 33] - they explain the procedures and detail the experimental parameters that we build our simulator on. As a note, circuit mapping and scheduling works such as [14, 23] have tackled the logical-to-physical execution problem for qubits; however, all of these works have focused on the space of superconducting hardware and not on neutral atom hardware.\nOn the other hand, in Qompose, we utilize many quantum and classical circuit descriptors that are leveraged by neural networks to estimate the fidelity, critical pulse count, and total pulse count for each shape, then select the best one. In addition we demonstrate specific advantages of different topologies for different circuits"}, {"title": null, "content": "based on fidelity, critical pulse count, and total pulse count. We demonstrate that Qompose reduces the critical pulse count over randomly selecting a topology by 8.4% for randomly generated circuits and 5.4% for real-world benchmarks. Qompose is open-sourced for community-wide experimentation and adoption: https://anonymous.4open.science/r/Qompose-5B67/"}]}