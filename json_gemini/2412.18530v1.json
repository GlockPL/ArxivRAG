{"title": "Characterizations of Language Generation With Breadth", "authors": ["Alkis Kalavasis", "Anay Mehrotra", "Grigoris Velegkas"], "abstract": "We study language generation in the limit, which was introduced by Kleinberg and Mullainathan [KM24] building on classical works of Gold [Gol67] and Angluin [Ang79]. The result of [KM24] is an algorithm for generating from any countable language collection in the limit. While their algorithm eventually generates strings from the target language K, it sacrifices breadth, i.e., its ability to output all strings in K. The main open question of [KM24] was whether this trade-off between consistency and breadth is necessary for language generation.\nRecent work by Kalavasis, Mehrotra, and Velegkas [KMV24] proposed three definitions for consistent language generation with breadth in the limit: generation with exact breadth, generation with approximate breadth, and unambiguous generation. Concurrent and independent work by Charikar and Pabbaraju [CP24a] introduced a different notion, called exhaustive generation. Both of these works explore when language generation with (different notions of) breadth is possible.\nIn this work, we fully characterize language generation for all these notions of breadth and their natural combinations. Building on [CP24a; KMV24], we give an unconditional lower bound for generation with exact breadth, removing a technical condition needed in [KMV24] and extending the unconditional lower bound of [CP24a] which holds for specific collections; our result shows that generation with exact breadth is characterized by Angluin's condition for identification from positive examples [Ang80]. Furthermore, we introduce a weakening of Angluin's condition and show that it tightly characterizes both generation with approximate breadth and exhaustive generation, thus showing that these two notions are equivalent. Moreover, we show that Angluin's condition further characterizes unambiguous generation in the limit as a corollary of a more general result that applies to a family of notions of breadth. We discuss the implications of our results in the statistical setting of Bousquet, Hanneke, Moran, van Handel, and Yehudayoff [BHMvY21]. Finally, we provide unconditional lower bounds for stable generators, strengthening the results of [KMV24], and we show that for stable generators all the aforementioned notions of breadth are characterized by Angluin's condition. This gives a separation for generation with approximate breadth, between stable and unstable generators.", "sections": [{"title": "1 Introduction", "content": "Building on classical work on learning theory, tracing back to Gold [Gol67] and Angluin [Ang88], Kleinberg and Mullainathan [KM24] provided a formal framework for language generation. In this framework, the domain X is a countable collection of strings, and there is an unknown target language K which is a subset of this domain. We know that the true language lies within a collection of possibly infinite but countably many languages L = {L1, L2, . . . }.1 Based on this elementary setup, one can define the tasks of language identification and generation. We start our exposition with the notion of identification in the limit, that goes back to the work of Gold in the late 1960s."}, {"title": "1.1 Language Identification in the Limit", "content": "The problem of language identification in the limit from positive examples was introduced by Gold [Gol67] and further studied by Angluin [Ang79; Ang80]. For a fixed collection L, an adversary and an identifier play the following game: The adversary chooses a language K from L without revealing it to the identifier, and it begins enumerating the strings of K (potentially with repetitions) x1, x2, ... over a sequence of time steps n = 1,2,3,.... The adversary can repeat strings in its enumeration, but the crucial point is that for every string x \u2208 K, there must be at least one time step n at which it appears. At each time n, the identification algorithm I, given the previous examples x1, x2, ..., xn, outputs an index in that corresponds to its guess for the index of the true language K. Language identification in the limit is then defined as follows."}, {"title": "Definition 1 (Language Identification in the Limit [Gol67]).", "content": "Fix some K from the language collection L = {L1, L2, . . . }. The identification algorithm I = (In) identifies K in the limit if there is some n* \u2208 IN such that for all steps n > n*, the identifier's guess in satisfies in = in\u22121 and Lin = K. The language collection L is identifiable in the limit if there is an identifier that identifies in the limit any K \u2208 L, for any enumeration of K. In this case, we say that the identifier identifies the collection L in the limit."}, {"title": "", "content": "It is important to note that the above definition imposes some stability to the algorithm: since there can be multiple appearances of K in the enumeration of L, an algorithm identifies K in the limit only if it eventually stabilizes (i.e., in = in\u22121 for n larger than some n*) to a correct index (i.e., Li* = K). A natural question is which collections of languages are identifiable in the limit. Angluin [Ang80] provided a condition that characterizes such collections."}, {"title": "Definition 2 (Angluin's Condition [Ang80]).", "content": "Fix a language collection L = {L1, L2, . . . }. The collection L is said to satisfy Angluin's condition if for any index i, there is a tell-tale, i.e., a finite set of strings Ti such that Ti is a subset of Li, i.e., Ti \u2286 Li, and the following holds:\nFor all j \u2265 1, if Lj \u2283 Ti, then Lj is not a proper subset of Li.\nFurther, the tell-tale oracle is a primitive that, given an index i, outputs an enumeration of the set Ti.\nIt turns out that the above condition characterizes language identification in the limit."}, {"title": "1.2 Language Generation in the Limit", "content": "Language generation in the limit was introduced by Kleinberg and Mullainathan [KM24] and we define it below. In this work, we define a generating algorithm G = (Gn)n\u2208N as a sequence of mappings, i.e., for each n \u2208 N, Gn is a mapping from training sets of size n to distributions on the domain X. Occasionally, we may refer to generating algorithms as simply generators. As in language identification, there is a two-player game where the adversary fixes a language K\u2208 Land an enumeration of its elements. The adversary presents the enumeration sequentially to the generator, who, at each round, generates a potential example from the target language. The generator's goal is as follows:"}, {"title": "Definition 3 (Language Generation in the Limit [KM24]).", "content": "Fix some K from the language collection \u00a3 = {L1, L2,... } and a generating algorithm G = (Gn). At each step n, let Sn \u2286 K be the set of all strings that the algorithm G has seen so far. G must output a string wn \u2260 Sn (its guess for an unseen string in K). The algorithm G is said to generate from K in the limit if, for all enumerations of K, there is some n* \u2208 IN such that for all steps n > n*, the algorithm's guess wn belongs to K \\ Sn (or K \\ Sn is empty). The collection L allows for generation in the limit if there is an algorithm G that, for any target K \u2208 L, generates from K in the limit.\nNote that for the problem of language generation to be interesting, the languages of the collection L must be of infinite cardinality. Hence, throughout this work we assume that that each language in the collection has infinite cardinality. The main result of Kleinberg and Mullainathan [KM24] is that language generation in the limit is possible for all countable collections of languages."}, {"title": "Theorem 1.2 (Theorem 1 in Kleinberg and Mullainathan [KM24]).", "content": "There is a generating algorithm with the property that for any countable collection of languages L = {L1, L2, ... }, any target language K \u2208 L, and any enumeration of K, the algorithm generates from K in the limit.\nThis result is in stark contrast to negative results in language identification, mentioned in the previous section; hence, showing a strong separation between identification and generation in the limit. We proceed with the main topic of interest: language generation with breadth."}, {"title": "1.3 Language Generation With Breadth in the Limit", "content": "The main open question of Kleinberg and Mullainathan [KM24] was whether there exists a generating algorithm satisfying consistency (i.e., eventually outputting elements only from the true language, which corresponds to Definition 3) and breadth (i.e., eventually being able to generate from the whole range of the true language). The mathematical formulation of this question was introduced in Kalavasis, Mehrotra, and Velegkas [KMV24] and is as follows:"}, {"title": "Definition 4 (Language Generation With Breadth in the Limit [KMV24]).", "content": "A generating algorithm G = (Gn) is said to generate with breadth in the limit for a language collection L = {L1, L2, . . . } if, for any K \u2208 L and enumeration of K, there is an n* > 1, such that for all n \u2265 n*, after seeing n elements of the enumeration,\n$\\mathrm{supp}(G_n) \\cup S_n = K,$\nwhere Sn is the set of elements enumerated until round n.\nOne can also study natural relaxations of the notion of breadth. Kalavasis, Mehrotra, and Velegkas [KMV24] proposed some relaxations of Definition 4. The first relaxation allows the generating algorithm to miss (any) finitely many elements of the target language."}, {"title": "Definition 5 (Language Generation with Approximate Breadth in the Limit [KMV24]).", "content": "A generating algorithm G = (Gn) is said to generate with approximate breadth in the limit for a language collection L = {L1, L2,... } if, for any K \u2208 L and enumeration of K, there is an n* > 1, such that for all n > n*, after seeing n elements of the enumeration,\n$\\mathrm{supp}(G_n) \\subseteq K\\qquad \\text{and}\\qquad |K\\setminus \\mathrm{supp}(G_n)| < \\infty.$\nObserve that a generating algorithm with approximate breadth avoids hallucinations (i.e., outputting elements outside of K, see first term of (2)) but also only misses finitely many elements of the infinite language K (second term of (2)). Hence, any algorithm satisfying Definition 4 immediately satisfies Definition 5; see Section 1.4 for some additional motivation behind the above definition. We note that $|K \\setminus \\mathrm{supp}(G_n)|$ should be finite for all $n > n^*$ but not a fixed constant."}, {"title": "Definition 6 (Exhaustive Language Generation in the Limit [CP24b]).", "content": "A generating algorithm G =(Gn) is said to be an exhaustive generator in the limit for a language collection L = {L1, L2, . . . } if, for any K \u2208 L and enumeration of K, there is an n* > 1, such that for all n \u2265 n*, after seeing n elements of the enumeration,\n$\\bigcup_{i=1}^\\infty G_n (i) \\setminus K <\\infty\\qquad \\text{and}\\qquad S_n \\cup \\bigcup_{j=1}^{n-1} \\bigcup G_j(1) \\cup \\bigcup_{i=1}^\\infty G_n(i) \\supseteq K,$"}, {"title": "Definition 7 (Unambiguous Language Generation in the Limit [KMV24]).", "content": "A generating algorithm G = (Gn) is unambiguous in the limit for a language collection L = {L1, L2, . . . } if, for any K \u2208 L and enumeration of K, its support eventually becomes closer to K than to any other language L \u2260 K in L in terms of the symmetric difference metric, i.e., there exists some n* \u2208 IN such that for all n \u2265 n*, after seeing n elements of the enumeration,\n$\\mathrm{|supp}(G_n) \\triangle K| < \\min_{L\\in \\mathcal{L}: L\\neq K} |\\mathrm{supp}(G_n) \\triangle L|,$\nwhere recall that for two sets S and T, S\u25b3T := (S \\ T) \u222a (T \\ S).\nUnambiguous generation is seemingly weaker than generation with (exact) breadth and not directly comparable to generation with approximate breadth and exhaustive generation."}, {"title": "Remark 1 (Representation of the Generators).", "content": "The astute reader might observe that the previous definitions allow for generating algorithms that output infinite-sized objects. However, all our generating algorithms have succinct representations and this allows for computable algorithms that sample (i.e., generate) a new element, enumerate the support of all generatable elements, and, given an element, decide whether it belongs to the support (i.e., whether it is part of the enumeration). On the other hand, our lower bounds are stronger, they hold for functions that might not be computable."}, {"title": "1.4 Motivation for Generation With Approximate Breadth and Infinite Coverage", "content": "In this section, we provide further motivation behind Definition 5, generation with approximate breadth. An immediate modification of the algorithm of [KM24] can achieve finite coverage of the target language, for any finite number. More concretely, for any function f: N \u2192 N and any countable collection of languages L there exists a generating algorithm (Gn)n\u2208N such that, for any target language K \u2208 L and any enumeration of K the algorithm achieves in the limit\n$\\mathrm{supp}(G_n) \\subseteq K, \\qquad \\mathrm{supp}(G_n) \\cap S_n = \\emptyset, \\qquad \\text{and}\\qquad |\\mathrm{supp}(G_n)| = f(n),$\nwhere Sn is the set of elements enumerated until round n. In fact, their algorithm can achieve the stronger property of infinite coverage defined below."}, {"title": "Definition 8 (Language Generation with Infinite Coverage in the Limit).", "content": "A generating algorithm G = (Gn) is said to generate with infinite coverage in the limit for a language collection L = {L1, L2, ...} if, for any K \u2208 L and enumeration of K, there is an n* > 1, such that for all n \u2265 n*, after seeing n elements of the enumeration (corresponding to the set Sn in round n),\n$\\mathrm{supp}(G_n) \\subseteq K, \\qquad \\mathrm{supp}(G_n) \\cap S_n = \\emptyset, \\qquad \\text{and}\\qquad |\\mathrm{supp}(G_n)| = \\infty,$"}, {"title": "Proposition 1.3 (Modification of [KM24]).", "content": "There is a generating algorithm with the property that for any countable collection of languages L = {L1, L2, . . . }, any target language K \u2208 L, and any enumeration of K, the algorithm generates with infinite coverage from K in the limit.\nThus, the aforementioned modification of the algorithm of [KM24] has the property that it does not hallucinate (i.e., it does not include any elements outside of K in its support) and covers infinitely many (unseen) elements of the target language, but might, potentially, not cover infinitely many elements as well. Thus, a natural question is whether there exists an algorithm that does not hallucinate, can cover infinitely many elements of K, and also miss only finitely many elements of it. This is precisely the requirement of generation with approximate breadth (Definition 5)."}, {"title": "1.5 Summary of Our Results", "content": "Building on [CP24a; KMV24], we provide a general collection of characterizations, summarized in Figure 1. We stress that all these results are unconditional, in the sense that they do not rely on any particular structure of the generating algorithm, strengthening the conditional lower bounds of [KMV24]. Further, the results also hold for all countable collections of languages and not for specific families, strengthening the family-specific lower bounds of [CP24a]. Moreover, in addition to strengthening existing results, the results also establish several new lower bounds and characterizations.\nWe proceed with the statement of our results, which provide a clear picture of the landscape of language generation in the limit. In particular, we show that generation with exact breadth and unambiguous generation are equivalent (Definition 2). Moreover, we show that generation"}, {"title": "Main Theorem 1 (Characterizations of Language Generation with Breadth).", "content": "For any countable collection of languages L, the following hold.\n1. The following are equivalent:\n\u2022 There is an algorithm that generates from L in the limit.\n\u2022 There is an algorithm that generates with infinite coverage from L in the limit.\n2. The following are equivalent:\n\u2022 There is an algorithm that generates with approximate breadth from L in the limit.\n\u2022 There is an algorithm that generates exhaustively from L in the limit.\n\u2022 L satisfies the weak Angluin's condition (Definition 9).\n3. The following are equivalent:\n\u2022 There is an algorithm that generates with (exact) breadth from L in the limit.\n\u2022 There is an algorithm that generates unambiguously from L in the limit.\n\u2022 There is an algorithm that identifies L in the limit.\n\u2022 L satisfies Angluin's condition (Definition 2).\nThe proofs for all the results of the list of characterizations are provided in the upcoming Section 2. We mention that using reductions from [KMV24], the above characterizations also have implications in the statistical setting, which we discuss in Section 2.5."}, {"title": "Remark 2 (Oracle Access for Main Theorem 1).", "content": "Following the phrasing of [KM24], we provide both functions and algorithms that generate in the limit. An algorithm only accesses L via a membership oracle (and potentially a tell-tale oracle). When a generator uses other types of oracles (e.g., subset oracle), we call it a function. To be more specific for the generators of Main Theorem 1, for Item (1), we design a function that uses membership and subset queries as well as an algorithm that uses only membership queries ([KM24] and Proposition 1.3). For approximate breadth in Item (2), we design a function that uses membership and subset queries (Lemma 2.4) as well as an algorithm that uses membership and tell-tale queries (Lemma 2.6). For exhaustive generation in Item (2), we design a function that uses membership, subset, and finite-difference queries (Lemma 2.9) and an algorithm that uses membership and tell-tale queries (Lemma 2.10). Finally, for Item (3), we design a function that uses membership and subset queries and an algorithm that uses membership and tell-tale queries [Ang80; KMV24]."}, {"title": "Landscape with Stable Generators.", "content": "Prior work [KMV24] also studied the problem of generation with breadth using generating algorithms that are stable. Roughly speaking, this means that their support eventually stops changing and stabilizes. Under this condition, perhaps surprisingly, the landscape for generation with breadth changes and we provide new results that characterize several definitions of stable generation with breath discussed so far. In particular, we show that the"}, {"title": "2 Main Results: Unconditional Characterizations", "content": "In this section, we present all the unconditional results provided in this work. Additional results for stable generators appear in Section 3."}, {"title": "2.1 Unconditional Characterization of Generation With (Exact) Breadth", "content": "In this section, we prove a strong impossibility result for language generation with exact breadth. This provides a stronger version of a result by [KMV24] for the in-the-limit setting which excluded generators for which the MOP (Definition 19) is undecidable."}, {"title": "Lemma 2.1 (Impossibility for Generation with Exact Breadth).", "content": "Let L be a countable collection of languages that is not identifiable in the limit. Then, no algorithm can generate with breadth from L in the limit.\nIf L is identifiable in the limit, then recent work by [KMV24] shows that consistent generation with breadth is possible in the limit. This algorithm combined with Lemma 2.1 gives us the following result, which completely characterizes generation with breadth in the Gold-Angluin model."}, {"title": "Theorem 2.2 (Characterization of Generation with Exact Breadth).", "content": "For any countable collection of languages L, one of the following holds.\n1. If L satisfies Definition 2, then there is a generator that generates with breadth from L in the limit.\n2. If L does not satisfy Definition 2, then no generator can generate with breadth from L in the limit."}, {"title": "Proof of Lemma 2.1.", "content": "Since L is not identifiable in the limit, it does not satisfy Angluin's condition (Definition 2). Hence, there exists a language L* \u2208 L such that the following holds:\nfor all finite subsets T \u2286 L*, there exists a language LT \u2208 L , T \u2286 LT and LT \u228a L* . (5)\nFix L* \u2208 L to be any language for which this holds. Let E\u221e* be an arbitrary enumeration of L* , without repetitions. Let K and E\u221eK respectively denote the target language and its enumeration that we will construct to show the impossibility result."}, {"title": "2.2 Unconditional Characterization of Generation With Approximate Breadth", "content": "In this section, we show that the following strict weakening of Angluin\u2019s condition characterizes language generation with approximate breadth (recall Definition 5)."}, {"title": "Definition 9 (Weakening of Angluin\u2019s Condition).", "content": "Fix a language collection L = {L1, L2, . . . }. The collection L is said to satisfy the weak Angluin\u2019s condition if for any index i, there is a tell-tale, i.e., a finite set of strings Ti such that Ti is a subset of Li , i.e., Ti \u2286 Li , and the following holds:\nFor all j \u2265 1 such that Lj \u2287 Ti , one of the following holds.\n\u2022 Either Lj is not a proper subset of Li ; or\n\u2022 Lj is a proper subset and misses finitely many elements of Li , i.e., $|L_i \\setminus L_j| < \\infty$.\nFurther, the tell-tale oracle is a primitive that, given an index i, outputs an enumeration of the set Ti ."}, {"title": "Remark 3 (Separation Between Definition 2 and Definition 9 [CP24a]).", "content": "We highlight that there is a separation between the collections of languages that satisfy Definition 2 and Definition 9, which is taken from [CP24a]. Let X = N, Li = N \\ {i}, and L = {N, L1, L2, . . .} . Then, L does not satisfy Definition 2 but satisfies Definition 9. Thus, Definition 9 is a strictly weaker condition than Definition 2.\nWe note that [KMV24] showed that if the MOP is decidable for the generator and the generator is stable (see Section 3 for a discussion on stability and Definition 11 for a formal definition), then Angluin\u2019s original condition characterizes language generation with approximate breadth. Hence, the following result shows a generator that is (1) unstable or (2) has an undecidable MOP can generate a strictly larger set of language collections with approximate breadth than stable generators with decidable MOP."}, {"title": "Theorem 2.3 (Characterization of Generation with Approximate Breadth).", "content": "For any countable collection of languages L, one of the following holds.\n1. If L satisfies Definition 9, then there is a generator that generates with approximate breadth from L in the limit.\n2. If L does not satisfy Definition 9, then no generator can generate with approximate breadth from L in the limit."}, {"title": "Lemma 2.4 (Function for Generation with Approximate Breadth).", "content": "Let L be a countable collection of languages that satisfies Definition 9. Then, there exists a generating algorithm that, given access to a membership oracle for L and a subset oracle for L (that given indices i, j outputs Yes if Li \u2286 Lj and No otherwise), generates from L with approximate breadth in the limit.\nThis proof is inspired by the proof of Theorem B.2 in [KMV24], the difference is that, instead of using Angluin's condition (Definition 2), we use its weakening (Definition 9)."}, {"title": "Proof of Lemma 2.4.", "content": "The algorithm A is illustrated below. This algorithm follows the steps of the generation algorithm of [KM24] (see Steps 1 to 5). The only change is in its last Step 6 where it generates a random sample from the set of interest.\nfor t \u2208 {1,2,... } do:\n1. Observe element xt and let St be the set of all elements observed so far.\n2. Construct a version space Vt consisting of all languages in L\u2264t consistent with St, i.e.,\nVt := {Lj: 1 \u2264 j \u2264t, Lj \u2287 St} .\n# Define a language Li \u2208 Vt to be critical if Li is the smallest-index language in Vt or Li is a subset of all languages preceding it in Vt, i.e., Li \u2286 Lj for all 1 < j < i.\n3. If Vt = \u00d8, output an arbitrary element of X and go to the next iteration.\n4. Construct the set Ct \u2286 Vt of all critical languages.\n# To construct the set of critical languages Ct the algorithm needs access to the subset oracle.\n5. Let Li be the largest-indexed language in the set of critical languages Ct.\n6. output a sample from any distribution whose support is Li \\ St. This can be done in a computable fashion by first sampling a natural number n from (e.g., the geometric distribution on N) and then outputting the n-th string from Li \\ St.\nLet z be the first index such that K = Lz. The proposed algorithm generates with approximate breadth from K when after some finite time t*, and for t > t*, the last language in the set of critical languages Ct, Li = Li(t), satisfies that\n$\\displaystyle L_i \\subseteq K \\text{ and } |K \\setminus L_i| < \\infty.$\""}, {"title": "", "content": "This condition is implied by the following two conditions.\n(A) K is eventually included in set of critical languages Ct and is never removed after that.\n(B) Eventually all the languages Lj with j > z that are in Ct satisfy Lj \u2286 K and |K \\ Lj| < \u221e.\nResult (4.3) of [KM24] shows that there is a finite time tA after which Condition (A) holds. We will show that there is also a finite time tB after which Condition (B) holds. This shows that, for any t > max {tA, tB}, A generates with approximate breadth from K.\nCondition (B) holds after a finite time. Since L satisfies the weakening of Angluin's condition (Definition 9), K = Lz has a finite tell-tale set Tz, such that, any language L \u2208 L containing the tell-take Tz satisfies one of the following:\n\u2022 Either L is not a proper subset of K;\n\u2022 Or L is a proper subset of K and satisfies |K \\ L| < \u221e.\n(Recall that Tz is not known to us; our proof will not need this.) Fix any j > z and any time tB \u2265 tA after which K is guaranteed to be a critical language and after which St \u2283 Tz (which happens at a finite time since Tz is finite and, so, all elements of Tz appear in the enumeration of K at some finite time). Our goal is to show that for any t > tB, and any j > z for which Lj is in Ct, it holds that\nLj\u2286 K and K \\ Lj| < \u221e.\nBy the definition of critical languages and the fact that Lj appears after K = Lz in the set of critical languages (as j > z), it follows that Lj \u2286 K. Hence, it remains to show that |K \\ Lj| < \u221e. To see this, observe that since Lj \u2208 Ct and Ct \u2286 Vt, Lj is in the version space Vt and, hence, by the definition of Vt, Lj \u2287 St. Therefore, in particular, Lj \u2287 Tz (as St \u2287 Tz). Now, Definition 9 combined with the observation that Lj \u2286 K implies that |K \\ Lj| < \u221e as required.\nBuilding on the result of Kalavasis, Mehrotra, and Velegkas [KMV24] (Corollary B.2 in their paper), the previous result shows that the function4 of Kleinberg and Mullainathan [KM24] with access to a subset query oracle achieves the \u201cbest-of-three\u201d worlds for generation, without requiring any prior information about L, only subset and membership oracle access."}, {"title": "Corollary 2.5.", "content": "Let L be a countable collection of languages. Exactly one of the following holds for the subset-oracle-based function of Kleinberg and Mullainathan [KM24].\n\u2022 If L satisfies Angluin's condition, the function generates with exact breadth in the limit.\n\u2022 If L does not satisfy Angluin's condition but satisfies the weak Angluin's condition, the function generates with approximate breadth in the limit.\n\u2022 If L does not satisfy the weak Angluin's condition, the function generates with infinite coverage in the limit."}, {"title": "Lemma 2.6 (Algorithm for Generation with Approximate Breadth).", "content": "Let L be a countable collection of languages that satisfies Definition 9. Then, there exists a generating algorithm that, given access to a membership oracle for L and the tell-tale oracle from Definition 9, generates from L with approximate breadth in the limit.\nProof of Lemma 2.6. Let Sn be the set of elements the adversary has enumerated up to round n \u2208 N. For every i, n \u2208 N, let Ti be the first n elements enumerated from the tell-tale oracle when called on language Li . Let also x1, x2, . . ., be an enumeration of the domain X. Our proof is reminiscent of Angluin's approach [Ang80], and the generating algorithm requires only one extra step, namely removing the elements x1, . . ., xn from the support of the outputted distribution. However, due to the relaxed condition we are using, our analysis is more technically involved.\nFor every round n \u2208 N, the generating algorithm constructs the sets Tn using the tell-tale oracle for all languages Li with 1 \u2264 i \u2264 n. Let gn \u2208 N, 1 \u2264 gn \u2264 n, be the smallest number (if any) such that Sn \u2286 Lgn and Tn \u2286 Sn. If no such number exists, let Gn be some arbitrary distribution. Otherwise, let Gn be a distribution with supp(Gn) = Lgn \\(Sn \u222a {x1,...,xn}).\nFix a canonical enumeration x1, x2, . . . of X.\nfor n \u2208 {1,2,... } do:\n1. Let Sn be the set of all elements observed so far.\n2. Create the list L\u2264n = {L1, ..., Ln}.\n3. For each language Li in L\u2264n, let Ti = TellTaleOracle(Li ), i \u2208 [n].\n4. Truncate the outputs of the oracle and keep only their first n elements\nT n i = (Ti (1),..., Ti (n)), i \u2208 [n] .\n5. Find smallest index gn \u2208 {1,..., n} such that Sn \u2286 Lgn and Tgn \u2286 Sn.\n# This is the minimum indexed language in L\u2264n that is consistent and its truncated tell-tale is contained in the observed elements.\n6. If no such gn exists, output an arbitrary point from X and go to the next iteration.\n7. Otherwise, define a distribution Gn with supp(Gn) = Lgn \\ (Sn \u222a {x1,...,xn}).\n# The intuition for removing the first n elements x1,..., xn of the canonical enumeration of X is as follows. A bad scenario for our algorithm is that there exists some language Lgn in the enumeration of L before Lz = K such Step 5 will be stuck on Lgn. Then we can guarantee that |Lgn \\ K| < \u221e. Since this set is finite, by removing parts of the enumeration of X of increasing"}, {"title": "", "content": "but finite size", "1)": "Sn \u2286 L1"}, {"1)": "We now move on to the case z > 1. Then", "holds": "n(i) either there exists some xji \u2208 Lz but xji \u2209 Li", "Li": 1, "condition": "a) either Lj is not a proper subset of Lj' or (b) |Lj \\ Lj\u2032 | < \u221e.\nConsider j' = z and any j \u2208 I. Since, by construction, Lz \u2288 Lj, the previous argument shows that either (I) Tj"}]}