{"title": "A Multiagent Path Search Algorithm for Large-Scale Coalition Structure Generation", "authors": ["Redha Taguelmimt", "Samir Aknine", "Djamila Boukredera", "Narayan Changder", "Tuomas Sandholm"], "abstract": "Coalition structure generation (CSG), i.e. the problem of optimally partitioning a set of agents into coalitions to maximize social welfare, is a fundamental computational problem in multiagent systems. This problem is important for many applications where small run times are necessary, including transportation and disaster response. In this paper, we develop SALDAE, a multiagent path finding algorithm for CSG that operates on a graph of coalition structures. Our algorithm utilizes a variety of heuristics and strategies to perform the search and guide it. It is an anytime algorithm that can handle large problems with hundreds and thousands of agents. We show empirically on nine standard value distributions, including disaster response and electric vehicle allocation benchmarks, that our algorithm enables a rapid finding of high-quality solutions and compares favorably with other state-of-the-art methods.", "sections": [{"title": "Introduction", "content": "Coalition formation is a major problem in artificial intelligence that is central to many practical applications. Coalitions of delivery companies can, for instance, be formed to reduce transportation costs by sharing deliveries (Sandholm and Lesser 1997). In disaster response, hundreds of human responders can be quickly organized into teams to coordinate their evacuation and rescue actions (Wu and Ramchurn 2020). Central to coalition formation is the coalition structure generation problem. It consists of identifying the optimal partitioning of a set of agents- that is, an optimal set of coalitions among agents that maximizes the sum of the values of the coalitions (an optimal coalition structure).\nSeveral algorithms have been proposed for this problem, including optimal and approximate solutions. Optimal solutions require a huge execution time and a large storage space due to the exponentiality of the input and the solution space. This limits their applicability to large-scale problems. Indeed, due to this, exact algorithms can only handle small numbers of agents (around 30) (Wu and Ramchurn 2020). Furthermore, we do not expect an algorithm that always finds an optimal solution to this problem for large-scale settings with hundreds of agents, as there is no proven guarantee that an algorithm can find an optimal solution without enumerating all 2n coalition values. To meet the need of addressing this limitation, scalable solutions that scale to hundreds and thousands of agents have been suggested. Along this line, approaches such as CSG-UCT (Wu and Ramchurn 2020), PICS (Taguelmimt et al. 2022) and C-Link (Farinelli et al. 2013) have been proposed. However, to our knowledge, PICS, and CSG-UCT produce the best results among existing state-of-the-art algorithms for solving large-scale problem instances.\nGiven the complexity of this problem, we propose SALDAE (Scalable Algorithm with Large-Scale Distributed Agent Exploration)\u2014a scalable and anytime algorithm for solving the coalition structure generation problem. Specifically, we develop a variant of multiagent path finding for coalition structure generation by gradually building a search graph of coalition structures based on three expansion steps. To the best of our knowledge, this is the first algorithm for this problem using any variant of path finding. This algorithm is scalable and can be run with large problem instances with thousands of agents, which is hard to achieve with existing state-of-the-art exact algorithms. Moreover, it can return an anytime solution when time is limited. To summarize, our main contributions are:\n\u2022 We present SALDAE, a new algorithm inspired by multiagent path finding concepts to search the coalition structure graph. It is anytime and scales to thousands of agents.\n\u2022 To improve the search process, we propose various strategies inspired by MAPF (Multiagent path finding) techniques for connecting the best solutions found at a given step during the execution in an effort to find even better ones. We also explore different techniques for select-"}, {"title": "Problem Formulation", "content": "In CSG, we are given a set of n agents, represented by $A = \\{a_1, a_2, ..., a_n \\}$, and a characteristic function v that assigns a real value to each coalition, indicating the efficiency of the coalition. A coalition C is any non-empty subset of A, and the size of C is denoted by |C|. A coalition structure CS is a partition of the set of agents A into disjoint coalitions, formally defined as a collection of coalitions $CS = \\{C_1, C_2, ..., C_k\\}$, where k = |CS|, and the following constraints are satisfied: $\\cup_{i=1}^{k} C_i = A$ (all agents are included in the coalition structure) and for all i,j \u2208 {1,2,...,k} where i \u2260 j, $C_i \u2229 C_j = \u00d8$ (each agent is included in exactly one coalition).\nLet \u03a0(A) denote the set of all coalition structures. The value of a coalition structure CS is assessed as the sum of the values of the disjoint coalitions that comprise it: $v(CS) = \\sum_{C \\in CS} v(C)$. The CSG problem aims at finding the optimal solution, which is the most valuable coalition structure $CS^* \\in \u03a0(A)$, i.e. $CS^* = arg max_{CS \\in I(A)} v(CS)$, for a given set of agents A. However, when time is limited having a good-enough quality solution within a reasonable time is more valuable.\nThe coalition structure graph, first introduced by (Sandholm et al. 1999), is a way to represent the search space as a graph composed of nodes representing the coalition structures. For a given set of n agents, these nodes are organized into n levels, where each level consists of nodes representing coalition structures that contain exactly i coalitions (i \u2208 {1, .., n}). Each edge of this graph connects two nodes belonging to two consecutive levels, such that each coalition structure at level i can be obtained by dividing a coalition from a coalition structure at level i \u2212 1 into two coalitions."}, {"title": "Related Work", "content": "Many approaches have been proposed to solve the CSG problem either optimally or approximately, including dynamic programming algorithms, anytime algorithms, heuristic algorithms, and scalable solutions. Dynamic programming approaches, such as those proposed in (Yeh 1986; Rahwan and Jennings 2008; Michalak et al. 2016), guarantee to find the optimal coalition structure but must be run to completion to do so. Anytime algorithms (Sandholm et al. 1999; Dang and Jennings 2004; Rahwan et al. 2009), on the other hand, allow for premature termination while providing intermediate solutions during execution. The hybrid algorithms that combine dynamic programming algorithms with anytime algorithms (Michalak et al. 2016; Changder et al. 2020, 2021; Taguelmimt et al. 2024, 2023) are the fastest exact algorithms.\nHeuristic algorithms, such as those proposed in (Sen and Dutta 2000; Kein\u00e4nen 2009; Di Mauro et al. 2010), prioritize speed and do not guarantee to find an optimal solution. These algorithms are useful when the number of agents increases and the problem becomes too hard to solve optimally. For instance, the simulated annealing method (Kein\u00e4nen 2009), a stochastic local search algorithm, explores different neighborhoods of coalition structures by splitting, merging, or shifting agents. It starts with a random coalition structure and moves to a new one in its neighborhood at each iteration, with the movement accepted with a probability that depends on the difference in utility and a decreasing temperature parameter.\nVery few scalable solutions to CSG exist. For example, the Monte Carlo tree search method proposed in (Wu and Ramchurn 2020) finds solutions by sampling the coalition structure graph and partially expanding a search tree that corresponds to a partial search space that has been explored. The hierarchical clustering approach proposed in (Farinelli et al. 2013) builds a coalition structure by merging coalitions using a similarity criterion based on the gain that the system achieves if two coalitions merge. The search algorithms FACS and PICS proposed in (Taguelmimt et al. 2021, 2022) generate coalition structures based on code permutations applied to selected initial vectors of a different search space representation. To the best of our knowledge, PICS (Taguelmimt et al. 2022) and CSG-UCT (Wu and Ramchurn 2020) are the best performing of the prior algorithms. Our proposed algorithm evaluates possible splits of coalitions and possible merges of coalition pairs. Unlike some other approaches, such as the C-Link method (Farinelli et al. 2013), which cannot split coalitions once they are merged, our algorithm allows for coalitions to be split and merged multiple times. This makes our algorithm less likely to get trapped in local maxima.\nMultiagent path finding (MAPF) (Stern 2019) is another important problem in multiagent systems, where agents must navigate through a given environment to reach their goals while avoiding collisions with each other. This problem of planning paths for multiple agents is also known to be NP-hard (Yu and LaValle 2013) and has been studied extensively in the literature. It is inspired by real-world applications such as warehouse logistics (Ma et al. 2017), autonomous aircraft-towing vehicles (Morris et al. 2016), airport operations (Li et al. 2019), and video games (Li et al. 2020b). One of the most popular algorithms for MAPF is the Conflict-Based Search (CBS) algorithm (Sharon et al. 2015). CBS is a complete algorithm that guarantees to find the optimal solution if one exists. Other algorithms (Gange, Harabor, and Stuckey 2021; Barer et al. 2014; Li et al. 2021; Li, Ruml, and Koenig 2021; Li et al. 2020a; Li, Ruml, and Koenig 2020) based on CBS and other methods have been developed to solve this problem in optimal, suboptimal, or bounded suboptimal ways. In the next section, we explain how we draw inspiration from MAPF concepts to enhance the search for solutions to CSG and propose a new algorithm that adapts ideas from MAPF for solving the CSG problem.\nIn this paper, we propose a path search algorithm for finding optimal coalition structures in coalition structure gener-"}, {"title": "Path Search Algorithm for CSG", "content": "In this paper, we consider a path finding variant where each node is a solution to the CSG problem, i.e. a coalition structure. The goal is thus to find the optimal one or at least approach its value. This variant is defined by a graph and a search agent that begins at a start node and can move to an adjacent node at each step. The search agent maintains a list of nodes, sorted according to the values of the corresponding coalition structures. A path in this context is a sequence of nodes that are adjacent to each other, starting at the start node. The decision to pursue one path over another is based on the coalition structure value of the reached node. Hence, the cost of a path is the value of the coalition structure of its last expanded node.\nMultiagent Path Finding (Stern et al. 2019; Stern 2019) also has many variants. Our goal is to find the optimal solution using multiple search agents. Inspired by concepts from MAPF, our variant is defined by a graph and a set of m search agents {s1,..., sm}. Each search agent si has a designated start node and can move to an adjacent node at each step. Conflicts can occur when two search agents consider the same coalition structure for evaluation. While the paths taken by the search agents are important for finding high-quality solutions quickly, they are not the solution themselves. The optimal solution is the highest-valued coalition structure found in the nodes.\nOur path search algorithm for the optimal coalition structure uses a search graph (see Figure 1). This graph is built gradually, starting from a designated start node that represents a starting coalition structure, which can be the top node (that represents the coalition structure containing the singleton coalitions), the bottom node (i.e. the coalition structure composed of the grand coalition that contains all the agents) or any other node. Each parent node in the search graph is connected to a number of child nodes that can be generated by either splitting a coalition or joining two coalitions in the parent coalition structure. Given a coalition structure $CS = \\{C_1, C_2, ..., C_k\\}$:\n\u2022 splitting a coalition $C_i$ into $C_j$ and $C_k$ (i.e. $C_i = C_j \\cup C_k$ with $C_j, C_k \u2260 \u00d8$ and $C_j \u2229 C_k = \u00d8$) in CS results in a new coalition structure $(CS \\setminus \\{C_i\\})\\cup\\{C_j,C_k\\}$.\n\u2022 merging two coalitions $C_i$ and $C_j$ in CS, with i \u2260 j, results in a new coalition structure $(CS \\setminus \\{C_i, C_j\\}) \\cup \\{C_i \\cup C_j\\}$.\nEach node in the search graph represents a potential solution. For the sake of clarity, we will consider the bottom node as the start node in the remainder of this section. The search graph is constructed iteratively by adding new nodes generated according to the following steps, which constitute a type of greedy algorithm. Throughout this process, the terms \"node\", \"coalition structure\", and \"solution\" may be used interchangeably.\n1.  Step 1: Generation: In this step, child coalition structures are generated from the current start node by either splitting a coalition or joining two coalitions. For the first iteration, if the bottom node is the start node, child nodes can only be generated by splitting the grand coalition. Each newly generated child node is added to the search graph.\n2.  Step 2: Selection: This step defines the start node selection procedure. When a set of child nodes is generated, they all form a set of candidate coalition structures to be the start node for the next iteration. Given this, the algorithm selects the most promising node to consider as the start node SN for the next iteration. The start node is chosen as the highest-valued child coalition structure, i.e. SN = arg maxcs\u2208Child V (CS), where Child is the current child nodes generated in the graph, not just the child nodes generated for one node.\n3.  Step 3: Comparison to incumbent: This step involves evaluating the selected coalition structure to determine if it is better than the current best solution found in previous iterations. If it is, the best solution is updated with the new one. The value of a coalition structure is determined by summing the values of the coalitions that comprise it. After evaluating the coalition structure, another iteration begins with the new start node, which is the tested coalition structure."}, {"title": "Exploring Solutions through Bridging Paths for Enhanced Solution Quality", "content": "The algorithm maintains a list of nodes and expands them based on the 3 steps. Hence, the algorithm moves from one node to another, seeking to improve the solution. In addition to these steps, each time a better solution is found, the algorithm creates a path of nodes between the previous best solution St and the new one Sn. This is done to explore the possibility of finding even better solutions along the path between the two solutions. The motivation for this is that the distribution of coalitions and agents in the two current best solutions is related to the quality of the solutions. Hence, a slight change in these coalition structures could lead to even better solutions.\nTo illustrate this, consider a search graph with 8 agents. If the two current best solutions are $S_t = \\{\\{a_2,a_7\\}, \\{a_1, a_4\\}, \\{a_3, a_5, a_6, a_8\\}\\}$ (located on level 3) and $S_n = \\{\\{a_2\\}, \\{a_3\\}, \\{a_7\\}, \\{a_1, a_4\\}, \\{a_5, a_6, a_8\\}\\}$ (located on level 5), we can split the first coalition of St to obtain the coalition structure CS1 = ${\\{{a_2\\}, \\{a_7\\}, \\{a_1, a_4\\}, \\{a_3, a_5, a_6, a_8\\}\\}$. Then, we can also split the fourth coalition {a3, a5, a6, a8} of CS1 into two coalitions {a3} and {a5, a6, a8} to obtain the coalition structure Sn. These two splits create a path between the two current best solutions. The solutions along this path (CS1), which may not have been processed yet, may be better than both St and Sn. It is worth noting that the path may contain multiple solutions, depending on the distance between St and Sn. However, it is not always possible to construct a path between two solutions by only splitting or merging coalitions. In some cases, agents may be in completely different coalitions than in the last best solution. Therefore, a path between the two current best solutions may be found by combining splits and merges of coalitions.\nIn what follows, we refer to the node that contains the grand coalition as the bottom node and the node that contains the singleton coalitions as the top node. The following properties hold.\nObservation 1. Given n agents, let N be a node of level l. Then, it holds that:\n\u2022 The bottom node can be reached from N with l \u2212 1 merges and N can be reached from the bottom node with l \u2212 1 splits.\n\u2022 The top node can be reached from N with n-l splits and N can be reached from the top node with n \u2013 l merges.\nRecall that a path goes through several coalition structures by splitting and merging coalitions. We refer to the number of splits and merges to reach one coalition structure from another by the size of the path.\nObservation 2. Let CSi and CSj be two coalition structures, where CSi \u2260 CSj. Then, there is always a path between CSi and CSj of size at most n \u2013 1.\nThe proofs of Observation 1 and Observation 2 are given in the appendix. Given the previous best solution $CS_l$ and the new best solution $CS_n$, to reach the coalition structure $CS_n$ from $CS_l$, we propose in this paper three strategies: SPLIT-THEN-MERGE, MERGE-THEN-SPLIT, and APPROACH-THEN-SWAP.\nSPLIT-THEN-MERGE One alternative to reach CSn from CSi is based on Observations 1 and 2. Starting from CSI, the algorithm splits the coalitions one by one until reaching the top node. Once the top node is reached, the algorithm merges the coalitions until the desired node CSn is reached. To ensure that CSn is reached, the algorithm avoids merging coalitions whose agents are not part of the same coalition in CSn. An illustration of this strategy can be seen in Figure 2 as the orange path.\nMERGE-THEN-SPLIT This strategy involves a descending phase followed by an ascending phase. During the descending phase, the algorithm starts from the last best solution CSI and merges coalitions to form the grand coalition at the bottom node. Then, during the ascending phase, the algorithm splits the coalitions to reach the target solution CSn. During this phase, the algorithm does not separate agents that are in the same coalition in CSn, as this would prevent the algorithm from reaching its target solution. An illustration of this strategy can be seen in Figure 2, where it is represented by the purple path."}, {"title": "Optimizing the Search for Global Optima through Memory Management", "content": "SALDAE maintains three lists of nodes in memory: OPEN, SUBSTITUTE, and RESERVE. OPEN is sorted in descending order according to the values of the coalition structures represented by the nodes it contains. It is constructed using the three steps of the search process (see Section 4). SUBSTITUTE contains the nodes visited by the algorithm during the path search between the current best solutions. These nodes are not expanded unless they improve the current solution. Two hyperparameters, \u03b8 and \u03c9, are introduced to control the memory usage of the algorithm. \u03b8 determines the number of child nodes to keep in memory for each expanded node, while \u03c9 is the lower bound on the minimum value required for a node to be maintained in the list OPEN. Let CS+ be the current best solution. The list OPEN contains nodes CS such that v(CS) > \u03c9 \u00d7 v(CS+), while RESERVE contains nodes CS with v(CS) < \u03c9 \u00d7 v(CS+). The list OPEN is used by SALDAE for the search and is replaced by either the SUBSTITUTE or RESERVE list if it becomes empty.\nReplacing OPEN with SUBSTITUTE Since the list OPEN contains the nodes where v(CS) > \u03c9 \u00d7 v(CS+), it is possible that after several iterations OPEN becomes empty. This can happen if the nodes expanded by SALDAE do not generate child nodes that meet the condition (v(CS) > \u03c9 \u00d7 v(CS+)), i.e. the child nodes are directly added to the list RESERVE. In this case, the algorithm replaces OPEN with SUBSTITUTE and continues the search. This allows SALDAE to explore different areas of the solution space that may be more promising, instead of staying in a part of the space that has not produced better solutions or at least solutions that would have remained in OPEN.\nReplacing OPEN with RESERVE In SALDAE, SUBSTITUTE is constructed after finding a new best solution. However, when OPEN is replaced with SUBSTITUTE, the list SUBSTITUTE remains empty, until a better solution is found. If before finding a better solution OPEN becomes empty, SALDAE replaces OPEN with the list RESERVE and continues the search. This way, SALDAE prioritizes searching in parts of the solution space that are more promis-"}, {"title": "Multiagent Search", "content": "To speed up finding high-quality solutions, SALDAE employs several search agents {s1,..., sm}. Each agent si has a start node and maintains three lists of nodes OPEN, RESERVE, and SUBSTITUTE. SALDAE affects one agent for each of the bottom and top nodes, and random nodes to other agents. Then, each agent moves from a node to an adjacent node searching for better solutions.\nWhen a search agent si expands a node and generates child nodes, it checks for conflicts among the lists of the search agents. We say that two agents have a conflict iff they consider the same coalition structure for evaluation. If there are no conflicts, the agent si adds the generated child node to the list OPENi or RESERVEi. Otherwise, si resolves the conflict by selecting the search agent that will keep the generated child node, using the following techniques. We introduce the following techniques to resolve the conflicts.\nBypassing Conflicts If a child node is found in an OPENj or RESERVEj list of another search agent sj, the search agent si is prohibited from using the conflicting child node and sj keeps it. This ensures that the first search agent to consider the node is the one that keeps it. This is different from the bypassing conflicts in CBS, where SALDAE aims to bypass the conflicts by generating coalition structures that avoid leading to conflicts in the first place. The goal of doing this in SALDAE is to guarantee that the search agents do not search the same coalition structures at the same time and explore different areas of the solution space.\nManaging Conflicts Since the OPEN and RESERVE lists are not the same for each agent, the search agent si compares the ranking of the child node in its own list with the ranking in the list of the conflicting search agent sj. If the search agent si allows the expansion of the conflicting child node first, it will remove the node from the list of the other search agent sj and add it to its own list. This indicates that the treatment of the conflicting child node is removed from the search agent sj. Otherwise, the search agent si is prohibited from using the conflicting child node and sj keeps it. This ensures that the search agent that allows the expansion of the conflicting child node first gets to keep it.\nAlgorithm 1 shows the pseudocode of SALDAE. Lines 8 and 12 are discussed in the section 5 of the paper. SALDAE runs in parallel m search agents si. ExecutePathStrategy function constructs a path between the last best solutions and adds the visited nodes to the list SUBSTITUTEi. AddChildNodesToOPENorRESERVE function distributes the nodes between the lists OPENi and RESERVEi according to their coalition structure values:\n1. if v(N) > \u03c9 \u00d7 v(CS+) then add N to OPENi;\n2. else add N to RESERVEi."}, {"title": "Selecting Child Nodes", "content": "Due to the large number of possible child nodes in the coalition structure graph, it is infeasible to generate all of them, especially for large numbers of agents, this makes the search space intractable and highlights the importance of using more efficient selection strategies. Here, we present and introduce two child node selection methods.\n1.  Quantity-Based Selection\nA straightforward idea for generating child nodes that can reduce computational burden and memory requirements is to select a number of child nodes and then keep the best ones in OPEN and RESERVE. Let Nc and Na be the number of child nodes to generate for the list OPENi, and the number of child nodes to actually add to the list OPENi, with Na < Nc. In the first step of generating child nodes, we generate Nc child nodes, when they exist, whose values are greater than or equal to a threshold value, \u03c9 \u00d7 v(CS+). From these generated child nodes, we select the Na nodes with the highest values and add them to the list OPENi. Any generated nodes that have values less than \u03c9 \u00d7 v(CS+) are added"}, {"title": "Empirical Evaluation", "content": "We experimentally compare the SALDAE algorithm against representative state-of-the-art CSG algorithms for small and large-scale problems. We compare the solution quality (for small-scale problems) and the gain rate (Taguelmimt et al. 2021) (for large-scale problems). We ran the PICS (Taguelmimt et al. 2022) algorithm with a number of processes set to 20 and we ran CSG-UCT (Wu and Ramchurn 2020) with a number of iterations set to 102, as suggested by the authors of the papers. We implemented our algorithm in Java and in the comparisons we used the codes provided by the authors of PICS and CSG-UCT, which are also written in Java. The algorithms were run on an Intel Xeon 2.30GHz E5-2650 CPU with 256GB of RAM.\nTo generate the problem instances, we considered the following value distributions: Agent-based Uniform (Rahwan, Michalak, and Jennings 2012), Agent-based Normal, Beta, Exponential, Gamma (Michalak et al. 2016), Normal (Rahwan et al. 2007), Uniform (Larson and Sandholm 2000), Pascal and Zipf (Changder et al. 2020). The result for each value distribution was produced by computing the average result from 50 generated problem instances per value distribution. The best strategies selection for SALDAE and the hyperparameters are explained in the appendix."}, {"title": "Small-Scale Benchmarks", "content": "In this subsection, we investigate how our algorithm compares to the state-of-the-art algorithms in solving small-scale problems with small numbers of agents. We run the algorithms on the nine value distributions and computed the solution quality achieved by the algorithms. Note that the algorithms behave differently depending on the value distributions. The solutions obtained by the algorithms are compared to the solutions provided by ODP-IP (Michalak et al. 2016), which always yields the optimal solutions. In these experiments, we set the number of search agents of SALDAE to 10 and we stopped the algorithms when they finish or at the time when ODP-IP finds the optimal solution in case they take more time to finish than ODP-IP. Moreover, the number of cores used for each algorithm was matched to the number of processes it utilized. Specifically, SALDAE was run on 10 cores, PICS on 20 cores, and CSG-UCT on 1 core. To ensure fairness in the comparison with CSG-UCT, we added results in the appendix of SALDAE using only one search agent and one core, demonstrating that even with limited resources, SALDAE still outperforms the other algorithm.\nFigure 4 clearly shows that our algorithm provides higher quality solutions than the other algorithms, which demonstrates its effectiveness. For example, with the Exponential distribution, SALDAE produces up to 28% higher solution quality than CSG-UCT and up to 15% higher solution quality than PICS. A notable exception is the Agent-based Normal, for which there is almost a tie (see the appendix).\nIn all value distributions, our algorithm provides optimal solutions more frequently than the other algorithms. For example with the Exponential distribution, SALDAE provides optimal solutions in 91% of the cases. With the same instances of Exponential, PICS and CSG-UCT produce the optimal solution in 7% and 5% of the Exponential instances, respectively. A more detailed experimental results are shown in the appendix. In summary, our algorithm consistently produces higher quality solutions than the PICS and CSG-UCT algorithms, while at the same time providing optimal solutions more frequently than the other algorithms."}, {"title": "Large-Scale Benchmarks", "content": "The fastest optimal algorithm, ODP-IP, only scales to 30 - 40 agents. Our algorithm is able to handle large problems with hundreds and thousands of agents. The algorithms PICS and CSG-UCT could also handle large-scale problems. However, for these settings, it is infeasible to guarantee to find an optimal solution due to the exponentiality of the solution space. Hence, we cannot compute the solution quality by comparing the solutions obtained to the optimal solutions. This is why we compare the algorithms using the gain rate, which measures the improvement of the solution achieved by the algorithms relative to the value of the singleton coalition structure. The gain rate is computed as\n$\\frac{v(CS_i) - v(CS_S)}{v(CS_S)}$,\nwhere i \u2208 {SALDAE, PICS, CSG-UCT} and v(CSS) is the value of the singleton coalition structure, which represents a partition into n coalitions, each containing a single agent, and v(CST) is the value of the best solutions provided by the algorithm i. We also considered a Disaster Response distribution introduced in (Wu and Ramchurn 2020), in which hundreds of human responders must be quickly organized into teams to coordinate their evacuation and rescue actions.\nFigure 13 shows the results of our large-scale benchmarks. We compared SALDAE to PICS, FACS (Taguelmimt et al. 2021), and CSG-UCT. The result of each experiment was produced by evaluating all the algorithms on instances of the different value distributions. To make sure that the algorithms competed on a similar search time, we used the same time limit for all the algorithms. First, we can see a clear general trend that SALDAE and PICS outperform the other algorithms. A notable exception is the Pascal distribution, for which there is almost a tie for less than 100 agents. We can also see that the SALDAE algorithm outperforms the PICS algorithm in a majority of the tests, most notably on problem instances of the Gamma, Exponential, Normal, Disaster Response, and Electric Vehicles Allocation distributions. However, PICS performed on par in Beta and Uniform distributions and in some tests of Agent-based Normal distributions (see the appendix). SALDAE's superior performance comes from the different heuristics that guide the"}, {"title": "Conclusion", "content": "We presented a multiagent path search inspired algorithm for coalition structure generation. In more detail, we developed an algorithm that utilizes multiple search agents to incrementally explore a search graph using various heuristics to guide the search process. Furthermore, we introduced different strategies for connecting the best solutions in order to improve upon them, as well as strategies for resolving conflicts between the search agents. The resulting algorithm is anytime and can handle large-scale problems. We ran experiments on a variety of different value distributions and our results demonstrate that our algorithm can perform better than existing well-established state-of-the-art algorithms in solving the coalition structure generation problem, often achieving significantly higher solution quality and gain rate.\nFuture work could explore the adaptation and application of other MAPF algorithms to address this problem. Another potential avenue for applying MAPF in CSG involves using a different approach where search agents not only have access to start nodes, as in the current version, but also to goal nodes. Currently, we lack a clear definition of goal nodes beyond the one representing the optimal solution, and we are unaware of its position in the graph. However, we have the flexibility to define additional goal nodes, either randomly or through a predefined function, and then the algorithm can be used to find paths between these start and goal nodes."}, {"title": "Analysis of SALDAE", "content": "Theorem 1. Our algorithm is anytime.\nProof. To compute the coalition structures", "storage": "Each node is stored by at most one search agent.\n\u2022 P2 No redundancy in computation: Each node is expanded by one search agent.\nP1 is desirable for accuracy. Less redundancy in storage enables the algorithm to store more unique nodes. P2 is desirable for speed.\nOptimal solution generation discussion. The proposed algorithm has the potential to return the optimal solution if given a sufficient amount of run time. Our algorithm operates by iteratively expanding a search graph of coalition structures. At each iteration, the algorithm generates new child nodes by considering different ways of splitting or merging coalitions from the coalition structures that have been visited so far. Our algorithm adds after each iteration new child nodes to the search graph. If the algorithm is given an unlimited amount of time with an unlimited amount of memory space, it can eventually add the optimal coalition structure to the graph and produce the optimal solution. This is because every possible coalition structure can be reached by a sequence of splits or merges from an existing coalition structure. However, in practice, it may not be feasible to run the algorithm for an unlimited amount of time, especially for large-scale problems. Nonetheless, for large-scale problems, it is intractable to guarantee to find the optimal solution in a limited run time.\nProof of Observation 1. A merger is an operation that combines two coalitions into a single coalition. A split is an operation that takes a single coalition and divides it into two coalitions. The level of a node indicates the number of coalitions in the partition. For example, a node at level 1 represents a partition into a single coalition containing all the agents, while a node at level n represents a partition into n coalitions, each containing a single agent.\nNow, we can prove the two parts of the lemma separately.\nFor the first part, we want to show that the bottom node, which represents a partition into a single coalition containing all the agents, can be reached from N with l \u2013 1 mergers and that N can be reached from the bottom node with l \u2013 1 splits.\nTo reach the bottom node from N, we can perform l \u2212 1 mergers, starting with the two coalitions containing the smallest number of agents and continuing until all the agents are in a single coalition. This requires l \u2212 1 mergers, as there are 1 \u2212 1 pairs of coalitions to merge.\nTo reach N from the bottom node, we can perform l \u2212 1 splits, starting with the single coalition containing all the agents and dividing it into two coalitions. We can then continue to divide the remaining coalition into two coalitions until we have l coalitions. This requires l \u2013 1 splits, as there are 1 \u2013 1 coalitions to split.\nFor the second part of the lemma, we want to show that the top node, which represents a partition into n coalitions, each containing a single agent, can be reached from N with n \u2212 l splits and that N can be reached from the top node with n \u2212 l mergers.\nTo reach the top node from N, we can perform n - I splits on coalitions that contain at least 2 agents until all the agents are in a single coalition. This requires n - l splits, as there are n \u2013 l coalitions to split.\nTo reach N from the top node, we can perform n \u2212 I splits, starting with"}]}