{"title": "Deep Generative Model for Mechanical System Configuration Design", "authors": ["Yasaman Etesam", "Hyunmin Cheong", "Mohammadmehdi Ataei", "Pradeep Kumar Jayaraman"], "abstract": "Generative AI has made remarkable progress in addressing various design challenges. One prominent area where generative AI could bring significant value is in engineering design. In particular, selecting an optimal set of components and their interfaces to create a mechanical system that meets design requirements is one of the most challenging and time-consuming tasks for engineers. This configuration design task is inherently challenging due to its categorical nature, multiple design requirements a solution must satisfy, and the reliance on physics simulations for evaluating potential solutions. These characteristics entail solving a combinatorial optimization problem with multiple constraints involving black-box functions. To address this challenge, we propose a deep generative model to predict the optimal combination of components and interfaces for a given design problem. To demonstrate our approach, we solve a gear train synthesis problem by first creating a synthetic dataset using a grammar, a parts catalogue, and a physics simulator. We then train a Transformer using this dataset, named GearFormer, which can not only generate quality solutions on its own, but also augment search methods such as an evolutionary algorithm and Monte Carlo tree search. We show that GearFormer outperforms such search methods on their own in terms of satisfying the specified design requirements with orders of magnitude faster generation time. Additionally, we showcase the benefit of hybrid methods that leverage both GearFormer and search methods, which further improve the quality of the solutions.", "sections": [{"title": "Introduction", "content": "Configuration design of mechanical systems in engineering (Mittal and Frayman 1989; Wielinga and Schreiber 1997) is a time-consuming task that relies on the domain expertise of engineers. Typically, engineers manually select the optimal combination of components to meet multiple design requirements based on their experience and knowledge, often leading to to sub-optimal solutions that negatively impacts product development (Suh 1990; Dym 1994).\nComputationally, configuration design can be defined as a combinatorial optimization problem with categorical design variables (e.g., component choices) and design requirements expressed as objectives and constraints (Levin 2009)."}, {"title": "Problem", "content": "We address a class of configuration design problems where the design solution can be represented as a sequence. For example, designing an open-loop kinematic mechanism with single input and single output motions/forces would fall under this category. In general, a design solution to such problems could be expressed as a sequence:\n$X = (S, C_1, I_{1,2}, C_2, ..., C_i, I_{i,i+1}, C_{i+1}, ..., C_N, \\Sigma)$ (1)\nwhere S is the start symbol, $C_i$ are the components, $I_{i,i+1}$ are the interfaces between the preceding and the following components, $\\Sigma$ is the terminal symbol, and N is the number of components in the sequence. The set of possible values of $C_i$ are typically based on the list of off-the-shelf components available to the engineer and the set of possible values of $I_{i,i+1}$ are based on the allowed interfacing between $C_i$ and $C_{i+1}$. X must be chosen such that it conforms to a set of rules, R. For example, if $C_1$ was a rack component of certain type, $C_2$ must be a spur gear component that can mesh with $C_1$ and $I_{1,2}$ must convey the corresponding meshing. The possible values and rules of the sequence for a particular application domain constitute the lexicon and grammar of a domain specific language (DSL).\nSolving a configuration design problem involves finding an optimal sequence X that minimizes a particular objective function while satisfying multiple design requirements posed as constraints. In most cases, evaluating the objective function or constraints requires the use of a black-box solver such as a physics simulator relevant to the application domain. Both the combinatorial nature of the problem and the non-differential functions make the problem incredibly difficult to solve with traditional computational methods."}, {"title": "Gear Train Synthesis Problem", "content": "To investigate solving a configuration design problem with a generative model approach, we focus on the gear train synthesis problem. A gear train with single input/output motions can be represented as a sequence defined in Eq. (1), an enumerated collection of gear components and their interfaces.\nDesign requirements considered for gear trains include the cost, weight, output speed/torque ratio, output motion position/vector, and input/output motion type conversion. We used the total weight of a gear train as our objective function, which also serves as a good proxy for the cost. Also, since a torque ratio is simply an inverse of a speed ratio for a gear train ignoring its efficiency, it was not considered for this problem. Then, the rest of the requirements were posed as constraints. We also must ensure that a gear train is physically realizable by conforming to the domain-specific grammar and having no components that interfere with each other. The optimization problem for gear train synthesis could be formulated as follows:\n$\\begin{aligned}\n\\min_X f_w &= \\sum_{i=1}^{N}(w_{C_i}), C_i \\in X \\\\\ns.t. \\\\\n& \\~s - \\tilde{s}(X) = 0; \\\\\n& \\tilde{m} \\cdot \\tilde{m}(X) - 1 = 0 \\\\\n& \\~{p} - \\tilde{p}(X)| = 0 \\\\\n& \\tilde{T}_{in} - \\tilde{T}_{in}(X) = 0; \\tilde{T}_{out} - \\tilde{T}_{out}(X) = 0 \\\\\n& g_{grammar}(X) = 0; g_{interfere}(X) = 0\n\\end{aligned}$ (2)\n$f_w$ is the total weight of the gear train, $w_{C_i}$ is the weight of each component $C_i$ that is a member of the gear train sequence X, $\\~{s}$ is the speed ratio, $\\~{p}$ is the output position in x, y, z coordinates, $\\tilde{m}$ is the output motion vector where the nonzero index indicates the coordinate and its sign indicates the direction, $\\tilde{T}_{in}$ is the input motion type, and $\\tilde{T}_{out}$ is the output motion type. Those denoted with tilde are targets provided by the engineer and those that are function of X are evaluated using a physics-solver. $g_{grammar}$ and $g_{interfere}$ are operators that return 0 if X conforms to the grammar and does not have interference among parts, respectively."}, {"title": "Proposed Approach", "content": "To solve the configuration design problem, we propose a generative model that takes the representation of the design requirement constraints as an input encoding vector E and outputs a sequence X conditioned based on that input while also minimizing the objective function f(X). In other words, we aim to find optimal parameters $\\theta$ for a generative sequential model such as a Transformer\n$X_i = Transformer(E_i, \\theta)$ (3)\nthat minimizes the loss function\n$L(X, X') = \\sum_{i=1}^{|D|} - L_{pred}(X_i, X') - \\alpha f_w(X_i),$ (4)\nwhere the first term is a measure of the model's ability to generate the expected ground-truth sequence $X'$ and the second term corresponds to the design objective, weighted with $\\alpha$. The model is trained using a dataset $D = \\{X_i, X'\\}.\nIt should be emphasized that the generative model could not only be used to predict a solution to the problem on its own but also used in conjunction with traditional search methods to efficiently solve the problem. To this end, we explore the hybrid approaches that combine traditional search algorithms with our generative model as explained below."}, {"title": "Hybrid Methods", "content": "We explore combining a Transformer-based model with two distinct search methods: Estimation of distribution algorithm (EDA) and Monte Carlo tree search (MCTS).\nEDA+Transformer EDA is an evolutionary algorithm that uses a probabilistic model to iteratively sample and improve a population of solutions (Larra\u00f1aga and Lozano 2012). We introduce a hybrid approach that combines EDA with a Transformer-based model to leverage the strengths of the two methods. In this method, EDA is used to explore the first few tokens of the sequence, which have the strongest influence on the whole sequence generation. Given the maximum sequence length of N, the method limits the sequence length considered by EDA to $N_{EDA} < N$ and then uses a Transformer-based model to complete the subsequent tokens before evaluating each candidate solution.\nWe use a bi-gram probabilistic model for EDA:\n$P(X_{1:N}) = \\prod_{i=1}^{N} P(X_i | X_{1:i-1})$ (5)\nwhere $x_1$ is the start token and subsequent tokens $x_i$ are generated using the conditional probability based on the previous token $X_{i-1}$.\nMCTS+Transformer MCTS is a heuristic search algorithm that balances the exploration of under-explored search paths with the exploitation of promising paths ((Coulom 2006; Kocsis and Szepesv\u00e1ri 2006)). Similar to the first method, we combine MCTS with a Transformer-based model to create a hybrid method. We limit the depth of the search tree explored by MCTS to $N_{MCTS} < N$, as MCTS is used to explore the critical initial tokens, while a Transformer-based model is used to complete the subsequent tokens before evaluating each candidate solution.\nMCTS uses a heuristic function to decide which child node (token) to expand during the search, typically:\n$h = \\frac{R_i}{v_i} + c\\sqrt{\\frac{\\ln V_i}{v_i}}$ (6)\nwhere $R_i$ is the accumulated reward for the i-th child, $v_i$ is the number of visits made at the child, $V_i$ is the total number of visits made at the parent, and c is an exploration parameter (set to 1.4 in our case).\nBoth hybrid methods combine the strengths of search algorithms (EDA and MCTS), namely their exploration capabilities, with a Transformer-based model to generate high-quality solutions, potentially leading to more efficient exploration of the search space and better overall results."}, {"title": "Domain Specific Language", "content": "To effectively represent valid gear train designs and also help constrain the search space, a domain specific language (DSL) is developed. For the gear train design problem, a valid sequence must conform to the grammar and lexicon of the DSL as follows."}, {"title": "Dataset Generation", "content": "An important contribution of our work is a method to create the synthetic dataset required to train a Transformer model, named GearFormer dataset, because there lacks any existing dataset of gear train designs. The dataset includes sequences that can be mapped to real-life gear trains paired with multiple requirement metrics evaluated with a physics simulator.\nUsing the grammar in Table 1 as production rules, we generated variable sequences having maximum 10 components to bound the problem but still produce realistic gear trains. A variable sequence with a maximum of 10 components can have up to 21 tokens, including the interface variables and the start/terminal tokens. An example variable sequence with five components is: (<start>, Rack (1), Mesh, Spur Gear (2), Translate, Shaft (3), Bevel Gear (4), Mesh, Bevel Gear (5), <end>). In total, 37,606 unique variable sequences are generated.\nFor each variable in a variable sequence, one of the possible tokens is randomly chosen from our lexicon list. This generates a token sequence that resembles a real gear train design. For the variable sequence example above, a possible token sequence is (<start>, MRGF2-500, (12, -), MSGA2-40, tra-, SH-200, SBSG2-3020R, (1\u00b9, +), SBSG2-2030L, <end>).\nWe discard sequences that are not physically feasible (i.e., at least two components interfere with each other) as explained in the following subsection. We generated a total of 7,363,640 grammatically valid and feasible sequences. Out of these, 0.05% (3,681) were randomly selected for validation, another 0.05% for testing, and the remaining sequences for training. Relatively small validation and test sets are used because each predicted sequence during validation/testing must be evaluated with a simulator to compute the actual requirement metrics, which can be time-consuming.\nTo verify the physical feasibility, we check for interference between all possible pairs of components in the sequence. We use the dimensions from the commercial catalogue to define a bounding box for each component, while keeping track of its current position and orientation. We check for intersections between the bounding box of the current component and those of the previous components, except for the one immediately preceding it, as they are supposed to be connected."}, {"title": "GearFormer for Gear Train Synthesis", "content": "GearFormer (Figure 1) is based on the standard Transformer architecture (Vaswani et al. 2017b). It includes a bidirectional encoder module that takes an input vector that encodes the design requirements, which are embedded with linear layers, ReLU activations, and batch normalization. The output of this encoder serves as context for the autoregressive decoder and is consumed via cross-attention. The decoder then predicts a sequence of output tokens, which represents a valid and feasible gear train design meeting the specified requirements while also minimizing the weight objective.\nPredicting each token of the sequence is a classification task that attempts to select the best class from a vocabulary of 53 tokens (52 tokens from the lexicon plus one for the end-of-sentence token), given the previous tokens and the context (design requirements). Hence, we use a standard cross-entropy loss for $L_{pred}$ in Eq. 4. We also include the weight of the gear train as the design objective loss and experiment with different ratios of $\\alpha$.\n$L(p(X), p(x')) = \\sum_{i=1}^{|D|} -p(X_i)\\log p(X'_i) + \\alpha f_w$ (7)\nEvaluating the weight objective in the training loop requires the ability to differentiably sample the output sequence from the model, and fetch the corresponding component weights from the catalogue. To achieve this, we first extract the component weights from the gear catalogue, and store them in a coefficient vector $W_{coef}$. Then, we use the straight-through Gumbel-Softmax (Jang, Gu, and Poole 2016) trick in the autoregressive sampling loop to generate each token in the sequence as a one-hot vector $s_i \\in \\{0,1\\}^{53}$. By computing the dot product $s_i \\cdot W_{coef}$, we can retrieve the weight of the component represented by the token. Repeating this for the"}, {"title": "Results", "content": "Table 3 compares the performance of GearFormer to a baseline method. The baseline method simply generates random sequences that conform to the grammar. GearFormer shows excellent performance on the test set, outperforming the baseline across all metrics. The results for the baseline also highlight the difficulty of finding solutions that are feasible and address multiple design requirements.\nTable 4 shows that GearFormer outperforms or is at par with EDA and MCTS in four out of the five design requirement categories. Because the search methods are specifically designed to only generate valid sequences and can pick only the feasible solutions out of multiple candidates, they demonstrate 100% accuracy on those metrics. They also tend to find more lightweight solutions, at the expense of not addressing the design requirements. It should be emphasized that GearFormer can instantly generate a high-quality solution, compared to the search methods that selected the best solution out of 10,000 candidate solutions evaluated.\nTable 4 also highlights the benefit of our hybrid methods. Compared to the search methods on their own, all design requirement metrics improved with the hybrid methods (in fact, the speed metric is better than GearFormer's). This came at the expense of the weight objective for EDA+GF but for MCTS+GF, the weight objective even improved slightly. Lastly, the hybrid methods only considered 1/10th of the candidate solutions compared to the search methods on their own to achieve such results."}, {"title": "Discussion and Conclusions", "content": "The current work has demonstrated the possibility of solving a challenging mechanical configuration design problem with a Transformer-based model, named GearFormer developed to solve a gear train synthesis problem. GearFormer can not only generate solutions instantly but also outperforms traditional search methods in finding quality solutions that meet design requirements. This is tremendously valuable in assisting engineers to quickly explore multiple solutions within a shorter amount of time. Also, GearFormer could be used to auto-complete a partial gear train design provided by the engineer, either by suggesting or ranking potential sets of subsequent components in real-time. This enables an interactive workflow between the engineer and the tool that is unattainable with traditional search methods.\nWe also introduce hybrid search methods augmented with a generative model, by combining EDA and MCTS with GearFormer. These methods leverage the explorative capability of search methods for early decisions during sequence generation and the generative model's ability to complete the remaining decisions toward high-quality solutions. The hybrid methods found solutions that better address design requirements than the search methods on their own within a shorter amount of time.\nAnother significant contribution of the current work is the introduction of the first dataset on gear train synthesis. We developed a domain specific language and a physics simulator that can be used to generate more datasets in the future. Our language can be extended to incorporate additional grammar and lexicon to produce richer datasets that can be used to train a model for more complex gear train designs.\nFinally, through this work, we hope to have elucidated how engineering design problems can be formulated and solved with a deep generative model approach and provide a strong evidence that it can be effectively utilized in engineering design. We strongly believe that many research opportunities exist in this space with significant implications for the societal innovation."}]}