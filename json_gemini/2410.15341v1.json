{"title": "IKDP : Inverse Kinematics through Diffusion Process", "authors": ["Hao-Tang Tsui", "Yu-Rou Tuan", "Hong-Han Shuai"], "abstract": "It is a common problem in robotics to specify the position of each joint of the robot so that the end point reaches a certain target in space. This can be solved in two ways:\n1. Forward kinematics method (FK)\n2. Inverse kinematics method (IK)\nHowever, inverse kinematics cannot be solved by an algorithm. The common method is the Jacobian inverse technique, and some people have tried to find the answer by machine learning. And in this project, we will show how to use the Conditional Denoising Diffusion Probabilistic Model (DDPM) [1] to integrate the solution of calculating IK.", "sections": [{"title": "I. INTRODUCTION", "content": "The motivation for doing this topic comes from our side project. We found that the inverse kinematics method(IK), which is commonly used to control the movement of human models in game engines, has a lot to be improved, such as the fidelity of movement and the angle of joint rotation accuracy. Therefore, we decided to do research on it.\nInverse kinematics is used to determine the kinematic equations to motion of a robot to reach a desired position. For example, given a 3D model of a human body, if the goal is to change the hand from a relaxed position to a waving position, we can use inverse kinematics to find the angle of the wrist and elbow.\nTherefore, we hope to convert the IK problem into an objective function in machine learning, combined with the denoising diffusion probabilistic models(DDPM) [1] taught this semester, consider the target condition that will be needed in the IK process, so our topic will use conditional DDPM to find IK's solution.\nThat is to train a model F with given target position $(t_x, t_y)$, so that $F(t_x, t_y)$ has the best solution $\\theta$, $\\theta$ is a series of robot joint angles, so that the end of the robot can reach $(t_x,t_y)$. Because we expect the robot's hand to reach a specific target, the target $(t_x, t_y)$ is added to the time embedding and becomes a condition diffusion form."}, {"title": "II. RELATED WORK", "content": "Inverse kinematics method (IK) is responsible for calculating the joint movement required for the end position. It will calculate the angle of each joint from a terminal joint and the length of each bone to form a robotic arm that touches this distal point. At present, IK can be realized through quite a variety of algorithms, such as Jacobian method [3] and machine learning methods that have been gradually proposed in recent years [2]. To sum up, we think that IK is worth improving, so we plan to use machine learning to improve it."}, {"title": "B. Denoising Diffusion Probabilistic Models (DDPM)", "content": "Denoising Diffusion Probabilistic Models (DDPM), as mentioned in the class, continuously removes the noise from a gaussian noise through the encoder and decoder until it becomes the image we want to generate. DDPM can also be done in 1D, which is our topic's task. We would like to use this technology because the task of IK is also related to generation. We want to achieve the task of generating the angle of the joint point of the manipulator through Conditional DDPM [4]."}, {"title": "III. METHODS", "content": "Design a diffusion model $F = (t_x,t_y,t_z)$, given the target position $(t_x, t_y, t_z)$ of the distal joint $t$ and the direction of the solution bone vector (two adjacent joints form a bone vector). With known bone length, we define that there are total N joints on a robotic arm, so there will be N bone vectors. Finally, the bone vectors will be combined into a vector list $A = {A_0, A_1, ..., A_{N-1}}$ of the best solution, and the end of the robotic arm can reach target position $(t_x, t_y,t_z)$, shown as Fig. 2. In three-dimensional space, each bone vector $A_n$ has three components x, y, and z. We define that $A_n$ is the x component of the nth bone, y and z components can be deduced by analogy. See equation (1).\n\\begin{equation}\n\\begin{aligned}\nt_x\\\\ t_y \\\\\nt_z\n\\end{aligned} = \\sum_{n=0}^{N-1} A_n\n\\begin{bmatrix}\n1\\\\1\\\\\n1\n\\end{bmatrix} - \\sum_{n=0}^{N-1} A_n \\\\ \\end{equation}"}, {"title": "B. Propose", "content": "Train a Conditional DDPM model to gradually denoise from $\\theta_T$ to $\\theta_0$. Where $\\theta_T = {\\theta|N(\\mu,\\sigma)}$ represents a list of noise sample from Gaussian, and $\\theta = {\\theta_0,\\theta_1,...\\theta_{N-1}}$ represent the angle to be rotated by each joint. $\\theta_0$ should be close to the ground truth $\\theta_0$, make $t = (t_x, t_y)$ close to ground truth $t = (t_x, t_y)$.\nIn Inverse Kinematics task, it is not enough to use only the diffusion model, because we also need to turn the tip to the target, so we will add condition $t_x, t_y$ to indicate where the tip of the robot arm should point. That is, we hope that t is close to t."}, {"title": "C. Loss Function", "content": "Evaluating the performance of Inverse Kinematics method will need to calculate the distance or difference, so we think Mean-Square Error(MSE) will be a good choice. In our model, there are a total of two losses as indicators for evaluate the performance of the model, and we expect both losses are as low as possible. The two matrices we evaluated, namely:\n1) Distance of t: $||t - \\hat{t}||^2 = \\sqrt{(t_x - \\hat{t_y})^2 + (t_y - \\hat{t_y})^2}$ Evaluates the quality of the model, and represents the differences of the end joint of the robotic arm and target position.\n2) Loss of $\\theta$: $|\\theta - \\hat{\\theta}||^2 = \\sqrt{\\sum_{n=0}^{N-1} (\\theta_n - \\hat{\\theta_n})^2}$ Represents the difference between each joint point and ground truth, and it is the loss function which would do backward."}, {"title": "D. Model Architecture", "content": "In a timestep, we hope that the input to the model is $\\theta_{t-1} = {\\theta_{t-1},\\theta_{t-1},...,\\theta_{t-1}^{N-1}}$, which is a list indicated how many degrees each joint of the robotic arm should turn. After input through a transformer encoder, we can obtain the feature. Concate the feature with the time embedding and condition which is the target position $(t_x, t_y)$. Its output will pass through a few layers of MLP, finally, go through the transformer decoder, and add the residual of the previous $\\theta_{t-1}$ to become the $\\theta_t$ we want, that is, the angle of each joint after 1 timestep of denoising process."}, {"title": "E. Training Process", "content": "We have visualized the training process and data sets. The first is to gradually add noise following the Gaussian distribution to the target point. Although in the normal Cartesian coordinate system, the trend of the Gaussian distribution that he gradually becomes cannot be observed. But you can map it back to the arccost coordinate system, and you will find that it will gradually change from a uniform distribution (because I drew tens of thousands of target coordinates at a time) to a normal distribution."}, {"title": "IV. EXPERIMENTS", "content": "We have visualized the training process and data sets. The first is to gradually add noise following the Gaussian distribution to the target point. Although in the normal Cartesian coordinate system, the trend of the Gaussian distribution that he gradually becomes cannot be observed. But you can map it back to the arccost coordinate system, and you will find that it will gradually change from a uniform distribution (because I drew tens of thousands of target coordinates at a time) to a normal distribution. Please see the Fig. 6 from the uniform distribution at $t_0$ to the normal distribution.\nIn the training part, we compare the output by the model with the correct angle $(\\theta, \\hat{\\theta})$, and visualize the distance between the tip and the actual target after the angle is applied to the robot $(t, \\hat{t})$. It can be found that the latter converges quickly because it is used as a loss function for model training. The former is positively correlated with loss, that is, there is a tendency to gradually decrease, just like training an ordinary Diffusion process, FID will not strictly decrease, but the trend will gradually decrease."}, {"title": "Experiments with different joints", "content": "The first is the experiment on the number of different joint points. We did experiments with 2, 4, and 8 joints respectively. It can be found that the more joints, the smaller the loss. For such a result, we speculate that the more joints the higher the fault tolerance rate. In the experiment of two joint points, there is almost only one set of inverse kinematics solutions for each angle, so the error of one joint angle can easily lead to a long distance from the target."}, {"title": "Experiments at different timesteps", "content": "We think that in this task, unlike DDPM for image generation, the task of generating one-dimensional numbers does not require so many diffusion processes. On the one hand, it can speed up the generation and save unnecessary iterations. After adjusting the parameter settings many times, it can be seen from the experimental results that the highest accuracy rate will be achieved at 80 timesteps, which also verifies the previous speculation."}, {"title": "Compare with other models", "content": "Although this topic is not popular, there are indeed other teams doing research here. See the TableIII. Like IKNET [2] proposed in early 2022, or simply MLP. Therefore, we are here to make some comparisons with other people's work, but because of the different methods, they only provide the mean-square error of the distance from the target, without the distance between each joint, so they only compare the former with the execution time. Our work is much better than other machine learning methods, such as IKNET. In terms of execution time, DDPM [1] is slower than pure MLP or IKNET because it takes many iterations to calculate the answer. However, like the nature of DDPM, it has a relatively high generation quality."}, {"title": "E. Future Work", "content": "In addition to the currently completed content, we are also advancing our project. First of all, we think that the model still has a lot of information to consider, and only the Transformer Encoder/decoder seems to be a bit insufficient. In addition, as mentioned above, this technology can be actually applied to joint control to determine whether the theoretically feasible model will have serious delay or whether it is accurate. Finally, on the topic of inverse kinematics, in fact, in addition to expecting the end of the robot to reach the given coordinates (x, y, z), it is also hoped that the contact angle of the robot will reach (yaw, pitch, roll). We believe that the model plus other design can accomplish this task."}, {"title": "V. CONCLUSION", "content": "In this Final project, we use the DDPM [1] concept to calculate the Inverse kinematic, that is, to generate the angles that each joint of the robot should have under the given target position of the robot tip. At the same time, we changed the ordinary DDPM into a conditional DDPM by adding conditions at the embedding time, so that the model can generate the joints of the robot so that the end touches our given conditions. In terms of generation ability, it is much better than the previous SOTA (IKNET), and the generation speed is also within one second. Finally, through the simplification of the formula, we observe the rotation matrix between the bones and change the formula that was originally calculated separately into an inner product or a parallel addition. The original data generation speed is increased to the millisecond level, and the data set of 100,000 records can be quickly generated."}]}