{"title": "Adaptive Genetic Algorithms for Pulse-Level Quantum Error Mitigation", "authors": ["William Aguilar-Calvo", "Santiago N\u00fa\u00f1ez-Corrales"], "abstract": "Noise remains a fundamental challenge in quantum computing, significantly affecting pulse fidelity and overall circuit performance. This paper introduces an adaptive algorithm for pulse-level quantum error mitigation, designed to enhance fidelity by dynamically responding to noise conditions without modifying circuit gates. By targeting pulse parameters directly, this method reduces the impact of various noise sources, improving algorithm resilience in quantum circuits. We show the latter by applying our protocol to Grover's and Deutsch-Jozsa algorithms. Experimental results show that this pulse-level strategy provides a flexible and efficient solution for increasing fidelity during the noisy execution of quantum circuits. Our work contributes to advancements in error mitigation techniques, essential for robust quantum computing.", "sections": [{"title": "I. INTRODUCTION", "content": "As quantum computing advances toward practical realization, the pervasiveness of hardware sensitivity to noise sources limits its transformative potential. Quantum computers promise extraordinary capabilities for solving problems otherwise intractable for classical systems, such as factoring large numbers, simulating complex quantum systems, and optimizing combinatorial problems [1]. Addressing this challenge is imperative for the next leap in computational power, and achieving scales of practical utility enabled by fault-tolerant quantum computing systems.\nContemporary quantum hardware operates within the constraints of Noisy Intermediate-Scale Quantum (NISQ) technology [2], where noise introduces significant barriers to the fidelity and scalability of quantum operations. As highlighted in Preskill's foundational work on NISQ [2], noise limits the reliability of quantum computations by introducing errors. In turn, reducing error rates prompts innovative methods for error mitigation. Quantum errors arise in various forms including bit-flip and phase-flip errors which respectively alter the logical state and phase of individual qubits [3]. Decoherence processes, characterized by amplitude relaxation (T\u2081) and phase decoherence (T2), degrade quantum information over time [4]. Multi-qubit systems face crosstalk, where unwanted interactions between qubits introduce additional errors during the execution of two- and multi-qubit gates [5]. These error mechanisms underscore the urgent need for scalable and robust strategies to mitigate noise in quantum systems. Since physical mechanisms responsible for the susceptibility of a quantum system to intrinsic and external noise sources tend to be harder to address, software-based strategies constitute the center of attention in this article.\nTraditional Quantum Error Correction (QEC) methods address these challenges by encoding logical qubits into entangled states distributed across multiple physical qubits [6]. For instance, a single logical qubit state |\u03c8\u27e9 = \u03b1|0\u27e9 + \u03b2|1\u27e9 can be transformed into an encoded state:\n|\u03c8\u27e9 \u2192 |\u03c8_L\u27e9 = \u03b1|0_L\u27e9 + \u03b2|1_L\u27e9,\nwhere |0_L\u27e9 and |1_L\u27e9 represent logical states encoded across multiple physical qubits. Syndrome measurements identify errors and enable corrective operations to restore |\u03c8_L\u27e9 to its intended state [6]. While effective, QEC requires significant overhead in qubits and operations, posing challenges for current NISQ hardware. Given these limitations, alternative methods that can effectively operate within NISQ constraints are essential.\nPulse-level control offers a direct means to mitigate noise by manipulating the Hamiltonian of the quantum system, bypassing the abstractions of gate-level programming [7]. The time-dependent Hamiltonian H(t) governs the dynamics of the quantum system and is expressed as:\nH(t) = H_0 + \\sum_k u_k(t)H_k,\nwhere H_0 represents the intrinsic Hamiltonian of the system, H_k are control Hamiltonians corresponding to specific operations, and u_k(t) are time-dependent control parameters applied via external pulses [8]. By precisely adjusting u_k(t), pulse-level control allows the system to steer towards desired quantum states with high fidelity, addressing noise at its source.\nAdvances in pulse optimization techniques such as Gradient Ascent Pulse Engineering (GRAPE) and Chopped Random Basis (CRAB) algorithms [9, 10, 11] have improved the ability to design high-fidelity control pulses [12]. These methods optimize control functions u_k(t) to achieve desired quantum"}, {"title": "A. Contributions", "content": "This paper introduces a novel adaptive pulse-level quantum error mitigation algorithm comprising three main advances:\n1) Adaptive Pulse Parameter Optimization: A new algorithm dynamically adjusts pulse parameters in response to real-time noise measurements, thereby enhancing its responsiveness to fluctuating noise conditions within quantum systems.\n2) Enhanced Fidelity Without Circuit Alteration: The algorithm achieves substantial fidelity improvements in quantum algorithms without requiring modifications to the original circuits, thereby preserving their design and intent.\n3) Empirical Validation on Benchmark Algorithms: The efficacy of the proposed method is empirically demonstrated through enhanced performance metrics in two benchmark quantum algorithms, specifically Grover's and Deutsch-Jozsa algorithms.\nCollectively, our contributions underscore the potential of evolutionary strategies to refine pulse-level control and achieve error mitigation. These also suggest an effective methodology to enhance the reliability of quantum computations on Noisy Intermediate-Scale Quantum (NISQ) devices. By leveraging adaptive optimization techniques, our methodology effectively navigates the noise of current quantum systems, thereby enabling more robust and accurate computational results."}, {"title": "B. Organization of the Paper", "content": "The remainder of this paper is structured as follows:\nSection II provides the necessary theoretical and technical background encompassing noise modeling in quantum computing, state-of-the-art quantum error modeling, quantum error mitigation and correction techniques, and a brief introduction to QuTiP. Section III details the design and implementation of our adaptive pulse-level error mitigation algorithm, covering pulse representation, the genetic algorithm framework, fitness evaluation, implementation specifics, and integration with quantum circuits. Section IV outlines the experimental setup, including benchmark quantum algorithms (Deutsch-Jozsa and Grover), circuit descriptions, noise modeling in simulations, and simulation parameters. Section V presents the experimental results, showcasing fidelity evolution and comparative analyses between optimized and non-optimized pulses for both algorithms. Section VI discusses the implications of our findings, assessing the strengths and limitations identified in the protocol, and synthesizing overall insights while proposing directions for future research. Finally, Section VII concludes by summarizing the key contributions and highlighting the potential impact of our work on advancing quantum error mitigation strategies."}, {"title": "II. BACKGROUND AND PRELIMINARIES", "content": "In this section, we provide the necessary theoretical and technical background behind our method. We begin with an overview of noise modeling in quantum computing, highlighting various types of errors and their mathematical representations. We then discuss techniques for quantum error mitigation (QEM) and contrast these methods with conventional quantum error correction (QEC) schemes. Finally, we introduce QuTiP (Quantum Toolbox in Python), the open-source framework employed for simulating open quantum systems and implementing pulse-level strategies."}, {"title": "A. Noise Modeling in Quantum Computing", "content": "Before delving deeper into the mathematical formalisms, we provide a brief roadmap of this subsection by\n\u2022 Reaffirming the significance of noise in NISQ devices.\n\u2022 Presenting the Lindblad and Kraus frameworks, essential tools for describing open quantum system dynamics.\n\u2022 Reviewing standard noise channels (bit-flip, phase-flip, depolarizing, and others) and outline their parameters and typical use cases.\nThis overview will guide the reader from general considerations to the concrete mathematical models of noise typically used in quantum error mitigation and correction.\nQuantum computing devices are intrinsically vulnerable to environmental noise and operational imperfections, both of which degrade the fidelity of quantum operations. As discussed by Nielsen and Chuang [1], and highlighted by Preskill in the NISQ era context [2], this susceptibility arises from unavoidable interactions between the quantum system and its environment, as well as practical limitations in our ability to implement qubits, gates and measurements. Understanding and modeling these noise mechanisms across multiple qubit modalities constitute central challenges in developing effective Quantum Error Correction (QEC) and Quantum Error Mitigation (QEM) techniques.\nA key theoretical framework used to describe the evolution of open quantum systems under noise and decoherence is"}, {"title": "dp(t)/dt", "content": "the Lindblad master equation. In the Markovian and weak-coupling regime-approximations often valid for contemporary quantum hardware one can write the time evolution of the density matrix \u03c1(t) as [15, 16]:\n= -i[H, \u03c1(t)] + \\sum_k (L_k\u03c1(t)L_k^\u2020 - \\frac{1}{2}{L_k^\u2020L_k, \u03c1(t)}),\nwhere H is the system Hamiltonian and L_k are Lindblad (collapse) operators encoding different decoherence channels. The Lindblad equation provides a continuous-time description of noisy dynamics, capturing processes such as energy relaxation and dephasing.\nAn equivalent yet flexible viewpoint is offered by the operator-sum or Kraus representation of quantum channels [1, 17]. Any completely positive, trace-preserving (CPTP) map E acting on \u03c1 can be expressed as:\nE(\u03c1) = \\sum_l E_l\u03c1E_l^\u2020, \\sum_l E_l^\u2020E_l = I.\nKraus operators {E_l} allow one to switch between the Lindblad and operator-sum representations, providing a versatile framework for modeling a wide variety of noise processes. Below, we outline common noise mechanisms and their standard models, following closely Nielsen and Chuang's [1] description and related works:\n1) Decoherence: Decoherence refers to the process by which a quantum system loses coherence due to unwanted interactions with its environment, transitioning from quantum superpositions to classical mixtures [18]. This fundamentally limits the time over which arbitrary quantum information can be reliably stored. In the Bloch sphere, decoherence typically contracts the sphere along certain directions, eroding the off-diagonal elements of the density matrix and effectively destroying quantum correlations.\n2) Relaxation (Amplitude Damping): Amplitude damping models energy relaxation, such as the decay of an excited state |1\u27e9 to the ground state |0\u27e9. Characterized experimentally by a timescale T\u2081, this process is expressed by the Lindblad operator L_\\text{relax} = \\sqrt{1/T_1} \u03c3^\u2212, where \u03c3^\u2212 = |0\u27e9\u27e81|. In Kraus form [1]:\nE_0 = \\begin{pmatrix} 1 & 0 \\ 0 & \\sqrt{1 - \u03b3} \\end{pmatrix}, E_1 = \\begin{pmatrix} 0 & 0 \\ \\sqrt{\u03b3} & 0 \\end{pmatrix},\nwith \u03b3 related to the damping probability. Amplitude damping drives states toward |0\u27e9, reducing excitation probability and reflecting energy dissipation into the environment.\n3) Dephasing (Phase Damping): Dephasing, affects the relative phase between computational basis states without energy exchange. It is characterized experimentally by T\u2082 and can be modeled by a Lindblad operator L_\\text{dephase} = \\sqrt{1/(2T_2)} \u03c3_z. In Kraus form [1]:\nE_0 = \\sqrt{1 - \u03bb} I, E_1 = \\sqrt{\u03bb} \\begin{pmatrix} 1 & 0 \\ 0 & -1 \\end{pmatrix}.\nDephasing destroys off-diagonal elements of \u03c1, diminishing quantum coherence. T\u2082 \u2264 2T\u2081 often indicates that phase coherence typically decays as fast as or faster than population relaxation.\n4) Discrete Pauli Errors (Bit-Flip, Phase-Flip, Bit-Phase-Flip): Discrete Pauli errors are among the simplest quantum noise models [1]. These occur when a Pauli operator \u03c3_x, \u03c3_y, or \u03c3_z is applied to the state with probability p, leaving the state unchanged with probability 1 \u2013 p. Physically, these can be viewed as sudden, discrete kicks rather than gradual evolutions. Mathematically:\nE(\u03c1) = (1 \u2212 p)\u03c1 + p(\u03c3\u03c1\u03c3),\nwith \u03c3 \u2208 {\u03c3_x, \u03c3_y, \u03c3_z}. In Kraus form:\nE_0 = \\sqrt{1 - p} I, E_1 = \\sqrt{p} \u03c3.\nSpecific channels include:\n\u2022 Bit-Flip: Applies \u03c3_x with probability P_\\text{bit-flip}, flipping |0\u27e9 \u2194 |1\u27e9.\n\u2022 Phase-Flip: Applies \u03c3_z with probability P_\\text{phase-flip}, introducing a relative phase between |0\u27e9 and |1\u27e9.\n\u2022 Bit-Phase-Flip: Applies \u03c3_y with probability P_\\text{bit-phase-flip}, simultaneously flipping the bit value and its relative phase.\nThe discrete channels above constitute composable building blocks useful to model more complex noise sources. They are central to the theory of quantum error correction, where correcting these basic errors implies the ability to correct arbitrary single-qubit errors due to the Pauli basis decomposition. In our case, we make use of the Kraus representation extensively in the sections below.\n5) Depolarizing Error: The depolarizing channel is a symmetric noise model often used for benchmarking [1]. With probability p, it replaces \u03c1 by the maximally mixed state I/2, and with probability 1 \u2013 p leaves it unchanged:\nE_\\text{depol}(\u03c1) = (1 \u2212 p)\u03c1 + \\frac{p}{3} (\u03c3_x\u03c1\u03c3_x + \u03c3_y\u03c1\u03c3_y + \u03c3_z\u03c1\u03c3_z).\nGeometrically, the depolarizing channel uniformly contracts the Bloch sphere toward its center, modeling a highly isotropic form of noise.\n6) Parameters in Simulations: In practical simulations, incorporating noise involves specifying parameters and channels that reflect the target device or scenario:\n\u2022 N: Number of qubits.\n\u2022 T1: Relaxation time (amplitude damping).\n\u2022 T2: Dephasing time.\n\u2022 Probabilities P_\\text{bit-flip}, P_\\text{phase-flip}, P_\\text{depol}, etc., governing discrete error channels.\nBy selecting the appropriate either Lindblad or Kraus operators through experiments and device characterizations, one can realistically simulate noisy quantum circuits. Doing so enables the evaluation of quantum algorithms in the presence of noise and guides the development of QEC and QEM strategies"}, {"title": "B. State of the Art in Quantum Error Modeling", "content": "Contemporary research in quantum computing has produced increasingly refined methods to characterize and simulate noise at different levels of abstraction. Early works primarily considered simplified error channels, such as depolarizing or amplitude damping processes, introduced solely at the gate level [1, 2, 3, 16, 4, 5]. Although these simplified representations were intended to capture essential decoherence mechanisms, they often neglect the intricate interplay between noise and unitary evolution that takes place during the execution of gates. As highlighted by Di Bartolomeo et al. [19], representing noise purely as separate stochastic operations interspersed between ideal gates may fail to fully reflect the underlying Markovian (and more generally, open-system) dynamics that real quantum hardware undergoes.\nRecent frameworks and quantum software toolkits have expanded their capabilities to incorporate more realistic noise models. Standard tools like Qiskit [20], Cirq [21], and Amazon Braket [22] provide built-in functionality to insert Kraus operators or Lindblad-like channels into simulated circuits, enabling a more faithful rendition of device physics. These implementations, however, commonly maintain a strict separation between the intended unitary operations and stochastic error processes [23, 24]. Although effective at capturing state-dependent decay channels and certain adaptive calibration protocols, these methods still presuppose a modular composition of errors that does not inherently account for the continuous-time influence of noise during gate pulse execution.\nAdditional refinements to noise modeling emphasize adaptive calibration and device characterization. For instance, quantum noise tomography [23] and learning-based noise inference [24] seek to extract more detailed noise parameters, potentially incorporating correlations and non-Markovian features. Yet, these techniques typically remain attached to frameworks that insert noise at discrete points in the circuit.\nAs discussed by Di Bartolomeo et al. [19], one can incorporate noise directly into gate definitions by modifying the time evolution that generates each gate. Instead of treating noise as extraneous channels appended before or after an ideal unitary, their formalism suggests building 'noisy gates' that arise naturally from solving the time-dependent Lindblad equation. This perspective ensures that the resultant operations automatically encode the interplay between unitary control and environmental coupling; this paradigm potentially outperforms traditional gate-plus-channel schemes, particularly in regimes where gate durations are not negligible compared to decoherence timescales. While we did not pursue this path in the work reported here due to time constraints, it is a natural extension we will address in future research.\nThe current frontier in quantum computing aims to go beyond traditional static gate-level noise toward noise modeling directly at the pulse level. The resulting paradigm, further informed by advances in tomography, machine learning, and adaptive calibration, paves the way for new strategies in how quantum gates are implemented. Embedding noise-aware techniques into gate design allows experimentalists and theorists to advance toward simulations that more faithfully represent the behavior of NISQ devices. All these strategies ultimately contribute to increase the realism of quantum simulations, reshape strategies for error mitigation, and ultimately enable quantum algorithms with greater physical fidelity and practicality."}, {"title": "C. Quantum Error Mitigation and Correction Techniques", "content": "Quantum Error Correction (QEC) seeks to protect quantum information from errors by redundantly encoding logical qubits into multiple physical qubits. Classical syndrome measurements lead to detecting and correcting certain types of errors without collapsing the encoded quantum state. Reliable quantum computation is possible whenever error rates are below a known thresholds [6]. Albeit successful, QEC implementations are resource-intensive and require significant overhead in terms of qubit count and error rates that are still challenging to achieve on current hardware.\nIn contrast, Quantum Error Mitigation (QEM) aims to reduce the impact of noise without fully correcting it. Instead of achieving fault-tolerance, QEM employs post-processing techniques, calibration methods, and noise extrapolation schemes to partially compensate for errors. For instance, zero-noise extrapolation linearly projects results from multiple runs with artificially amplified noise back to a zero-noise scenario, while probabilistic error cancellation statistically eliminates certain noise contributions [12]. Although QEM does not produce a fully error-corrected logical qubit, it can significantly improve the fidelity of quantum algorithms on NISQ devices, increasing the feasibility of certain algorithms under practical conditions today [9, 10]. Nevertheless, as established by Takagi et al. [25], QEM methods are inherently limited, particularly as circuit depth increases, due to fundamental constraints on the achievable error mitigation without exponential resource overhead. This underscores the complementary nature of QEM and QEC in advancing quantum computing, where QEM offers"}, {"title": "D. Introduction to QuTiP", "content": "To implement and evaluate our adaptive pulse-level quantum error mitigation technique, we rely on Quantum Toolbox in Python (QuTiP) [26], an open-source framework for simulating the dynamics of open quantum systems. QuTiP accommodates various tasks that include noise modeling, time-dependent Hamiltonian evolution, and real-time tracking of quantum states under user-defined control parameters.\n1) Abstract model: A principal component of QuTiP is the Qobj class, which unifies quantum states, operators, and superoperators into a coherent interface [12, 26]. Being an object-oriented framework enables sophisticated manipulations (e.g., tensor products, partial traces, matrix exponentials, and spectral decompositions) using intuitive high-level syntax. For instance, composite systems of multiple qubits can be constructed seamlessly by tensoring single-qubit states or operators.\n2) Open-System Dynamics: Another hallmark feature of QuTiP is its capacity to model open-system dynamics via master equation solvers. The Lindbladian introduced in Section II is usually numerically integrated using the mesolve function by considering the alternative form\n dp(t)/dt = - i[H(t), \u03c1(t)] + (C_j\u03c1(t) - {C_j^\u2020C_j, \u03c1(t)}),\nwhere H(t) is a (potentially time-dependent) Hamiltonian and {C_j} are collapse operators capturing decoherence. In this work, we make use of the mesolve solver, which provides an ensemble-averaged picture of open-system evolution. Meanwhile, mcsolve offers a more granular alternative that unravels the master equation into individual quantum trajectories, capturing stochastic fluctuations that may be obscured in ensemble-averaged treatments. Although mcsolve is especially pertinent when one wishes to model pulse-level noise events on a single-run basis, we chose mesolve in our study to focus on the averaged dynamics and simplify computational overhead. [27]\n3) Integration and Performance: QuTiP integrates efficiently with Python libraries such as NumPy, SciPy, and Matplotlib, allowing seamless transitions from problem formulation to numerical simulation and data visualization."}, {"title": "E. Introduction to QuTiP-QIP", "content": "Building upon the functionalities of QuTiP, the qutip-qip module [12] extends the support to the simulation of pulse-level circuits. The package is intended to model quantum hardware at the time-evolution level, treating gates as time-sequenced control pulses while incorporating noise processes inherent to realistic devices.\n1) Processor Pulse-Level Simulations: Central to qutip-qip is the notion of a Processor, which encapsulates both drift and control Hamiltonians:\nH(t) = H_d + \\sum_j u_j(t) H_j,\nwhere H_d represents the intrinsic system Hamiltonian, and {H_j} are control Hamiltonians modulated by time-dependent coefficients u_j(t). This structure enables direct simulation of pulse dynamics, including imperfections and decoherence.\n2) OptPulseProcessor and Key Parameters: OptPulseProcessor, which applies optimal control methods to refine u_j(t) for desired gate operations specified as pulse sequences, even in the presence of noise. Two parameters are of special interest:\n\u2022 Evolution Time (evo_time): The total duration over which the quantum state evolves under H(t). This defines how long the system interacts with both drift and control fields.\n\u2022 Number of Time Slices (num_tslots): the number of segments in which time evolution is to be discretized for the fine-tuning of u_j(t) at each step. A larger number of segments improves the resolution of pulse shaping at the expense of increased computational resources.\nMathematically, the unitary evolution over an interval \u0394t satisfies\nU(\u0394t) = \\exp(-it [H_d + \\sum_j u_j H_j]).\nAdjusting u_j across num_tslots within a fixed evo_time, results in operations which can approximate target gates with high fidelity.\n3) Simulation Flow: A QuTiP-based simulation consists of three main steps performed in sequence:\n1) Circuit Compilation: Quantum gates are mapped onto Hamiltonian-based pulses that account for the hardware's drift.\n2) Noise Integration: Decoherence models (e.g., collapse operators) or error probabilities are introduced, leveraging QuTip's solvers.\n3) Control Optimization and Evolution: The OptPulseProcessor optimizes {u_j(t)} over time slices. mesolve then integrates the master equation over the specified time range to obtain the final state or measurement statistics.\nThis modular framework includes several Processor subclasses for specific physical systems:"}, {"title": "III. METHODOLOGY", "content": "In this section, we provide a detailed description of the design and implementation of our adaptive pulse-level error mitigation algorithm. The corresponding code has been made available in a GitHub repository under the open-source MIT License as indicated in Code and Data Availability."}, {"title": "A. Pulse Representation and Control", "content": "A pulse is a time series of complex-valued amplitudes with a maximum unit norm, represented as [d_0,...,d_{n-1}]. Each d_j, where j \u2208 {0, . . ., n \u2212 1}, is called a sample. Each system specifies a cycle time dt, which is the finest time resolution available in the pulse coprocessor. This cycle time is typically defined by the sampling rate of the coprocessor's waveform generators. Each sample in a pulse is issued over one cycle, corresponding to a single time step. All pulse durations and time steps are defined and discretized with respect to dt.\nThe ideal output signal has an amplitude given by:\nD_j = \\text{Re} [e^{i(2\u03c0f_jdt + \u03c6_j)}],\nat time f_jdt, where f_j is a modulation frequency and \u03c6_j is a phase. Pulse samples describe only the envelope of the signal produced, which is then mixed in hardware with a carrier signal defined by its frequency and phase [28]."}, {"title": "B. Adaptive Pulse-Level Error Mitigation Algorithm", "content": "We present below an overview of the Adaptive Pulse-Level Error Mitigation Algorithm, which leverages an enhanced Genetic Algorithm framework to dynamically optimize pulse parameters. The algorithm operates over multiple generations, evolving a population of candidate solutions through selection, crossover, mutation, and other genetic operations. Each component of the algorithm is detailed in the Appendix (see Appendix A).\nOur primary contribution is the development of an Adaptive Pulse-Level Error Mitigation Algorithm based on an enhanced Genetic Algorithm (GA) framework. This algorithm dynamically optimizes pulse parameters to mitigate quantum errors induced by noise and decoherence in quantum circuits.\nKey features of our algorithm include:\n\u2022 Feedback-Based Mutation and Crossover Adjustment: We incorporate a dynamic feedback mechanism to adaptively adjust mutation and crossover probabilities, P_\\text{mut}"}, {"title": "F(\u03c1_\\text{final}, \u03c1_\\text{target})", "content": "and P_\\text{cross}, based on observed improvement in the average fitness of the population over successive generations [13]. Specifically, after every I generations, we compute the change in average fitness \u0394F = F_g - F_{g-1}. If \u0394F falls below a predefined improvement threshold \u03b4, indicating stagnation in the search process, we increase P_\\text{mut} and P_\\text{cross} by a small increment \u0394\u03c1 to promote diversity and exploration of new regions in the solution space. Conversely, if significant improvement is observed (\u0394F > \u03b4), we decrease P_\\text{mut} and P_\\text{cross} to fine-tune the search around promising areas, emphasizing exploitation. Mathematically, the adjustment rule can be expressed as:\nP_\\text{mut}^{(g+1)} = \\begin{cases} P_\\text{mut}^{(g)} + \u0394\u03c1, & \\text{if } \u0394F < \u03b4 \\ P_\\text{mut}^{(g)} - \u0394\u03c1, & \\text{otherwise} \\end{cases}\nP_\\text{cross}^{(g+1)} = \\begin{cases} P_\\text{cross}^{(g)} + \u0394\u03c1, & \\text{if } \u0394F < \u03b4 \\ P_\\text{cross}^{(g)} - \u0394\u03c1, & \\text{otherwise} \\end{cases}\nOur adaptive mechanism ensures a balanced search strategy that dynamically responds to the pattern of variation of improvement during the optimization progress. This prevents the algorithm from being trapped by local optima and enhances convergence towards the global optimum.\n\u2022 Diversity Control To prevent premature convergence and maintain genetic diversity within the population, we"}, {"title": "D = 2/N(N-1) \u03a3_(i=1)^(N-1) \u03a3_(j=i+1)^N D_M(x_i, x_j)", "content": "implement diversity control strategies that monitor the genetic variance of the population [29]. We calculate the diversity D using the average Mahalanobis distance between all pairs of individuals in the parameter space. The choice of the average Mahalanobis distance is motivated by its ability to account for correlations between different parameters and provide a scale-invariant measure of diversity. Unlike simpler metrics such as Euclidean distance, the Mahalanobis distance considers the covariance structure of the population, allowing for a more nuanced assessment of genetic variance.The Mahalanobis distance between two individuals x_i and x_j is defined as:\nD_M(x_i, x_j) = \\sqrt{(x_i - x_j)^T \u03a3^{-1} (x_i - x_j)}\nwhere \u03a3 is the covariance matrix of the variables in the population. Diversity D is then the average of Mahalanobis distances across all unique pairs of individuals:\nD = \\frac{2}{N(N-1)} \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} D_M (x_i, x_j)\nwhere N is the population size and D_M(x_i, x_j) is the Mahalanobis distance between individuals i and j. If D falls below a predefined threshold \u03b8, indicating that individuals are becoming too similar, we apply one of the following actions:\n\u2022 Higher Variance Mutation: Increase mutation rate to reintroduce genetic variability.\n\u2022 Individual Replacement: Replace a percentage of the population with new random individuals.\nThis strategy ensures that the algorithm continues to effectively explore the solution space, increasing the likelihood of discovering high-quality solutions that might otherwise be overlooked.\nElitism: The algorithm employs an elitist strategy by retaining the top performing individual(s) from each generation and directly transferring them to the next generation without alteration. This ensures that the best-found solutions are preserved throughout the evolutionary process, preventing the loss of valuable genetic information due to stochastic operations like mutation and crossover. By maintaining an elite set of solutions, we ensure that the algorithm's performance does not degrade over time and that high-fidelity pulse parameters are continuously refined and propagated.\n\u2022 Early Stopping Criterion: To enhance computational efficiency and prevent unnecessary evaluations, we implement an early stopping mechanism that monitors the improvement of the best fitness value over consecutive generations. If no significant improvement (exceeding a minimal threshold \u03f5) is observed in the best fitness after R consecutive generations, we conclude that the algorithm has likely converged to an optimal or near-optimal solution and terminate the optimization process. Formally, if"}, {"title": "F_best^(g)", "content": "F_best^(g) - F_best^(g-R) < \u03f5\nthen the algorithm stops. This criterion helps save computational resources, especially important given the high computational cost associated with simulating quantum systems and evaluating the fitness function.\nParallelization: Recognizing the computational intensity of simulating quantum circuits for fitness evaluations, we adopt a dynamic work-stealing strategy via the SCOOP framework, adopting the framework introduced by Hold-Geoffroy et al. [30]. Under this paradigm, each fitness evaluation constitutes a self-contained task with no inter-task communication. SCOOP relies on a broker-worker [31] design:\n\u2022 Broker process: Manages global scheduling by receiving and redistributing tasks. It connects to workers through a router pattern, holding a central view of the workload to ensure dynamic load balancing. In addition, a publisher socket handles one-to-many broadcast messages, such as requests to terminate or directives to share constants.\n\u2022 Worker processes: Execute tasks in a decentralized manner. Each worker subscribes to the broker's messages and cooperates with other workers by forming a peer-to-peer network. When a worker finishes existing tasks and detects surplus demand, it requests more tasks from the broker, effectively \"stealing\" work. This adaptively levels out the load across all available resources without requiring explicit \u201cfork\u201d or \"join\" calls.\nThis architecture enables SCOOP to distribute hierarchical or nested tasks automatically -each fitness evaluation can spawn subtasks, which in turn can spawn further subtasks without the user explicitly managing inter-process communication. By shifting scheduling and data routing to the broker-worker pattern, the framework seamlessly scales to multi-core or multi-node deployments while minimizing idle CPU time.\n1) Fitness Function: The fitness function is defined as the quantum state fidelity between the final state \u03c1_\\text{final} obtained after applying the pulse sequence and the target state \u03c1_\\text{target}. For arbitrary density matrices \u03c1_\\text{final} and \u03c1_\\text{target}, the fidelity is given by the Uhlmann formula\nF(\u03c1_\\text{final}, \u03c1_\\text{target}) = \\left( Tr \\sqrt{ \\sqrt{\u03c1_\\text{final}} \u03c1_\\text{target} \\sqrt{\u03c1_\\text{final}} } \\right)^2,\nIn the special case where both states are pure, \u03c1_\\text{final} = |\u03c8_\\text{final}\u27e9\u27e8\u03c8_\\text{final}| and \u03c1_\\text{target} = |\u03c8_\\text{target}\u27e9\u27e8\u03c8_\\text{target}|, the fidelity reduces to\nF(\u03c1_\\text{final}, \u03c1_\\text{target}) = |\u27e8\u03c8_\\text{target}|\u03c8_\\text{final}\u27e9|^2."}, {"title": "IV. EXPERIMENTAL SETUP", "content": "In this section, we describe the experimental setup used to evaluate our algorithm. To ensure scalability and efficiency, all experiments were conducted on a MacBook Pro equipped with Apple's M3 chip, which offers integrated CPU, GPU, and Neural Engine capabilities on a single System on Chip (SoC). Table I summarizes the main hardware specifications, demonstrating sufficient computational resources to handle pulse-level quantum simulations and the parallelized fitness evaluations in our genetic algorithm framework."}, {"title": "A. Benchmark Quantum Algorithms", "content": "Well-known quantum algorithms serve as benchmarks for evaluating quantum hardware performance, gate fidelity, and coherence times. Implementing these algorithms at the pulse level on actual quantum devices allows researchers to gather valuable metrics on the scalability, robustness, and accuracy of their experimental setups. Two particularly instructive examples are the Deutsch-Jozsa algorithm, which provides an exponential speedup when determining whether a Boolean function is constant or balanced ([35]), and Grover's algorithm, which offers a theoretical quadratic speedup for unstructured database search ([34]).\nA key measure for benchmarking is the fidelity ([1]) between quantum states. Fidelity quantifies how close two quantum states are and serves as a useful tool for assessing the quality of the implemented quantum operations. The fidelity F(\u03c1, \u03c3) between two density matrices \u03c1 and \u03c3 is defined as"}, {"title": "F(\u03c1,\u03c3)", "content": "F(\u03c1,\u03c3) = (tr\u221a\u03c1^(1/2)\u03c3\u03c1^(1/2))^2.\nIt is symmetric, bounded between 0 and 1, invariant under unitary transformations, and reduces to the overlap between states when one of them is pure. High fidelity indicates that the prepared or evolved state closely matches the ideal target state, making fidelity a natural figure of merit for comparing expected algorithmic outcomes with those observed in experiments."}, {"title": "B. Deutsch-Jozsa Algorithm", "content": "The Deutsch-Jozsa algorithm ([35]) determines whether a given Boolean function f: {0,1} \u2192 {0,1} is constant or balanced with a single evaluation. With four qubits, three are used as inputs and one as an ancilla. The algorithm produces a clear and deterministic expected result, which makes it an excellent initial benchmark. If implemented correctly, measuring the final state after the algorithm indicates whether the function is constant (e.g., ideally measuring |0000\u27e9) or balanced. The fidelity between the experimentally obtained final state and the ideal theoretical outcome quantifies the quality of the hardware and pulse-level control as simulated under various noise regimes.\n1) Circuit Description:\n1) Initialization: Start with the qubit register in the |0000\u27e9 state.\n2) Ancilla Preparation: Apply an X gate to qubit 3 to obtain the state |0001\u27e9.\n3) Superposition: Apply a uniform superposition H\u22974 to the qubit register.\n4) Oracle: Apply an oracle unitary gate U_f implementing a total function f. In the example here, f = XOR.\n5) Superposition: Apply a second uniform superposition H\u22974 to the qubit register after the oracle computation.\n6) Measurement: Measure the qubit register. An |0000\u27e9 outcome indicates a constant function, whereas other results indicate a balanced function."}, {"title": "C. Grover's Search Algorithm", "content": "Grover's algorithm ([34", "Description": "n1) Initialization: Start with the qubit register in the |0000\u27e9 state.\n2) Superposition: Apply a uniform superposition H\u22974 to the qubit register.\n3) Oracle U_f:\na) Preparation: Apply X\u22974 to the qubit register.\nb) Phase Flip (target |1111\u27e9): Use three consecutive CNOT gates", "Reversion": "Apply X\u22974 again to restore all non-marked states to their original form and add a global phase of"}]}