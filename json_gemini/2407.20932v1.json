{"title": "Complete Approximations of Incomplete Queries", "authors": ["Julien Corman", "Werner Nutt", "Ognjen Savkovi\u0107"], "abstract": "This paper studies the completeness of conjunctive queries over a\npartially complete database and the approximation of incomplete queries. Given a\nquery and a set of completeness rules (a special kind of tuple generating dependen-\ncies) that specify which parts of the database are complete, we investigate whether\nthe query can be fully answered, as if all data were available. If not, we explore\nreformulating the query into either Maximal Complete Specializations (MCSs) or\nthe (unique up to equivalence) Minimal Complete Generalization (MCG) that can\nbe fully answered, that is, the best complete approximations of the query from\nbelow or above in the sense of query containment. We show that the MSG can\nbe characterized as the least fixed-point of a monotonic operator in a preorder.\nThen, we show that an MCS can be computed by recursive backward application\nof completeness rules. We study the complexity of both problems and discuss\nimplementation techniques that rely on an ASP and Prolog engines, respectively.", "sections": [{"title": "Introduction", "content": "Completeness is one of the classical dimensions of data quality, well studied both in\nthe context of relational data [1,4,5,7] and more recently in the context of knowledge\ngraphs [6, 12]. An information system may be incomplete because some data has not yet\nbeen inserted, or simply because some information is unavailable for certain records. As\na consequence, a query Q that retrieves data may itself be incomplete, in the sense that\nwhen Q is evaluated over the actual (incomplete) database, some answers to Q over the\nideal (complete) database are missing. Similarly, if Q produces statistics (e.g., count\nanswers), then these statistics may be incorrect.\nOn the other hand, part of the data is often known to be complete. This information\nmay be sufficient to confirm that Q is complete, or, if this is not the case, to produce a\nquery that is complete and approximates Q. The latter task is the one investigated in\nthis paper. More precisely, we consider two natural strategies to approximate Q. The\nfirst strategy consists in producing a complete query Q' that is more general than Q, in\nthe sense that the answers to Q over the ideal (complete) database are a subset of the\nanswers to Q'. In a scenario where one is searching for a specific piece of information,\nthis strategy ensures that it will be retrieved. Instead, the second strategy consists in\nproducing a complete query that is more specific than Q. This can be useful for statistics:\nthe answers to Q may not be complete yet (e.g., for a whole country), but one may already\npublish partial statistics (e.g., for a given region) that are guaranteed to be correct.\nAs a (toy) running example, we will consider a database instance D of a hypothetical\nschool information system in the Italian province of Bolzano. Following the approach\nof [8, 10,13], one can express which (parts of which) tables in D are known to be complete,"}, {"title": "Query Completeness", "content": "Preliminaries We adopt standard notation from databases. We assume an infinite set\neach of relation symbols, constants, and variables. The constants make up the set dom\n(the domain). Terms are constants or variables. For variables, we use upper-case, for\nconstants lower-case letters, tuples are indicated by an overline, like \u0113. For a relation\nsymbol R with arity n, an atom is an expression R(t1, ..., tn), where t\u2081, ..., tn are terms.\nA database instance D is a finite set of ground atoms (facts), that is, atoms that contain\nonly constants. A conjunctive query (CQ) is written as Q(\u016b) \u2190 B, where Q(\u016b) is an atom\nand B a conjunction of atoms. We call B the body of Q and \u016b the head terms. A CQ is\nsafe if all variables of \u016b occur in B. Given a CQ Q(\u016b) \u2190 B and an instance D, a tuple au\nis an answer of Q over D, written Q(D), if a is an assignment of variables from Q to dom\nsuch that &B C D. A query Q is contained in a query Q', written Q \u2286 Q', if for every\ndatabase instance D it holds that Q(D) \u2286 Q'(D). We say that Q and Q' are equivalent if\nQQ' and Q'\u2286 Q. The query Q is strictly contained in Q' if Q is contained in Q' and\nQ' is not equivalent to Q. If Q is contained in Q', then Q' is more general than Q, and Q\nis more special than Q'.\nCompleteness Theory\nWhen stating that data is potentially incomplete, one must\nhave a conceptual complete reference. We model an incomplete database in the style\nof [9] as a pair of database instances D = (D\u00b2, D\u00ba), where D\u00ba C D\u00b2. Here, D\u00b2 is called\nthe ideal state and D\u00ba the available state. In an application, the state stored in a DBMS is\nthe available state, which often represents only a part of the facts that hold in reality. The\nfacts holding in reality constitute the ideal state, which however is unknown.\nGiven a query Q and an incomplete database D = (D\u00b2, D\u00ba), we say that Q is complete\nover D if Q(D\u00b2) = Q(D\u00ba) and we write D = Compl(Q).\nTo specify that parts of a relation instance are complete, we introduce a kind of\nmetadata, which we call table completeness (TC) statements (or TCS for short). A TCS,\nwritten Compl(R(s); G), has two components, a relational atom R(5), where s is a tuple\nof terms, and (a possibly empty) conjunction of atoms G, called condition. Intuitively, a\nTC statement Compl(R(s); G) asserts that table R is complete for all tuples that match s\nand can be joined with G. We denote a TC statement generically as C.\nTo define the semantics of a TCS C, we associate to it a query Qc(5) \u2190 R(5), G.\nThen C is satisfied by D = (D\u00b2, D\u00ba), written D |= Compl(R(5); G), if Qc(D\u00b2) \u2286 R(D\u00ba).\nThis means that the ideal instance D\u00b2 is used to determine the tuples in the ideal instance\nR(D\u00b2) of R that match s and satisfy G, and that the statement C is satisfied if these\ntuples are present in the available version R(D\u00ba). If no TC statement is associated with a\nrelation then we do not know anything about the completeness of that relation.\nLet C be a set of TC statements. We say that C entails the completeness of Q, written\nC = Compl(Q), if for every D it holds that D = C implies D = Compl(Q)."}, {"title": "Query Generalization", "content": "In this section, we study the problem of finding a complete generalization of a (possibly\nincomplete) query. We restrict our scope to the case where all queries (input query and\ngeneralizations) are CQs.\nFirst, we rephrase the well-known characterization of containment among conjunctive\nqueries due to Chandra and Merlin [2] in our formalism.\nProposition 6 (Characterization of Containment). Let Q(\u016b) \u2190 B and Q'(\u016b') \u2190 B' be\nconjunctive queries. Then\nQEQ\n\u03b8\u016b \u2208 Q' (DQ)."}, {"title": "Query Specialization", "content": "As discussed in the introduction, another common way to approximate a query is to\nmake it more specific. Analogously to the previous section, we study the existence and\ncomputation of CQs that specialize Q and are complete wrt a set of TCSs. As in the\npreceding section, all queries mentioned are assumed to be conjunctive queries.\nWe say, that Q' is a complete specialization (CS) of Q wrt a set C of TCSs if Q' \u2286Q\nand C = Compl(Q'). Among those queries, the preferred ones are the maximal ones:\nDefinition 16 (Maximal Complete Specialization). A query Q' is a maximal complete\nspecialization (MCS) of Q wrt a set C of TCSs if:\nQ' is a CS of Q wrt C, and\nit is a maximal one, that is, there exists no query Q\" such that Q\" is a CS of Q and\nQ' is strictly contained in Q\".\nEven though the definition of an MCS is symmetric to the one of an MCG, it will turn\nout that there are important differences between these two settings that require different\napproaches. First, a query may have several non-equivalent MCSs (whereas it admits at\nmost one MCG up to equivalence). Second, a query may admit CSs but no MCS:"}, {"title": "Maximal Complete Instantiations", "content": "Definition 19 (Maximal Complete Instantiation). If C is a set of TCSs, then a maximal\ncomplete instantiation (MCI) of Q wrt C is an instantiation of Q that is complete wrt C\nand maximal wrt containent among these.\nAs an illustration, in the proof sketch of Theorem 17, the query Q' (X) \u2190 conn(X, X)\nis the only MCI for Q wrt C.\nOur approach to compute MCIs revolves around a specific type of substitution that\nwe call a complete unifier, defined as follows:\nDefinition 20 (Complete Unifier). Let Q be a CQ and C a set of TCSs. A complete\nunifier for Q and C is a substitution y such that, for each atom A in the body of Q, there\nis a TCS C = Compl(A'; G) \u2208 C that satisfies\n\u03b3\u0391 = \u03b3\u0391' and\nG C B.\nApplying a complete unifier to Q yields a complete query:\nProposition 21. If y is a complete unifier for Q and a set C of TCSs, then C =\nCompl(Q)."}, {"title": "Adding Atoms", "content": "We can now extend our approach to computing all k-MCSs of a query Q of size n wrt a\nset C of TCSs. Let Ec be the set of all relation names appearing in C. An extension of\nQ is a query obtained by adding atoms to the body of Q. We call an extension fresh if\nthe variables of the added atoms do not appear in Q. A first observation is that a fresh\nextension Q' of Q is a specialization of Q, therefore the MCIs of Q' are CSs of Q.\nNext, a key observation is that the k-MCSs of Q coincide with the MCIs of all\nfresh extensions of Q with n + k - 1 fresh atoms, restricted to MCIs of size \u2264 n + k.\nThe intuition is the following. Let Q' be a CS of Q of size \u2264 n + k. Then there is a\nhomomorphism & from Q to Q'. Let also B' be the set atoms in Q' that have no preimage\nvia 8. Then the size of B' is < n + k \u2212 1. We construct a new query Q\" of size 2n + k \u2212 1\nwhose body consists of the body B of Q, and a fresh version of B'. Then Q' \u2286 Q\".\nMoreover, since Q' is complete, Q\" must have an MCI at least as general as Q'."}, {"title": "Implementation", "content": "We now briefly discuss how we chose platforms to implement our algorithms in the demo\ntool MAGIK [14]."}, {"title": "Implementing Generalization", "content": "At its core the generalization algorithm repeatedly\napplies the GC operator to the database instance D\u0119 until it has reached a fixed point. In\neach round, starting from an instance of the size of the query, a new instance is produced\nby applying TC statements in a forward fashion, until original and new instance are\nidentical. We implemented this via a datalog engine, namely the ASP solver dlv. The\ninstance Do is represented by facts, initially obtained by freezing the query, and the TC\nstatements are translated into TC rules."}, {"title": "Implementing Specialization", "content": "The core operation of the specialization algorithm in\nSection 4 is unification, which makes ASP systems unsuitable as a platform while it is\noffered as a functionality by Prolog. We implemented it in SWI-Prolog. The problem is\ninherently hard, due to the doubly exponential search space."}, {"title": "Conclusion", "content": "In this work, we studied the completeness of conjunctive queries over partially complete\ndatabases where completeness is determined via so-called completeness statements. For\nqueries that cannot be answered completely, we study ways to approximate such queries\nwith more general or more special queries that are complete. In particular, we established\ncharacterizations and algorithms for finding maximal complete specializations (MCSs) or\nthe (unique) minimal complete generalization (MCG). The MCG can be characterized as\nthe least fixed-point of a monotonic operator in a preorder. An MCS can be computed\nthrough unification between the query and completeness statements. The complexity of\nboth problems is studied, and implementation techniques using ASP and Prolog engines\nare discussed.\nWe plan to extend our theory by considering integrity constraints like primary\nand foreign keys, and finite domain constraints, and to enhance our implementation\ntechniques."}, {"title": "A The Complexity of Identifying MCGs", "content": "Recall that DP consists of problems that can be decided by an algorithm that simultane-\nously performs two calls to an NP-oracle. The algorithm responds \"yes\" if the first oracle\ncall returns \"yes\" and the second one returns \u201cno\u201d. Our proof is based on a reduction of a\nDP-complete graph problem, known as Critical 3-colorability [11]:\nGiven a graph, is it true that the graph is not 3-colorable but any subgraph\nobtained by removing one of the edges is 3-colorable?\nProposition 26. For a set C of TC statements and two CQs Q and Q', deciding whether\nQ' = GC(Q) is DP-complete.\nProof. (Membership) That the problem is in DP follows because one can verify that\nQ' = GC(Q) in two steps. For every atom in A' \u2208 D\u0693, one has to find a statement C \u2208 C\nsuch that A' = Tc(DQ). This can be done with one NP-oracle call. Similarly, one has to\nshow for every A \u2208 Dq \\ Doi that such a rule does not exist. This can be done again\nwith one call to an CO-NP oracle.\n(Hardness) We show hardness by reducing the Critical 3-colorability problem.\nAssume we are given a graph G = (V, E) with vertices V and edges E. It is known that\nstarting from G one can construct a Boolean query QG \u2190 BG where:\n$BG = \\bigwedge_{(v_i,v_j)\\in E} Eg(X_i, X_j)$"}, {"title": "B The Number of MCSs for Acyclic Sets of TC Statements", "content": "Theorem 28. et Q be a query and C an acyclic set of TCSs such that exactly s relations\nnames appear in C. Then the number of atoms in a MCS of Q wrt C is in O(|Q|\u00d7 |C|s+1).\nProof. We analyze the number of atoms that one needs to add to Q (in the worst case)\nin order to make it complete. We observe that some atoms in Q may need to be also\ninstantiated but that does not affect the maximal number of atoms that one may need to\nconsider. We also observe that adding more atoms may only create queries that are more\nspecial thus they wont be maximal any more.\nSince the set of TCSs is acyclic we can create a total order on the relation names\nR1,..., Rn in C such that if i < j then there is no TC statement with Rj in the head and\nan Ri-atom in the condition. Further, for any relation that occurs in the condition of\nsome TC statement with Rj as a head does not have and R\u2081-atom in the condition, and\nso on recursively. In other words, completeness of Rj-atoms does not depend on the\ncompleteness of Ri-atoms."}, {"title": "C Complete Unifiers Make Queries Complete", "content": "Applying a complete unifier to Q yields a complete query:\nProposition 29. If y is a complete unifier for a CQ Q and set C of TCSs, then C =\nCompl(Q).\nProof. First let us recall the completeness characterization for minimal queries. Let C be\na set of TCSs and Q(\u016b) \u2190 B be a minimal query then it holds that C = Compl(Q) iff\n0B C TC(0B). In other words, C = Compl(Q) iff for each A \u2208 B there exists a TCS\nC = Compl(A'; G) \u2208 C such that\n$\\Theta A \\in T_C(\\Theta B) = \\{\\beta A' | \\beta \\text{ is a substitution and } \\beta G \\subseteq \\Theta B\\}.$", "latex": ["BG = \\bigwedge_{(v_i,v_j)\\in E} Eg(X_i, X_j)", "BG^{(i,j)}= \\bigwedge_{(v_l,v_k) \\in E \\setminus \\{(v_i,v_j)\\} } Eg(X_l, X_k),", "\\Theta A \\in T_C(\\Theta B) = \\{\\beta A' | \\beta \\text{ is a substitution and } \\beta G \\subseteq \\Theta B\\}."]}, {"title": "D Maximal Instantiations are Produced by Complete Unifiers", "content": "Theorem 30. Let C be a set of TCSs, Q a query, and Q' a complete instantiation of Q\nwrt C. Then there is a complete unifier y for Q and C such that Q' \u2286 YQ.\nProof. We restate again characterization (2) that we established in the preceding proof.\nLet C be a set of TCSs and Q(\u016b) \u2190 B be a minimal query then it holds that C =\nCompl(Q) iff B C Tc (0B). For a minimal query Q, it holds that C = Compl(Q) iff for\neach A \u2208 B there exists a TC statement C = Compl(A';G) \u2208 C such that\n$\\Theta A_i \\in T_{C_i}(\\Theta B) = \\{\\beta A'_i | \\beta \\text{ is a substitution and } \\beta G_i \\subseteq \\Theta a' B\\}."}, {"title": "E The k-MCS Algorithm is Correct", "content": "First we recall the algorithm (in this document listed as Algorithm 3) that returns all\nk-MCSs for a given query Q and set of TCSs C.\nTheorem 31 (k-MCS Algorithm). Let Q be a CQ, C a set of TCSs, k a nonnegative\ninteger and k-MCS(Q, C) be the set of queries returned by Algorithm 3. Then for every\nquery Q':\nQ' \u2208 k-MCS(Q, C) iff Q' is a k-MCS of Q wrt C.\nProof. Let b be the size of Q, i.e. the number of atoms in Q.\n(Soundness). We show that the algorithm only returns complete specializations of Q of\nsize \u2264 n + k."}]}