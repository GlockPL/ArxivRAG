{"title": "Complete Approximations of Incomplete Queries", "authors": ["Julien Corman", "Werner Nutt", "Ognjen Savkovi\u0107"], "abstract": "This paper studies the completeness of conjunctive queries over a\npartially complete database and the approximation of incomplete queries. Given a\nquery and a set of completeness rules (a special kind of tuple generating dependen-\ncies) that specify which parts of the database are complete, we investigate whether\nthe query can be fully answered, as if all data were available. If not, we explore\nreformulating the query into either Maximal Complete Specializations (MCSs) or\nthe (unique up to equivalence) Minimal Complete Generalization (MCG) that can\nbe fully answered, that is, the best complete approximations of the query from\nbelow or above in the sense of query containment. We show that the MSG can\nbe characterized as the least fixed-point of a monotonic operator in a preorder.\nThen, we show that an MCS can be computed by recursive backward application\nof completeness rules. We study the complexity of both problems and discuss\nimplementation techniques that rely on an ASP and Prolog engines, respectively.", "sections": [{"title": "1 Introduction", "content": "Completeness is one of the classical dimensions of data quality, well studied both in\nthe context of relational data [1,4,5,7] and more recently in the context of knowledge\ngraphs [6, 12]. An information system may be incomplete because some data has not yet\nbeen inserted, or simply because some information is unavailable for certain records. As\na consequence, a query Q that retrieves data may itself be incomplete, in the sense that\nwhen Q is evaluated over the actual (incomplete) database, some answers to Q over the\nideal (complete) database are missing. Similarly, if Q produces statistics (e.g., count\nanswers), then these statistics may be incorrect.\nOn the other hand, part of the data is often known to be complete. This information\nmay be sufficient to confirm that Q is complete, or, if this is not the case, to produce a\nquery that is complete and approximates Q. The latter task is the one investigated in\nthis paper. More precisely, we consider two natural strategies to approximate Q. The\nfirst strategy consists in producing a complete query Q' that is more general than Q, in\nthe sense that the answers to Q over the ideal (complete) database are a subset of the\nanswers to Q'. In a scenario where one is searching for a specific piece of information,\nthis strategy ensures that it will be retrieved. Instead, the second strategy consists in\nproducing a complete query that is more specific than Q. This can be useful for statistics:\nthe answers to Q may not be complete yet (e.g., for a whole country), but one may already\npublish partial statistics (e.g., for a given region) that are guaranteed to be correct.\nAs a (toy) running example, we will consider a database instance D of a hypothetical\nschool information system in the Italian province of Bolzano. Following the approach\nof [8, 10,13], one can express which (parts of which) tables in D are known to be complete,"}, {"title": "2 Query Completeness", "content": "Preliminaries We adopt standard notation from databases. We assume an infinite set\neach of relation symbols, constants, and variables. The constants make up the set dom\n(the domain). Terms are constants or variables. For variables, we use upper-case, for\nconstants lower-case letters, tuples are indicated by an overline, like \u0113. For a relation\nsymbol R with arity n, an atom is an expression R(t1, ..., tn), where t\u2081, ..., tn are terms.\nA database instance D is a finite set of ground atoms (facts), that is, atoms that contain\nonly constants. A conjunctive query (CQ) is written as Q(\u016b) \u2190 B, where Q(\u016b) is an atom\nand B a conjunction of atoms. We call B the body of Q and \u016b the head terms. A CQ is\nsafe if all variables of \u016b occur in B. Given a CQ Q(\u016b) \u2190 B and an instance D, a tuple au\nis an answer of Q over D, written Q(D), if a is an assignment of variables from Q to dom\nsuch that &B C D. A query Q is contained in a query Q', written Q \u2286 Q', if for every\ndatabase instance D it holds that Q(D) \u2286 Q'(D). We say that Q and Q' are equivalent if\nQQ' and Q'\u2286 Q. The query Q is strictly contained in Q' if Q is contained in Q' and\nQ' is not equivalent to Q. If Q is contained in Q', then Q' is more general than Q, and Q\nis more special than Q'.\nCompleteness Theory When stating that data is potentially incomplete, one must\nhave a conceptual complete reference. We model an incomplete database in the style\nof [9] as a pair of database instances D = (D\u00b2, D\u00ba), where D\u00ba C D\u00b2. Here, D\u00b2 is called\nthe ideal state and D\u00ba the available state. In an application, the state stored in a DBMS is\nthe available state, which often represents only a part of the facts that hold in reality. The\nfacts holding in reality constitute the ideal state, which however is unknown.\nGiven a query Q and an incomplete database D = (D\u00b2, D\u00ba), we say that Q is complete\nover D if Q(D\u00b2) = Q(D\u00ba) and we write D = Compl(Q).\nTo specify that parts of a relation instance are complete, we introduce a kind of\nmetadata, which we call table completeness (TC) statements (or TCS for short). A TCS,\nwritten Compl(R(s); G), has two components, a relational atom R(5), where s is a tuple\nof terms, and (a possibly empty) conjunction of atoms G, called condition. Intuitively, a\nTC statement Compl(R(s); G) asserts that table R is complete for all tuples that match s\nand can be joined with G. We denote a TC statement generically as C.\nTo define the semantics of a TCS C, we associate to it a query Qc(5) \u2190 R(5), G.\nThen C is satisfied by D = (D\u00b2, D\u00ba), written D |= Compl(R(5); G), if Qc(D\u00b2) \u2286 R(D\u00ba).\nThis means that the ideal instance D\u00b2 is used to determine the tuples in the ideal instance\nR(D\u00b2) of R that match s and satisfy G, and that the statement C is satisfied if these\ntuples are present in the available version R(D\u00ba). If no TC statement is associated with a\nrelation then we do not know anything about the completeness of that relation.\nLet C be a set of TC statements. We say that C entails the completeness of Q, written\nC = Compl(Q), if for every D it holds that D = C implies D = Compl(Q).\nExample 1. We consider a simplified database \u201cschoolBolzano\u201d, modeling schools in\nthe province of Bolzano. It consists of the three tables below:\npupil(pname, code, sname), school(sname, type, district), learns (pname, lang)."}, {"title": "3 Query Generalization", "content": "In this section, we study the problem of finding a complete generalization of a (possibly\nincomplete) query. We restrict our scope to the case where all queries (input query and\ngeneralizations) are CQs.\nFirst, we rephrase the well-known characterization of containment among conjunctive\nqueries due to Chandra and Merlin [2] in our formalism.\nProposition 6 (Characterization of Containment). Let Q(\u016b) \u2190 B and Q'(\u016b') \u2190 B' be\nconjunctive queries. Then\nQEQ\n\u03b8\u016b \u2208 Q' (DQ).\n1 \"Freezing\" variables is a well-known concept in logic programming and database theory, which\nallows one to treat a variable like a constant."}, {"title": "4 Query Specialization", "content": "As discussed in the introduction, another common way to approximate a query is to\nmake it more specific. Analogously to the previous section, we study the existence and\ncomputation of CQs that specialize Q and are complete wrt a set of TCSs. As in the\npreceding section, all queries mentioned are assumed to be conjunctive queries.\nWe say, that Q' is a complete specialization (CS) of Q wrt a set C of TCSs if Q' \u2286Q\nand C = Compl(Q'). Among those queries, the preferred ones are the maximal ones:\nDefinition 16 (Maximal Complete Specialization). A query Q' is a maximal complete\nspecialization (MCS) of Q wrt a set C of TCSs if:\nQ' is a CS of Q wrt C, and\nit is a maximal one, that is, there exists no query Q\" such that Q\" is a CS of Q and\nQ' is strictly contained in Q\".\nEven though the definition of an MCS is symmetric to the one of an MCG, it will turn\nout that there are important differences between these two settings that require different\napproaches. First, a query may have several non-equivalent MCSs (whereas it admits at\nmost one MCG up to equivalence). Second, a query may admit CSs but no MCS:\nTheorem 17. There is a query Q and set C of TCSs such that Q admits CSs wrt C, none\nof which is maximal.\nProof. Consider a schema with a binary relation conn that specifies whether two cities\nare connected via a direct flight, and let C be the TCS Compl(conn(X, Y); conn(Y, Z)),\nwhich states that the data is complete for all (direct) connections that can be extended.\nThe query Q(X) \u2190 conn(X,Y), which retrieves all cities with an outgoing flight, is not\ncomplete wrt {C}. As an illustration, consider the incomplete database D = (D\u00b2, D\u00ba)\nwhere D\u00b2 = {conn(a, b), conn(b, c), conn(d,e)} and D\u00ba = {conn(a, b), conn(b, c)}. The\ndatabase D satisfies C, but Q(D\u00b2) \u00a3 Q(D\u00ba).\nNow let Q' be any complete specialization of Q wrt C. Because Q' is complete, its\nbody must contain a set Ak of atoms that identifies a round trip of length k for some\nk \u2265 1, having the form Ak = {conn(X0, X1), conn(X1, X2), . . ., conn(Xk\u22121, Xo)}, and\nQ' must project exactly one of these variables.\nLet k' be the largest k for which this holds, and consider the query Q2k\u2032 (X0) \u2190 A2k\u2032\u00b7\nThis query is also a complete specialization of Q. Moreover, the function dk that maps\neach Xi to Xi mod k is a homomorphism from Q2k/ to Q', which implies Q' \u2286 Q2k/\u2022\nHowever, Ak cannot be mapped to A2k/ (i.e., the body of Q), therefore there is no\nhomomorphism from Q' to Q2k', which implies Q2k' Z Q'. So Q' is not an MCS.\nThese observations lead us to investigate restrictions on a set C of TCSs that guarantee\nthe set of CSs (thus also of MCSs) of a query wrt C to be finite. We define the dependency"}, {"title": "5 Implementation", "content": "We now briefly discuss how we chose platforms to implement our algorithms in the demo\ntool MAGIK [14].\nImplementing Generalization At its core the generalization algorithm repeatedly\napplies the GC operator to the database instance D\u0119 until it has reached a fixed point. In\neach round, starting from an instance of the size of the query, a new instance is produced\nby applying TC statements in a forward fashion, until original and new instance are\nidentical. We implemented this via a datalog engine, namely the ASP solver dlv. The\ninstance Do is represented by facts, initially obtained by freezing the query, and the TC\nstatements are translated into TC rules.\nFor example, the query Qppb(N) would be translated into the facts pupil' (n',c',s'),\nand school' (s', primary, merano), while the statement Cpb would be translated into the\nrule pupil\u00ba (N, C, S) \u2190 pupil\u00b2 (N, C, S), school (S,T, merano)). To distinguish original\nand new atoms, the relation symbols are either labeled with the superscript \u00b2, standing\nfor \"ideal\", or \", standing for \"available\". A fixed point is reached if each \u201cideal\u201d fact is\ntranslated into an \"available\" fact.\nWhile the ASP functionality is not used here, it becomes beneficial when taking\naccount of disjunctive constraints such as finite domain constraints.\nImplementing Specialization The core operation of the specialization algorithm in\nSection 4 is unification, which makes ASP systems unsuitable as a platform while it is\noffered as a functionality by Prolog. We implemented it in SWI-Prolog. The problem is\ninherently hard, due to the doubly exponential search space.\nFor instance, let us consider the query Q1 \u2190 learns(N, L), and the set of TCSs\nfrom our running example, minus the TCS Cpb, and extended with Compl(pupil(N,\nC, S); class (C, S, L, halfDay)) and Compl(pupil(N, C, S); class(C, S, L, fullDay)). The\nsearch for all 3-MCSs would run out of memory.\n4\nTo avoid this we implemented several optimizations. Briefly, to compute k-MCSs,\nwe consider extensions of size 0, then 1, 2, ..., k. For j > i, the i-MCSs are likely to\nbe identical to the j-MCSs. By keeping in memory the list of maximal specializations\ncollected so far, we can compare them for containment with the currently analyzed\nextensions. This step reduces the search space at line 2 of Alg. 3. This way, we reduce the\nnumber of specializations that we store, and this reduces memory consumption. Further\noptimizations can be implemented in the presence of integrity constraints (e.g., foreign\nkeys) which we do not present in this paper.\nWe performed preliminary tests of our optimized code, and reached size |Q1| +7 after\naround more than 2 hours. The average running times (over multiple runs) are reported in\nTable 1. We observe that the running time grows exponentially with the number of atom\nadded to the query."}, {"title": "6 Conclusion", "content": "In this work, we studied the completeness of conjunctive queries over partially complete\ndatabases where completeness is determined via so-called completeness statements. For\nqueries that cannot be answered completely, we study ways to approximate such queries\nwith more general or more special queries that are complete. In particular, we established\ncharacterizations and algorithms for finding maximal complete specializations (MCSs) or\nthe (unique) minimal complete generalization (MCG). The MCG can be characterized as\nthe least fixed-point of a monotonic operator in a preorder. An MCS can be computed\nthrough unification between the query and completeness statements. The complexity of\nboth problems is studied, and implementation techniques using ASP and Prolog engines\nare discussed.\nWe plan to extend our theory by considering integrity constraints like primary\nand foreign keys, and finite domain constraints, and to enhance our implementation\ntechniques."}]}