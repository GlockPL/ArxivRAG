{"title": "Exploring Facets of Language Generation in the Limit", "authors": ["Moses Charikar", "Chirag Pabbaraju"], "abstract": "The recent work of Kleinberg and Mullainathan [KM24] provides a concrete model for language generation in the limit: given a sequence of examples from an unknown target language, the goal is to generate new examples from the target language such that no incorrect examples are generated beyond some point. In sharp contrast to strong negative results for the closely related problem of language identification, they establish positive results for language generation in the limit for all countable collections of languages. Follow-up work by Raman and Tewari [RT24] studies bounds on the number of distinct inputs required by an algorithm before correct language generation is achieved namely, whether this is a constant for all languages in the collection (uniform generation) or a language-dependent constant (non-uniform generation).\nWe show that every countable language collection has a generator which has the stronger property of non-uniform generation in the limit. However, while the generation algorithm of [KM24] can be implemented using membership queries, we show that any algorithm cannot non-uniformly generate even for collections of just two languages, using only membership queries.\nWe also formalize the tension between validity and breadth in the generation algorithm of [KM24] by introducing a definition of exhaustive generation, and show a strong negative result for exhaustive generation. Our result shows that a tradeoff between validity and breadth is inherent for generation in the limit. Finally, inspired by algorithms that can choose to obtain feedback, we consider a model of uniform generation with feedback, completely characterizing language collections for which such uniform generation with feedback is possible in terms of an abstract complexity measure of the collection.", "sections": [{"title": "Introduction", "content": "Consider the following algorithmic problem: given as input an infinite stream of strings from an unknown, target language (one of a known collection of languages), learn to generate new and previously unseen strings also belonging to this target language in the limit. This problem was recently formalized in the work of [KM24] with a view to synthesize the core problem at the heart of large language models. The same problem, but with the goal of identifying the target language in the collection instead of simply generating from it, has been extensively studied in classical work on language identification in the limit [Gol67, Ang79, Ang80]. In fact, we have a precise characterization [Ang79, Ang80] of the collections of languages for which this problem is tractable\u2014as it turns out, for essentially any interesting collection of formal languages (any collection at all that is not finite, e.g., regular, context-free, context-sensitive), the language identification problem is intractable, not just in the amount of computational power that an algorithm might require, but in a strict computability sense\u2014any algorithm can be fed inputs consistent with a target language in such a way that the algorithm makes an incorrect guess of the target language infinitely often.\nGiven the strong negative results for language identification, [KM24] showed a remarkable positive result for language generation. They showed that language generation is tractable for every countable collection of languages! Their work gives a simple and elegant algorithm, which, given any stream of input strings from any target language $K$ in a countable collection $C = {L_1, L_2, ...}$, generates a sequence of previously unseen strings such that beyond a finite time step $t$, the generated strings all belong to the unknown language $K$. Furthermore, they show that this algorithm can be implemented with only membership query oracle access to the collection $C$. Namely, the algorithm simply needs to be able to ask queries of the form \"does $w$ belong to $L_i$?\" for any string $w$ in the universe and language $L_i \\in \u0421$.\nGiven that this is possible, it is natural to ask for more. How quickly can we hope to achieve this generation in the limit guarantee? In fact, the work of [KM24] shows that a stronger guarantee of this type can be achieved for finite collections of languages, as soon as $t^*$ many distinct strings are seen, where $t^*$ depends neither on the target language nor its enumeration order, but is only a function of the collection $C$. The algorithm that achieves this guarantee is quite different from their all-purpose algorithm which achieves generation in the limit more generally for all countable collections. Inspired by this, very recent work of [RT24] seeks to obtain a precise characterization of the collections of languages (beyond just finite collections) for which such guarantees can be obtained. Adopting their terminology, the collections for which $t^*$ may depend only on the target language, but not on its enumeration order, are said to be non-uniformly generatable, whereas the collections for which $t^*$ is a function of the language collection, and depends neither on the target language nor its enumeration order are said to be uniformly generatable. [RT24] show that the collections that are uniformly generatable are exactly those that have a bounded complexity measure, termed as the closure dimension. They leave the characterization of collections that can be non-uniformly generated largely open.\nA different line of inquiry, also motivated from the work of [KM24], stems from a tradeoff between validity and breadth which the generation algorithm of [KM24] has to incur. Concretely, the algorithm starts off generating invalid strings, then steadily refines its hallucinations, before eventually settling to generate from an increasingly small subset of the language. Thus, en route to becoming a valid generator, it appears that the algorithm has to sacrifice on generating the entire bulk of the target language. This phenomenon also notoriously shows up in the form of mode collapse while training generative adversarial networks [AB17, ACB17]. As an open direction in their work, [KM24] asked if such a tradeoff is provably necessary for achieving generation in the limit."}, {"title": "Overview of Results", "content": "As our first result, we show that it is possible to non-uniformly generate in the limit from every countable language collection $C = {L_1, L_2, ...}$. We give a simple algorithm (Section 3), which has the property that it generates a valid, unseen string from the target language being enumerated as input, as soon as it sees a fixed constant number of distinct strings in the enumeration, where this constant depends only on the target language and the collection, but not the enumeration order. We note that [KM24]'s algorithm for generation in the limit does not satisfy this latter property namely, for adversarial enumerations of the target language, their algorithm could take arbitrarily long before starting to validly generate. Thus, in addition to being a different algorithm than that of [KM24] for generation in the limit, our algorithm satisfies a stronger property.\nTheorem 1 (Non-uniform Generation for Countable Collections). There exists an algorithm that non-uniformly generates in the limit from every countable collection of languages.\nTheorem 1 also answers an open question raised by [RT24], who asked if every countable collection can be non-uniformly generated in the limit, in the affirmative. The language-dependent constant for the number of distinct strings that our non-uniform generation algorithm must see is formalized in terms of a non-uniform complexity measure of the language (see Definition 6, Theorem 5).\nDespite not being a non-uniform generation algorithm, the algorithm of [KM24] has the attractive property that it can be implemented using only membership queries. Namely, their generation algorithm can be implemented given access to an oracle that can answer queries of the form \u201c$w \\in L_i$?\u201d for any string $w$ and language $L_i \\in C$ of the algorithm's choosing. Given this, one may ask if our non-uniform generation algorithm from above can also be implemented with sole access to such a membership query oracle. Our next result provides a strong negative answer to this question.\nTheorem 2 (Non-uniform Generation Membership Query Lower Bound). Any algorithm that non-uniformly generates from all countable collections cannot be solely implemented with membership queries.\nOur lower bound in fact shows that a generation algorithm that only issues membership queries cannot even non-uniformly generate from all finite (even size 2!) collections. This result shows that non-uniform generation provably requires more computational power in the form of different and stronger oracles. We note that our result does not contradict the closure-based uniform generation algorithm of [KM24], which can be implemented using membership queries. The key detail is that their algorithm starts off with a small piece of additional information about the collection; perhaps surprisingly, we find that this information is entirely crucial (see also the discussion in Section 4).\nOur next result addresses the open question in [KM24] regarding the tradeoff between validity and breadth in generation. Towards this, we propose a definition of exhaustive generation in the limit. This definition still requires an algorithm to eventually always generate from the target language (validity). However, there is an additional requirement concerning breadth of generation: beyond some finite time, it ought to be possible to terminate the input entirely and stop looking at additional examples. If the algorithm is now asked to continue generating strings indefinitely, it should be the case that the set of strings it would go on to generate, when combined with the input seen so far and the strings it previously generated, cover the entirety of the target language. We formalize these requirements in Definition 5, and show a strong negative result for exhaustive generation."}, {"title": "Uniform/Non-uniform Generation", "content": "In the case that the collection $C$ is finite, [KM24] additionally showed that it is possibly to construct an algorithm that uniformly generates from languages in $C$: namely, as soon as the algorithm sees $t^* = t^*(C)$ many distinct strings from any $K \\in C$, irrespective of $K$ and its enumeration order, it generates from $K \\setminus S_t$ successfully for every $t > t^*$. Inspired by this, the recent work of [RT24] formalizes the following distinctions of \u201cnon-uniform\" and \"uniform\" generation of a language.\nDefinition 2 (Non-uniform generation in the limit (Definition 3 in [RT24])). An algorithm non-uniformly generates in the limit from languages in a collection $C$, if for any language $K \\in C$, there exists a $t^* = t^*(C, K)$ such that for any enumeration of $K$ presented to the algorithm, the string $z_t$ generated by the algorithm at time step $t$ belongs to $K \\setminus S_t$ for all $t$ satisfying $|S_t| \\geq t^*$.\nDefinition 3 (Uniform generation in the limit (Definition 4 in [RT24])). An algorithm uniformly generates in the limit from languages in a collection $C$, if there exists a $t^* = t^*(C)$ such that for any language $K \\in C$ and any enumeration of $K$ presented to the algorithm, the string $z_t$ generated by the algorithm at time step $t$ belongs to $K \\setminus S_t$ for all $t$ satisfying $|S_t| \\geq t^*$.\n[RT24] generalize the uniform generation result of [KM24] for finite collections to possibly infinite collections by showing that any collection $C$ of languages having bounded complexity (defined in terms of having a finite \"closure dimension\") admits uniform generation. Furthermore, if a collection $C$ has infinite closure dimension, then it is not possible to uniformly generate from languages in $C$.\nDefinition 4 (Closure dimension). The closure dimension of a collection $C$ of languages is the size of the largest set $S = {x_1,...,x_a}$, such that the intersection of all languages in $C$ that contain $S$ is finite."}, {"title": "Exhaustive Generation", "content": "The generation algorithm of [KM24] exhibits a tension between validity of outputs and breadth of generation, as also stated by the authors. Namely, the algorithm starts off by generating strings that could possibly not belong to the target language $K$ for a while, before eventually settling to generate from subsets of $K$ that seemingly get smaller and smaller. [KM24] leave the problem of bridging this gap open, asking if it is possible to construct an algorithm that generates from $K$ with breadth (i.e., does not miss out on generating any strings from $K$), or if there is a formal sense in which such a tradeoff is necessary. To model this tradeoff, we propose a definition of exhaustive generation.\nFor this, we consider a generating algorithm $A$, which at any time $t$, maps $S_t$ to a generator $G_t : IN \\rightarrow \\Sigma^*$. We can imagine that the string generated by the algorithm at time step $t$ is simply $G_t(1)$. However, we want to also consider what happens if the input were to be terminated beyond time step $t$. In this case, we want to study the sequence of strings $G_t(1), G_t (2), G_t (3), . . .$ that would be generated by $G_t$-we can think of this latter scenario to be a form of \"generate-only\" mode that is implicitly defined by the generator $G_t$. We use the shorthand $Z_{<t}$ to denote the set of distinct strings in the sequence $G_1(1), G_2(1), . . ., G_{t-1}(1)$, and the shorthand $Z_{>t}$ to denote the set of distinct strings in the sequence $G_t(1), G_t (2), . . .$ generated by $G_t$ were it to go into generate-only mode from time $t$.\nDefinition 5 (Exhaustive Generation). A generating algorithm $A$ exhaustively generates in the limit from languages in a collection $C$, if for any $K \\in C$ and any enumeration of $K$, there exists $t^* < \\infty$ such that for any $t > t^*$, it holds that"}, {"title": "Non-uniform Language Generation for a Countable Collection", "content": "In this section, we show that every countable collection $C$ of languages can be non-uniformly generated. We consider $C$ to be specified as a fixed enumeration $C = {L_1, L_2, L_3, . . .}$.\nAlgorithm Consider the algorithm, which at step $t$ in the enumeration of its input, initializes $I_t = \\Sigma^*$, and iterates through the languages $L_1,..., L_t$ in this order. Whenever it encounters a language $L_i$ that contains $S_t$, it checks if $|I_t \\cap L_i| = \\infty$. If it is, then it updates $I_t$ as $I_t = I_t \\cap L_i$. Otherwise, it skips over $L_i$, and leaves $I_t$ unaffected. Thus, throughout the algorithm's iteration over $L_1,..., L_t$, the following invariants are maintained: (1) $I_t$ is an infinite set, and (2) $I_t$ is the intersection of a finite set of languages that contain $S_t$. The algorithm then generates an arbitrary string from $I_t \\setminus S_t$.\nWe will now show that the above algorithm non-uniformly generates from languages in $C$. We will specify the non-uniform guarantee of the algorithm in terms of the non-uniform complexity of languages in the collection $C$.\nDefinition 6 (Non-uniform Complexity). Given $C = {L_1, L_2, L_3,...}$, for any $i \\in IN$, define the non-uniform complexity $m_C(L_i)$ of $L_i$ as\n$m_C(L_i) := max\\{\\bigcap_{L\\in C'} L : C' \\subseteq {L_1, ..., L_i}, C' \\ni L_i, \\bigcap_{L\\in C'} L  < \\infty\\}.$   (1)\nTheorem 5. For any language $L_{i^*} \\in C$, and any enumeration of $L_{i^*}$ presented as input to the above algorithm, the algorithm generates from $L_{i^*} \\setminus S_t$ for all $t$ satisfying\n$|S_t| \\geq max(i^*, m_C(L)) + 1.$  (2)"}, {"title": "Lower Bound for Non-uniform Language Generation Using Only Membership Queries", "content": "Given that the generation algorithm of [KM24] can be implemented using membership queries, it is natural to ask if our non-uniform generation algorithm from above can also be implemented using only membership queries. Towards this, we show a strong negative result\u2014we show that it is impossible (in a computability sense) for any algorithm to (simultaneously) non-uniformly generate for every finite collection, with just membership queries.\nSomewhat surprisingly, our lower bound applies to collections with just two languages $L_0$ and $L_1$, when the algorithm has no a priori information about $L_0$ and $L_1$ and can only access the languages using membership queries. While this result might seem to contradict the results of [KM24] who give uniform generation algorithms for finite collections of languages, we reconcile this apparent contradiction in our discussion after establishing the formal theorem.\nInformally, the theorem says that we cannot have an algorithm with a non-uniform generation guarantee for every collection of two languages. A non-uniform guarantee for such a collection $C = {L_0, L_1}$ means that, for any input that is a valid enumeration of $L_0$ (respectively $L_1$), there is a bound $t_0$ (respectively $t_1$) independent of the enumeration, such that the algorithm correctly generates from $L_0$ (respectively $L_1$) after time step $t_0$ (respectively $t_1$). The proof takes a supposed"}, {"title": "Results on Exhaustive Generation", "content": "In this section, we study the setting of exhaustive generation introduced in Section 2.3. Recall that here, we are concerned with generating algorithms $A$ that output a generator $G_t : IN \\rightarrow \\Sigma^*$ at every time step $t$. We denote by $Z_{<t}$ the set of distinct strings generated by the algorithm up until time $t - 1$ (namely $G_1(1), . . ., G_{t-1}(1)$), and by $Z_{>t}$ the set of distinct strings generated by the algorithm from time $t$ onwards, as if it were to stop seeing any more input (namely $G_t(1), G_t(2), . . .$). As given in Definition 5, we desire that for any language $K\\in Cand enumeration of it, there exists a finite $t^* < \\infty$ such that for every $t > t^*$, it holds that $Z_{>t} \\subseteq K$, and also that $S_t \\cup Z_{<t} \\cup Z_{>t} \\supseteq K$.\nWe restate Theorem 3, which shows that even simple language collections cannot be exhaustively generated.\nTheorem 3 (Exhaustive Generation Lower Bound). There exists a countable collection C (of regular languages) that cannot be exhaustively generated in the limit.\nProof. Consider the collection $C = {L_{\\infty}} \\cup \\cup_{i \\in Z} L_i$, where\n$L_{\\infty} = Z,$\n$L_i = {-i, -i + 1, -i + 2, . . . }$ for $i \\in Z$.\nEach language above is an arithmetic progression, and hence a regular language (e.g., when the strings are expressed in binary representation). Assume for the sake of contradiction that there exists an algorithm $A$ that exhaustively generates in the limit from languages in $C$. This means that for any $K\\in C$ and any enumeration of $K$, there exists a $t^* < \\infty$ such that for any $t > t^*$, it holds that (1) $Z_{>t} \\subseteq K$, and (2) $S_t \\cup Z_{<t} \\cup Z_{>t} \\supseteq K$. Recall here that the algorithm $A$ outputs a generator $G_t$ at time step $t$ in the enumeration as a function of $S_t$, $Z_{<t}$ denotes the set of distinct strings in the sequence $G_1(1), G_2(1), . . ., G_{t-1}(1)$, and $Z_{>t}$ denotes the set of distinct strings in the sequence $G_t (1), G_t (2), . . . generated by $G_t$ if it were to go into generate-only mode from time $t$."}, {"title": "Uniform Generation with Feedback", "content": "In this section, we consider the setting of uniform generation from a language collection with feedback, where the generating algorithm is additionally allowed, at each time step, to query if any string $w$ of choice belongs to the target language $K$ being enumerated. We note again that this model is different from the membership query model considered in [KM24]; there, an algorithm can only query if a string $w$ belongs to any language $L_i$ in the collection $C = {L_1, L_2,...}$. In the feedback setting, the algorithm is more powerful since it can directly query membership in the target language $K$.\nAs before, we restrict our attention to countable language collections\u2014we know by Theorem 5 that non-uniform generation is always possible for such collections, without requiring any feedback. So, we want to further understand when uniform generation is possible, with or without feedback. It is easy to construct examples of language collections that cannot be uniformly generated without feedback, but can be uniformly generated with feedback. The following example is adopted from Lemma 15 in [RT24].\nExample 9. Consider a partition ${S_d}_{d\\in n}$ of $IN$, where $|S_1| < |S_2| < .... Let $E$ be the set of all negative even integers, and $O$ be the set of all negative odd integers. For $d \\in IN$, let $L^E_d = E \\cup S_d$, and let $L^O_d = O \\cup S_d$, and consider the language collection $C$ comprising of all languages $L^E_d$ and $L^O_d$ for $d\\in IN$. This collection has infinite closure dimension (which can be seen by noticing that the intersection of languages containing any $S_d$-namely $L^E_d$ and $L^O_d$ is exactly $S_d$), and hence cannot be uniformly generated from without feedback. However, observe that with just one query, a generator can find out whether the target language belongs to the \"even\" or \"odd\" category. Once it knows this, it can generate indefinitely from either the set of even or odd negative integers.\nWe want to now identify a property of a given collection $C$, preferably in the form a dimension (like the closure dimension from the work of [RT24] for uniform generation), which characterizes if it is possible to uniformly generate with feedback.\nTowards this, we first propose an alternate dimension to the closure dimension, which also characterizes uniform generation (without feedback). We will later generalize this dimension and show that it characterizes uniform generation with feedback."}, {"title": "The GnF Dimension for Generation with no Feedback", "content": "First, we abstractly formalize some notions from the language generation setup, which will be particularly helpful in defining the dimension.\nTranscript A transcript is a record of interaction between an adversary (who is enumerating a language $K\\in C$) and a generator (who is trying to generate from the language). A transcript is an infinite sequence $x_1, z_1, x_2, z_2, x_3, z_3, ..., where each $x_t \\in K$; here, $x_t$ is the input given to the generator at time step $t$, and $z_t$ is the string generated by the generator at time step $t$. Note that the actions of the adversary and the generator are interleaved.\nAdversary Strategy An adversary strategy $A$ is a mapping from prefixes of a transcript ending in an action by the generator (in this case, the last string generated by the generator) to the next action by the adversary (in this case, the next string from $K$ to append to the enumeration). For any language $L\\in C$, an adversary strategy $A$ is consistent with $L$ if the sequence $x_1, x_2,...$ is an enumeration of all the strings in $L$, i.e., for every $x \\in L$, there is some finite index $i$ such that"}]}