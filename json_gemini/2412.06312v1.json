{"title": "Towards High-Level Modelling in Automated Planning", "authors": ["Carla Davesa", "Joan Espasa", "Ian Miguel", "Mateu Villaret"], "abstract": "Planning is a fundamental activity, arising frequently in many contexts, from daily tasks to industrial\nprocesses. The planning task consists of selecting a sequence of actions to achieve a specified goal\nfrom specified initial conditions. The Planning Domain Definition Language (PDDL) is the leading\nlanguage used in the field of automated planning to model planning problems. Previous work has\nhighlighted the limitations of PDDL, particularly in terms of its expressivity. Our interest lies in\nfacilitating the handling of complex problems and enhancing the overall capability of automated\nplanning systems. Unified-Planning is a Python library offering high-level API to specify planning\nproblems and to invoke automated planners. In this paper, we present an extension of the UP library\naimed at enhancing its expressivity for high-level problem modelling. In particular, we have added\nan array type, an expression to count booleans, and the allowance for integer parameters in actions.\nWe show how these facilities enable natural high-level models of three classical planning problems.", "sections": [{"title": "Introduction", "content": "Planning is a fundamental activity, impacting our daily lives in many and varied ways.\nThe planning task consists of selecting a sequence of actions to achieve a specified goal\nfrom specified initial conditions. This type of problem arises frequently in many contexts,\nfrom daily tasks to industrial processes. Examples include scheduling deliveries, organising\nproject schedules, improving manufacturing efficiency, optimising resource allocation, and\ncoordinating transportation routes. Automatically solving planning problems is a central\ndiscipline of Artificial Intelligence that involves specifying the desired outcome (the 'what')\nin a purely declarative manner, leaving it to the planning engine to determine the sequence\nof actions (the 'how') needed to reach that outcome.\nConsider a scenario where a delivery robot operates within an environment that can be\nrepresented as a grid of cells, each represented as distinct locations that the robot can occupy.\nThe robot's objective is to transport a package from one position to another. This involves\nconsidering various states such as the robot's presence in a cell, the package's location, and\nwhether the robot is holding the package. The planning task requires defining a set of\npossible actions: the robot can move between cells, pick up and drop off packages. In the\ninitial state, both the robot and package are located in specific cells, and the goal is to find a\nsequence of actions where the robot successfully delivers the package to the desired cell.\nIn such scenarios, it is natural to represent the grid as a matrix. However, traditional\nplanning frameworks do not support these grid-like structures directly, which poses challenges\nwhen modelling the problem. This motivates our work to develop new planning constructs\nand extensions that can effectively model problems in such structured environments.\nThe difficulty of solving planning problems grows rapidly with their size in terms of\nthe number of states and possible actions considered. Over many years, a great deal of\neffort by a number of different research groups has resulted in the development of highly\nefficient AI planners [26]. These planners serve as the computational engines that apply\nproblem-solving algorithms to generate optimal or satisfactory plans given specific problem\ndomains. However, it is beneficial to consider automated modelling as much a part of the\nprocess of solving a planning problem as the search for a solution. The choice of a model has\na significant effect on the performance of state-of-the-art AI planning systems [8, 6], similarly\nto the importance of modelling to Constraint Programming. Constraint Programming has\nbeen successfully used to solve planning problems [4, 5] and is particularly well suited to\nplanning problems when the problem requires a certain level of expressivity, such as temporal\nreasoning or optimality [27, 3].\nThe Planning Domain Definition Language (PDDL) [17] is the leading language used\nin the field of automated planning to model planning problems and the domains in which\nthey occur. It provides a formal way to concisely describe the problem in terms of objects,\npredicates, actions and functions with parameters. PDDL was created in an effort to\nstandardise the input for AI planners, facilitating the solving of planning problems.\nPrevious work [22] highlighted the limitations of PDDL, particularly in terms of its\nexpressivity, prompting the development of abstraction techniques to extract higher level\nconcepts from PDDL models. Our interest lies in facilitating the handling of complex problems\nand enhancing the overall capability of automated planning systems. The incorporation of\nhigh-level concepts, akin to those available in ESSENCE [14] via CONJURE [1] in Constraint\nProgramming, such as functions, relations, arrays, (multi)sets, and sequences, can significantly\nenrich the modelling scope and flexibility.\nUnified-Planning (UP) [28] is a Python library offering high level API to specify planning\nproblems and to invoke planning engines. This open-source library has gained substantial\nrecognition within the research community due to its extensive adoption and continuous\ndevelopment, making it an excellent candidate on which to base our research efforts, offering\nample opportunity for exploration and experimentation.\nIn this paper, we present an extension of the UP library aimed at enhancing its ex-\npressiveness for high-level problem modelling. The new high-level implementations we are\nintroducing include:\n1. A new UP type: Array\n2. A new UP expression: Count\n3. Support for Integers as Parameters in Actions\nFurthermore, we have developed three new UP compilers, each dedicated to removing one\nof the high-level concepts we've implemented. These compilers automate the translation of\nthese constructs into simpler ones, employing advanced problem transformations similar to\nthose used for other features within the library.\nIn the experimental part of this work, we model three classical planning problems\nPlotting [11], Rush Hour [12], 8-Puzzle [21] to demonstrate the effectiveness of our extended\nframework. These problems are particularly suitable for array-based modelling due to their\ngrid-based nature, which aligns well with our new array type implementation."}, {"title": "Background and Related Work", "content": "A classical planning problem is typically formalised as a tuple \u03a0 = (F, A, I, G), where F is\na set of propositional state variables, A is a set of actions, I is the initial state, and G is\nthe goal. A state s is a variable-assignment (or valuation) function over state variables F,\nwhich maps each variable of F into a truth value. An action $a \\in A$ is defined as a tuple\n$a = (Pre_a, Eff_a)$, where $Pre_a$ refers to the preconditions and $Eff_a$ to the effects of the action.\nPreconditions (Pre) and the goal G are first-order formulas over propositional state variables.\nAction effects (Eff) are sets of assignments to propositional state variables. An action a is\napplicable in a state s only if its precondition is satisfied in s ($s \\models Pre_a$). The outcome after\nthe application of an action a will be the state where variables that are assigned in Effa take\ntheir new value, and variables not referenced in Effa keep their current values. A sequence of\nactions (ao,..., an-1) is called a plan. We say that the application of a plan starting from\nthe initial state I brings the system to a state sn. If each action is applicable in the state\nresulting from the application of the previous action and the final state satisfies the goal (i.e.,\nsn=G), the sequence of actions is a valid plan. A planning problem has a solution if a valid\nplan can be found for the problem.\nA formalisation for the previously mentioned delivery robot scenario, set within a 2x2\ngrid with positions named P00, P01, P10, and P11, could be as follows:\n\u03a0 = (\nF = {at_robot(p), at_package(p), holding_package},\nA = {\nMove(p1, p2) = (at_robot(p1), {at_robot(p2), \u00acat_robot(p1)}),\nPickUp(p) = (at_robot(p) ^at_package(p), {holding_package, \u00acat_package(p)}),\nDropOff(p) = (at_robot(p) ^ holding_package, {at_package(p), \u00acholding_package}),\n},\nI = {at_robot(P00), at_package(P10), \u00acholding_package},\nG = {at_package(P11)}\n)\nIs important to note that some of these propositional variables F are actually first-order\natoms over unquantified variables. For instance, the atom at_robot(p) is not a propositional\nvariable by itself. Here, p is a parameter that represents a position in the grid and can\nbe substituted with specific grid locations such as P00, P01, P10 and P11. During the\ngrounding process, this predicate generates multiple propositional variables corresponding\nto each specific position in the grid: at_robot_P00, at_robot_P01, at_robot_P10 and\nat_robot_P11. The actions A define the tasks the robot can perform, such as Move(p1, p2),\nwhich allows the robot to move from position p1 to position p2 if it is currently in position\np1. So when the action is executed, the robot moves to position p2 and it is no longer in\nposition p1. The initial state I is the in P00, the package is in P10, and the robot not holding\nthe package. The goal state G is to have the package in P11.\nThe Planning Domain Definition Language (PDDL) [17] initially supported only Boolean\ntypes. Over the years, it has evolved significantly to include support for features such as\nnumeric types, temporal constraints, hierarchical types, durative actions, derived predicates\nand conditional effects. This evolution has greatly enhanced the expressiveness and flexibility\nof PDDL, allowing for more sophisticated and detailed modelling of planning problems."}, {"title": "Pipeline", "content": "Despite these advancements, there remains a significant lack of expressiveness in PDDL,\nparticularly when it comes to representing more complex planning scenarios [22].\nThe UP library simplifies the processes of both formulating planning problems and utilising\nautomated planners. The library allows users to define problems in a simple and intuitive\nmanner and solve them using any of the wide array of supported solvers. Additionally, it\nprovides functionality for exporting and importing problems in PDDL or ANML [24] format,\nand executing advanced problem transformations such as simplification, grounding, and\nremoval of conditional effects.\nIn the field of automated planning, various approaches have been explored to enhance\nplanning modelling methodologies. This section offers an overview of recent advancements in\nplanning techniques and related works that have inspired or guided our research.\nGeffner's Functional STRIPS [16] introduced an extension of the STRIPS planning\nlanguage by incorporating first-class function symbols. This addition allowed for greater\nflexibility in representing planning problems, enabling more efficient encodings and supporting\ncomplex tasks with minimal action definitions. Recent work by Geffner and Frances [13]\nexplores how to address the computational challenges posed when solving problems expressed\nin Functional STRIPS by using a Constraint Satisfaction Problem to compute an heuristic\nthat guides the search.\nPlanning Modulo Theories (PMT) [18], inspired by SAT Modulo Theories (SMT), offers a\nflexible modelling language and framework where arbitrary first-order theories can be treated\nas parameters. Although further work has been done in the context of PMT [7], no concrete\nimplementations have been released.\nElahi and Rintanen [10] proposed a modelling language supporting complex data types\nlike Booleans, numeric types, enumerated types, records, unions, arrays, sets, and lists, which\nare reduced to a Boolean representation. This Boolean representation is further reduced to\nPDDL, allowing existing domain-independent planners to solve problems specified in the\nricher modelling language. While this approach effectively enhances PDDL's expressivity\nthrough the use of complex data types, our work aims to extend these capabilities further by\nleveraging the UP library. By directly integrating complex data types into UP, we benefit\nfrom Python's simplicity and readability, along with its extensive libraries and community\nsupport. This results in intuitive and concise models that are easier to understand and\nmanipulate. Inspired by ESSENCE and CONJURE, our method aims to introduce similar\nhigh-level modelling expressivity to automated planning, providing a more intuitive and\nfluent framework.\nIn this section, we provide an overview of the pipeline within the Unified-Planning framework.\nThe framework is designed to streamline the process of transforming planning problems into\nformats that various planners can understand and solve. The different stages of this pipeline\nare depicted in Figure 1.\nThe first step in defining a planning problem is to create a new instance that serves as\na container for all the elements that constitute the problem: the fluents, actions, objects,\ninitial state, and goals. Similarly to PDDL, objects typically represent entities in the problem\ndomain, each with a type. Note that the term fluent has been historically used to refer\nto state variables that may change over time. UP also uses a lifted representation of the\nproblem, with state variables and actions having parameters, enabling a concise definition of\nthe problem."}, {"title": "The Proposed UP Extensions", "content": "The new Array Type class is designed to represent arrays consisting of a specified number\nof elements of a given type. It relies on two main parameters: size and elements_type.\nThe size parameter signifies the number of elements contained within the array and must\nbe an integer (Python class int) with a predefined value greater than one. On the other\nhand, elements_type represents the type of the elements within the array. It is optional\nand it defaults to None, meaning no specific type is assigned. In this case, the array will be\nassumed to be of Boolean type. The construction of the class is shown in Listing 1.\nThis type empowers us to represent tables or matrices effectively. With this implementa-\ntion, we can now define Array Type Fluents, giving us the ability to access the array's elements\nindividually, treating each as a fluent, while also knowing the position of each within the\narray. Moreover, given that arrays are considered types themselves and the elements_type\nparameter represents a type, we can create arrays of arrays and so forth, enabling the creation\nof nested arrays.\nAssume the initial example of a robot that operates in a 3x3 grid, where the robot can\nonly move to adjacent cells -left, right, up, or down, but not diagonally. Without using\narrays, it is necessary to define all the relationships between the different cells to determine\nif they are neighbours. However, by utilising arrays, their position and relationship becomes\nimplicit. For example, we can define the grid cells using a double array-type fluent (matrix)\nthat encapsulates Booleans, indicating whether the robot is in each cell of the grid. The same\napproach can be used for the package. Listing 2 shows the definition of the initial state and\nfluents. Note that all positions that are not specified in initial_values default to false.\nGiven that this new implementation is not compatible with the planners, we've developed an\nArraysRemover compiler to transform arrays into individual elements. For each array-type\nfluent, we create a series of fluents that correspond to its individual elements. These new\nfluents maintain the original name but are suffixed with '_' followed by the respective\nposition indices of the array elements. For example, the i-th element of the array my_ints,\naccessed using my_ints[i], transforms into a new fluent named my_ints_i. Moreover, this\nmethodology extends to multidimensional arrays. For each dimension, an index is added\nto represent all the elements. Considering the fluent at_robot of the previous example,\nthe elements are separated into the nine new fluents with the format depicted in Listing 3.\nFurthermore, in all actions and goals, we not only replace array accesses, as previously\nillustrated, but also manage the entire array comprehensively. For instance, when encountering\nan expression such as at_robot [0] \u2192 [False, False, False], we decompose it into:\nat_robot_0_0 \u2192 False / at_robot_0_1 \u2192 False / at_robot_0_2 \u2192 False.\nIntroducing arrays poses a significant issue when accessing positions outside the arrays'\ndefined range. The concept of undefinedness in planning is not extensively addressed because"}, {"title": "Integer Type Parameters in Actions", "content": "We identified support for bounded integer parameters to be passed to actions as a highly\nuseful implementation when working with arrays.\nWe will illustrate this approach with the previous example. To properly control the\npossible movements, we create four actions, each corresponding to one direction. For instance,\nwith the move_right action, shown in Listing 4, we ensure that the robot cannot move\noutside the grid by allowing this movement only when the robot is in one of the first two\ncolumns. This means that only the integers 0 and 1 will be passed as parameters for the\ncolumns, preventing the robot from moving right when it is in the rightmost column.\nThis approach allows for more flexible and concise problem descriptions in planning\nscenarios. It enables us to refer to any element within the array by indexing this integer in\nthe array, eliminating the need to create an action for each individual element. However, it\nis crucial to ensure that the bounded integer values fall within the specified domain range,\nas values outside this range may lead to undefined behaviour. It is crucial to understand\nhow undefined values will be handled according to the strategies outlined above, ensuring\nthe implementation appropriately manages any out-of-range values introduced. Additionally,\nintegers can be utilized not only for indexing arrays but also as values in preconditions or\neffects, as well as in arithmetic operations, enhancing the model's flexibility and expressiveness."}, {"title": "Integer Type Parameters in Actions Compiler", "content": "This compiler overcomes the limitations of the previous implementation, as planners could\nnot comprehend or process integer parameters or anything other than objects in actions. For\neach action, the compiler generates new actions for each possible combination of the integer\nparameters. These new actions do not include the integer parameters, as they are replaced\nby their respective values within the preconditions and effects. Retaining the original name,\nthey are suffixed with '_' followed by the current integer parameter values separated by '_'.\nFor instance, when the compiler processes the move_right action described in Listing 4,\nit will transform it into six new actions, one for each possible combination of the parameters\nr and c \u2014 (0,0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1) \u2014. In Listing 7, the action generated for\nthe parameters (0,1) illustrates how the parameters r and c in both preconditions and\neffects are substituted with their specific values. Furthermore, this compiler simplifies\nexpressions wherever possible during parameter substitution with integer values. This\nsimplifier handles arithmetic operations at runtime, reducing the size and complexity of the\ngenerated expressions. For example, in the previous instance with at_robot [0] [2], the\nvalue 2 results from the addition (1+1), which is computed automatically during compilation.\nThis optimisation streamlines execution, enhances efficiency, and simplifies the problem\ndescription for the planner."}, {"title": "Count Expression", "content": "When encoding problems, we encounter situations where evaluating the number of True\nstatements among multiple Boolean expressions becomes necessary. To address this, we\nhave developed the Count expression, specifically designed to manage Boolean n-arguments\nefficiently. The purpose of this function is to return an integer representing the number of\nTrue expressions among multiple Boolean expressions. The construction of this expression\nis shown in Listing 8, and can be formulated in two ways: Count(a,b,c) or Count([a, b, c]),\nwhere a, b, c represent Boolean arguments.\nWe can exemplify the function with an illustration of a possible goal from the previous\nexample. Suppose our problem involves multiple robots, and the goal is for all robots to end\nup in the same room, leaving only one room occupied. To achieve this, we need to count\nhow many cells are occupied by any robot. This is demonstrated in Listing 9."}, {"title": "Count Expression Compiler", "content": "This compiler translates each Count expression into a new set of expressions that the planner\ncan comprehend, involving the creation of a new function (known as an integer fluent in\nUnified-Planning) for each argument of every Count expression in the problem. These\nfunctions are designed to represent the Boolean value of each argument: they take on a value\nof 0 if the expression is False and 1 if it is True. The new fluents will be named sequentially as\ncount_0, count_1, count_2, and so on, for each argument of the expressions in the problem.\nWhen different Count expressions share an argument with the same expression, they will be\nassigned the same name. Moreover, substitutes each argument in the expression with its\ncorresponding function, and replaces the Count operator expression with the well-known\nPlus operator, which adds up various integer expressions. This way, we sum up the new\nfunctions created, each corresponding to its original Boolean expression. This is shown in\nListing 10. These functions are initialised depending on the initial value of the fluents and\nthe evaluation of the expression. As depicted in Listing 12, in our example, only the position\n(0,0) is set to True, resulting in the function related to this Boolean expression, count_0,\nhaving an initial value of 1.\nFurthermore, for each action, if any fluent is modified, those expressions (arguments\nfrom Count expressions) containing that fluent will also be evaluated to potentially change\nthe value of the corresponding function based on the evaluation result. As illustrated in\nListing 10, the Integer Type Parameters in Actions compiler and the Array Type Compiler\nhave already been applied. It must be in this order, as discussed in Section 4.4. The"}, {"title": "Sequence of Compiler Application", "content": "To ensure the proper utilisation of the compilers we've developed, it is crucial to follow a\nspecific sequence in their application. The required order, assuming all three implementations\nare included in a problem, is as follows:\n1. Integer Parameters in Actions Compiler\n2. Array Type Compiler\n3. Count Expression Compiler\nWhen a problem includes integer parameters in actions it is crucial to apply the Integer\nParameters in Actions Compiler before any other compiler. Not applying this compiler\nfirst could lead to issues if our problem also involves arrays. For example, accessing specific\nelements like my_ints[i] where i is an integer parameter requires knowing its value to\ndetermine the array element. Applying the Array Type Compiler first without this information\nwould result in errors due to the undefined value of i.\nThe Count Expression Compiler should be applied after resolving complexities related to\narrays using the other two compilers. This sequence is critical because the expressions it\nhandles may reference array elements. Additionally, to effectively adjust the new functions\nassociated with each argument of count expressions, it is essential to first evaluate the\nchanges affecting the fluents within the action effects. Without substituting integers and\nremoving arrays beforehand, we would not know which fluents are affected by action changes."}, {"title": "Experiments", "content": "In this section, we evaluate our new UP-extended implementation encoding three typical\nplanning games: Plotting, Rush-Hour, and 8-Puzzle, against existing PDDL models. These\nexperiments were conducted using a cluster comprising 20 nodes, each equipped Intel(R)\nXeon(R) E-2234 CPUs @ 3.60 GHz with 16GB of RAM. The solvers used in our experiments\nare Enhsp-opt [23] for our UP-extended model and Fast-Downward [19] with the seq-opt-lmcut\nheuristic for the selected PDDL models. We employ two different planners to leverage their\nrespective strengths: Enhsp (version 20) supports numeric extensions crucial for our model,\nwhile Fast-Downward (version 23.06+), although lacking numeric support, provides robust\nheuristic-based search capabilities. Our aim was to measure the combined preprocessing and\nsolving time, with a configured timeout of 1 hour (all results are presented in seconds), and\nsee if the proposed UP extensions had a reasonable cost regarding solving time. For each\nproblem we will highlight the advantages in modelling provided by some of the features that\nwe have developed in UP. The models with UP-extended, along with the implementation of\nthe proposed extensions, can be found on GitHub at https://github.com/stacs-cp/unified-\nplanning/tree/new_types2."}, {"title": "Plotting", "content": "Plotting is a tile-matching puzzle video game published by Taito (Figure 2a illustrates an\ninstance of the game). The objective of the game is to remove at least a certain number of\ncoloured blocks from a grid by sequentially shooting blocks into the same grid. The interest\nand difficulty of Plotting is due to the complex transitions after every shot: various blocks\nare affected directly, while others can be indirectly affected by gravity.\nListing 13 depicts the grid represented as a double array, with each cell indicating the\ncolor of a block. The initial grid configuration is defined using a Python nested list.\nWe define several actions that manipulate the grid of colored blocks based on the shot.\nThese actions utilise integer parameters to reference different blocks, and we ensure these\nparameters are within valid ranges to prevent out-of-bounds access. One such action, detailed\nin Listing 14, is shoot_partial_row, which clears blocks of a colour p from a row r up to\nthe last column 1 of that row, stopping when the next block is of a different color.\nIn Listing 14, we highlight some of the most interesting preconditions and effects of this\naction, particularly to demonstrate the effectiveness of Python functions, such as for loops,\nfor iterating over different elements. The first precondition ensures that the next block of the\ncolumn 1 is different from p and not N, where N indicates no block is present. The first loop\nensures that all elements in the row until the column I are either por N. And the following\nprecondition confirms that at least one of these elements (i.e., among all elements being\ncleared) is p, preventing unnecessary actions when all blocks are N. The effects described\ndetail how the action modifies the grid. Initially, the hand takes on the value of the next block\nin sequence (the first block different), while this position saves the value of p. Additionally,\nthe nested loops update the grid's elements in accordance with gravity, ensuring the correct\nmovement of blocks above the affected row.\nAs shown in Listing 15, the objective of the game is to have no more than a specified\nnumber of blocks remaining, in this example, 4 or fewer. Our new implementation of the\nCount expression is particularly useful for this purpose as it facilitates the counting of blocks\nthat are different from N, indicating how many blocks are left on the grid."}, {"title": "Rush Hour", "content": "Rush Hour is a sliding block puzzle game set on a 6x6 grid, where blocks represent vehicles\nstuck in a traffic jam (Figure 2b illustrates an instance of the game). The objective is to move\na special vehicle, the red car, to the exit located at the right edge of the grid. However, the\nmovement of vehicles is restricted: they can only move forwards or backwards in a straight\nline and cannot cross over each other.\nIn modelling the Rush Hour game, we utilise a 6x6 grid represented by a double array,\nwhere each cell denotes a letter representing a vehicle, as depicted in Listing 16. This\ngrid instantiation process utilises Michael Fogleman's database [12], which provides string\nrepresentations where 'o' denotes an empty cell, and each letter represents a distinct vehicle.\nVehicles include cars, which occupy 2 cells, and trucks, which occupy 3 cells. Python's ability\nto manage strings as iterable sequences allows for a concise representation of the grid and\nenhances flexibility in modifying its configuration.\nUtilising the permissive mode when handling undefinedness (See Undefinedness above)\nis highly beneficial in encoding the Rush Hour problem. It eliminates the requirement to\nspecify exact movement possibilities for each vehicle position while ensuring they remain"}, {"title": "8-Puzzle", "content": "The N-puzzle is a classic sliding puzzle game consisting of a k*k grid with ((k * k) \u2013 1)\nnumbered tiles (N) and one blank space (Figure 2c illustrates an instance of the game).\nThe objective is to rearrange the tiles by sliding them horizontally or vertically into the\nblank space, with the goal of achieving a specific configuration, often the ordered sequence of\nnumbers from 1 to N.\nThe definition of the grid, depicted in Listing 18, is represented as a 2D array where each\ncell contains an integer value ranging from 0 ton. The value 0 represents the empty space.\nThe representation of slide_up action is shown in Listing 19, which moves a tile up into\nthe empty space in the grid. The parameters r and care integers representing the row and"}, {"title": "Conclusions and Future Work", "content": "This proposed extension allows plans to be expressed more naturally, facilitating the manage-\nment of complex problems. By making the modelling process more intuitive, it significantly\nreduces the manual effort and time required to select an optimal modelling approach. One\nsignificant advantage of this Python-based framework is its ability to effectively utilise Python\nfunctions, such as for loops, for iterating over different elements, allowing better manipulation\nof complex structures. This capability enhances the flexibility and power of the modelling\nprocess, making it easier to handle intricate scenarios. A key benefit of this pipeline is the\nsignificant modelling flexibility it provides, enabling the use of different compilers depending\non the planner, which illustrates the diverse methods to model, transform and solve the same\nproblem. As we have seen, arrays have been particularly useful in our examples.\nLooking ahead, we aim to implement more high-level concepts such as functions, relations,\n(multi)sets, and sequences to further enhance the modelling capabilities of the framework. We\nalso want to explore alternative compilers for each feature obtaining different possible encoding\npaths from our high-level UP extensions to PDDL (as done in constraint programming with\nConjure [1] between Essence and Essence Prime). We also plan to conduct an experimental\nanalysis of the solving time cost of using our proposed high-level UP representations."}]}