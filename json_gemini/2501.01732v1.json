{"title": "CHEZ PL: A Hyper-Extensible AI-Integrated Zero-Trust CIAM-PAM Framework for Enterprise Security Modernization", "authors": ["Shivom Agarwal", "Shourya Mehra", "Safeer Sathar"], "abstract": "Customer Identity and Access Management (CIAM) systems play a pivotal role in securing enterprise infrastructures. However, the complexity of implementing these systems requires careful architectural planning to ensure positive Return on Investment (Rol) and avoid costly delays. The proliferation of Active Persistent cyber threats, coupled with advancements in AI, cloud computing, and geographically distributed customer populations, necessitates a paradigm shift towards adaptive and zero-trust security frameworks. This paper introduces the Combined Hyper-Extensible Extremely-Secured Zero-Trust (CHEZ) CIAM-PAM architecture, designed specifically for large-scale enterprises. The CHEZ PL CIAM-PAM framework addresses critical security gaps by integrating federated identity management (private and public identities), password-less authentication, adaptive multi-factor authentication (MFA), microservice-based PEP (Policy Entitlement Point), multi-layer RBAC (Role Based Access Control) and multi-level trust systems. This future-proof design also includes end-to-end data encryption, and seamless integration with state-of-the-art AI-based threat detection systems, while ensuring compliance with stringent regulatory standards.\nThis research paper outlines the architectural components of the CHEZ PL CIAM-PAM model, including its modular design, dynamic policy enforcement, and real-time monitoring capabilities. The proposed framework effectively minimizes technical debt during IAM migration processes, enabling smooth transitions from legacy systems while maintaining business continuity. Additionally, this paper evaluates the suitability of the CHEZ PL CIAM-PAM model for global organizations operating in distributed environments with diverse regulatory requirements and highlights strategies to mitigate integration challenges. The paper also explores potential enhancements, including the deployment of AI/GenAI tools for advanced risk analysis, behavior-based anomaly detection, and predictive analytics. By leveraging Al within a zero-trust architecture, the CHEZ PL framework ensures scalability, adaptability, and proactive security monitoring. Finally, the research concludes with insights into limitations, practical implications for enterprise adoption, areas for future development, and considerations for managerial decision-making.", "sections": [{"title": "I. INTRODUCTION", "content": "The regular emergence of novel cybersecurity threats necessitates that organizations continuously adapt their security strategies to have an effective & efficient enterprise cybersecurity system. Customer Identity and Access Management (CIAM) and Privileged Access Management (PAM) systems have emerged as critical components for securing the enterprise systems. Typically, legacy IAM systems facilitated the definition and implementation of access control policies, determining authorized users, specific resource access, temporal restrictions, and contextual conditions. However, these traditional IAM solutions often fail to address modern requirements such as distributed and open Customer identities, scalability, password-less authentication, Al-driven monitoring, and zero-trust security models required for globally distributed systems.\nThe proposed framework leverages adaptive authentication, identity federation, Al-powered continuous session risk analysis, and integrated privileged access management system. Departing from traditional perimeter-based security policies, this architecture adopts a Zero Trust framework, enabling granular access control, real-time session monitoring, and adaptive policy enforcement. While traditional systems are constrained by static access control policies and a hierarchical access framework, this architecture enhances resilience through decentralized authorization and dynamically adapts access privileges contingent on contextual risk factors.\nKey innovations of this framework include enhanced encryption standards, pseudonymized data sharing, federated identity management, and advanced behavioral analytics. These innovations support distributed network environments and multi-platform integration while adhering to compliance standards such as GDPR, HIPAA, and SOC 2. Additionally, the CHEZ PL CIAM-PAM model provides seamless interoperability with legacy systems due to underlying microservices design, facilitating enterprises to upgrade CIAM systems without causing major disruptions to existing workflows.\nFurthermore, CHEZ PL integrates AI-driven anomaly detection for privileged access, session monitoring, and proactive risk assessments. It also employs real-time auditing tools that simplify compliance reporting and reduce overheads associated with manual audits. This research also investigates the efficacy of the proposed architecture in mitigating challenges related to scalability, interoperability across diverse platforms, and adherence to regulatory compliance standards, while also establishing a future-proof framework readily adaptable to emerging Artificial Intelligence (AI) and Generative AI (GenAI) technologies.\nThis paper concludes with a discussion on future extensions of this research paradigm, limitations of adopting CHEZ PL CIAM-PAM architecture and implications for Cybersecurity managers in large multi-national organizations."}, {"title": "II. LITERATURE REVIEW", "content": "The paradigm of IAM systems has been changing over the last decade with more requirements of integrating external Customer identities, provide privileged access and demands of enhancing the monitoring & reporting. Historically, IAM architectures tend to be either role-based access control (RBAC) model, attribute-based access control model, mandatory access control model or discretionary access control model (Nahar & Gill 2022). But latent research (Yang et al 2014, Mohammed et al 2018, Nahar & Gill 2022) found that RBAC based architectures are most efficient for large scale organizations. Furthermore, these traditional IAM systems primarily relied on access control processes based on static roles and organizational hierarchies. The proliferation of cloud computing and geographically distributed customer populations, multiple open-source identities, active persistent cyber threats, etc. revealed limitations in existing architectures, highlighting the need for more dynamic, scalable, and adaptive solutions. Zero Trust architecture design, initially popularized by Forrester Research, has become a cornerstone of latest Identity and Access Management (IAM) systems (Turner et al 2021).\nBesides, Zero-trust implications, IAM policies need to adapt to the emerging trend of multi-identity dynamics & data privacy compliance rules for external users, including open identities, state-sponsored identities, social media identities, other trusted third-party identities (Peterson et al 2008, Roy 2023, Gl\u00f6ckler et al 2024). To address this challenge, federated identity models are increasingly utilized in contemporary deployments of CIAM to optimize authentication workflows across hybrid and multi-cloud environments (Malik et al 2015, P\u00f6hn & Hommel 2020, Kiourtis et al 2023). The resulting federated identity systems centralize identity verification, alleviating the need for users to manage disparate credentials, thus enhancing both usability and security. Standards such as SAML (Hughes & Maler 2005), OAuth 2.0 (Fett et al 2016), and OpenID Connect (Mainka et al 2017) also significantly facilitated the interoperability between CIAM and PAM solutions across heterogeneous platforms (Walker 2019).\nOther scholars have proposed to enhance existing IAM systems by incorporating password-less authentication (Alqubaisi et al 2020), AI-driven identity governance (Azhar 2016, Hawa 2024), risk-based access control models (Atlam et al 2020). Furthermore, the advancements in AI are also impacting our understanding of IAM systems, especially for automation and control. Many studies have postulated different methodologies to incorporate IA into IAM architectures to - authentication, authorization, and auditing (Aboukadri et al 2024, Vegas & Lamas 2024, Ahmadian et al 2014).\nIncorporating all these different paradigms into one holistic architecture is crucial research gap and requires deep knowledge of cybersecurity architectures as well as Al systems design. This paper takes this challenge to bring all these state-of the-art technologies into CIAM architecture. This CHEZ PL CIAM-PAM architecture advances beyond this prior work by implementing a synergistic integration of Zero Trust principles and AI-driven threat detection, specifically designed to overcome scalability and compliance obstacles prevalent in large-scale enterprise environments It incorporates pseudonymized data models and compliance mechanisms for GDPR and HIPAA, ensuring regulatory alignment. Furthermore, it extends prior work by addressing integration challenges with legacy systems, providing backward compatibility, and enabling gradual migration strategies, in turn reducing overall project costs.\nThis paper extends prior work by offering a comprehensive, modular framework designed specifically for large-scale enterprises operating in geographically distributed networks. This architecture emphasizes interoperability with legacy systems while integrating adaptive authentication, AI-driven analytics, and policy enforcement mechanisms to effectively mitigate emerging cybersecurity threats and minimize technical debt. It highlights the practical application of federated identities and pseudonymized data models, ensuring compliance with regulatory standards across multiple jurisdictions. Finally, the framework leverages AI-driven monitoring for continuous improvements, adaptive threat response, and risk mitigation strategies."}, {"title": "III. PROPOSED METHODOLOGY", "content": "The proposed CHEZ PL CIAM-PAM architecture is structured to address the limitations of traditional CIAM-PAM frameworks while ensuring scalability, security, and compliance. An architecture HLD design methodology for complex IT systems (Platunov et al 2014, Diaz-Pace & Bianchi 2019, Li et al 2024)\nThe methodology is divided into five primary phases:\n\u2022\tRequirements Gathering and Analysis: This phase identifies enterprise-specific security policies, needs & technical debt from legacy systems, business & compliance requirements, and existing gaps in CIAM-PAM systems. This involves stakeholder consultations, conducting risk assessments, and verifying data flow analysis to ensure the architecture aligns with business & cybersecurity objectives.\n\u2022\tFramework Design and Architecture Planning: A modular design approach is employed using microservices & incorporating multi-level authentication system, federated identity management, role-based access control, and AI-driven anomaly detection mechanisms. This phase also defines envisioned data encryption protocols, attributes pseudonymization techniques, and codifies integration points with existing systems.\n\u2022\tImplementation and Integration: The implementation phase involves deploying the CIAM-PAM framework, configuring access controls, integrating AI modules for monitoring, and enabling adaptive MFA mechanisms. Automated workflows for policy enforcement, identity federation, and data encryption are established.\n\u2022\tTesting and Validation: Comprehensive testing scenarios are executed, including penetration testing, vulnerability assessments, and stress testing. Performance metrics such as latency, throughput, and scalability are validated to ensure the architecture meets enterprise-grade requirements.\n\u2022\tDeployment and Optimization: The final phase involves rolling out the solution, conducting user training, and optimizing configurations based on feedback. Continuous monitoring tools and AI analytics are used to refine access controls, identify anomalies, and enhance performance.\nThis methodology ensures seamless migration from legacy systems, reduces operational risks, and enables dynamic scalability while maintaining compliance with regulatory standards. This research paper's scope covers only first 3 steps of requirements gathering, framework design & architecture planning and implementation & integration. The last two steps are left for a specific organization to deploy CHEZ PL CIAM-PAM architecture, test the integrated system, validate with power users & business managers, and enforce a continuous improvement process for regular optimization."}, {"title": "IV. MODEL & ARCHITECHTURE", "content": "The Combined Hyper-Extensible Extremely-Secured Zero-Trust (CHEZ) CIAM-PAM architecture proposed in this paper is designed to address the evolving cybersecurity requirements of large-scale enterprises. It provides a multi-layered security approach that integrates Identity and Access Management (IAM) and Privileged Access Management (PAM) into a unified framework, enabling dynamic policy enforcement, zero-trust principles, and AI-powered threat detection. This section provides a detailed breakdown of the CHEZ CIAM-\nAccess Manager. FIM integration requires an Access Manager ensuring the operational readiness of required components, such as Web Logic Server and associated Identity Management (IdM) elements; registering a HTTP Server as a partner with Access Manager for resource protection; configuring Identity Federation as both a service provider (SP) and/or an identity provider (IdP) with Access Manager; and configuring Access Manager to delegate authentication to, or authenticate on behalf of FIM. Prior to undertaking these integration tasks, several key components must be installed, including application deployment server, HTTP server, Access Manager, Identity Federation tool, and a web server plug-in for Access manager (required in authentication mode).\nPAM architecture, focusing on its core components, design principles, and operational workflows.\nA. Core Components of the CHEZ PL Architecture\n1. Identity Management Layer\nFederated Identity Management: Supports multiple identity providers, enabling seamless integration of private and public identities. It allows organizations to centralize authentication while enabling cross-domain identity federation, ensuring secure interoperability. CHEZ PL CIAM-PAM architecture enables the integration of disparate Identity Providers (IdPs) utilizing SAML 2.0 and OpenID Connect (OIDC) protocols, allowing for the use of federated user attributes in access control decisions.\nFIM is core component of the architecture that can support multiple federation protocols including SAML 1.x and SAML 2.0. Key capabilities include cross-protocol single sign-on (SSO), native integration with Access Manager and interoperability with any LDAP directory supported by the Role-Based Access Control (RBAC): Utilizes hierarchical roles and permission sets to define user access levels. The RBAC model ensures minimal privilege principles and enforces granular access policies.\nIn CHEZ PL CIAM-PAM architecture, RBAC has a defined component - The User Service, responsible for managing user-related functionalities as well as verifying user identities and granting access to protected resources. It serves as a central hub for user registration, and profile management, ensuring seamless interaction between users and other services within the system.\nThe architecture is centered around a master entity, serving as the"}, {"title": "VALIDATE CAPTCHA", "content": "primary entry point for the system. Users, groups, permissions, and resources are foundational components intricately linked to this master entity. Within each user account, a root user is granted the highest level of access and control. Groups, resources, and permission sets are associated with the master entity, defining their relationship with the account. Groups can also have specified permissions and resources, thus enabling fine-grained access control and resource management. Furthermore, users from one account may be members of groups in other accounts, facilitating collaboration and cross-account access management.\nCHEZ PL CIAM-PAM architecture's design leverages several key patterns to enhance modularity and maintainability. The Singleton Pattern has been employed in the design through a \u201cSingletonSessionManager\u201d class to manage user sessions efficiently across the system. The Strategy Pattern provides further flexible authentication options for a given user by defining \"PasswordHashingStrategy\u201d and \u201cEmailVerification Strategy\" interfaces with concrete implementations such as bcrypt hashing and token-based verification. Moreover, the Observer Pattern enables event-driven behavior via an \"UserEventListener\u201d interface, allowing classes to respond to events like registration completion or password resets. The Decorator Pattern facilitates the dynamic extension of user profiles with features like social media links and themes, while also enabling the addition of functionality like logging and caching. Access control is enforced using the Proxy Pattern, implemented via an \"AccessControlProxy\u201d class that checks permissions before granting access to sensitive resources. Finally, the Builder Pattern provides a structured approach for constructing user objects, utilizing a \u201cUserBuilder\" class to manage attributes like name, email, and password.\npassword reset processes, the Send Email action is invoked to deliver necessary communication.\nIdentity Management LLD A LLD (Low-level Design) implementation example for such a user flow process where a robust Captcha is also deployed.\nValidation of Input (Condition): The system rigorously validates the user-provided input, ensuring the integrity and accuracy of critical information including:\n\u2022\tName: Checks the name input for completeness, valid characters, and adherence to specified length limits.\n\u2022\tPassword: Validates the password to meet predefined criteria such as length, complexity, and inclusion of special characters for enhanced security.\n\u2022\tDate of Birth (DOB): Verifies the date of birth format to adhere to the specified pattern (e.g., dd/mm/yyyy) and validates against acceptable age ranges.\n\u2022\tEmail: Ensures the email address follows the standard email format (e.g., user@example.com) and validates against common email validation rules.\n\u2022\tPhone Number: Validates the phone number format to conform to standard conventions and ensures it contains only numeric characters with optional country code.\n\u2022\tThrow Validation Error (Process): If the input is invalid, an error is thrown, and the registration process stops.\n\u2022\tCheck for CAPTCHA Enablement (Condition): Determines whether CAPTCHA verification is enabled or not from the .env variable. If CAPTCHA is enabled, the system proceeds to \"Validate CCAPTCHA\"; otherwise, it directly checks for user existence.\n\u2022\tCAPTCHA Validation (Condition): Validates the CAPTCHA input. If the CAPTCHA is invalid, the process moves to \"Throw CAPTCHA Error\".\n\u2022\tThrow CAPTCHA Error (Process): If the CAPTCHA is invalid, an error is thrown, and the registration process stops.\n\u2022\tCheck User Existence (Condition): Checks if the user already exists in the system. If the user exists with the"}, {"title": "END REGISTRATION", "content": "CHEZ PL's Identity management system architecture is characterized by a Customer actor, representing the user, and a System actor, representing the main application. The architecture supports several categories of use cases, including: account registration and verification (with registration, email verification, and send email functionalities), password recovery (comprising forgot password, reset password, and send email functionalities), profile management (including profile update, address management and image updates), and group management (with group view, edit, member addition, and permission management). Note that the delete address functionality has been disabled. In email verification and email or phone number, the process moves to \"Throw User Existence Error\"; otherwise, it proceeds to create a master record.\n\u2022\tThrow User Existence Error (Process): If the user already exists, an error is thrown, and the registration process stops.\n\u2022\tCreate a Master Record (Process): Creates a master record if the user doesn't exist, preparing for user creation.\n\u2022\tCreate User Record (Process): Generates a new user record in the user table, associating it with the master record, with default role as \"USER\" and active status. Simultaneously, user-specific details, such as name, email, phone, password, and date of birth, are stored in the user_details table with initial verification flags set to false and null values for optional fields like profile image and OTP. password should be hashed using the bcrypt algorithm.\n\u2022\tGenerate Token with User ID and OTP (Process): Creates a token containing the user ID and one-time password (OTP) for verification purposes. Here we need to add one additional field to the token to identify the token type. Eg payload { userId: \"user_123\", otp: 123, type: VERIFY_EMAIL }. Token should be generated on Auth SVC.\n\u2022\tSend a Verification Link (Process): Sends a verification link containing the token to the user's email for account verification. Here, we can send the link, email and template id to the mail service.\n\u2022\tSend Success Response (Process): Upon successful registration and verification, sends a success response indicating completion of the registration process.\n\u2022\tStop: Marks the end of the registration process."}, {"title": "RESET PASSWORD", "content": "\u2022\tUser Request Forgot Password Mail (Process): Initiates the process when a user requests to reset their password.\n\u2022\tValidate Input (Condition): Checks if the provided email and date of birth (DOB) are in the correct format and adhere to validation rules.\n\u2022\tThrow Validation Error (Process): If the input is invalid, an error is thrown, and the process stops.\n\u2022\tGenerate Token with User ID and OTP (Process): Creates a token containing the user ID and one-time password (OTP) for verification purposes. Here we need to add one additional field to the token to identify the token type. Eg payload { userId: \"user_123\", otp: 123, type: FORGOT_PASSWORD }. Token should be generated on Auth SVC.\n\u2022\tSend Verification Link (Process): Sends a verification link containing the token to the user's email for password reset.\n\u2022\tSend Success Response (Process): Upon successful sending of the verification link, sends a success response to the user.\n\u2022\tStop: Marks the end of the forgot password process.\n\u2022\tUser Opens the Link (Process): Starts when the user opens the password reset link received via email.\n\u2022\tValidate Token and Payload (Condition): Checks if the token and payload sent by the user are valid. Validate the token and payload on Auth SVC.\n\u2022\tThrow Validation Error (Process): If the token or payload is invalid, an error is thrown, and the process stops.\n\u2022\tUpdate the New Password in the Database (Process): If the token and payload are valid, updates the user's password in the database.And update the OTP in the database as NULL.\n\u2022\tSend Success Response (Process): Upon successful password reset, sends a success response to the user.\n\u2022\tStop: Marks the end of the password reset process.\nValidation of Input (Condition): The system rigorously validates the user-provided input, ensuring the integrity and accuracy of critical information including:\n\u2022\tName: Checks the name input for completeness, valid characters, and adherence to specified length limits.\n\u2022\tPassword: Validates the password to meet predefined criteria such as length, complexity, and inclusion of special characters for enhanced security.\n\u2022\tDate of Birth (DOB): Verifies the date of birth format to adhere to the specified pattern (e.g., dd/mm/yyyy) and validates against acceptable age ranges.\n\u2022\tEmail: Ensures the email address follows the standard email format (e.g., user@example.com) and validates against common email validation rules."}, {"title": "EMAIL", "content": "\u2022\tPhone Number: Validates the phone number format to conform to standard conventions and ensures it contains only numeric characters with optional country code.\n\u2022\tThrow Validation Error (Process): If the input is invalid, an error is thrown, and the registration process stops.\n\u2022\tCheck for CAPTCHA Enablement (Condition): Determines whether CAPTCHA verification is enabled or not from the .env variable. If CAPTCHA is enabled, the system proceeds to \"Validate CAPTCHA\"; otherwise, it directly checks for user existence.\n\u2022\tCAPTCHA Validation (Condition): Validates the CAPTCHA input. If the CAPTCHA is invalid, the process moves to \"Throw CAPTCHA Error\".\n\u2022\tThrow CAPTCHA Error (Process): If the CAPTCHA is invalid, an error is thrown, and the registration process stops.\n\u2022\tCheck User Existence (Condition): Checks if the user already exists in the system. If the user exists with the email or phone number, the process moves to \"Throw User Existence Error\"; otherwise, it proceeds to create a master record.\n\u2022\tThrow User Existence Error (Process): If the user already exists, an error is thrown, and the registration process stops.\n\u2022\tCreate a Master Record (Process): Creates a master record if the user doesn't exist, preparing for user creation.\n\u2022\tCreate User Record (Process): Generates a new user record in the user table, associating it with the master record, with default role as \"USER\" and active status. Simultaneously, user-specific details, such as name, email, phone, password, and date of birth, are stored in the user details table with initial verification flags set to false and null values for optional fields like profile image and OTP. password should be hashed using the bcrypt algorithm.\n\u2022\tGenerate Token with User ID and OTP (Process): Creates a token containing the user ID and one-time password (OTP) for verification purposes. Here we need to add one additional field to the token to identify the token type. Eg payload { userId: \"user_123\", otp: 123, type: VERIFY_EMAIL }. Token should be generated on Auth SVC.\n\u2022\tSend Verification Link (Process): Sends a verification link containing the token to the user's email for account verification. Here, we can send the link, email and template id to the mail service.\n\u2022\tSend Success Response (Process): Upon successful registration and verification, sends a success response indicating completion of the registration process.\n\u2022\tStop: Marks the end of the registration process.\nOther User Verification& Validation\n\u2022\tUser Requests Email Verification (Process): The process initiates when a user requests to verify their email address.\n\u2022\tValidate Email (Condition): Checks if the provided email address is in the correct format and adheres to validation rules.\n\u2022\tThrow Validation Error (Process): If the email address is invalid, an error is thrown, and the process stops.\n\u2022\tGenerate Token with User ID and OTP (Process): Creates a token containing the user ID and one-time password (OTP) for verification purposes. Here we need to add one additional field to the token to"}, {"title": "MFA Management", "content": "identify the token type. Eg payload { userId: \"user_123\", otp: 123, type: VERIFY_EMAIL }. Token should be generated on Auth SVC.\n\u2022\tSend Verification Link (Process): Sends a verification link containing the token to the user's email address for email verification.\n\u2022\tSend Success Response (Process): Upon successful sending of the verification link, sends a success response to the user.\n\u2022\tUser Opens Verification Link (Process): The process begins when the user opens the email verification link received in their email inbox.\n\u2022\tValidate Token and Payload (Condition): Checks if the token and payload sent by the user are valid. Validate the token and payload on Auth SVC.\n\u2022\tThrow Validation Error (Process): If the token or payload is invalid, an error is thrown, and the process stops.\n\u2022\tVerify Email and Update the Database (Process): If the token and payload are valid, verifies the user's email address and updates the database accordingly. And update the OTP in the database as NULL.\n\u2022\tSend Success Response (Process): Upon successful email verification, sends a success response to the user.\nMulti-factor authentication (MFA) bolsters security by mandating multiple authentication factors throughout the user lifecycle. The multi-factor authentication (MFA) process begins with Authentication, where the system verifies the customer's identity using credentials such as username and password. Successful authentication leads to Token Generation for subsequent resource access. Following authentication, an Authorization Check is performed to ensure the customer has permission to access the requested resource. If authorized, the process proceeds to Multi-Factor Authentication (MFA), which adds an extra layer of security by requiring a secondary factor, such as a one-time code. Successful completion of the MFA prompts the generation of a second Token Generation, granting the customer access.\nThe MFA process can be broken down into key phases: a Registration Phase where users associate their accounts with multiple unique identifiers, such as mobile devices or authenticator applications. An Authentication Phase follows, which requires users to provide the primary credentials (password) followed by a secondary authentication response generated by the linked device. This might involve receiving a one-time code or a push notification, which, upon verification from the user in the Reaction Phase, grants access to the system. MFA may vary, for example, with two-factor authentication (2FA) by using only two factors, a third-party authenticator application for managing the secondary authentication, the use of biometric authentication, and adaptive authentication based on the device being used."}, {"title": "MFA", "content": "MFA Implementation LLD\nThe system's login process begins with an Initiation, followed by Input Validation, where user-provided email (or phone number) and password are checked for accuracy. If the input is invalid, a Validation Error halts the process. Next, the system checks if CAPTCHA is enabled; if so, CAPTCHA Validation is performed, and failure generates a CAPTCHA Error. Following this, Credential Validation ensures the user's credentials are valid. Invalid credentials result in an Invalid Credentials Error. The system then determines whether MFA is Enabled for the user. If enabled, the system verifies the MFA Validation Type (email or Google Authenticator) and generates a one-time password (OTP) through Generate OTP, which is delivered to the user through Send Verification OTP. A JWT token is generated for the MFA request using Generated JWT Auth Token for MFA Request. A JWT token and a refresh token are generated through the Generated JWT Auth Token and Refresh Token once this is completed. Otherwise, if MFA is not enabled, a JWT token and a refresh token are directly generated. A Success Response concludes the login.\nThe Multi-Factor Authentication process starts with an Initiation, followed by Input Validation for the MFA OTP. An invalid OTP results in a Validation Error. The system then performs MFA Validation, throwing a MFA Validation Error for an incorrect OTP. If the validation is successful, a JWT token and a refresh token is generated through Generated JWT Auth Token and Refresh Token, followed by a Success Response to indicate the process is complete.\nEnable/Disable MFA Request\n\u2022\tValidate Input: Checks the validity of the input parameters provided by the user.\n\u2022\tThrow Validation Error: If the input is invalid, an error is thrown, and the process stops.\n\u2022\tType Check: Determines whether the user requested to enable MFA via email or Google authenticator.\n\u2022\tGenerate OTP and Send Verification OTP Email: If the user opts for email-based MFA, generates a one-time password (OTP) and sends it via email for verification. And it also saves the OTP in mfa table.\n\u2022\tGenerate Google Secret and QR Code Image: If the user opts for Google authenticator-based MFA, generates a secret key and a QR code image for scanning. And it also saves the secret in mfa table.\nGenerate OTP/Google secret on AUTH SVC.\n\u2022\tSend Success Response: Upon successful generation and delivery of the verification mechanism, sends a success response to the user.\nEnable/Disable MFA\n\u2022\tValidate Input: Ensures the validity of the input parameters provided by the user.\n\u2022\tThrow Validation Error: If the input is invalid, an error is thrown, and the process stops.\n\u2022\tType Check: Identifies whether the user chose email-based or Google authenticator-based MFA.\n\u2022\tValidate the OTP: Fetch the mfa row by user id, If the user chooses email-based MFA, validates the OTP sent to the user's email.\n\u2022\tValidate Google OTP with the Google-generated Secret: If the user opts for Google authenticator-based MFA, validates the OTP entered by the user against the Google-generated secret key. Validation should also process on AUTH SVC.\n\u2022\tGenerate Backup Codes if the Request is to Enable: If the user is enabling MFA, generates backup codes for future authentication.\n\u2022\tSend Success Response: Upon successful validation and processing of the MFA request, sends a success response to the user."}, {"title": "RBAC", "content": "RBAC Manage Groups Implementation LLD\nCHEZ PL CIAM-PAM architecture provides mechanism to build a multi-level grouping system where individual users, for example, can be part of a company and each user needs to associated with a valid company. Then each user can be mapped to N number of companies and a company can have N number of users. Furthermore, a multi-mapping approach is inherent in the design to allow both B2B and B2B2C type of operations for an enterprise architect.\nAdd/Edit Group\n\u2022\tValidate Input (Condition): Checks if the input provided for adding/editing a group is valid.\n\u2022\tThrow Validation Error (Process): Throws an error if the input is invalid.\n\u2022\tAuthorization Check (Condition): Verifies if the user is authorized to perform the action.\n\u2022\tThrow Authorization Error (Process): Throws an error if the user is not authorized.\n\u2022\tAdd/Update Group: Adds or updates the group with the provided master ID.\n\u2022\tSend Success Response (Process): Sends a success response after successfully adding/editing the group.\nDelete Group\n\u2022\tValidate Input (Condition): Checks if the input provided for deleting a group is valid.\n\u2022\tThrow Validation Error (Process): Throws an error if the input is invalid.\n\u2022\tAuthorization Check (Condition): Verifies if the user is authorized to perform the action."}, {"title": "GROUP MEMBERS & PERMISSIONS", "content": "\u2022\tThrow Authorization Error (Process): Throws an error if the user is not authorized.\n\u2022\tCheck Group Members (Condition): Checks if the group has any members.\n\u2022\tThrow Members Present Error (Process): Throws an error if group members are present.\n\u2022\tCheck Permissions (Condition): Checks if the group has any permissions assigned.\n\u2022\tThrow Permissions Present Error (Process): Throws an error if permissions are present.\n\u2022\tDelete Group: Deletes the group from the database.\n\u2022\tSend Success Response (Process): Sends a success response after successfully deleting the group.\nGroup Members & Permissions - Add/Delete Group Members\n\u2022\tValidate Input (Condition): Checks if the input provided for adding/deleting group members is valid.\n\u2022\tThrow Validation Error (Process): Throws an error if the input is invalid.\n\u2022\tAuthorization Check (Condition): Verifies if the user is authorized to perform the action.\n\u2022\tThrow Authorization Error (Process): Throws an error if the user is not authorized.\n\u2022\tAdd/Delete Group Members: Adds or deletes group members with the provided group ID and user ID.\n\u2022\tSend Success Response (Process): Sends a success response after successfully adding/deleting group members.\nAdd Group Permissions\n\u2022\tValidate Input: Checks the validity of the input parameters provided for adding group permissions.\n\u2022\tThrow Validation Error: If the input parameters are invalid, an error is thrown, and the process stops.\n\u2022\tAuthorization: Determines whether the user requesting to add group permissions is authorized to perform this action and, if the user type is \"user\", checks if the given permission ID is supposed to be added for the user role; if not, throws an authorization error and stops the process.\n\u2022\tThrow Authorization Error: If the user is not authorized, an error is thrown, and the process stops.\n\u2022\tAdd Group Permissions: If the validation and authorization are successful, the group permissions are added to the system.\n\u2022\tSend Response: Upon successful addition of group permissions, a success response is sent to the user.\n\u2022\tStop: Marks the end of the process.\nAnd, additionally, the permissions table should be externally provided. For instance, for the client creation action, the"}, {"title": "Database", "content": "\u201ccreate\", and the apps field can contain an array of app names. Furthermore, this permission can only be assigned to users by users if the permission role is set to \"user\".\nDatabase Modelling Implementation\nThe data model for RBAC within a CIAM system is designed to ensure efficient access control by optimizing lookups of users, their assigned roles, and associated permissions. It also focuses on maintaining data integrity through well-defined relationships and constraints, while supporting scalability to manage a large number of users, roles, permissions, and resources. Furthermore, the model facilitates auditing through proper logging mechanisms, enabling tracking of user access and permission changes and includes the ability to be future proofed, by allowing for new entities such as organizational units, to be added, ensuring it supports the changing requirements of an organization.\n\u2022\tmaster:\n\u2022\tuser:\n\u2022\tuser_details:\n\u2022\taddress:\n\u2022\tgroup:\n\u2022\tgroup_members:\n\u2022\tpermission:\n\u2022\tgroup_permission:\n\u2022\tresource:\n2. Gateway & PEP\nGateway acts as the central entry point for all customer requests, providing a unified interface and delegating authentication to the CIAM system. The main functions are to: route the request to appropriate backend services, validate user authentication tokens, manage microservices version & plug-ins for different applications enterprise & customer apps) via Autho2.0. Additionally, the Gateway tracks requests, responses, and traffic logs to improve observability."}, {"title": "RESOURCE ATTRIBUTES", "content": "On the other hand", "implementation.\nMicroservices": "n\u2022\tPEP (Policy Enforcement Point): Represents the component within microservices responsible for enforcing access control policies.\n\u2022\tfetch_resource (Filter the resource with group attributes): Represents"}]}