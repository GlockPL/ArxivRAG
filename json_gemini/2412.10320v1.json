{"title": "MeshA*: Efficient Path Planing With Motion Primitives", "authors": ["Marat Agranovskiy", "Konstantin Yakovlev"], "abstract": "We study a path planning problem where the possible move actions are represented as a finite set of motion primitives aligned with the grid representation of the environment. That is, each primitive corresponds to a short kinodynamically-feasible motion of an agent and is represented as a sequence of the swept cells of a grid. Typically heuristic search, i.e. A*, is conducted over the lattice induced by these primitives (lattice-based planning) to find a path. However due to the large branching factor such search may be inefficient in practice. To this end we suggest a novel technique rooted in the idea of searching over the grid cells (as in vanilla A*) simultaneously fitting the possible sequences of the motion primitives into these cells. The resultant algorithm, MeshA*, provably preserves the guarantees on completeness and optimality, on the one hand, and is shown to notably outperform conventional lattice-based planning (x1.5 decrease in the runtime), on the other hand. Moreover, we suggest an additional pruning technique that additionally decreases the search space of MeshA*. The resultant planner is combined with the regular A* to retain completeness and is shown to further increase the search performance at the cost of negligible decrease of the solution quality.", "sections": [{"title": "Introduction", "content": "Kinodynamic path planning is a fundamental problem in AI, automated planning and robotics. Among the various approaches to tackle this problem the following two are the most widespread and common: sampling-based planning (Karaman and Frazzoli 2011; Sakcak et al. 2019) and lattice-based planning (Pivtoraiko and Kelly 2005; Pivtoraiko, Knepper, and Kelly 2009). The former methods operate in the continuous space, rely on the randomized decomposition of the problem into the smaller sub-problems and are especially advantageous in high-dimensional planning (e.g. planning for robotic manipulators). Still they provide only probabilistic guarantees of the completeness and the optimality. Lattice-based planners rely on the discretization of the workspace/configuration space and provide strong theoretical guarantees w.r.t. this discretization. Consequently, they may be preferable when the number of degrees of freedom of the agent is not high, such as in mobile robotics when one primarily considers the coordinates and the heading of the robot.\nThis is a pre-print. Currently under review."}, {"title": "Related Work", "content": "A variety approaches to path finding with taking kinodynamic constraints of the mobile agent into account exists (Gonz\u00e1lez et al. 2016). One of the prominent approaches is sampling-based planning. The classical representative is RRT algorithm (LaValle and Kuffner 2001) that rapidly explores the configuration space. Its anytime modification, RRT* (Karaman and Frazzoli 2010), gradually improve the solution and is aimed at converging to optimal solutions. Informed RRT* (Gammell, Srinivasa, and Barfoot 2014) applies heuristics to enhance efficiency. RRT-Connect (Kuffner and LaValle 2000) is a fast bidirectional planner. RRTX is an adaptation of RRT tailored to fast re-planning needed for navigation of an agent in unpredictably changing environment.\nAnother approach is the lattice-based planning when a set of motion primitives, that respect the constraints of the agent, is constructed and then a search for a suitable sequence of such primitives is conducted. To compose primitives various approaches are be proposed, such as B-splines (Flores and Milam 2006), the shooting method (Jeon, Karaman, and Frazzoli 2011), the covering method (Yakovlev et al. 2022), learning techniques (De Iaco, Smith, and Czarnecki 2019), and others. In this work, we follow the lattice-based approach but do not focus on constructing the primitives themselves and consider them to be given (in the experiments we use a simple Newton's optimization method (Nagy and Kelly 2001) to obtain primitives for a car-like agent).\nIn this work we focus on reducing the search efforts in path planning. Numerous algorithms aimed at the similar goals have already been developed, such as Jump Point Search (Harabor and Grastien 2011), which significantly accelerates search on an 8-connected grid, and the well-known WA* (Ebendt and Drechsler 2009), which provides suboptimal solutions through the use of weighted heuristics."}, {"title": "Problem Statement", "content": "Consider a point-sized mobile agent that moves in a 2D workspace $W \\subset \\mathbb{R}^2$ that is composed of the free space, $W_{\\text{free}}$, and the obstacles, $W_{\\text{obs}}$, and is tessellated into the grid (composed of the square cells). A grid cell, denoted as $(i, j)$, is considered blocked if its intersection with $W_{\\text{obs}}$ is not empty, and is free otherwise.\nState Representation. The state of the agent is defined by a 3D vector $(x, y, \\phi)$, where $(x, y) \\in W$ are the coordinates in the workspace and $\\phi \\in [0,360^\\circ)$ is the heading angle. We assume that the latter can be discretized into a set $\\Theta := {\\theta_1, ..., \\theta_k}$, allowing us to focus on discrete states $s := (i, j, \\theta)$ that correspond to the centers of the grid cells $(i, j) \\in \\mathbb{Z}^2$, with $\\theta \\in \\Theta$.\nMotion Primitives. The kinematic constraints and physical capabilities of the mobile agent are encapsulated in motion primitives, each representing a short kinodynamically-feasible motion (i.e., a continuous state change). We assume that these primitives align with the discretization, meaning that transitions occur between two discrete states, such as $(i, j, \\theta)$ and $(i', j', \\theta')$. In other words, the motion starts at the center of a grid cell, ends at the center of another cell, and the agent's heading at the endpoints belongs to a finite set of possible headings. Each primitive is additionally associated with the collision trace, which is a sequence of cells swept by the agent when execution the motion, and cost which is a positive number (e.g. the length of the primitive).\nFor a given state $s = (i, j, \\theta)$ there is a finite number of motion primitives that the agent can use to move to other states. Moreover, we assume that there can be no more than one primitive leading to each other state, which corresponds to the intuitive understanding of a primitive as an elementary motion. We also consider that the space of discrete states, along with the primitives, is regular; that is, for any $\\delta_i, \\delta_j \\in \\mathbb{Z}$ if there exist a motion primitive connecting $(i, j, \\theta)$ and $(i', j', \\theta')$ then there also exists one from $(i + \\delta_i, j + \\delta_j, \\theta)$ to $(i' + \\delta_i, j' + \\delta_j, \\theta')$. While the endpoints of such primitives are distinct, the motion itself is not. This means that the collision traces of these primitives differ only by a parallel shift of the cells, and their costs coincide.\nThus, we can consider a canonical set of primitives \u2013 control set \u2013 from which all others can be obtained through parallel translation. We assume that such set is finite and is computed in advance according to the specific motion model of the mobile agent. To avoid any misunderstanding, we clarify that the term \"primitive\u201d and the corresponding notation $prim$ will be used in two contexts:\n*   When we refer to a primitive, we mean a specific motion between discrete states.\n*   When we specify that a primitive is from the control set, we mean a motion template that, when instantiated from a specific discrete state, yields an exact primitive.\nPath. A path is a sequence of motion primitives, where the adjacent ones share the same discrete state. The path's collision trace is the union of the collision traces of the constituent primitives (shown as blue cells in Fig. 1). A path is considered collision-free if its collision trace consists of the free cells only.\nProblem. Our task is to construct a collision-free path between the two given discrete states: the start one, $s_0$, and the goal one, $s_f$. We wish to solve this problem optimally, i.e. to obtain the least cost path, where the cost of the path is the sum of costs of the primitives forming the path."}, {"title": "Method", "content": "A well-established approach to solve the given problem is to search for a path on a state lattice graph, where the vertices represent the discrete states and edges \u2013 the primitives connecting them. In particular, heuristic search algorithms of the A* family can be used for such pathfinding.\nThese algorithms iteratively construct a search tree composed of the partial paths (sequences of the motion primitives). At each iteration the most prominent partial path is chosen for extension. Extension is done by expanding the path's endpoint \u2013 a discrete state $(i, j, \\theta)$. This expansion involves considering all the primitives that can be applied to the state, checking which ones are valid (i.e. do not collide with the obstacles), computing the transition costs, filtering out the duplicates (i.e. the motions that lead to the states for which there already exist paths in the search tree at a lower cost) and adding the new states to the tree. Indeed, as the number of available motion primitives increases the expansion procedure (which is the main building block of a search algorithm) becomes computationally burdensome and the performance of the algorithm degrades.\nPartially, this problem can be addressed by the lazy approach, where certain computations associated with the expansion are postponed, most often \u2013 collision checking. However, in environments with complex obstacle arrangements, searches that exploit lazy collision checking often extract invalid states (for which the collision check fails). Consequently, a significant amount of time is wasted on extra operations with the search tree, which is also time-consuming.\nWe propose an alternative approach. We abandon the search at the level of primitives and instead conduct the search at the level of cells, where the number of successors is limited and does not depend on the amount of motion primitives. During the search, we simultaneously reason about the possible motion primitives that can pass through the cells.\nThis is achieved through careful organization of the search space (i.e. we introduce a search element that is a combination of a cell and a set of primitives) and a proper definition of the successor relationship. As a result we are able to obtain optimal solutions faster leveraging the cell-by-cell nature of the search process.\nTo gain an intuition about how our search operates, consider an example illustrated in Fig. 2. On the left, we see a partial collision trace that ends with a magenta cell a cell that is under expansion. Assume that we know this cell can be reached by first applying the red primitive in the start state, followed by any of the green primitives (as their collision traces do not differ before reaching this cell). We store information about the primitives that pass through a cell, and this augmentation is called an extended cell (which is central to our approach and will be formally defined later). With this information, we can infer that the cell under expansion may have two successors (the ones that follow it along the green primitives) \u2013 the cells depicted in orange. We generate the corresponding extended cells as successors, propagating the information about the primitives that pass through them. At a later stage of the search, one of these cells is chosen for expansion - the one to the right (see the right part of Fig. 2). As the information on the motion primitives was propagated from its predecessor (note that the gray ones are not included in this information, as they led to a different cell from the predecessor), we can again establish which of the adjacent grid cells may serve as the continuation of the collision trace the cell above the expanding one.\nThis example highlights the main idea of our approach \u2013 conducting the search at the level of cells while simultaneously reasoning over the motion primitives that pass through them. Next, we describe it in more details."}, {"title": "The Search Space", "content": "The element of our search space is an extended cell. Formally it is a tuple:\n$u = (i, j, \\Psi)$, where\n*   $(i, j)$ is a grid cell,\n*   $\\Psi := { (prim_1, k), (prim_2, k), ..., (prim_n, k) | \\forall l \\in [1,n] : 1 \\leq k < U_{prim_l} }$ is a set of pairs consisting of a primitive from the control set and the non-maximum index in its collision trace. Here $U_{prim}$ is the number of cells in the collision trace of the primitive $prim$.\nTo better understand the definition, recall that the primitives from the control set are considered as the motion templates, which, when copied into a specific discrete state, yield a particular primitive. Thus, the conceptual meaning of this definition is as follows: for each pair $(prim, k) \\in \\Psi$, we consider a copy of $prim$ that traverses the cell $(i, j)$, in such a way that it is the $k$-th cell in the collision trace of that primitive. Consequently, the extended cell captures the information about the grid cell itself and the motion primitives that pass through it. Importantly, the index $k$ is the same across all the primitives \u201cstored\u201d in an extended cell. In Fig. 2, the magenta cells with the green primitives passing through them are the examples of the extended cells.\nThe projection of the extended cell $u = (i, j, \\Psi)$ will be referred to as the cell with the coordinates $(i, j)$. The set $\\Psi$ will be referred to as the configuration of primitives. In practice, instead of storing such a complex structure directly in an extended cell a single number can be used, obtained by numbering the configurations of primitives (more details on this are in the Appendix)."}, {"title": "Initial extended cells", "content": "As will be shown later, it is important for us to distinguish a special class of the configurations of primitives called initial."}, {"title": "Successors", "content": "To define the successor relationship between the extended cells let us first denote by\n$\\Delta_{prim}^{k} := (i' \u2013 i, j' \u2013 j)$\nthe change in the grid coordinates that occurs when transitioning from the $k$-th cell to the $(k+1)$-th cell in the collision trace of some primitive $prim$. This change will be referred to as the step along the primitive.\nLet $u = (i, j, \\Psi)$ and $v = (i', j', \\Psi')$ be two extended cells. How can $v$ be a successor of $u$? Intuitively, the successors of an extended cell are obtained simply as the results of steps along each primitive from the configuration (as illustrated in Fig. 2). To formally define the successor relationship, it is necessary to consider the following two cases:\n1.  Let $v$ be the initial extended cell, all primitives in which emerge at an angle $\\theta$ (i.e., $\\Psi' = \\Psi_{\\theta}$). Then $v$ is a successor of $u$ (we will also use term initial successor for $v$) if the following condition holds:\n$\\exists (prim, k) \\in \\Psi$ such that: $k = U_{prim} - 1$,\n$\\Delta_{prim}^{k} = (i' \u2013 i, j' \u2013 j)$ and $prim$ ends at angle $\\theta$\nThis condition requires that there exists a primitive $prim$ in $\\Psi$ for which the cells $(i, j)$ and $(i', j')$ are the last ones in the collision trace. In this case, at the cell $(i', j')$, we can consider its extension by a whole bundle of primitives that begin at the same angle $\\theta$ at which $prim$ ends.\n2.  If $v$ is not the initial extended cell, then $v$ is a successor of $u$ if the following conditions are simultaneously satisfied:\n(a)\n$\\forall (prim, k) \\in \\Psi'$ the following holds:\n$(prim, k - 1) \\in \\Psi$ and $(i' \u2013 i, j' \u2013 j) = \\Delta_{prim}^{k-1}$\n(b)\n$\\forall (prim, k) \\in \\Psi$ such that $k < U_{prim} - 1$ and\n$\\Delta_{prim}^{k} = (i' \u2013 i, j' \u2013 j)$ the following holds:\n$(prim, k + 1) \\in \\Psi'$\nCondition (b) requires that all primitives of the predecessor leading to the projection cell of the successor are present in its configuration, while Condition (a) ensures that there are no other primitives in the successor.\nHaving defined the successor relationship, we now define the cost of transitioning from a predecessor to a successor, assuming that the cost of each primitive $prim$ is $C_{prim}$.\nLet $u = (i, j, \\Psi)$ and $v = (i', j', \\Psi')$ be two extended cells, where $v$ is a successor of $u$. The cost of the transition from $u$ to $v$ is:\n*   $cost(u, v) = 0$ if $v$ is not an initial cell\n*   $cost(u, v) = C_{prim}$ where $prim$ is such that\n$(prim, U_{prim} - 1) \\in \\Psi$, $\\Delta_{prim}^{U_{prim} - 1} = (i' \u2013 i, j' \u2013 j)$ and $prim$ ends at angle $\\theta$ (where $\\theta : \\Psi' = \\Psi_{\\theta}$), otherwise\nNote that in the second case, such a primitive exists by the definition of the initial successor. If there are multiple such primitives, the cost associated with any of them can be chosen as cost(u, v). In fact, it will be shown in the next section that such ambiguity cannot exist."}, {"title": "MeshA*", "content": "Having defined the elements of the search space as well as the successor relationship, we obtain a directed weighted graph that we will call the mesh graph. We can utilize a standard heuristic search algorithm, i.e. A*, to search for a path on this graph. We will refer to this approach as MeshA*.\nNext we will show that running MeshA* leads to finding the optimal solution of the problem at hand, which is equivalent to the one found by A* on the lattice graph."}, {"title": "Theoretical Results", "content": "In this section, we will demonstrate the equivalence between searches on the mesh graph we constructed and those on the state lattice. The main result is Theorem 3, which outlines the recipe for trajectory construction.\nNote: to distinguish between a path as a sequence of vertices (where adjacent vertices are connected by an edge) in a certain graph and a path as a sequence of motion primitives, we will refer to the latter as the trajectory.\nLemma 1. Let an extended cell $u = (i, j, \\Psi)$ be given, and let the cell $(i', j')$ be such that it is the result of a step along one of the primitives from $u$, that is:\n$\\exists (prim, k) \\in \\Psi : \\Delta_{prim}^{k} = (i' \u2013 i, j' \u2013 j)$\nThen there exists a configuration of primitives $\\Psi'$ such that the extended cell $v := (i', j', \\Psi')$ will be a successor of $u$. Moreover, $\\Psi'$ can always be composed in such a way that it is non-initial, except in the case when $k = U_{prim} - 1$. In the latter case, $\\Psi' := \\Psi_{\\theta}$ (where $prim$ ends at the angle $\\theta$) will satisfy the lemma.\nLemma 2. For any path $u_1, u_2, ..., u_N$ on the mesh graph starting from an initial extended cell, the following holds:\n1.  For any another initial extended cell $u_l$ with $l > 1$ on this path, if all primitives of its configuration exit at some angle $\\theta$ (i.e., $\\Psi_l = \\Psi_{\\theta}$), then there exists a unique $(prim, k) \\in \\Psi_{l-1}$ such that $prim$ ends at angle $\\theta$, $k = U_{prim} - 1$, and $\\Delta_{prim}^{k} = (i_l \u2013 i_{l-1}, j_l \u2013 j_{l-1})$.\n2.  The costs of all transitions along the path are uniquely defined.\nNote that here we use the notation $u_l := (i_l, j_l, \\Psi_l)$.\nThe meaning of point 1 is that among the primitives in $\\Psi_{l-1}$, there is only one that ensures $u_l$ is a successor of $u_{l-1}$ (i.e., removing this primitive from configuration $\\Psi_{l-1}$ would cause $u_l$ to no longer be a successor of $u_{l-1}$).\nThe proofs of Lemmas 1 and 2 are straightforward and omitted for the sake of space. They can be found in the Appendix.\nTheorem 1. Let there be an edge in the state lattice graph, that is, some primitive $prim$ that transitions from one discrete state $s_a = (i_a, j_a, \\theta_a)$ to another $s_b = (i_b, j_b, \\theta_b)$. In this case, there exists a path in the mesh graph from the initial extended cell $(i_a, j_a, \\Psi_{\\theta_a})$ to another initial cell $(i_b, j_b, \\Psi_{\\theta_b})$ that satisfies the following conditions:\n1.  The projections of the vertices along this path precisely form the collision trace of this primitive.\n2.  The cost of this path is exactly equal to the cost of the primitive $C_{prim}$.\nProof. First, we note that, similar to the state lattice, the mesh graph is regular. That is, if there is a path between the extended cells $(i_1, j_1, \\Psi_1)$ and $(i_2, j_2, \\Psi_2)$, then there is also a path between all pairs $(i_1 + \\delta i, j_1 + \\delta j, \\Psi_1)$ and $(i_2 + \\delta i, j_2 + \\delta j, \\Psi_2)$ for any integers $\\delta i$ and $\\delta j$. This straightforwardly follows from the definition of the successor relation on the mesh graph, which is independent of the coordinates due to the regularity of the state lattice. Therefore, it suffices to prove the statement assuming that $prim$ is a primitive from the control set.\nFor convenience, we will use the notation $n = U_{prim}$. Let the collision trace of the $prim$ consists of cells $(i_1, j_1), (i_2, j_2),..., (i_n, j_n)$ (with indexing following the order of traversal along the primitive). From the condition, it follows that $i_1 = i_a, j_1 = j_a$ and $i_n = i_b, j_n = j_b$.\nNow, let us consider the extended cell $u_1 = (i_1, j_1, \\Psi_{\\theta_a})$. Since the primitive exits at an angle $\\theta_a$, it follows from the definition of the initial configuration of primitives that $(prim, 1) \\in \\Psi_{\\theta_a}$. Next, we observe that each cell $(i_k, j_k)$ results from a step along the primitive $prim$ from the cell $(i_{k-1}, j_{k-1})$, as they sequentially follow in the collision trace of this primitive. Thus, by Lemma 1, for the extended cell $u_1$ and the cell $(i_2, j_2)$, there exists a non-initial extended cell $u_2 = (i_2, j_2, \\Psi_2)$ that is a successor of $u_1$. By the definition of a non-initial successor, we get $(prim, 2) \\in \\Psi_2$. We can continue to apply Lemma 1 analogously, leading to the conclusion that for all $n-1 > k \\geq 2$, there exists a non-initial extended cell $u_k$ that is a successor of $u_{k-1}$ and $(prim, k) \\in \\Psi_k$. It remains to note that for the extended cell $u_{n-1}$ and the cell $(i_n, j_n)$, Lemma 1 also provides a successor, which is the initial cell $u_n = (i_n, j_n, \\Psi_{\\theta_{\\tau}})$, where the angle $\\theta_{\\tau}$ is precisely the angle at which $prim$ ends.\nFinally, we obtain a sequence $u_1, u_2, ..., u_n$ where each extended cell is a successor of the previous one, thus forming a path in the mesh graph. Since the projection $u_k$ is exactly $(i_k, j_k)$ (the $k$-th cell of the collision trace of the primitive), the first point of the theorem is proven.\nTo prove the second part, we note that in the considered path on the mesh graph, all transitions except the last lead to non-initial extended cells, meaning the costs of these transitions are equal to 0. The last transition occurs from the extended cell $u_{n-1} = (i_{n-1}, j_{n-1}, \\Psi_{n-1})$ to the initial extended cell $u_n = (i_n, j_n, \\Psi_{\\theta_{\\tau}})$. Since $u_{n-1}$ and $u_n$ are on the path from the initial extended cell $u_1$, according to Lemma 2, the cost of transitioning from $u_{n-1}$ to $u_n$ is uniquely defined. Since $(prim, n - 1) \\in \\Psi_{n-1}$, $\\Delta_{prim}^{n-1} = (i_n - i_{n-1}, j_n - j_{n-1})$, and $prim$ ends at the angle $\\theta$, in our case, this transition cost is exactly $C_{prim}$. This completes the proof of the second part.\nTheorem 2. Let two initial extended cells $u = (i, j, \\Psi_{\\theta})$ and $u' = (i', j', \\Psi_{\\theta'})$ be fixed. Suppose there exists a path in the mesh graph from the first one to the second one. Then, there will be a trajectory composed of primitives (corresponding to the path in the state lattice) that transitions from the discrete state $s = (i, j, \\theta)$ to $s' = (i', j', \\theta')$ and satisfies the following conditions:\n1.  The collision trace of this trajectory coincides with the projections of the vertices along this mesh graph path."}, {"title": "Proof", "content": "2.  The cost of this trajectory is equal to the cost of the path in the mesh graph.\nProof. We will prove the statement by mathematical induction on the number of initial extended cells along the specified path in the mesh graph. For one initial extended cell, the case is trivial, resulting in an empty trajectory.\nLet $U_1, U_2,..., U_N$ be the path in the mesh graph as specified, where $u_k$ denotes the extended cell $(i_k, j_k, \\Psi_k)$, with $u_1 = u$ and $u_N = u'$ being the initial extended cells from the condition. According to Lemma 2, all transition costs along this path are uniquely defined (which means that point 2 of the theorem is at least correctly formulated). Additionally, since $u_N$ is initial and a successor of $u_{N-1}$, there exists a unique (according to Lemma 2) primitive $prim$ from the control set such that $(prim, U_{prim} - 1) \\in \\Psi_{N-1}$, $prim$ ends at angle $\\theta'$ and $(i_N, j_N)$ is the result of a step along $prim$ from $(i_{N-1}, j_{N-1})$. In this case, the cost of transitioning from $u_{N-1}$ to $u_N$ is equal to $C_{prim}$.\nNext, using the definition of a non-initial successor, we find that since $u_{N-1}$ is a successor of $u_{N-2}$, it follows that $(prim, U_{prim} - 2) \\in \\Psi_{N-2}$ and the step along $prim$ from $(i_{N-2}, j_{N-2})$ leads to $(i_{N-1}, j_{N-1})$. Continuing this process, we obtain that for all $U_{prim} - 1 > k \\geq 1$, it holds that $(prim, k) \\in \\Psi_{N-U_{prim}+k}$ and $\\Delta_{prim} = (i_{N-U_{prim}+k+1} - i_{N-U_{prim}+k}, j_{N-U_{prim}+k+1} - j_{N-U_{prim}+k})$.\nThis result leads to two conclusions. First, if a copy of $prim$ (considered as a motion template) is placed at $(i_{N-U_{prim}+1}, j_{N-U_{prim}+1})$, then for the resulting primitive, the sequence of cells $(i_{N-U_{prim}+1}, j_{N-U_{prim}+1}),..., (i_N, j_N)$ forms its collision trace, as each cell in this sequence is the result of a step along the primitive from the previous cell. Second, since $(prim, 1) \\in \\Psi_{N-U_{prim}+1}$, it follows that the extended cell $u_{N-U_{prim}+1}$ is initial, because according to the definition of successors, this is the only case in which the configuration of primitives (of some extended cell that is a successor of another one) can include a primitive paired with the index 1 in its collision trace. Thus, we obtain that $\\Psi_{N-U_{prim}+1} = \\Psi_{\\phi}$, where the primitive $prim$ exits at an angle $\\phi$.\nAs a result, we have a sequence of extended cells $U_1, U_2, ..., U_{N-U_{prim}+1}$ that also forms a path in the mesh graph between the initial extended cells $u_1 = u = (i, j, \\Psi_{\\theta})$ and $u_{N-U_{prim}+1} = (i_{N-U_{prim}+1}, j_{N-U_{prim}+1}, \\Psi_{\\phi})$, but contains one fewer initial extended cell than the original path. This allows us to apply the induction hypothesis and conclude that there exists a trajectory composed of primitives that transitions from the discrete state $s = (i, j, \\theta)$ to t = $(i_{N-U_{prim}+1}, j_{N-U_{prim}+1}, \\phi)$, satisfying all the requirements of the theorem.\nSince this trajectory ends at the angle $\\phi$, at which $prim$ begins, and since, as previously discussed, we can consider the primitive obtained by copying $prim$ at $(i_{N-U_{prim}+1}, j_{N-U_{prim}+1})$, then we can append it to the end of this trajectory to obtain a trajectory that transitions from the discrete state $s$ to $s'$ (with a cost that increases by exactly $C_{prim}$). It corresponds to the original path in the mesh graph and obviously satisfies all the requirements of the theorem. This concludes the proof."}, {"title": "Theorem 3 (Main Theorem)", "content": "The search for a path in the state lattice graph is equivalent to the search for a path in the mesh graph in the following sense: to find a trajectory between the discrete states $s = (i, j, \\theta)$ and $s' = (i', j', \\theta')$ with a cost $c$, it is sufficient to perform two steps:\n1.  Find a path with cost $c$ in the mesh graph between the initial extended cells $u = (i, j, \\Psi_{\\theta})$ and $u' = (i', j', \\Psi_{\\theta'})$.\n2.  Recover the trajectory from $s$ to $s'$ based on the found path using Algorithm 3.\nThe proof of Theorem 3 involves a meticulous combination of previous results and is therefore omitted here. It can be found in the Appendix."}, {"title": "Soft Duplicates Pruning", "content": "As postulated above the main ingredient of MeshA* is the extended cell, which is a tuple $(i, j, \\Psi)$. For two extended cells, $(i, j, \\Psi)$ and $(i', j', \\Psi')$, to be equal all their elements should coincide. That is $i = i', j = j', \\Psi = \\Psi'$. This definition is used in MeshA* for detecting duplicates.\nConsider now two extended cells for which $i = i', j = j', \\Psi \\neq \\Psi'$, but most of the elements forming $\\Psi$ and $\\Psi'$ coincide. In other words, the extended cells share the coordinates but slightly differ in their constituting primitives. Intuitively, these extended cells are quite similar and can be considered soft duplicates and one can prune such duplicates in the search tree. We will dub an algorithm that utilizes such pruning of the soft duplicates as Mesh/PruningA*.\nThe specific rule for determining soft duplicates is left to the user, as it should be tailored based on preferences and experimental results. For our evaluations, we chose the following approach. For each extended cell in the mesh graph, we considered the set of vertices reachable from it in $\\leq 2$ steps (i.e., those for which there is a path consisting of no more than 2 edges), and then projected these vertices to obtain a corresponding set of grid cells. We considered vertices with shared coordinates as soft duplicates if their associated sets of grid cells coincide. In practice, it is sufficient to compare two numbers obtained from the enumeration of these sets (details can be found in the Appendix).\nIndeed, Mesh/PruningA* might consider less search nodes in practice due to pruning (and thus find a solution faster) but, evidently, it is incomplete in general. To this end we suggest to combine Mesh/PruningA* and regular A* that operates in the space of original motion primitives (not the extended cells) and is complete and optimal. That is we interleave two searches: after $K$ steps of Mesh/PruningA*, where $K$ is a user-defined parameter, we perform one step of regular A*. In our experiments we set $K$ to 100. We refer to such an approach as Mesh/ParallA*. Obviously, it is complete (as we have now regular A* in the loop). Still, the optimality of the solution is not guaranteed. However, we expect that in practice the cost overhead will be low. This expectation is confirmed by our empirical evaluation."}, {"title": "Empirical Evaluation", "content": "Setup. In the experiments we utilize 16 different headings and generate 24 motion primitives for each heading. We generate the primitives using the motion model of a car-like robot. We use four maps of varying topology from the well-known MovingAI benchmark (Sturtevant 2012) for the experiments. The start and goal locations on these maps were picked from the scenario files that are present in the benchmark. For any pair of start-goal locations we randomly generate three different headings. The total number of instances across all the maps exceeds 25000. Fig. 3 provides an overview of our setup.\nThe following algorithms were evaluated:\n1.  LBA* (short for Lattice-based A*): The standard A* algorithm on the state lattice", "LazyLBA*": "The same algorithm that conducts collision-checking lazily.\n3.  MeshA* (ours): Running A* on the mesh graph.\n4.  Mesh/ParallA* (ours): An"}]}