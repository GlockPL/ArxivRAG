{"title": "Flexora: Flexible Low Rank Adaptation for Large Language Models", "authors": ["Chenxing Wei", "Yao Shu", "Ying Tiffany He", "Fei Richard Yu"], "abstract": "Large Language Models (LLMs) are driving advancements in artificial intelligence by increasing the scale of model parameters, which has significantly enhanced generalization ability and unlocked new capabilities in practice. However, their performance in specific downstream tasks is usually hindered by their knowledge boundaries on these tasks. Thus, fine-tuning techniques, especially the widely used Low-Rank Adaptation (LORA) method, have been introduced to expand the boundaries on these tasks, whereas LoRA would underperform on certain tasks owing to its potential overfitting on these tasks. To overcome this overfitting and improve the performance of LORA, we propose the flexible low rank adaptation (Flexora) method to automatically and flexibly select the most important layers needing to be fine-tuned to achieve the best performance on different downstream tasks. Specifically, Flexora firstly frames this layer selection problem as a well-defined hyperparameter optimization (HPO) problem, then addresses it using the unrolled differentiation (UD) method, and finally selects the most useful layers based on the optimized hyperparameters. Our extensive experiments on many pre-trained models and natural language tasks show that Flexora is able to consistently improve over the existing baselines, indicating the effectiveness of our Flexora in practice. We additionally provide insightful theoretical results and many ablation studies to deliver a comprehensive understanding of our Flexora.", "sections": [{"title": "1 Introduction", "content": "The emergence of large language models (LLMs) (Zhao et al. 2023; Xu et al. 2023) has introduced significant computational demands (Touvron et al. 2023), characterized by extensive parameter sets and robust functionalities (Wei et al. 2022), necessitating substantial training resources. Consequently, parameter-efficient fine-tuning (PEFT) methods (Li and Liang 2021; Lester, Al-Rfou, and Constant 2021) have become increasingly popular. Among these, low-rank adaptation (LoRA) (Hu et al. 2021) is especially noteworthy. LoRA freezes pre-trained parameters and introduces auxiliary trainable parameters $AW$ at each layer, markedly reducing training costs while achieving impressive results. However, fine-tuning LLMs using LoRA still encounters challenges such as an excessive number of fine-tuning parameters and a tendency toward model overfitting, leading to suboptimal performance. Recently, researchers have proposed various methods to enhance LoRA. For example, AdaLoRA (Zhang et al. 2023b) employs singular value decomposition (SVD) to prune less critical singular values, while DORA (Mao et al. 2024a) dynamically reduces high-rank LoRA layers into structured single-rank components. Additionally, techniques such as dropout (Lin et al. 2024) and novel regularization strategy (Mao et al. 2024b) have been proposed to address overfitting. Despite these improvements, several limitations persist. Performance is often comparable to or lower than that of LoRA, and these methods do not automatically tune hyperparameters to achieve optimality, nor do they offer flexibility. Therefore, there is a pressing need for an algorithm that delivers good performance, enables automatic selection, and supports flexible training, which we have developed.\nHyperparameter optimization (HPO) is a fundamental problem in the field of machine learning (Liu, Simonyan, and Yang 2019a; Franceschi et al. 2018; Ren et al. 2019; Guo et al. 2020). The goal of HPO is to identify hyperparameter-hypothesis pairs that optimize the expected risk of test samples drawn from an unknown distribution. This involves solving two nested optimization problems: the inner problem focuses on optimizing the hypothesis on the training set for a specified hyperparameter configuration, while the outer problem aims to find hyperparameters that minimize the validation error. In recent years, unfolded differentiation (UD) algorithms have emerged as the mainstream solution for HPO due to their potential to adjust a large number of hyperparameters (Franceschi et al. 2017; Fu et al. 2016; Maclaurin, Duvenaud, and Adams 2015; Shaban et al. 2019). Inspired by HPO, we consider each layer of an LLM as a hypothesis, facilitating a layer-wise analysis of LLMs. Driven by the desire for a deeper understanding of LLMs, we have undertaken this work.\nIn this paper, we introduce a novel method, Flexora, designed to address the overfitting in LoRA by automatically and flexibly selecting the most critical layers for fine-tuning, as illustrated in Figure 1. To achieve this, we frame the layer selection problem as an HPO task and employ the UD method to solve it. More specifically, during the initialization stage, Flexora injects the defined hyperparameters into the LoRA parameters, producing a PEFT model ready for training. In the flexible layer selection stage, described in Sec. 4.1, the UD method optimizes this hyperparameter problem."}, {"title": "2 Related Work", "content": "2.1 Low-Rank Adaptation (LoRA)\nIn recent years, low-rank adaptation (LoRA) methods have gained widespread adoption to reduce the number of training parameters while fine-tuning large language models (LLMs) for specific applications. However, LoRA frequently suffers from overfitting, which results in poor performance on downstream tasks. To address this issue, researchers have developed various methods to alleviate overfitting by reducing training parameters. Wu et al. (2024) found that training all LoRA parameters may lead to overfitting, and proposed LoRA-SP, which randomly freezes half of the LoRA parameters during fine-tuning, thus effectively alleviating overfitting. Zhang et al. (2023a) noted that the down-projection weights in LoRA might lead to overfitting, and introduced LORA-FA, which freezes the down-projection weights and only updates the up-projection weights, thereby enhancing the performance. Zhou et al. (2024) proposed LoRA-drop, which prunes less important parameters based on layer output analysis, thus enhancing the generalization ability of the model. In contrast, Zhang et al. (2024) investigated the interaction between LoRA parameters and the original LLM and proposed LORAPrune. This method jointly prunes parts of the LORA matrix and parts of the LLM parameters based on the gradient of LoRA to further reduce overfitting. In addition, LoRAShear (Chen et al. 2023) introduces a knowledge-based structured pruning method that reduces the computational cost while retaining essential knowledge, thus reducing overfitting and enhancing generalization performance. Unfortunately, these methods usually (a) require significant manpower in an algorithm or configuration design, (b) struggle to yield adaptive policies across different downstream tasks, and (c) are often too complex (i.e., parameter-level policies) to be applied in practice. In contrast, in this paper, we introduce Flexora, a framework that aims to flexibly fine-tune LoRA across various downstream tasks using an automated yet simple layer-level policy.\n2.2 Hyperparameter Optimization (HPO)\nHPO is widely applied across various domains. Specifically, in the domain of neural architecture search, Liu, Simonyan, and Yang (2019b) conceptualizes the coefficients defining the network architecture as hyperparameters. In the domains of feature learning, Guo et al. (2020) considers feature extractors as hyperparameters. In the field of data science,"}, {"title": "3 Preliminaries", "content": "In this section, we first provide empirical insights showing that layer selection is crucial for improved performance of LLMs in Sec. 3.1, and then frame the layer selection problem as a well-defined HPO problem in Sec. 3.2.\n3.1 Empirical Insights\nTo investigate the relationship between the number of fine-tuning layers and overall performance, we conducted a preliminary study on Llama3-8B. The results, presented in Figure 2, indicate that while increasing the number of fine-tuning layers generally enhances model performance, there exists a critical threshold beyond which additional fine-tuning leads to overfitting and a subsequent decline in performance. Therefore, fine-tuning a subset of LoRA layers emerges as a natural strategy to minimize overfitting and enhance LoRA performance, aligning with numerous empirical findings. For instance, Zhu et al. (2023) employed a randomized and structured pruning approach on the original LLM pre-trained parameters and LoRA parameters of layers, training only the remaining subset of LoRA, and achieved favorable outcomes. Similarly, Zhou et al. (2024) analyzed the output values of LoRA elements across different layers and utilized output value pruning to reduce overfitting, thus improving performance by training a selected subset of layers. Additionally, Chen et al. (2023) highlighted that different layers encapsulate different types of knowledge, and pruning irrelevant layers can significantly enhance model performance on downstream tasks. In summary, fine-tuning a subset of LoRA layers offers several advantages: fewer parameters, reduced memory consumption, shorter training times, diminished overfitting, and ultimately, enhanced model performance.\n3.2 Problem Formulation\nInspired by the insights above, we aim to identify the most critical layers in LLM fine-tuning with LoRA to further improve generalization performance on varying downstream tasks. Formally, given a N-layer LLM with LoRA fine-tuning parameter $\\theta$, let hyperparameter $\\alpha \\in \\{0,1\\}^N$ represent the selection results of LoRA fine-tuning layers with 1 indicating that a layer will be selected, and define the expected test error $R_{\\text{test}}(\\theta, \\alpha) \\approx \\mathbb{E}_{x \\sim D_{\\text{test}}} l(x, \\theta; \\alpha)$ and the expected training error $R_{\\text{train}}(\\theta, \\alpha) = \\mathbb{E}_{x \\sim D_{\\text{train}}} l(x, \\theta; \\alpha)$. To select the most important LoRA fine-tuning layers in this LLM for its optimal fine-tuning performance on downstream tasks, we need to solve the following bilevel optimization problem:\n$\\min_{\\alpha\\in\\{0,1\\}^N} R_{\\text{test}} (\\theta^*(\\alpha), \\alpha) \\text{ s.t. } \\theta^*(\\alpha) = \\arg\\min_{\\theta \\in \\Theta} R_{\\text{train}} (\\theta, \\alpha) .\\tag{1}$ Of note, this formulation serves as a standard form of HPO as demonstrated in Bao et al. (2021), where $\\alpha$ is the hyperparameter. Consequently, we have framed the layer selection problem in LLM fine-tuning with LoRA as a well-defined HPO problem.\nUnfortunately, it is typically infeasible to obtain the training (i.e., $D_{\\text{train}}$) and test (i.e., $D_{\\text{test}}$) distributions for this optimization. As a result, we commonly use the training dataset $S_{\\text{train}}$ and validation dataset $S_{\\text{val}}$ to approximate the training and test distributions respectively. Define the empirical validation error $R_{\\text{val}} (\\theta, \\alpha) = \\mathbb{E}_{x \\sim S_{\\text{val}}} l(x, \\theta; \\alpha)$ and the empirical training error $R_{\\text{train}} (\\theta, \\alpha) = \\mathbb{E}_{x \\sim S_{\\text{train}}} l(x, \\theta; \\alpha)$, we aim"}, {"title": "4 The Flexora Framework", "content": "This section outlines the methodology behind our proposed Flexora framework. As shown in Figure 1, our Flexora framework consists of two major stages: a flexible layer selection stage detailed in Sec. 4.1 and a fine-tuning stage of the selected LoRA layers detailed in Sec. 4.2.\n4.1 Flexible Layer Selection Stage\nRelaxation and Computation. Due to the difficulty of optimizing the discrete layer selection hyperparameter $\\alpha = (\\alpha_1,...,\\alpha_N)$ directly, we relax it to the continuous counterpart $\\hat{\\alpha} = (\\hat{\\alpha}_1,...,\\hat{\\alpha}_N)$, with each $\\hat{\\alpha}_i$ defined as\n$\\hat{\\alpha}_i = \\frac{\\exp (a_i)}{\\sum_{i \\in [N]} \\exp (a_i)}N.\\tag{3}$ where a is initialized with zeros, and the constant scale $N$ is applied to ensure that the initialized $\\hat{\\alpha}$ is equivalent to the selection of all LoRA layers. The specific computation involving this hyperparameter is as follows:\n$h_i = Woz_i + \\alpha_i B_i Aiz_i.\\tag{4}$ Therefore, if $\\alpha_i$ is close to zero, it degenerates to the standard computation in the original LLM, indicating that LoRA is not required by this layer. Meanwhile, if $\\alpha_i$ is larger, intuitively, this layer requires LoRA more significantly for better performance.\nOptimization. To find the most important layers for fine-tuning LLMs on downstream tasks, we need to solve the HPO problem defined by Equation 2 in Section 3.2. To solve it, we will employ the UD algorithm. Specifically, we define $\\arg \\min_{\\Theta \\in \\mathcal{R}} R_{\\text{train}}(\\theta, \\alpha)$ as the inner layer optimization, where the LORA parameter $\\theta$ is updated. Similarly, we define $\\arg \\min_{\\alpha \\in \\{0,1\\}^N} R_{\\text{val}} (\\theta^*(\\alpha), \\alpha)$ as the outer layer optimization, where the hyperparameter $\\alpha$ is updated based on the results of the inner layer optimization.\nAccording to the aforementioned explanation, our primary optimization target is the hyperparameter $\\alpha$. In practice, we use Equation 3 to convert the hyperparameter a into $\\hat{\\alpha}$, which guides the layer selection at each step. As illustrated in Figure 1a, we initially set a to zeros and inject the hyperparameter into all LoRA parameters. Next, as illustrated in Figure 1b, we conduct inner layer training optimization for all layers and retain all computational graphs for subsequent outer layer updates. It is crucial to note that the computational graph is differentiable with respect to the hyperparameter $\\alpha$. Subsequently, we use the updated parameters $\\theta$ and computational graphs to conduct outer layer training K times. Each outer layer training iteration randomly selects batch data from the validation dataset for optimization. This process is formally described by Alg. 1, under the assumption that a and $\\theta$ are independent of $S_{\\text{val}}$ and $S_{\\text{train}}$. When fine-tuning large language models (LLMs), the substantial sizes of $S_{\\text{val}}$ and $S_{\\text{train}}$ make the gradient computation of Alg. 1 computationally infeasible, necessitating the use of stochastic gradient descent (SGD) for hyperparameter updates with a single outer layer update as follows:\n$\\alpha_{k+1} \\leftarrow \\alpha_k - \\nabla_{\\alpha} \\mathcal{R}_{\\text{val}} (\\theta_t (\\alpha), \\alpha)|_{\\alpha = \\hat{\\alpha}_t, data = \\{ d_j \\}} \\tag{5}$ where $d_j$ is randomly selected from $S_{\\text{val}}$. In subsequent epochs, we first apply Equation 4 to update the LoRA parameters of different layers based on the latest hyperparameters $\\alpha$. Then, we continue the optimization starting from the updated LoRA parameters. After minimizing the validation metric $\\mathcal{R}_{\\text{val}}$, as shown in Equation 2, we will end the training process and obtain the optimal configuration of hyperparameters.\nSelection Strategy. Based on our formulation, we have the following proposition:\nProposition 1. For any T > 0 and K \u2265 0 in our Alg. 1, the following condition holds if a is initialized with zeros,\n$\\sum_{i=1}^N \\hat{\\alpha}_i = 0.$\nProof detailed in Appendix A.1.Based on the optimized $a^*$, we automatically select the layers with $\\alpha_i > 0$ which has $\\hat{\\alpha}_i > 1$ to obtain the best performance. When resources are limited, we can flexibly choose the number of layers to fine-tune, optimizing performance within these constraints. Consequently, we only need to select the x layers with the largest $\\alpha_i$. This approach allows for both automatic and flexible selection of the number and specific layers for tuning.\n4.2 Fine-Tuning Stage\nSince the LORA parameters of all layers are updated alongside the hyperparameters during the flexible layer selection stage, direct deletion of LORA parameters from any layer is not feasible, necessitating a dedicated fine-tuning stage. During the fine-tuning stage, as illustrated in Figure 1c, we freeze the unselected layers and retrain the LoRA parameters from scratch. This selective activation strategy ensures that the model focuses on fine-tuning the most critical layers, thus minimizing overfitting and optimizing performance for specific downstream tasks."}, {"title": "5 Empirical Results", "content": "In this section, we present a comprehensive set of experiments to assess the effectiveness and efficiency of our proposed Flexora method. We first describe the datasets and experimental setup. Next, we detail the main results and ablation studies.\n5.1 Datasets and Setup\nTo evaluate the performance of our proposed Flexora method, we utilize several benchmark datasets, including Winogrande, RACE, PIQA, and Hellaswag, which collectively offer a comprehensive evaluation framework for various reasoning and comprehension tasks, with accuracy as the evaluation metric. Winogrande (Sakaguchi et al. 2019) evaluates commonsense reasoning using 44,000 questions, RACE (Lai et al. 2017) focuses on reading comprehension using nearly 100,000 questions, PIQA (Bisk et al. 2019) evaluates physics commonsense reasoning using more than 16,000 question-answer pairs, and Hellaswag (Zellers et al. 2019) tests commonsense natural language reasoning using 70,000 questions. In our experimental setup, we included 11 mainstream large-scale language models (LLMs), such as Llama3-8B (Meta 2024), Chatglm3-6B (GLM et al. 2024), Mistral-7B-v0.1 (Jiang et al. 2023), Gemma-7B (Team et al. 2024), and others. Flexora was developed using the Llamafactory (Zheng et al. 2024) framework and evaluated using the opencompass (Contributors 2023) framework. Detailed descriptions of data processing and experimental configurations can be found in the Appendix B. All experiments were performed on a single NVIDIA A100 GPU.\n5.2 Main Results\nIn the main experiments, we assess the performance improvement and training efficiency of Flexora on Llama3-8B, with results presented in Table 1 (accuracy) and Table 2 (time and parameters). Baselines include pre-trained models, Full FT, LoRA, AdaLoRA, LoRA-drop, LORAShear, and others. In particular, the experimental results with LoRAShear are detailed in Appendix C.3. The results indicate that Flexora outperforms all baselines. Compared to methods without LoRA, Flexora fine-tunes fewer parameters, thereby reducing overfitting and enhancing performance. When compared to methods that enhance LoRA, Flexora optimizes by considering the relationship between pre-trained parameters of each LLM layer and downstream tasks, achieving superior performance. Loss Detailed in Appendix C.6 Additionally, Flexora surpasses LoRA-drop, which always selects final layers, by identifying the most critical layers. Flexora also demonstrates strong generalization and scalability across different LLMs. Almost all LLMs can use Flexora to significantly improve performance with fewer fine-tuning parameters, as shown in Figure 3 and Appendix C.1"}, {"title": "5.3 Ablation Studies", "content": "Ablation Study 1 In the first ablation experiment, we maintained the number of layers selected by Flexora unchanged but chose different layers for fine-tuning. The experimental results are shown in Table 3. The result underscores two key points: First, Flexora can precisely determine the number of layers for fine-tuning. Even when the specific fine-tuning layers are chosen at random, the results continue to outperform LoRA. The theoretical explanation for this result can be found in Sec. 6. Second, Flexora can automatically and flexibly select the specific layers for fine-tuning, targeting the most important layers to maximize performance and generalization. Detailed in Appendix C.5\nAblation Study 2 In the second ablation experiment, we manually determined the number of fine-tuning layers and contrasted Flexora with random selection. The results in Table 4 underscore the flexibility of Flexora, demonstrating that it can achieve optimal performance irrespective of the number of fine-tuning layers. The specific layers selected are shown in Table 12. An notable observation is that Flexora often selects the initial and final layers. An intuitive explanation is that the initial and final layers of a model have a significant impact on the data. The initial layer directly transforms the input into the feature space, while the final layer predicts the data in the form of labels, rendering them crucial. Additionally, for the same downstream task, the input to the initial layer remains consistent and closely aligned with the task, and the output of the final layer is also consistent. Focusing on optimizing these layers can enhance learning efficiency. This conclusion is corroborated by other studies. Chen et al. (2023) observed that the knowledge distribution in LLMs is primarily concentrated in the initial and final layers. Sharma, Ash, and Misra (2023) demonstrated that the loss gradient of the initial and final layers is steep, which benefits the model during training. Pan et al. (2024) found that the weight norm of the initial and final layers is hundreds of times greater than that of the intermediate layers, indicative of their heightened importance."}, {"title": "6 Theoretical Insights", "content": "In this section, we provide theoretical explanations for why Flexora (using only a subset of LoRA layers) can achieve excellent results. We first introduce Theorem 1 below, and then simplify LoRA layers as linear layers in multi-layer perceptron (MLP) to derive our Proposition 2, aiming to offer insights for this question.\nTheorem 1. (Hardt, Recht, and Singer 2016) Assume that f(\u00b7; z) \u2208 [0, 1] is an L-Lipschitz and \u03b2-smooth loss function for every sample z. Suppose that we run SGM for T steps with monotonically non-increasing step sizes nt \u2264 c/t (t \u2208 [T]). In particular, omitting constant factors that depend on \u03b2, c, and L, we have\n$R_{\\text{test}} (\\theta, \\eta) \\leq R_{\\text{train}}(\\theta, \\eta) + \\frac{1}{\\sqrt{m}} \\eta^{-1/(c+1)}$ Theorem 1 reveals that if all the conditions except for \u03b2 in Theorem 1 remain the same, a smaller smoothness \u03b2 will typically result in a smaller test error $R_{\\text{test}}(\\theta, \\eta)$, indicating a better generalization performance in practice. To show how the number of LoRA layers is related to this \u03b2, we then follow the practice in (Shu, Wang, and Cai 2020) to prove our Proposition 2 below.\nProposition 2. For an N-layer linear multi-layer perceptron (MLP): $y^{(N)} = \\prod_{i=1}^N W^{(i)} x$ with MSE function $l = (y^{(N)} - y)^2 / 2$ where y denotes the true label, let $\\lambda^{(i)} = ||W^{(i)} ||$ for any i \u2208 [N], we then have.\n$\\frac{\\partial l}{\\partial W^{(i)} \\partial W^{(i)}} \\leq \\frac{2}{\\lambda^{(i)}} (\\prod_{j=1, j \\neq i}^N \\lambda^{(j)}) ||x^2|| ||W^{(i)} - W_{*}^{(i)}||.$"}, {"title": "7 Conclusion and Future Work", "content": "In this study, we introduce Flexora, a method designed to enhance the efficiency and effectiveness of fine-tuning large language models (LLMs). Flexora automatically and flexibly selects the most critical layers for fine-tuning, addressing overfitting and enhancing performance by modeling layer selection as an HPO problem and employing UD to solve it. This targeted fine-tuning approach reduces computational overhead by updating only selected layers. Extensive experiments demonstrate Flexora reduces parameters, suppresses overfitting, and enhances performance, outperforming baseline methods. We also provide a theoretical explanation for these improvements.\nFuture work will focus on the following areas: (a) Exploring the relationship between individual layers of the LLM and their impact on downstream tasks to theoretically elucidate the role of each layer in reasoning processes. (b) Investigating optimal fine-tuning schemes for Flexora, inspired by its enhanced performance when integrated with various LoRA-enhanced algorithms, as demonstrated in Appendix C.2."}, {"title": "B Experimental setting", "content": "In the main experiment, we compared Flexora with the baseline. The datasets and experimental parameters are as follows:\nB.1 Dataset\nWe added new templates to the original dataset to ensure the model could complete the required tasks and output formats. It is important to note that the added templates did not alter the original dataset, and special processing was performed for different LLMs. The specific examples are as follows:\nDataset Format of Hellaswag\n1 dataset: Hellaswag\n2 dataset format:\n3 {\n4 \"instruction\": \"{Article} \\n Question: {Question}\\n A. {Option A}\\nB. {Option B}\\nC. {Option C}\\nD. {\n5 Option D}\\n You may choose from 'A', 'B', 'C', 'D'.\\n Answer:\",\n6 \"output\": \"{Answer}\"\n7 }\n8 example:\n9 {\n \"instruction\": \"A man is sitting on a roof. He\\nQuestion: Which ending makes the most sense?\\n A. is\n using wrap to wrap a pair of skis. \\nB. is ripping level tiles off. \\nC. is holding a Rubik's cube.\\nD\n starts pulling up roofing on a roof. \\n You may choose from 'A', 'B', 'C', 'D'.\\n Answer:\",\n10 \"output\": \"D\"\n11 }\nDataset Format of PIQA\n1 dataset: PIQA\n2 dataset format:\n3 {\n4 \"instruction\": \"There is a single choice question. Answer the question by replying A or B.'\\n Question: {\n Question}\\nA. {Option A}\\nB.{Option B}\\nAnswer:\",\n5 \"output\": \"{Answer}\"\n6 }\n7 example:\n8 {\n9 \"instruction\": \"There is a single choice question. Answer the question by replying A or B.'\\n Question:\n When boiling butter, when it's ready, you can\\nA. Pour it onto a plate\\nB. Pour it into a jar\\\nnAnswer:\",\n10 \"output\": \"B\"\n11 }\nDataset Format of Winogrande\n1 dataset: Winogrande\n2 dataset format:\n3 {\n4 \"instruction\": \"There is a single choice question, you need to choose the correct option to fill in the\n blank. Answer the question by replying A or B.'\\n Question: {Question}\\nA.{Option A}\\nB. {Option B}\\nAnswer:\",\n5 \"output\": \"{Answer}\"\n6 }\n7 example:\n8 {\n9 \"instruction\": \"There is a single choice question, you need to choose the correct option to fill in the\n blank. Answer the question by replying A or B.'\\n Question: Sarah was a much better surgeon than\n Maria so always got the easier cases.\\nA. Sarah\\nB. Maria\\nAnswer:\",\n10 \"output\": \"B\"\n11 }"}, {"title": "B.2 Specific experimental parameters", "content": "Based on the Llama3-8B model configuration, several adjustments were made to optimize model performance. In the baseline model experiment, generation parameters were adjusted to ensure the correct output. In the LoRA experiment, adjustments to the generation parameters were retained, and LoRA-related parameters were adjusted. In the Flexora experiment, the size of the validation set was adjusted to control the time required to search for the optimal layer. In the AdaLoRA experiment, the initial rank size was modified to ensure that the fine-tuning parameters are consistent with Flexora. In the LoRA-drop experiment, the number of fine-tuning layers was set to be consistent with Flexora to ensure that the fine-tuning parameters are consistent. In the LoRAShear experiment, the pruning ratio was modified, where the parameter amount with a pruning ratio of 50% is consistent with Flexora. For specific experimental parameters, see the table 5."}, {"title": "B.3 Other LLMs experimental parameters", "content": "In order to explore the versatility and scalability of Flexora, we conducted experiments on multiple different LLMs. The specific training parameters are shown in Table 6."}, {"title": "C More results", "content": "C.1 The results of other LLMs experiment\nWide Applicability of Flexora. According to the parameter settings in Table 6, the verification results for various LLMs are presented in Table 7. The selected LLMs include Llama3-8B, Llama-7B, Llama2-7B, ChatGLM3-6B, Mistral-7B-v0.1, Gemma-7B, Zephyr-7B-beta, Vicuna-7B-v1.5, XuanYuan-6B, Qwen1.5-7B, and Yi-6B. These models demonstrate unique characteristics in terms of training data, architecture design, and optimized training. First, the models utilize varied training data, leading to differences in data distribution. Additionally, some models have enhanced attention mechanisms: Mistral-7B-v0.1 employs grouped query attention (GQA) and sliding window attention (SWA), while ChatGLM3-6B features a special attention design to support tool calling and code execution capabilities. Activation functions vary across these models. Llama3-8B uses the SwiGLU activation function, inspired by the PaLM model, to improve performance and convergence speed, while ChatGLM3-6B uses the Swish activation function. Furthermore, differences in reasoning optimization and multilingual capabilities contribute to varied reasoning abilities across fields. The experimental result of each model is shown in Table 7, which presents the scores of each model on different downstream tasks after LoRA and Flexora fine-tuning. It should be noted"}, {"title": "C.2 The results of other LoRAs experiment", "content": "Strong Scalability of Flexora. Recently, as emphasized in the Introduction 1, numerous LoRA improvement methods have been proposed, achieving excellent performance in specific fine-tuning tasks. In this section, the potential for combining Flexora with other emerging LoRA algorithms is explored. Two promising LoRA variants were selected from different approaches, each demonstrating impressive performance. Specifically, DoRA (Weight-Decomposed Low-Rank Adaptation) achieves low-rank adaptation through weight decomposition, and rsLoRA (Rank-Stabilized LoRA) addresses the slow training speed of traditional LORA by introducing a rank-stabilized scaling factor when increasing rank. These methods primarily address the parameter overfitting problem within LoRA parameters but overlook the overall overfitting issue. These methods were innovatively combined with Flexora to first address the overall overfitting problem and then tackle the overfitting of the remaining LORA parameters, resulting in notable performance improvements. The specific experimental results are shown in Table 8. The results indicate that Flexora integrates well with both DoRA and rsLoRA, effectively mitigating the overfitting problem of LLMs and improving performance with training on less than half of the parameters. The specific implementation entails replacing LORA with DORA or rsLoRA for inner layer optimization during the flexible layer selection stage, with the outer layer optimization remaining unchanged. These adjustments are achievable through straightforward modifications. The results demonstrate that Flexora exhibits strong scalability when combined with algorithms that enhance LoRA parameters, highlighting its significant potential."}, {"title": "C.3 Comparison with LoRAShear", "content": "Better Performance of Flexora. In this section, the accuracy of Flexora is compared with that of LoRAShear across various datasets, with specific results presented in Table 9. Since LoRAShear is not open source and poses challenges for direct experimentation, the comparison relies on the experimental configurations and results reported in the LoRAShear paper. Notably, Flexora can freely adjust the selected layers according to the dataset, achieving an average pruning parameter rate of 50%. Consequently, under the same pruning rate, Flexora outperforms by 14% (Ratio = 0.5).Experiments have shown that under the same pruning rate, Flexora can achieve better performance."}, {"title": "C.4 Different search sample", "content": "Flexibility of Flexora. In Flexora, search time is managed by adjusting the maximum number of search samples (corresponding to the size of the validation dataset) to align with the requirements of the downstream task. In Table 10, we explore the relationship between different numbers of search samples, downstream task performance, and search time. For simpler datasets like Hellaswag and PIQA, a 10-minute search with 1,000 samples significantly improves performance. For more challenging tasks, at least 1 hour of search time is required for 5,000 samples. In more difficult tasks, using too few samples can"}, {"title": "C.5 Selection of layers", "content": "For different LLMs and datasets, the layers chosen by Flexora vary due to the different parameters learned in the pre-training stage and the diversity of downstream tasks. In Table 11, Table 12, Table 13, Table 14, and Table 15, we show the layers chosen by Flexora in all experiments and the corresponding training parameters. In this section, the preferences of the layers chosen by Flexora are analyzed in detail, providing layer-wise insights for LLMs.\nThe Effectiveness of Flexora Comes from Reducing Overfitting. In Table 11, the layers and parameter amounts selected by different LoRA methods are presented. A comparison between LoRA-drop and Flexora reveals that Flexora is more effective. LoRA-drop tends to select the later layers, as these outputs exhibit a larger two-norm, aligning with Proposition 2. This result suggests that layers selected during fine-tuning should not concentrate in a specific range but rather be distributed across various ranges, fully utilizing the extensive knowledge system of LLMs. Comparing LoRA with DoRA and rsLoRA shows that LoRA selects more layers, requiring more training parameters but yielding worse performance. This suggests a higher degree of overfitting when Flexora is applied to LoRA compared to the other two methods. Therefore, using more advanced LORA improvement algorithms can significantly reduce overfitting and enhance performance, underscoring the importance of the fine-tuning approach. Interestingly, certain layers are consistently fine-tuned in the same downstream task, regardless of whether LoRA, DORA, or rsLoRA is used. For example, in Hellaswag, layers [0, 1, 2, 4, 14, 15, 19, 20, 21, 23, 26, 27, 28, 29, 31", "Select first 6 layers by Flexora\" row reveals that certain layers, such as [27, 28": "are crucial for any downstream task. These layers may store general knowledge, suggesting that their fine-tuning could enhance the performance across most downstream tasks.\nDownstream task-specific layers. Table 13 displays the layers and parameter amounts selected by various LLMs for different downstream tasks. As evident from the table, the same model utilizes the aforementioned general knowledge layers across different tasks. Additionally, unique layers for each downstream task, termed downstream task-specific layers, are predominantly found in the first and last layers. The distinction between general knowledge"}]}