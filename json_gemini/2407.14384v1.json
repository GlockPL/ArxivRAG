{"title": "The Sticky Path to Expressive Querying:\nDecidability of Navigational Queries under\nExistential Rules", "authors": ["Piotr Ostropolski-Nalewaja", "Sebastian Rudolph"], "abstract": "Extensive research in the field of ontology-based query answering has led to\nthe identification of numerous fragments of existential rules (also known as tuple-\ngenerating dependencies) that exhibit decidable answering of atomic and conjunc-\ntive queries. Motivated by the increased theoretical and practical interest in nav-\nigational queries, this paper considers the question for which of these fragments\ndecidability of querying extends to regular path queries (RPQs). In fact, decid-\nability of RPQs has recently been shown to generally hold for the comprehensive\nfamily of all fragments that come with the guarantee of universal models being\nreasonably well-shaped (that is, being of finite cliquewidth). Yet, for the second\nmajor family of fragments, known as finite unification sets (short: fus), which are\nbased on first-order-rewritability, corresponding results have been largely elusive\nso far. We complete the picture by showing that RPQ answering over arbitrary\nfus rulesets is undecidable. On the positive side, we establish that the problem is\ndecidable for the prominent fus subclass of sticky rulesets, with the caveat that a\nvery mild extension of the RPQ formalism turns the problem undecidable again.", "sections": [{"title": "Introduction", "content": "Existential rules, also known under the names tuple-generating dependencies (TGD) [1],\nDatalog+ [16], or \u2200\u2203-rules [2] have become a very popular formalism in knowledge\nrepresentation and database theory, with a plethora of applications in ontology-based\ndata access, data exchange, and many more. One of the fundamental tasks in the con-\ntext of existential rules is ontological query answering, where a query, expressing some"}, {"title": "Preliminaries", "content": "Structures and homomorphisms. Let F be a countably infinite set of function sym-\nbols, each with an associated arity. We define the set of terms Tas a minimal set\ncontaining three mutually disjoint, countably infinite sets of constants C, variables V,\nand nulls N that satisfies: f(t) \u2208 T for each tuple t of its elements and each symbol\nf\u2208 F of matching arity. A signature S is a finite set of predicates. We denote the arity\nof a predicate P with ar(P). An atom is an expression of the form P(t) where P is a\npredicate and t is an ar(P)-tuple of terms. Atoms of binary arity will also be referred to\nas edges. Facts are atoms containing only constants. An instance is a countable (possi-\nbly infinite) set of atoms. Moreover, we treat conjunctions of atoms as sets. A database\nis a finite set of facts. The active domain of an instance I, denoted adom(I), is the\nset of terms appearing in the atoms of I. We recall that instances naturally represent\nfirst-order (FO) interpretations.\nA homomorphism from instance I to instance I' is a function h : adom(I) \u2192\nadom(I') such that (1) for each atom P(t) of I we have P(h(t)) \u2208 I', and (2) for each\nconstant c\u2208 C we have h(c) = c. Given a finite instance I, a core of I is a minimal\nsubset I' such that I homomorphically maps to it. It is well known that all cores of a\nfinite structure are isomorphic, allowing us to speak of \u201cthe core\u201d \u2013 denoted core(I).\nQueries. A conjunctive query (CQ) is an FO formula of the form: \u2203x.\u03c6(x, y) where \u03c6\nis a conjunction of atoms over disjoint tuples of variables x, y. The tuple y denotes the\nfree variables of $. A query with no free variables is Boolean. A union of conjunctive\nqueries (UCQ) is a disjunction of conjunctive queries having the same tuples of free\nvariables. Seeing & as a set of atoms, the definition of homomorphism naturally extends\nto functions from CQs to instances.\nA regular path query (RPQ) is an expression \u2203z.A(x, y) where x and y are distinct\nvariables, z \u2286 { x, y }, and A is a regular expression over binary predicates from some\nsignature. Given an instance I and two of its terms s and t, we write I = A(s,t)\nto indicate that there exists a directed path P from s to t in I whose subsequent edge\nlabels form a word w such that w belongs to the language of A. Given a signature S,\nwe define S as the set {\u03c3\u00af | \u03c3\u2208 S}. Given an instance I over signature S, we define"}, {"title": "The Chase and Existential Rules", "content": "An FO formula p of the form \u2200x\u1ef9.a(x, y) \u2192 \u2203z.\u1e9e(\u1ef9, z) is called an existential rule\n(short: rule), where x, y and z are tuples of variables, a is a conjunction of atoms, and\n\u1e9e is an atom. We call a(x, y) the body of p and \u1e9e(\u1ef9, z) its head, while y is called\nthe frontier. CQs \u2203x.\u03b1(x, y) and \u2203z.\u1e9e(\u00ff, z) will be called the body query and the\nhead query of p, respectively. A rule is Datalog if z is empty. A finite set of rules is\nsimply called a ruleset. We may drop the universal quantifier in rules for visual clarity.\nSatisfaction of a rule p (a ruleset R) by an instance I is defined as usual and is written\nI = p (I = R). Given a database D and a ruleset R, we define an instance I to be a\nmodel of D and R, written I |= (D, R), iff D \u2286 I and I = R.\nQuerying under existential rules. Given a query Q(x), a set of rules R, and a\ndatabase D along with a tuple \u0101 of constants, we say that Q(\u0101) is entailed by D,R\niff every model of D and R satisfies Q(\u0101). In such a case we write D, R = Q(\u0101) or\nD,R,\u0101 = Q(x). We then also call the tuple \u00e0 a certain answer for the query Q(x)\nwith respect to D, R. Due to the computational similarity and easy interreducibility of\nthe two tasks, we will not distinguish query entailment from query answering and use\nthe two terms synonymously in this paper.\nNext, we recap a specialized version of the Skolem chase [22]. While more in-\nvolved than the \u201cmainstream\u201d Skolem chase, we need to employ this variant to estab-\nlish the required results regarding the various ruleset-transformations presented in the\npaper. In short, it enforces that the Skolem naming depends only on the shape of the\nrule head.\nIsomorphism types. Two CQs have the same isomorphism type if one can be obtained\nfrom the other by a bijective renaming of its variables (including existentially quanti-\nfied ones). We denote the isomorphism type of a CQ I as \u03c4(\u03a6). For a CQ (y) of\nisomorphism type 7 and any existentially quantified variable z of $(\u1ef9), we introduce a\n|y|-ary function symbol f.\nSkolemization. Let z be a tuple (z1,...zk) of variables. For a CQ \u00a2 = \u2203\u017e.\u03c8(\u1ef9, z)\nand a mapping h from \u1ef9 to a set of terms, we define the Skolemization sh($) of \u0444\nthrough h as the instance \u03c8(h(\u1ef9), (\u22481,...\u2248)) where z = f(h(y)) and is the"}, {"title": "Query Rewritability", "content": "Definition 2. Given a ruleset R and a UCQ Q(x) we say that a UCQ Q\u2032(x) is a\nrewriting of Q(x) (under R) if and only if, for every database D and tuple \u0101 of its\nconstants, we have:\nCh(D, R) = Q(\u0101) \u21d4 D = Q'(\u0101).\nFinite Unification Sets A rule set R is a finite unification set (fus) iff every UCQ has\na UCQ rewriting under R.\nBounded Derivation Depth Property We say a ruleset R admits the bounded deriva-\ntion depth property (is bdd) iff for every UCQ Q(x) there exists a natural number k\nsuch that for every instance I and every tuple of its terms \u0101 we have:\nCh(L, R) = Q(\u0101) \u21d4 Chk(I, R) |= Q(\u0101).\nIt turns out that fus and bdd classes are equivalent [6]:"}, {"title": "Sticky Rulesets", "content": "Definition 4 (Sticky). Following Cal\u00ec, Gottlob, and Pieris (2010), a ruleset R over\nsignature S is sticky iff there exists a marking > of S assigning to each P\u2208 S a subset\nof [1, ar(P)] called marked positions such that, for every p \u2208 R,\n\u2022 if x is a join variable in p then x appears at a marked position in the head-atom\nof p, and\n\u2022 if x appears in a body-atom of p at a marked position then x appears at a marked\nposition in the head-atom of p.\nObservation 5. Let I be an instance, R a sticky ruleset, and t a term from Ch(I, R)\nwith birth atom a. If some t' is on a marked position in a, then each atom \u1e9e containing\nt must also contain t' on a marked position.\nProof. We prove this by contradiction. Let i be the smallest natural number such that\nthere exists an atom \u03b2 \u2208 Chi(I, R) containing t but not t'. Take the rule p that created\nB and pick some atom y \u2208 Chi\u22121(I, R) containing t to which one of p's body atoms\nwas mapped. Then by assumption y contains t' in a marked position. However, since\nR is sticky, t' must appear in a marked position in \u1e9e, leading to a contradiction. \nDefinition 6. Following Gogacz and Marcinkowski (2017): A ruleset is joinless iff\nnone of its rule bodies contains repeated variables. Clearly, every joinless ruleset is\nsticky and therefore is fus."}, {"title": "On the Single-Head Assumption", "content": "Note that, throughout this paper, we assume that all rulesets are \"single-head\", meaning\nthat we disallow conjunctions of multiple atoms in the heads of rules. This is without\nloss of generality, due to the following transformation presented by Cal\u00ec, Gottlob, and\nKifer (2013): Given a multi-head ruleset Rmulti over a signature S, one can define\nthe ruleset Rsingle as follows: take a rule p of Rmulti\n\u03b2(x,y) \u2192 \u2203z. A\u2081(\u00ff, z),... An (\u1ef9, z)\nand replace it by the following collection of rules:\n{(x,y) \u2192 \u2203z. Pp(y, z) }\nU {Pp(y, z) \u2192 a\u00bf(\u1ef9, z) | i\u2208 [n]}\nwhere P is a fresh symbol, unique for each rule p."}, {"title": "Undecidability of RPQs over FUS", "content": "Theorem 7. Boolean RPQ entailment under fus rulesets is undecidable.\nWe shall prove the above theorem by a reduction from the halting problem for the\nfollowing kinds of two-counter automata.\nTwo-counter automaton. A two-counter automaton (TCA) consists of a finite set of\nstates Q, two positive integer counters called Cx and Cy, and an instruction instr(q) =\n(C, d, qt, qf) for each state q \u2208 Q which is executed as follows:\n1: if C == 0 then\n2: C:=C+1, move from q to qt\n3: else\n4:\nC:=C+d, move from q to qf\nwhere C\u2208 {Cx, Cy } and d \u2208 {\u22121,1}. In each step, the automaton executes the\ninstruction assigned to its current state and moves to the next. We also distinguish\na starting state qo\u2208Q and a halting state qhalt \u2208 Q. The TCA halting problem asks\nwhether a given TCA M can reach the halting state starting from qo with both counters\nset to zero. For a state q \u2208Q and numbers x and y representing the states of counters\nCx and Cy respectively, we call the tuple (q, x, y) a configuration of M. Note that our\nTCAs are deterministic.\nThe above TCA is a standard variation of one presented by Minsky (1967, Chapter\n14). The original automaton exhibits two types of instructions: 1) Add unity to counter\nC and go to the next instruction, and 2) If counter C is not zero, then subtract one and\njump to the n-th instruction, otherwise go to the next instruction. It is straightforward to\nimplement Minsky's automata by means of our TCAs. Thus, we inherit undecidability\nof the corresponding Halting problem.\nIn order to prove Theorem 7, we use the following reduction. Given a TCA M we\nconstruct a database Dgrid, ruleset Rgrid and a RPQ QM such that M halts starting\nfrom configuration \u3008q0,0,0) if and only if Dgrid, Rgrid = QM."}, {"title": "Database $D_{\\textit{grid}}$ and Ruleset $R_{\\textit{grid}}$", "content": "Both the database and the ruleset are independent of the specific TCA M considered\n\u2013 thus they are fixed. The idea behind the construction is that Ch(Dgrid, Rgrid) repre-\nsents an infinite grid. The database Dgrid consists of just the two atoms Succ(a, b) and\nZero(a)."}, {"title": "Grid G", "content": "Figure 1 visualizes Ch(Dgrid, Rgrid) restricted to the atoms using IncX, DecX, IncY,\nDecY, XZero, and YZero. As the soon to be defined RPQ QM only uses these binary\npredicates, it is sufficient to consider this part of Ch(Dgrid, Rgrid), which we denote\nby G.\nAs G resembles a grid, we find it convenient to introduce a few notions. First, we\nidentify any term of G with a pair of natural numbers called coordinates. As usual,\nthe first element of a coordinate pair is called X-coordinate, while the second is called\nY-coordinate."}, {"title": "RPQ Q\u043c", "content": "We shall define the Boolean regular path query QM by means of a deterministic finite\nautomaton AM. To simplify its definition, we will allow ourselves to write some ex-\npressions which evaluate to binary symbols from S. We let the function \u2211(\u00b7) assign\npredicates from \u2211 to operations and tests on the two counters:\n\u03a3(Cx := Cx + 1) = IncX,\n\u03a3(Cx := Cx - 1) = DecX,\n\u03a3(Cx==0) = XZero,\n\u03a3(Cy: = Cy + 1) = IncY,\n\u03a3(Cy : = Cy - 1) = DecY,\n\u03a3(Cy==0) = YZero.\nDefinition of the automaton Am. The DFA \u0410\u043c is a tuple (Qa, \u2211a, da, q\u0ed0, qfin)\nconsisting of the set of states QA, the alphabet \u03a3\u2081, the transition function \u0431\u0434, the\nstarting state qo, and the accepting state qfin.\nStates. The set QA of states of Am is QUQaux where Qaux is a set of auxiliary states\nconsisting of four states qthen1, qthens, qelse, and qelse2 for every state q \u2208 Q. The\nstarting (accepting) state of Am is the starting (halting) state of M.\nAlphabet. The alphabet \u2211 of Am consists of IncX, IncY, DecX, DecY, XZero, and\nYZero.\nTransition function. The transition function da of Am is a subset of QA \u00d7 \u03a3\u0391\u00d7 QA.\nFirst, we shall explain the transitions of Am in a graphical manner. Given a state\nq\u2208Q recall the instruction of M assigned to that state.\n1: if C == 0 then\n2: C:=C+1, move from q to qt\n3: else\n4: C:=C+d, move from q to qf\nNow, we take that instruction and with it we define the following transitions as\ndepicted in the figure below:"}, {"title": "Correspondence between QM and M", "content": "In this section we shall show the following lemma:\nLemma 10. Ch(Dgrid, Rgrid) = Qm if and only if M halts starting from (0,0, qo ).\nTo this end, we shall imagine a B-path corresponding to a match of QM to G. Its\ntwo first steps have to be over symbols XZero and YZero which is possible only at the\n(0,0) coordinates of the grid G. After this point, the query uses the automaton Am\nto define its behavior. Therefore, we will be discussing states and transitions of Am\nin the context of M. Imagine the automaton Am starting at coordinates (0,0) and\n\u201cwalking\u201d over G and \u201creading\u201d its binary predicates. We say that the automaton Am\nat coordinates (x, y) and in state q is in configuration (x, y, q). To prove Lemma 10,\nand thus Theorem 7, it is enough to inductively use the following observation:\nObservation 11. For all natural numbers x,x', y, and y' and every pair of states\nq, q'\u2208Q the following two are equivalent:\n\u2022 Automaton Am transitions from configuration (x, y, q) to (x',y', q') in three\nsteps.\n\u2022 TCA M transitions from (x, y, q) to (x', y', q') in one step."}, {"title": "Deciding RPQs over Sticky Rulesets", "content": "This section is dedicated to the following theorem:\nTheorem 12. RPQ entailment from sticky rulesets is decidable.\nTo simplify the intricate proof of the above, we restrict the query language to plain\nRPQs. However, it is straightforward to obtain the following as a consequence:\nCorollary 13. 2RPQ entailment from sticky rulesets is decidable.\nOne can obtain Corollary 13 by a simple reduction. Take a sticky ruleset R over\nsignature S, a database D and a 2RPQ Q. Keep D intact, add a single rule E(x, y) \u2192\nE'(y, x) to R for every binary predicate E \u2208 S, and replace every occurence of the"}, {"title": "Recursive Enumerability", "content": "This part exploits an easy reduction of RPQ entailment to a first-order entailment prob-\nlem.\nObservation 14. Given a Boolean RPQ Q = \u2203x, y.A(x, y) one can write a Datalog\nruleset Ro with one distinguished nullary predicate GOAL, such that:\nD, R = Q\nD, RURQ = GOAL.\nProof. See supplementary material, Appendix A.\nAs DARARQ is an FO theory, we can invoke completeness of FOL to recursively\nenumerate consequences of D, RURQ and therefore semi-decide D, RURQ\nGOAL. Thus, we can semi-decide D, R = Q as well."}, {"title": "Co-Recursive Enumerability", "content": "This part presents a greater challenge and necessitates a novel approach. We leverage\nthe fact that, following a specific pre-processing of D and R, the non-entailment of\nRPQs is witnessed by a finite instance\nDefinition 15. Given a query language L and a ruleset R we say that R is finitely\nL-controllable iff for every Q \u2208 L and for every database D such that D, R = Q there\nexists a finite model M of D and R s.t. M \u2260 Q.\nLemma 16. One can compute a database D+ and a ruleset R+ such that R+ is finitely\nRPQ-controllable and such that for every Boolean RPQ Q we have D, R = Q \u21d4\nD+, R+ = Q.\nIn view of this lemma, we can \u201cco-semidecide\" D,R |= Q (that is, semi-decide\nD, R Q) by recursively enumerating all finite instances and terminating whenever a\nQ-countermodel of D+, R+ is found."}, {"title": "Overview of the Proof of Lemma 16", "content": "Before we begin discussing the proof, let us introduce a specific class of rulesets:\nStellar rules. A stellar rule is a rule with at most one join variable, which also must\nbe a frontier variable. A ruleset comprising only stellar rules is stellar.\nThe ultimate goal is to construct R+ as a stellar ruleset. The reason behind this is\nas follows:\nLemma 17. Any ruleset consisting of stellar rules is finitely RPQ-controllable.\nWe will first prove the above lemma, then we will show the construction of R+ and\nD+."}, {"title": "Finite RPQ-Controllability", "content": "Assume S is a stellar ruleset. To prove its finite RPQ-controllability, we present, given\nsome database and a non-entailed RPQ, a construction of a finite countermodel. This\ninvolves two key parts: the \"finite model\u201d and the \"counter\" parts. We start with the\nfirst.\nFor any instance I and two of its terms t, t' we let I[t, t' \u2192 t"}, {"title": "Construction of D+ and R+", "content": "In this section, we construct D+ and R+ satisfying the two following lemmas. These,\ntogether with Lemma 17, establish Lemma 16.\nLemma 22. The ruleset R+ is stellar.\nLemma 23. For every Boolean query Q it holds:\nCh(D,R) = Q\u2194 Ch(D+,R+) |= Q.\nIn order to ensure the first of the two lemmas, we perform a couple of transforma-\ntions on the initially fixed sticky ruleset R. As we progress, we maintain intermediate\nvariants of the second lemma.\nRewriting-away non-stellar rules\nFor this step, we heavily rely on the stickiness (and thus fusness) of R. The below\nrelies on the idea that for fus rulesets, rewriting can be also applied to bodies of rules\n\u2013 yielding a new equivalent ruleset. This transformation preserves stickiness of the input\nruleset and, importantly, it preserves Boolean RPQ entailment."}, {"title": "Generalizing RPQs", "content": "Rather than having RPQs restricted to only use binary predicates, we may include\nhigher-arity predicates, with the assumption that only the first two positions matter for\nforming paths. We refer to RPQs that permit such slightly extended regular expressions\nas higher-arity regular path queries (HRPQs). We obtain the following:\nTheorem 38. Boolean HRPQ entailment under sticky rulesets is undecidable.\nIn order to prove the theorem, one can use the proof of Theorem 7 with a small\ntweak. Consider the ruleset from Definition 8 with the last six rules tweaked:\nSucc(x,x') \u2192 \u2203x\". Succ(x', x')\nSucc(x, x') / Succ(y, y') \u2192 \u2203z. GridPoint(x, y, z)\nGridPoint(x, y, z) \u2192 XCoord(z,x)\nGridPoint(x, y, z) \u2192 YCoord(z,y)\nCright (x, x', y, z, z') \u2192 IncX(z, z', x, x', y)\nCup(x, y, y', z, z') \u2192 IncY(z, z', x, y, y')\nIncX(z, z', u, v, t) \u2192 DecX(z', z, u, v, t)\nIncY(z, z', u, v, t) \u2192 DecY(z', z, u, v, t)\nXCoord(z, x) Zero(x) \u2192 XZero(z, z, x)\nYCoord(z, y) Zero(y) \u2192 YZero(z, z, y)\nand note that it is sticky \u2013 there exists a trivial marking of positions for it. The\nrest of the proof of Theorem 7 remains unchanged, observing that when we project\nIncX, IncY, DecX, DecY, XZero, and YZero to the first two positions, we obtain the\nprevious ruleset."}, {"title": "Generalizing stickiness", "content": "Alternatively, instead of generalizing RPQs, one can consider \u201cslightly non-sticky\"\nrulesets. Consider an extension of the above ruleset with the following projections.\nIncX(z, z', u, v, t) \u2192 IncXBin(z, z')\nDecX(z, z', u, v, t) \u2192 DecXBin(z, z')\nIncY(z, z', u, v,t) \u2192 IncYBin(z, z')\nDecY(z, z', u, v, t) \u2192 DecYBin(z, z')\nXZero(z, z, x) \u2192 XZeroBin(z, z)\nYZero(z, z,y) \u2192 YZeroBin(z, z)\nNote that such expanded ruleset would as well admit undecidable RPQ entailment, and\nthat the projections are not allowing for further recursion. Therefore the above ruleset\ncan be viewed as essentially sticky, just followed by one single projection step."}, {"title": "Conclusion", "content": "In this paper, we reviewed established existential rules fragments with decidable CQ\nanswering, asking if the decidability carries over to RPQs. We recalled that for the very\ncomprehensive fcs class of rulesets, the decidability for RPQs and even much more\nexpressive query languages follows from recent results. Thus focusing on the fus\nclass of rulesets, we established that they do not allow for decidable RPQ answering in\ngeneral, due to the insight that \u2013 unlike fcs rulesets - fus rulesets allow for the creation\nof grid-like universal models, which then can be used as a \"two-counter state space\", in\nwhich accepting runs of two-counter machines take the shape of regular paths. On the\nother hand, we showed that 2RPQ answering over sticky rulesets is decidable thanks\nto the reducibility to a finitely RPQ-controllable querying problem. This decidability\nresult is rather brittle and crucially depends on (1) the restriction of path expressions to\nbinary predicates and (2) the inability to freely project away variables in sticky rulesets.\nFor this reason, a setting where RPQs are slightly liberalized leads to undecidability\nagain.\nThere are several obvious questions left for future work:\n\u2022 What is the precise complexity of 2RPQ answering over sticky rulesets? Recall\nthat, as our decidability argument is based on finite controllability, the generic\ndecision algorithm ensuing from that does not come with any immediate upper\ncomplexity bound.\n\u2022 Does the problem remain decidable for sticky rulesets when progressing to CR-\nPQs or C2RPQs? We do not believe that a minor extension of our current proof\nwould be sufficient to positively settle this question, as we are currently lacking\nmethods of coping with variable joins in C(2)RPQs (under such circumstances,\nestablishing finite controllability via stellar types fails). However, we think that\nsome of the tools we used in this paper might come in handy when tackling that\nextended case."}]}