{"title": "The Sticky Path to Expressive Querying: Decidability of Navigational Queries under Existential Rules", "authors": ["Piotr Ostropolski-Nalewaja", "Sebastian Rudolph"], "abstract": "Extensive research in the field of ontology-based query answering has led to the identification of numerous fragments of existential rules (also known as tuple- generating dependencies) that exhibit decidable answering of atomic and conjunc- tive queries. Motivated by the increased theoretical and practical interest in nav- igational queries, this paper considers the question for which of these fragments decidability of querying extends to regular path queries (RPQs). In fact, decid- ability of RPQs has recently been shown to generally hold for the comprehensive family of all fragments that come with the guarantee of universal models being reasonably well-shaped (that is, being of finite cliquewidth). Yet, for the second major family of fragments, known as finite unification sets (short: fus), which are based on first-order-rewritability, corresponding results have been largely elusive so far. We complete the picture by showing that RPQ answering over arbitrary fus rulesets is undecidable. On the positive side, we establish that the problem is decidable for the prominent fus subclass of sticky rulesets, with the caveat that a very mild extension of the RPQ formalism turns the problem undecidable again.", "sections": [{"title": "Introduction", "content": "Existential rules, also known under the names tuple-generating dependencies (TGD) [1], Datalog+ [16], or \u2200\u2203-rules [2] have become a very popular formalism in knowledge representation and database theory, with a plethora of applications in ontology-based data access, data exchange, and many more. One of the fundamental tasks in the con- text of existential rules is ontological query answering, where a query, expressing some"}, {"title": "Preliminaries", "content": "Structures and homomorphisms. Let F be a countably infinite set of function sym- bols, each with an associated arity. We define the set of terms Tas a minimal set containing three mutually disjoint, countably infinite sets of constants C, variables V, and nulls N that satisfies: f(t) \u2208 T for each tuple t of its elements and each symbol f\u2208 F of matching arity. A signature S is a finite set of predicates. We denote the arity of a predicate P with ar(P). An atom is an expression of the form P(t) where P is a predicate and t is an ar(P)-tuple of terms. Atoms of binary arity will also be referred to as edges. Facts are atoms containing only constants. An instance is a countable (possi- bly infinite) set of atoms. Moreover, we treat conjunctions of atoms as sets. A database is a finite set of facts. The active domain of an instance I, denoted adom(I), is the set of terms appearing in the atoms of I. We recall that instances naturally represent first-order (FO) interpretations.\nA homomorphism from instance I to instance I' is a function h : adom(I) \u2192 adom(I') such that (1) for each atom P(t) of I we have P(h(t)) \u2208 I', and (2) for each constant c\u2208 C we have h(c) = c. Given a finite instance I, a core of I is a minimal subset I' such that I homomorphically maps to it. It is well known that all cores of a finite structure are isomorphic, allowing us to speak of \u201cthe core\u201d \u2013 denoted core(I).\nQueries. A conjunctive query (CQ) is an FO formula of the form: \u2203x.\u03c6(x, y) where \u03c6 is a conjunction of atoms over disjoint tuples of variables x, y. The tuple y denotes the free variables of $. A query with no free variables is Boolean. A union of conjunctive queries (UCQ) is a disjunction of conjunctive queries having the same tuples of free variables. Seeing & as a set of atoms, the definition of homomorphism naturally extends to functions from CQs to instances.\nA regular path query (RPQ) is an expression \u2203z.A(x, y) where x and y are distinct variables, z \u2286 { x, y }, and A is a regular expression over binary predicates from some signature. Given an instance I and two of its terms s and t, we write I \u22a8 A(s,t) to indicate that there exists a directed path P from s to t in I whose subsequent edge labels form a word w such that w belongs to the language of A. Given a signature S, we define S as the set {\u03c3\u00af | \u03c3\u2208 S}. Given an instance I over signature S, we define"}, {"title": "The Chase and Existential Rules", "content": "An FO formula p of the form \u2200x\u1ef9.\u03b1(x, y) \u2192 \u2203z.\u03b2(\u1ef9, z) is called an existential rule (short: rule), where x, y and z are tuples of variables, \u03b1 is a conjunction of atoms, and \u03b2 is an atom. We call \u03b1(x, y) the body of p and \u03b2(\u1ef9, z) its head, while y is called the frontier. CQs \u2203x.\u03b1(x, y) and \u2203z.\u03b2(\u1ef9, z) will be called the body query and the head query of p, respectively. A rule is Datalog if z is empty. A finite set of rules is simply called a ruleset. We may drop the universal quantifier in rules for visual clarity. Satisfaction of a rule p (a ruleset R) by an instance I is defined as usual and is written I \u22a8 p (I \u22a8 R). Given a database D and a ruleset R, we define an instance I to be a model of D and R, written I \u22a8 (D, R), iff D \u2286 I and I \u22a8 R.\nQuerying under existential rules. Given a query Q(x), a set of rules R, and a database D along with a tuple \u0101 of constants, we say that Q(\u0101) is entailed by D,R iff every model of D and R satisfies Q(\u0101). In such a case we write D, R \u22a8 Q(\u0101) or D,R,\u0101 \u22a8 Q(x). We then also call the tuple \u0101 a certain answer for the query Q(x) with respect to D, R. Due to the computational similarity and easy interreducibility of the two tasks, we will not distinguish query entailment from query answering and use the two terms synonymously in this paper.\nNext, we recap a specialized version of the Skolem chase [22]. While more in- volved than the \u201cmainstream\u201d Skolem chase, we need to employ this variant to estab- lish the required results regarding the various ruleset-transformations presented in the paper. In short, it enforces that the Skolem naming depends only on the shape of the rule head.\nIsomorphism types. Two CQs have the same isomorphism type if one can be obtained from the other by a bijective renaming of its variables (including existentially quanti- fied ones). We denote the isomorphism type of a CQ \u03a6 as \u03c4(\u03a6). For a CQ \u03a6(y) of isomorphism type \u03c4 and any existentially quantified variable z of \u03a6(y), we introduce a |y|-ary function symbol f.\nSkolemization. Let z be a tuple (z1,... zk) of variables. For a CQ \u00a2 = \u2203\u017e.\u03c8(\u1ef9, z) and a mapping h from \u1ef9 to a set of terms, we define the Skolemization sh(\u03a6) of \u03a6 through h as the instance 4(h(\u1ef9), (z1,...zk)) where z = f(h(y)) and 7 is the"}, {"title": "Query Rewritability", "content": "Definition 2. Given a ruleset R and a UCQ Q(x) we say that a UCQ Q\u2032(x) is a rewriting of Q(x) (under R) if and only if, for every database D and tuple \u0101 of its constants, we have:\nCh(D, R) \u22a8 Q(\u0101) \u21d4 D \u22a8 Q'(\u0101).\nFinite Unification Sets A rule set R is a finite unification set (fus) iff every UCQ has a UCQ rewriting under R.\nBounded Derivation Depth Property We say a ruleset R admits the bounded deriva- tion depth property (is bdd) iff for every UCQ Q(x) there exists a natural number k such that for every instance I and every tuple of its terms \u0101 we have:\nCh(L, R) \u22a8 Q(\u0101) \u21d4 Chk(I, R) \u22a8 Q(\u0101).\nIt turns out that fus and bdd classes are equivalent [6]:"}, {"title": "Sticky Rulesets", "content": "Definition 4 (Sticky). Following Cal\u00ec, Gottlob, and Pieris (2010), a ruleset R over signature S is sticky iff there exists a marking > of S assigning to each P\u2208 S a subset of [1, ar(P)] called marked positions such that, for every p \u2208 R,\n\u2022 if x is a join variable in p then x appears at a marked position in the head-atom of p, and\n\u2022 if x appears in a body-atom of p at a marked position then x appears at a marked position in the head-atom of p.\nObservation 5. Let I be an instance, R a sticky ruleset, and t a term from Ch(I, R) with birth atom \u03b1. If some t' is on a marked position in \u03b1, then each atom \u03b2 containing t must also contain t' on a marked position.\nProof. We prove this by contradiction. Let i be the smallest natural number such that there exists an atom \u03b2 \u2208 Chi(I, R) containing t but not t'. Take the rule p that created B and pick some atom \u03b3 \u2208 Chi\u22121(I, R) containing t to which one of p's body atoms was mapped. Then by assumption \u03b3 contains t' in a marked position. However, since R is sticky, t' must appear in a marked position in \u03b2, leading to a contradiction. \u25a1\nDefinition 6. Following Gogacz and Marcinkowski (2017): A ruleset is joinless iff none of its rule bodies contains repeated variables. Clearly, every joinless ruleset is sticky and therefore is fus."}, {"title": "On the Single-Head Assumption", "content": "Note that, throughout this paper, we assume that all rulesets are \"single-head\", meaning that we disallow conjunctions of multiple atoms in the heads of rules. This is without loss of generality, due to the following transformation presented by Cal\u00ec, Gottlob, and Kifer (2013): Given a multi-head ruleset Rmulti over a signature S, one can define the ruleset Rsingle as follows: take a rule p of Rmulti\n\u03b2(x,y) \u2192 \u2203z. A\u2081(\u1ef9, z),... An(\u1ef9, z)\nand replace it by the following collection of rules:\n{(x,y) \u2192 \u2203z. Pp(y, z) }\n\u222a {Pp(y, z) \u2192 ai(\u1ef9, z) | i\u2208 [n]}\nwhere P is a fresh symbol, unique for each rule p."}, {"title": "Undecidability of RPQs over FUS", "content": "Theorem 7. Boolean RPQ entailment under fus rulesets is undecidable.\nWe shall prove the above theorem by a reduction from the halting problem for the following kinds of two-counter automata.\nTwo-counter automaton. A two-counter automaton (TCA) consists of a finite set of states Q, two positive integer counters called Cx and Cy, and an instruction instr(q) = (C, d, qt, qf) for each state q \u2208 Q which is executed as follows:\n1: if C == 0 then\n2: C:=C+1, move from q to qt\n3: else\n4:\nC:=C+d, move from q to qf\nwhere C\u2208 {Cx, Cy } and d \u2208 {\u22121,1}. In each step, the automaton executes the instruction assigned to its current state and moves to the next. We also distinguish a starting state q\u2080\u2208Q and a halting state qhalt \u2208 Q. The TCA halting problem asks whether a given TCA M can reach the halting state starting from q\u2080 with both counters set to zero. For a state q \u2208Q and numbers x and y representing the states of counters Cx and Cy respectively, we call the tuple (q, x, y) a configuration of M. Note that our TCAs are deterministic.\nThe above TCA is a standard variation of one presented by Minsky (1967, Chapter 14). The original automaton exhibits two types of instructions: 1) Add unity to counter C and go to the next instruction, and 2) If counter C is not zero, then subtract one and jump to the n-th instruction, otherwise go to the next instruction. It is straightforward to implement Minsky's automata by means of our TCAs. Thus, we inherit undecidability of the corresponding Halting problem.\nIn order to prove Theorem 7, we use the following reduction. Given a TCA M we construct a database Dgrid, ruleset Rgrid and a RPQ QM such that M halts starting from configuration \u3008q0,0,0) if and only if Dgrid, Rgrid \u22a8 QM."}, {"title": "Database Dgrid and Ruleset Rgrid", "content": "Both the database and the ruleset are independent of the specific TCA M considered \u2013 thus they are fixed. The idea behind the construction is that Ch(Dgrid, Rgrid) repre- sents an infinite grid. The database Dgrid consists of just the two atoms Succ(a, b) and Zero(a)."}, {"title": "Grid G", "content": "Figure 1 visualizes Ch(Dgrid, Rgrid) restricted to the atoms using IncX, DecX, IncY, DecY, XZero, and YZero. As the soon to be defined RPQ QM only uses these binary predicates, it is sufficient to consider this part of Ch(Dgrid, Rgrid), which we denote by G.\nAs G resembles a grid, we find it convenient to introduce a few notions. First, we identify any term of G with a pair of natural numbers called coordinates. As usual, the first element of a coordinate pair is called X-coordinate, while the second is called Y-coordinate."}, {"title": "RPQ QM", "content": "We shall define the Boolean regular path query QM by means of a deterministic finite automaton AM. To simplify its definition, we will allow ourselves to write some ex- pressions which evaluate to binary symbols from S. We let the function \u03a3(\u00b7) assign predicates from \u2211 to operations and tests on the two counters:\n\u03a3(Cx := Cx + 1) = IncX,\n\u03a3(Cx := Cx - 1) = DecX,\n\u03a3(Cx==0) = XZero,\n\u03a3(Cy: = Cy + 1) = IncY,\n\u03a3(Cy : = Cy - 1) = DecY,\n\u03a3(Cy==0) = YZero.\nDefinition of the automaton Am. The DFA Am is a tuple (Qa, \u03a3a, \u03b4a, q\u2080, qfin) consisting of the set of states QA, the alphabet \u03a3\u2081, the transition function \u0431\u0434, the starting state qo, and the accepting state qfin.\nStates. The set QA of states of Am is QUQaux where Qaux is a set of auxiliary states consisting of four states qthen1, qthens, qelse, and qelse2 for every state q \u2208 Q. The starting (accepting) state of Am is the starting (halting) state of M.\nAlphabet. The alphabet \u2211 of Am consists of IncX, IncY, DecX, DecY, XZero, and YZero.\nTransition function. The transition function \u03b4a of Am is a subset of QA \u00d7 \u03a3\u0391\u00d7 QA. First, we shall explain the transitions of Am in a graphical manner. Given a state q\u2208Q recall the instruction of M assigned to that state.\n1: if C == 0 then\n2: C:=C+1, move from q to qt\n3: else\n4: C:=C+d, move from q to qf\nNow, we take that instruction and with it we define the following transitions as depicted in the figure below:"}, {"title": "Correspondence between QM and M", "content": "In this section we shall show the following lemma:\nLemma 10. Ch(Dgrid, Rgrid) \u22a8 Qm if and only if M halts starting from (0,0, qo ).\nTo this end, we shall imagine a B-path corresponding to a match of QM to G. Its two first steps have to be over symbols XZero and YZero which is possible only at the (0,0) coordinates of the grid G. After this point, the query uses the automaton Am to define its behavior. Therefore, we will be discussing states and transitions of Am in the context of M. Imagine the automaton Am starting at coordinates (0,0) and \u201cwalking\u201d over G and \u201creading\u201d its binary predicates. We say that the automaton Am at coordinates (x, y) and in state q is in configuration (x, y, q). To prove Lemma 10, and thus Theorem 7, it is enough to inductively use the following observation:\nObservation 11. For all natural numbers x,x', y, and y' and every pair of states q, q'\u2208Q the following two are equivalent:\n\u2022 Automaton Am transitions from configuration (x, y, q) to (x',y', q') in three steps.\n\u2022 TCA M transitions from (x, y, q) to (x', y', q') in one step."}, {"title": "Deciding RPQs over Sticky Rulesets", "content": "This section is dedicated to the following theorem:\nTheorem 12. RPQ entailment from sticky rulesets is decidable.\nTo simplify the intricate proof of the above, we restrict the query language to plain RPQs. However, it is straightforward to obtain the following as a consequence:\nCorollary 13. 2RPQ entailment from sticky rulesets is decidable.\nOne can obtain Corollary 13 by a simple reduction. Take a sticky ruleset R over signature S, a database D and a 2RPQ Q. Keep D intact, add a single rule E(x, y) \u2192 E'(y, x) to R for every binary predicate E \u2208 S, and replace every occurence of the"}, {"title": "Recursive Enumerability", "content": "This part exploits an easy reduction of RPQ entailment to a first-order entailment prob- lem.\nObservation 14. Given a Boolean RPQ Q = \u2203x, y.A(x, y) one can write a Datalog ruleset Ro with one distinguished nullary predicate GOAL, such that:\nD, R \u22a8 Q \u21d4 D, R\u222aRQ \u22a8 GOAL.\nAs DARARQ is an FO theory, we can invoke completeness of FOL to recursively enumerate consequences of D, RURQ and therefore semi-decide D, RURQ \u22ad GOAL. Thus, we can semi-decide D, R \u22a8 Q as well."}, {"title": "Co-Recursive Enumerability", "content": "This part presents a greater challenge and necessitates a novel approach. We leverage the fact that, following a specific pre-processing of D and R, the non-entailment of RPQs is witnessed by a finite instance\nDefinition 15. Given a query language L and a ruleset R we say that R is finitely L-controllable iff for every Q \u2208 L and for every database D such that D, R \u22a8 Q there exists a finite model M of D and R s.t. M \u22ad Q.\nLemma 16. One can compute a database D+ and a ruleset R+ such that R+ is finitely RPQ-controllable and such that for every Boolean RPQ Q we have D, R \u22a8 Q \u21d4 D+, R+ \u22a8 Q.\nIn view of this lemma, we can \u201cco-semidecide\" D,R \u22a8 Q (that is, semi-decide D, R \u22ad Q) by recursively enumerating all finite instances and terminating whenever a Q-countermodel of D+, R+ is found."}, {"title": "Overview of the Proof of Lemma 16", "content": "Before we begin discussing the proof, let us introduce a specific class of rulesets:\nStellar rules. A stellar rule is a rule with at most one join variable, which also must be a frontier variable. A ruleset comprising only stellar rules is stellar.\nThe ultimate goal is to construct R+ as a stellar ruleset. The reason behind this is as follows:\nLemma 17. Any ruleset consisting of stellar rules is finitely RPQ-controllable.\nWe will first prove the above lemma, then we will show the construction of R+ and D+."}, {"title": "Finite RPQ-Controllability", "content": "Assume S is a stellar ruleset. To prove its finite RPQ-controllability, we present, given some database and a non-entailed RPQ, a construction of a finite countermodel. This involves two key parts: the \"finite model\u201d and the \"counter\" parts. We start with the first.\nFor any instance I and two of its terms t, t' we let I[t, t' \u2194 t\"] denote the structure obtained from I by replacing each occurrence of t or t' by the fresh null t''.\nPreservation of modelhood under this kind of \"term merging\" is trivial for rules without join variables:\nObservation 18. Let I be an instance with terms s, t and p a joinless rule.Then I \u22a8 p implies I[s, t\u2194u] \u22a8 p.\nProof. Note, as p is joinless, identification of terms cannot create new active triggers. \u25a1\nFor stellar rules with a join variable, we define a kind of 1-type that indicates which terms are similar enough so they can be \u201cmerged\" while preserving modelhood.\nStellar types. A stellar query (SQ) is a CQ S(y) such that y is the only join variable of S and each atom of S has at most one occurrence of y. Given a term t of some instance I the stellar type \u2605(t) of t is the (up to equivalence) most specific\u00b3 SQ S(y) such that I \u22a8 S(t).\nObservation 19. Let I be an instance with terms s,t satisfying \u2605(s) = \u2605(t) and p a stellar rule with a single join variable. Then I \u22a8 p implies I[s, t\u21a6u] \u22a8 p.\nProof. Observe \u2605(s) = \u2605(t) = \u2605(u) and that the stellar types of other terms remain unchanged after identification (\u2661). Let \u03b1(z) be a head of p, with 2 a tuple of its frontier variables. Note that as p is stellar, 2 contains its join-variable denoted by x. Let Hv be the set of homomorphisms from a body of p to I such that x is always mapped to v. Note, it can be determined whether every trigger in the set (p, h) | h \u2208 H\u2082 is satisfied based only on the stellar type of v. Therefore, from (\u2661), the satisfaction of \u03b1(z) is preserved. \u25a1"}, {"title": "Construction of D+ and R+", "content": "In this section, we construct D+ and R+ satisfying the two following lemmas. These, together with Lemma 17, establish Lemma 16.\nLemma 22. The ruleset R+ is stellar.\nLemma 23. For every Boolean query Q it holds:\nCh(D,R) \u22a8 Q\u2194 Ch(D+,R+) \u22a8 Q.\nIn order to ensure the first of the two lemmas, we perform a couple of transforma- tions on the initially fixed sticky ruleset R. As we progress, we maintain intermediate variants of the second lemma.\nRewriting-away non-stellar rules\nFor this step, we heavily rely on the stickiness (and thus fusness) of R. The below relies on the idea that for fus rulesets, rewriting can be also applied to bodies of rules \u2013 yielding a new equivalent ruleset. This transformation preserves stickiness of the input ruleset and, importantly, it preserves Boolean RPQ entailment."}, {"title": "Definitions", "content": "Definition 24. Given an existential rule p \u2208 R of the form: \u03b1(x, y) \u2192 \u2203z. \u03b2(\u1ef9, z) let rew(p, R) be the ruleset:\n{(x,y) \u2192 \u2203z. \u03b2(y,z) |\n\u2203'. (1',\u1ef9) \u2208 rew(\u2203r.a(1,\u1ef9), R) }.\nFinally, let rew(R) = R\u222a\u222a\u03c1\u2208r rew(\u03c1, R).\nDefinition 27. A ruleset R' is quick iff for every instance I and every atom \u03b2 of Ch(I, R') if all frontier terms of \u03b2 appear in adom(I) then \u03b2\u2208 Ch\u2081(I, R').\nDefinition 29. Given an existential rule p of the form \u03b1(x, y) \u2192 \u2203z. \u03b2(\u1ef9, z), we define core(p) as the existential rule \u03b1\u2032(x', \u1ef9) \u2192 \u2203z. \u03b2(\u1ef9, z) where \u03b1' is a core of \u03b1 with variables y treated as constants."}, {"title": "Lemmas", "content": "Lemma 3. A ruleset R is fus if and only if it is bdd.\nLemma 25. The ruleset rew(R) is sticky.\nLemma 26. For every Boolean RPQ Q we have:\nCh(D,R) \u22a8 Q \u2190 Ch(D, rew(R)) \u22a8 Q.\nLemma 28. For any fus ruleset R, rew(R) is quick.\nLemma 34. Ch(D,R+) and Ch(D, cr+(R)) when restricted to the binary atoms containing at least one non-constant term are equal.\nLemma 39. Given a sticky ruleset R' and its rule p we have that rewr' (p, R') is sticky.\nLemma 40. Given a UCQ Q(v) and a fus ruleset R, the following are equivalent for every instance I and a tuple a of its elements:\nLemma 42. Both Ch(D,R) and Ch(D, rew(R)) can be homomorphically mapped into each other."}, {"title": "Observations", "content": "Observation 5. Let I be an instance, R a sticky ruleset, and t a term from Ch(I, R) with birth atom \u03b1. If some t' is on a marked position in \u03b1, then each atom \u03b2 containing t must also contain t' on a marked position.\nObservation 9. Ruleset R is fus\nObservation 18. Let I be an instance with terms s, t and pa joinless rule.Then I \u22a8 p implies I[s, t\u2194u] \u22a8 p.\nObservation 19. Let I be an instance with terms s,t satisfying \u2605(s) = \u2605(t) and pa stellar rule with a single join variable. Then I \u22a8 p implies I[s, t\u21a6u] \u22a8 p.\nObservation 31. Ch(D, cr(R)) = Ch(D, rew(R)), and cr(R) is both sticky and quick.\nObservation 32. Ch(D, cr+(R)) = Ch(D,rew(R)), and cr+(R) is sticky and quick.\nObservation 36. D+ is computable."}, {"title": "Other steps", "content": "Introducing redundant stellar rules. We are one step away from defining R+. Let cr+(R) be the ruleset obtained from cr(R) by augmenting it with a set of additional rules as follows: For every non-stellar rule p in cr(R), let cr+(R) also contain the rule derived from p by substituting all its join variables by one and the same fresh variable.\nDefining R+ is to remove all rules which contains two or more join variables.\nTaking cores of rules is to make the set of rules for a ruleset to be equivalent while taking less rules.\nRewriting away non-stellar rules is to make the rule set simpler.\nWith this, lemmas can be combined and proofs can be shown."}, {"title": "Corollaries", "content": "Corollary 1. Let R be a ruleset such that for every database D, there exists a universal model of D, R having finite cliquewidth. Then C2RPQ answering wrt. R is decidable.\nCorollary 13. 2RPQ entailment from sticky rulesets is decidable.\nCorollary 20. Let I be an instance with terms s,t satisfying \u2605(s) = \u2605(t), and let S be a stellar ruleset. Then I \u22a8 S implies I[s, t \u2192 u] \u22a8 S.\nCorollary 37. For every Boolean RPQ Q Ch(D, cr+(R)) \u22a8 Q \u2194 Ch(D+,R+) \u22a8 Q.\nCorollary 41. For every fus ruleset and a UCQ Q(v) there exists a k \u2208 N such that for every instance I and a tuple \u0101 of its terms we have:\nCh(L,R) \u22a8 Q(\u0101) \u2194 I \u22a8 rew\u02ca(Q(\u0101))."}, {"title": "Undecidability and Stickiness", "content": "In this section we show two seemingly harmless generalizations of the (decidable) case studied in the previous section. Importantly, both lead to undecidability and, given that both generalizations are rather slight, they highlight that the identified decidability result is not very robust."}, {"title": "Generalizing RPQs", "content": "Rather than having RPQs restricted to only use binary predicates, we may include higher-arity predicates, with the assumption that only the first two positions matter for forming paths. We refer to RPQs that permit such slightly extended regular expressions as higher-arity regular path queries (HRPQs). We obtain the following:\nTheorem 38. Boolean HRPQ entailment under sticky rulesets is undecidable.\nIn order to prove the theorem, one can use the proof of Theorem 7 with a small tweak. Consider the ruleset from Definition 8 with the last six rules tweaked:\nSucc(x,x') \u2192 \u2203x\". Succ(x', x')\nSucc(x, x') \u2227 Succ(y, y') \u2192 \u2203z. GridPoint(x, y, z)\nGridPoint(x, y, z) \u2192 XCoord(z,x)\nGridPoint(x, y, z) \u2192 YCoord(z,y)\nCright (x, x', y, z, z') \u2192 IncX(z, z', x, x', y)\nCup(x, y, y', z, z') \u2192 IncY(z, z', x, y, y')\nIncX(z, z', u, v, t) \u2192 DecX(z', z, u, v, t)\nIncY(z, z', u, v, t) \u2192 DecY(z', z, u, v, t)\nXCoord(z, x) \u2227 Zero(x) \u2192 XZero(z, z, x)\nYCoord(z, y) \u2227 Zero(y) \u2192 YZero(z, z, y)\nand note that it is sticky \u2013 there exists a trivial marking of positions for it. The rest of the proof of Theorem 7 remains unchanged, observing that when we project IncX, IncY, DecX, DecY, XZero, and YZero to the first two positions, we obtain the previous ruleset."}, {"title": "Generalizing stickiness", "content": "Alternatively, instead of generalizing RPQs, one can consider \u201cslightly non-sticky\" rulesets. Consider an extension of the above ruleset with the following projections.\nIncX(z, z', u, v, t) \u2192 IncXBin(z, z')\nDecX(z, z', u, v, t) \u2192 DecXBin(z, z')\nIncY(z, z', u, v,t) \u2192 IncYBin(z, z')\nDecY(z, z', u, v, t) \u2192 DecYBin(z, z')\nXZero(z, z, x) \u2192 XZeroBin(z, z)\nYZero(z, z,y) \u2192 YZeroBin(z, z)\nNote that such expanded ruleset would as well admit undecidable RPQ entailment, and that the projections are not allowing for further recursion. Therefore the above ruleset can be viewed as essentially sticky, just followed by one single projection step."}, {"title": "Conclusion", "content": "In this paper, we reviewed established existential rules fragments with decidable CQ answering, asking if the decidability carries over to RPQs. We recalled that for the very comprehensive fcs class of rulesets, the decidability for RPQs and even much more expressive query languages follows from recent results. Thus focusing on the fus class of rulesets, we established that they do not allow for decidable RPQ answering in general, due to the insight that \u2013 unlike fcs rulesets - fus rulesets allow for the creation of grid-like universal models, which then can be used as a \"two-counter state space\", in which accepting runs of two-counter machines take the shape of regular paths. On the other hand, we showed that 2RPQ answering over sticky rulesets is decidable thanks to the reducibility to a finitely RPQ-controllable querying problem. This decidability result is rather brittle and crucially depends on (1) the restriction of path expressions to binary predicates and (2) the inability to freely project away variables in sticky rulesets. For this reason, a setting where RPQs are slightly liberalized leads to undecidability again.\nThere are several obvious questions left for future work:\n\u2022 What is the precise complexity of 2RPQ answering over sticky rulesets? Recall that, as our decidability argument is based on finite controllability, the generic decision algorithm ensuing from that does not come with any immediate upper complexity bound.\n\u2022 Does the problem remain decidable for sticky rulesets when progressing to CR-PQs or C2RPQs? We do not believe that a minor extension of our current proof would be sufficient to positively settle this question, as we are currently lacking methods of coping with variable joins in C(2)RPQs (under such circumstances, establishing finite controllability via stellar types fails). However, we think that some of the tools we used in this paper might come in handy when tackling that extended case."}]}