{"title": "Lifted Model Construction without Normalisation: A Vectorised Approach to Exploit Symmetries in Factor Graphs", "authors": ["Malte Luttermann", "Ralf M\u00f6ller", "Marcel Gehrke"], "abstract": "Lifted probabilistic inference exploits symmetries in a probabilistic model to allow for tractable probabilistic inference with respect to domain sizes of logical variables. We found that the current state-of-the-art algorithm to construct a lifted representation in form of a parametric factor graph misses symmetries between factors that are exchangeable but scaled differently, thereby leading to a less compact representation. In this paper, we propose a generalisation of the advanced colour passing (ACP) algorithm, which is the state of the art to construct a parametric factor graph. Our proposed algorithm allows for potentials of factors to be scaled arbitrarily and efficiently detects more symmetries than the original ACP algorithm. By detecting strictly more symmetries than ACP, our algorithm significantly reduces online query times for probabilistic inference when the resulting model is applied, which we also confirm in our experiments.", "sections": [{"title": "Introduction", "content": "Parametric factor graphs (PFGs) are probabilistic relational models, i.e., they combine probabilistic models and relational logic (which can be seen as first-order logic with known universes) to efficiently reason about objects and their relationships under uncertainty. To allow for tractable probabilistic inference (e.g., inference requiring polynomial time) with respect to domain sizes of logical variables, PFGs use representatives of indistinguishable objects to represent groups of random variables (randvars), thereby yielding a more compact model that can be exploited by lifted inference algorithms for faster inference. Here, probabilistic inference (or just inference for short) refers to the task of computing marginal distributions of randvars given observations for other randvars (see Appendix A for more details). Clearly, to run a lifted inference algorithm on a PFG, the PFG has to be constructed first. The current state-of-the-art algorithm to construct a PFG is the advanced colour passing (ACP) algorithm. The ACP algorithm begins with a propositional model in form of a factor graph (FG) and exploits symmetries therein to obtain a PFG entailing equivalent semantics as the initial FG. During the course of ACP, potentials of factors are compared to decide whether factors are equivalent and thus might be grouped. However, all potentials of the factors must be scaled equally for ACP to be able to detect symmetries between factors that are exchangeable but whose potentials differ only by a scalar, thereby leading to a less compact lifted representation if potentials are not normalised before running ACP. In this paper, we solve the problem of constructing a PFG from a given FG such that the resulting PFG entails equivalent semantics as the initial FG and exchangeable factors are detected independent of the scale of their potentials. We therefore allow potentials to be learned from different data sources without having to perform a normalisation step while at the same time obtaining a more compact representation for lifted inference than the output of ACP.\nIn previous work, Poole (2003) introduces PFGs and lifted variable elimination as an inference algorithm to carry out lifted probabilistic inference in PFGs. Lifted inference exploits symmetries in a probabilistic model by using a representative of indistinguishable objects for computations"}, {"title": "Background", "content": "We begin by defining FGs as propositional probabilistic graphical models. An FG compactly encodes a full joint probability distribution over a set of randvars by factorising the distribution into a product of factors (Frey et al., 1997; Kschischang et al., 2001).\nDefinition 1 (Factor Graph). An FG G = (V, E) is an undirected bipartite graph consisting of a node set V = R \u222a \u03a6, where R = {R1,..., Rn} is a set of variable nodes (randvars) and \u03a6 = {\u03c61,..., \u03c6m} is a set of factor nodes (functions), as well as a set of edges E \u2286 R \u00d7 \u03a6. The term range(Ri) denotes the possible values of a randvar Ri. There is an edge between a variable node Ri and a factor node \u03c6j in E if Ri appears in the argument list of \u03c6j. The argument list Aj of a factor \u03c6j(Aj) is a sequence of randvars from R. A factor is a function that maps its arguments to a positive real number, called potential. The semantics of G is given by\n$P_G = \\frac{1}{Z} \\prod_{j=1}^m \\Phi_j(A_j),$ (1)\nwhere Z is the normalisation constant and Aj denotes the randvars occurring in \u03c6j's argument list."}, {"title": "Avoiding Normalisation During Lifted Model Construction", "content": "Before we formally define the notion of exchangeable factors, let us take a look at the upcoming example, which illustrates the idea of having differently scaled potentials in exchangeable factors.\nA straightforward solution to deal with different scales of potentials is to normalise potentials. However, we cannot always assume that a given FG contains normalised potentials by default and in practical applications, the normalisation of potentials is often undesirable as it results in additional floating point arithmetics causing numerical issues. We thus develop a solution that does not require potentials to be normalised but still detects exchangeable factors, which we formally define next.\nDefinition 2 (Exchangeable Factors). Let \u03c61(R1, ..., Rn) and \u03c62(R'1, ..., R'n) denote two factors in an FG G. Then, \u03c61 and \u03c62 represent equivalent potentials if and only if there exists a scalar \u03b1 \u2208 R+ and a permutation \u03c0 of {1, . . ., n} such that for all r1, ...,rn \u2208 \u00d7_{i=1} range(Ri) it holds that \u03c61(r1,...,rn) = \u03b1 \u00b7 \u03a62(r\u03c0(1),\u00b7\u00b7\u00b7,\u03c0(n)). Factors that represent equivalent potentials are called exchangeable factors.\nNote that as a necessary condition, exchangeable factors must be defined over the same function domain and hence must have the same number of arguments.\nWe remark that in general, \u03c0 does not have to be the identity function, i.e., there might be situations where, for example, the argument positions of C and B in \u03c62 are swapped and the potential values in the table read \u03c61, \u03c63, \u03c62, \u03c64 from top to bottom instead of \u03c61, \u03c62, \u03c63, \u03c64. Note that the potential mappings are still the same but their order is a different one. For now, we focus on the scalar"}, {"title": "Dealing with Scaled Potentials", "content": "Previous work by Gehrke et al. (2020) shows that potentials of factors can be conceived as vectors such that the cosine similarity of the vectors can be used to check whether factors \"behave identically\", thereby avoiding groundings in temporal probabilistic inference. We apply the idea of representing potentials as vectors to detect exchangeable factors independent of a scaling factor already during the construction of a PFG to obtain a more compact model even before online inference takes place.\nDefinition 3 (Vector Representation of Factors). Let \u03c6(R1,..., Rn) denote a factor. The vector representation of \u03c6 is defined as the vector $\\vec{\\phi} = (\\Phi(a))_{a \\in \\times_{i=1}range(R_i)}$\nGiven a vector representation of a factor, the idea is that vectors of exchangeable factors point to the same direction in the vector space. Thus, the angle between those vectors can be computed to deter- mine whether the factors are exchangeable because exchangeable factors have vector representations whose angle is equal to zero (i.e., they are collinear).\nTo obtain a distance measure, we define the cosine distance as one minus the cosine similarity.\nDefinition 4 (Cosine Distance, Gehrke et al., 2020). Let \u03c61(R1, . . ., Rn) and \u03c62(R'1,..., R'n) denote two factors. The cosine distance between \u03c61 and \u03c62 is defined as\n$D_{cos}(\\phi_1, \\phi_2) = 1 - \\frac{\\sum_{a \\in \\times_{i=1} range(R_i)} \\phi_1(a) \\cdot \\phi_2(a)}{\\sqrt{\\sum_{a \\in \\times_{i=1} range(R_i)} \\phi_1(a)^2} \\cdot \\sqrt{\\sum_{a \\in \\times_{i=1} range(R_i)} \\phi_2(a)^2}}$ (3)\nIf \u03c61 and \u03c62 are defined over different function domains, we define $D_{cos}(\\phi_1, \\phi_2) = \\infty$.\nA fundamental advantage of using vector representations in combination with the cosine distance to search for exchangeable factors is that it is also possible to allow for a small deviation of Dcos from zero (e.g., dependent on a hyperparameter \u03b5). While it is also conceivable to directly compare the tables of potential mappings and allowing for a deviation controlled by \u03b5, a direct comparison of tables becomes sophisticated in settings where both a deviation and a scaling factor \u03b1 have to be considered at the same time. Vector representations circumvent such issues and allow for a straightforward comparison of factors at any time. In this paper, however, we focus on the problem of exact lifted model construction, i.e., we aim to transform a given FG into a PFG entailing equivalent semantics as the initial FG. Allowing for a deviation between potentials results in the problem setup of approximate lifted model construction, which is a different problem not considered in detail here.\nBefore we continue to deal with permutations of arguments in addition to scaled potentials, we formally show that the cosine distance is a suitable measure to check for exchangeability.\nTheorem 2. Let \u03c61(R1,..., Rn) and \u03c62(R'1,..., R'n) denote two factors. If \u03c61 and \u03c62 are ex- changeable, then it holds that $D_{cos}(\\phi_1, \\phi_2) = 0$.\nProof Sketch. If \u03c61 and \u03c62 are exchangeable, there exists a scalar \u03b1 \u2208 R+ and a permutation \u03c0 of {1,..., n} such that for all r1,...,rn \u2208 \u00d7_{i=1}range(Ri) it holds that \u03c61(r1,...,rn) = \u03b1 \u00b7 \u03a62(r\u03c0(1),..., r\u03c0(n)). Without loss of generality, assume that the arguments of \u03c62 are rearranged such that for all r1, ...,rn \u2208 \u00d7_{i=1}range(Ri) it holds that \u03c61(r1,...,rn) = \u03b1 \u00b7 \u03c62(r1,...,rn). Then, entering \u03c61(r1,...,rn) = \u03b1 \u00b7 \u03a62(r1, ..., rn) into Eq. (3) yields $D_{cos}(\\phi_1, \\phi_2) = 0$. \u25a1\nNote that the cosine distance is a measure to check for collinearity of the vectors $\\vec{\\phi_1}$ and $\\vec{\\phi_2}$, that is, to check whether there exists a scalar \u03b1 such that $\\vec{\\phi_1} = \\alpha \\cdot \\vec{\\phi_2}$. As we only have to check for collinearity, we can avoid computing the cosine distance (and hence avoid floating point arithmetics during exchangeability checks) by checking the equality of products of potential values. The technical details for collinearity checks using only multiplication operations are given in Appendix D. However, also keep in mind that even when using the cosine distance to determine collinearity of vectors (which involves floating point arithmetics), we are able to avoid floating point numbers in the tables of"}, {"title": "Dealing with Permutations of Arguments", "content": "A straightforward approach to handle permutations of arguments when searching for exchangeable factors is to iterate over all possible argument permutations of one of the factors, rearrange its arguments and its table of potential mappings accordingly, and then compute the cosine distance as described in Sec. 3.1. If there exists a permutation such that the cosine distance is zero, the factors are exchangeable, otherwise they are not. Such an approach, however, is computationally expensive as it iterates over O(n!) argument permutations for a factor with n arguments in the worst case. Luttermann et al. (2024d) introduce the detection of exchangeable factors (DEFT) algorithm, which avoids iterating over all permutations of arguments and thereby allows to efficiently detect exchangeable factors according to Def. 2 where \u03b1 = 1. In other words, DEFT is able to efficiently handle permutations of arguments but does not consider differently scaled potentials. We now combine the ideas of DEFT and the vector representation in combination with the cosine distance to handle both scalars different from one and permutations of arguments simultaneously.\nThe idea behind the DEFT algorithm is that a factor maps its arguments to potential values that can be distributed across so-called buckets. Buckets count the occurrences of specific range values in an assignment for a subset of a factor's arguments and within these buckets, possible permutations of arguments are heavily restricted such that not all permutations have to be considered. Before we illustrate the idea at an example, we give a formal definition of a bucket.\nDefinition 5 (Bucket, Luttermann et al., 2024d). Let \u03c6(R1, . . ., Rn) denote a factor and let S \u2286 {R1,..., Rn} denote a subset of \u03c6's arguments such that range(Ri) = range(Rj) holds for all Ri, Rj \u2208 S. Further, let V denote the range of the elements in S (identical for all Ri \u2208 S). Then, a bucket b entailed by S is a set of tuples {(vi, ni)}^l_{i=1}, vi \u2208 V, ni \u2208 N, and \u2211ini = |S|, such that ni specifies the number of occurrences of potential value vi in an assignment for all randvars in S. A shorthand notation for {(vi, ni)}^l_{i=1} is [n1,...,n|v|]. In abuse of notation, we denote by $\\vec{\\Phi}(b)$ the ordered multiset of potentials a bucket b is mapped to by \u03c6 (in order of their appearance in \u03c6's table of potential mappings). The set of all buckets entailed by \u03c6 is denoted as B(\u03c6)."}, {"title": "Detection of Exchangeable Factors without Normalisation", "content": "Algorithm 1 Detection of Exchangeable Factors without Normalisation\nInput: Two factors \u03c61 (R1, ..., Rn) and \u03c62(R'1,..., R'm).\nOutput: true if \u03c61 and \u03c62 are exchangeable, else false.\nif n \u2260 m \u2228 B(\u03c61) \u2260 B(\u03c62) then\nreturn false\nfor each b \u2208 B(\u03c61) do\n\u03b1 \u2190 max(\u03c61 (b)) / max($\\vec{\\Phi_2}$ (b))\nif \u03b1 differs from \u03b1 for a previous bucket then\nreturn false\nCb \u2190 Possible swaps to obtain $\\vec{\\Phi_1}$ (b) = \u03b1 \u00b7 $\\vec{\\Phi_2}$ (b)\nif there exists a swap of \u03c62's arguments in \u2229b\u2208B(\u03c61) Cb such that $D_{cos}(\\phi_1, \\phi_2) = 0$ then\nreturn true\nelse\nreturn false\nLuttermann et al. (2024d) show that two factors \u03c61 and \u03c62 are exchangeable (for the setting of \u03b1 = 1) if and only if there exists a permutation of their arguments such that $\\vec{\\Phi_1}$ (b) = $\\vec{\\Phi_2}$ (b) for all buckets b entailed by the arguments of \u03c61 and \u03c62. The DEFT algorithm exploits this property by checking for each bucket b whether arguments can be rearranged such that $\\vec{\\Phi_1}$ (b) = $\\vec{\\Phi_2}$ (b) holds. The idea is that the potential values in the ordered multisets determine possible permutations of arguments and thus, DEFT avoids iterating over all permutations of arguments.\nWe next generalise the DEFT algorithm such that it is able to handle the setting of \u03b1 \u2260 1 as well. A crucial observation is that the orders of the potential values in the ordered multisets must be identical up to the scaling factor \u03b1.\nTheorem 3. Let \u03c61 and \u03c62 denote two factors. Then, \u03c61 and \u03c62 are exchangeable if and only if there exists a permutation of their arguments such that $\\vec{\\Phi_1}$ (b) = \u03b1 \u00b7 $\\vec{\\Phi_2}$ (b) for all buckets b entailed by the arguments of \u03c61 and \u03c62, where, by abuse of notation, \u03b1 \u00b7 $\\vec{\\Phi_2}$ (b) denotes the ordered multiset resulting from multiplying each potential value in $\\vec{\\Phi_2}$ (b) by \u03b1.\nUsing the insight from Thm. 3, the DEFT algorithm can be adapted to search for identical potential values up to scalar \u03b1 in the ordered multisets of potential values"}, {"title": "Experiments", "content": "To assess the effectiveness of Alg. 1 in practice, we compare the run times of running lifted vari- able elimination on the output of ACP in its original form and of running lifted variable elimina- tion on the output of ACP extended by running Alg. 1 to detect exchangeable factors (\u03b1-ACP).\nFor our experiments, we generate FGs containing between 2^d + 1 and $d \\cdot \\lfloor log_2(d) \\rfloor + 2^d + 1$ randvars as well as between 2^d and $d \\cdot \\lfloor log_2(d) \\rfloor + d + 1$ factors, where the parameter $d \\in \\{2, 4, 8, 16, 32, 64, 128, 256, 512, 1024\\}$ controls the size of the FG. In every FG, a proportion of p\u2208 {0.01, 0.05, 0.1, 0.15} of the factors is scaled by a scalar \u03b1 \u2208 {1, ..., 10} (chosen uniformly at random). For each choice of d, we pose three to four queries to each FG and report the average run time over all queries. Figure 5 displays the results. The left plot shows the average run times of lifted variable elimination on the output of ACP and \u03b1-ACP, respectively. As expected, lifted variable elimination runs significantly faster and is able to handle larger values of d if \u03b1-ACP instead of ACP is applied. Since \u03b1-ACP is able to detect exchangeable factors that are scaled differently, it detects strictly more symmetries than ACP resulting in a more compact model and hence in faster inference times. Clearly, the speedup depends on the proportion p of scaled factors and thus, we provide additional experimental results for each individual choice of p in Appendix E.\nThe boxplot on the right in Fig. 5 displays the average number \u03b2 of queries after which the additional offline overhead of \u03b1-ACP compared to ACP amortises.\nIn other words, after \u03b2 queries, the additional time needed by \u03b1-ACP to construct the PFG is saved due to faster inference times. Thus, after a maximum of ten queries, the additional offline overhead of \u03b1-ACP amortises, showing that \u03b1-ACP works efficiently as it introduces almost no overhead."}, {"title": "Conclusion", "content": "In this paper, we generalise the ACP algorithm to detect exchangeable factors independent of the scale of their potentials without the requirement of normalising the potentials. Our proposed approach allows for arbitrary scalars and makes use of vector representations in combination with collinearity checks to efficiently detect exchangeable factors independent of their scale. We show that our approach maintains equivalent semantics and at the same time yields a more compact representation by detecting strictly more symmetries than the original ACP algorithm, thereby speeding up inference."}, {"title": "Probabilistic Inference in More Detail", "content": "The task of probabilistic inference describes the computation of marginal distributions of randvars given observations for other randvars. In other words, probabilistic inference refers to query answer- ing, where a query is defined as follows.\nDefinition 6 (Query). A query P(Q | E1 = e1,..., Ek = ek) consists of a query term Q and a set of events {Ej = ej}^k_{j=1} (called evidence), where Q and E1, ..., Ek are randvars. To query a specific probability instead of a probability distribution, the query term is an event Q = q.\nExample 9 (Probabilistic Inference). Take a look again at the FG depicted in Fig. 2a and assume we want to answer the query P(B = true).\nP(B = true) = \u2211\u2211 P(A = a, B = true, C = c) (4)\na\u2208range(A) c\u2208range(C)\n= 1/Z \u2211\u2211 \u03c61(a, true) \u00b7 \u03c62(c, true) (5)\na\u2208range(A) c\u2208range(C)\n= 1/Z (\u03c61\u03c61 + \u03c62\u03c62 + \u03c61\u03c63 + \u03c63\u03c61 + \u03c63\u03c62 + \u03c62\u03c63). (6)\nSince \u03c61(A, B) and \u03c62(C, B) are exchangeable (i.e., it holds that \u03c61(a, true) = \u03c62(c, true) for all assignments where a = c), we can exploit this symmetry to simplify the computation and obtain\nP(B = true) = 1/Z \u2211\u2211 \u03c61(a, true) \u00b7 \u03c62(c, true) (7)\na\u2208range(A) c\u2208range(C)\n= 1/Z \u2211 \u03c61(a, true) \u2211 \u03c62(c, true) (8)\na\u2208range(A) c\u2208range(C)\n= 1/Z (\u2211 \u03c61(a, true))2 (9)\na\u2208range(A)\n= 1/Z (\u2211 \u03c62(c, true))2 (10)\nc\u2208range(C)\n= 1/Z (\u03c61 + \u03c63)2 (11)\nThis example illustrates the idea of using a representative of indistinguishable objects for compu- tations (here, either A or C can be chosen as a representative for the group consisting of A and C). This idea can be generalised to groups of k indistinguishable objects to significantly reduce the computational effort when answering queries."}, {"title": "Formal Description of the Advanced Colour Passing Algorithm", "content": "The ACP algorithm (Luttermann et al., 2024c) extends the colour passing algorithm (Kersting et al., 2009; Ahmadi et al., 2013), thereby solving the problem of constructing a lifted representation in form of a PFG from a given FG. The idea of ACP is to first find symmetric subgraphs in a propositional FG and then group together these symmetric subgraphs. ACP searches for symmetries based on potentials of factors, on ranges and evidence of randvars, as well as on the graph structure by employing a colour passing routine. A formal description of the ACP algorithm is depicted in Alg. 2. We next explain the steps undertaken by ACP in more detail.\nACP begins with the colour assignment to variable nodes, meaning that all randvars having the same range and observed event are assigned the same colour. randvar with different ranges or different observed events are assigned distinct colours since those randvar do not \"behave in the same way\". Then, in Line 2, ACP assigns colours to factor nodes such that exchangeable factors encoding equivalent semantics according to Def. 2 are assigned the same colour. In its original form, ACP uses the DEFT algorithm (Luttermann et al., 2024d) to efficiently detect exchangeable factors and to assign colours accordingly. The DEFT algorithm deployed within ACP, however, is not able to"}, {"title": "Advanced Colour Passing", "content": "Algorithm 2 Advanced Colour Passing (reprinted from Luttermann et al., 2024c)\nInput: An FG G with randvars R = {R1, ..., Rn}, factors \u03a6 = {\u03c61,..., \u03c6m}, and evidence E = {R1 = r1,..., Rk =rk}.\nOutput: A lifted representation G' in form of a PFG entailing equivalent semantics as G.\nAssign each Ri a colour according to R(Ri) and E\nAssign each \u03c6i a colour according to order-independent potentials and rearrange arguments accordingly\nrepeat\nfor each factor \u03c6 \u2208 \u03a6 do\nsignature \u2190 []\nfor each randvar R \u2208 neighbours(G, \u03c6) do\nappend(signature, R.colour) \nappend(signature, \u03c6.colour)\nGroup together all \u03c6s with the same signature\nAssign each such cluster a unique colour\nSet \u03c6.colour correspondingly for all \u03c6s\nfor each randvar R\u2208 R do\nsignatureR \u2190 []\nfor each factor \u03c6 \u2208 neighbours(G, R) do\nif \u03c6 is commutative w.r.t. S and R\u2208 S then\nappend(signatureR, (\u03c6.colour, 0))\nelse\nappend(signatureR, (\u03c6.colour, p(R, \u03c6)))\nSort signatureR according to colour\nappend(signatureR, R.colour)\nGroup together all Rs with the same signature\nAssign each such cluster a unique colour\nSet R.colour correspondingly for all Rs\nuntil grouping does not change\nG' \u2190 construct PFG from groupings\nhandle factors with differently scaled potentials (i.e., it detects exchangeable factors according to Def. 2 only for \u03b1 = 1) and thus, our extension replaces the DEFT algorithm by Alg. 1 to detect exchangeable factors independent of the scale of their potentials in Line 2 of Alg. 2.\nAfter the initial colour assignments, ACP runs a colour passing routine. ACP first passes the colours from each variable node to its neighbouring factor nodes and after a recolouring step to reduce communication overhead, each factor node \u03c6 sends its colour as well as the position p(R, \u03c6) of R in \u03c6's argument list to all of its neighbouring variable nodes R, again followed by a recolouring step. The procedure is then iterated until the identified groups do not change anymore. In the end, the determined groups are then used to construct a PFG entailing equivalent semantics as the input FG G.\nand C receive identical messages (positions are not shown in Fig. 6) and after the recolouring step, A and C share the same colour while B is assigned a different colour. The groupings do not change in further iterations and the resulting PFG is shown on the right (where X has domain {A, C}).\nFor more details about the colour passing routine and the grouping of nodes, we refer the reader to (Luttermann et al., 2024c). The authors also demonstrate the benefits of a lifted representation in terms of speedup for probabilistic inference."}, {"title": "Missing Proofs", "content": "Theorem 2. Let \u03c61(R1,..., Rn) and \u03c62(R'1,..., R'n) denote two factors. If \u03c61 and \u03c62 are ex- changeable, then it holds that Dcos(\u03c61, \u03c62) = 0.\nProof. If \u03c61 and \u03c62 are exchangeable, there exists a scalar \u03b1 \u2208 R+ and a permutation \u03c0 of {1, ..., n} such that for all r1,...,rn \u2208 \u00d7_{i=1}range(Ri) it holds that \u03c61(r1,...,rn) = \u03b1 \u00b7 \u03c62(r\u03c0(1),..., r\u03c0(n)).\nWithout loss of generality, assume that the arguments of \u03c62 are rearranged such that for all r1,...,rn \u2208 \u00d7_{i=1}range(Ri) it holds that \u03c61(r1,...,rn) = \u03b1 \u00b7 \u03c62(r1,...,rn). Then, entering \u03c61(r1,...,rn) = \u03b1 \u00b7 \u03c62(r1,...,rn) into Eq. (3) yields\nDcos(\u03c61, \u03c62) = 1 - \u03b1 \u00b7 \u2211 \u03c62(a) / \u221a \u03b12 \u2211 \u03c62(a) \u00b7 \u2211 \u03c62(a) (12)\na\u2208\u00d7\u2081range(Ri) / a\u2208\u00d7\u2081range(Ri) a\u2208\u00d7\u2081range(Ri)\n= 1 - \u03b1 \u00b7 \u2211 \u03c62(a) / \u03b1 \u221a(\u2211 \u03c62(a) (\u2211 \u03c62(a) (13)\na\u2208\u00d7\u2081range(Ri) / a\u2208\u00d7\u2081range(Ri) a\u2208\u00d7\u2081range(Ri)\n= 1 - \u03b1 \u2211 \u03c62(a) / \u03b1 \u2211 \u03c62(a) (14)\na\u2208\u00d7\u2081range(Ri) / a\u2208\u00d7\u2081range(Ri)\n= 0. (15)"}, {"title": "Checking Collinearity of Vectors without Division Operations", "content": "Let $\\vec{\\phi_1} = (\\phi_1,...,\\phi_n)$ and $\\vec{\\phi_2} = (\\psi_1,..., \\psi_n)$ denote two vector representations of factors \u03c61 and \u03c62. Our goal is to check whether \u03c61 and \u03c62 are collinear, that is, whether there exists a scalar \u03b1 such that $\\vec{\\phi_1} = \\alpha \\cdot \\vec{\\phi_2}$, without using division or square root operations. By doing so, we avoid floating point arithmetic issues. In particular, if the potential values \u03c61,..., \u03c6n and \u03c81,..., \u03c8n are integers (which is the case if the initial FG is learned from data by counting occurrences of specific assignments), then no floating point numbers are involved in our calculations during exchangeability checks. Note that, even if we apply the cosine distance to check for collinearity, the model itself can still consist only of integer potential values and only the check for exchangeability involves floating point arithmetics in this case (as opposed to a model where potential values are normalised at the beginning, which results in floating point numbers for its potential values).\nWe next provide the technical details to check whether $\\vec{\\phi_1} = \\alpha \\cdot \\vec{\\phi_2}$ holds by using only multiplication operations. If $\\vec{\\phi_1}$ and $\\vec{\\phi_2}$ are collinear, we have \u03c6i = \u03b1 \u00b7 \u03c8i,..., \u03c6n = \u03b1 \u00b7 \u03c8n and hence \u03b1 = \u03c6i / \u03c8i for all i \u2208 {1, . . ., n}. Since \u03b1 = \u03c6i / \u03c8i holds for all i \u2208 {1, . . ., n}, we can enter \u03b1 = \u03c61 / \u03c81 into the equation \u03c6i = \u03b1 \u00b7 \u03c8i and obtain\n\u03c6i = \u03c61 / \u03c81 \u00b7 \u03c8i (16)\n\u21d4 \u03c6i \u00b7 \u03c81 = \u03c61 \u00b7 \u03c8i. (17)\nIn consequence, we can check whether $\\vec{\\phi_1}$ and $\\vec{\\phi_2}$ are collinear by verifying whether \u03c6i \u00b7 \u03c81 = \u03c61 \u00b7 \u03c8i holds for all i \u2208 {1,...,n}. Verifying this equation involves only multiplication operations and hence avoids floating point arithmetics as much as possible.\nTo supplement Sec. 3.2, we next show that the aforementioned approach can also be extended to handle permutations of arguments. In case there exists a permutation \u03c0 of {1,...,n} such that for all r1,...,rn \u2208 \u00d7_{i=1}range(Ri) it holds that \u03c61(r1,...,rn) = \u03b1 \u00b7 \u03a62(r\u03c0(1),..., r\u03c0(n)), it does not necessarily hold that \u03b1 = \u03c6i / \u03c8i for i \u2208 {1, ..., n}. However, we know that \u03b1 = maxi\u2208{1,...,n} \u03c6i / maxi\u2208{1,...,n} \u03c8i (analogously for min instead of max). At the same time, we know that in the first bucket, there is only a single potential value, which remains the same for all possible permutations \u03c0 of {1, . . ., n} because the corresponding assignment assigns all arguments the same range value (e.g., true). We thus have \u03b1 = \u03c61 / \u03c81 again, regardless of the order of arguments. Consequently, when searching for possible swaps to obtain $\\vec{\\Phi_1}$ (b) = \u03b1 \u00b7 $\\vec{\\Phi_2}$ (b) in Line 7 of Alg. 1, we can find identical potential values up to the scalar \u03b1 for each \u03c6i \u2208 \u03c6\u2081 (b) in $\\vec{\\Phi_2}$ (b) by iterating over all potential values \u03c81 \u2208 $\\vec{\\Phi_2}$ (b) and checking whether \u03c6i \u00b7 \u03c81 = \u03c61 \u00b7 \u03c8i holds.\nHaving found identical potential values up to \u03b1, possible swaps to obtain $\\vec{\\Phi_1}$ (b) = \u03b1 \u00b7 $\\vec{\\Phi_2}$ (b) are again determined by the positions of the identical potential values (up to \u03b1) in the ordered multisets. In particular, if \u03c6i = \u03b1 \u00b7 \u03c8i holds for \u03c6i \u2208 \u03c6\u2081 (b) and \u03c81 \u2208 \u03c6\u2082 (b), then \u03c6i and \u03c81 must be located at the same position in \u03c6\u2081 (b) and \u03c6\u2082 (b), respectively, to achieve that \u03c6\u2081 (b) = \u03b1 \u00b7 \u03c6\u2082 (b).\n\u03c6i \u2265 \u03b1 \u00b7 \u03c8i \u00b7 (1 \u2013 \u03b5), and (18)\n\u03c6i \u2264 \u03b1 \u00b7 \u03c8i \u00b7 (1 + \u03b5). (19)\nBy entering \u03b1 = \u03c61/\u03c81 into Eqs. (18) and (19), we obtain\n\u03c6i\u00b7 \u03c81 \u2265 \u03c61\u00b7\u03c8i\u00b7 (1 \u2013 \u03b5), and (20)\n\u03c6i\u00b7 \u03c81 \u2264 \u03c61\u00b7\u03c8i\u00b7 (1 + \u03b5). (21)"}, {"title": "Experimental Results", "content": "In addition to the experimental results provided in Sec. 4, we give further experimental results in this section. We again evaluate the run times of running lifted variable elimination on the output of ACP as well as of running lifted variable elimination on the output of \u03b1-ACP and also investigate the average number \u03b2 of queries after which the additional offline overhead of \u03b1-ACP compared to ACP amortises. The instances used in this section are identical to those used in Sec. 4 but we do not average the results over the proportion p \u2208 {0.01, 0.05, 0.1, 0.15} of scaled factors. Instead, we present separate results for each individual choice of p to highlight the effect of p on both the run times for online query answering as well as on the offline overhead for constructing the PFG.\nThe results are illustrated in Figs. 7 to 10. Unsurprisingly, the run times of lifted variable elimination on the output of \u03b1-ACP remain constant for all choices of p because \u03b1-ACP is able to detect arbitrarily many scaled factors without forfeiting compression. At the same time, ACP is not able to detect exchangeable factors on different scales and thus, the run times of lifted variable elimination on the output of ACP increase as the proportion p of scaled factors increases. Regarding the amortisation of the offline overhead (depicted in the plots on the right), we can observe the same behaviour as in Fig. 5 (negative values for \u03b2 are again omitted)."}]}