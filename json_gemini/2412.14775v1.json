{"title": "Energy and polarization based on-line interference mitigation in radio interferometry", "authors": ["Sarod Yatawatta", "Albert-Jan Boonstra", "Chris P. Broekema"], "abstract": "Radio frequency interference (RFI) is a persistent contaminant in terrestrial radio astronomy. While new radio interferometers are becoming operational, novel sources of RFI are also emerging. In order to strengthen the mitigation of RFI in modern radio interferometers, we propose an on-line RFI mitigation scheme that can be run in the correlator of such interferometers. We combine statistics based on the energy as well as the polarization alignment of the correlated signal to develop an on-line RFI mitigation scheme that can be applied to a data stream produced by the correlator in real-time, especially targeted at low duty-cycle or transient RFI detection. In order to improve the computational efficiency, we explore the use of both single precision and half precision floating point operations in implementing the RFI mitigation algorithm. This ideally suits its deployment in accelerator computing devices such as graphics processing units (GPUs) as used by the LOFAR correlator. We provide results based on real data to demonstrate the efficacy of the proposed method.", "sections": [{"title": "1. Introduction", "content": "Various human-made electromagnetic signals are received by radio telescopes and act as unwanted interference. Mitigation of such RFI has been extensively researched and many algorithms exist for this purpose, (e.g. Leshem et al., 2000; Leshem and van der Veen, 2000; Fridman and Baan, 2001; Raza et al., 2002; Bentum et al., 2008; Hellbourg et al., 2012; Offringa et al., 2010; Baan, 2019; Cucho-Padin et al., 2019; Vos et al., 2019). However, new sources of RFI are still emerging, (e.g. Brentjens, 2016; Winkel and Jessner, 2019; Sokolowski et al., 2016; Vruno et al., 2023; Bassa et al., 2024) that require continuous investment on better RFI mitigation algorithm development.\nThe majority of existing RFI mitigation algorithms are off-line, i.e., they operate on data that are stored on disk. On the other hand, on-line RFI mitigation algorithms (Van Nieuwpoort, 2016; Van Nieuwpoort et al., 2018; Smith, 2022; Rafiei-Ravandi and Smith, 2023; Sclocco et al., 2020) operate on data streams in real-time. There are several differences between the off-line and the on-line RFI mitigation algorithms. Off-line algorithms have access to the full time-frequency domain (or footprint) of the data and can access the data multiple times. This is because the data are channelized in frequency and averaged over time to reduce the raw data volume as much as possible before storing on disk. Hence, sophisticated algorithms can be developed for off-line RFI mitigation, provided the data storage and computational costs are not a limitation. In contrast, on-line algorithms can only access the data once to determine the presence or absence of RFI, and the time-frequency domain of the data being accessed at any given instance is small. A key characteristic of an on-line RFI mitigation algorithm is its computational efficiency, making the run-time of such an algorithm to be lower than the duration of the data being considered (real-time). A distinct advantage of a real-time and on-line RFI mitigation algorithm is its applicability to data streams at a high time-frequency resolution. For example, in the LOFAR correlator (Broekema et al., 2018), one second of post-correlation data is produced by averaging thousands of samples taken at a much higher time resolution. In such a situation, RFI that have a small duty cycle (having a duration of much less than one second) that are also called as 'transient' (Gehlot et al., 2024) or 'short duration' (Cucho-Padin et al., 2019) RFI will be averaged with RFI free data,"}, {"title": "2. Energy and polarization based RFI mitigation", "content": "We consider the output of a correlator that is fed by dual (linear) polarized data streams from each station or receiver. The instantaneous output of the correlator for a given pair of receivers (a baseline) can be given as\n$V_{i} =\\begin{bmatrix}  XX_{i} & XY_{i} \\\\ YX_{i} & YY_{i} \\end{bmatrix}$ (1)\nwhere we use the subscript i to denote the time-frequency sampling point for the given receiver pair and $XX_{i},XY_{i}, YX_{i},YY_{i} \\in \\mathbb{C}$ are the correlations produces produced by the correlator. Given N receivers, the correlator will produce N(N+1)/2 data streams at the output and we perform RFI mitigation on each of them separately. Normally, the instantaneous output (1) is averaged over i using thousands of samples before the averaged data is sent to storage on disk. Assuming linear polarized feeds, we can form the complex Stokes parameters for (1) as\n$I_{i} = XX_{i} + YY_{i}$,\n$Q_{i} = XX_{i} - YY_{i}$,\n$U_{i} = XY_{i} + YX_{i}$,\n$V_{i} = i(XY_{i} - YX_{i})$ (2)\nwhere $I_{i}, Q_{i}, U_{i}, V_{i} \\in \\mathbb{C}$. We consider a window with indices in the set W with W elements for detection of RFI. In off-line RFI mitigation methods, W can be arbitrarily large but in our case, W is small, typically a handful of data samples.", "subsections": [{"title": "2.1. Flagging using spectral kurtosis", "content": "Post correlation spectral kurtosis statistics (Nita and Hellbourg, 2020) can be extracted using the data window as\n$S_{1} = \\sum_{i \\in W} I_{i}  S_{2} = \\sum_{i \\in W} I_{i}^{2}.$ (3)\nThe statistic for determining the presence or absence of RFI is given as (Nita and Gary, 2010)\n$T_{SK} = \\frac{W(W + 1)}{(W - 1)}\\bigg[ \\frac{S_{2}}{S_{1}^{2}} - \\frac{1}{W} \\bigg].$ (4)\nwhere d is given a priori based on the distribution of RFI free data (typically d \u2208 [0.5, 1] but can be fine tuned as in Nita and Hellbourg (2020)). The spectral"}, {"title": "2.2. Flagging using directional statistics of polarization", "content": "In order to extract the directional statistics (Guo et al., 2013; Yatawatta, 2021), we work on both the real and imaginary parts of Qi, Ui, and Vi separately. Without loss of generality, let $q_{i}, u_{i}$, and $v_{i}$ (\u2208 R) be the real or imaginary parts of Qi, Ui, and Vi respectively.\nFor each data point i (\u2208 W) we construct the polarization vector as\n$p_{i} = \\sqrt{q_{i}^{2} + u_{i}^{2} + v_{i}^{2}}$ (6)\nand thereafter, the normalized polarization components are calculated as\n$\\hat{q_{i}} = q_{i}/p_{i}, \\hat{u_{i}} = u_{i}/p_{i}, \\hat{v_{i}} = v_{i}/p_{i}.$ (7)\nThe average polarization within the window W is calculated as\n$q = \\sum_{i \\in W} \\hat{q_{i}}, u = \\sum_{i \\in W} \\hat{u_{i}}, v = \\sum_{i \\in W} \\hat{v_{i}}$ (8)\nand the directional statistic as\n$r = \\sqrt{q^{2} + u^{2} + v^{2}}/W.$ (9)\nWith RFI, the directional statistic will be more prominent and therefore can be compared to a pre-defined threshold \u03b3 to determine whether to flag the data within the window W or not, i.e.,\nflag = r > \u03b3. (10)\nThe flags derived from the real parts and imaginary parts of Qi, Ui, and Vi are combined using the logical OR operation before applying to the data. Finally, the flags derived from spectral kurtosis in section 2.1 and directional statistics in section 2.2 are combined using the logical OR operation for applying them to the data.\nNote that the hyperparameters and thresholds d,"}]}, {"title": "3. Mixed precision optimization using reinforcement learning", "content": "In this section, we break down the algorithms described in sections 2.1 and 2.2 into a set of instructions that can be performed in an arbitrary precision format. The optimal precision to use is determined by satisfying two criteria:\n\u2022 Accuracy: The end result of the algorithm should agree with the end result obtained by the same algorithm using double precision (64 bit) floating point operations. We consider the double precision floating point result as the ground truth. Note however that the end result of the overall algorithm is a flag (a one or a zero), i.e., a value with 1 bit precision. Therefore, theoretically there should be a way to reduce the precision from the starting precision of 32 bits to one bit and the objective of this optimization is to find this optimal way. However, we remind the reader that the data stream that is being processed is kept fixed at 32 bit precision.\n\u2022 Cost: The overall computational cost should be as low as possible. Let C be the cost of an operation in any floating point precision. We use C = 1 for one single precision (32 bit) operation and (arbitrarily) set C = 0.6 for one half precision (16 bit) operation. More exact costs for these operations can be used for optimizing the algorithms for any specific GPU. Obviously, we do not use double precision for calculation of the cost because it will not be used in the practical algorithm (only used for ground truth calculation).\nThe input $Z_{i}, Q_{i}, U_{i}$, and $V_{i}$ are single precision (32 bit) floating point data. In Table 1, we have broken down the spectral kurtosis based RFI mitigation algorithm described in section 2.1 into groups of operations. For each group listed in Table 1, we use the"}, {"title": "3.1. The action", "content": "The optimal precision to use for any given situation is produced by the agent as the action $a \\in [0,1]^{14}$. The 14 values in the action correspond to the number of groups of operations in Tables 1 and 2. If $a[i] < 0.5$ the i-th group precision is set to 32 bits (single precision) else it is set to 16 bits (half precision)."}, {"title": "3.2. The state", "content": "The state consists of information about the data, the current precision being used and the floating point error as compared to the ground truth. We consider a data window of size W divided into T time samples and F frequency samples, i.e., W = T \u00d7 F. Each data"}, {"title": "3.3. The reward and the penalty", "content": "The reward is calculated by comparing the ground truth flags (obtained by using double precision computation) to the flags obtained with the reduced precision versions of Table 1 and Table 2). For a correct match or flags, a reward of 33 for each routines in Table 1 and Table 2) are added. In order to calculate the computational cost, we set 1 for one 32 bit (single precision) floating point operation and 0.6 for one 16 bit (half precision) floating point operation. Furthermore, a unit cost 0.3 for type conversion, for example from 32 bit to 16 bit or vice versa is added whenever there is a conversion from one precision type to another precision type is required. An additional penalty of 20 for floating point overflow or underflow is added if this occurs anywhere in Tables 1 or 2. The final reward is calculated as the reward for correctness compared to the ground truth minus the cost and penalties.\nWith the setup described above, we train the RL agent to solve our problem, or in other words, to maximize the cumulative reward. In section 4, we present the performance of the RL agent in learning to solve the problem of finding the optimal precision configuration that maximizes the accuracy while minimizing the cost incurred."}, {"title": "4. Results", "content": "In this section we first present results in training our RL agent to solve the problem of finding the pre-"}, {"title": "4.1. Reinforcement learning", "content": "We train an ensemble of E = 4 RL agents to solve our problem described in section 3. We consider a time-frequency window of size W = 20 data samples, that can (randomly) have various time-frequency footprints, T = 10, F = 2 or T = 5, F = 4. In each episode, we generate complex, circular Gaussian data using the standard normal distribution for (1) and multiply this with a uniform-randomly selected scale factor in [0.01,1000] as the RFI-free data. Afterwards, with a probability of 0.4, we add RFI to this data. The RFI signals are generated as follows. First, we uniform-randomly select an RFI footprint in the T \u00d7 F window. We generate the RFI signals for Stokes I,Q,U, and V by filling the RFI window with ones multiplied by a complex scale factor that is uniform-randomly selected from [0.01, 1000]. We also generate a 2\u00d72 matrix that is filled by complex, circular Gaussian random values with zero mean and unit variance. This is used to multiply the RFI signal window to create correlation between the polarizations of the RFI signal. Note that this simulation setup is quite general and not specialized to any specific telescope like LOFAR, but it can be done, if needed.\nUsing the soft actor-critic algorithm (Haarnoja et al., 2018a,b), we train the ensemble for 100000 episodes and in each episode, the RL agent can make 100 steps. Each model in the ensemble is randomly initialized and the data used for training each model is also different from one another. The reward obtained by the ensemble and the increase in the reward reaching a steady value indicating learning is shown in Fig. 1.\nWe use the trained ensemble to marginalize the effect of the data on the optimal action. We feed all E models in the trained ensemble with the same data for 100000 episodes and find the average action taken by each model over all episodes. The optimal action thus determined in given in Tables 3 and 4. Note that each element in the action a is in [0, 1] and"}, {"title": "4.2. RFI mitigation", "content": "We consider LOFAR observations taken by the low-band-antenna array (LBA) that are stored on disk. However, the proposed algorithms in Tables 3 and 4 operate with a window size W = 20 = 10 \u00d7 2"}, {"title": "5. Conclusions", "content": "We have proposed a novel, on-line RFI mitigation method for post-correlation interferometric data that jointly exploit the spectral kurtosis and the polarization directional statistics. We have also proposed the use of reinforcement learning for optimizing the floating point operations of the proposed algorithms to minimize the computational cost especially in GPUs. Future work on this topic will focus on implementing and deploying the proposed algorithm in the LOFAR correlator and dynamic adaptation of the threshold levels depending on the data streams. Furthermore, it is interesting to investigate if the on-line RFI detections can be used as input to on-line beamforming algorithms for spatial filtering of RFI as in Raza et al. (2002).\nSource code implementing all algorithms discussed in this paper are publicly accessible at (FlagPol)."}]}