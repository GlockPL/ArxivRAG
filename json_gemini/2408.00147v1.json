{"title": "Formal Ethical Obligations in Reinforcement Learning Agents: Verification and Policy Updates", "authors": ["Colin Shea-Blymyer", "Houssam Abbas"], "abstract": "When designing agents for operation in uncertain environments, designers need tools to automatically reason about what agents ought to do, how that conflicts with what is actually happening, and how a policy might be modified to remove the conflict. These obligations include ethical and social obligations, permissions and prohibitions, which constrain how the agent achieves its mission and executes its policy. We propose a new deontic logic, Expected Act Utilitarian deontic logic, for enabling this reasoning at design time: for specifying and verifying the agent's strategic obligations, then modifying its policy from a reference policy to meet those obligations. Unlike approaches that work at the reward level, working at the logical level increases the transparency of the trade-offs. We introduce two algorithms: one for model-checking whether an RL agent has the right strategic obligations, and one for modifying a reference decision policy to make it meet obligations expressed in our logic. We illustrate our algorithms on DAC-MDPs which accurately abstract neural decision policies, and on toy gridworld environments.", "sections": [{"title": "Introduction: Strategic Obligations in the Face of Uncertainty", "content": "In the rapidly evolving domain of reinforcement learning (RL), agents are trained to autonomously perform tasks within complex and often unpredictable environments. While significant advancements have been made in improving the performance and adaptability of these agents, a crucial dimension remains under-explored: how these agents align with societal and ethical expectations. Given the increasing ubiquity of RL agents in real-world scenarios \u2014 from finance (Hambly, Xu, and Yang 2023) to health care (Yu et al. 2021) and transportation (Sallab et al. 2017) \u2014 it is essential to establish mechanisms that ensure their actions do not merely optimize for the mission's objective but also adhere to a broader spectrum of ethical norms and societal standards. For brevity, we refer to these ethical and social standards as obligations. Without such normative constraints, the agent's behavior is likely to be badly surprising, and ultimately unsafe when we think of the reactions of human agents in the environment.\nRunning example. Figure 1 shows a problem where a drone must carry biohazardous material across a city to a hospital. The RL problem is to maximize the drone's expected utility, and the rewards are assigned such that the hospital rewards the drone with 10 points, but every other space gives the drone a penalty of -1. The penalty is designed to reflect the operating cost of the drone, and the opportunity cost of not being at its goal. The reward reflects the utility of the drone arriving and remaining at the hospital. This reward encodes the drone's mission. Solving this RL problem gives the policy that leads to the shortest route to the hospital.\nHowever, we also want the drone to avoid a children's playground, where accidental contamination is especially problematic. This indicates a moral conflict between delivering the material to hospital patients quickly, and avoiding contamination to third parties. Instead of tweaking the reward or designing a secondary reward, we assign the drone an explicit, legible, logical obligation to avoid the playground with a high probability. The requirement is probabilistic to account for the uncertainty in the environment, which could make a non-probabilistic obligation unachievable in every case. This explicit obligation, and the algorithms we develop to handle it, avoid the pitfalls of reward manipulation, especially as the number of moral dilemmas increases, and the reward balancing potentially becomes more and more arbitrary.\nFor this task we need ways to formalize the right obligations, and tools to guarantee that the agent has adopted a policy that maximizes its utility only subject to meeting these obligations. Traditional specification languages, like Linear Temporal Logic (LTL), are inadequate at drawing a distinction between what is the case (how the agent behaves) and what should be the case (how it should behave to meet its obligations). Instead, a deontic logic is needed for this distinction (Hilpinen and McNamara 2013). We adopt the logic of Expected Act Utilitarianism (EAU), first introduced in (Shea-Blymyer and Abbas 2022). EAU allows specification and automatic reasoning about the obligations of utility maximizing systems, including the models that underlie reinforcement learning. But it has the shortcoming of grounding obligations in the agent's optimal action at a given moment, without regard for future actions, which conflicts with the way a policy is computed as the maximizer of long-term utility. To remedy this, we introduce a strategic modality to EAU which grounds obligations in the agent's entire policy, not just instantaneous action.\nDesigners also need algorithms that can both verify if a given agent's policy meets the specified obligations, and guide modifications to the agent's policy if it falls short. This paper introduces two algorithms for these challenges: the first efficiently model-checks an RL agent's policy against the strategic obligations formalized in EAU, and the second employs policy gradient ascent to refine the agent's policy until it aligns with the given obligations.\nThis paper's contributions are:\n\u2022 An extension of EAU to strategic obligations, which formalize obligations that must be met by the optimal (utility-maximizing) policy over an infinite horizon, not just the current time step (Section 4).\n\u2022 An algorithm for model-checking whether a Markov Decision Process (MDP), which models action under uncertainty, has given strategic obligations formalized in (the extended) EAU. The model-checker can handle MDPs with tens of thousands of states (Section 4).\n\u2022 An algorithm for modifying a utility-maximizing policy to also satisfy a deontic obligation (Section 5).\n\u2022 An extension of the above policy search algorithm for the case where rewards are not known a priori (Section 6).\n\u2022 Experimental evidence for the effectiveness of the model checking and policy search algorithms (Section 6)."}, {"title": "Related Work", "content": "There are several works that propose approaches for developing ethical RL agents. In (Abel, MacGlashan, and Littman 2016), the authors argue that RL provides a sufficient foundation to ground ethical decision making, and (Gerdes and Thornton 2015) explores methods for implementing ethics into RL systems. Works such as (Noothigattu et al. 2019) and (Wu and Lin 2017) propose the use of inverse reinforcement learning to teach norms to agents. However (Arnold, Kasenberg, and Scheutz 2017) argues for a hybrid approach, and (Bringsjord, Arkoudas, and Bello 2006) offers a purely logical approach. In this paper, we aim to maintain the precision and formality of a logical approach while extending it to be compatible with common RL techniques.\nOur algorithm to modify an agent's policy resembles work in policy gradient methods (Sutton, Singh, and McAllester 2000). Policy gradient methods are robust and versatile mechanisms within the realm of on-policy reinforcement learning and have been used in safe reinforcement learning (Gu et al. 2022). These techniques are designed to optimize cumulative reward by directly manipulating policy functions, affording ease of implementation and compatibility with function approximations. The foundational work of REINFORCE (Williams 1992) marked an early instance where policy gradients were computed using Monte Carlo returns. However, our approach relies entirely on the dynamics of the system, and is concerned both with cumulative reward and conformance to an obligation.\nThis reliance on system dynamics makes our problem similar to the problem addressed in (Wolff, Topcu, and Murray 2012). There, the authors produce an MDP that encodes logical constraints (in a non-deontic logic) and can be solved with dynamic programming. However, their solution maximizes the probability of satisfying the logical constraint while ours seeks to maximize expected utility subject to satisfying a logical constraint.\nOur goal of maximizing expected utility subject to the satisfaction of an obligation is analogous to the constrained MDP (CMDP) problem (Altman 2021). The CMDP problem is to find the policy that maximizes expected utility subject to a constraint on expected cost (or secondary reward). We seek to constrain the MDP solution with a non-discounted probability of reaching a state instead of with a discounted cost. The non-discounted nature of the probability of reaching a state makes our problem distinct from the CMDP problem. Further, the model checkers we employ do not consider discounted rewards. Thus, our problem is not solved by solutions to the CMDP problem or by solutions to a classical model checking problem."}, {"title": "Technical Preliminaries", "content": "We introduce the Expected Act Utilitarian deontic logic for formalizing obligations of agents acting in stochastic environments. We then draw a correspondence between the semantic frames of the logic, MDPs, and Bellman optimality. And we discuss the policy gradients that are central to our policy search algorithms."}, {"title": "Expected Act Utilitarianism", "content": "Expected Act Utilitarianism, or EAU (Shea-Blymyer and Abbas 2022), uses PCTL (Baier and Katoen 2008) to describe states of affairs in the world, and adds modalities to speak of action and obligation. Letting a be an agent from a finite set of agents $agents$, $A$ and $\u00ac$ be Boolean conjunction and negation, and $\\phi$ a PCTL formula, the syntax of EAU is defined by the following grammar,\n$A := \\phi | \u00ac A | A \\land A | [\\textit{a cstit} : A] | \\otimes [\\textit{a cstit} : A]$\nIntuitively, PCTL formula $\\phi$ describes a state of affairs, such as $P_{\\geq 0.9}g$: the probability of predicate $g$ eventually holding is at least 0.9. See (Baier and Katoen 2008) for details of PCTL. Formula $[\\u200ba cstit : A]$ says that a \u201csees to it that\u201d, or ensures, that $A$ is true, while $\\otimes[\\u200ba cstit : A]$ says that $a$ ought to ensure that $A$ is true. For example, the formula"}, {"title": "Property Gradients for Parametric Markov Chains", "content": "In the second part of this paper we will propose an algorithm for updating an optimal policy so that it satisfies the content of an obligation - that is, the PCTL formula $P_{\\geq p}\\phi$ that shows up in an obligation operator $\\otimes [\\textit{a s\\text{-}stit} : P_{\\geq p}\\phi]$.\nTo do this we leverage recent work (Badings et al. 2023), in which gradients with respect to transition probabilities are computed. Specifically, given a parametric Markov Chain (MC) whose transition probabilities are parameterized, and some function $f: S\\rightarrow \\mathbb{R}$ of the states which is obtained as the solution of a linear program, (Badings et al. 2023) show how the gradient of $f$ with respect to the parameters can be computed efficiently. In practice, the parameters on the transition probabilities represent a policy. The function $f$ represents either the reward function (when we want to maximize expected utility), or the probability of satisfying the formula $\\phi$ (when we want to maximize the likelihood of satisfaction)."}, {"title": "Model-Checking Strategic Obligations", "content": "We aim to extend EAU to describe what an agent should do given that it follows its optimal policy for all time. Following (Horty 2001), we call these strategic obligations. This makes EAU more applicable to the RL paradigm, where the optimal policy is typically followed forever. We therefore extend EAU to speak of strategic obligations, then present a model-checking algorithm to handle strategic obligations."}, {"title": "Expected Strategic Oughts", "content": "While EAU gives us the capability to specify and reason about an agent's obligations in stochastic environments, the obligations it defines are determined only by the agent's optimal action in the moment of evaluation. When an agent follows a strategy however, it is natural to inquire about the implications that strategy has on its behavior (beyond its immediate impact). This is especially pertinent when verifying RL systems, as they are expected to follow a learned policy.\nTo reason about an agent's obligations under a strategy, we introduce a strategic obligation in the manner of Horty's strategic ought (Horty 2001), though a broader treatment of strategic modalities can be found in (Broersen and Herzig 2015).\nA strategy (or policy, or schedule) $\\pi$, is a mapping from moments to actions that determines what action an agent will take when it finds itself in a given state. A strategic obligation, then, is an agent's obligation to the state of affairs brought about by an agent following its optimal strategy. We begin with the strategic $stit$ modality: $[\\u200bas\\text{-}stit: A]$, which says that agent $a$ has some strategy that, if followed, ensures that $A$ is the case. To say that an agent has a strategic obligation we write $[\\u200ba s\\text{-}stit: A]$.\nWe define a strategy as a mapping from moments $m$ in the $stit$ tree to a subset $\\pi(m)$ of the actions available at $m$. The set of histories realizable by $\\pi$ starting at $m$ is then\n$H_{m,\\pi} = \\{ h \\in H_m | h \\in \\pi(m') \\forall m' \\in Tree \\text{ s.t. } m' \\geq m \\}$\nThus $h \\in H_{m,\\pi}$ iff $h$ is a possible evolution of the system if the agent follows $\\pi$.\nDefinition 2 (Strategic stit) In\nstit model M,\nM,m/h $[\\u200bas\\text{-}stit: A]$ iff there exists a policy $\\pi$ such that $h\\in H_{m,\\pi}$, and $H_{m,\\pi} \\subseteq |A|^M$.\nTo say that an agent has a strategic obligation we must return to the question of optimality. We say that a strategy is"}, {"title": "Model Checker of Strategic Oughts", "content": "To make the strategic EAU modalities a practical tool for the verification of RL agents, we developed and implemented a model checking algorithm for strategic obligations. Our model checking algorithm takes as inputs an MDP $M$, and an obligation $\\otimes [\\textit{a s\\text{-}stit} : \\phi]$ where $\\phi$ is a formula in PCTL. The algorithm then determines if it is the case that $M \\models \\otimes [\\textit{a s\\text{-}stit} : \\phi]$. By definition 3, this model checking problem can be performed in two sequential steps: first, find the optimal strategy $\\pi^*$, and second, determine if all histories consistent with $\\pi^*$ satisfy $\\phi$. Our model checker assumes that the optimal policy $\\pi^*$ is unique. To enforce this assumption we simply employ a tie-breaking rule, forcing the selection of only one optimal policy if multiple are available. This is done for simplicity; if the existence of multiple optimal policies is critical then the algorithm could be modified to return true only if all optimal policies satisfy the obligation. This algorithm is shown in Algorithm 1, and experimental results of its performance are given in Section 6."}, {"title": "Policy Update to Satisfy Obligations", "content": "In this part of the paper, we move from model-checking an MDP against a strategic obligation, to policy search with strategic obligation constraints. Namely, the design team is given an obligation $\\otimes [\\textit{a s\\text{-}stit} : P_{\\geq p}\\phi]$ as part of design requirements. The team comes up with a reward structure for the agent. Ideally, the reward function induces an optimal policy $\\pi^*$ that also satisfies the obligation, but that is not guaranteed since the reward might be balancing several requirements, and reward shaping is notoriously difficult. But the ethical obligations aren non-negotiable. We therefore ask: how can we modify the reward optimal $\\pi^*$ to\nobtain a policy $\\pi'$ such that the controlled system satisfies $P_{>p}\\phi$ while maintaining a high expected reward?\nWe do this by leveraging gradient computation for parametric MCs (Badings et al. 2023), which was described in Section 3. In our case, the parametric MC is the underlying MDP controlled by $\\pi^*$. The parameters of the MC are the probabilities of taking a given action in a given state, i.e. $\\pi(a|s)$. The function $f$ to be optimized is the probability of the parametric MC satisfying $\\phi$: this probability is computed as the solution of a linear program (Baier and Katoen 2008). The gradient of $f$ relative to the policy parameters is computed by solving a system $\\mathcal{E}$ of linear equations (Badings et al. 2023, Sect. 4.1). We call this the probability gradient $\\nabla_{\\pi}.f$. By doing gradient ascent on $f$ relative to the action probabilities, we can increase the probability of satisfaction, at the cost of veering away from the initial, reward-optimal policy $\\pi^*$. This process does not change the agent's reward function allowing us to continuously evaluate our modified policy on the reward function given by the design team. Note that the probability bound can also be $< p$ with trivial changes to the algorithm. Note also that we can move along the top $k$ largest gradient entries, but potentially decrease search effectiveness. The impacts of this are explored in Section 6.1.\nApproaches to policy updates. Given the probability gradients needed to improve the policy's probability to satisfy $\\phi$, there are many heuristics that can be taken to update the policy while maintaining a high reward.\n\u2022 Line Search: One approach is to do a line search over the line connecting $\\pi^*$, the reward-optimal policy, and $\\pi^{\\circ}$, the policy that satisfies $P_{>p}\\phi$ (and which can be obtained by, e.g., STORM (Hensel et al. 2022)). This line is depicted in Figure 3a. This update simplifies the search space, and is doable using a classical projected gradient.\n\u2022 Average Gradient: We can also use the policy gradient $\\nabla_{\\pi} V$ for expected utility to guide our policy updates (the utility gradient). By following the average of this gradient and probability gradient $\\nabla_{\\pi}.f$, we can allow a simple trade-"}, {"title": "Experiments", "content": "To demonstrate the performance of our algorithms we report on the results of experiments on constrained policy search and model checking. An implementation of our model checking algorithm and our policy update algorithm is included with code to run the following experiments at: https://github.com/sabotagelab/formal-ethical-obligations."}, {"title": "Illustrative Example", "content": "We first apply our methods to the \u201cwindy-drone\u201d system depicted in Figure 1. The \"windy-drone\u201d system represents a drone delivering a heart for transplant while battling high winds. The effects of the wind are represented by stochastic transitions in the system. The drone's objective (as represented by its reward function) is to reach the hospital as quickly as possible. However, in such high winds, we want to prevent the drone from flying bio-hazardous material over locations such as playgrounds.\nThe algorithm is given the stochastic policy that maximizes the agent's expected reward, and aims to modify the\npolicy to satisfy $\\otimes [\\textit{a s\\text{-}stit} : P_{>p}[\u00ac\\diamond playground]]$. This obligation represents the requirement for the agent to avoid the playground with a probability greater than $p$. The dynamics of this obligation are interesting as fulfilling it pushes the agent away from its optimal policy - encouraging it to take a path that is almost twice as long in the best case. In this system, $p$ can not be larger than 0.998, and for the following experiments we set $p = 0.75$. In practice, this probability threshold should be based on a risk analysis, and should reflect the degree of risk that stakeholders are willing to accept.\nLine Search experiment. Our first experiment was on the performance of policies, on the line in policy space, between the the maximally satisfying policy $\\pi^{\\circ}$ and the reward optimal policy $\\pi^*$. In this case we simply interpolate between the two policies \u2014 taking 100 steps between $\\pi^{\\circ}$ and $\\pi^*$. In Figure 4 we show the expected utility and probability of satisfaction of the policies on the line between $\\pi^{\\circ}$ (update 0) and $\\pi^*$ (update 100). Each update $i$ on the x-axis describes the evaluation of a policy $\\pi(i)$ defined by:\n$(1 - i/100)\\pi^{\\circ} + (i/100)\\pi^*$\nAs $i$ increases, the probability of satisfaction monotonically decreases. The expected utility, however, initially decreases, but, around update 40, increases again as $\\pi_i$ approaches $\\pi^*$. This non-monotonicity means that using a simple hill-climbing algorithm to find the maximum expected utility among policies on the line between two given policies will not necessarily return a policy with a global maximum expected utility. We also note that the first update in this experiment to violate the probability threshold $p$ in our obli-"}, {"title": "Policy Optimization With Exploration", "content": "We also sought to test if our method could perform well when rewards were not known a priori. To do this, we guessed the rewards at each state as an arbitrary value, and updated those values as the agent explored its environment. This gave us access to an approximation of the utility gradient $\\nabla_{\\pi} V$ which we can use to increase the expected reward of our policy.\nHowever, if we want to ensure safety while exploring, then we need a way to prevent the agent from taking unsafe actions. To this end we implement a PCTL shield (Alshiekh et al. 2018) that prevents the agent from taking any action that would violate the content of a given obligation.\nWith the shield in place we can allow the agent to explore"}, {"title": "Large Model-Checking Experiment: Cartpole", "content": "This experiment illustrates the execution of our model-checker on a large MDP - specifically, on an MDP modeling the cartpole system. The cartpole system consists of a pole attached by an un-actuated joint to a cart, which moves along a frictionless track. The system is controlled by applying a force of either positive or negative magnitude to the cart, with the objective of keeping the pole balanced upright without the cart running off the track. A tabular approximation of such a system can be defined by a DAC-MDP compiled on a set of trajectories collected by a random policy in the original MDP (Shrestha et al. 2020). The size of the DAC-MDP can be adjusted based on the data size, fan-out, and fan-in size of the compiled MDP. Fan-out is controlled by the number of candidate actions for each state, and fan-in by the number of neighbors used to compile the DAC-MDP.\nThe MDP we retrieved had 50,000 states, 15 actions at each state, and 5 transitions per action, for over 3,000,000 transitions. We formulated 20 PCTL formulas $\\phi_1,..., \\phi_{20}$ to check as both strategic $stit$ statements $[\\u200bas\\text{-}stit : \\phi_k]$, and as strategic obligations $\\otimes [\\textit{a s\\text{-}stit} : \\phi_k]$. We labeled each state with the quintile of the angle of the pole in that state"}, {"title": "Obligation Implication", "content": "To demonstrate our policy optimization procedure on a more complicated form of obligation we show how to find a policy that satisfies an obligation with an implication within it.\nIn the \"windy-drone\u201d system, we might consider allowing the drone to fly over a playground if it visits the checkpoint where its cargo is checked for safety and security. We can model the obligation of the drone to fly over the playground (and thus take a shorter path to the hospital) if it visits the checkpoint as $[\\u200bas\\text{-}stit: P_{\\geq\\beta}[\\diamond playground] \\rightarrow P_{\\geq \\gamma}[\\diamond checkpoint]]$. This is equivalent to saying that the"}, {"title": "Contrary-to-Duty Obligation", "content": "As mentioned, a key strength of a deontic logic is the ability to distinguish between what ought to be the case (the obligation) and what actually is the case, and to reason over the divergence between these two.\nA contrary-to-duty (CTD) obligation is an obligation that enters into force in case a primary obligation (the duty) is violated: e.g. if the agent ought to ensure that the medicine cabinet is full (the primary obligation), but it isn't (the violation), then the agent ought to ensure that next an order is placed (the CTD). This has the following general structure: If a ought to ensure A but A does not happen, then a ought\nto ensure B next. (Other structures are possible, notably using conditional obligations)\n$[\\otimes [\\textit{a s\\text{-}stit} : A] \\land \u00acA] \\Rightarrow [\\otimes [\\textit{a s\\text{-}stit} : OB]]$\nWe model-check such a formula on the \"windy-drone\u201d system depicted in Figure 1. By setting a high reward on the checkpoint state, the agent will have the duty $[\\u200bas\\text{-}stit : \\bigcirc P_{\\geq 0.7}[checkpoint]]$. However, in the case that the agent slips north towards the playground (the violation), it will inherit the new CTD obligation to return to the start state so that it might make a second attempt at the checkpoint: $[\\u200bas\\text{-}stit : \\bigcirc P_{\\geq 0.6}[start]]$. In the CTD structure we have:\n$[\\otimes [\\textit{a s\\text{-}stit} : \\bigcirc P_{\\geq 0.7}[checkpoint]] \\bigwedge Onorth]\n\\Rightarrow [\\otimes [\\textit{a s\\text{-}stit} : \\bigcirc \\bigcirc P_{\\geq 0.6}[start]]\nVerifying that our agent has this obligation allows us to determine how it is expected to behave when it enters a less-than-ideal state.\nWe checked this contrary-to-duty obligations by forcing the agent to move north, and then verifying the truth of the CTD obligation from that state. More generally, we check CTD obligations by looking at the successor states that would indicate a violation of the primary obligation and then verify the truth of the CTD obligations from those states."}, {"title": "Conclusions", "content": "Our modalities for strategic agency and strategic obligation give us the expressive power to reason about a large class of reinforcement learning agents. We presented an algorithm for model-checking that an MDP, equipped with a policy, has the right obligations captured in deontic logic. We introduced a new kind of constrained MDP problem where reward maximization is constrained by an obligation. We also provided a way to modify a policy so that it meets such an obligation without needing to toy with reward functions.\nWe hope that these algorithms will aid system designers in specifying normative constraints, checking their systems against those constraints, and refining their systems to meet their constraints.\nIn future work we're interested in extending our policy update algorithm beyond safety properties to support a larger class of PCTL. We're also interested in managing the trade-offs between following the utility gradient and the probability gradient, perhaps by using a linear weighting function, or different learning rates for each. Further, we'd like to try constraining the policy search with a maximum divergence from the initial policy."}]}