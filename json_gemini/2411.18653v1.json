{"title": "PRSI: Privacy-Preserving Recommendation Model Based on Vector Splitting and Interactive Protocols", "authors": ["Xiaokai Cao", "Wenjin Mo", "Zhenyu He", "Changdong Wang"], "abstract": "With the development of the internet, recommending interesting products to users has become a highly valuable research topic for businesses. Recommendation systems play a crucial role in addressing this issue. To prevent the leakage of each user's (client's) private data, Federated Recommendation Systems (FedRec) have been proposed and widely used. However, extensive research has shown that FedRec suffers from security issues such as data privacy leakage, and it is challenging to train effective models with FedRec when each client only holds interaction information for a single user. To address these two problems, this paper proposes a new privacy-preserving recommendation system (PRSI), which includes a preprocessing module and two main phases. The preprocessing module employs split vectors and fake interaction items to protect clients' interaction information and recommendation results. The two main phases are: (1) the collection of interaction information and (2) the sending of recommendation results. In the interaction information collection phase, each client uses the preprocessing module and random communication methods (according to the designed interactive protocol) to protect their ID information and IP addresses. In the recommendation results sending phase, the central server uses the preprocessing module and triplets to distribute recommendation results to each client under secure conditions, following the designed interactive protocol. Finally,", "sections": [{"title": "1. Introduction", "content": "With the continuous development of society, more and more products and services are available for people to choose. Therefore, it is increasingly difficult for people to find what they are really interested in, which is the problem of information overload. To address the above issues, recommendation systems (RS) have been proposed and widely used [1, 2]. Researchers have developed various kinds of recommendation systems to effectively uncover users' latent interests [3, 4].\nHowever, RS typically require users' historical interaction data, to recommend items (such as products, movies, or short videos) of interest to users. The interaction data may contain sensitive personal information, and its direct use could potentially compromise user privacy. With the advancement of data science and increasing attention from regulations (e.g., GDPR) and citizens regarding the collection and use of personal data, balancing the efficient use of data with privacy security has become a significant research issue.\nFederated Learning is a key technology for addressing this issue [5]. Training recommendation systems using a federated learning framework allows for a balance between model performance and security to some extent. This is also the mainstream research direction in privacy-preserving recommendation systems, known as Federated Recommendation Systems (FedRec). Perifanis et al. [6] and Lin et al. [7] designed different FedRec frameworks based on neural network collaborative filtering algorithms. Han et al. [8], Zhou et al. [9], and Imran et al. [10] extended FedRec to models suitable for time-series data, which is a common data type in real-world scenarios.\nAlthough FedRec avoids directly transmitting data and achieves distributed training by transferring gradient parameters, numerous studies have shown that this approach is still not secure. Researchers have found that by attacking the gradient parameters, it is possible to recover users' private"}, {"title": "2. Related Work", "content": "Model training in recommendation systems often involves the privacy data of multiple users, making it particularly suitable to use distributed training methods across multiple clients for training recommendation models. Consequently, federated learning has been widely applied to distributed training in recommendation systems in recent years. In 2020, Muhammad et al. [19] proposed a fast distributed learning model called FedFast, based on the classic federated learning framework [5]. This model selects a subset of clients for parameter aggregation in each training round and sends the aggregated model to other clients, thus enhancing the efficiency of training FedRec. In 2022, Perifanis et al. [6] introduced Federated Neural Collaborative Filtering (FedNCF), the first method to train neural network-based"}, {"title": "3. The Proposed Method", "content": "There are N clients and a central server involved in a recommender system task in privacy computing. In this problem, client i holds only one interaction vector $u_i$, and $u_i$ contains the indices of the items that client i has interacted"}, {"title": "3.3. Vector Splitting", "content": "In this section, we introduce the preprocessing module, namely the concept and method of 'Vector Splitting'. The purpose of splitting vectors is to protect the local interaction vectors of clients (i.e., users) and the recommendation results generated by the central server. Without loss of generality, we illustrate this process basing on interaction vectors. Figure 1 illustrates the basic steps of this process.\nLet the total number of interaction items be $N_{item}$, the maximum number of interaction items for each user be $n_{max}$, each interaction vector is split into $S_{spl}$ vectors.\nTo protect the interaction data from being leaked, we randomly select some non-interacted (fake interaction) items to mask the real interaction items. For an interaction vector $u_i$, let $n^* = c \\cdot N_{max}$, where $c\\in \\mathbb{N}^+, c > 1$, and satisfy $c \\cdot N_{max} < N_{item}$, and $n^* < len(u_i)$ represents the number of fake interaction items. The function len(\u00b7) calculates the dimensionality of the corresponding vector. This process corresponds to Step 1 in Figure 1.\nThen, the indices of fake interaction items and real interaction items are shuffled, and the result is denoted as matrix $u$, i.e.,\n$u^*_i = shuffle \\begin{bmatrix} u_i \\\\ ones(len(u_i)) \\end{bmatrix} \\begin{bmatrix} randint(1, N_{item}; n^* - len(u_i)) \\\\ zeros(n^* - len(u_i)) \\end{bmatrix} $, (1)\nwhere $u_i$ represents the items interacted by user i. The function $randint(1, N_{item}; n^*-len(u_i))$ generates a vector of dimension $n^*-len(u_i)$ with elements being distinct integers from 1 to $N_{item}$, ensuring they do not overlap with the elements in $u_i$. Its purpose is to generate fake interaction items to mask the"}, {"title": "3.4. Collecting Interaction Vectors", "content": "In the previous section, we split the interaction vectors into multiple splitting vectors. In this section, we will describe the process by which the"}, {"title": "3.5. Sending Recommendation Results", "content": "In the previous section, the central server collected interaction vectors from various clients and trained a recommendation model, resulting in recommendation vectors for each client/user. In this section, we will design an interactive protocol to send the recommendation results.\nTo protect each user's recommendation results from being intercepted by other users, we first use the vector splitting algorithm described in Section 3.3 (Algorithm 1) to split the recommendation results into tuples ($V_{Rec,i}, u_{Rec,i,1}$). These tuples, along with the virtual ID, form the triples ($V_{ID}, V_{Rec,i}, u_{Rec.i.1}), i = 1,2,..., N_{user} \u00b7\nThe central server randomly sends these triples to different clients. Each client that receives the triple compares the $V_{ID}$ with the locally generated virtual ID. If they match, the client stores the triple locally. If they do not match, the client randomly forwards the triple to another client.\nAfter multiple iterations, each client can receive all the triples belonging to itself (confirmed by comparing the virtual ID $V_{ID}$). Finally, each client will use the tuples to compute the interaction information, i.e.,\n$u^*_{Rec,i} = \\begin{bmatrix} u_{Rec,i,1} \\\\ \\sum_s V^*_{Rec,i} \\end{bmatrix} $ (7)\nFinally, remove the redundant information to obtain $u_{Rec,i}$, that is, remove the columns containing 0 from the matrix $u^*_{Rec,i}$, then delete the second row of the matrix. Denote the resulting matrix as $\\bar{u}_{Rec,i}$ Thus, $\\bar{u}_{Rec,i}$ represents the recommended items of client/user i, equivalent to $Rec_i$."}, {"title": "4. Experiments", "content": "In this section, we will experimentally verify the security, transmission accuracy, and communication cost of the proposed privacy-preserving computation method."}, {"title": "4.1. Experimental Settings", "content": "In this experiment, we conducted evaluations based on the Yelp2018 dataset to assess the effectiveness and security of the proposed algorithm. The Yelp2018 dataset was used in the 2018 challenge held by Yelp, containing users' rating information for various businesses, such as restaurants and bars. This dataset includes 31,831 users, 40, 841 items, and 1,666, 869 interactions, with a density of 0.00128 [32]. We will conduct the evaluation from the following perspectives."}, {"title": "4.1.1. Security", "content": "Regarding security, we test the proposed method's security by verifying whether obtaining some split vectors $V^s_i$ can reconstruct the interaction vector $u_i$. Specifically, we assume that several split vectors $V^s_i$ of an interaction vector $u_i$ are obtained by a certain client i, and we explore how many split vectors this client needs to approximately recover the interaction vector $u_i$. When client i obtains t split vectors $V^s_i$, it can use equation (5) to calculate the sum of $V^s_i$ to obtain the speculated vector $u_{spe}$, denoted as\n$u_{spe} = \\sum_{s<t} V^s_i $ (8)\nBy calculating the Jaccard similarity between the speculated vector $u_{spe}$ and the interaction vector$u_i$, we can determine the amount of interaction information obtained by client i. This experiment considers two scenarios.\nThe first scenario examines the relationship between the number of split vectors $V^s_i$ obtained by client i and the Jaccard similarity when the total number of split vectors is 50, 100, and 200. The second scenario examines the relationship between the ratio of fake interaction items to real interaction items, denoted as c, and the Jaccard similarity. The ratios considered are c = 2, 4, 6, 8, 10."}, {"title": "4.1.2. transmission accuracy", "content": "Regarding transmission accuracy, the proposed privacy-preserving computation method needs to accurately send interaction information to the central server. During this process, if the randomly generated virtual IDs by the clients are duplicated, it will result in errors when the central server aggregates the interaction information. Therefore, to ensure high accuracy, the repetition rate of virtual IDs among all clients must be minimized. In this experiment, we will compare the relationship between the length of virtual IDs and the repetition rate."}, {"title": "4.1.3. Communication cost", "content": "For the efficiency and practicality of the interaction process, we conducted the following experiment with groups of 1000 clients.\nRegarding communication cost, we first considered the impact of the attenuation factor a on communication cost during the collecting interaction vectors phase and the sending recommendation results phase. Based on this, we selected the optimal value for the attenuation factor. Furthermore, we examined the relationship between the total communication cost in bytes and the number of clients, which is a crucial metric when considering communication costs in privacy-preserving computation.\nAdditionally, since the communication frequency of the proposed method is influenced by both probability and the number of clients, it is necessary to further verify whether the method is suitable for scaling to large data applications. We conducted experiments to compare the relationship between the number of clients participating in the computation during data interaction and the average number of information transmissions per client (i.e., the number of times triplets are sent)."}, {"title": "4.2. Results and Analysis", "content": null}, {"title": "4.2.3. Results of Communication Cost Experiment", "content": "Figure 5 shows the results of the first communication cost experiment. From this figure, we can draw the following three conclusions:\n\u2022 During the collecting interaction vectors phase, the communication cost increases with the attenuation factor a. This is because a larger attenuation factor increases the probability of clients participating in communication (as indicated in lines 6 to 12 of Algorithm 2), thereby increasing the number of communications and the communication cost.\n\u2022 During the sending recommendation results phase, the communication cost decreases with the increase of the attenuation factor. This is because the tuples ($V_{ID}, I_{ip}$) that we set indirectly reduce the communication cost. Specifically, with a larger attenuation factor, the number of communications during the collecting interaction vectors phase increases, thus increasing the probability that each client stores other clients' ID information tuples ($V_{ID}, I_{ip}$) in the local database LD (as indicated in line 18 of Algorithm 2). Therefore, in the sending recommendation results phase, each client can send information based on the tuples ($V_{ID}, I_{ip}$), increasing the probability of correctly sending information and reducing the communication cost.\n\u2022 From the sum of the communication costs of the two phases, it can be seen that the total communication cost is minimized when the attenuation factor a = 0.90.\nFigure 6 shows the results of the second communication cost experiment. As shown in Figure 6, under different attenuation factor settings, the total communication cost of the proposed privacy-preserving computation method has a roughly linear relationship with the number of clients. This indicates that if this method is extended to large-scale data privacy computations, it will not lead to an exponential increase in communication cost.\nFigure 7 shows the average number of triplets sent by each client during the collecting interaction vectors phase and the sending recommendation results phase. The experimental results indicate that as the number of clients increases, the average number of transmissions remains very stable, further validating the stability of the proposed method."}, {"title": "5. Conclusion", "content": "In this paper, we propose a new privacy-preserving recommendation system to address the security issues in recommendation systems and the scenario where each client only holds interaction data for a single user. We used split vectors and generated fake interaction items to protect the real"}]}