{"title": "Perceptron Collaborative Filtering", "authors": ["Arya Chakraborty"], "abstract": "While multivariate logistic regression classifiers are a great way of implementing collaborative filtering - a method of making automatic predictions about the interests of a user by collecting preferences or taste information from many other users, we can also achieve similar results using neural networks. A recommender system is a subclass of information filtering system that provide suggestions for items that are most pertinent to a particular user. A perceptron or a neural network is a machine learning model designed for fitting complex datasets using backpropagation and gradient descent. When coupled with advanced optimization techniques, the model may prove to be a great substitute for classical logistic classifiers. The optimizations include feature scaling, mean normalization, regularization, hyperparameter tuning and using stochastic/mini-batch gradient descent instead of regular gradient descent. In this use case, we will use the perceptron in the recommender system to fit the parameters i.e., the data from a multitude of users and use it to predict the preference/interest of a particular user.", "sections": [{"title": "I. A BRIEF HISTORY AND INTRODUCTION", "content": "Neural network in machine learning is a model made up of artificial neurons or nodes. The connections between the nodes are modelled as weights. A positive weight reflects an excitatory connection while a negative weight reflects an inhibitory connection. The inputs are modified by the weights and summed; an activity known as linear combination. An activation function at the end controls the amplitude of the output i.e., brings the output in a desirable range - usually 0 to 1 or -1 to 1.\nIn 1943, Warren McCulloch and Walter Pitts from the University of Illinois and the University of Chicago published research that analysed how the brain could produce complex patterns and could be simplified down to a binary logic structure with only true/false connections. Frank Rosenblatt from the Cornell Aeronautical Laboratory was credited with the development of the perceptron in 1958. His research introduced weights to McColloch's and Pitt's work, and Rosenblatt leveraged his work to demonstrate how a computer could use neural networks to detect imagines and make inferences.\nThe next step in the development of neural networks came in 1982 with the development of 'Hopfield Networks' by John Hopfield. A Hopfield network is a fully interconnected recurrent neural network where each unit is connected to every other unit. It behaves in a discrete manner and produces distinct outputs in generally binary (0/1) form or in bipolar (-1/1) form. In a recurrent neural network, the outputs of the neurons are again fed into the network as 'memory' that improves the current output and input of the network.\nThe backpropagation algorithm, which nowadays forms the basis of the neural networks, though independently discovered many times earlier, the modern form was proposed by Yann LeCun in 1987. Paul Werbos was the first in US to propose that backpropagation could be used for neural nets after deep analyzation in his 1974 dissertation. The Werbos method was rediscovered in 1985 by Parker and in 1986 by David Everett Rumelhart, Geoffrey Everest Hinton and Ronald J. Williams. However, the basics of continuous backpropagation were derived in the context of 'Control Theory' by Henry J. Kelley and Arthur E. Bryson in 1960 and 1961 respectively"}, {"title": "II. THE CLASSICAL APPROACH", "content": "Collaborative Filtering is usually done using multivariate logistic regression as the output is discrete in nature (Logistic regression corresponds to discrete output, used in classification problems; while linear regression corresponds to continuous output, used in data-value prediction problems). With conventional regularized multivariate regression, appreciable accuracy is achieved. But, neural networks (perceptron) can help us to achieve considerably more accuracy using backpropagation and gradient descent. The classical approach to collaborative filtering using logistic regression is as follows:\nnu = number of users\nnm = number of movies\nr(i,j) = 1 if 'j' has rated movie 'i' (0 otherwise)\ny(i,j) = rating by user 'j' on movie 'i' (if defined)\n$\\theta^{(0)}$ = parameter vector for user 'j'\nx(i) = feature vector for movie 'i'\nGiven x (1), ..., x (nm), estimate $\\theta^{(1)}$, ..., $\\theta^{(nu)}$:\n$\\min_{\\theta^{(1)}, ..., \\theta^{(nu)}} \\frac{1}{2} \\sum_{j=1}^{nu} \\sum_{i:r(i,j)=1} ((\\theta^{(j)})^T x^{(i)} \u2013 y^{t.j})^2$\nAdding the regularization term to overcome overfitting or underfitting (due to high bias or variance):\n$\\min_{\\theta^{(1)}, ..., \\theta^{(nu)}} \\frac{1}{2} \\sum_{j=1}^{nu} \\sum_{i:r(i,j)=1} ((\\theta^{(j)})^T x^{(i)} \u2013 y^{t.j})^2 + \\frac{\\lambda}{2} \\sum_{j=1}^{nu} \\sum_{k=1}^{n} (\\theta_k^{(j)})^2$\nWhere $\\theta \\epsilon R^n$ i. e., $\\theta$ is an n \u2013 dimensional vector, $\\lambda$ = regularization parameter\nSimilarly, Given $\\theta^{(1)}$, ..., $\\theta^{(nu)}$ estimate x(1), ...,x(nm):\n$\\min_{x^{(1)}, ..., x^{(nm)}} \\frac{1}{2} \\sum_{i=1}^{nm} \\sum_{i:r(i,j)=1} ((\\theta^{(j)})^T x^{(i)} \u2013 y^{t})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{nm} \\sum_{k=1}^{n} (x_k^{(i)})^2$\nWhere x \u2208 R i. e., x is an n \u2013 dimensional vector\nConsidering the above functions as the cost functions for the respective parameter vectors ($\\theta$) and feature vectors (x) as J($\\theta^{(1)}$, ..., $\\theta^{(nu)}$) and J(x(1), ..., x(nm)) we simultaneously minimize the functions using gradient descent. Thus, for every j = 1,2, ..., nu and i = 1,2,..., nm:\n$x_k^{(i)} = x_k^{(i)} \u2013 \\alpha (\\sum_{j:r(i,j)=1} ((\\theta^{(j)})^T x^{(i)} \u2013 y^{(t)}) x_k^{(i)}) + \\frac{\\lambda}{2} x_k^{(i)}$\n$\\theta_k^{(0)} = \\theta_k^{(0)} - \\alpha (\\sum_{i:r(i,j)=1} ((\\theta^{(j)})^T x^{(i)} \u2013 y^{(i,j)}) x_k^{(i)}) + \\frac{\\lambda}{2} \\theta_k^{(i)}$\nWhere $x^{(t)}$ is the kth feature of the feature vector x \u2022x(i) and $\\theta^{(i)}$ is the kth parameter of the parameter vector $\\theta^{(i)}$. The learning rate for the gradient descent is \u03b1 and the regularization parameter for the same is \u03bb. Both are hyperparameters and can be optimized using hyperparameter tuning."}, {"title": "III. USING ARTIFICIAL NEURAL NETWORKS", "content": "After minimizing the cost functions and coming up with a set of feature vector (X) and parameter vector ($\\theta$), we compute the hypothesis h(x) using the sigmoid function\n$h(X) = \\frac{1}{1+ e^{-\\theta^T X}}$\nwhere X is the feature vector of the movie to be recommended to the user and $\\theta$ is the parameter vector of the user. h(x) is the estimated likelihood that user $\\theta$ will like movie X\nNeural networks are complex machine learning models designed to fit complex datasets using backpropagation and gradient descent (or other advanced optimization algorithms). This can help us to achieve higher levels of accuracy in predicting the choice/taste of a user. Coupled with optimization techniques such as cosine similarity, gradient boosting and dimensionality reduction, it will be able to provide a more accurate outcome.\nAs seen in a number of experiments and research studies, artificial neural networks tend to provide a better overall fit to the data, thanks to its ability to form more complex decision boundaries. Thus, in this use case too, it would help us to find a better fit for the data."}, {"title": "A. Objective of the Model", "content": "Given x(1), ..., x(nm) and y(i,j), estimate $\\theta^{(1)}$, ..., $\\theta^{(nu)}$\nCompute: Argmin C($\\theta$); C($\\theta$) \u2192 Cost/Loss Function\nPreprocessing of the dataset:\n$y^{(i,j)} = \\begin{cases} 1: y^{(i,j)} \\geq T \\\\ 0: y^{(i,j)} < T  \\end{cases} ;T \u2192 Threshold of recommendation$\nThe value of T can be set based on the rating of the movies. It signifies that the value of y will be set to 1, if the rating of the movie according to a user is greater than the threshold and 0, if the rating is lower than the same.\n$Cost(h(x), y) = \\begin{cases}  - logh(x); y = 1 \\\\ (-log(1 \u2013 h(x)); y = 0  \\end{cases}$$\nwhere, $h(x) = \\frac{1}{1+ e^{-\\theta^T X}}$\n$\\theta^T$ = Transpose of the matrix containing the parameter vectors of the user\nX = Matrix containing the feature vectors of the movie\nCombined form of the cost function:\ncost(h(x),y) = \u2212y log(h(x)) \u2013 (1 \u2013 y) log(1 \u2013 h(x))\nFor artificial neural networks the total cost, denoted by C ($\\theta$) is:\n$C(\\theta) = - \\frac{1}{Nm} \\sum_{i=1}^{Nm} (y^{{i}} log (h(x^{(i)}) + (1-y^{{i}}) log (1-h(x^{({i}}))$\nFor a neural network containing K output nodes, the cost/loss function gets modified. The sum over all the output nodes is taken in this case, and the function is modified in the following way:\nK \u2192 number of ouput nodes of the neural network\n$C(\\theta) = - \\frac{1}{Nm} \\sum_{i=1}^{Nm} \\sum_{k=1}^{K} (y^{{i}} log (h(x^{({i}})) + (1-y^{{i}}) log (1-h(x^{({i}}))$\nTherefore, objective: compute Argmin C ($\\theta$):\nCompute: $Argmin - \\frac{1}{Nm} \\sum_{i=1}^{Nm} \\sum_{k=1}^{K} (y^{{i}} log (h(x^{({i}})) + (1-y^{{i}}) log (1-h(x^{({i}}))$"}, {"title": "B. Working of the Proposed Model", "content": "g(x) = Activation function of the neural network\nThe activation function helps to map the resulting values in between 0 to 1 or -1 to 1 etc. (depending on the function). Some of the activation functions that can be used in the neural network including linear and non-linear activation function are:"}, {"title": "C. Optimization Techniques", "content": "The following optimization techniques can be implemented in the model to increase the computational efficiency of the same as well as to achieve a better overall result.\n1) Implementing Gradient Checking: Backpropagation is very powerful if implemented correctly. While building a neural network from scratch, backpropagation is often the place where people make mistakes. Implementing backpropagation incorrectly may not only result in the improper estimation of the weights, but also the total failure of the neural network. Thus, an intermediate step, known as gradient checking could help in overcoming this problem. This is a powerful way to eliminate all the bugs in backpropagation.\nFrom calculus we know,\n$\\frac{d}{dx} f'(x) = \\frac{d}{dx} f(x) = \\lim_{h\\to 0} \\frac{f(x + h) - f(x - h)}{2h}$\nUsing this, we can conduct the numerical estimation of the gradient by\n$\\frac{d}{d\\theta} C(\\theta) \\approx \\frac{C(\\theta + \\gamma) \u2013 C(\\theta \u2013 \\gamma)}{2\\gamma}$; where $\\gamma \\approx 10^{-7}$\nTherefore, $\\forall \\theta_i \\in {\\theta_1, \\theta_2,...,\\theta_n}$:\n$\\frac{\\partial}{\\partial \\theta_i} C(\\theta) \\approx \\frac{J(\\theta_1, \\theta_2,..., \\theta_i + \\gamma, \\theta_{i+1}, ... \\theta_n) \u2013 J(\\theta_1, \\theta_2,..., \\theta_i \u2013 \\gamma, \\theta_{i+1}, ... \\theta_n)}{2\\gamma}$\nLet the matrix formed by the numerical estimation of the gradients be G'. Now we calculate the Euclidian distance normalized by the sum of the sum of the vectors G and G'.\n$\\epsilon = \\frac{||G' - G||_2}{||G'||_2 + ||G||_2}$\nIf $\\epsilon < \\gamma$, we can conclude that the backpropagation was implemented correctly and is therefore working.\nNote: While gradient checking is an incredibly powerful way of checking whether backpropagation is working properly, it must be noted that it is a very memory intensive process and therefore must be implemented only once i.e., after the initial calculation of the gradient matrix using backpropagation. If gradient checking is allowed to run after every iteration of gradient descent, then the efficiency of the model will be hampered.\n2) Random Initialization of the Parameters: While setting all the initial value of the weights to zero works for logistic regression, it doesn't work for neural networks. This is because, for all iterations, the weights of the activation nodes will be equal. This will therefore result in the parameters going into each of the nodes be equal. That is,\n$\\frac{\\partial}{\\partial \\theta_1} C(\\theta) = \\frac{\\partial}{\\partial \\theta_2} C(\\theta) = ... = \\frac{\\partial}{\\partial \\theta_n} C(\\theta)$\nThus, the neural network always ends up with only one feature. This will result in high bias and will therefore result in under-fitting of the parameters.\nSymmetry breaking: Initialize every $\\theta \\epsilon \\theta^{(1)} \\forall \\theta^{(1)} \\epsilon U_z$ to some random value in between [-x.x] e.g., 0.69420\nNote: Usually it is a good practice to randomize all the weights in the range (0, 1), such that every weight is a random real number between 0 and 1 (both exclusive). The weights can also be between -1 and 1 (both exclusive).\n3) Feature Scaling: The idea is to make sure that all the features are on a similar scale. Gradient descent can converge faster if the features are in a similar range. Therefore, for all the different features, the features need to be divided by some constant (maybe be different for different features) to get them into approximately -1$\\leq$x$\\leq$1 range."}, {"title": "4) Mean Normalization", "content": "Just like feature scaling, this falls under the category of preprocessing of data. Here the idea is to make all the features have zero mean. Having a normalized dataset helps the gradient descent to converge faster, thereby lowering the training time of the model.\n$X_i = \\frac{X_i \u2013 \\mu_i}{max \\, x_i - min \\, x_i}$; $\\mu_i$ \u2192 mean of the dataset\nReplacing the denominator by standard deviation instead, we obtain a similar result. The process is called mean standardization.\n5) Implementing Regularization: A machine learning model is often prone to high bias or high variance. The former happens when the hypothesis functions maps poorly to the trend of the data and is also known as under-fitting. The latter is when the learned hypothesis may fit the training set very well but fail to generalize to new examples outside the training dataset. This can be eliminated by keeping all the features but reducing the magnitude/values of the parameters.\nTherefore, we penalize the cost function using a new introduced term, \u03bb, known as regularizing parameter, thereby minimizing the values of the parameters.\nThe regularized cost function for the neural network is:\n$C(\\theta) = \\frac{1}{Nm} \\sum_{i=1}^{nm} \\sum_{k=1}^{K} (y_k^{({i}}) log (h(x^{(i)})) x) + (1 -y_k) log (1 \u2013 h(x^{({i}})) + (0\\frac{\\lambda}{2Nm} \\sum_{l=1}^{L-1} \\sum_{i=1}^{S_l} \\sum_{j=1}^{S_{l+1}} (\\theta_{ji}^{(l)})^2$\nWhere St, Sl+1 = number of units in layer l, l + 1 respectively; L = total number of layers in neural network\nNote: If the value of \u03bb i.e., the regularization parameter is too large, all the parameters are close to zero. This results in underfitting i.e., the hypothesis has too high bias. Similarly, a too small value of the regularizing parameter will make the regularization term very small and thus will result in regularization becoming useless. Thus, we should pick a moderate value of the regularization parameter (around 10) and modify it overtime to find the best fit.\n6) Hyperparameter Tuning: In machine learning, a hyperparameter is a parameter whose value is used to control the learning process unlike the other parameters whose values are derived via training. For the neural network, we have two hyperparameters involved i.e., the learning rate, a, of the gradient descent and the regularization parameter, \u03bb, for the regularized cost function.\nThere are various ways of going about hyperparameter tuning. The most common ones are GridSearchCV and Randomized SearchCV. In GridSearchCV approach, the machine learning model is evaluated for a range of hyperparameter values. It is called GridSearchCV because it searches for the best set of hyperparameters from a grid of hyperparameter values.\nRandomizedSearchCV solves a drawback of GridSearchCV, as it goes through only a fixed number of hyperparameter settings. It moves within the grid in a random fashion to find the best set of hyperparameters. This approach reduces unnecessary computation."}, {"title": "7) Using Stochastic Gradient Descent or Mini-Batch Gradient Descent", "content": "Stochastic gradient descent is selecting data points at each step to calculate the derivatives. Stochastic gradient descent randomly picks one data point from the whole dataset at each iteration to reduce the computations enormously.\nThe way of going about stochastic gradient descent is as follows:\n$cost (\\theta, (x^{(i)},y^{(i)})) = \\frac{1}{2} (h(x^{(i)}) \u2013 y^{(i)})^2$\nTherefore, calculating the derivative of the cost function, we have the following expression:\n$\\frac{\\partial}{\\partial \\theta_j} cost (\\theta, (x^{(i)},y^{(i)})) = (h(x^{(i)}) \u2013 y^{(i)})x_j^{(i)}$\nThus, the following steps should be taken in order to implement Stochastic Gradient Descent (SGD):\n1. Randomly shuffle the dataset. Randomly shuffled dataset at first will help the gradient descent converge a little faster to the global minimum.\n2. Repeat {\nfor i = 1,2..., m {\n$\\theta_j = \\theta_j \u2013 \\alpha ((h(x^{(i)}) \u2013 y^{(i)})x_j^{(i)})$; for all j = 0, 1, ..., n (n = total number of features)\n}\n}\nLooking through each example and take a little step to try to fit just that particular parameter.\nFor mini-batch gradient descent we define a parameter \"b\", the mini batch size i.e., using \"b\" examples for every iteration. Usually the value of \"b\" is taken somewhere between 2 and 100. The process is as follows:\nRepeat {\nGet \u201cb\u201d examples \u2192 ($x^{(i)},y^{(i)}$), ..., ($x^{(i+(b-1))},y^{(i+(b-1))}$)\n$\\theta_j = \\theta_j - \\alpha \\sum_{k=i}^{i+(b-1)} (h(x^{(k)}) \u2013 y^{(k)})x_j^{(k)}$ ; for all j = 0,1,...,n (n = total number of features)\ni=i+b\n}\nUsing mini-batch gradient descent results in more stable convergence towards the global minimum since we are calculating an average gradient over \"b\" examples.\nNote: While mini-batch gradient descent is computationally more efficient, the one major turnoff in this case is the introduction of a new hyperparameter \"b\", i.e., the batch size. Thus, to ensure peak efficiency, we have to tune the mini batch size, \"b\", as well along with the other hyperparameters using hyperparameter tuning.\nThe above optimization techniques help us not only to eliminate bugs and improve accuracy of the model, but also goes a long way in improving the computational efficiency of the same. Therefore, we should implement all of the above techniques to help us make the model optimal."}, {"title": "IV. CONCLUSION", "content": "While logistic regression classifiers provide a fairly accurate result of the user's recommendation based on the data collected from a multitude of users, we can further enhance the accuracy of the model by the introduction of neural networks. As neural networks are designed to fit complex datasets, we can form functions of higher complexity and thus get a better fit for the data without running into issues like high bias (under-fitting) and high variance (over-fitting). While neural networks can fit the datasets better than logistic classifiers, they are often computationally more expensive. Thus, we implement a series of optimization techniques to get the best possible results with the least computational work. This includes preprocessing of data i.e., implementing mean normalization and feature scaling. While training the model, we use gradient checking to ensure backpropagation is implemented correctly, we use regularization to overcome the issue of under-fitting and over-fitting due to high bias and high variance respectively. We initialize the parameter vectors using random initialization. To make the model computationally more efficient, instead of regular batch gradient descent, we use stochastic/mini-batch gradient descent. Finally, to achieve the best set of hyperparameters i.e., the learning rate (a), the regularization parameter (\u03bb) and the mini-batch size (b), we use hyperparameter tuning using GridSearchCV or RandomizedSearchCV. More advanced algorithms such as Momentum (used for reducing the high variance in SGD and softening the convergence), Nesterov Accelerated Gradient (made so that Momentum does not miss the local minima), AdaGrad (overcomes the problem of having a constant learning rate and therefore implements a dynamic learning rate), AdaDelta (removes the decaying learning rate problem of AdaGrad) and Adaptive Momentum Estimation (works with momentums of first and second order) can be used instead of gradient descent to further improve the computational efficiency and accuracy. For neural networks specifically, Adaptive Momentum Estimation tends to be the best optimizer.\nThe objective (section III-A) and the working (section III-B) of the model have been explained with the specific example of recommending a movie to a user. However, the similar approach can be followed in other use cases as the core concept remains the same. The most important part is the implementation of gradient checking just after the calculation of the derivatives using backpropagation to ensure the proper working of the backpropagation algorithm. The perceptron collaborative filtering can be used in OTT platforms to recommend movies to a user based on the rating of other users. It can also be used in online shopping platforms to recommend certain products to certain people based on relatability and rating/reviews."}]}