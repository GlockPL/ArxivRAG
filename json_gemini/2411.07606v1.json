{"title": "Optimizing Service Function Chain Mapping in Network Function Virtualization through Simultaneous NF Decomposition and VNF Placement", "authors": ["A.Asgharian-Sardroud", "M. H. Izzanlou", "A. Jabbari", "S. Mahmoodian Hamedani"], "abstract": "Network function virtualization enables network operators to implement new services through a process called service function chain mapping. The concept of Service Function Chain (SFC) is introduced to provide complex services, which is an ordered set of Network Functions (NF). The network functions of an SFC can be decomposed in several ways into some Virtual Network Functions (VNF). Additionally, the decomposed NFs can be placed (mapped) as VNFs on different machines on the underlying physical infrastructure. Selecting good decompositions and good placements among the possible options greatly affects both costs and service quality metrics. Previous research has addressed NF decomposition and VNF placement as separate problems. However, in this paper, we address both NF decomposition and VNF placement simultaneously as a single problem. Since finding an optimal solution is NP-hard, we have employed heuristic algorithms to solve the problem. Specifically, we have introduced a multiobjective decomposition and mapping VNFs (MODMVNF) method based on the non-dominated sorting genetic multi- objective algorithm (NSGAII) to solve the problem. The goal is to find near-optimal decomposition and mapping on the physical network at the same time to minimize the mapping cost and communication latency of SFC. The comparison of the results of the proposed method with the results obtained by solving ILP formulation of the problem as well as the results obtained from the multi-objective particle swarm algorithm shows the efficiency and effectiveness of the proposed method in terms of cost and communication latency.", "sections": [{"title": "1. Introduction", "content": "In recent years, the ever-increasing proliferation of applications on computers and mobile devices has increased the demand for network services. Traditionally, network services were delivered through expensive hardware equipment that could neither keep up with the ever- increasing demand nor allow new services to be deployed cost-effectively. Network Functions Virtualization (NFV) has recently been proposed to overcome such issues. NFV is a promising network architecture concept that aims to virtualize network service by implementing single service components in virtual machines enabled on commercial servers (COTS). Each service is represented by a service function chain (SFC), which is a collection of NFs that execute according"}, {"title": "1.2. SFC structure", "content": "One of the main challenges of NFV orchestration is the deployment and appropriate prototyping of sequences of VNFs that form the Service Function Chain (SFC) [2, 3]. SFC is a mechanism that allows different service functions to be connected together to form a service that enables carriers to benefit from a virtualized software-defined infrastructure. SFC is an enabler for NFV that provides a flexible and cost-effective alternative to today's static environment for Cloud Service Providers (CSP), Application Service Providers (ASP), and Internet Service Providers (ISPs). The required services usually are represented as Service Graphs (SG) in which the number, type, and order of each NF are determined according to the performance and behavioral characteristics of the corresponding service. Service decomposition is the process of converting an SG containing high-level NFs (composite) into SGs with more basic NFs that can finally be mapped onto the physical infrastructure. Service decomposition aims to reuse basic building blocks (NF), build new and more complex services, and request high-level services without worrying about detailed implementations. Primitive NFs can be of different types, which means they can be implemented through different techniques. These techniques include 1) virtual machine (VM) images with different virtualization techniques such as Xen, Virtual Box, and VMware; 2) Processing inside a container (Process); 3) package I/O drivers such as Intel's Data Plane Development Kit (DPDK), which includes a set of open source libraries integrated with VMware to speed up the processing of packages that use services such as VNF; 4) Hardware"}, {"title": "1.3. VNF Mapping", "content": "In NFV networks, network functions are separated from the main hardware and run as VNFs. Due to the software feature of VNFs, they can be deployed flexibly. Therefore, an important issue"}, {"title": "1.4. Contributions", "content": "Our proposed method simultaneously finds a near-optimal decomposition and mapping considering both cost and delay criteria, for each SG. Some research has been done on finding the"}, {"title": "2. Related works", "content": "So far, many works have been done in the area of creating service function chains and mapping these chains on physical infrastructures that we survey each one separately. In the following two subsections, we review some related works on service function decomposition and VNF mapping."}, {"title": "2.1. Creating service function chains", "content": "The VNF chaining problem (VNF-C), which is also called the service function chaining problem, mainly focuses on the chaining mechanisms of VNFs and routing the relevant traffic through these VNFs in order, to reach the destinations [6]. Intending to solve this problem, the IETF has specifically created a working group to document new approaches to service delivery and VNF functionality and SFC architecture and traffic command algorithms [7], which prove the importance of SFC. To solve this problem, Sahaf et al. [4], and Li et al. [8] formulated it as an ILP model with different objectives. Sahaf et al. aimed to minimize the total cost by judicious choice of VNF decomposition, but Lee et al. aimed to minimize end-to-end delay by random flow distribution. Sahaf et al. formulated the VNF-C problem as an ILP model, which was solved by COIN-OR solver [9]. Their algorithm can be divided into two steps, namely, decomposition selection and mapping. In the decomposition selection step, a decomposition with the minimum cost is selected and in the mapping step, it is placed on an appropriate node. Li et al. also first proposed two criteria: uniform distribution scheme (flows are distributed equally to all VNF instances and no resource constraints are considered) and network distribution scheme (flows are distributed based on the delay between VNF samples). Then, by changing the flow distribution, it was claimed that the two measures reduced the overall delay by 27.14-40.56% and 12.77-28.84%, respectively.\nFor practical situations, solving the VNF-C problem dynamically is more suitable. In this regard, Liu et al. [10] considered the problem of re-adapting VNF-C in a dynamic environment so that, on the one hand, it should satisfy the new service requirements. On the other hand, it should readjust the existing service chain to meet the changing needs of users. To solve these two cases, Liu et al. first formulated the corresponding ILP model that can be used to obtain the optimal solution. However, due to the huge execution time spent to solve the ILP model, they also proposed an innovative method based on the idea of column generation (CG) that only needs to generate variables that may improve the objective formulated in the ILP model. In addition, the main idea behind the CG-based algorithm was to decompose the original problem into a main problem and a sub-problem and then solve them iteratively to obtain the near-optimal solution. For flexibility and economic reasons, many service providers want to consider VNF-C and VNF placement. To achieve such a common goal [11], Botton and colleagues proposed a model for VNF-C that considered not only resource capacity constraints but also VNF location constraints. Similarly, the corresponding proposed heuristic algorithm was also implemented under such constraints. However, it was found that this proposed innovative method considered the VNF-C problem as a VNE problem and therefore the problem actually solved was VNE instead of VNF-C. Although"}, {"title": "2.2. VNFs mapping", "content": "VNF mapping is a step for the optimal allocation of VNFs in the network infrastructure. Moen and Mones [21] presented a formal VNF mapping problem for resource allocation in hybrid network environments where network functions can be allocated over physical hardware and virtual instances. With the advancement of 5G networks, low and predictable end-to-end latency is becoming increasingly important as a critical factor for many applications. They have presented a general model for the efficient mapping of virtual network functions. The simultaneous mapping of VNFs is used to form a service function chain (SFC) and a chain of VNFs, and then admission control (AC) is used to reach the maximum performance state. In fact, the main problem of [21] is to present a system model that formulates the problem of allocating the desired resources for different types of SFCs and deals with the computational complexity of the problem. In [22] Bari et al. introduced the VNF orchestration problem, which was equivalent to VNF-P, and formulated it as an ILP model, in terms of OPEX minimization and network utilization maximization. Riggio et al. formulated VNF-P [23] in a radio access network scenario as an ILP model and solved it to obtain the optimal solution of VNF mapping under radio resource constraints. This problem also has been considered for different objectives. For example, Luizelli et al. [24] formulated the ILP model to minimize the end-to-end delay and resource overage ratio, while Gupta et al. [25] aimed to minimize the bandwidth consumption using the ILP model. Although they have different aims and work in different scenarios, the constraints of VNF-P, which include resource allocation, VNF mapping, and traffic engineering (TE), are generally the same.\nHowever, the ILP model is only suitable for the condition that all variables are integers. Therefore, for some special circumstances, MILP is used instead. Addis et al. [26] proposed a VNF-P model that considers both minimizing the number of CPUs used by creating VNFs and minimizing the risk of sudden bottlenecks in network links (TEs). But, to achieve these two goals at the same time, some non-integer variables must be introduced. Therefore, the VNF-P model proposed by them was a MILP model that described the relationship between VNF mapping and traditional routing. By solving this model, Addis et all. claim to have achieved a 70% NFVI cost savings and a 5% increase in link utilization compared to studies that only consider the TE target. ILP and MILP models are usually solved by open-source optimization software such as CPLEX [27], LINGO [28], and GLPK [29] to obtain the optimal solution. Among other classical algorithms that solve two mathematical models are: branch and bound, branch and cut, etc. However, these mathematical proposals suffer from the weakness of scalability, that is, they cannot be implemented in large-scale networks, because their execution time grows exponentially with the size of the network. For example, Bari et al. [22] spent 1595.12 seconds solving the ILP model using CPLEX for a network containing only 23 nodes and 43 links. They also proposed a heuristic algorithm that solved the problem on the same network in 0.442 seconds. Due to the fact that the execution time of the heuristic method is much less than the optimal solvers and they can find solutions close to the optimal solutions, they are more common in solving VNF decomposition and mapping problems. In [23], Riggio et al. proposed a three-step heuristic algorithm for VNF-P in wireless networks. The steps of their algorithm were: calculating the candidate substrate nodes for virtual nodes, sorting the virtual nodes, and mapping them on the substrate nodes. After three stages, they claimed to have achieved an approximation of the desired performance. This turns VNF-P into a VNE problem. However, despite the similarities between VNF-P and VNE, they are different problems. Interested readers can refer to [30] to study more on this topic."}, {"title": "3. The Problem description", "content": "A service consists of several service functions that are traditionally implemented by intermediate nodes. The service is described by a chain of high-level network functions (NF) and predefined parameters called service graphs (SGs). A service graph is a set of NVFs that must be mapped onto the physical infrastructure.\nLet SG denote the set of all service graphs that have already been sent to an Internet Service Provider (ISP). Each $sg_k \\in SG$ is an independent service graph that contains several different VNFs and each of them is associated with resource requirements such as processing capacity (C), memory capacity (M), and storage capacity (S). An sg e SG may have multiple decompositions which we denote them $Decompsg$. That is:\n$\\forall sg_k \\in SG: Decomp_{sg_k} = \\{dc_1, dc_2, ..., dc_n\\}."}, {"title": "3.1. Physical network", "content": "The physical infrastructure of the problem is considered an undirected graph $G_p$ with nodes $N_p$ and links $L_p$. That is:\n$G_p = (N_p, L_p)$.\nWe use $Cuj$, $Muj$ and $Suj$ respectively to denote the processing capacity, memory capacity, and storage capacity of the node $uj$:\n$\\forall u_j \\in N_p: C_{u_j}, M_{u_j}, S_{u_j} \\in N^+$.\n$\\forall u_j \\in N_p: C_{Cost_{u_j}}, M_{Cost_{u_j}}, S_{Cost_{u_j}} \\in N^+$.\nWe assume that each physical node can host different types of NFs including a) virtual machine (VM) images; b) processing in a container; c) packet I/O drivers and d) hardware appliances."}, {"title": "3.2. MILP formulation of the problem", "content": "In this section, we give MILP formulation of the problem which contains the definition of decision variables, objective functions, and constraints of the problem. Table 1 shows the symbols, variables, and parameters used in our formulation."}, {"title": "3.2.1. Decision variables", "content": "The decision variables are as:\ni) The decision variable$x_{u_j}^{i}$, which takes the value of one if the i-th NF is written on the physical node $u_j$, and the value of zero otherwise:\n$x_{u_j}^{i} \\in \\{0,1\\} \\forall dc \\in Decomp_{sG}, \\forall u_j \\in N_p, \\forall i \\in N_{dc}$.\nii) The decision variable $u_j$ which takes the value of one if the physical node is selected and takes the value of zero otherwise:\n$u_j \\in \\{0,1\\},  \\forall u_j \\in N_p$.\niii) The decision variable $z^{dc}$, which takes the value of one if the de decomposition is chosen, and zero otherwise.\n$z^{dc} \\in \\{0,1\\}, \\forall dc \\in Decomp_{sG}$."}, {"title": "3.2.2. Objective functions", "content": "According to the decision variables, the objective functions for a unique SG can be formulated as follows:\nMinimize:\n$f_1 = \\sum_{u_j\\in N_p(VM)} \\sum_{i\\in N_{dc}(VM)} cost(i, u_j)$\n$+ \\sum_{u_j\\in N_p(PRC)} \\sum_{i\\in N_{dc}(PRC)} cost(i, u_j)$\n$+ \\sum_{u_j\\in N_p(I/O)} \\sum_{i\\in N_{dc}(1/0)} cost(i, u_j)$\n$+ \\sum_{u_j\\in N_p(HW)} \\sum_{i\\in N_{dc}(HW)} cost(i, u_j),$\n(1)\nMinimize:\n$f_2 = \\sum_{u_j \\in N} \\sum_{u_m \\in N} \\sum_{i \\in N_{dc}(type)} L(j, m)x_{u_j}^{i} x_{u_m}^{i+1},$\n(2)\nwhere\n$cost(i, u_j) = (c_i x C_{Cost_{u_j}} + M_i x M_{Cost_{u_j}} + S_i x S_{Cost_{u_j}}) \\times x_{u_j}^{i}$.\nIn the objective function $f_1$, the total costs of using processing resources, RAM, and storage memory are calculated by the decomposition NFs selected from SG, and the best decomposition with the lowest cost is selected and mapped, and in the objective function $f_2$, the delay between used physical nodes by SG is minimized."}, {"title": "3.2.3. Constraints", "content": "In order to guarantee that the physical nodes have the capacity to accept NF, we consider some restrictions.\ni) Constraints of physical nodes\nFor each physical node, the sum of requirements of all mapped NFs should not exceed the capacity of the node. Therefore, we must consider a constraint for each of the processing, memory, and storage capacities.\n$\\sum_{i\\in N_{dc}(type)} C_i x_{u_j}^{i} \\leq C_{u_j},$\n(3)\n$\\forall dc \\in Decompsg, \\forall i \\in N_{dc}(type):  \\forall type \\in \\{VM, PRC,I/O,HW\\}, \\forall u_j \\in N_p,$\n$\\sum_{i\\in N_{dc}(type)} m_i x_{u_j}^{i} \\leq M_{u_j},$\n(4)\n$\\forall dc \\in Decompsg, \\forall i \\in N_{dc}(type):  \\forall type \\in \\{VM, PRC,I/O,HW\\}, \\forall u_j \\in N_p,$\n$\\sum_{i\\in N_{dc}(type)} S_i x_{u_j}^{i} \\leq S_{u_j},$\n(5)\n$\\forall dc \\in Decompsg, \\forall i \\in N_{dc}(type): \\forall type \\in \\{VM, PRC,I/O, HW\\}, \\forall u_j \\in N_p,$\nii) Decomposition constraint\n$\\sum_{u_j \\in N_p(type)} x_{u_j}^{i} = z^{dc},$\n(6)\nwhere\n$\\forall dc \\in Decompsg, \\forall i \\in N_{dc}(type): \\forall type \\in \\{VM,PRC,I/O,HW\\}\nThis constraint ensures that all selected decomposition NFs are mapped only once.\niii) Constraint of delay between physical nodes\n$\\sum_{u_j\\in H} \\sum_{u_m \\in H} \\sum_{i \\in N_{dc}(type)} l(j, m)x_{u_j}^{i} x_{u_m}^{i+1} \\leq L_{target}$\n(7)"}, {"title": "4. The Proposed algorithm", "content": "In this section we introduce our multiobjective algorithm for simultanous decomposition selection and VNFs mapping based on well-known NSGAII algorithm.\nOur algorithm solves both the NF decomposition and VNF placement problems simultaneously. The steps of the algorithm are described in detail below."}, {"title": "4.1. Gene, chromosome", "content": "First, we determine the gene and chromosome structure. The structure of a typical gene is shown in Table 2. Each gene contains an NF identifier and a physical node identifier. In other words, each gene indicates which NF is mapped to which physical node. We denote the total number of NFs in the system by $N_t \\times SG$. Therefore, each chromosome is an array of size $N_t \\times SG$ that contains genes. Each individual chromosome is a feature of a larger structure, the \"solution\" which is depicted in Figure 3."}, {"title": "4.2. Initial and offspring population", "content": "Let $P_t$ and $Q_t$ be the population of parents and offspring, respectively. To build $P_t$, first, according to the decompositions related to an SG, we make a two-dimensional matrix with the number of rows equal to the number of decompositions and the number of columns equal to the maximum number of VNFs in the decompositions. Then, one of the rows of the mentioned matrix is randomly selected, which indicates the corresponding decomposition. According to the selected row, computation resources and RAM memory, and storage memory based on the type of VNF participating in the decomposition, are allocated to that VNF as required requirements. Then, the determined VNFs are mapped on the physical nodes of the network, which will be an acceptable solution to the considered problem.\nNow, by creating N samples of these solutions, the set $P_t$ is built, and the set $Q_t$ is created using crossover and a binary tournament choice strategy.\nFigure 3 shows the structure of $P_t$ and $Q_t$ :\n$P_t = \\{sol_1, sol_2, ..., sol_n\\}$\nand\n$Q_t = \\{offspring_1, offspring_2, ..., offspring_n\\}$"}, {"title": "3.3.3. Sorting the population and calculating the crowding distance", "content": "We use the non-dominated sorting algorithm [31] to rank the input population. After sorting the population, the crowding distance parameter is calculated for each member of the population, and the population in terms of rank and crowded distance is sorted. Figures 4 and 5 show the process of the non-dominated sorting algorithm and calculating the crowding distance."}, {"title": "3.3.4. Crossover, mutation, and fitness", "content": "The binary tournament selection method is used to randomly select parents from the total $P_t$. In this way, two members $sol_1$ and $sol_2$ are selected from the set $P_t$. If the two selected parents have the same decomposition, the crossover will be done on them, otherwise, these two parents will have no offspring. In the crossover process, each parent chromosome is divided into four equal-sized segments. Then, for each segment, a random selection is made between the two parents. In this way, the offspring's chromosomes are obtained by random shuffling of their parent chromosomes. Finally, for each offspring, the function calc_fitness is called to calculate its fitness value. The pseudocode of the calc_fitness function is shown in Algorithm 1. Now, each offspring must be passed as a parameter to the mutation function. The pseudocode of this algorithm is also shown in Algorithm 2. This function takes a solution value and checks for each gene whether the suggested resources in the gene are suitable for VNF mapping. If the allocation is practical, the VNF resource requirement is subtracted from the remaining resources of the designated node. If all the genes of the chromosome show functional assignments, the objective functions $f_1$ and $f_2$ introduced in equations (1) and (2), are calculated. Otherwise, the fitness values are set to infinity. The utility level for the minimization functions $f_1$ and $f_2$ is set to the large number $+\\infty$. This approach prevents impossible solutions from prevailing over other solutions. The routine in which the above-mentioned functions are called is the make_new_pop function, whose pseudocode is included in Algorithm 3. This function receives the main population $P_t$ in round t as input and selects two solutions $sol_1$ and $sol_2$ from the set $P_t$. Then, by calling the crossover function, two children $offspring_1$ and $offspring_2$ are created and the mutation operator is applied to them, and then these two offspring are added to the population of $Q_t$ children. Finally, the $Q_t$ array is returned by the make_new_pop function (Algorithm 3)."}, {"title": "3.3.5. Main Phase of VNF mapping algorithm", "content": "The main phase of the proposed algorithm is to input the initial population $p_0$ and generate the offspring population $Q_0$ . For this end, at first, a random initial population $p_0$ with size N is created and fed to the VNF mapping algorithm. Then, the sorting algorithm fast_non_dominated_sort is called to obtain the Pareto non-dominated leading set $F=\\{F_1, F_2, ...\\}$. In order to generate the generation of offspring $Q_0$ with size N, the operators of binary tournament, crossover, mutation and the NSGA-II algorithm (shown in Algorithm 4) are used. The NSGA-II algorithm first combines the population $p_t$ and $Q_t$ to form a new population $R_t$ of size N. Then, the population $R_t$ is sorted using the sorting algorithm fast_non_dominated_sort. The main point in achieving elitism in NSGA-II is that it should search for solutions that belong to the best non-dominated set $F_1$. If there are fewer than N chromosomes in $F_1$, NSGA-II will definitely select all chromosomes of the set $F_1$ for the new population $P_{t+1}$. The remaining $P_{t+1}$ members are selected from $F_2$ solutions, followed by $F_3$, and so on until the last set is reached. To find the best solutions to fill all gaps in the population, the NSGA-II algorithm uses the sort () subroutine with the $\\n operator. Then, the make_new_pop () subroutine to make the selection, crossing and mutation and creating the next generation $Q_{t+1}$is fed by the population $P_{t+1}$ with size N. Finally, the NSGA-II algorithm is called recursively until the required number of iterations is met. At this stage, the Pareto optimal front contains the desired solutions for the VNF mapping problem."}, {"title": "5. Simulation results", "content": "In this section, we evaluate the effectiveness of the proposed method (MODMVNF) in generating optimal possible solutions for the mapping problem of VNFs on physical nodes. In order to show the efficiency and performance of the our proposed method, we compare it with the particle swarm optimization algorithm. Simulation of the MODMVNF algorithm is run in MATLAB 2015b software and in a 64-bit system with X64-based processor, with Windows 10 Pro version, Intel Core i5-5500 u 2.4 GHz processor, 12 GB memory (RAM), NVIDIA GeForce 820M-2G graphics processor. Also, the graphic memory is 2 GB HDD.\nTo evaluate the performance of the MODMVNF algorithm, first, we consider a small physical network including 10 physical nodes, each of which has 16 TB of secondary memory and 1 GB of internal memory, and runs on a quad-core processor with a total processing capacity of 1000 MIPS and compare the results of our algorithm with integer linear programming (ILP) and PSO. Then, we will expand the number of physical hosts up to 30. As mentioned, at first, the physical structure of the problem is a non-path graph that contains 10 nodes as physical nodes that are connected by links (L). We assume that there is not necessarily a connecting link between each node, but there is at least one path between all nodes. In addition, $C_{Cost_{u_i}} $, $M_{Cost_{u_i}}$, \u0648 $S_{Cost_{u_i}}$ for all 10 physical nodes are the same and equal to 3, 2 and 1, respectively. Also, we assume that each NF can be of a different type:\n$Vie N_{dc}: i \\in \\{VM, process, 1/0, hardware\\}$.\nThe processing rate of each VM randomly from the MIPS set \\{250,500,750,750,1000,1000\\}, the processing rate of each process from the MIPS set \\{250,500,750,750,1000,1000,1000\\}, the processing rate of each I/O from the MIPS set \\{250,500,750,1000\\} and the processing rate of each hardware are selected from the set of MIPS \\{250,250,250,500,500,750,1000\\}. The required memory of each VM from the set of MB \\{128,256,256,512,512,512\\}, the memory of each process from the set of MB \\{128,256,512\\}, the memory of each I/O from the set of \\{128,256,512\\} MB and the memory of each hardware from the set of \\{128,256,512\\} MB, as well as the storage amount of each VM from the set \\{ 256,512,1024,1024\\} MB, the storage amount of each process from the set\\{ 256,256,256,512,512,1024\\}MB, the storage amount of each I/O from the set \\{ 256,512,1024\\} MB and the storage rate of each hardware from the set \\{ 256,512,512,1024,1024,1024\\} MB is selected. The scenario used to calculate the number of physical nodes used and calculate the delay between these nodes as well as calculate the cost of VNFs mapping on the physical infrastructure includes several SFCs with different decompositions. We assume that each SFC has a maximum of 4 different partitions, which consist of a maximum of ten VNFs with different virtualization technologies. The initial population that we consider in our proposed algorithm includes N=60 solutions, whose initial mapping on physical nodes is done randomly. Our goal is to simultaneously map VNFs on physical nodes and minimize the cost of mapping, to obtain the shortest path between the used nodes (delay (latency) between nodes) by Dijkstra's algorithm.\nFigure 6 shows the average mapping cost for the different SFCs. It is worth mentioning that while solving the problem of mapping VNFs and calculating the latency between used nodes, the best type of decomposition of each SG is also determined. In fact, during the execution of the mapping algorithm, the one with the lowest mapping cost is selected. To compare the MODMVNF algorithm with the PSO algorithm and ILP, we consider the results of the MODMVNF and PSO algorithms for each SFC as the average of members of the Pareto front $F_1$ and compare these results with the unique optimal solution of ILP. In these algorithms for each SFC, the average cost obtained from the mapping of VNFs by the members of the Pareto front $F_1$ is calculated and a number is obtained for each SFC in each algorithm. Figure 6 shows that the performance of the MODMVNF algorithm is close to that of the ILP approach, but it has superiority and better performance compared to the PSO algorithm, especially for more VNFs.\nFigure 7 shows the latency among used nodes for algorithms MODMVNF, PSO, and ILP with different SFCs. In MODMVNF and PSO algorithms, for each SFC, the average latency between the physical nodes used by the members of the Pareto front $F_1$ is calculated and a number is obtained for each SFC, which we compare the obtained numbers by the two algorithms for each SFC with the obtained optimal solution by ILP. As seen in Figure 7, the MODMVNF algorithm has a lower time latency than the PSO algorithm and ILP. Therefore, it has a better performance. Figures 8 and 9 are the plots of the cumulative distribution of the MODMVNF, PSO algorithms simulation, and also ILP. These figures show the cumulative distribution of mapping cost VNFs on the used physical nodes and the cumulative distribution of latency between these nodes.\nIt is important to mention that the MODMVNF proposed algorithm simultaneously optimizes two objective functions $f_1$ and $f_2$ in equations 1 and 2, respectively. Probably if only $f_1$ or only $f_2$ is considered as the objective, better results will be obtained for the latency or the cost of mapping VNFs on physical nodes.\nTo illustrate the ability and efficiency of the MODMVNF algorithm for large networks, we perform simulations of the proposed algorithm for a network with 30 physical hosts and 10 SFCs. Figures 10-13 show the obtained results. According to these figures, we can see that the MODMVNF algorithm is efficient in large networks too. Also, the results show the MODMVNF algorithm is better than the PSO algorithm."}, {"title": "6. Conclusion", "content": "In this paper, we have presented a meta-heuristic solution based on NSGA-II to solve the mapping problem of VNFs in order to minimize the delay between the used physical nodes and the mapping cost. We assumed that the incoming requests are in the form of SFCs, each of which has ten VNFs, and each SFC has several decompositions, during the algorithm execution process, the best decomposition is selected so that the cost of mapping and the delay between physical nodes are minimized. The physical structure of the problem was considered as a non-path graph that included N nodes as physical nodes that are connected by links (L). We also assumed that there is not necessarily a link between two physical nodes, but there must be a path between two physical nodes. In addition, we assumed that the edges of the graph have a very large bandwidth capacity and do not impose any constraints on the VNF-P problem. The simulation results showed the efficiency and accuracy of the MODMVNF approach in terms of important criteria such as average delay, cost of mapping VNFs on physical infrastructure, and choosing the best decomposition compared to PSO."}]}