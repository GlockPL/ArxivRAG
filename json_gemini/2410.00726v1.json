{"title": "LTLf Synthesis on First-Order Action Theories", "authors": ["Till Hofmann", "Jens Cla\u00dfen"], "abstract": "Golog is an expressive high-level agent language that includes nondeterministic operators which allow to leave some of the decisions to be made only at execution time. This so-called program realization is typically implemented by means of search, or in an incremental online fashion. In this paper, we consider the more realistic case where parts of the non-determinism are under the control of the environment. Program realization then becomes a synthesis problem, where a successful realization executes the program and satisfies the temporal goal for all possible environment actions. We consider Golog programs in combination with an expressive class of first-order action theories that allow for an unbounded number of objects and non-local effects, together with a temporal goal specified in a first-order extension of LTLf. We solve the synthesis problem by constructing a game arena that captures all possible executions of the program while tracking the satisfaction of the temporal goal and then solving the resulting two-player game. We evaluate the approach in two domains, showing the general feasibility of the approach.", "sections": [{"title": "Introduction", "content": "Golog (Levesque et al. 1997) is a popular agent programming language based on the situation calculus (McCarthy and Hayes 1969; Reiter 2001a), a first-order logic formalism for reasoning about change. It allows for complex agent behavior with nondeterministic branching, iteration, and concurrency (De Giacomo, Lesp\u00e9rance, and Levesque 2000) and hence provides a middle ground between classical planning and pure programming. Golog programs may be interpreted in an offline fashion by means of search, or online (De Giacomo et al. 2009). However, it is typically assumed that the agent is in complete control, even if it only has incomplete knowledge (Reiter 2001b; Cla\u00dfen and Neuss 2016) or its actions are stochastic (Boutilier et al. 2000). Nondeterminism in the program is implicitly assumed to be angelic, i.e., the agent may choose any outcome. Recently, the situation calculus has been extended with nondeterministic actions (De Giacomo and Lesp\u00e9rance 2021; Cla\u00dfen and Delgrande 2021) similar to FOND planning, where instead the environment chooses the outcome. However, this still assumes that agent and environment act in turns. In many scenarios, agent and environment may act concurrently, e.g., in multi-agent systems or in the presence of humans. Hence, we propose an alternative formulation by partitioning the actions into agent and environment actions where agent and environment may act in arbitrary order, similar to supervisory control (Ramadge and Wonham 1989). In this setting, program realization becomes a synthesis task. Given a Golog program and a temporal goal, the goal is to synthesize a policy that executes the program while satisfying the temporal goal, independent of and reacting to all possible environment behaviors. In this paper, we focus on the decidable fragment of Golog with acyclic basic action theories restricted to C\u00b2 (Zarrie\u00df and Cla\u00dfen 2016) and temporal goals given as LTLf formulas, a restriction of Linear Temporal Logic (LTL) to finite traces (De Giacomo and Vardi 2015). We provide a decidable approach for this problem by constructing a finite game arena that captures all possible program executions while tracking the satisfaction of the temporal specification, and then applying a game-theoretic approach to synthesize a policy. Exploiting an encoding of LTLf formulas that interprets temporal formulas as propositional atoms (Li et al. 2020), the construction works on-the-fly and avoids building irrelevant parts. The remainder of this paper is structured as follows. After discussing related work in Section 2, we summarize Golog and introduce LTLf in the context of Golog programs in Section 3. We describe the synthesis approach in Section 4 and evaluate it in Section 5, before concluding in Section 6."}, {"title": "Related Work", "content": "Verification of Golog programs has been studied in various contexts. Initially, verification efforts relied on manual proofs (De Giacomo, Ternovska, and Reiter 1997; Liu 2002; Shapiro, Lesp\u00e9rance, and Levesque 2002). Cla\u00dfen and Lakemeyer (2008) describe a (possibly not terminating) system that is capable of automatically verifying properties of non-terminating Golog programs. Subsequent research identified decidable fragments of Golog based on C2, the decidable two-variable fragment of first-order logic with counting (Gr\u00e4del, Otto, and Rosen 1997). Verification of Golog programs with context-free or local-effect basic action theories (BATs) in C\u00b2 and with pick operators restricted to finite domains is decidable for properties in CTL (Cla\u00dfen et al. 2014), LTL (Zarrie\u00df and Cla\u00dfen 2014a), and CTL* (Zarrie\u00df and Cla\u00dfen 2014b). Beyond local-effect BATs, verification remains decidable if the BAT is acyclic, i.e., there is no cyclic dependency between fluents in the effect descriptors, or flat, i.e., effect descriptors are quantifier-free (Zarrie\u00df and Cla\u00dfen 2016). Bounded theories, where the number of objects described by any situation is bounded, also results in decidable verification (De Giacomo, Lesp\u00e9rance, and Patrizi 2016). All these approaches rely on a finite abstraction of the infinite program configuration space, which yields decidability, and hence could be used as basis for our approach. Related to verification is synthesis of temporal properties, which can be described as two-player games between the system and the environment (Abadi, Lamport, and Wolper 1989; Pnueli and Rosner 1989). Given a specification, e.g., in LTL, and a partition of the symbols into controllable and uncontrollable ones, the players alternate selecting a subset of their symbols. LTL has also been used to describe temporally extended goals for planning (Bacchus and Kabanza 1998; De Giacomo and Vardi 2000; Geffner and Bonet 2013), possibly resulting in infinite plans (Patrizi et al. 2011). LTL can also be used to specify conformant planning problems with temporally extended goals (Calvanese, De Giacomo, and Vardi 2002) and synthesis is related to FOND planning (Camacho et al. 2017, 2018; De Giacomo and Rubin 2018) as a nondeterministic effect can be seen as an environment action. Moreover, there has been a particular interest in LTLf (De Giacomo and Vardi 2013), where the synthesis problem can be solved by transforming the LTLf specification into a finite automaton (De Giacomo and Vardi 2015). Like LTL, LTLf synthesis is 2EXPTIME-complete, although LTLf synthesis tools usually perform better. Recently, several methods have been proposed to improve the performance of LTLf synthesis, e.g., based on BDDs (Zhu et al. 2017) and on-the-fly forward search (Xiao et al. 2021; De Giacomo et al. 2022; Favorito 2023)."}, {"title": "Preliminaries", "content": "We describe the logic ES and an ES-based variant of Golog and then introduce LTLf in the context of Golog programs."}, {"title": "The Logic ES", "content": "The logic ES (Lakemeyer and Levesque 2010) is a first-order modal variant of the situation calculus. Following (Zarrie\u00df and Cla\u00dfen 2016), we consider ES formulas restricted to C2.\nSyntax Terms are of sort object or action. We use $x, y,...$ (possibly with decorations) to denote object variables, and $a$ for a variable of sort action. $\\mathcal{N}_o$ is a countably infinite set of object constant symbols, and $\\mathcal{N}_A$ a countably infinite set of action function symbols whose arguments are all of sort object. Let $\\mathcal{N}_O$ denote the set of all ground terms (called standard names) of sort object, and $\\mathcal{N}_a$ those of sort action. Formulas are constructed over equality atoms and fluent predicates with at most two arguments of sort object, using the usual Boolean connectives, quantifiers, counting quantifiers, as well as modalities $\\Box\\phi$ (\u201c$\\phi$ holds after any sequence of actions\u201d), and $[t]\\phi$ (\u201c$\\phi$ holds after executing action $t$\u201d). We call a formula fluent if it does not mention $\\Box$ or $[. ]$. A sentence is a formula without free variables. A C2-fluent formula is a fluent formula without actions and with at most two variables.\nSemantics A trace is a finite sequence of action standard names. When a trace represents a history of already executed actions, it is called a situation. For a trace $z = (\\alpha_1,..., \\alpha_n) \\in \\mathcal{Z}$, we write $|z|$ for the length $n$ of $z$, $z \\cdot a$ for the concatenation $(\\alpha_1,..., \\alpha_n, a)$ of $z$ with an action $a$, $z[i]$ for the ith action $\\alpha_i$, $z[..i]$ for the prefix $(\\alpha_1,..., \\alpha_i)$, and $z[i..]$ for the suffix $(\\alpha_i,..., \\alpha_n)$. Let $\\mathcal{Z} = \\mathcal{N}_A^*$ be the set of all traces, and $\\mathcal{PF}$ the set of all primitive formulas $F(n_1, ..., n_k)$, where $F$ is a $k$-ary fluent with $0 \\leq k \\leq 2$ and the $n_i$ are object standard names. A world $w$ maps primitive formulas and situations to truth values, i.e., $w: \\mathcal{PF} \\times \\mathcal{Z} \\rightarrow \\{0, 1\\}$. The set of all worlds is denoted by $\\mathcal{W}$.\nDefinition 1 (Truth of Formulas). Let $w \\in \\mathcal{W}$ be a world and $a$ an action standard name. We define for every $z \\in \\mathcal{Z}$:\n1. $w, z \\models F(n_1, ..., n_k)$ iff $w[F(n_1, ..., n_k), z] = 1$;\n2. $w, z \\models (n_1 = n_2)$ iff $n_1$ and $n_2$ are identical;\n3. $w, z \\models \\phi_1 \\land \\phi_2$ iff $w, z \\models \\phi_1$ and $w, z \\models \\phi_2$;\n4. $w, z \\models \\neg \\phi$ iff $w, z \\not\\models \\phi$;\n5. $w, z \\models \\exists^{\\leq m} x.\\phi$ iff $| \\{n \\in \\mathcal{N}_x | w, z \\models \\phi \\}| < m$;\n6. $w, z \\models \\forall x. \\phi$ iff $w, z \\models \\phi$ for every $n \\in \\mathcal{N}_x$;\n7. $w, z \\models \\exists^{\\geq m} x.\\phi$ iff $| \\{n \\in \\mathcal{N}_x | w, z \\models \\phi \\}| \\geq m$;\n8. $w, z \\models \\Box \\phi$ iff $w, z \\cdot z' \\models \\phi$ for every $z' \\in \\mathcal{Z}$;\n9. $w, z \\models [a]\\phi$ iff $w, z \\cdot \\alpha \\models \\phi$.\nHere, $\\mathcal{N}_x$ refers to the set of all standard names of the same sort as $x$, and $\\phi[n/x]$ the result of simultaneously replacing all free occurrences of $x$ in $\\phi$ by $n$. We understand $\\lor, \\exists, \\supset, \\equiv, \\top$ and $\\bot$ as the usual abbreviations. For a set of sentences $\\Sigma$ and a sentence $\\alpha$, we write $\\Sigma \\models \\alpha$ (read: $\\Sigma$ entails $\\alpha$) to mean that for every $w$, if $w, (\\rangle \\models \\alpha'$ for every $\\alpha' \\in \\Sigma$, then $w, (\\rangle \\models \\alpha$. Finally, we write $\\models \\alpha$ (read: $\\alpha$ is valid) to mean $\\{\\} \\models \\alpha$. Note that rule 2 above includes a unique names assumption for actions and objects into the semantics."}, {"title": "Basic Action Theories", "content": "To encode a dynamic domain, we employ a basic action theory (BAT) (Reiter 2001a) with additional restrictions (Zarrie\u00df and Cla\u00dfen 2016) for ensuring decidability:\nDefinition 2 (Basic Action Theory). A basic action theory (BAT) $\\mathcal{D} = \\mathcal{D}_o \\cup \\mathcal{D}_{pre} \\cup \\mathcal{D}_{post}$ is a set of axioms, where $\\mathcal{D}_o$ is a finite set of C2-fluent sentences describing the initial state of the world, $\\mathcal{D}_{pre}$ consists of a single sentence of the form $Poss(a) \\equiv \\pi$, where $\\pi$ is a C2-fluent formula with free variable $a$, and $\\mathcal{D}_{post}$ is a finite set of successor state axioms (SSAs), one for each fluent, of the form $[a]F(\\vec{x}) \\equiv \\gamma_F(\\vec{x}) \\land \\neg \\gamma_{\\neg F}$, where the positive effect condition $\\gamma_F$ and the negative effect condition $\\gamma_{\\neg F}$ are disjunctions of formulas of the form $\\exists \\vec{y}. (a = A(\\vec{v}) \\land \\epsilon \\land \\kappa)$ such that\n* the free variables of the formula $\\exists \\vec{y}. (a = A(\\vec{v}) \\land \\epsilon \\land \\kappa)$ are among $\\vec{x}$ and $a$,\n* $A(\\vec{v})$ is an action term and $\\vec{v}$ contains $\\vec{y}$,\n* the effect descriptor $\\epsilon$ is a fluent formula with no terms of sort action and the number of variables in $\\epsilon$ that do not occur in $\\vec{v}$ or occur bound in $\\epsilon$ is less or equal two,\n* the context condition $\\kappa$ is a fluent formula with free variables among $\\vec{y}$, no terms of sort action, and at most two bound variables.\nIntuitively, the effect descriptor is the part of the effect condition that expresses which objects are affected, while the context condition encodes whether the effect takes place.\nAcyclic BATs For a BAT $\\mathcal{D}$, we can construct the fluent dependency graph $\\mathcal{A}_D$, which captures the dependencies between fluents in the effect descriptors. In $\\mathcal{A}_D$, each node is a fluent of $\\mathcal{D}$ and there is a directed edge (F, F') from fluent F to fluent F' if there exists a disjunct $\\exists \\vec{y}.(a = A(\\vec{v}) \\land \\epsilon \\land \\kappa)$ in $\\gamma_F$ or $\\gamma_{\\neg F}$ such that F' occurs in $\\epsilon$. A BAT is acyclic if $\\mathcal{A}_D$ is acyclic. Furthermore, the fluent depth of an acyclic BAT, denoted by $fd(\\mathcal{D})$, is the length of the longest path in $\\mathcal{A}_D$ and the fluent depth of $F$ w.r.t. $\\mathcal{D}$, denoted by $fd_D(F)$, is the length of the longest path in $\\mathcal{A}_D$ starting in F."}, {"title": "Golog Programs", "content": "We consider a set of program expressions that includes ground actions $(a)$, tests for C2-fluent sentences $(\\phi?)$, sequence of subprograms $(\\delta_1; \\delta_2)$, nondeterministic choice $(\\delta_1 | \\delta_2)$, interleaved concurrent execution $(\\delta_1 \\| \\delta_2)$, and non-deterministic iteration $(\\delta^*)$. We write $nil = \\top?$ for the empty program that always succeeds.\nA Golog program $G = (\\mathcal{D}, \\delta)$ consists of a C2-BAT $\\mathcal{D} = \\mathcal{D}_o \\cup \\mathcal{D}_{post}$ and a program expression $\\delta$ where all fluents occurring in $\\mathcal{D}$ and $\\delta$ have a SSA in $\\mathcal{D}_{post}$. For a program $G = (\\mathcal{D}, \\delta)$, we write $\\mathcal{A}_G$ for all action terms occurring in $\\delta$ and we may omit the subscript if $G$ is clear from context. The semantics of Golog programs is based on transitions between configurations, where a configuration $(z, p)$ consists of a sequence of already performed actions $z \\in \\mathcal{Z}$ and the remaining program $p \\in sub(\\delta)$. Given a world $w \\in \\mathcal{W}$, the transition relation $\\rightarrow$ among configurations is defined inductively. As an example, $(z, a) \\rightarrow (z \\cdot a, nil)$ is the transition for a primitive action $a$. The set of final configurations $Fin(w)$ defines the configurations where the program may terminate, e.g., $(z, \\psi?) \\in Fin(w)$ if $w, z \\models \\psi$. We write $||\\delta||$ for the set of traces starting in configuration $(z, \\delta)$ and ending in a final configuration. The full definition can be found in the supplementary material.\nSituation-Determined Programs Following (De Giacomo, Lesp\u00e9rance, and Muise 2012), we say that a program $G = (\\mathcal{D}, \\delta)$ is situation-determined, iff for all $w \\in \\mathcal{W}$ with $w \\models \\mathcal{D}$, all $z, z' \\in \\mathcal{Z}$, and all program expressions $\\delta', \\delta''$:\n$(z, \\delta) \\rightarrow^* (z', \\delta')$ and $(z, \\delta) \\rightarrow^* (z', \\delta'')$ implies $\\delta' = \\delta''$.\nWe assume that all programs are situation-determined."}, {"title": "LTLf", "content": "For temporal properties, we define temporal formulas with the same syntax as LTLf formulas, but replacing propositions with C2-fluent sentences $\\phi$, i.e., $\\Phi ::= \\phi | \\Phi \\land \\Phi | \\mathsf{X} \\Phi | \\Phi \\mathsf{U} \\Phi$. For a temporal formula $\\Phi$, we denote the set of subformulas of $\\Phi$ with $cl(\\Phi)$. For a set of formulas $\\Psi$, we write $\\bigwedge \\Psi$ for $\\bigwedge_{\\phi \\in \\Psi} \\Phi$. As usual, we define $\\mathsf{F}\\Phi = \\top \\mathsf{U} \\Phi$ and $\\mathsf{G}\\Phi = \\neg\\mathsf{F}\\neg\\Phi$, as well as $\\Phi_1 \\lor \\Phi_2 = \\neg(\\neg \\Phi_1 \\land \\neg \\Phi_2)$, $\\mathsf{N}\\Phi = \\neg \\mathsf{X} \\neg \\Phi$, and $\\Phi_1 \\mathsf{R} \\Phi_2 = \\neg(\\neg \\Phi_1 \\mathsf{U} \\neg \\Phi_2)$.\nTNF and XNF As we intend to track the satisfiability of the temporal formula $\\Phi$ over the traces of the program, we adapt Tail Normal Form (TNF) and neXt Normal Form (XNF) from (Li et al. 2020). TNF explicitly marks the end of satisfying traces, while XNF allows us to split the temporal formula into a local part, which can be evaluated at the current state, and a future part, which is evaluated against the remaining trace. First, we say a formula is in Negated Normal Form (NNF) if all negations are in front of only atoms. Each LTLf formula can be transformed into NNF by using the dual operators to push negation inwards. Based on NNF, we define TNF, which marks the last state of satisfying traces:\nDefinition 3. Let $\\Phi$ be an LTLf formula in NNF. Its TNF $tnf(\\Phi)$ is defined as $t(\\Phi) \\land \\mathsf{F} Tail$, where $Tail$ is a new atom to identify the last state of satisfying traces and $t(\\Phi)$ is an LTLf formula defined recursively as follows:\n1. $t(\\Phi) = \\Phi$ if $\\Phi$ is $\\top, \\bot$, or a C2-fluent sentence;\n2. $t(\\mathsf{X}(\\Psi)) = \\neg Tail \\supset \\mathsf{X}(t(\\Psi))$;\n3. $t(\\mathsf{N}(\\Psi)) = Tail \\lor \\mathsf{X}(t(\\Psi))$;\n4. $t(\\Phi_1 \\land \\Phi_2) = t(\\Phi_1) \\land t(\\Phi_2)$;\n5. $t(\\Phi_1 \\lor \\Phi_2) = t(\\Phi_1) \\lor t(\\Phi_2)$;\n6. $t(\\Phi_1 \\mathsf{U} \\Phi_2) = (\\neg Tail \\land t(\\Phi_1)) \\mathsf{U} t(\\Phi_2)$;\n7. $t(\\Phi_1 \\mathsf{R} \\Phi_2) = (Tail \\lor t(\\Phi_1)) \\mathsf{R} t(\\Phi_2)$.\nWhen interpreting a TNF formula over a trace, $Tail$ needs to be treated separately, as it is not a fluent sentence. We define: $w, z, z' \\models Tail$ iff $z' = (\\rangle$. It can be shown that $\\Phi$ and $tnf(\\Phi)$ are equivalent:2\nTheorem 1. Let $\\Phi$ be a temporal formula, w a world, and z and z' traces. Then w, z, z' |= $\\Phi$ iff w, z, z' |= tnf(\u03a6).\nIn the following, each LTLf formula is assumed to be in TNF and we may omit the common part $\\mathsf{F} Tail$. We continue by interpreting temporal formulas as propositional formulas by treating sub-formulas with a temporal operator as outermost connective as if they were propositional atoms. For a temporal formula $\\Phi$, we define the set of propositional atoms $\\mathsf{PA}(\\Phi)$ of $\\Phi$ inductively: (1) $\\mathsf{PA}(\\Phi) = \\{\\}$ if $\\Phi$ is an atom, X, U, or R formula; (2) $\\mathsf{PA}(\\Phi) = \\mathsf{PA}(\\Psi)$ if $\\Phi = \\neg \\Psi$; and (3) $\\mathsf{PA}(\\Phi) = \\mathsf{PA}(\\Phi_1) \\cup \\mathsf{PA}(\\Phi_2)$ if $\\Phi = \\Phi_1 \\land \\Phi_2$ or $\\Phi = \\Phi_1 \\lor \\Phi_2$. For a temporal formula $\\Phi$, let $\\Phi_P$ be $\\Phi$ understood as a propositional formula over $\\mathsf{PA}(\\Phi)$. A propositional assignment $P$ of $\\Phi_P$ is a partial function $P : \\mathsf{PA}(\\Phi) \\rightarrow \\{0, 1\\}$ that assigns truth values to the propositional atoms $\\mathsf{PA}(\\Phi)$. We write $P \\models \\Phi_P$ if $P$ satisfies $\\Phi_P$. A propositional assignment $P$ can also be understood as a"}, {"title": "Approach", "content": "Our goal is to determine an execution of a given Golog program that satisfies the given temporal formula, for all possible environment behaviors. The controller must determine which actions to execute; more specifically, which branch to follow in all nondeterministic choices of the program, while not restricting the environment in its actions. Formally, our goal is to find a successful policy, defined as follows:\nDefinition 5 (Policy). Let $G = (\\mathcal{D}, \\delta)$ be a Golog program and $\\mathcal{A} = \\mathcal{A}_C \\cup \\mathcal{A}_E$ a partition of the actions $\\mathcal{A}$ of $G$ into controllable and environment actions. A policy is a partial mapping $\\pi : \\mathcal{W} \\times \\mathcal{Z} \\times sub(\\delta) \\rightarrow 2^{\\mathcal{A}_C}$ such that: (1) if $w \\models \\mathcal{D}$, then $\\pi$ is defined on $(w, (\\rangle, \\delta)$; (2) if $a \\in \\pi(w, z, \\rho)$, then $(z, \\rho) \\rightarrow (z \\cdot a, \\rho')$ for some $\\rho' \\in sub(\\delta)$; (3) if $a \\in \\pi(w, z, \\rho)$ and $(z, \\rho) \\rightarrow (z \\cdot a, \\rho')$, then $\\pi$ is defined on $(w, z \\cdot a, \\rho')$; (4) if $a \\in \\mathcal{A}_E$ and $(z, \\rho) \\rightarrow (z \\cdot a, \\rho')$ for some $\\rho' \\in sub(\\delta)$, then $a \\in \\pi(w, z, \\rho)$; and (5) if $\\pi(w, z, \\rho) = \\emptyset$, then $(z, \\rho) \\in Fin(w)$.\nIntuitively, a policy chooses a subset $\\pi(w, z, \\rho)$ from all possible actions in the current configuration $(z, \\rho)$ and world w. From this subset, the environment then chooses one action to be executed. The agent's choices are restricted: Every possible environment action must be selected, hence the agent can never limit the environment's choices. A policy induces a set of traces $||\\pi||_w$ in world $w$, where $z = (\\alpha_1,..., \\alpha_n) \\in ||\\pi||_w$ if there are $\\rho_1,..., \\rho_n$ such that (1) $(\\langle\\rangle, \\delta) \\rightarrow (z[..1], \\rho_1) ... \\rightarrow (z, \\rho_n)$; (2) $\\alpha_{i+1} \\in \\pi(w, z[..i], \\rho_i)$; and (3) $\\pi(w, z, \\rho_n) \\subseteq \\mathcal{A}_E$ and $(z, \\rho_n) \\in Fin(w)$. Hence, the environment may choose to terminate the execution if $(z, \\rho)$ is a final configuration and the agent chose no further actions to execute. Note that by definition, a policy is a restriction of the program execution, i.e., $||\\pi||_w \\subseteq ||\\delta||_w$. We call a policy terminating if for every infinite sequence of $\\pi$-compatible configurations $(\\langle\\rangle, \\delta), (z_1, \\rho_1), (z_2, \\rho_2), ...$ and for every $i$, there is a $j > i$ such that $\\pi(w, z_j, \\rho_j) \\subseteq \\mathcal{A}_E$ and $(z_j, \\rho_j) \\in Fin(w)$. Intuitively, a terminating policy ensures that at any point of the execution trace, there is some future final configuration where the policy does not choose any agent actions and hence the environment may terminate. A policy may still result in an infinite trace if the environment continues to select actions indefinitely. However, we exclude those from consideration as we assume that the environment eventually stops. We can now formalize our goal:\nDefinition 6 (Synthesis Problem). Given a Golog program $G = (\\mathcal{D}, \\delta)$ and a temporal formula $\\Phi$, find a policy $\\pi$ for $G$ that satisfies $\\Phi$, i.e., for every world $w$ with $w \\models \\mathcal{D}$ and every $z \\in ||\\pi||_w$, it holds that $w, (\\rangle, z \\models \\Phi$.\nWe note that it is in general undecidable to determine whether a satisfying policy exists. In (Zarrie\u00df and Cla\u00dfen 2014a, 2016) it was shown that the related verification problem (a special case of the synthesis problem) becomes decidable if (1) C\u00b2 is used as base logic, (2) successor state axioms are acyclic, and (3) \u201cpick operators\u201d are disallowed, i.e., all actions in the program are ground. Furthermore, dropping any of these three restrictions while maintaining the other two immediately leads to undecidability: for (1) this is due to the undecidability of FOL, and for (2) and (3) due to the possibility of reducing the halting problem for Turing machines to the verification problem. In the following, applying the same three restrictions, we describe a sound and complete method for determining a terminating policy that satisfies $\\Phi$. We will do so by constructing a finite game arena $\\mathcal{A}$ that captures the possible program executions while tracking the satisfaction of $\\Phi$. Once we have constructed $\\mathcal{A}$, we can use a game-theoretic approach to determine a terminating policy that satisfies $\\Phi$. However, as both the number of worlds satisfying $\\mathcal{D}$ and the number of reachable program configurations is generally infinite, we first need to construct a finite abstraction based on characteristic graphs and types."}, {"title": "Characteristic Graphs", "content": "We use characteristic graphs (Cla\u00dfen and Lakemeyer 2008) as a finite encoding of the reachable program configurations. In such a graph, the nodes correspond to programs $\\rho$, intuitively representing what remains to be executed, while an edge $\\rho \\xrightarrow{a:\\psi} \\rho'$ encodes that a transition is possible from $\\rho$ to $\\rho'$ through action $a$, if formula $\\psi$ holds. In addition, each program $\\rho$ has an associated termination condition $\\phi(\\rho)$, in the form of a fluent formula (the full definition is presented in the supplementary material). Given an input program $\\delta$, its characteristic graph $C_G = (v_o, V, E)$ is now defined inductively so that $v_o = \\delta \\in V$ (initial node), and the nodes V and edges E are the smallest sets obtained by repeatedly adding reachable nodes and edges, respectively. In particular, we will often identify the set V obtained in this fashion with $sub(\\delta)$, the subprograms reachable from $\\delta$. We note:\nLemma 4. For any program $\\delta$, $C_G$ is finite, and for any world $w$, situation $z$, and $\\delta' \\in sub(\\delta)$, it holds that (1) $(z, \\delta') \\in Fin(w)$ iff $w, z \\models \\phi(\\delta')$; and (2) $(z, \\delta') \\rightarrow (z \\cdot a, \\delta'')$ iff $\\delta' \\xrightarrow{a: \\psi} \\delta''$ and $w, z \\models \\psi$.\nCharacteristic graphs therefore exactly capture the program transition semantics. We can hence use them as finite abstractions of the reachable program configurations. Also, using characteristic graphs, there is a (simple to test) sufficient condition for programs being situation-determined:\nLemma 5. If every ground action $a$ occurs at most once among the outgoing edges of every node in $C_G$, then $\\delta$ is situation-determined."}, {"title": "Types", "content": "With characteristic graphs", "a": "F(\\vec{x"}, "equiv (\\gamma_F^{+}) \\lor (F(\\vec{x}) \\land \\neg(\\gamma_{\\neg F}))$ . As each $\\gamma$ is a disjunction of formulas of the form $\\exists \\vec{y}.(a = A(\\vec{v}) \\land \\epsilon \\land \\kappa)$, the resulting positive effect condition $(\\gamma_F^{+})_a$ is equivalent to a disjunction of the form $\\epsilon_1 \\land \\kappa_1 \\lor ... \\lor \\epsilon_n \\land \\kappa_n$, which allows us to write $(\\gamma_F^{+})_a$ as a set of pairs $(\\gamma_F^{+})_a = \\{\\langle \\epsilon_i, \\kappa_i \\rangle\\}_i$. We write $(\\epsilon, \\kappa) \\in (\\gamma_F^{+})_a$ if $(\\epsilon, \\kappa)$ occurs in the disjunction (analogously for $(\\gamma_{\\neg F})_a$). For a fluent F, the set of positive effect descriptors is then defined as $eff^{+}(F) := \\{\\epsilon | (\\epsilon, \\kappa) \\in (\\gamma_F^{+})_a \\text{ for some } a \\in \\mathcal{A}\\}$, and similarly for negative effect descriptors $eff^{-}(F)$. Hence, we can write a set of effects $E$ as a set of pairs $E = \\{\\langle F^{\\pm}, \\epsilon_i \\rangle\\}_i$, where $\\epsilon_i \\in eff^{\\pm}(F)$. We define a variant of regression on such a set of effects:\nDefinition 7 (Regression). Let E be a set of effects and $\\phi$ a C2 fluent formula. The regression of $\\phi$ through E, denoted by $R[E, \\phi"]}