{"title": "X-DFS: Explainable Artificial Intelligence Guided Design-for-Security Solution Space Exploration", "authors": ["Tanzim Mahfuz", "Swarup Bhunia", "Prabuddha Chakraborty"], "abstract": "Design and manufacturing of integrated circuits predominantly use a globally distributed semiconductor supply chain involving diverse entities. The modern semiconductor supply chain has been designed to boost production efficiency, but is filled with major security concerns such as malicious modifications (hardware Trojans), reverse engineering (RE), and cloning. While being deployed, digital systems are also subject to a plethora of threats such as power, timing, and electromagnetic (EM) side channel attacks. Many Design-for-Security (DFS) solutions have been proposed to deal with these vulnerabilities, and such solutions (DFS) relays on strategic modifications (e.g., logic locking, side channel resilient masking, and dummy logic insertion) of the digital designs for ensuring a higher level of security. However, most of these DFS strategies lack robust formalism, are often not human-understandable, and require an extensive amount of human expert effort during their development/use. All of these factors make it difficult to keep up with the ever growing number of microelectronic vulnerabilities. In this work, we propose X-DFS, an explainable Artificial Intelligence (AI) guided DFS solution-space exploration approach that can dramatically cut down the mitigation strategy development/use time while enriching our understanding of the vulnerability by providing human-understandable decision rationale. We implement X-DFS and comprehensively evaluate it for reverse engineering threats (SAIL, SWEEP, and OMLA) and formalize a generalized mechanism for applying X-DFS to defend against other threats such as hardware Trojans, fault attacks, and side channel attacks for seamless future extensions.", "sections": [{"title": "I. INTRODUCTION", "content": "A horizontal and distributed supply chain is at the heart of the booming semiconductor industry (see Fig. 1). Creation of digital hardware such as integrated circuits (IC) typically involves the development of sub-designs (intellectual properties IP) by small entities, the integration of 3rd party sub-designs with the in-house components at the main design house, IC layout creation, fabrication at a foundry, testing at a testing facility, and assembly by the original electronic manufacturer (OEM). This model reduces the time to market for digital systems, allows for specialization, and enables small businesses. All these steps are typically carried out by different entities in different geographical locations. Such a flow can lead to a series of problems, such as: (1) design or sub-design theft, (2) hardware cloning, and (3) malicious hardware modification/tampering. Microelectronic ICs and devices in the field also face diverse threats, such as power side channel attacks and reverse engineering. A variety of Design-for-Security (DFS) strategies such as IC metering [1], [2], watermarking [3], camouflaging [4], [5], split manufacturing [6], [7], logic locking [8], [9], gate parameter optimization [10], variable delay module insertion [11], and dummy logic insertion [12] have been developed to guarantee trust in the supply chain [13] and boost post-deployment IC/device security. However, security solutions often become obsolete with the emergence of novel attacks, while developing appropriate countermeasures requires extensive research effort, time, and expert resources.\nTo expedite the solution search process (against novel vul-nerabilities) and to create a human-understandable knowledge base of the said vulnerability, we propose an automated framework, X-DFS (Explainable - Design For Security). X-DFS uses a heuristics-based search process to determine a large set of DFS candidate instances that might contribute towards the defense against a given vulnerability. These DFS candidates are then used to train an explainable AI model that is capable of: (1) Emitting DFS rules that can be used to efficiently mitigate the vulnerability; (2) Automatically apply these rules towards securing the design. Hence X-DFS not only secures the design, it can also help researchers obtain a deeper understanding of the vulnerability."}, {"title": "II. RELATED WORKS & MOTIVATIONS", "content": "The proposed framework is highly generalized in nature and can be applied to a wide range of vulnerabilities (with minor tweaks), while most state-of-the-art DFS techniques are typically hand-crafted for mitigating a specific vulnerability or a small set of vulnerabilities. X-DFS can modify a design to-wards mitigating a given vulnerability and at the same time can generate human-understandable design transformation rules. Such capabilities do not exist in current state-of-the-art DFS techniques. X-DFS is highly flexible (parameterized) and extremely efficient in terms of computation cost, while most state-of-the-art DFS techniques are static in nature (not highly configurable) and fail to work for larger designs (inefficient).\nWe implement X-DFS as a highly parameterized robust framework and use it to perform a comprehensive effective-ness analysis for large-scale designs. We evaluate the X-DFS framework by testing it in the logic locking domain where X-DFS is used to automatically search for mitigation strategies (human-understandable) against three powerful logic locking attacks (SAIL [14], OMLA [15]), SWEEP [16]. X-DFS was able to learn how to defend against these attack models and at the same time extracted human-understandable rules that can be used by other logic locking frameworks (such as LeGO [17]) or human experts to carry out the locking process.\nIn particular, we make the following research contributions:\n1) Formalize a general framework and the core mecha-nisms for automatic exploration of the design-for-security search space for countering novel attack vector(s).\n2) Design a set of algorithms (for reverse engineering at-tacks) that leverages this knowledge regarding an attack vector(s) to build an X-DFS model that can modify a given target design to be resilient against the attacks.\n3) Define a methodology to extract and understand the defense rules (human understandable) that are learned by the X-DFS models.\n4) Implement the proposed algorithms as a highly parame-terized and scalable tool.\n5) Qualitatively and quantitatively verify the efficacy of the X-DFS framework/tool against different reverse engineer-ing threats (SAIL, SWEEP, and OMLA).\nNext, we provide the additional details about different DFS solutions and understand the motivations behind X-DFS."}, {"title": "A. Design for Security (DFS)", "content": "Design for security techniques are widely used to protect digital designs and ICs from diverse attack vectors such as hardware Trojans, reverse engineering, and side channel threats (see Fig. 2). These techniques typically involve the insertion of security elements in the design (like logic locking key gates) and strategic modification of existing logic. IC Me-tering techniques [1] modifies the original finite state machine towards creating a Boosted Finite State Machine (BFSM) that ensures that the IC is only in the power-up state when an unique ID is provided. Watermarking techniques often insert an watermark in unused configurable logic blocks (CLBs) outputs [3] to provide passive intellectual property theft pro-tection. Techniques such as CamoPerturb [5] attempts to minimally perturb the design logic towards thwarting reverse engineering. Logic Locking (LL) involves inserting a set of additional gates into the design (connected to some key inputs) such that the modified design does not function correctly without the application of the right key values to these gates [18], [19]. This ensures functional security of the design (to stop reverse engineering), but guessing the correct key input is almost trivial by investigating the structure of the gates inserted. For example, the correct key input for an additional XOR gate inserted to lock a wire will always be 0. Hence, a set of structural changes are introduced by synthesizing the design to make key guessing difficult by observing the design structures (see Fig. 3). Karna [10] attempts to mitigate power side channel leakage by: (1) analyzing each N \u00d7 N grid of the design; (2) obtaining the corresponding TVLA-scores; (3) reconfiguring the gates if a vulnerability is detected in the grid. Variable delay module insertion has also been proposed to provide defense against side channel analysis [11]. To prevent the insertion of hardware Trojans in a design, researchers have proposed the insertion of dummy logic in the design [12]."}, {"title": "B. Background on Logic Locking", "content": "Several different types of logic locking techniques have been developed over the years. Combinational logic locking involves the insertion of combinational gates in the design towards corrupting the output if a wrong key value is ap-plied [20], [21], [22], [23], [8]. Sequential locking techniques such as HARPOON [24] obfuscate the state space requiring a user to apply a sequence of correct key inputs towards unlocking the design. Trace logic locking (TLL) [25], Delay-based locking [26], Analog locking [27], and RTL locking techniques [28] have also been developed to address different requirements. The main focus of this work is combinational logic locking, and let us start by looking at its brief history.\n1) First Generation of LL: The first set of techniques focused on inserting only XOR (key = 0) and XNOR (key = 1) gates randomly towards encrypting the digital design [18], [19]. However, this led to suboptimal output corruption and unpredictable security against attacks such as KSA [29] which leveraged several pitfalls in these locking schemes.\n2) Heuristics Driven Locking: The next generation of lock-ing schemes such as SLL [23], XOR/XNOR insertion based on fliprate [19], and logic cone based insertion (CS) [18] were designed to be more robust against vulnerabilities such as KSA [29]. However, these heuristics-driven techniques have been shown to be vulnerable to SAT-based attacks that could extract the key by pruning the key space [30], [31], [32].\n3) Anti-SAT Locking Era: A plethora of logic-locking techniques were developed to defend against attacks like SAT (and later SMT). These techniques either attempted to increase the time it took for SAT to complete each iteration or simply increased the number of iterations that SAT required to perform before it is able to obtain the key. Prominent among these techniques are: Anti-SAT, Strong Anti-SAT, SFLL, and CAS-Lock [33], [34], [35], [36]. However, these techniques"}, {"title": "C. Why should we use XAI for DFS?", "content": "Most DFS methods follow two steps: (1) Determine where in the design modifications are required and (2) Determine the correct nature of these modifications. Assuming that there"}, {"title": "D. Related Works", "content": "Isolated DFS solutions have been developed to mitigate re-verse engineering [23], [19], [18], [43], side channel [10], [11], and hardware Trojan [12] threats but there exists no systematic way to automatically devise defense strategies against novel attack vectors. Due to the rapidly growing microelectronic threat space, it has become extremely difficult for the research community and the industry to keep up with developing defense strategies against these novel attacks. These concerns are not addressed by current state-of-the-art DFS schemes. Moreover, techniques such as LeGO [17] are designed to apply already known defense rules to mitigate threats and are not designed to generate new defense strategies. Our proposed framework, X-DFS promises to address these concerns making it distinct and highly impactful."}, {"title": "III. X-DFS METHODOLOGY", "content": "The overall framework is depicted in Fig. 4. Next, we formally describe how X-DFS can be used to defend against different microelectronic threats and do a deeper dive into the methodology, particularly for reverse engineering threats."}, {"title": "A. A Formal & Generalized approach to X-DFS", "content": "To formalize the X-DFS process, let us assume that:\n1) We have a digital design ($D = \\{V,E\\}$). V = ver-tices/gates and E = hyperedges among elements in V.\n2) There is a set of metrics/attacks ($At = \\{a_1, a_2, ..., a_n \\}$) that can evaluate the vulnerabilities of the design (D).\n3) There are a set of DFS constructs ($C = \\{c_1, c_2, ..., c_k \\}$) that might lead to the design being resilient to the said attacks (At) if inserted or utilized in the right way.\nWith these assumptions, X-DFS first executes a knowledge extraction process by: (1) Randomly selecting $c_i$ from C; (2) Randomly selecting a location (gate \u2208 V or wire \u2208 E) in D to insert $c_i$; (3) Inserting $c_i$ and obtaining a modified design (D'); (4) Validating the effectiveness of such a modification (D') by utilizing At and tracking this information in the knowledge base (K); (5) Fully or partially reverting the design"}, {"title": "B. Understanding the Feature Set", "content": "Training and using an AI/XAI model will require us to first come up with a set of features that can capture diverse properties of a design or a sub-design (locality). For training and using X-DFS, we propose to use local structural features of design regions similar to SAIL [14], [39] and functional features (Static and Transition probabilities) of nearby wires based on methods proposed in [53]. The structural features of a wire captures information about the placement and connectivity of its locality (different types of gates and their interconnections). For a sub-design graph, we encode the connectivity as an adjacency matrix and represent the gate types using a one-hot encoding scheme. The structural feature extraction process is depicted in Fig. 5 and more details can be found in the SAIL article [14]. The gates are named (G1, G2, etc.) based on a breadth first search (BFS) algorithm search-order starting from the originating gate of the wire being considered for locking.\nThe functional features of a given wire are computed using the formulas presented in Table III and Table IV [53]. For a given signal or net in Table III, $P_A$ and $P_B$ are static probabilities (also known as signal probability) which indicate"}, {"title": "C. Automatic Knowledge Extraction", "content": "As seen in Fig. 4, we start with a set of reference digital designs, and a set of DFS constructs. In case of logic locking, these constructs are gates such as XOR, AND, etc. Next, we randomly insert a set of DFS constructs into the design, apply the selected attack vector, and identify which insertions were successfully attacked and which insertions remain secure. If the attack model bypasses/removes an inserted construct, we label this insertion (choice of both DFS construct + region of insertion) as 0, a bad label. If not, we label it 1, a good label. These labels and associated features are stored in the knowledge base. After that, we remove bad insertions, ran-domly add new DFS constructs, and continue the knowledge extraction process until a termination condition is met (based on runtime, iterations, or label ratio). The amount of randomly added new constructs will be equal to the number of removal of bad insertions.\nThe essential consistent notations used in this paper are outlined in Table I. We have thoroughly discussed those notations when necessary. Algo. 1, provides greater details of the knowledge extraction process specifically for logic locking. Algo. 1 receives inputs such as the design (design) itself, possible locking gates (lockDict), number of keys to lock the design (keySize), locality size (loc) and number of iterations (Thit) to terminate the algorithm. In line 1, we parse the"}, {"title": "D. Building the X-DFS Model", "content": "Next, we train an XAI model to capture the DFS experimentation knowledge base. All the Train_Data and Train_Label obtained from each design using Algo. 1 are merged to form Train_Data_Merged and Train_Label_Merged. This dataset is used to fit a wide range of Al models that are either inherently explainable (such as Decision Tree) or can be explained using other techniques such as SHAP (SHapley Additive exPlanations) [58], LIME (Local Interpretable Model-agnostic Explanations) [59], and Anchors [60]. We also experiment with different data preprocessing techniques (e.g., standard scalar, min/max scaling [61]). Although the Decision Tree (DT) and Random Forest (RF) model are by default explainable, we also obtain results with Ensembling (Decision Tree, Random Forest, and Adaboost). When considering the ensemble results, we assign equal importance to each model. Due to the random nature of the development of the dataset, if we encounter any data imbalance, we employ the SMOTE [62] technique to"}, {"title": "E. Extraction of Design Transformation Rules", "content": "We leverage different explainability algorithms towards vi-sualizing the internal learning and decision making process of X-DFS models. Complex models perform best; however, they are not inherently human-understandable. Hence, we utilize the SHAP (SHapley Additive exPlanations) algorithms, specifically the Kernel Explainer (model-agnostic) towards"}, {"title": "F. DFS using the XAI Model", "content": "With a trained X \u2013 DFS_Model, we can also directly use it (and the inherent DFS rules) to transform a target design. This process is described in Algo. 2 specifically for logic locking. Algo. 2 requires the design (D), number of key length (KL), the X-DFS model (Model), possible gates to lock (lockDict), participation of Ada X-DFS (A), participation of unique wires (U), participation of RN X-DFS (RN), threshold to determine the goodness of locking (Thg), locality size (lc), integer value to filter Ada X-DFS (M) as inputs. In line 1, we parse the input design (D) and capture it in our graph data structure as G. In line 2, we pre-compute the functional features of every wire. Then for each wires in G and for each entry in the locking dictionary lockDict, we obtain a real-valued prediction (0 to 1) using X \u2013 DFS_Model (lines 6-19). Next the specific design wire (G.wires[i]), the locking construct (lockDict[j]), and the prediction (P) are appended to options (line 12). To speed up the locking process (and avoid unnecessary computation), we terminate this exhaustive evaluation process only when the A (X-DFS_Ada) flag is set to 'TRUE' (line 13) and at least M \u00d7 KL good locking options are discovered (lines 14-17). Here M is a multiplier integer value provided as input by the user and KL is the target key length for the locking operation. The goodness of a locking option is determined using a threshold (Thg) imposed on the prediction values. Based on the goodness threshold (Thg), the best options are filtered into Good in line 14. If A (X-DFS_Ada) flag is set to 'TRUE' and RN (X-DFS_RN) is 'FALSE', we use prediction value in descending order to sort the Good candidates in lines 20-21. To allow flexibility and some variability (to divert attackers), we also introduce some"}, {"title": "G. Algorithms Complexity Analysis", "content": "For Algo. 1, let us assume that the termination condition (line 23) is based on a set number of iterations (I), there are V gates in the design, there are E wires in the design, and the time complexity of the attack/metric is O(At) (varies). Then the computational time complexity of line 1 is O(V + E), line 2 is O(V + E), line 7 (for each outer iteration) is O(KeySize), line 8 (for each outer iteration) is O(At), line 9-19 (for each outer iteration) is O(KeySize), line 20 (for each outer iteration) is O(KeySize), and line 21-22 (for each outer iteration) is O(Const). Then the total computational time complexity considering the outer loop, line 23 (I) is:\nO(V+E+V+E+I*KeySize+I*At*Const+I*KeySize+\nI * KeySize + I) = O(V + E + I * KeySize + I * At). Both I and KeySize will be small values and will not necessarily scale across applications. Hence, the complexity can be further simplified to O(V + E + At). For attacks such as SAIL where the computation required is O(KeySize), the time complexity becomes O(V + E) (considering KeySize is small).\nFor Algo. 2, let us also assume that the locking dictionary (lockDict) size is L. Then the computational time complexity of line 1 is O(V + E), line 2 is O(V + E), lines 8-12 (for each iteration) is O(Const) where Const is constant, line 14 (for each iteration) is O(EL), line 21 is O(EL * Log(EL)), lines 23-24 is O(EL * Log(EL) + EL), lines 26-27 is O(EL), line 29 is O(EL * Log(EL)), line 31 is O(EL), line 32 is O(KeySize), and line 33 is O(V + E). The total computational time complexity considering the outer loops (EL) and upon simplification is: $O(E^2L^2)$. L will typically be a small value making the time complexity $O(E^2)$."}, {"title": "IV. RESULTS & ANALYSIS", "content": "In this section, we analyze the effectiveness of the proposed framework (X-DFS) in creating DFS strategies to counter reverse engineering attacks (SAIL [14], [39], OMLA [15], SWEEP [16]). We do not consider the SAT [64] attack for this study because: (1) It can be countered with well-known techniques such as Anti-SAT [34], Full-Lock [37], and LoPher [38]; (2) It does not perform well for large designs and large key sizes due to its reliance on solving an NP-Hard problem in the backend; (3) It requires an oracle or unlocked design making it less practical."}, {"title": "A. Experimental Setup", "content": "We implement the above described algorithms towards creating a highly parameterized framework for extensive eval-uations. Algo. 1 was used to extract training data from a set of small designs from the ISCAS-85 benchmark suit (c1355, c1908, \u04412670, c3540, c5315, c6288, c7552 [54]) to speed up the learning process. However, during the evaluation process, we utilize large scale designs (sqrt, sin, div, arbiter, memc-trl, log2, square, multiplier, voter [54]) following a transfer learning approach to better understand the scalability of the proposed framework. The locking dictionary (lockDict) has the following logic locking gate constructs: XOR, XNOR, OR, AND. We choose SAIL, SWEEP, and OMLA for our evaluation because: (1) They represent the large set of structural analysis-based attacks; (2) These attacks are cutting edge and strongest framework in structural attacks domain; (3) Each of them is highly scalable for large designs; and (4) Other functional attacks such as SAT attack can be mitigated using locking constructs such as Anti-SAT [34], Full-Lock [37], LoPher [38].\nThe SAIL and SWEEP attack models are trained on the following designs: c1355, c1908, c2670, c3540, c5315, c6288, c7552, sqrt, sin, div, arbiter, voter [54].\nOn the contrary, we train the OMLA attack using the designs presented in [55]. We have located 1,000 designs for each of c1355, c1908, c2670, and c3540, totaling 4,000 designs. All designs have been utilized to train OMLA. The total number of gates defines the size of a design.\nkeySize for Algo 1 are always set to 128. Thit for Algo. 1 is set to 80. KL for Algo. 2 has been altered in various ways for different experimental types, and we have specified all those key sizes in the subsequent descriptions. Algo. 1 creates the dataset in just 1.5 hours with this settings. All experiments are run on: Intel Core i9-11900, 8 cores and 16 threads, 32GB RAM."}, {"title": "B. X-DFS for Defending Against SAIL", "content": "As shown in Table V, we experiment utilizing different AI techniques for creating the X-DFS model to counter the SAIL attack. Among them, Adaboost outperforms all. 10% of each design size is the total amount (large quantity) of locking gates that X-DFS uses to lock the designs for this table. For instance, if a design has 30,000 gates, then 3,000 locking gates are inserted (10%). Each value in this Table V indicates SAIL's accuracy. This SAIL accuracy is the appropriate proportion of keys that the SAIL attack model identifies correctly. It appears that the div and the voter designs are inherently more vulnerable to SAIL, probably due to uniform structural patterns (similar to c6288 from ISCAS-85 benchmark suit as demonstrated in the original SAIL work [14]). Table V com-pares the effectiveness of different AI models for mitigating the SAIL attack using the X-DFS framework."}, {"title": "C. Comparison Against Other LL Techniques", "content": "In Table VI, we compare X-DFS with other popular logic locking algorithms, including SFLL_Point [19], [36]. Here, the random locking (column Random) uses the same set of locking dictionary as X-DFS without the added learn-ing/intelligence. X-DFS clearly outperforms all these tech-niques in terms of building up SAIL resiliency. Also note that Anti-SAT fails to lock some of the designs (ran for > 20 hours) probably due to their large size and other algorithm specific constraints (indicated with -, inside the table). For the experiments in Table VI, these big designs are locked using 128 bit keys. This is because some logic locking methods are unable to lock designs with larger keys ( > 128 can not be handled). This is, however, not a limitation for X-DFS, which is highly scalable in this regard."}, {"title": "D. X-DFS for Countering OMLA and SWEEP", "content": "In Table VII and Table VIII we illustrate the effectiveness of X-DFS against OMLA [15] and SWEEP [16] respectively. We utilize the transfer learning approach for these experiments by using the X-DFS model already trained for mitigating SAIL. As seen in Table VII and Table VIII, X-DFS shows great performance in terms of mitigating OMLA and SWEEP even when it is not trained on those specific data. This ability to provide protecting against unknown attacks is one of the most crucial aspects of building a logic locking (or DFS) framework, since new attacks will inevitably arise. X-DFS is quite effective in accomplishing this goal. This demonstrates the practicality and robustness of X-DFS. Results shown in Table VII are provided for 64 bit keys because the publicly available trained model and the dataset for OMLA [55] utilize 64 bit keys. For SWEEP and OMLA, we observed the best performance when utilizing Random Forest (among other machine learning algorithms)."}, {"title": "E. Effectiveness of X-DFS for Different Locality Sizes", "content": "In Table XII we present the X-DFS results for countering SAIL attack while using structural features with locality sizes 5, 7, and 10. X-DFS generally performs better as we increase the locality size. Analyzing a larger locality provides more context for the AI model in terms of determining the optimal locking choices. All the results in this Table XI are obtained using the Adaboost model."}, {"title": "F. Improving the Runtime: Ada X-DFS", "content": "The X-DFS locking algorithm (Algo 2) has a time complex-ity of $O(E^2)$ which is already very scalable (analysis provided above). However, to further speed things up, we introduce an approximation using the adaptive flag (A) as shown in Algo 2. We set A = TRUE, RN = FALSE, and vary M = {3,7,11} (M selects the least number of possibilities, mentioned in Algo. 2) toward obtaining the results in Table IX. For this table, Good (in Algo 2) is measured using Thg \u2265 0.90. Since synchronization with other locking approaches is not required, larger size keys (10% of design size) are utilized to track how long X-DFS takes to produce resilient designs. It shows a clear trade-off between run-time and SAIL resilience in Fig. 6. As M increases, we observe that both the execution time and SAIL resilience improve. This is because higher values of M result in a larger search space, allowing for the identification of better DFS/locking candidates. The General Settings column of Table IX showcases the results of X-DFS when A = FALSE (non Adaptive)."}, {"title": "G. Ada X-DFS with different thresholds", "content": "Next we examine the behavior of the framework for dif-ferent threshold (Thg) values, with M being held constant at 11. These results are shown in Table XI. When the threshold (Thg) is increased to values above 0.50, we observed that the locking duration increases and the accuracy of the SAIL attack decreases. This is because a higher threshold allows the X-DFS to search for more optimal locking candidates."}, {"title": "H. Introducing Randomness: RN X-DFS", "content": "X-DFS is an informed (through learning) locking technique, but some degree of randomness is necessary for different designing scenarios (for obfuscations or variant generations). Hence, we have allowed for some controlled randomness using the flag RN in Algo 2. We set A = FALSE, RN = TRUE, towards obtaining the results in Table X for multiple instances of X-DFS locking. We also show through a cross-instance averaged cosine similarity metric (Sim column in Table X) in several rounds that the generated designs are indeed locked differently while maintaining a high degree of SAIL resilience (SAIL column in Table X)."}, {"title": "I. Explainability: Which Features are Important for X-DFS?", "content": "The top sub-figures in Fig. 7(a) shows the feature im-portance summary plot for the X-DFS_RF_Model (on 100 random data points). The feature names are mentioned on the Y-Axis ranked in descending order of significance. The position on the X-axis (with respect to the neural point 0.0) determines the amount of positive (right side, towards label 1) or negative (left side, towards label 0) impact. Each dot is a data point which represents a row of data from the original dataset. Each point on the graph is assigned a color that corresponds to the value of the related feature. High values are represented by the color red, while low values are represented by the color blue. LockType refers to a specific type of locking gate. G1 (Gatel), G2 (Gate2), and G3 (Gate3) are the three gates in the structural feature locality (in Fig. 5) and the value next to them indicates their gate type. The naming of these gates are based on their breadth-first-search order as detailed in Section III-B. Static_Prob is referring to static probability (Table III) and Transition_Prob is referring to transition probability (Table IV). We can observe that locking with gate types OR and XNOR is preferred by the model, whereas locking with gate types AND and XOR is avoided. Selecting a wire with higher static probability for locking is preferred. It is also evident that design regions with AND gates are avoided during locking. SHAP [58] utilizes a game-theory-based approach and some of the features do not participate strongly enough (dropped from these plots)."}, {"title": "J. Explainability: Can we Extract Good Locking Rules?", "content": "Using SHAP algorithms, it is also possible to understand the decision process for each sample by observing the waterfall graphs (b,c,d,e,f,g in Fig. 7). The waterfall plot represents the values of the X-axis corresponding to the target variable, which in this case is the probability of good locking. x represents the selected observation, f(x) is the predicted value of the model for input x, and E[f(x)] represents the expected value of the target variable, which is essentially the average of all predictions (in our case, 100 random points). The SHAP value for each feature is indicated by the length of the bar (effect on prediction). For example, in Fig. 7(c) locking type XNOR is pushing the prediction towards 1.\nFrom these plots, we can extract 'rules' that are being im-plicitly used by the X-DFS_Models for locking a given design to counter SAIL, OMLA, and SWEEP attacks. We consider probability values below 0.3 as low, 0.3 to 0.5 as moderate, and beyond 0.5 as high. Rules are shown in Table XIV. These rules (extracted via X-DFS) can also be used to directly lock designs using manual methods or frameworks like LeGO [17]. This knowledge can be used to understand the strengths and weaknesses of a given attack vector and thereby assist researchers/engineers in mitigating similar attacks/variants."}, {"title": "K. Directly Locking with Extracted Rules: LeGO", "content": "The human-understandable rules generated from X-DFS can be directly utilized by the LeGO [17] framework to lock a design. In Table XIII, we show the effectiveness of using the X-DFS rules (Table XIV) directly with the help of the LeGO framework for mitigating SAIL attack."}, {"title": "V. CONCLUSION", "content": "Through this work, we have developed an explainable artificial intelligence guided framework (X-DFS) that can automatically navigate the design-for-security search space for generating a set of mitigation rules for a given novel attack vector. We have explained the inner-workings of X-DFS using detailed algorithms and implemented the framework towards creating a highly parameterized tool (specifically for reverse engineering attacks). Using the implantation, we have demonstrated the effectiveness of the framework for mitigating logic locking attacks such as SAIL, SWEEP, and OMLA in diverse settings. To boost the speed of X-DFS, we introduce X-DFS_Ada which can operate on large designs with up to 60,000 gates within 15 minutes and still ensure attack resiliency. Another variant, X-DFS_RN, was also in-troduced for injecting controlled randomness in the process towards diverting certain type of bias-driven attacks. X-DFS has outperformed most existing popular logic locking DFS algorithms including SFLL_Point. We have also demonstrated how X-DFS can be used to understand the decision process of AI models towards creating human-understandable X-DFS rules for countering target attacks. Future works will focus on exploring the effectiveness of X-DFS against other attack vectors (e.g., hardware Trojans, fault injection, side channel) and developing more sophisticated explainable algorithms."}]}