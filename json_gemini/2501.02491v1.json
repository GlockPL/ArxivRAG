{"title": "Rethinking IDE Customization for Enhanced HAX: A Hyperdimensional Perspective", "authors": ["Roham Koohestani", "Maliheh Izadi"], "abstract": "As Integrated Development Environments (IDEs) increasingly integrate Artificial Intelligence, Software Engineering faces both benefits like productivity gains and challenges like mismatched user preferences. We propose Hyper-Dimensional (HD) vector spaces to model Human-Computer Interaction, focusing on user actions, stylistic preferences, and project context. These contributions aim to inspire further research on applying HD computing in IDE design.", "sections": [{"title": "I. INTRODUCTION", "content": "Advancements in Artificial Intelligence (AI) have transformed Software Engineering (SE), with tools such as Cursor [1] and GitHub Spark [2] redefining development workflows. Despite gains in productivity and satisfaction [3], [4], mismatches between developer preferences and AI-generated code persist [5], [6], leading to increased code churn. Although fine-tuning can address these issues [7], it remains computationally expensive, leaving the customization of developer experiences largely unsolved. Existing research [8] has explored the use of machine learning for automated code formatting, but these methods tend to incur substantial performance overhead.\nAt the same time, an entire field of vector-symbolic AI has been gaining traction, with some methods leveraging it to store vast amounts of project context for model consumption [9]. The field of vector-symbolic AI, and more broadly Hyper-Dimensional Computing (HDC), is not new. Its origins can be traced back to 1995, with Plate's development of holographic reduced representation [10], [11]. Given the attributes of high-dimensional vector spaces, it is easy and efficient to model environments that store a large amount of context in a compact form. As there is a great amount of computational resource dependence for running state-of-the-art machine learning models, HDC can be seen as a less costly alternative for advanced behavior and preference modeling.\nNext, we present the existing computational theory behind Hyper-Dimensional (HD) vector spaces and then explore their potential applications in customizable Human-AI Experience (HAX) designs."}, {"title": "II. HYPERDIMENSIONAL COMPUTING", "content": "The term HDC was first coined by Pentti Kanerva [10] and builds on previous work by various others, such as Plate with Holographic Reduced Representation [11] and Gayler with Vector-Symbolic Architecture [12]. As the underlying theory is mostly the same, we will refer to the concept as HDC. We will specifically look at the Multiply Add Permute (MAP) framework by Gayler [13];"}, {"title": "A. Foundations", "content": "The MAP framework operates on hyper-dimensional vectors using three key operations: multiplication, addition, and permutation. These operations enable the composition, binding, and manipulation of high-dimensional representations.\n1) Variables: In this framework, variables are represented as randomly-sampled, high-dimensional, approximately orthogonal vectors. These vectors have the form v \u2208 {-1,+1}D. Although there are other variants of the framework with real- and integer-valued domains, we look at the bipolar variant. For instance, coding preferences like naming conventions or indentation styles could be defined as:\nNameFormat = V\u2081, Indentation = V\u2082\nThese variables are combined using the binding operation to represent more complex concepts holistically.\n2) Multiplication (Binding): Binding involves combining two vectors to create a third vector that is dissimilar (orthogonal) to both. This ensures that information about the two input vectors is encoded in the resulting vector. Here, binding can be implemented as component-wise multiplication:\nBind(A, B) = A \u25ca B\nwhere A and B are sampled from {-1,+1}D. Note that the binding operator is also its own inverse.\n3) Addition (Bundling): Bundling aggregates multiple vectors into a single vector that represents their collective information. This is typically implemented as a component-wise sum followed by a normalization to remain in the same domain as the original vector:\nBundle(A, B, C) = Normalize(A+B+C)\n4) Permutation (Reordering): Permutation denoted by P rearranges the elements of a vector to encode positional or structural information. For example, cyclically shifting vector components with respect to their position and subsequently bundling them can be used to denote a sequence:\nPermute(A) = P(A)"}, {"title": "5) Similarity Analysis", "content": "For evaluating the similarity of two vectors, the dot product/cosine similarity of the two vectors is calculated."}, {"title": "III. HDC IN IDES", "content": "We now shift focus to applying the theory of HDC to model two main aspects of any software project: user behavior/preferences and project context."}, {"title": "A. Action Sequences - Next Action Prediction", "content": "To model sequences of user actions, we draw inspiration from the work of Mozannar et al. [14], which focuses on modeling the states of developers. Consider an IDE that logs sequences of actions performed by a developer (e.g., opening files, typing code, running tests, etc.). Using HDC, we can represent these actions as high-dimensional vectors.\nEach action (e.g., OpenFile, RunTest) can be represented as a vector sampled from the high-dimensional space. A sequence of n actions is represented by binding and permuting these vectors to encode temporal order (see subsubsection II-A4):\nSequence = Pn-1(Action1) \u25ca Pn-2(Action2)\n...P(ActionN)\nFor example, if a user performs the actions OpenFile, RunTest, and Commit, the sequence can be encoded as:\nSequence = P\u00b2(OpenFile) \u25ca P\u00b9(RunTest)\n\u25ca P\u00ba(Commit)\nFor a sequence of M actions where m > n we can encode a user's behavior UB as\n\nencode((Action\u1d62,...,Action\u1d62\u208a\u2099))\n\ni=0\n\nTo predict the next action after observing a sequence of n actions, we use the properties of HD vector spaces. As the binding operation is distributive over bundling, we can attempt to extract the next action by applying UB \u25ca P(encode(Action1,...,Actionn\u22121)). As all other dissimilar vectors result in negligible noise, the remaining vector PredAcc will be highly similar to the vector of the next action of the user. This action ActionX can therefore be found as\narg max Similarity(PredAcc,ActionX)\nActionX\nThis allows the IDE to predict the next most likely action, enabling the optimization of the user's experience."}, {"title": "B. Stylistic Preferences - Style-Matched Generation", "content": "Developers often have personal stylistic preferences when writing code. HDC can model and enforce these preferences for tasks like code completion [15], [16] or auto-formatting [17]. Using the approach inspired by Kanerva's \"Dollar of Mexico\" analogy [18], we encode stylistic preferences for different languages or individual developers. For instance:\nSTYLE = (NameFormat \u25ca CamelCase)\n(Indentation \u25ca Spaces4)\nMODEL_STYLE = (NameFormat \u25ca SnakeCase)\n(Indentation \u25ca Tabs)\nTo adapt the generated code to the developer's style, a mapping vector is created:\nMAPPING = MODEL_STYLE \u25ca STYLE\nIf a LLM generates code with NameFormat = SnakeCase, the mapping ensures it is translated to CamelCase:\nCamelCase \u25ca SnakeCase \u25ca MAPPING\nThis enables the IDE to generate dynamically style-matched code and maintain consistent project styling."}, {"title": "C. Representing Project Context", "content": "HDC also provides a robust framework for modeling the context of a software project and encompasses aspects such as programming languages, Application Programming Interface (APIs), design patterns, and usage scenarios.\nFor example, the project's context can be encoded as:\nCONTEXT = (LANG \u25ca Python)\n(API \u25ca TensorFlow)\n(Pattern \u25ca Observer)\nThis holistic vector representation allows the IDE to adapt suggestions and auto-completions to the specific context of the project. For instance, when working on a Python project with TensorFlow, the IDE can prioritize TensorFlow-related completions or suggest design patterns suitable for Python. Furthermore, transitions between contexts, such as switching from hobby projects to work-related projects, can be modeled using mappings represented as:\nWORK_CONTEXT * HOBBY_CONTEXT"}, {"title": "IV. FUTURE DIRECTION", "content": "While we have outlined several ways HDC can help model user behaviors to enhance their experience, the challenge lies in applying these methods effectively in real-world scenarios. Future research should explore methods to incorporate these representations more effectively and ensure that they influence the models' generations. There exists research looking at interventions at the decoding stage [19] to improve the coding style adherence of LLMs. Additionally, IDE developers could explore adopting a mapping approach similar to the model-to-user mapping discussed in the previous section. This would allow them to align the style of code generated by the LLM with the user's preferred coding style."}, {"title": "V. CONCLUSION", "content": "In this paper, we look at applying the HDC theory to modeling user behavior and preferences through Hyper-dimensional vectors. We present three use cases in which user actions, stylistic preferences, and project setup can be represented using HDC. We encourage the IDE research and development community to engage in research that attempts to include such representations inside the IDE to improve the experience of users in the IDE through efficient approaches."}]}