{"title": "Graphical Conditions for the Existence, Unicity and Number of Regular Models", "authors": ["Van-Giang Trinh", "Belaid Benhamou", "Sylvain Soliman", "Fran\u00e7ois Fages"], "abstract": "The regular models of a normal logic program are a particular type of partial (i.e. 3-valued) models which correspond to stable partial models with minimal undefinedness. In this paper, we explore graphical conditions on the dependency graph of a finite ground normal logic program to analyze the existence, unicity and number of regular models for the program. We show three main results: 1) a necessary condition for the existence of non-trivial (i.e. non-2-valued) regular models, 2) a sufficient condition for the unicity of regular models, and 3) two upper bounds for the number of regular models based on positive feedback vertex sets. The first two conditions generalize the finite cases of the two existing results obtained by You and Yuan (1994) for normal logic programs with well-founded stratification. The third result is also new to the best of our knowledge. Key to our proofs is a connection that we establish between finite ground normal logic programs and Boolean network theory.", "sections": [{"title": "1 Introduction", "content": "Relating graphical representations of a normal logic program (or just program if not otherwise said) and its model-theoretic semantics is an interesting research direction in theory that also has many useful applications in practice [14, 6, 20]. Historically, the first studies of this direction focused on the existence of a unique stable model in classes of programs with special graphical properties on (positive) dependency graphs, including positive programs [16], acyclic programs [1], and locally stratified programs [16]. In 1991, Fages gave a simple characterization of stable models as well-supported models in [13], and then showed that for tight programs (i.e. without non-well-founded positive justifications), the stable models of the program coincide with the Herbrand models of its Clark's completion [14]. Being finer-represented but more computationally expensive than dependency graphs, several other graphical representations (e.g., cycle and extended dependency graphs, rule graphs, block graphs) were introduced and several improved results were obtained [6, 7, 9, 20]. There are some recent studies on dependency graphs [15, 28], but they still focus only on stable models. In contrast, very few studies were made about regular models despite of their prominent importance in argumentation frameworks [32, 4] and program semantics [18]. The work of [12] showed the unicity of regular and stable models in locally stratified programs. The work of [33] showed two sufficient graphical conditions, one for the coincidence between stable and regular models, and another one for the unicity of regular models. However, these two conditions were only proven in the case of well-founded stratification programs, and the question if they are still valid for any program is still open to date.\nMotivated by the above elements, in this paper, we explore graphical conditions on the dependency graph of a finite ground program to analyze the existence of non-trivial (i.e. not 2-valued) regular models and the unicity and multiplicity of regular models for the program. More specifically, we show three main results: 1) the existence of negative cycles is a necessary condition for the existence of non-trivial regular models, 2) the absence of positive cycles is a sufficient condition for the unicity of regular models, and 3) $3^{|U^+|}$ (resp. $2^{|U^+|}$) is an upper bound (resp. a finer upper bound) for the number of regular models in generic (resp. tight) finite ground programs where U+ is a positive feedback vertex set of the dependency graph. The first two conditions generalize the finite cases of the two existing results obtained by [33] for well-founded stratification normal logic programs. The third result is also new to the best of our knowledge. Key to our proofs is a connection that we establish between finite ground programs and Boolean network theory based on the trap space semantics.\nBoolean Networks (BNs) are a simple and efficient mathematical formalism that has been widely applied to many areas from science to engineering [26]. Originated in the early work of [27], studying relationships between the dynamics of a BN and its influence graph has a rich history of research [22, 24]. To date, this research direction is still growing with many prominent and deep results [24, 26, 25]. Hence, the established connection can bring a plenty of existing results in BNs to studying finite ground programs as well as provide a unified framework for exploring and proving more new theoretical results in the logic program theory.\nThe rest of this paper is organized as follows. In the next section, we recall preliminaries on normal logic programs, regular models, BNs, and related concepts. Section 3 presents the connection that we establish between finite ground programs and BNs. In Section 4, we present the main results on relationships between regular models and graphical conditions. Finally, Section 5 concludes the paper with some perspectives for future work."}, {"title": "2 Preliminaries", "content": "We assume that the reader is familiar with the logic program theory and the stable model semantics [16]. Unless specifically stated, a program means a normal logic program. In addition, we consider the"}, {"title": "2.1 Normal logic programs", "content": "We consider a first-order language built over an infinite alphabet of variables, and finite alphabets of constant, function and predicates symbol. The set of first-order terms is the least set containing variables, constants and closed by application of function symbols. An atom is a formula of the form $p(t_1,...,t_k)$ where p is a predicate symbol and $t_i$ are terms. A normal logic program P is a finite set of rules of the form\n$P \\leftarrow P_1,..., P_m, \\sim P_{m+1},...,\\sim P_k$\nwhere p and $p_i$ are atoms, $k \\ge m \\ge 0$, and $\\sim$ is a symbol for negation. A fact is a rule with k = 0. We denote by $atom(P)$ the set of atoms appearing in P. For any rule r of the above form, h(r) = p is the head of r, $b^+(r) = \\{P_1,...,P_m\\}$ is called the positive body of r, $b^-(r) = \\{P_{m+1},..., P_k\\}$ is called the negative body of r, and $bf(r) = p_1 \\land...\\land p_m \\land \\sim p_{m+1} \\land...\\sim p_k$ is the body formula of r. If $b^-(r) = \\emptyset,\\forall r \\in P$, then P is called a positive program. If $b^+(r) = \\emptyset,\\forall r \\in P$, then P is called a quasi-interpretation program.\nA term, an atom or a program is ground if it contains no variable. The Herbrand base is the set of ground atoms formed over the alphabet of the program. It is finite in absence of function symbol, which is the case of Datalog programs [5]. The ground instantiation of a program P is the set of the ground instances of all rules in P. In the rest of the paper, we restrict ourselves to finite ground normal logic programs.\nWe shall use the fixpoint semantics of normal logic programs [11] to prove many new results in the next sections. To be self-contained, we briefly recall the definition of the least fixpoint of a normal logic program P as follows. Let r be the rule $p \\leftarrow \\sim P_1,...,\\sim P_k,q_1,..., q_j$ and let $r_i$ be rules $q_i \\leftarrow \\sim q_1^i,...,\\sim q_{l_i}^i$ where $1 \\le i \\le j$ and $l_i \\ge 0$. Then $\\sigma_r(\\{r_1,...,r_j\\})$ is the following rule\n$p \\leftarrow \\sim P_1,...,\\sim P_k,\\sim q_1^1,...,\\sim q_{l_1}^1,...,\\sim q_1^j,...,\\sim q_{l_j}^j$.\n$\\sigma_P$ is the transformation on quasi-interpretation programs: $\\sigma_P(Q) = \\{\\sigma_r(\\{r_1,...,r_j\\}) | r \\in P, r_i \\in Q, 1 < i < j \\}$. Let $lfp_i = \\sigma_P^i(\\emptyset) = \\sigma_P(\\sigma_P(... \\sigma_P(\\emptyset)))$, then $lfp(P) = \\bigcup_{i\\ge 1} lfp_i$ is the least fixpoint of P. In the case of finite ground programs, $lfp(P)$ is finite and also a quasi-interpretation finite ground program [11]."}, {"title": "2.1.1 Stable and supported partial models", "content": "A 3-valued interpretation I of a finite ground program P is a total function I: atom(P) $\\rightarrow$ {t,f,u} that assigns one of the truth values true (t), false (f) or unknown (u), to each atom of P. If I(a) $\\neq$ u,$\\forall a \\in$ atom(P), then I is an Herbrand (2-valued) interpretation of P. Usually, a 2-valued interpretation is written as the set of atoms that are true in this interpretation. A 3-valued interpretation I characterizes the set of 2-valued interpretations denoted by $\\gamma(I)$ as $\\gamma(I) = \\{J | J \\in 2^{atom(P)},\\forall a \\in atom(P), I(a) \\neq u \\Rightarrow J(a) = I(a)\\}$. For example, if I = {p = t,q = f, r = u}, then $\\gamma(I) = \\{\\{p\\},\\{p,r\\}\\}$.\nWe consider two orders on 3-valued interpretations. The truth order $\\le_t$ is given by f $<_t$ u $<_t$ t. Then, $I_1 \\le_t I_2$ iff $I_1(a) \\le_t I_2(a),\\forall a \\in atom(P)$. The subset order $\\le_s$ is given by f $<_s$ u and t $<_s$ u. Then, $I_1 \\le_s I_2$ iff $I_1(a) \\le_s I_2(a),\\forall a \\in atom(P)$. In addition, $I_1 \\le_s I_2$ iff $\\gamma(I_1) \\subseteq \\gamma(I_2)$, i.e., $\\le_s$ is identical to the subset partial order."}, {"title": "2.1.2 Dependency and transition graphs", "content": "The Dependency Graph (DG) of a finite ground program P (denoted by dg(P)) is a signed directed graph (V,E) on the set of signs {\u2295} where V = atom(P) and $(uv, \\oplus) \\in E$ (resp. $(uv,\\ominus) \\in E$) iff there is a rule r $\\in$ P such that v = h(r) and u $\\in b^+(r)$ (resp. u $\\in b^-(r)$). An arc (uv, $\\oplus$) is positive, whereas an arc (uv, $\\ominus$) is negative. Since atom(P) is finite, the DG of P is a finite graph, thus we can apply the finite graph theory. A cycle of dg(P) is positive (resp. negative) if it contains an even (resp. odd) number of negative arcs. A positive (resp. negative) feedback vertex set is a set of vertices that intersect all positive (resp. negative) cycles of dg(P). The positive DG of P (denoted by $dg^+(P)$) is a sub-graph of dg(P) that has the same set of vertices but contains only positive arcs. P is locally stratified if every cycle of dg(P) contains no negative arc [16]. P is tight if $dg^+(P)$ has no cycle [14]. P is well-founded stratification if there is a topological order on the set of Strongly Connected Components (SCCs) of dg(P) and for every SCC B, there exists SCCA $\\le$ B and for any SCCC, if C $\\le$ A then there are only positive arcs from atoms in C to atoms in A [33]. Herein, A $\\le$ B iff there is a path from some atom in A to some atom in B. In the case of finite ground programs, the above definition of well-founded stratification (which was orginally defined for both finite and infinite ground programs) is equivalent to that a finite ground"}, {"title": "2.1.3 Stable and supported trap spaces", "content": "In [31], we introduce a new semantics for finite ground programs, called the trap space semantics. This semantics shall be used in this work as the bridge between finite ground programs and Boolean networks. To be self-contained, we briefly recall the definition and essential properties of this semantics.\nA set S of 2-valued interpretations of a finite ground program P is called a stable trap set (resp. supported trap set) of P if $\\{F_P(I) | I \\in S\\} \\subseteq S$ (resp. $\\{T_P(I) | I \\in S\\} \\subseteq S$). A 3-valued interpretation I of a finite ground program P is called a stable trap space (resp. supported trap space) of P if $\\gamma(I)$ is a stable (resp. supported) trap set of P. By definition, a stable (resp. supported) trap set of P is a trap domain of $tgs_t(P)$ (resp. $tgs_p(P)$). Hence, we can deduce that a 3-valued interpretation I is a stable (resp. supported) trap space of P if $\\gamma(I)$ is a trap domain of $tgs_t(P)$ (resp. $tgs_p(P)$). We also show in [31] that I is a supported trap space of P iff I is 3-valued model of of (P) w.r.t. to the orders $\\subseteq$ where cf (P) is the \u2190 part of the Clark's completion of P, and a stable (resp. supported) partial model of P is also a stable (resp. supported) trap space of P."}, {"title": "2.2 Boolean networks", "content": "A Boolean Network (BN) f is a finite set of Boolean functions on a finite set of Boolean variables denoted by varf. Each variable v is associated with a Boolean function $f_v: B^{|var_f|} \\rightarrow B$. f, is called constant if it is always either 0 or 1 regardless of its arguments. A state s of f is a mapping s: varf $\\rightarrow$ B that assigns either 0 (inactive) or 1 (active) to each variable. We can write $s_v$ instead of s(v) for short.\nLet x be a state of f. We use x[v $\\leftarrow$ a] to denote the state y so that $y_v = a$ and $y_u = x_u,\\forall u \\in var_f, u\\neq v$ where a $\\in$ B. The Influence Graph (IG) of f (denoted by ig(f)) is a signed directed graph (V,E) on the set of signs {\u2295} where V = varf, $(uv, \\oplus) \\in E$ (i.e., u positively affects the value of $f_v$) iff there is a state x such that $f_v(x[u \\leftarrow 0]) < f_v(x[u \\leftarrow 1])$, and $(uv,\\ominus) \\in E$ (i.e., u negatively affects the value of $f_v$) iff there is a state x such that $f_v(x[u \\leftarrow 0]) > f_v(x[u \\leftarrow 1])$.\nAt each time step t, variable v can update its state to $s'(v) = f_v(s)$, where s (resp. s') is the state of f at time t (resp. t +1). An update scheme of a BN refers to how variables update their states over (discrete) time [26]. Various update schemes exist, but the primary types are synchronous, where all variables update simultaneously, and fully asynchronous, where a single variable is non-deterministically chosen for updating. By adhering to the update scheme, the BN transitions from one state to another, which may or may not be the same. This transition is referred to as the state transition. Then the dynamics of the BN is captured by a directed graph referred to as the State Transition Graph (STG). We use sstg(f) (resp. astg(f)) to denote the synchronous (resp. asynchronous) STG of f.\nA non-empty set of states is a trap set if it has no out-going arcs on the STG of f. An attractor is a subset-minimal trap set. An attractor of size 1 (resp. at least 2) is called a fixed point (resp. cyclic attractor). A sub-space m of a BN is a mapping m: varf $\\rightarrow BU\\{\\*\\}$. A sub-space m is equivalent to the set of all states s such that s(v) = m(v),$\\forall v \\in var_f, m(v) \\neq \\*$. With abuse of notation, we use m and its equivalent set of states interchangeably. For example, m = $\\{v_1 = \\*, v_2 = 1, v_3 = 1\\} = \\{011,111\\}$ (for simplicity, we write states as a sequence of values). If a sub-space is also a trap set, it is a trap space. Unlike trap sets and attractors, trap spaces of a BN are independent of the update scheme [19]. Then a trap space m is minimal iff there is no other trap space m' such that $m' \\subset m$. It is easy to derive that a minimal trap space contains at least one attractor of the BN regardless of the update scheme."}, {"title": "3 Finite ground normal logic programs and Boolean networks", "content": "We define a BN encoding for finite ground programs in Definition 2. Then, we show two relationships between a finite ground program and its encoded BN (see Theorems 1 and 3).\nDefinition 2. Let P be a finite ground program. We define a BN f encoding P as follows: var f = atom(P), $f_v=\\bigvee_{r\\in P, v=h(r)} bf(r), \\forall v \\in var_f$. Conventionally, if there is no rule r $\\in$ P such that h(r) = v, then $f_v = 0$. By considering 1 (resp. 0) as t (resp. f), and \u2217 as u, sub-spaces (resp. states) of f are identical to 3-valued (resp. 2-valued) interpretations of P.\nTheorem 1. Let P be a finite ground program and f be its encoded BN. Then ig(f) $\\subseteq$ dg(P)."}, {"title": "4 Graphical analysis results", "content": "In this section, we present our new results on graphical conditions for several properties of regular models in finite ground normal logic programs by exploiting the connection established in Section 3."}, {"title": "4.1 Preparations", "content": "For convenience, we first recall several existing results in both logic programs and Boolean networks that shall be used later."}, {"title": "4.2 Unicity of regular and stable models", "content": "To illustrate better applications of the connection between finite ground programs and Boolean networks, we start with providing a probably simpler proof for the finite case of a well-known result on the unicity of regular and stable models in locally stratified programs [12]."}, {"title": "4.3 Existence of non-trivial regular models", "content": "Theorem 13 provides a sufficient (resp. necessary) condition on the dependency graph for the non-existence (resp. existence) of non-trivial regular models, but it is only limited to well-founded stratification normal logic programs. Note that the well-founded stratification of a normal logic program is defined based on the ground instantiation of this program [33], and the set of all possible well-founded stratification programs in the finite case is only a small piece of the set of all possible finite ground programs [33]. To the best of our knowledge, the question if it is valid for any finite ground program is still open to date. We answer this question in Theorem 14."}, {"title": "4.4 Unicity of regular models", "content": "The work of [33] shows a sufficient condition for the unicity of regular models for well-founded stratification normal logic programs."}, {"title": "4.5 Upper bound for number of regular models", "content": "To the best of our knowledge, there is no existing work connecting between regular models of a finite ground program and (positive/negative) feedback vertex sets of its dependency graph. In [28], we have shown that $2^{|U^+|}$ is an upper bound for the number of stable models where $U^+$ is a positive feedback vertex set of the dependency graph. Since stable models are 2-valued regular models, we can naturally generalize this result for the case of regular models, i.e., $3^{|U^+|}$ is an upper bound for the number of regular models. The underlying intuition for the base of three is that in a regular model, the value of an atom can be t, f, or u."}, {"title": "5 Conclusion and perspectives", "content": "In this paper, we have shown three main results relating some graphical properties of a finite ground normal logic program to the set of its regular models, namely 1) the presence of negative cycles as a necessary condition for the existence of non-trivial regular models, 2) the absence of positive cycles as a sufficient condition for the unicity of regular models, and 3) two upper bounds on the number of regular models for, respectively generic and tight, finite ground normal logic programs based on the size of positive feedback vertex sets in their dependency graph. The first two conditions generalize the finite cases of the two existing results obtained by [33] for well-founded stratification normal logic programs. Our proofs use an encoding of finite ground normal logic programs by Boolean networks, the equivalence established between regular models and minimal trap spaces, and some recent results obtained in Boolean network theory.\nWe believe that the established connection can provide more results for the study of Datalog programs and abstract argumentation, and might also be worth considering for normal logic programs without finiteness assumption on their ground intantiation. The results presented in this paper use conditions on either positive cycles or negative cycles. It is thus natural to think that by using both kinds of cycles simultaneously, improved results might be obtained. Finally, we also conjecture that the upper bound for tight finite ground normal logic programs presented here, is in fact valid for generic ones."}]}