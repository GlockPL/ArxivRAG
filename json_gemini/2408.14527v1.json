{"title": "Multi-Agent Path Finding with Real Robot Dynamics and Interdependent Tasks for Automated Warehouses", "authors": ["Vassilissa Lehoux-Lebacque", "Tomi Silander", "Christelle Loiodice", "Seungjoon Lee", "Albert Wang", "Sofia Michel"], "abstract": "Multi-Agent Path Finding (MAPF) is an important optimization problem underlying the deployment of robots in automated warehouses and factories. Despite the large body of work on this topic, most approaches make heavy simplifications, both on the environment and the agents, which make the resulting algorithms impractical for real-life scenarios. In this paper, we consider a realistic problem of online order delivery in a warehouse, where a fleet of robots bring the products belonging to each order from shelves to workstations. This creates a stream of inter-dependent pickup and delivery tasks and the associated MAPF problem consists of computing realistic collision-free robot trajectories fulfilling these tasks. To solve this MAPF problem, we propose an extension of the standard Prioritized Planning algorithm to deal with the inter-dependent tasks (Interleaved Prioritized Planning) and a novel Via-Point Star (VP*) algorithm to compute an optimal dynamics-compliant robot trajectory to visit a sequence of goal locations while avoiding moving obstacles. We prove the completeness of our approach and evaluate it in simulation as well as in a real warehouse.", "sections": [{"title": "1. Introduction", "content": "Multi-Agent Path Finding (MAPF) [22] is the problem of planning a set of collision-free paths for a team of agents to reach one, or a sequence of goal locations, with minimal travel time. With the impressive progress of AI and robotics research over the last decade, an increasing number of real-world applications are based on multi-agent systems and require solving some MAPF problem. Examples include automated warehouses [15, 24], video games [14], UAV traffic management [10] and autonomous vehicles [5, 16]. While there exists quite extensive literature on MAPF, most works consider a simplified setting where the environment is modeled as a 4-neighbor grid where each agent occupies one cell at a time, and at each discrete time step, can either move to a neighboring cell or wait in place [22]. Even in this simplified setting, MAPF is already NP-hard [25].\nWe target a warehouse scenario in which large robots move heavy objects in a spatially constrained workspace. Additionally, we consider that orders are received throughout the day and each order consists of mul- tiple products that robots need to pick up at specific shelves and deliver to a workstation. Each workstation can process only one order at a time. This creates a stream of inter-dependent pickup and delivery tasks. Such a scenario, and its corresponding lifelong MAPF variant, features several characteristics which are not typically taken into account in previous works. Due to the weight of the robots, accelerating (or decelerating) to full (or zero) linear and angular speed may take many seconds (and meters). Since transported objects are heavy, the speed and acceleration depend on the load of the robot. When path-finding is planned on a graph, a heavy robot cannot necessarily stop from a full speed to the closest node. Furthermore, a large robot also often occupies multiple graph nodes and edges. Large robots have seldom space to bypass each other or even turn in place in narrow aisles. If the robot can pick up and drop off objects only from one side, the plan should anticipate the turns so that the robots enter the aisles with the right orientation for pickups/drop-offs. This more realistic setting renders the majority of methods devised for grid-based environments ill-suited for our scenario. Simplified assumptions on robot dynamics also yield trajectories that can quickly lead to collisions when executed by realistic robots (see Section 5.1.1).\nIn this paper, we introduce a MAPF solution taking the aforementioned characteristics into account. Our ap- proach is based on the classical Prioritized Planning (PP) algorithm [20], which consists of ordering the agents in a certain priority order, then computing the shortest path for each agent, avoiding the trajectories of the previously planned agents (considered as moving ob- stacles). PP is well-suited to our context as the shortest path computation is done for each robot separately and can in principle accommodate kinematic constraints."}, {"title": "2. Related Works", "content": "MAPF and MAPD for automated warehouses. Our problem is closely related to the lifelong Multi-Agent Pickup and Delivery (MAPD) problem [17], which is generally treated as a sequence of MAPF problems. There is extensive work on MAPF [6,20,21,22] with several works focusing on warehouse applications (e.g. [15,24]). However all the above approaches use many simplifying assumptions mentioned in Section 1.\nMAPF with realistic assumptions. In order to deploy MAPF solvers for real-world scenarios, researchers and practitioners have developed two main strategies. The first one is to adapt existing algorithms to handle specific aspects of the real applications. For example, Zhang et al. [26] extend some MAPF algorithms to explicitly account for turn actions but in the usual grid- world environment with discretized time steps. Ma et al. [18] present an approach for lifelong MAPD that takes into account the robot's translational and rotational speed but assumes infinite acceleration and decelera- tion (i.e., no inertia). Li et al. [13] consider agents of arbitrary shape, but agents still move in unitary time steps from one vertex to another of the graph, hence not accounting for the agents' dynamics. The second strategy is to use so-called execution frameworks which allow to execute a given MAPF solution and update it if necessary. These frameworks are generally agnostic to the underlying MAPF solver. For example, Hoenig et al. [11] and H\u00f6nig et al. [12] propose post-processing the output of a standard MAPF solver in order to make the trajectories satisfy the kinematics constraints. However the produced plans might not be as effective since these constraints were not taken into account by the planning algorithm.\nMAPF in uncertain environments. Even with an ac- curate model of the robots, unexpected time variations in robot actions will happen. To mitigate the effect of this uncertainty, Atzmon et al. [3] propose k-robust MAPF that guarantees the feasibility of the plan even if the agents are delayed by up to k steps. We propose a similar robustness feature by introducing time mar- gins that ensure robustness of the plan to k seconds of earliness or tardiness of the agents. While historically most of the MAPF research is evaluated on simulators with simplistic assumptions, tests with more advanced simulators such as ROS Gazebo are becoming more common [23]. For example, H\u00f6nig et al. [12] conduct a mixed reality tests using iCreate robots. However, un- like in our case, robots' dynamics do not deviate much from the simple assumptions under which the plans are created and the transfer is thus quite successful. In our case, applying these simplifying assumptions quickly lead to collisions (see Section 5.1.1)."}, {"title": "3. Lifelong MAPF with Interdependent Tasks", "content": "In this section, we define more formally our setting and the MAPF problem we want to address.\nAgents. Agents (or robots) in this work refer to differ- ential drive robots that can move forward, backward and turn in place. Robots are also equipped with a mechanism to pick up (or drop off) an object at a shelf or workstation, which can only be executed when robot is at a specific orientation and zero speed. We assume that a dynamics model for the robots is given, so that the trajectory and travel time to go from an initial state (e.g., position and speed) to target state, as well as the times to perform pickups and drop-offs, can be com- puted.\nWarehouse Graph. We represent the workspace of the warehouse as a general directed graph $G_w = (V_w, A_w)$. The vertices (or nodes) are associated with the physical locations where the robot can either stop to pick up and drop off objects (in front of shelves and workstations) or turn (in case there is enough space). The arcs (or edges) represent the segments to be trav- eled between the vertices. Note that we do not make the standard assumption that the graph is a regular grid, therefore not imposing any restriction on the warehouse layout nor the distance between vertices. Such general- ity leads to cases where a robot may occupy multiple vertices and arcs simultaneously. Although this graph is not used directly by our routing algorithm, it represents the input data used to build the more sophisticated rout- ing graph described in Section 4.3.\nOrders and Tasks. We define an order as a set of objects to be picked up at some shelves and delivered to a (single) workstation; or the reverse, several objects at a workstation that need to be delivered at specific shelves. We assume that orders arrive throughout the day. Formally, an order $o \\in O$ with k objects is defined as a tuple ($r^o$, {(p\u2081, d\u2081) . . ., (p\u2096, d\u2096)}) where $r^o$ is the release date, p\u2096 the vertex corresponding to the location of the shelve where the j-th object must be picked up or delivered and d\u2096 the duration of the corresponding pickup or delivery action. A duration for the action (pickup or delivery) performed at the workstation for each object can also be defined, either as workstation or object specific. We define a task as an agent picking up an object at an initial location and delivering it at a target location. The set of tasks that correspond to a given order are said to be interdependent because they share the same workstation as initial or target location and must all be finished before a workstation can be used for another order.\nLifelong MAPF with Interdependent Tasks. Given a set of agents, a warehouse graph and a stream of orders with their associated tasks, the goal is to find a sequence of collision-free trajectories for the agents to execute their tasks, such that only one order is handled at a workstation at a time and the throughput is maximized."}, {"title": "4. Interleaved Prioritized Planning with VP*", "content": "The Lifelong MAPF problem with Interdependent Tasks defined above includes two optimization subproblems: (i) Task Assignment: which agent should execute each task, and which workstation should be used for each task (order)? (ii) MAPF: how should the agents move (in space and time) to execute their tasks?\nFor simplicity we consider these two interdependent subproblems separately. In addition, to deal with the stream of online orders, we solve the subproblems at regular, user-specified, intervals. Similarly to Receding Horizon Control [4], the idea is to compute a plan and start executing it; then plan again, given the current state of the system, including the newly released orders. Hence without loss of generality, in the following, we focus on one planning iteration and assume that the orders are known and the objective is to minimize the makespan, i.e., the maximum completion time of all the known tasks.\nIn this section, we first present our task assignment strategy, and then our MAPF algorithm, Interleaved Prioritized Planning (IPP), that we prove to be com- plete. We then describe the details of the Via-Point Star (VP*) algorithm that we use for routing agents with- out collision, starting by the graph model and collision checking mechanisms that enable us to manage the robots' dynamics."}, {"title": "4.1. Task Assignment Heuristic", "content": "To optimize the task assignment, we solve the under- lying idealized scheduling problem where we assume that the robots always use the shortest paths (i.e., ig- noring potential collisions). We use a rule-based heuris- tic, inspired by the classical priority dispatching rule approaches for scheduling [9]. More precisely, we decompose the system state S into the agents' states $S_{agents} := {(\\tau^a, v^a) : a \\in A}$ where $ \\tau^a$ is the time when agent a will be available and $v^a$ its position (vertex) at $ \\tau^a$; and the workstations' states $S_{ws} := {\\tau^w : w \\in W}$ with time $ \\tau^w$ indicating when the workstation w will be available. At the beginning of the day, agents are at their initial position and availability times are zero. Or- ders are sorted in a First In First Out (FIFO) fashion, by increasing released date. For each order, we first assign the earliest available workstation. Then, for each task of the order (corresponding to a pickup and delivery), we assign the earliest available agent and update its state, based on the product pickup and drop-off times and the ideal travel times. After assigning all the tasks of an order, we update the availability time of the worksta- tion, and switch to the next order. To avoid congestion at the workstations, we can limit the number of agents assigned to one order. From the complete schedule, we extract the assignment of the orders to the workstations and the sequence of tasks assigned to each robot.\nBased on the task assignments, we reinitialize the agent and workstation states, and add to each agent's state its assigned sequence of tasks; and for each worksta- tion, its assigned sequence of orders. For each order (sorted by the FIFO rule), we consider the subset of agents assigned to (the tasks of) this order. The earliest available agent a gets the priority for path planning. Its path should visit the sequence of goal locations of its next task t and, optionally, finish at its waiting loca- tion. To compute its start time, we take into account the availability time of the relevant workstation. The start time and list of goal locations are given to the VP* algorithm (Sec 4.5) which computes a trajectory that avoids collisions with previously planned trajectories. Given the trajectory, we update the availability time of the agent and workstation, and remove t from the tasks of agent a. We update the previously planned trajectories with the complete trajectory information, including the last part of the path (that goes to the waiting location). We repeat until all the tasks of the order are planned and then switch to the next order. The last part of each path is optional in the sense that if a robot can directly depart from the delivery loca- tion of its previous task to the pickup location of its next task then we discard the go-to-waiting-spot part of its path. However, this part can be used and is key to ensure that our algorithm always returns a feasible solution. A detailed pseudo-code for IPP is provided in Algorithm 1.\nWe now state the completeness of the proposed algo- rithm.\nTheorem 1. Assume that each robot has a designated waiting place, where it can be idle without interfering with other robot trajectories. If the robots are at their waiting place at the beginning of the planning, the Interleaved Prioritized Planning algorithm is complete.\nProof. To show that the algorithm is complete, we need to prove that it always returns a feasible solution. There are two constraints to consider: (i) the paths of two robots must not collide and (ii) all the tasks of an order must be finished on its workstation before any new task can start on that workstation. The robots are starting at their waiting place. The planned trajectories con- tain, for each robot, a reservation of its waiting place for the duration of the planning horizon and no other information. Each robot can hence wait for an unlim- ited time at its starting position without blocking the way of the other robots. Consider the first task $o_{1,1}$ of the first order $o_1$ assigned to robot r, that is released at time t. Its assigned workstation w is either avail- able for order $o_1$ or will be available at a given time $ \\tau^w$."}, {"title": "4.2. Interleaved Prioritized Planning Algorithm", "content": "In the standard Prioritized Planning (PP) algorithm [20], agents are given a certain priority order, then in descending priority order, we compute the shortest path for each agent, avoiding the trajectories of the previously planned agents (considered as moving obsta- cles). While PP is well-suited to our context because the shortest path computation is done for each robot sepa- rately and can accommodate the kinematic constraints, it is not adapted to handle the interdependence of tasks.\nFor example, consider a simple scenario where we have 3 robots, 1 workstation and a sequence of 10 orders, each containing 3 products. To process orders as fast as possible, it is natural to divide the tasks (products) of each order between the robots. With PP, after planning the 10 pickups and deliveries of the 1st and 2nd robot, the last planned robot may incur significant delays (due to the numerous moving obstacles). In this case, one cannot guarantee that objects from different orders are not mixed at the workstation. To avoid this issue, we propose an extension of PP, that we call Interleaved Prioritized Planning (IPP), where the priorities are dy- namically assigned throughout the planning process, as follows."}, {"title": "4.3. Routing Multi-Graph", "content": "In many other works, routing is performed directly in the warehouse graph $G_w$ as defined in Section 3. However, as a robot may occupy several nodes in our context, cannot turn everywhere and has more complex dynamics, we design a specific routing graph that can integrate those elements in its structure. To do so, we convert the warehouse graph $G_w$, to a directed routing multi-graph in which each vertex (say node C in the Figure 2) of $G_w$ is represented with several vertices of different types and their associated arcs: (i) a start and a stop node, to start planning from that position or end an itinerary at that position (only shown for node A below); (ii) for each adjacent node in the warehouse graph (like node D), we create two nodes: one for arriving from that node and one for going to that node. They are linked by an additional arc allowing for going backward without changing direction; (iii) where it is possible to turn, we add turning arcs for the robot to reverse its orientation (i.e., a U-turn); (iv) at the nodes (like C) where two nonparallel edges meet, we add two turning arcs per node-triplet (two for B-C-D, and two for D-C-B), one for turning clockwise and one for turning counter-clockwise. One of these arcs also turns the traveling orientation of the robot.\nThe robot needs to stop in order to turn, to avoid sliding, tilting and dropping its potentially heavy load. How- ever, if the robot is going straight, we want to traverse long paths without stopping, possibly passing through several nodes. To this effect we augment the routing graph with additional shortcut edges between nodes that are on a straight line. With shortcuts in place, we can set the initial and final linear and angular velocities at all the nodes to zero. We use the robot's dynamics to associate two travel times with each arc: one for an empty robot and one for a loaded one. The times for each arc traversal can now be precomputed based on accelerating the robot to maximum linear/angular velocity within the edge-specific speed limits and de- celerating back to speed zero. As the speed at each node is zero, and arc travel times are fixed, comput- ing the shortest path without moving obstacles for a single robot is polynomial (as opposed to the general case of shortest path with kinematics [2]). We use this property to rapidly compute the lower bounds on the duration of paths that avoid collisions."}, {"title": "4.4. Collision Checking", "content": "In classical settings, strong hypotheses on the routing graph are taken to avoid robot collision. Robots in ad- jacent nodes cannot collide, and many rules on robot movement ensure that collisions are avoided [22]. In our setting, adjacent nodes can be so close that two robots occupying them would collide, or so far away that two robots traveling the same edge would not col- lide. We hence define a more spatially explicit collision checking method, adapted to this setting and reminis- cent to swept AABB [7].\nThe position $xy \\in R^2$ of each robot and its orientation (yaw) $ \\theta \\in [-\\pi, \\pi]$ is uniquely determined at each time $ \\tau$. In the routing algorithm, the configuration of the robot is defined as a tuple ($t, xy, \\theta, s, s_e, l$), where $s \\in R$ is the linear velocity in direction $ \\theta$, $s_e \\in R$ is the angular velocity, and l = 1 if agent is loaded and l = 0 otherwise. For collision detection, the space occupied by the robot is modeled as a connected two-dimensional set (such as a polygon) centered at its xy-position and rotated by its orientation. Such a set may include additional padding. We check if the spaces occupied by two different robots intersect at any given time $ \\tau$. For a practical implemen- tation, one may, for example, cut continuous time into intervals, and model the space occupied by the robot during an interval as (a convenient superset of) the union of the sets the robot occupies during this interval. Checking if a robot would collide with other robots at time t can then be conservatively approximated by checking if the space occupied by the robot intersects with the spaces of the other robots occupied during the interval containing $ \\tau$. One may also add some time safety margin by reserving some neighboring intervals."}, {"title": "4.5. VP* Algorithm", "content": "To plan the displacements of the robot for a given task, classical shortest path algorithms are inappropriate as we need to compute paths that take into account not only the position of static obstacles (modeled into the graph with non-existing edges) but the position of the other robots, which are moving in the warehouse at the same time as we plan the robot's path.\nVia points. For each task, we must plan several con- secutive displacements of the robot (e.g., going to an aisle to pick up an object, going to the workstation to deliver the object, moving to a waiting area to wait for the next task). We call via points the locations that we have to visit sequentially. If we were to use classical shortest path with collision avoidance sequentially for each pair of consecutive via points, we would have no guarantee of finding a path for all the displacements of the sequence (see Section 5.1.2). Indeed, taking the shortest path for the first pair of the sequence may pre- vent the robot finding any feasible path to the remaining via points.\nLi et al. [15] propose a complete heuristic algorithm for a simpler version of the shortest path with via points problem. This heuristic however does not account for robot dynamics, actual robot load, position and orien- tation in space, and its collision checking is based on vertex and swapping conflicts only. We explain below how to handle these additional constraints and propose an improvement that guides the search faster toward a first feasible solution.\nRobot dynamics in VP*. Even if the arc weights are precomputed, based on the robot's dynamics, we need precise displacement information when checking col- lision for the current robot against already planned robot paths (our moving obstacles), which impacts the speed of the algorithm. From a practical point of view, the space occupied by the robots along their planned paths are computed and stored in a reservation table for later collision checking when other robots compute their paths.\nRobot configuration. In our context, the orientation of the robot is important: in order to pick up or drop off objects at the shelves and workstations, the robot must be in an specific orientation to execute the (pickup or drop-off) action. However, due to space constraints, it may not be possible for the robot to rotate in the aisle, so it must be in the right orientation when entering the aisle. Orientation is hence taken into account in the con- figuration of the robot, and also in the description of the via points and in the routing multi-graph. In addition, the speed of the robot is different when loaded, so the load is also added to the via-point information. Each via point is defined by a node in the graph (and physi- cal position), a partial in-configuration indicating the required orientation (yaw) and the load when arriving at the node, and a partial out-configuration indicating the required orientation and the load when leaving the node, and the time required at the via point to perform the associated action. The via points are the only points where the robot can perform an action.\nShortest path with via points. The objective is to find an earliest arrival path starting from the first via point and then passing by each via point in the order of the sequence, and arriving at the last via point while respecting the constraints imposed by the partial con- figurations of each via point, stopping at each via point for the required time, and avoiding collision with the moving obstacles whose configuration is known at each time instant from the reservation table. Although, in our warehouse, the only moving obstacles are the other robots, the collision checking could be performed simi- larly for any kind of moving obstacle whose occupied spaces have been stored in the reservation table. In our context, travel time must be either continuous or discrete with high precision to avoid cumulative errors over multiple paths computed sequentially during the planning. However, to reduce the computation time, when the robot is waiting at a given point, the waiting time is discretized to the second in our experiments. When waiting at a node is possible, the graph contains an additional arc from the node to itself with a duration equal to the chosen minimum waiting time.\nNotation We denote by G = (V, A) the routing graph (as explained in Section 4.3) where V is the set of nodes and A the set of arcs between those nodes. For a given node v, A(v) denotes the output arcs of v, i.e., the set of arcs {(v, v') \u2208 A\\v' \u2208 V}. The weight $ \\tau(v, v', l)$ of an arc (v, v') is the duration to traverse the arc (v, v') with l = 1 if the robot is loaded and 0 otherwise. The angle $ \\theta(v, v')$ is the rotation angle of the edge, when the edge allows to turn in a given direction, and 0 otherwise. A path is a succession $(v_0, v_1), (v_1, v_2), . . . (v_{i-1}, v_i)$ of arcs of A. The duration of a path p is $ \\sum_{(v,v')\\in p} \\tau(v, v', 1)$. To obtain a lower bound h(v, v', l) for the duration of a path between node v and node v', we precompute the duration of the shortest path under the assumption that there are no moving obstacles (one duration for a loaded robot and one for an unloaded robot), and without any requirement on orientation at node v', us- ing any classical shortest path algorithm, like the one used by Li et al. [15]. As stated before, this shortest path can be obtained in polynomial time based on our routing graph. We denote via points with nodes v with additional attributes so that v.l is the out-configuration load of via point v and v.d is the duration to perform an action at via point v. When passing by k + 1 se- quential via points $ \\bar{v} = (v_0, v_1, . . ., v_k)$, we define the estimate of the duration of the path to reach the last via point as as the sum of the estimates of the subpaths, i.e., $h(v) = \\sum_{0<i<k} (h(v_i, v_{i+1}, v_i.l) + v_i.d)$ (it does not in- clude the time of the action at the last via point). With some modifications to check the required orientation at nodes, configurations at start point and via points can be taken into account to obtain a better estimate. For a partial solution where via points $(v_0, v_1, ..., v_{vp}), vp < k$, have already been passed sequentially, we can then estimate the path duration from its last node v in configuration c to via point $v_k$ similarly. This duration is denoted $\\hat{h}(v, c, vp, \\bar{v})$ or $\\hat{h}(v, c, vp)$ for short.\nVP* algorithm. The VP* algorithm plans the path from node $v_0$ to $v_k$ sequentially visiting via points $ \\bar{v}$ and avoiding collisions with previously planned paths saved in the reservation table. The algorithm iterates on a priority queue, which directs the search toward the most promising elements. This queue contains tu- ples (v, c, vp, hs), where v is a node, c a configuration at this node, vp the index of the last via point reached and hs the heap score of the tuple.\nAt the beginning of the search, we initialize this queue with a tuple ($v_0, c_0, v_{p0}, h_{s0}$) containing the origin node $v_0$ (the first via point), the initial configuration $c_0$ (ob- tained from the partial out-configuration of the first via point and the path start time), $v_{p0}$ = 0 and the heap score $h_{s0}$ of the element.\nDuring a search step, the algorithm pops a heap element (v, c, vp, hs) with the lowest heap score and explores its neighborhood A(v) in the routing graph. We first check the lower bound $h(v, c, v_p)$ on the duration of a path to the destination $v_k$ from (v, c, vp). If it is larger than the duration of the best path found so far, the search is pruned by going to the next step. If not, we check if we have reached the next via point in the right orientation, i.e. if node v is the next via point and if configuration c has the same orientation as the in-configuration of the next via point.\nIf we are at the next via point, we need to be able to stay at node v without collision for the duration of the action to perform at this via point. If we can, and we are at destination $v_k$, we can update the earliest known arrival time at node $v_k$ and go to the next step. If we are not yet at final destination $v_k$, we increase by one the index vp of the last reached via point and update the configuration time $ \\tau$ with the time spent at the via point before exploring the neighborhood of v, as well as the load from the out-configuration of the via point.\nFor each neighbor v' of node v, we verify if we can use arc (v, v') starting at time $ \\tau$ without collision, using the dynamics of the robot to compute its position in time and space while traveling the edge. If there is no collision, we check that the obtained configuration c' at v' has not already been added to the queue for via- point index vp. If not, we compute the heap score hs' and add the new element (v', c', vp, hs') to the queue.\nThe algorithm finishes when the queue is empty. Note that additional stopping criteria could be added, such as having found a first feasible path, having popped a maximum number of elements out of the queue, or having spent a certain amount of time. The first drops the optimality of the algorithm, the last two leads to drop the completeness of the algorithm as it can return before finding a first feasible solution when one exists. Algorithm 2 gives the pseudo-code of the algorithm.\nNote that in our experiments, we stop the search as soon as a first solution is found. In practice, it is much faster (as the algorithm does not need to empty the queue completely before returning a solution) and we observed on our setting good results at the level of the MAPF algorithm, sometimes even better than with optimal paths, suggesting that optimizing locally the path of a given robot might in some cases make it more difficult for other agents to plan their own paths.\nHeap score. The heap score of (v, c, vp), where v is a node, c a configuration and vp a via point index, is com- puted as the sum of an optimistic estimate $\\hat{h}(v, c, v_p)$ of the shortest path duration to the destination after passing through all via points and a penalty p(vp) that is higher when the number of remaining via points to pass is higher, and equal to 0 when only one via point remains to be reached. This penalty aims to favor find- ing a first feasible path between origin and destination passing through all via points by making a depth-first like search. It is hence different from the heap score used by Li et al. [15] and of the classical A* algorithm as the score is not necessarily a lower bound on the duration of a path to destination from the current heap element. However, as we use the travel-time lower bounds to prune the search and not the heap scores, the algorithm remains optimal if run until the queue is empty. Section 5.1.2 compares our heap score to the one with p(vp) = 0, and shows that the proposed penalty is indeed an efficient way to reduce the search space.\nFurther improvements of VP* As the robots must regularly wait to avoid collision in our setting, the VP* algorithm, implemented as described above, might lead to solutions that are optimal in terms of path dura- tion, but not satisfactory for a human observer. Indeed, spending the waiting time immobile or moving is equiv- alent according to the path duration criterion, and we observe in our experiments solutions with unnecessary moves happening during those waiting times. Because we discretize waiting times (by setting the duration of the loop arcs of the graph), it can also happen that those moves improve the minimum path duration by allowing to return at a node slightly before what would have been possible staying immobile. To avoid this problem, we introduce a secondary criterion, the minimum total time in movement of the robot, that we use to break ties between equivalent solutions, and we discretize arrival times in such way that solutions that are very close in terms of arrival times are deemed equal according to"}, {"title": "5. Validation", "content": "5.1. In Simulation\nWe implement a simulator of the warehouse environ- ment where robot movements are modeled with sim- ple dynamics. The robot's linear acceleration A is con- strained to the interval [Adec, Aacc]. The value of A may depend on the loading state of the robot since a heavy robot cannot accelerate as fast as a lighter one. If we suppose that the robot is always accelerating or decel- erating as fast as it can toward the desired speed, we can compute the shortest time $t_s$ it takes to travel a line segment of length d when starting with velocity $v_i$ and obeying acceleration constraints, segment-specific speed limit V and the maximum speed at the end of the segment $V_f$. Identical computations can be made for pure turning arcs in which only the robot's orienta- tion @ changes. In this case the same computation are performed with acceleration limits [$A_{ddec}, A_{dacc}$], angular distance $d_ \\theta$, and maximum angular speed $V_ \\theta$. For all the arcs in the routing graph, the initial and maximum final velocities equal zero. Under those hypotheses, we get highly accurate travel times, compared to the actual measurements in the warehouse (see Section 5.5).\nIn the simulation experiments, the maximum lin- ear/angular velocities are 0.2[m/s; rad/s], and the constant (ac/de)celerations is 0.25[m/s\u00b2; rad/s\u00b2] when the robot is loaded, 0.5 otherwise."}, {"title": "5.1.1 The Need for Dynamics", "content": "To study the need for taking dynamics into account, we compare our proposed method to two different base- lines. The first baseline, admittedly naive given our graph with edges of different length, assumes that we can move to any neighboring node in constant time. Following the paths planned based under this hypothe- sis causes collisions in our standard warehouses after following two edges.\nThe second baseline, like suggested by Ma et al. [18] ignores inertial dynamics and allows instantaneous switching between stopping and constant-speed move- ment. This assumption, does not actually simplify or speed-up our algorithm (since the spatially explicit col- lision checking is still needed). We simulated 100 differ- ent scenarios and the paths planned with this assump- tion using 4 robots. All of them resulted in a collision within 5 minutes, half of them failed within 1 minute, some within the first 10 seconds. Due to the increased need for replanning and no significant speed-up benefit, it is clear that dynamics should be considered in the planning process."}, {"title": "5.1.2 Ablation Study", "content": "In this study, we use a simple layout graph similar to the left layout in Fig. 1, with 100 nodes and 106 arcs in the warehouse graph and 596 nodes and 1908 arcs in the routing multi-graph. We call it Layout 0.\nSequential planning vs via points. To evaluate the need for the proposed via-point algorithm VP* in our IPP MAPF solver, we replace it by a more naive"}]}