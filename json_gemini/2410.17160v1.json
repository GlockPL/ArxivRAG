{"title": "Layered LA-MAPF: a decomposition of large agent MAPF instance to accelerate solving without compromising solvability", "authors": ["Zhuo Yao"], "abstract": "Multi-Agent Path Finding (MAPF) has been widely studied in recent years. However, most existing MAPF algorithms assume that an agent occupies only a single grid in a grid-based map. This assumption limits their applicability in many real-world domains where agents have geometric shapes, rather than being point-like. Such agents, which can occupy multiple cells simultaneously, are referred to as \u201clarge\u201d agents. When considering the shape and size of agents in MAPF, the computational complexity increases significantly as the number of agents grows, primarily due to the increased overhead in conflict detection between geometric agents. In this paper, we propose two types of subproblems for the LA-MAPF (Large-Agent MAPF) problem: cluster (which has no constraints on the order of solution) and level (which imposes constraints on the solution order). We introduce Layered LA-MAPF, a method that decomposes a MAPF instance involving geometric agents into clusters, and then further decomposes each cluster into levels. This approach aims to reduce time complexity when solving LA-MAPF problems. Our results demonstrate the performance of our method as the number of agents increases across various maps, and how it accelerates LA-MAPF methods, such as LA-CBS and LA-LaCAM. Experiments show that our LA-MAPF method with instance decomposition halves the time cost (reducing from an average of 40s to 20s) and triples the success rate (from an average of 0.27 to 0.80) in finding a solution within 60 seconds. To facilitate further research, we have made the source code for Layered LA-MAPF publicly available at https://github.com/JoeYao-bit/LayeredMAPF/algorithm/LA-MAPF.", "sections": [{"title": "Introduction", "content": "In robotics and computer games, multiple agents often need to move simultaneously, and avoiding conflicts between agents has led to the study of Multi-Agent Path Finding (MAPF). MAPF aims to find a path for each agent from its given start location to its target location on a given map, ensuring that no agents collide at any time. Numerous MAPF algorithms have been developed in recent years, such as Conflict-Based Search (CBS)\u00b9, Priority-Based Search (PBS)2, Priority Inheritance with Backtracking (PIBT)\u00b3, and Lazy Constraints Addition for MAPF (LaCAM)\u2074.\nAlthough previous MAPF algorithms have found some real-world applications5\u20137, they are based on one simplistic assumption that limits their applicability. This assumption is the consideration of agents as point agents, which occupy exactly one grid at any time, ignoring their actual shape. In reality, agents are geometric in nature, with definite shapes (e.g., rectangular or circular), and typically occupy a set of points at any given time. Li et al. refer to such agents as large agents. MAPF algorithms can be applied to large agents by lowering the resolution of the environment's discretization. However, this approach degrades performance and reduces practical applicability. Therefore, Li et al. formalize and study LA-MAPF, i.e., MAPF for large agents. Intuitively, LA-MAPF is more difficult to solve than MAPF, as it is a generalization of MAPF and agents are more likely to collide with one another.\nMotivated by the observation that the cost of solving MAPF instances grows exponentially as the number of agents increases, we proposed a novel approach, Layered MAPF\u00b9\u2070, to reduce the computational cost of MAPF methods by decomposing a MAPF instance into multiple smaller subproblems. These subproblems are solved independently, always ensuring a solution while considering the solutions of other subproblems as dynamic obstacles. Initially, we decompose the MAPF instance into subproblems without restricting the order of solving (referred to as clusters), and then further divide them into smaller subproblems with a restricted solving order (referred to as levels). A brief example of clusters and levels is shown in Fig.1.\nConsidering that LA-MAPF requires more computational resources than MAPF (such as conflict detection between geometric shapes), decomposing an LA-MAPF instance has an even stronger impact on reducing the time cost of LA- MAPF methods. In this paper, we extend the decomposition approach from MAPF instances to LA-MAPF instances and introduce an additional step to further decompose the instance into smaller subproblems, as illustrated in Fig.2. The contributions of this manuscript are as follows:\n1, we extend the decomposition of MAPF instances to LA-MAPF instances. Additionally, we propose a framework that allows general LA-MAPF methods to solve subproblems independently and merge their solutions to obtain the solution to the original problem without loss of solvability.\n2, compared to previous work, we introduce a new step to further decompose level into smaller levels.\n3, we conduct extensive testing to evaluate how the decomposition of LA-MAPF instances influences LA- MAPF methods across various maps and with an increasing number of agents. We assess the impact in terms of time cost, success rate, and solution quality (makespan and sum of cost).\nThe remainder of this article is organized as follows. In the Related Works section, we review related articles about decomposition of MAPF instances. In the Preliminaries section, we introduce basic concepts and processes, followed by our method in the Methodology section. Our test results on the performance of decomposition under various maps and different numbers of agents are presented in the Results section, and an examination of how decomposition benefits LA-MAPF methods. Finally, the Conclusion section concludes this article."}, {"title": "Related works", "content": "The idea of splitting a MAPF problem into multiple smaller subproblems has been explored by researchers in recent years. Standley et al.\u00b9\u00b9,\u00b9\u00b2 proposed that if the optimal paths of two agents have no conflicts, they can be solved independently. Standley \u00b9\u00b2 introduced an independence detection (ID) algorithm to decompose a group of agents into the smallest possible groups. ID begins by assigning each agent to its own group and finds an initial path for each group independently. It then attempts to find alternative paths to avoid conflicts. If attempts to find conflict-free paths fail, ID merges the conflicting groups. The process continues until there are no conflicts between agents from different groups.\nWhile ID ensures the solvability of the decomposition, searching the full path multiple times is very time- consuming. In contrast, our method reduces the time cost of decomposition by using connectivity graph, which represent connections between regions, instead of grid-by-grid paths. Additionally, ID does not consider how the order of solving affects whether two agents are independent (e.g., by altering the order of solving, two agents can be solved separately, even if their isolated paths initially have conflicts).\nSharon et al. \u00b9\u00b3 proposed a continuum between CBS and ID called Meta-Agent CBS (MA-CBS). MA-CBS introduces a predefined parameter B, where conflicting agents are merged into a meta-agent and treated as a joint composite agent if the number of conflicts exceeds B. The original CBS algorithm corresponds to the extreme case where B = \u221e (never merge agents), while the Independence Detection (ID) framework \u00b9\u00b9,\u00b9\u00b2 represents the other extreme, where B = 0 (always merge agents when conflicts occur).\nPriority-Based Search (PBS)\u00b2 is an incomplete, subop- timal algorithm designed for prioritized planning. At the high level, PBS employs a depth-first search to dynamically construct a priority ordering, forming a priority tree (PT). When a collision occurs, PBS greedily assigns a higher priority to one of the agents involved. It efficiently backtracks"}, {"title": "Preliminaries", "content": "In this section, we will introduce basic definitions and concepts about LA-MAPF.\nWorkspace\nDefinition 1. Work space: a N-dimensional Euclidean space $C^N$ (usually N = 2,3). There are only two possible states for a grid/element in $C^N$: passable or unpassable. The set of all passable grids in $C^N$ is denoted as F, while the set of all unpassable grids is denoted as O.\nRobot's state\nWe define robot's state as a tuple of location and orientation.\nDefinition 2. Location: The location is a point in the Euclidean space $C^N$ and is specified by its coordinates $(p_0, p_1,...,p_{N-\\infty})$, where $p_i \\in Z$ for $i = 0,1,..., N - \\infty$.\nIn an N-dimensional Euclidean space, there are $2^N$ possible orientations. Each orientation is a unit vector along one of the coordinate axes.\nFor example:\n*   In a 2D space, the four possible orientations are: (1,0), (-1,0), (0, 1), and (0, -1).\n*   In a 3D space, the six possible orientations are: (1,0,0), (-1,0,0), (0,1,0), (0, -1, 0), (0, 0, 1), and (0,0,-1).\nDefinition 3. Agent Orientation: The orientation of an agent is defined as an integer r, where $r \\in \\{0, 1, 2, ..., 2^N - 1\\}$. Each value of r corresponds to one of the $2^N$ possible orientations in an N-dimensional space.\nFor example:\n*   In 2D space, r = 0 corresponds to the orientation (1,0), r = 1 corresponds to (\u22121,0), r = 2 corre- sponds to (0,1), and r = 3 corresponds to (0, \u22121).\n*   In 3D space, r = 0 corresponds to the orientation (1,0,0), r = 1 corresponds to (-1,0,0), r = 2 corresponds to (0,1,0), and so on up to r = 5, which corresponds to (0, 0, \u22121).\nBy considering orientation changes during planning, we can account for conflicts arising from these changes, making our solution more realistic compared to those that consider only locations. This approach brings our solutions closer to real-world scenarios and makes them more convenient for execution.\nIn summary, we define the robot's state as a tuple consisting of its location and orientation.\nDefinition 4. Robot's state is defined as $S=\\{(p_1,p_2,...,p_N),r\\}$. For convenience, we denote the start state of agent $a_i$ as $S[a_i]$, and the target state as $T[a_i]$.\nCollision detection\nConsidering that different agents have different shapes, we define the process for checking whether agents collide with obstacles or with other agents. To facilitate collision checks"}, {"title": "Subgraph of agent", "content": "As mentioned in Li et al.8, different agents have different traversable subgraphs due to their varying shapes.\nDefinition 6. Subgraph $G_i = (V_i, E_i)$: a graph repre- senting all possible robot states and whether one state can transfer to another for agent ai, which is a directed graph. $V_i$ contains all collision-free robot states, and $E_i$ contains all collision-free robot state transfers, i.e., $\\forall v \\in V_i$, $[a_i, v] \\cap O = \\emptyset$ and $\\forall (v \\rightarrow v') \\in E_i$, $[a_i, v, v'] \\cap O = 0$. $v \\in V_i$ denote a node in Vi and $(v \\rightarrow u) \\in E_i$ denote a edge in $E_i$ that transfer from node v to u."}, {"title": "Solvability of MAPF instance", "content": "Considering that not all MAPF instances are solvable, researchers have proposed several algorithms to check whether a MAPF instance is solvable. A common approach is to check whether each agent has a path that connects its start state and target state while ignoring other agents, similar to the implementation of EECBS*.\nHere we extend this approach to LA-MAPF. First, we define a search path function:\nDefinition 9. search_path($G_i(V_i, E_i)$, avoid_node_set): a complete method to search a path in $G_i(V_i, E_i)$ that connects the start vertex and target state of agent ai. The parameter avoid_node_set refers to the set of nodes that cannot be part of the path. If a solution exists, we denote this as search_path($G_i(V_i, E_i)$, avoid_node_set) $\\neq$ 0."}, {"title": "Decompositin of instance", "content": "Given that the cost of solving a MAPF instance increases almost exponentially with the number of agents, decompos- ing the instance and solving subproblems generally results in lower costs compared to directly solving the entire instance.\nHere we define the decomposition of a MAPF instance:\nDefinition 10. Decomposition of a MAPF instance: splitting a set of k agents, $A = \\{a_1, a_2,..., a_k\\}$, where k $\\geq$ 1, into m subsets of agents, $A_1, A_2,..., A_m$, where m $\\geq$ 1 and $A_10 A_2 U U A_m = A$. Each subset is solvable independently without updating the solutions of the other subsets.\nThe criterion for evaluating the quality of one decompo- sition over another involves sorting the sizes of the sub- problems in decreasing order and comparing them from the largest to the smallest. The first smaller subproblem encountered indicates the better decomposition.\nFor example, suppose there are two decompositions of a MAPF instance with 100 agents. The sizes of the subproblems for the first decomposition are 40, 20, 15, 14, and 11, while for the second decomposition, they are 40, 20, 19, 13, and 8. The first decomposition is better than the second because the size of the third subproblem (15) in the first decomposition is smaller than the size of the third subproblem (19) in the second decomposition.\nIn the implementation, we measure the quality of the decomposition by calculating the ratio between the size of the largest subproblem and the total number of agents in the raw MAPF instance. Since the cost of solving a MAPF instance is primarily determined by the size of the largest subproblem, we refer to this ratio between size of the largest subproblem and the total number of agents as the decomposition rate in the following text.\nA decomposition of a LA-MAPF instance is considered legal if each subproblem remains solvable. Before discussing how to decompose a MAPF instance, we first introduce the method for checking whether a decomposition is legal. Specifically, each subproblem must have a solution that avoids conflicts with the paths of other subproblems, and the solutions can be merged to form a conflict-free total solution.\nWe simplify this by allowing the agents in each subproblem to start moving only after all agents in the previous subproblems have reached their target states, while avoiding the start states of subproblems that have not yet been solved. In other words, in this simplified scenario, each subproblem treats the agents of other subproblems as static obstacles, as shown in Fig. 6. If we can find a solution for every subproblem under this simplified scenario, we can obtain a conflict-free total solution by combining the solutions of each subproblem. If all subproblems are solvable under this simplified scenario, we say we have found a legal decomposition of the LA-MAPF instance."}, {"title": "Cluster and level", "content": "Definition 11. Here we define two types of subproblems: cluster, a type of subproblem with no restriction on the order of solving; and level, a type of subproblem that must be solved in a specific order.\nFor convenience, we denote the start or target pose of a cluster c and a level l as S[c] or T[c] and S[l] or T[l], respectively.\nA brief example of clusters and levels is shown in Fig. 1. A MAPF instance may be decomposed into multiple clusters $C = \\{C_1, C_2,...,C_m\\}$ or multiple levels $L = \\{l_1,l_2,..., l_n\\}$.\nTo ensure that the decomposition of a LA-MAPF instance into clusters or levels is legal, the cluster and level must satisfy certain conditions. Before introducing these conditions, we denote nodes in $G_i(V_i, E_i)$ (the subgraph of agent ai) that are related to the start state of agent aj as $r_s(i, j)$, and nodes in $G_i(V_i, E_i)$ that are related to the target state of agent aj as $r_t(i, j)$. A related example is shown in Fig. 7.\nWe denote a node as related to an agent if it is related with the agent's start state or target state.\n$r_s(i, j) =\\{u|u \\in V_i, [a_i, u] \\cap [a_j, S[a_j]] \\neq 0\\}U \\{u|(u \\rightarrow v) \\in E_i, [a_i, u, v] \\cap [a_j, S[a_j]] \\neq 0\\}U \\{v|(u \\rightarrow v) \\in E_i, [a_i, u, v] \\cap [a_j, S[a_j]] \\neq 0\\}$\n$r_t(i, j) =\\{u|u \\in V_i, [a_i, u] \\cap [a_j, T[a_j]] \\neq 0\\}U \\{u|(u \\rightarrow v) \\in E_i, [a_i, u, v] \\cap [a_j, T[a_j]] \\neq 0\\}U \\{v|(u \\rightarrow v) \\in E_i, [a_i, u, v] \\cap [a_j, T[a_j]] \\neq 0\\}$\nWe denote the set of all start or target states of other agents related to a robot state u in current agent's subgraph"}, {"title": "Theorem 1. Solvable condition for decomposition into clusters:", "content": "If a LA-MAPF instance is decomposed into multiple clusters $C = \\{C_1, C_2,..., C_m\\}$, then $\\forall c \\in C$, $\\forall a_i \\in c$, the set of nodes to avoid () is defined as\navoid_node_set = $\\{s | s\\in \\{ \\bigcup_{j=0}^{k}r_s(i, j) \\cup \\bigcup_{j=0}^{k}r_t(i, j)\\}, j \\notin c\\}$\nIf search_path($G_i(V_i, E_i)$, avoid_node_set) $\\neq$ 0, then the decomposition of the LA-MAPF instance into clusters is considered legal.\nIn other words, if each cluster's agents have a path that does not pass through nodes related to the start or target states of agents in other clusters, the decomposition of the LA-MAPF instance into clusters is legal.\nProof 1. If each cluster's agents have a path that does not pass through nodes related to the start or target states of agents in other clusters, then the decomposition is solvable under the mentioned simplified scenario, and the decomposition of the LA-MAPF instance into clusters is considered legal."}, {"title": "Component connectivity graph", "content": "As our main focus is on whether an agent's path passes through nodes related to other agents' start or target states, we store whether nodes in the subgraph are related to other agents' start or target states (in simple terms, their relation to other agents). We then use strongly connected component detection to split Vi into subsets of nodes that have the same relations to other agents, where every node in a subset is reachable from every other node.\nWe denote a component as related to an agent if the nodes in it are related to that agent. Similarly, we denote a component as related to an agent's start or target state if the nodes in it are related to the agent's start or target state.\nStrongly Connected Components (SCCs) are a fundamen- tal concept in graph theory and algorithms. In a directed graph, a strongly connected component is a subset of nodes where every node in the subset is reachable from every other node in the same subset by traversing the directed edges.\nIn the implementation, we use Tarjan's algorithm \u00b9\u2075 for strongly connected component detection, and ignore edges between nodes that have different relations to other agents to ensure that nodes within the same component have the same relations to other agents. In the implementation, we can simplify component connected graph to minimize its scale by ignoring components that have no relationship with other agents or isn't contain start node or target node of current agent, and directly connecting the relevant nodes. An example of a connectivity graph is shown in Fig. 8.\nDefinition 12. We define the directed graph that takes these components as nodes and represents their connections as the component connectivity graph G(V, E).\nHere, we denote all start or target states that a component uc\u2208 Ve is related to as R(uc). For all u \u2208 Vc, and for all u' \u2208 uc, v \u2208 uc, we have R(u) = R(v) = R(uc). Thus, we can search for paths in G(V, E) rather than in $G_i(V_i, E_i)$. A path in G(V, E) that does not pass through any component related to another agent aj's start or target state is equivalent to a path in Gi (Vi, Ei) that does not pass through any node related to agent aj's start or target state."}, {"title": "Variants of search path", "content": "Here, we define two variants of the search path function used in decomposing the LA-MAPF instance into clusters:\nDefinition 13. search_path_agent(G(V, E), avail_agent_set, avoid_agent_set), where avail_agent_set represents the what agents that path (in $G_i$) can only have components related to them, and avoid_agent_set means what agents that path cannot have components related to. If avail_agent_set = \u00d8, it means the path can pass through all nodes in V, except those related to agents in avoid_agent_set.\nsearch_path_agent performs a complete graph search on G(V, E) to determine which components are necessary to connect the components that S[ai] and T[ai] in, and returns the agents that the current agent needs to be related to in order to connect S[ai] and T[ai] (i.e., it returns the agents that are related to these components).\nIn general MAPF, if each agent has a path that does not conflict with obstacles, the MAPF instance is solvable. Similarly, if a cluster of agents has paths that do not pass through states related to agents in other clusters (which means that if we treat other agents as obstacles, staying at their start or target states, the current cluster is solvable),"}, {"title": "Definition 14. search_path_SAT", "content": "Similarly, we define a variant of search_path used in decomposing the instance into levels:\nDefinition 14. search_path_SAT(G(V, E), avail_SAT_set, avoid_SAT_set), where avail_SAT_set what agents' start or target state that path can only have components related to, and avoid_SAT_set what agents' start or target state that path cannot have components related to. If avail_SAT_set = \u00d8, it means the path can pass through all components in Vi, except those related to agents' start or target states in avoid-SAT_set.\nsearch_path_agent performs a complete graph search on G(V, E) to determine which components are necessary to connect the components that S[ai] and T[ai] in, and returns what agents' start or target states that the current agent needs to be related to in order to connect its start and target states. For convenience, we will refer to these as the related SATs of the current agent in the following text. In detail, SAT stands for Start And Target.\nEssentially, search_path_SAT is a more detailed version of search_path_agent; they have almost the same implementation, except for their return values.\nSimilar to search_path_agent, an important property of search_path_SAT is that if its return value contains only aj's start state, the current agent and aj can be in different levels by setting aj's level earlier than ai; if the return value contains only aj's target state, the current agent and aj can be in different levels by setting aj's level later than ai; if the return value contains both aj's start and target states, the current agent and aj should be in the same level."}, {"title": "Methodology", "content": "In this section, we focus on how to use the component connectivity graph and variants of the search path to decompose a LA-MAPF instance into clusters and levels, minimizing the size of each decomposition as much as possible."}, {"title": "Decompose instance into clusters", "content": "In this section, we present how to use the component con- nectivity graph and search_path_agent to decompose a LA- MAPF instance into clusters as small as possible. According to the definition of search_path_agent, we define the return value of search_path_agent(G(V, E), avail_agent_set, avoid_agent_set) as the related agents of ai.\nDefinition 15. Relevance of two agents: If the return value of search_path_agent contains aj, or if the return value of search_path_agent contains ai, we denote those two agents ai and aj as relevant.\nIt is noteworthy that the relevance of two agents is determined by the avail agent_set, avoid_agent_set, and G(V, E). The subgraph is constant, but avail_agent_set and avoid_agent_set are variables, so whether two agents are relevant may changes as avail_agent_set and avoid_agent_set change.\nDefinition 16. Graph of agents' relevance Ga: An undirected graph where nodes represent agents and edges represent whether two agents are relevant.\nAccording to the definition of a cluster, a cluster is a maximal connected subgraph (i.e., a connected component) of Ga.\nIntuitively, a cluster is a set of agents from the raw LA- MAPF instance, where any agents within it are only relevant to agents within the same set. For convenience, we denote Cmajor or Cremain as independent if they have no relationship with any external agent.\nAn intuitive way to obtain clusters is by con- structing clusters while setting avail_agent_set = 0 and avoid_agent_set = 0. We refer to such clusters as initial clusters.\nHowever, setting avail_agent_set = \u00d8 and avoid_agent_set = \u00d8 does not always result in the smallest possible clusters, as it does not consider how to avoid agents from forming large clusters.\nThere is room for decomposing these initial clusters into smaller ones by updating the return value of search_path_agent (in implementation, we verify the existence of such relations between agents under different avail_agent_set and avoid_agent_set rather than explicitly maintaining all agents' related agents). Thus, we propose a method to iteratively bipartition clusters until further subdivision is not possible, aiming to minimize the size of each clusters.\nMore details about bipartitioning can be found in the following section. This process ensures the solvability of the decomposition, and the more bipartitioning steps, the better the results obtained. Bipartitioning a cluster does not guarantee the discovery of the optimal decomposition, but it is a Pareto improvement. An overview of the process"}, {"title": "Definition 17.  A crucial concept", "content": "Definition 17. A crucial concept to introduce is the notion of \u201cunavoidable agents\u201d for an agent a\u017c within a cluster C. Unavoidable agents of an agent a\u017c in a cluster C refer to those agents within C that are always related to ai. In other words, these agents must belong to the same cluster and cannot be further divided.\nDefinition 18. Unavoidance graph Gu of a cluster: an undirected graph representation of whether one agent is unavoidable to another agent within the cluster. It is important to note that for a given cluster C, its unavoidance graph is unique.\nBoth the unavoidance graph Gu and the relevance graph Ga depict relationships between agents within the cluster.\nThe largest connected component of the unavoidance graph Gu is the maximum indivisible agents of the cluster. Intuitively, these maximum unavoidable agents represent the largest indivisible subset within the current cluster, and are referred to as the \"major set\" during the cluster bipartition process. This is aim to reducing the time cost of bipartition by pick out the largest subset at first. Agents within the cluster, excluding those belonging to the maximum unavoidable agents, are referred to as the \u201cremaining set\u201d during the cluster bipartition process.\nThe bipartition of the cluster involves moving agents from the remaining set to the major set until no agent remains in the remaining set, or both sets could form valid clusters. The bipartition of a cluster comprises four steps:"}, {"title": "Algorithm 1: Decomposition instance to clusters", "content": "Algorithm 1: Decomposition instance to clusters\nInput: $A = \\{a_1, a_2, ..., a_k\\}$\nOutput: C\n1 // determine initial clusters\n2 $P = \\{P_1, P_2, ..., P_k\\}$; // relavant agents of all agents\n3 for i = 1, 2,..., k do\n4   $| P_i =$ search_path_agent($G(V, E)$, 0, 0);\n5 get Ga from P;\n6 // get initial clusters\n7 $C_{init}$ = all connected components of Ga;\n8 C = 0; // final clusters\n9 for c\u2208 $C_{init}$ do\n10   temp_cluster = c;\n11   while temp_cluster $\\neq$ \u00d8 do\n12   \\{$C_{major}, C_{remain}\\} =$ Bipartition of cluster (c);\n13   add $C_{major}$ to $C'$ ;\n14   temp_cluster = $C_{remain}$;\n15 return C;"}, {"title": "Bipartition of cluster", "content": "This section is dedicated to decomposing a cluster into two smaller clusters. However, before delving into the bipartition of cluster, it's essential to introduce some necessary concepts.\nDefinition 17. A crucial concept to introduce is the notion of \u201cunavoidable agents\u201d for an agent a\u017c within a cluster C. Unavoidable agents of an agent a\u017c in a cluster C refer to those agents within C that are always related to ai. In other words, these agents must belong to the same cluster and cannot be further divided.\nDefinition 18. Unavoidance graph Gu of a cluster: an undirected graph representation of whether one agent is unavoidable to another agent within the cluster. It is important to note that for a given cluster C, its unavoidance graph is unique.\nBoth the unavoidance graph Gu and the relevance graph Ga depict relationships between agents within the cluster.\nThe largest connected component of the unavoidance graph Gu is the maximum indivisible agents of the cluster. Intuitively, these maximum unavoidable agents represent the largest indivisible subset within the current cluster, and are referred to as the \"major set\" during the cluster bipartition process. This is aim to reducing the time cost of bipartition by pick out the largest subset at first. Agents within the cluster, excluding those belonging to the maximum unavoidable agents, are referred to as the \u201cremaining set\u201d during the cluster bipartition process.\nThe bipartition of the cluster involves moving agents from the remaining set to the major set until no agent remains in the remaining set, or both sets could form valid clusters. The bipartition of a cluster comprises four steps:"}, {"title": "Definition 15. Relevance of two agents:", "content": "Definition 15. Relevance of two agents: If the return value of search_path_agent contains aj, or if the return value of search_path_agent contains a\u017c, we denote those two agents a\u017c and aj as relevant.\nIt is noteworthy that the relevance of two agents is determined by the avail agent_set, avoid_agent_set, and G(V, E). The subgraph is constant, but avail_agent_set and avoid_agent_set are variables, so whether two agents are relevant may changes as avail_agent_set and avoid_agent_set change.\nDefinition 16. Graph of agents' relevance Ga: An undirected graph where nodes represent agents and edges represent whether two agents are relevant.\nAccording to the definition of a cluster, a cluster is a maximal connected subgraph (i.e., a connected component) of Ga.\nIntuitively, a cluster is a set of agents from the raw LA- MAPF instance, where any agents within it are only relevant to agents within the same set. For convenience, we denote Cmajor Or Cremain as independent if they have no relationship with any external agent."}, {"title": "Algorithm 2: Bipartition of cluster", "content": "Algorithm 2: Bipartition of cluster\nInput: c\nOutput: \\{$C_{major}, C_{remain}\\}\n1 // step 1\n2 $G_u = 0$;\n3 for $a_i$ \u2208 c do\n4   for $a_j$ \u2208 $\\$c do\n5   if $a_i \\neq a_j$ then\n6    if\n7      search_path_agent(G(Vi, E), c, \\{$a_j$\\}) = then\n    $|$ add ($a_i \\rightarrow a_j$) as an edge to $G_u$;\n8 $C_{major}$ = agents related to largest connected component of $G_u$;\n9 $C_{remain} = C\\$Cmajor ;\n10 while True do\n11   // step 2\n12   new_agents = 0;\n13   while True do\n14   move_agent = False;\n15   for $a_i$ \u2208 $C_{remain}$ do\n16      if search_path_agent(G(V, E), $C_{remain}, C_{major}$) = \u00d8 then\n17       move $a_i$ from $C_{remain}$ to $C_{major}$;\n18       add $a_i$ to new_agents;\n19       move_agent = True;\n20   if move_agent = False then\n21   $|$ break;\n22 // step 3\n23 while True do\n24   move_agent = False;\n25   for $a_i$ \u2208 new_agents do\n26      if search_path_agent(G(V, E), $C_{major}, C_{remain}$) = 0 then\n27       // consider $a_i$ belong to cluster c, following search path always success\n28       $P_i =$\nsearch_path_agent(G(V, E), c, \u00d8);\n29       move agents in ($p_i\\C_{remain}$) from $C_{remain}$ to $C_{major}$;\n30       move_agent = False;\n31   if move_agent = False then\n32   $|$ break;\n33 // step 4\n34 if both $C_{major}$ and $C_{remain}$ are independent then\n35   $|$ break;\n36 return \\{$C_{major}, C_{remain}\\};"}, {"title": "Decompose cluster into levels", "content": "Clusters can be solved irrespective of the order of solving, thus providing an opportunity to decompose clusters into smaller subproblems by considering the order of solving. By considering the order of solving, we can divide two agents into different subproblems even if they are in the same cluster. We refer to these smaller problems decomposed from clusters as levels.\nIn this section, we focus on how to decompose clusters into levels and determine the"}]}