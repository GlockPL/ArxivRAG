{"title": "An action language-based formalisation of an abstract argumentation framework", "authors": ["Yann Munro", "Camilo Sarmiento", "Isabelle Bloch", "Gauvain Bourgne", "Catherine Pelachaud", "Marie-Jeanne Lesot"], "abstract": "An abstract argumentation framework is a commonly used formalism to provide a static representation of a dialogue. However, the order of enunciation of the arguments in an argumentative dialogue is very important and can affect the outcome of this dialogue. In this paper, we propose a new framework for modelling abstract argumentation graphs, a model that incorporates the order of enunciation of arguments. By taking this order into account, we have the means to deduce a unique outcome for each dialogue, called an extension. We also establish several properties, such as termination and correctness, and discuss two notions of completeness. In particular, we propose a modification of the previous transformation based on a \"last enunciated last updated\" strategy, which verifies the second form of completeness.", "sections": [{"title": "Introduction", "content": "The notion of dialogue, defined as an exchange between at least two agents, either real or virtual, is a central element during an interaction. No matter which type of dialogue game is played [21], elements called arguments are traded one after another between the participants following a set of rules. Formally, these dialogues can be modelled using the abstract argumentation framework (AAF) introduced by Dung [12]. Indeed, AAF provides tools for both creating a dialogue system [6] and reasoning on it. Using these arguments and a binary relation called the attack relationship, it is possible to represent and reason about contradicting information. For that, sets of arguments that can be accepted together, called extensions, are identified [2]. In addition, explanations on the reasons why such sets are accepted or not can be returned [24,20]. However, in the classical version of formal argumentation, there is no focus on the order in which arguments are stated. Since this is very important to establish the causal relations in the dialogue, a notion of temporality has to be included in order to better model a dialogue. Note that we observe the dialogue and do not take part in it. Thus, in contrast to argumentation based dialogue systems [6], we adopt a descriptive approach to model and reason on an AAF. Moreover, we are using an abstract argumentation framework as an input. It means that arguments are abstract objects and the attack relation is only a way to model conflicts between them. Doing so, in contrast to the works done in argumentation theory [23,22], we are focusing neither on the argument structure nor on the nature of the attack.\nIn this paper we propose to investigate the use of a Labelled Transition System (LTS) to include the enunciation order of arguments in the dialogue formalisation. We do not consider a LTS as a language for reasoning about action and change, but rather as a general way of adapting to a dynamic environment. Thus, in practice we consider an action description language (ADL) to formalise our work. In particular, we use the ADL developed in [19] due to its well adapted tools for reasoning about causality, which is the first step towards explanations. Our contributions are as follows: first a new framework is proposed to model and reason on dialogues based on an ADL and following abstract argumentation principles. This new method allows the order in which arguments are presented to be included in the model: we establish a set of rules, inspired from argumentation labellings, to model the argumentative process, leading to a unique outcome, i.e. the acceptability status of each argument. In contrast to discussion games for a given semantic [9] where a dialogue is built a posteriori to find and justify the membership of an argument to the studied semantics, we model the actual dialogue in real time and update the acceptability thanks to these defined rules. Secondly, we study the formal properties of this method. In particular, we prove its termination and its correctness with respect to AAF as well as a discussion about two notions of completeness. Finally, we propose a modification of the previous transformation based on a \"last enunciated last updated\" strategy. Thanks to that, our second version of the notion of completeness is satisfied."}, {"title": "Related work", "content": "The main problem addressed in this work is the modelling of the order of enunciation of arguments in a dialogue in a formalism that is suitable for reasoning about the causality of the acceptability status of an argument. Both questions of temporality and causality have been studied independently in the context of abstract argumentation, while we aim to do both together.\nTemporality in AAF. Barringer et al. [3,4] propose different scales to include temporality in abstract argumentation: the \"object level\" is focusing on the temporal evolution of each component of the graph while at the \"meta level\" a snapshot of the whole system is taken at each time step. One of the solutions they suggested, without formalising it, is to include the action of adding arguments. This idea has been taken up in work aimed at modelling persuasion or negotiation between different agents. In particular, Arisaka and Satoh [1] propose an extension of AAFs called abstract persuasion argumentation (APA)."}, {"title": "From AAF to ADL", "content": "This section presents our first contribution: the use of an ADL to enrich the AAF by taking into account the order of enunciation of arguments. Instead of having only a couple (A, R), the input is a couple (\u0394, R), where \u0394 is a dialogue: \u0394 = {(\u03b1, \u03bf) | (\u03b1, o) \u2208 A \u00d7 N}, where each argument \u03b1 \u2208 A is associated to its order of enunciation, \u03bf \u2208 N."}, {"title": "Instantiating the Context", "content": "To formalise an AAF in the ADL described in Section 3.2, there are three main points to study: the fluents, the events, and the priority rules."}, {"title": "Describing the dialogue: the fluents.", "content": "Let us first define the variables necessary to describe the world, i.e. the AAF. These variables correspond to the fluents F. As introduced in Section 3.1, there are two elements to consider: the arguments and the attack relation. To describe an argument x, we create three fluents. First, $p_x \\in F$ represents the fact that x is present in the graph. Then, as reminded in Section 3.1, for cyclic argumentation framework, the acceptability status of arguments can take three values. To obtain this three-valued logic, we propose to use two fluents: $i_x$ (resp. $o_x$) represents the fact that x is in (resp. out). Combining them makes it possible to get the three different acceptability values: $a_x = i_x \\land \\neg o_x$ corresponding to be acceptable or IN for labellings, $\\neg a_x = \\neg i_x \\land o_x$ corresponding to be not acceptable or OUT, and $undec_x = \\neg i_x \\land \\neg o_x$ corresponding to the undetermined state or UNDEC. The fourth combination $i_x \\vee o_x$ is considered impossible. Another option could have been to create these three fluents $a_x$, $\\neg a_x$ and $undec_x$ directly. Nevertheless, to deal with cycles properly, we want to separate the acceptability status updates as much as possible. For instance, when an acceptable argument is attacked by another acceptable or undecided argument then it becomes undecided. In our formalism, it simply means being attacked by an argument that is not out. Moreover, because the fourth combination is impossible, x is acceptable is the same as $i_x$ holds, and x is unacceptable is the same as $o_x$ holds. Therefore, creating those three fluents is not useful with this decomposition.\nThe last element that is needed to model the dialogue is the attack relation R between the arguments: we use the fluent $c_{Ay,x} \\in F$ to model that argument y can attack argument x."}, {"title": "Updating the argumentation graph: the events.", "content": "During a dialogue, the only deliberate action we consider is to enunciate an argument, which leads to A = {enunciatex | x \u2208 A}. When performed, x becomes present and is acceptable by default. It is also worth noting that if an argument is already present, enunciating it again has the effect of resetting its acceptability value to being acceptable. This way it is possible to repeat an argument that was previously rejected or undecided to reconsider its status. Formally:\n$pre(enunciate_x) = \\top$; $eff(enunciate_x) = p_x \\land i_x \\land \\neg o_x$"}, {"title": "From acceptable to undecided.", "content": "We first study the rule that leads an acceptable argument to become undecided. Suppose that an argument y can attack argument x, and that y is not unacceptable i.e. undecided or acceptable while x is acceptable. Then, x being attacked by an argument y which is not unacceptable, it cannot be acceptable anymore. Formally, the exogenous event $\\Delta_{y,x}^1$ can be written as:\n$tri(\\Delta_{y,x}^1) = p_x \\land i_x \\land p_y \\land c_{Ay,x} \\land \\neg o_y$;\n$eff(\\Delta_{y,x}^1) = \\neg i_x$"}, {"title": "From undecided to unacceptable.", "content": "Now if an acceptable argument y attacks an undecided argument x, then x becomes unacceptable. This leads to the second exogenous event $\\Delta_{y,x}^2$:\n$tri(\\Delta_{y,x}^2) = p_x \\land \\neg o_x \\land p_y \\land c_{Ay,x} \\land i_y$;\n$eff(\\Delta_{y,x}^2) = o_x$"}, {"title": "From unacceptable to undecided.", "content": "Now, let us suppose that argument x is unacceptable and that because of some circumstances, all its attackers have become not acceptable i.e. not in. Then, x cannot be unacceptable anymore and becomes not unacceptable i.e. not out. It is represented by event $I_x^1$:\n$tri(I_x^1) = p_x \\land o_x \\land (\\bigwedge_y (c_{Ay,x} \\land i_y) \\vee \\neg c_{Ay,x})$;\n$eff(I_x^1) = \\neg o_x$"}, {"title": "From undecided to acceptable.", "content": "Finally, if argument x is not acceptable and is attacked only by arguments that are unacceptable then x becomes acceptable. This is translated in the ADL by event $I_x^2$:\n$tri(I_x^2) = p_x \\land \\neg i_x \\land \\neg o_x \\land (\\bigwedge_y(c_{Ay,x} \\land o_y) \\vee \\neg c_{Ay,x})$;\n$eff(I_x^2) = i_x$\nWith these exogenous events, we have broken down the process of making arguments acceptable or unacceptable in two steps by using the undecided status. This is necessary for termination when dealing with cycles to avoid going round in circles. For example, in the case of a two-element cycle, both arguments are first undecided and then the update is stopped, rather than simultaneously becoming acceptable, then unacceptable, then acceptable, and so on and so forth. In the case of acyclic graphs, it would have been possible to merge the first and second rules of each type."}, {"title": "Cycles and Priority rules.", "content": "The decomposition through the undecided status requires defining priority conditions taking into account two elements. The first one is that the decomposed rules ($I^1$ and $I^2$, $\\Delta^1$ and $\\Delta^2$) have to be triggered in the right order. This prevents the fact that an argument x is both in and out which is forbidden. Therefore, we prioritise the rules numbered 1 that lead to the undecided status before possibly lifting the indecision. It can be seen as first focusing on acceptable and unacceptable arguments before handling undecided ones. This is reflected by the two rules: $R_1 := I^1 > I^2$ and $R_1 := \\forall x, y, \\Delta_{y,x}^1 > \\Delta_{y,x}^2$.\nThe second element is to handle cycles and in particular to guarantee the termination of our transformation. To do that, we use the following priority rules: $\\forall x_1, y_1, x_2,y_2, R_2 := \\Delta_{x_1, y_1}^1 > \\Delta_{x_2,y_2}^2$ and $R_3 := \\Delta_{y_1,x_1}^1 > \\Delta_{x_2,y_2}^2$. While these rules are stronger than the previous ones, the principle behind them is the same: focusing on acceptable and unacceptable arguments before handling undecided ones. For more details, please refer to the termination proof in the supplementary material. Note that the latter rule $R_3$ includes the second one $R_1$ presented."}, {"title": "ADL Semantics Adapted to AAF", "content": "Having an adapted  for the argumentative framework, we now propose to modify the ADL semantics to produce traces that are representative of the dialogue. For this purpose, arguments are stated from Ec-argumentative states step by step in the order determined by the dialogue \u0394.\nFirst, let us define what is considered a valid path in a LTS adapted to AAF. Defining this can be seen as setting the conditions that the labelled transition relation \u03c4 must satisfy. The modifications to the conditions in the original ADL [19] can be found in conditions 2.d and 2.e. These conditions specify that an action in the sequence can only be triggered if no exogenous event is triggered at the same time point, and that the event trace cannot be empty.\nGiven an argu-mentative context \u043a, a sequence E(\u22121), S(0), ..., S(N+1) is a valid path w.r.t. \u043a if S(0) = $S_0$ and \u2200t \u2208 T, (S(t), E(t), S(t + 1)) \u2208\u03c4 satisfy:\nS(t) \u2286 Litr is a state.\nE(t) \u2286 E satisfies:\n\u2200e \u2208 E(t), S(t) |= pre(e);\n(e, e') \u2208 E(t)2, e > e';\n\u2200e \u2208 U s.t. S(t) |= tri(e), then e \u2208 E(t) or \u2203e' \u2208 E(t), e' \u27a2 e;\nIf \u2203e \u2208 E(t) \u2229 A, then \u2200e' \u2208 U, S(t) |\u2260 tri(e');\nE(t) \u2260 \u00d8;\nS(t+1) = {l \u2208 S(t)|\u2200e \u2208 E(t),l \u2209 eff(e)}\u222a{l \u2208 Litr|\u2203e \u2208 E(t),l \u2208 eff(e)}.\nAs in the ADL proposed in [19], there is potentially more than one valid path for a given context K. The form of scenario \u03c3 used in this previous work to obtain a unique path is not convenient for the formalisation of a dialogue because it requires that the number of steps that each chain of admissibility update events will take is known in advance. Without this information, it is not possible to plan at which time the next argument should be stated. To solve this issue we introduce a set of ranked actions s\u2286 A\u00d7N, called sequence. The input to obtain unique traces is no longer a scenario o but a sequence s."}, {"title": "Formal properties", "content": "In this section, we first establish and discuss some formal properties of the transformation proposed in Section 4, including the correctness and termination of this transformation. Detailed proofs are given as supplementary material. After that, we discuss two forms of completeness. Then we propose to explore a modification of the transformation according to a new strategy that may lead to one of these forms of completeness. We finally discuss other semantics.\nWe first show that, although valid paths given  are not unique, valid paths given x are, as well as the corresponding traces $T_{\\Xi}^{\\chi}$ and $T_{\\S}^{\\chi}$."}, {"title": "Two versions of completeness.", "content": "A first definition of completeness is, given a dialogue A and an argumentative semantics \u03a3, to be able to find all the extensions of this semantics. This means that there is no loss of information when using the formalism we propose to model the dialogue instead of an argumentative one. By contrast, we gain some insight into how such a state has been reached thanks to the traces. The problem with this completeness is that it erases most of the benefits of modelling the order of enunciation of arguments. Indeed, if no matter what the order is we require to find all the extensions, then the order only matters for the traces. We want to go a bit further and use this temporality to discriminate between extensions.\nThus, we propose to consider another form of completeness: for each extension of a given semantics, there exists an order of enunciation such that the labelling associated with its final state is equal to this extension. Using this definition, we can find all the extensions and at least one order of enunciation that leads to such an extension. Then, if an agent wants to reach a certain decision i.e. a particular extension, finding an order that leads to it can be seen as a debating strategy. This is the type of completeness we are looking for."}, {"title": "A new transformation.", "content": "In the current state of the transformation, this second form of completeness does not hold. Indeed, to handle graphs with odd-length cycles, the two priority rules R2 and R3 lead to set the acceptability status of the arguments to undecided before applying other rules. For that reason, in the case of an even-length cycle, the only final state that can be reached is the one where all arguments are undecided. To deal with that issue, we explore here the possibility of another strategy.\nFor example, let us consider the case where an argument x that is attacked and also attacks other arguments is enunciated. Without any further hypotheses, event $\\Delta_{y,x}^1$ may be triggered and change the acceptability status of x to undecided. Here, we consider the \"last enunciated last updated\" strategy (discussing the appropriateness of this strategy is beyond the scope of this paper) i.e. we first apply all of the enunciated argument effects and then update its own status, eventually triggering another chain of exogenous events. By doing so, all attackers of x may become unaccepted and so the status of x may not change. To do that, the context has to be modified. First, we need a new fluent $l_x^e$ that is set to true when an argument has just been enunciated. This fluent means that this argument has to be updated last. Then, the action enunciatex becomes:\npre(enunciatex) = T; eff (enunciatex) = $p_x \\land l_x \\land i_x \\land \\neg o_x$\nThen, in order the acceptability update of a just stated argument to occur last, we create two instances of each exogenous event, e.g. $\\Delta_{y,x}$ is replaced by $\\Delta_{y,x}^E$ and $\\Delta_{y,x}^L$ such that:\n$tri(\\Delta_{y,x}^E) = p_x \\land l_x \\land i_x \\land p_y \\land c_{Ay,x} \\land \\neg o_y$;\n$eff(\\Delta_{y,x}^E) = \\neg i_x$\n$tri(\\Delta_{y,x}^L) = p_x \\land \\neg l_x \\land i_x \\land p_y \\land c_{Ay,x} \\land \\neg o_y$;\n$eff(\\Delta_{y,x}^L) = \\neg i_x \\land \\neg l_x$\nAlong the same lines, from the three other exogenous events we create six exogenous events, three for the earliest arguments and three for the latest ones. We define $U = U^E \\cup U^L$.\nFinally, the last step is to update the priority rules with the new exogenous events. The four previous rules become eight. Moreover, to force the model to"}]}