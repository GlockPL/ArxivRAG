{"title": "A Meta-Engine Framework for Interleaved Task and\nMotion Planning using Topological Refinements", "authors": ["Elisa Tosello", "Alessandro Valentini", "Andrea Micheli"], "abstract": "Task And Motion Planning (TAMP) is the problem of\nfinding a solution to an automated planning problem that includes\ndiscrete actions executable by low-level continuous motions. This\nfield is gaining increasing interest within the robotics community,\nas it significantly enhances robot's autonomy in real-world appli-\ncations. Many solutions and formulations exist, but no clear stan-\ndard representation has emerged. In this paper, we propose a general\nand open-source framework for modeling and benchmarking TAMP\nproblems. Moreover, we introduce an innovative meta-technique to\nsolve TAMP problems involving moving agents and multiple task-\nstate-dependent obstacles. This approach enables using any off-the-\nshelf task planner and motion planner while leveraging a geometric\nanalysis of the motion planner's search space to prune the task plan-\nner's exploration, enhancing its efficiency. We also show how to spe-\ncialize this meta-engine for the case of an incremental SMT-based\nplanner. We demonstrate the effectiveness of our approach across\nbenchmark problems of increasing complexity, where robots must\nnavigate environments with movable obstacles. Finally, we integrate\nstate-of-the-art TAMP algorithms into our framework and compare\ntheir performance with our achievements.", "sections": [{"title": "1 Introduction", "content": "Task And Motion Planning (TAMP) is the problem of finding high-\nlevel plans to accomplish assigned tasks (task planning), as well as\nthe motions needed to execute these plans (motion planning). Con-\nsider a warehouse robot collecting items and placing them in bins\nfor shipment. At the task level, it determines the sequence of ac-\ntions needed, such as collecting items and navigating. At the motion\nlevel, it plans the movements considering obstacles. Merely sequenc-\ning task and motion planning may lead to ineffective solutions, with\nthe robot possibly moving directly toward the goal, ignoring obsta-\ncles. In contrast, integrating these components effectively allows the\nrobot's plan to adapt dynamically. For instance, if a pallet blocks an\naisle, the robot will try to move it before proceeding further.\nA wide range of proposed solutions and formulations exist, but no\nclear standard representation has emerged [17]. In this paper, we pro-\npose a formalization and implementation for modeling TAMP prob-\nlems related to navigation tasks involving multiple movable objects,\nwhich remains independent of specific planners and languages. Ad-\nditionally, we offer an open-source modeling tool, built within the\nopen-source Unified Planning (UP) library\u00b9, that facilitates seamless\nintegration of setups and planners for evaluation and comparison."}, {"title": "2 Problem Statement", "content": "In this Section, we formalize a TAMP problem with mobile agents\nmoving within a workspace populated by task-dependent obstacles.\nAs a motivating example, consider a robot tasked to navigate an of-\nfice environment with multiple sliding doors controlled by button\npresses. To reach its destination, the robot needs to\nfind a sequence of actions to move and open doors. Simultaneously,\nit must physically execute these actions, which means finding mo-\ntion primitives ensuring collision-free movement. Upon pressing the\nbutton, it must be aware of the change in door configuration so it can\npass through and reach the assigned target. A formal definition of\nthis class of problems follows.\nDefinition 1. A (ground) Task And Motion Planning problem is a\ntuple \u03c8 = (R, W, C, U, V, I, A, G) such that:\n\u2022 R is a set of mobile agents, where each agent r is characterized\nby a certain geometric model.\n\u2022 WCRN (N = 2 or N = 3) is the workspace, that is the physical\nvolume of all end point positions reachable by the robots in R. We\ndefine Wf as the subset of W free from fixed obstacles.\n\u2022 U is a map that assigns to each agent r \u2208 Ra motion model\nUr, that is a mathematical representation of the kinematic and\ndynamic laws that allows the agent to evolve within W.\n\u2022 C is the configuration space, where Cr C is that subset of C\nthat represents the joint configurations that r\u2208 R may assume\ngiven its motion model. In this context, occ(r, q) Wf is the set\nof points in Wf occupied by r when in configuration q \u2208 Cr.\n\u2022 V = {f1, .., fk} is a finite set of variables (or fluents) f \u2208 V, each\nwith a finite or infinite domain Dom(f).\n\u2022 I is the initial task state, which assigns a value I(f) \u2208 Dom(f)\nto each f \u2208 V.\n\u2022 A is a set of actions a = (P, E, M) such that:\nP is a set of preconditions pre \u2208 P, with pre a Boolean combi-\nnation of atoms f = v, with f \u2208 V and v \u2208 Dom(f).\nE is a set of effects eff \u2208 E each of the form f := v with f \u2208 V\nand v \u2208 Dom(f).\nM is a (possibly empty) set of motion constraints of the form\n(r, qs, qG, O), where r \u2208 R is the agent performing a, qs \u2208 Cr\nis its start configuration, qG E Cr is the target configuration,\nand 0 C 2RxC is a function associating the other movable\nagents, which r must avoid, to the configurations they currently\n\u043e\u0441\u0441\u0438\u0440\u0443.\n\u2022 G is the goal condition, represented as a Boolean combination of\natoms of the form f = v, with f \u2208 V and v \u2208 Dom(f).\nFocusing on the semantics of the problem, a state S is a total as-\nsignment of values to the fluents such that S(f) \u2208 Dom(f) for all\nf\u2208 V. An action is applicable in a state S if its preconditions are\nsatisfied by substituting each fluent f appearing in the Boolean com-\nbination with S(f) and if all the motion constraints M are satisfiable.\nA motion constraint (r, qs, qG, O) is satisfied if there exists a\ncollision-free path \u03c4: [0,1] \u2192 Cr that moves r from \u03c4(0) = qs\nto \u03c4(1) = qG. T must be compliant with the motion model Ur,\nmust reside in Wf, i.e., \u2200t \u2208 [0,1]. occ(r, \u03c4(t)) \u2286 Wf, and"}, {"title": "must be collision-free with the obstacles listed on O, i.e., \u2200t \u2208\n[0, 1]. \u2200(r', q') \u2208 O. occ(r, \u03c4(t)) \u2229 occ(r', q') = 0.\nThe successor of S, once applied a = (P, E, M), is a(S) where:", "content": "a(S)(f) = { v  if (f := v) \u2208 E\nS(f)  otherwise\nThe plan solving \u03c8 is a sequence (ao,...,an) of actions\nsuch that ao is applicable in I, each action ar is applicable in\nai-1(ai-2((ao(I)))), and the final state satisfies G.\nIn our example, r moves in a deterministic and fully observable\n2D map where fixed obstacles are the walls. Thus, Wf encompasses\nall the points on the map not occupied by the walls. The robot moves\naccording to a ReedsShepp-type motion model [20], i.e., its config-\nuration has the form (x, y, \u03b8), where (x, y) are Cartesian coordinates\nand \u03b8 is the orientation angle. A motion constraint (r, qs, qG, O) is\nsatisfied if we find a path that connects qs to qe while avoiding the\ndoors in O, where a door is a movable object that changes its config-\nuration from closed to open when pressing its open button.\nDefinition 1 is a ground formalization of the TAMP problem we\ntackle. For the sake of brevity, we only formalize the syntax and se-\nmantics of the ground representation. In practical modeling, we adopt\na lifted representation, as is customary in the planning community.\nOur peculiarity is to consider movable agents and configurations of\ninterest as objects of the problem, allowing fluents to have subsets\nof configurations as domains. This is useful for specifying goals for\nthe agents and expressions evaluating movable agents or configura-\ntions. If er is an expression evaluating a movable agent and eq is\nan expression evaluating a configuration, a motion constraint will\nhave the form (er, eqs, eqg, Ot), with Or a set of pairs of the form\n(er, eq). The semantics is given by grounding: we assess the expres-\nsions within the lifted motion constraint in the state where the action\nstarts, and we obtain the ground motion constraint of Definition 1."}, {"title": "3 Meta-Engine Framework", "content": "To effectively and efficiently solve the TAMP problem \u03c8, we devel-\noped a meta-engine framework that allows to interleave an off-the-\nshelf task planner \u03be and an off-the-shelf motion planner \u03c1, provided\nas inputs. The basic idea of the approach is to invoke the task plan-\nner on the planning problem obtained by disregarding all the motion\nconstraints of every action to generate a candidate plan. The candi-\ndate plan is then checked to ensure all the motion constraints of the\ninvolved actions are realizable. If this is the case, then the plan is re-\nturned, otherwise we extract information from the search space of the\nmotion planner for the motion constraint that is not realizable; this in-\nformation is then used to refine the task problem and we restart the\ntask planner to find a new candidate plan. In this section, we detail\nthis general schema and we explain how the refinement is computed.\nAlgorithm 1 reports the pseudo-code of the meta-engine. The task\nplanner \u03be searches for a plan \u03c0 that is valid for the problem \u03c8 while\ndisregarding the motion constraints (line 5). By excluding the motion\naspect, the problem is reduced to a traditional task-planning prob-\nlem. If a valid plan \u03c0 is found, the function CHECKPLANMOTIONS\nchecks all the motion constraints of all the actions involved in the\nplan (line 7). Since many motion planning algorithms are sample-\nbased and do not guarantee termination if a path does not exist, we set\na timeout tp to each invocation of the motion planner. The algorithm\nkeeps a cache \u03b3 which stores each motion constraint successfully\nchecked and its trajectory \u03c4. If all the motion constraints of all the\nactions of \u03c0 are found to be realizable by the motion planner, then"}, {"title": "the constraint (r, qs, qG, O) is infeasible, it means that the target qG\ncannot be reached either because it is blocked by fixed obstacles or\nby movable ones (or that we did not give enough time to the motion\nplanner, but this is handled as discussed above). In the first case, there\nis simply no plan that solves the high-level task that was assigned\nto r. In the second case, some of the obstacles in O prevent r from\nreaching the target, hence some of them must be moved to find a\nvalid plan. In our motivating example, this means that some closed\ndoor prevents the robotic agent from reaching its final destination.\nIf the constraint (r, qs, qG, O) is invalid, we find the convex hull", "content": "H(qs) = {\\sum_{j=1}^{K} x_jP_j | \\sum_{j=1}^{K} x_j = 0; \\sum_{j=1}^{K} = 1}\nof the points {p1,..., pk} sampled by the motion planner from qs.\nLet X be the set {q1,..., qm} Cr of interesting configurations\nthat the agent may assume, i.e., the motion constraints' configura-\ntions involving r for the ground case or the objects of type Config-\nuration for the lifted case. We check which configurations yield an\noccupancy that does not belong to H(qs). The idea is that H(qs) is\nan approximation of the positions that the agent can reach and we\nwant to compute the set of interesting locations that are unreachable\nfrom the specified starting configuration qs. We call the resulting set\n\u03c3 and we define it formally as {q \u2208 X | occ(r, q) \u2288 H(qs)}.\nThe second element of the explanation concerns the blocking mov-\nable obstacles. Not all the obstacles in O block the agent from reach-\ning its goal, hence we isolate the obstacles that prevent the motion\nplanner from computing a feasible path connecting qs to \u03c3. We call\nthis set \u03c9 C 0. This set can be efficiently computed by keeping track\nof the collisions analyzed by the motion planner: if a collision hap-\npens in a point p\u2208 occ(r', q') with (r', q') \u2208 O, we add the element\n(r', q') to \u03c9. The intuition is that obstacles we do not collide with\ndo not hinder finding a valid plan, offering no useful information for\npruning the task planner's search space. Hence, they can be omitted.\nCHECKPLANMOTIONS collects all the conflicts in \u00b5 and uses this\ndata to refine the problem (line 11). The idea is to prevent the task\nplanner from using actions that are not feasible because of the expla-\nnations in \u00b5. We present here two refinements, one for the grounded\nproblem of Definition 1 and a more practical one for the lifted case.\nIn the grounded refinement, we remove any actions with motion\nconstraints that conflict with explanations in \u00b5, thereby refining the\nset of actions. Formally, given \u03c8 = <R, W, C, U, V, I, A, G), we\nreturn \u03c8' = (R, W, C, U, V, I, A', G) with A' defined as:\n{a = (P, E, M) \u2208 A | \u2200m = (r, qs, qG, O) \u2208 M.\n(r, qs,\u03c3,\u03c9) \u0395\u03bc\u039b (qG \u0395\u03c3\u03bd\u03c9 \u2286 0)}\nThis prevents the execution of actions with known unrealizable con-\nstraints (with the given timeout tp)."}, {"title": "The lifted case is similar, but requires the addition of preconditions\nto eliminate all the groundings that would conflict with the learned\nexplanations. For each action a in the lifted TAMP problem, we add\nthe following precondition for each lifted motion constraint m =", "content": "(er, eqs, eqc, O\u02bb) of a and for each explanation (r, qs, \u03c3,\u03c9) \u2208 \u03bc:\ner \u2260 r \u2228eqs \u2260 qs \u2228\u2228\u2227 eqG \u2260 q\u2228\n\u03b1\u03b5\u03c3\n\u2228\n((er\u2260r') \u2228 (ec \u2260 c'))\n(r',c') Ew (er,ec)\u2208Ol\nwhich informally means that m of a is consistent with the explana-\ntion if any of the following conditions are met: i) er does not evaluate\nto r; ii) eqs does not evaluate to qs; iii) the destination eqg does not\nevaluate to any element of \u03c3; iv) there exists an obstacle in w that has\na different configuration or doesn't exist in this constraint.\nTheoretical Guarantees. Many motion planners exist and can be\nleveraged by our meta-engine. In our case, we exploit sampling-\nbased motion planners, specifically the Rapidly exploring Random\nTree (RRT) algorithm [18] and its Lazy version. Our proposal be-\ncomes probabilistic complete assuming the task planner is complete,\nbecause the probability of finding a solution tends to 1 as the time tp\ngiven to the motion planner to compute a plan tends to infinity. We\nalso assume that when a motion from qs to qe fails, qG \u0395\u03bcat line\n7 of Algorithm 1 (the destination is always unreachable), preventing\nto enter an infinite loop as the interesting configuration set is finite."}, {"title": "4 SMT-based Specialization", "content": "We tailored our framework to leverage the incremental solution capa-\nbilities of SMT-based solvers. Such solvers maintain a stack of con-\nstraints (called assertions), enabling efficient repeated satisfiability\nchecks as constraints are pushed onto or popped from the constraint\nstack. This feature eliminates the need for restarting the planning rou-\ntine upon failure to find a valid plan, enhancing overall scalability."}, {"title": "Our approach is called TAMPEST and it iterates between task and\nmotion planning while progressively increasing the search depth un-\ntil finding a valid plan or reaching the maximum step horizon hmax.\nAs shown in Algorithm 3, the general schema is that of the meta-\nengine in Algorithm 1, with the outer while loop serving for the re-\nfinement of the motion planner timeout tp, the learned explanations\n\u03bc, and the horizon h. The inner loop is the focal point of the ap-\nproach. We encode the task part of \u03c8 as an SMT planning problem,\nanalogously to many SATPlan-like approaches [16, 21], and we add\nto the assertions relative to the initial state, which hold at step 0\n(line 6). At each step h\u2264 hmax, we generate and add the assertions\nf and l (lines 9-13). As in [5], f asserts that a selected action im-\nplies its preconditions and effects, the state remains the same unless\nchanged by an action effect, and only one subset of non-mutex ac-\ntions is taken at time. Assertion l, instead, characterizes the goal.\n\u03b6 searches for a valid plan \u03c0, that means finding a satisfying assign-\nment for the asserted logical formulae (line 15). If a model exists, we\ncheck the motion feasibility of \u03c0 via CHECKPLANMOTIONS, possi-\nbly exploiting the cached information (line 16). If all constraints are\nsatisfied, we return the plan and the paths (line 18). Otherwise, we\npop the solver and add the logical lemmas representing the topologi-\ncal refinements \u03bc'. We use the same logical formulation used for the\nlifted refinement in the meta-engine encoding the preconditions as an\nSMT formula instantiated at all the symbolic times i \u2208 {1, ..., h}.\nOnce this data is added, we push the solver, re-add the goal, and try to\nfind a solution again (lines 20:25). Every time we enlarge the encod-\ning bound, we permanently add the lemmas for all the explanations\nin \u00b5 at h, ensuring their validity across all encoding steps (line 11)."}, {"title": "5 Modeling and Benchmarking", "content": "Besides formulating the TAMP problem of Definition 1 and defin-\ning suitable TAMP solvers, we developed a comprehensive open-\nsource framework for modeling and benchmarking these problems.\nAn overview of the key components of this implementation follows,\nalong with a description of the benchmark suite we designed.\nUP\u00b9 is an open-source, planner-agnostic planning library that col-\nlects planning tools and algorithms to model, manipulate, and solve\nclassical, numerical, temporal, and other complex tasks, such as\nmulti-agent assignments. To enable the modeling of TAMP prob-\nlems, we extended the TAMP modeling of the UP adding obstacle\navoidance. Besides preconditions and effects, motion actions include\nmotion constraints of the form path(r, qs, [qG], {o : qo\u2200o\u2208 O}),\ni.e., there \u2203\u03c0 : [qs, [qG]] \u2192 Cr for r \u2208 R and {0 : q\u2200o\u2208 O}, as in Definition 1. Non-fixed objects are defined as Movable Objects\nwith a geometric and motion model. Their configurations are Con-\nfiguration Objects with a value in the form provided by the motion\nmodel of the agent (e.g., (x, y, yaw) in SE(2)). The workspace is an\n\u041e\u0441\u0441\u0438\u0440\u0430\u043f\u0441\u0443 \u041cap collecting all useful data for motion planning and\ncollision avoidance with fixed obstacles, such as the 2D image or\n3D mesh of the operating environment and its reference system. We\nallow fluents that accept as input a Movable Object and output its cur-\nrent Configuration Object within the Occupancy Map. As for all the\ntools of the UP library, this extension is independent of the planning\nlanguage and planner available to define and solve this problem.\nWith this extension, we offer a set of benchmarks that task robotic\nagents with Navigating Among Movable Obstacles (NAMO) [24],\ni.e., moving through a workspace while removing or avoiding mov-\nable obstacles. As in [17], we assume the search space is i) geomet-\nric: motion planning focuses only on finding feasible object poses\nbased on the geometric constraints of the world; ii) fully observable:"}, {"title": "Steps to take the robot from start to goal while opening all the\ndoors and visiting all extra locations (large task space). Closed\ndoors make some locations unreachable (infeasible task actions).\n\u2022 Maze. A robot must navigate out of a maze while visiting M points\nrandomly distributed within it. N doors block\nvarious passages, not all leading to exit or target locations. Their\nmotion model requires the motion planner to compute opening\npaths. Actions are {move, open}. Again, we are exploring a large\ntask space equipped with infeasible task actions. Moreover, we\nshould find a good motion/task trade-off to efficiently solve the\nproblem: while opening all doors and reaching the assigned targets\nis valid, only opening necessary doors yields efficiency.\n\u2022 Delivery. Inspired by the delivery domain of IPC, Maze locations\nbecome parcels with no geometry and motion model. They are\ndistinguished by colors and must be arranged into rows by color,\neach row delivered before the next. Actions are\n{move, open, load, unload}, where load involves collecting a par-\ncel and placing it atop an agent. unload enables the agent to re-\nmove an item from its cargo and deposit it at a specified loca-\ntion (large task space). The robot has a fixed capacity (numeri-\ncal problem), and can unload packages only when positioned in\nfront of the unloading location, though some parcels are already\nat their stations. N doors block N passages, some of which are\nuseful to reach the unloading area (unfeasible task actions). The\nlayout of the unloading area and the presence of obstructing doors\ninfluence the motion/task trade-off. Parcels initially at unloading\nstations enable assessment of non-monotonicity: if a parcel blocks\nthe unloading of other items, it must be temporally relocated.\n\u2022 Rovers. We reproduce the rover domain of IPC to demonstrate the\ngenerality of our approach. N rovers must col-\nlect rock and soil samples, separated from each robot by a door.\nThen, they must calibrate their cameras, photograph M objectives\nlocated around each sample without occlusions, and send the re-\nsults back to a lander. Due to obstacles that limit the reachability of\nparts of the workspace, one rover must be utilized for each sample\nand the objectives around it. Actions are {move, open, calibrate,\nsample rock, sample soil, send analysis, drop, take image, send\nimage}, and some of them change only the discrete state and not\nthe configuration space (non-geometric actions).", "content": "6 Related Work\nMany planners exist that combine symbolic and geometric search.\nAs an example, the aSyMov planner [3, 4] interleaves a FF-based\ntask planner with lazily-expanded roadmaps. However, this approach\nis impractical when action plans are valid in the symbolic space"}, {"title": "framework with PDDLSTREAM, highlighting our ability to inte-\ngrate existing solvers and the superior performance of our proposal.\nBenchmarks and solvers are available in the supplementary material,\nto be released upon paper acceptance. Our test cases follows:", "content": "\u2022 Doors. We feature na \u2208 [1, 2, 4, ..., 10] closed doors that must\nall be open to reach the final destination. Additionally, either 0 (\u043f\u0441\n= [(0, 0)]) or 10 extra configurations are randomly distributed in\nthe reachable space (nc = [(10,0)]), the initially unreachable space\n(nc = [(0, 10)]), or equally split between both (nc = [(5,5)]).\n\u2022 Maze. We increase the complexity of our domain by introducing\nna \u2208 [1, 2, 3, ..., 10] closed doors within a maze setup, where not\nall doors block the final destination. The extra-configurations be-\ncomes ne \u2208 [0, 1, 2, 3, ..., 10] mandatory targets for inspection,\nrandomly located within the maze.\n\u2022 Delivery. We sample na \u2208 [1,2,4,..., 10] closed doors, not\nall obstructing the target, and nr + ng \u2208 [0,1, 2, 3, ..., 8] red\nand green parcels. Colors are randomly sampled among available\nparcels. Parcels must be delivered in two rows, with at most 4 red\nparcels placed in the front and 4 green parcels in the back. dr \u2264 3\nred parcels and dg \u2264 3 green parcels are already in their delivery\nspots, eventually blocking the reachability of the unloading loca-\ntions behind them, that means ne = x = [(nr,ng, dr, dg)]. The\nrobot's load capacity ni ranges from 1 to 4.\n\u2022 Rovers. We involve 2nd robots with na \u2208 [1,2,3,4,5]. Each\nrobot analyzes either one soil or one rock sample, each one sit-\nuated one closed door away from the robot. We design nc E\n[0, 1, 2, 3, 4] objectives to be photographed around each sample.\nWe tested Maze and Rover domains in both 2D and 3D setups, while\nDoors and Delivery tests were limited to their 2D implementations.\nIndeed, these setups closely resemble those of the former domains.\nWe instantiate our Meta-Engine with FAST-DOWNWARD [14], the\nExpressive Numeric Heuristic Search Planner (ENHSP) [22], and\nTAMER [27], and evaluate their performance compared with TAM-\nPEST (with hmax = 100), where the last three can solve numerical\nproblems such as our Delivery domain. We combine each solver with\nthe RRT [18] and LAZYRRT motion planners (with tp = 3s). In\n2D scenarios, we implement an ad-hoc collision checker that ver-\nifies the feasibility of a robot's pose by ensuring that its footprint\ndoesn't intersect obstacles. In 3D, we exploit the Flexible Colli-\nsion Library [19]. Finally, we study our refinement schema by dis-\nabling some of the explanations computed by CHECKPLANMO-\nTIONS. We set the topological refinements \u03bc' = {(\u03c3, \u03c9)} as follows.\nAll-Refinements is the full algorithm as described in the previous sec-\ntions. Only-Reachables assumes w = O, disabling the analysis of\nthe obstacles with which the agent collided, but retaining the anal-\nsis of the unreachable points. Only-Obstacles forces \u03c3 = {qG},\nretaining the obstacles analysis but disabling the unreachable con-\nfigurations one, to only remove the target location. No-Refinements\nforces \u03c3 = {qG} and w = 0, removing only the violated constraint.\nFocusing on PDDLSTREAM, we explore its incremental, fo-\ncused, binding, and adaptive variants equipped with FAST-\nDOWNWARD [13], as provided by default. To enable them to solve\nour benchmarks, we convert the motion constraints into streams,\nmapped with functions that certificates the existence of paths. We\nemploy the same motion planners and collision checkers as before.\nWe set a global timeout of 1800 s, a memory limit of 10 GB, and\nran tests on an Intel Xeon CPU 6226R @2.9GHz."}, {"title": "refinements are leveraged at the task level, enhancing\nefficiency and allowing for plans with many actions.", "content": "7 Experimental Evaluation\nIn this Section, we present experiments evaluating our meta-engine\nframework across various task and motion planners. We assess the\neffectiveness of its SMT-based specialization and quantify improve-\nments from topological refinements. Moreover, we compare our"}, {"title": "Solver excels with simpler\ninstances, but encounters scalability issues with its SMT component\nwhen plans include many actions. As plan size grows, solver perfor-\nmance may decline due to the need to process a larger number of pa-\nrameters, resulting in longer resolution times. Finally, in Figure 4(c)\nwe compare PDDLSTREAM's adaptive variant with TAMPEST (both\nwith RRT and TAMPEST with all refinements). The former consis-\ntently times out, even when our approach easily finds solutions. This\nstands out notably in the Maze domain (magenta dots).", "content": "8 Conclusion and Future Work\nIn this paper, we provided a detailed representation of a multi-agent\nTAMP scenario with one agent moving at a time and multiple task-\ndependent obstacles. Our contributions include a general problem\nformulation and semantic definition, supported by an open-source\nlibrary for modeling and benchmarking. We also introduced a novel\nmeta-engine framework for combining off-the-shelf task and motion\nplanners to solve complex scenarios. We proposed using geometric\ncontext to generate topological refinements and prune the task plan-\nner's search space. Additionally, we demonstrated how this meta-\nengine can be adapted for an incremental SMT-based task planner,\nnamed TAMPEST. We compared TAMPEST with existing planners in-\nterleaved with sample-based motion planners, with and without topo-\nlogical refinements. SMT's incremental nature accelerates problem\nresolution, while topological refinements decrease the time required\nto find a valid plan. Finally, we integrated PDDLStream enabling di-\nrect comparison of solvers on the same input data: TAMPEST outper-\nforms PDDLStream, especially when using topological refinements.\nIn future work, we will include metric time and address scenarios\nwith multiple agents moving simultaneously. We will also integrate\nreplanning mechanisms to handle non-determinism."}]}