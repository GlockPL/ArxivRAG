{"title": "Pearce's Characterisation in an Epistemic Domain", "authors": ["Ezgi Iraz Su"], "abstract": "Answer-set programming (ASP) is a successful problem-solving approach in logic-based Al. In ASP, problems are represented as declarative logic programs, and solutions are identified through their answer sets. Equilibrium logic (EL) is a general-purpose nonmonotonic reasoning formalism, based on a monotonic logic called here-and-there logic. EL was basically proposed by Pearce as a foundational framework of ASP. Epistemic specifications (ES) are extensions of ASP-programs with subjective literals. These new modal constructs in the ASP-language make it possible to check whether a regular literal of ASP is true in every (or some) answer-set of a program. ES-programs are interpreted by world-views, which are essentially collections of answer-sets. (Reflexive) autoepistemic logic is a nonmonotonic formalism, modeling self-belief (knowledge) of ideally rational agents. A relatively new semantics for ES is based on a combination of EL and (reflexive) autoepistemic logic. In this paper, we first propose an overarching framework in the epistemic ASP domain. We then establish a correspondence between existing (reflexive) (auto)epistemic equilibrium logics and our easily-adaptable comprehensive framework, building on Pearce's characterisation of answer-sets as equilibrium models. We achieve this by extending Ferraris' work on answer sets for propositional theories to the epistemic case and reveal the relationship between some ES-semantic proposals.", "sections": [{"title": "1 Introduction", "content": "Answer-set programming (ASP), introduced by Gelfond&Lifschitz [7, 8], is an approach to declarative logic programming. Its reduct-based semantics is defined by stable models (alias, answer-sets), essentially the supported classical models of a logic program. ASP has demonstrated success in solving problems within logic-based Al: a problem is first encoded as a logic program, and then efficient ASP-solvers are employed to compute its stable models corresponding to the solutions. However, as Gelfond pointed out in his seminal work [4], ASP encounters challenges in accurately representing and reasoning about incomplete information. The difficulty arises when a program involves multiple stable models, and a proposition holds in one stable model but contradicts another. The main reason for this drawback lies in the local performance of ASP's negation as failure (NAF) operator, which handles incomplete information within individual stable models. To address this issue and enable collective reasoning about incomplete information, we need additional tools in the language of ASP. Epistemic modal operators provide one potential solution to ASP's limitation with incomplete information. By integrating such op- erators into the ASP-language, the new modal constructs in the extended language allow us to quantify over a collection of stable models and check whether a proposition holds in every (some) stable model.\nThe initial approach to this problem is by Gelfond's epistemic specifications [4, 5], referred to as ES94 here: Gelfond extended ASP with epistemic constructs known as subjective literals. Indeed, with the incorporation of epistemic modalities K and M, he could represent incomplete information within stable-model collections. While a subjective literal KI (MI) makes it possible to check whether a literal I is true in every (some) stable model of a collection, in particular, the epistemic negation not K accu- rately captures collective reasoning of incomplete information. The extended language is interpreted in terms of world-views, which are, in essence, stable-model collections. However, researchers have soon"}, {"title": "2 Background: ASP and epistemic specifications (ES) in a nutshell", "content": "In this context, ASP-formulas are built from an infinite set P of atoms using the connectives, viz. reversed implication (\u2190), disjunction (V), conjunction (\u2227), NAF (not), strong negation (~), true (T) and false (\u22a5).\nIn ASP, a literal l is an atom p or a strongly-negated atom ~p for p\u2208 P. An ASP-program consists of a finite set of rules r : head(r) \u2190 body(r) s.t. body(r) is formed by a conjunction of literals possibly preceded by NAF, and head(r) is formed by a disjunction of literals: for 0\u2264m\u2264n\u2264k,\n$$l_1 \\lor ... \\lor l_m \\leftarrow l_{m+1} <...> l_n \\land not l_{n+1} \\land ... \\land not l_k.$$ (1)\nAlternatively, we call body goal and its conjuncts subgoals. When m = 0, we suppose head(r) to be and call the rule r constraint. When k = m, we call r fact and omit both body(r) and \u2194. When k = n, we call r a positive rule. A program composed of only positive rules is positive. Finally, as strong negation can be removed from a logic program via auxiliary atoms, this paper mostly ignores ~ for simplicity.\nA valuation is a consistent (possibly empty) set T of literals, i.e., p \u2209 T or ~p \u00a2 T for any p\u2208 P. A valuation T satisfying an ASP-program I (which means T = II) is a classical model of I. Then, stable-models of II are its reduct-based minimal classical models. Stable-model semantics is based on a program transformation that aims to eliminate 'not' from I w.r.t. \u03a0's classical model T (a candidate model), resulting in a positive program \u03a0\u00b9 referred to as reduct of I w.r.t. T: (reduct-taking) replace notp with T if T = not p (equivalently, if T \u2260 p, i.e., p \u00a2 T); otherwise, with 1. This approach also requires that the valuation T be a smallest (minimal) model of this reduct \u03a0\u00b9 w.r.t. subset relation. Eventually, the successful models of this process are called stable models (alias, answer-sets) of \u03a0.", "subsections": [{"title": "2.1 Gelfond's epistemic specifications: ES94", "content": "Epistemic specifications (ES) extends ASP-programs with the epistemic modal operators K ('known') and M ('may be true'). The language LES contains four kinds of literals: objective literals (l), extended objective literals (L), subjective literals (g), and extended subjective literals (G), viz. for p\u2208 P,\n$$\\begin{array}{cccc} l & L & g & G \\\\hline p|\\sim p & l|not l & Kl|Ml & g|not g \\end{array}$$\nNote that ASP's regular literals are called objective literals in ES. By convention, the belief operator M can be defined in terms of the knowledge operator K, i.e., M \u00ba\u00ba\u00b9 not Knot, meaning that they are dual. def An ES-rule 'r : l\u2081 \u2228 ... \u2228 lm \u2190 e1 ^ ... ^en' is an extension of an ASP-rule (1) with extended subjective literals that can appear exclusively in body(r) as subgoals. Thus, body(r) = e\u2081 ^ ... \u0245en is a conjunction of arbitrary ES-literals. Then, an ES-program is a finite collection of ES-rules.\nTruth conditions: Let T be a non-empty collection of valuations. Let I be a valuation, which is not necessarily included in T. Then, for an objective literal I and a subjective literal g, we have:\n$$\\begin{array}{llll} \\mathcal{T}, I |= l & \\text{if } l \\in I; & \\mathcal{T}, I \\models not l & \\text{if } l \\notin I. \\\\ \\mathcal{T}, I \\models Kl & \\text{if } I \\models l \\text{ for every } T \\in \\mathcal{T}; & \\mathcal{T}, I \\models not g & \\text{if } \\mathcal{T}, I \\models g. \\\\ \\mathcal{T}, I \\models Ml & \\text{if } I \\models l \\text{ for some } T \\in \\mathcal{T}; & & \\end{array}$$\nNote that the satisfaction of an objective literal I is independent of T, while the satisfaction of a subjective literal g is independent of I. Thus, we simply write T = g or I = l. Then, we define the"}, {"title": "2.1.1 Motivation", "content": "Example 1 The one-rule program \u0393 = {a \u2190 Ka} has 2 world-views, {0} and {{a}} in ES94. Among these, only the former is intended. The self-supported model {{a}} appears due to the fact that ES94-reduct attacks positive (not preceded by NAF) literals. This approach causes unsupported models to provide fake derivations for head-literals, which in return produce these models by fixed-point justifications. Thus, Gelfond's methodology includes flaws for programs containing cyclic dependencies like \u0393, {a \u2190 Kanot Kb}, {a \u2190 Ka^not b}, etc. Such circular scenarios may arise when the goal contains a positive subjective literal and is satisfied by the candidate unsupported S5-model. Notice that transformation of a literal into true/false w.r.t. its truth-value is secure when it is preceded by NAF with literal reading there is no evidence, or when there exits logical derivations of literals as used by splitting property of (epistemic) ASP. To overcome this problem, Gelfond [6] slightly modifies his reduct definition by replacing Kp with p when TKp and partly avoids circular justifications, but the problem of recursion via M prevails.\nThis modification has probably necessitated further changes in his reduct definition as shown in Table1. The underlying reasons of Kahl's new reduct [9] may be grounded as follows: (1) If T\u2260 not Kl,"}]}, {"title": "3 Epistemic Answer Set Programming (EASP)", "content": "This section introduces a direct generalisation of logic programs under stable-model semantics (aka, ASP-programs) to epistemic logic programs under stable S5-model semantics. This new concept has been partially explored by [15]. The shift from the general term world-view to stable S5-model in EASP, and equilibrium S5-model in the following section is intended to emphasise the purpose of this work. Our main motivation for this study arises from the unsupported models that emerge due to circular justifications under ES94-semantics (see Ex. 1-2). ES94's reduct definition deviates somewhat from the traditional approach. We here propose a new reduct definition for ES-programs, oriented to eliminate exclusively NAF. Thus, our reduct is a positive program, similar to the method in search for stable models.\nThe new approach exploits a two-step computation process, focusing on stability in terms of truth (t) and knowledge (k). The method involves finding the minimal models in terms of truth first, and then refining them further w.r.t. a k-minimality criterion to select stable S5-models. Such models then capture truth and knowledge minimality concepts that is central in (nonmonotonic) epistemic ASP. In broader terms, what we refer to as t-minimality in ES is essentially an extension of the familiar minimisation criterion of ASP from classical models to classical S5-models. However, k-minimality is a relatively new concern within the ASP field compared to the well-established method of t-minimality. The necessity for such a technique has become evident with the incorporation of epistemic concepts into ASP and the need to maximise epistemic possibilities (i.e., ignorance).\nA stable S5-model T of an epistemic logic program II is its S5-model s.t. each valuation T\u2208T forms \u03a0's pointed S5-model (T,T) where T is minimal w.r.t. truth and T is minimal w.r.t. knowledge. For a nonepistemic ASP-program II, such valuations are I's stable-models in ASP, and the (unique) stable S5-model T is the set of all such models. Similar to stable-models of ASP, the intuition underlying stable S5-models is to capture the rationality of an agent associated with an epistemic logic program II: \u201can agent is not supposed to believe anything that it is not forced to believe.\u201d The aim, in principle, is to determine which propositions can be nonmonotonically inferred from II by considering all its stable- models. These inferences are then used to deduce new information about the knowledge of I."}, {"title": "3.1 The Language of EASP (LEASP)", "content": "The language LEASP extends that of ASP by epistemic modalities K and K. Literals (\u03bb) of LEASP are of two types; objective (l) and subjective (g) literals, viz. l:= p | ~p and g := Kl | Kl for p \u2208 P. Then, not a means failing to derive \u03bb, the query \u03bb? is undetermined and assumed to be false; yet we do not offer literal interpretations of the modalities for the sake of flexibility.\nReplacing literals of ASP with those of EASP in (1), we obtain an EASP-rule r, viz.\n$$\\lambda_1 \\vee ... \\vee \\lambda_m \\leftarrow \\lambda_{m+1} \\wedge ... \\wedge \\lambda_n \\wedge not \\lambda_{n+1} \\wedge ... \\wedge not \\lambda_k.$$ (for 0\u2264m\u2264 n \u2264k) (2)\nin which li's are objective or subjective literals for every i = 1,...,k. When we restrict li's to objective literals, the resulting program is a disjunctive logic program [8]. Hence, EASP-rules are conservative extensions of ASP's disjunctive rules (1). Different from ES, we allow Kl and Kl to appear in head(r). While the use of subjective literals in the head has not yet been fully explored, we still find it useful to provide the same syntax structure with ASP for easier understanding of the approach. This way, extensions to richer languages are straightforward via the main ASP track. An epistemic logic program (ELP), also known as EASP-program, is a finite collection of EASP-rules (2)."}, {"title": "3.2 Semantics of EASP in terms of stable S5-models", "content": "We first introduce t-minimality concept in EASP. Based on the existing ES-formalisms in the literature, we provide two slightly different approach. For example, the program \u03a6 = {1,2,3}\n$$r_1 = a \\vee b.$$ $$\nr_2 = a - Kb.$$ $$\nr_3 = b - Ka.$$ (3)\nmay produce t-minimal models T\u2081 = {{a}, {b}} and T2 = {{a,b}}; yet it may also yield T\u2081 only, depending on how restrictive we want to be. In EASP, this subtle distinction originates from differing approaches of t-minimality techniques, emphasising functional vs. relational perspective.\nDefinition 1 (weakening of a point in an S5-model in terms of truth: functional approach) Given a nonempty collection T of valuations, let s : T \u2192 2P be a subset function s.t. s(T) \u2286 T for every T \u2208T. Let id refer to the identity function, and let s[T] = {s(T)}Ter denote the image of T under s. A functional (f) weakening of T at a point T\u2208T by means of s is identified with (s[T], s(T)) s.t. s \u2260 id on T and S|T\\{T} = id, by which we take a strict subset of T \u2208T and keep the elements of T \\{T} unchanged. We say that (s[T], s(T)) is f-weaker than \u3008T,T) on T\u2208T and denote it by (s[T], s(T)) <\u00a3 (T,T).\nDef. 1 has already been introduced by [15]; yet the following more cautious approach is novel.\nDefinition 2 (weakening of a point in an S5-model in terms of truth: relational approach) Let Sr: T\u21d2 2 be a multi-valued subset function s.t. Sr(T) \u2286 27 and sx(T) \u2260 0 for every T \u2208T. For ease of understanding, we also design sr as a serial subset relation, relating each T\u2208T to at least one element from 27 and form the collection sr = {(T, H) : H \u2208 sx(T)}rer. Then, a relational ( r ) weakening of T at a point T \u2208 T by means of sr is identified with (sr[T], Sr(T)) s.t. s \u2260 id on T and s|T\\{r} = id, by which we replace only T in T by a set of its subsets including at least one strict subset H \u2282 T. We say that (Sr[T], Sr(T)) is r-weaker than \u3008T,T) on T\u2208T and denote it by (sr[T], Sx(T)) <r (T,T).\nWe now define a nonmonotonic satisfaction relation * for S5-models, involving a t-minimality criterion based on set inclusion over each set T\u2208T. Intuitively, this condition says that none of the weakenings of \u3008T,T) is an S5-model of an epistemic logic program (ELP) II for every T \u2208\u03a4."}, {"title": "Definition 3 (generalisation of the truth-minimality (t-minimality) criterion of ASP to EASP)", "content": "For a positive EASP-program II, let T be a nonempty collection of valuations, and T \u2208T. Then, we have:\n$$\\mathcal{T}, \\mathcal{T} |=^* \\Pi \\text{ iff } \\mathcal{T}, \\mathcal{T} \\models \\Pi \\text{ and } s[\\mathcal{T}], s(\\mathcal{T}) \\models \\Pi \\text{ for every } s \\text{ s.t. } (s[\\mathcal{T}], s(\\mathcal{T})) <_f (\\mathcal{T}, \\mathcal{T}).$$ (4)\nThus, T is a tf-minimal model of I if T,T = I for every T \u2208T [15]. In this paper, we also define by replacing s with sr, and <f with <r in (4) and produce t\u0159-minimal models of II accordingly.\nAlthough the above definitions seem to be technically complex and daunting, they are easily applied:\nExample 3 Reconsider first the program O, identified by (3), and its S5-model T2 = {{a,b}}. Then construct 2{a,b} = {{{a,b},{a},{b},0}. Since the f-weaker models {{a}}, {{b}}, and {0} of T2 do not satisfy r3, r2, and r1 respectively, I does not hold in them either. Thus, T2 is a tf-minimal model of \u0424.\nWhat eliminates T2 in the second approach is the relational nature of the weakening methodology because now we have to consider all possible subsets of 2{a,b} different from 0 and T2, i.e., all the elements of the set 22{a,b} \\{T2,0}. The element {{a}, {b}} from this set, namely an r-weakening of T2 at the point {a,b} \u2208 T2, satisfies \u03a6. Thus, T2 fails to be a tr-minimal model of D.\nNote that when we consider T\u2081, different from the singleton model T2, we follow the above steps for every pointed S5-model of T1, viz. {{a}, {b}} and {{a}, {b}}. Also note that I is a positive program, and its reduct trivially equals itself. Thus, our reduct is not interested in the positive literals Ka and Kb in \u03a6.\nFact 1 Functional minimality implies relational minimality because any function can be defined as a relation. Thus, a tr-minimal model of an ELP II is a tf-minimal model of II, but not vice versa."}, {"title": "Example 4 Consider the EASP-program \u2211 = {r1, r2, r3, r4} with its rules explicitly represented below:", "content": "r\u2081 = av b.\nr2 = c - b.\nr3 = d - Ka.\nr4 = 1 \u2190 \u0154d.\nNote that \u2211 is a positive program. We compute that {{a}, {b,c}} is a t-minimal model of \u2211: {{a}, {b,c}} |= \u03a3 while its only f-weakening {0,{b,c}} refutes it. Likewise, {{a},{b,c}} = \u2211 while all its f-weakenings, i.e., {{a},{b}}, {{a},{c}}, and {{a},0} do not satisfy it. We leave it to the reader to show that T is also tr-minimal; yet we give a hint that while computing the r-weakenings of, for example, {{a}, {b,c}}, we consider all possible models including {{a},{b},{c}}, {{{a}, {b,c}, 0, {b}}, etc. There are 14 of such models. Clearly, {{b, c}} is E's other t-minimal model, that is unintended and to be eliminated under k-minimality conditions. Note that like Ka, the other positive literal \u0154d is not involved in the reduct-taking process.\nRemark 1 The need for relational minimality arises from the fact that under singleton S5-models like {{p}}, the literals Kp, Kp, and p are of no difference since quantification is trivially performed over just one valuation {p}. For instance, notice that when we replace Kl by I in \u03a6 (3), the resulting ASP- program has the stable model {a,b}. Using relational weakening, we increase epistemic possibilities (points) while reducing truth. Quantifying over these points then reveals the nontrivial functionality of subjective literals. In a sense, the relational t-minimality approach simultaneously embeds in itself a kind of k-minimality strategy by increasing ignorance with epistemic possibilities. The difference between two minimality methods strikingly appears for I under the S5-model {{a,b}} (see Ex. 3). Adding the constraint rc = 1 \u2190 not Ka into D, the new program \u03a6' = \u03a6\u222a{rc} has a world-view {{a,b}} under several ES-formalisms. Some researchers find this result unsupported; yet the existing k-minimality techniques is unable to eliminate this model. Thus, a more restrictive t-minimality tool has been designed to remove models like {{a,b}} while computing t-minimal models. We do not discuss this issue here, as our aim is just to establish a correspondence between existing ES-formalisms; to put it better, to demonstrate the reader how current epistemic equilibrium logics are manifested in the logic programming domain."}, {"title": "Definition 4 (generalisation of the conventional reduct definition of ASP to EASP)", "content": "For an arbitrary EASP-program II, let T be a nonempty collection of valuations, and let T \u2208T. Then, the reduct \u03a0\u3008T,T\u3009 of II w.r.t. the pointed S5-model (T,T\u3009 is defined by replacing every occurrence of NAF-negated (i.e., preceded by NAF) literals not a in II with the truth-constants\n$$\\perp \\text{ if } \\mathcal{T}, \\mathcal{T} \\models \\lambda \\text{ ( for } \\lambda = l \\text{ if } \\mathcal{T} \\not\\models l; \\qquad \\text{ for } \\lambda = Kl \\text{ (} \\~Kl) \\text{ if } \\mathcal{T} \\models Kl \\text{ (} \\~Kl) ). $$\n$$\\top \\text{ if } \\mathcal{T}, \\mathcal{T} \\not\\models \\lambda \\text{ ( for } \\lambda = l \\text{ if } \\mathcal{T} \\models l; \\qquad \\text{ for } \\lambda = Kl \\text{ (} \\~Kl) \\text{ if } \\mathcal{T} \\not\\models Kl \\text{ (} \\~Kl) );$$\nThus, T is a t-minimal model of I if T,T|=* \u03a0{T,T\u3009 for every T \u2208T [15].\nWhile Def. 4 provides a general definition, its specialisation to tf and tr is straightforward. When these methods do not result in a distinction, we refer to them by the general name \u201ctruth\u201d (t)."}, {"title": "Example 5 Consider the EASP-program \u0393 = {r1, r2, r3, r4} where its rules are explicitly shown below:", "content": "r\u2081 = a Vb.\nr2 = c \u2190 Ka^ not b.\nr3 = d \u2190 not Kab.\nr4 \u2190 not kc.\nWe claim that {{a, c}, {b,d}} is a t-minimal model of \u0393. We first compute the following reducts:\navb.\nc\u2190 Kanot \u22a5.\nd\u2190 not ab.\n\u2190 not T.\n\u0393{{a,c},{b,d}} and\navb.\nc - \u041a\u0430\u028cnot T.\nd\u2190 not\u043b\u044c.\n\u2190 not T.\n{{a,c},{b,d}}\nThe above reducts are respectively equivalent to {r\u2081, c \u2190 \u0154a, d \u2190 b} and {r\u2081, d \u2190 b}: when \u22a5 (not \u3112) appears as a subgoal, the goal fails to hold. This means that the effect of the entire rule r is negligible, and r can be safely omitted. When \u315c (not \u22a5) appears as a subgoal, T can be dropped from the subgoals of body(r) as it trivially holds. While {{a,c}, {b,d}} = [{{a,c},{b,d}}, all its f-weakenings, viz. {{a}, {b,d}}, {{c}, {b,d}} and {0, {b, d}}, refute it. While {{a,c}, {b,d}} = [{{a,c},{b,d}}, all its f-weakenings, viz. {{a,c}, {b}}, {{a,c},{d}} and {{a,c},0}, refute it. Finally, notice that the S5-model {{a,c}} is the other (unintended) tf-minimal model of I, and both t-minimality tools produce the identical results for \u0393.\nIn a parallel, purely logical context, world-views are alternatively computed as epistemic extensions of equilibrium models. A first step towards epistemic equilibrium logic belongs to Wang&Zhang [19]. As their approach has generalised ES94 and also due to page restrictions, we do not include it below."}, {"title": "4 Epistemic Extensions of Equilibrium Logic", "content": "Equilibrium logic (EL) is a nonmonotonic formalism, basically proposed by Pearce [11] as a logical and mathematical framework of ASP. EL is based on here-and-there logic (HT), a three-valued monotonic logic which is intermediate between classical logic and intuitionistic logic. An HT-model is an ordered pair (H,T) of valuations H,T C P satisfying H \u2286 T. The semantics of EL, via equilibrium models, is obtained through a t-minimality criterion over HT-models: T is an equilibrium model of 4 iff T, THT 4 (i.e., T= 4) and (t-minimality condition) H,T #\u043d\u315c 4 for any H strictly included in T (HcT). In summary, Pearce has generalised ASP by characterising its stable-models as equilibrium models in EL."}, {"title": "4.1 Su et al.'s approach (ES20a): autoepistemic equilibrium logic (AEEL)", "content": "Inspired by EL's success as a foundational framework for ASP, Su et al. introduced [13, 2, 18] an epistemic extension of EL as an alternative semantics for ES. We here name their approach ES20a and recall how ES20a produces its t-minimal models, namely epistemic equilibrium models (EEMS). For our purposes, we do not include their k-minimality method, selecting ES20a-world-views among its EEMs."}, {"title": "4.1.1 Epistemic here-and-there logic (EHT) and its equilibrium S5-models w.r.t. truth", "content": "EHT extends HT with nondual epistemic modalities K and K, both of which are primitive and structurally identical to the modalities in EASP. Depending on knowledge-minimality conditions, these modalities may characterise different epistemic concepts, so we do not assign them a literal reading for generality. The language of EHT (LEHT) is given by the grammar below, where the formulas outside HT are in bold.\n$$ \\varphi := p |\\bot|\\varphi \\land \\varphi|\\varphi \\nu \\varphi |\\varphi \\rightarrow \\varphi | K\\varphi | \\~K\\varphi.$$ (for pe P)\nAs usual, the derived formulas \u00ac6, T, and 6 \u2194 \u03c8 respectively abbreviate 4 \u2192 1, 1 \u2192 1, and (4 \u2192 \u03c8)^(\u03c8 \u2192 \u03c6). A theory is a finite set of formulas. An EASP-program II is translated to the corresponding EHT-theory \u03a0* via a map (.)*: given \u2211 = {r1, r2} s.t. r\u2081 = p \u2228 ~q \u2190 Kr ^nots and r2 = q \u2190 not Kp,\n$$ \\Sigma^* = ((\\~Kr \\land \\sim s) \\rightarrow (p \\lor \\bar{q})) \\land (\\neg Kp \\rightarrow q) \\land \\neg (q \\land \\bar{q}).$$\nThe literal ~q is treated as a new atom q\u2208 P, and this entails the formula \u00ac(q^q) to be inserted into 2* for consistency purposes. Since it can be easily removed from a logic program with the addition of a constraint | \u2190 q^q as above, the rest of the paper disregards strong negation ~ for simplicity.\nAs already mentioned in Ex. 2, the K operator is syntactically different from M\u2208 Les. This is justified by the fact that M is derived as not Knot in ES and so translated into EHT as \u00abK\u00ab where - refers to EHT-negation. Because \u00abK\u00ab\u03c6, \u00ac\u00acK\u00a2, and K\u00ac\u00ac\u00a2 are all equivalent in EHT, the M operator is expected to coincide with notnotk and Knotnot in a possible extension of EASP-programs to propositional theories, which will be shortly discussed in the next section. Notice that the difference between Mp and Kp in EASP resembles that of notnotp and p in ASP. As a result, in an extended language, we expect Mp not to have a world-view, whereas {0,{p}} is one easily-understandable world-view for Kp.\nAn EHT-model (T, s) is a refinement of a classical S5-model T in which valuations T\u2208T are replaced by HT-models (s(T),T) w.r.t. a subset function s : T \u2192 2, assigning to each T\u2208T one of its subsets, i.e., s(T) \u2286 T. Thus, the explicit representation of \u3008T, s) is given by {(s(T), T)}TET. Satisfaction of a formula E LEHT is defined recursively w.r.t. to the following truth conditions:\n$$\\begin{array}{ll} \\langle \\mathcal{T}, s \\rangle, T \\models_{EHT} p & \\text{if } p \\in s(T); \\\\ \\langle \\mathcal{T}, s \\rangle, T \\models_{EHT} \\bot & \\text{ never; } \\\\ \\langle \\mathcal{T}, s \\rangle, T \\models_{EHT} \\varphi \\rightarrow \\psi & \\text{ if } ( \\langle \\mathcal{T}, s \\rangle, T \\not\\models_{EHT} \\varphi \\text{ or } \\langle \\mathcal{T}, s \\rangle, T \\models_{EHT} \\psi ) \\text{ and } \\\\ & ( \\langle \\mathcal{T}, id \\rangle, T \\not\\models_{EHT} \\varphi \\text{ or } \\langle \\mathcal{T},id \\rangle, T \\models_{EHT} \\psi ); \\\\ \\langle \\mathcal{T}, s \\rangle, T \\models_{EHT} K\\varphi & \\text{ if } \\langle \\mathcal{T}, s \\rangle, T' \\models_{EHT} \\varphi \\text{ for every } T' \\in \\mathcal{T}; \\\\ \\langle \\mathcal{T}, s \\rangle, T \\models_{EHT} \\sim K\\varphi & \\text{ if } \\langle \\mathcal{T}, s \\rangle, T' \\models_{EHT} \\varphi \\text{ for some } T' \\in \\mathcal{T}; \\\\ \\end{array}$$\nwhere id denotes the identity function. The truth conditions of \u22a5, \u2227 and \u2228 are standard. The EHT-model \u3008T,id) = {(T,T)}ret is called total and identical to the classical S5-model T. Then, T is an equilibrium S5-model w.r.t. truth, or originally an epistemic equilibrium model (EEM) of y\u2208 LEHT if T is a classical S5-model of 4, and the following t-minimality condition (referred to as tf-minimality), viz.\nfor every possible subset function s on T with s \u2260 id, there is T\u2208T s.t. (T, s),TEHT 4 (5)"}, {"title": "4.2 Cabalar et al.'s approach (ES20b): founded autoepistemic equilibrium logic (FAEEL)", "content": "Cabalar et al. [1", "H,T)": "TS\u1e5bH"}, "TET. To illustrate the functional vs. relational nature of the formalisms ES20a and ES206, take the S5-model T = {T} where T = {p,q}. Depending on the subset function s on T, we can only form the EHT-models {(0,T)}, {({p}, T)}, {({q},T)}, and {(T,T)} in ES20a as we are restricted to choose a unique subset H = s(T) and so build a unique HT-model (H, T) for each T \u2208 T. However, in EHT20, we can obtain the additional EHT-models\n{({p}, T), ({q},T)}, {(0,T),({p},T),({q},T)}, {(0,T),(T,T)}, {(0,T),({p},T),(T,T)}, etc.\nsince as many subset as desired can be chosen for each T \u2208T, keeping in mind that sr is serial.\nWhile the truth conditions are the same, to avoid possible confusion, we recall that \u3008T, s),T FEHT &\nmeans {(H,T) : H = S(T)}\u03c4\u03b5\u03c4, (H, T) FEHT 6 in ES20a, but here s\u2081(T) may refer to"]}