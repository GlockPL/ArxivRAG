{"title": "Quantum Algorithms for Weighted Constrained Sampling and Weighted Model Counting", "authors": ["Fabrizio Riguzzi"], "abstract": "We consider the problems of weighted constrained sampling and weighted model counting, where we are given a propositional formula and a weight for each world. The first problem consists of sampling worlds with a probability proportional to their weight given that the formula is satisfied. The latter is the problem of computing the sum of the weights of the models of the formula. Both have applications in many fields such as probabilistic reasoning, graphical models, statistical physics, statistics and hardware verification. In this article, we propose QWCS and QWMC, quantum algorithms for performing weighted constrained sampling and weighted model counting, respectively. Both are based on the quantum search/quantum model counting algorithms that are modified to take into account the weights. In the black box model of computation, where we can only query an oracle for evaluating the Boolean function given an assignment, QWCS requires $O(2^{n/2} + 1/\\sqrt{WMC})$ oracle calls, where where n is the number of Boolean variables and WMC is the normalized between 0 and 1 weighted model count of the formula, while a classical algorithm has a complexity of $\\Omega(1/WMC)$. QWMC takes $\\Theta(\\sqrt{2^n})$ oracle calss, while classically the best complexity is $\\Theta(2^n)$, thus achieving a quadratic speedup.", "sections": [{"title": "Introduction", "content": "Given a Boolean formula and a functions assigning weights to assignments of values to the Boolean variable, we consider the problems of Weighted Constrained Sampling (WCS) and Weighted Model Counting (WMC). The first, also called distribution-aware sampling (Chakraborty et al, 2014), involves sampling assignments to the Boolean variables with a probability proportional to their weight given that the formula is satisfied. The latter (Sang et al, 2005) consists in computing the sum of the weights of the models of the formula, i.e. the weighted model count.\nWCS has important applications in a variety of domanis, including statistical physics (Jerrum and Sinclair, 1996), statistics (Madras and Piccioni, 1999), hardware verification (Naveh et al, 2006), and probabilistic reasoning, where it can be used to solve the problem of Most Probable Explanation (MPE) and Maximum A Posteriori (MAP). MPE (Sang et al, 2007) involves finding an assignment to all variables that satisfies a Boolean formula and has the maximum weight. The related MAP problem means finding an assignment of a subset of the variables such that the sum of the weights of the models of the formula that agree on the assignment is maximum.\nWMC was successfully applied, among others, to the problem of performing inference in graphical models (Chavira and Darwiche, 2008; Sang et al, 2005). In particular, other graphical model inference algorithms (Lauritzen and Spiegelhalter, 1988; Zhang and Poole, 1996; Dechter, 1999; Darwiche, 2001) take time $\\Theta(n2^w)$, where n is the number of variables and w is the treewidth (Bodlaender et al, 1993) of the network, a measure of the complexity of the network. WMC instead takes time $O(n2^w)$, i.e., exponential in the treewidth in the worst case (Chavira and Darwiche, 2008). This is possible because WMC exploits the structure of graphical models in the form of context-specific independence and determinism.\nIn this paper we propose to use quantum computing for performing WCS and WMC. We call QWCS and QWMC the resulting algorithms. The first is based on quantum search using Grover's algorithm (Grover, 1996a,b, 1997). The latter on quantum model counting (Boyer et al, 1998; Brassard et al, 1998). We modified these algorithms to take into account weights. In particular, the proposed algorithms modify the algorithms for unweighted search and counting by replacing the Hadamard gates with rotation gates, with the rotations depending on the weights.\nQWCS and QWMC work under a black box computation model where we don't know anything about the propositional formula, we only have the possibility of querying an oracle giving the value of the formula for an assignment of the propositional variables. QWCS take $O(2^{n/2} + 1/\\sqrt{WMC})$ oracle calls to solve WCS with a probability of at least $\\approx 0.707$, where WMC is the weighted model count normalized between 0 and 1 (cf. Theorem 10) and n is the number of variables, while any classical algorithm takes $\\Omega(1/WMC)$ oracle calls.\nQWMC takes $\\Theta(\\sqrt{2^n})$ oracle calls (cf. Theorem 14), to bound the error to 2^{-\\frac{n}{2}-\\frac{1}{2}} with probability $\\approx\\frac{11}{12}$, while any classical algorithm takes $\\Theta(2^n)$ oracle calls, thus achieving a quadratic speedup.\nExisting approaches for WMC (knowledge compilation (Darwiche and Marquis, 2002; Lagniez and Marquis, 2017; Huang et al, 2006), backtracking search (Bacchus"}, {"title": "Weighted Constrained Sampling and Weighted Model Counting", "content": "Let X be a vector of n Boolean variables $[X_1,..., X_n]$ and let x be an assignment of values to X, i.e., a vector of n Boolean values $[x_1,...,x_n]$. We call x a world, a configuration or an assignment. Consider a propositional logic formula $\\phi$ over X built from the standard propositional connectives $[\\,\\neg, \\land, \\lor, \\rightarrow, \\leftrightarrow, \\oplus,]$ (not, and, or, imply, iff, xor). If an assignment x of variables X makes formula $\\phi$ evaluate to true, we write $x \\models \\phi$ and we say that x satisfies $\\phi$ or that x is a model of $\\phi$. Let us call M the number of models. We can also see $\\phi$ as a function from $B^n$ to B, where B = {0,1}, and express that x makes $\\phi$ evaluate to true by $\\phi(x) = 1$.\nThe Satisfiability problem (SAT) is the problem of deciding whether a formula $\\phi$ has a model, i.e., whether M > 0. The Functional Satisfiability Problem (FSAT) is defined as: given a formula $\\phi$, return an assignment x that is a model of $\\phi$ or answer NO if no such assignment exists. The problem of Model Counting (#SAT) (Gomes et al, 2009) is the problem of computing M.\nThe problem of Constrained Sampling (CS) (Meel et al, 2016) consists of sampling configurations x with a uniform distribution given that $\\phi(x) = 1$. In other words, we"}, {"title": "Quantum Search", "content": "CS can be seen as a search problem: find a satisfying assignment of bits. A quantum algorithm for solving this problem was proposed in (Grover, 1996a,b, 1997). Here we follow the exposition of (Nielsen and Chuang, 2010) and (Hirvensalo, 2013).\nWe assume we have a black box quantum circuit that evaluates $\\phi$, called an oracle O, that is such that\n$O|x\\rangle = (-1)^{\\phi(x)} |x\\rangle$\ni.e., the oracle marks solutions to the search problems by changing the sign of the state. The oracle may use extra ancilla bits to do so.\nThe first gate of the search circuit applies the H gate to each qubit in register X. Since all qubits in register X start as |0) and the effect of H is to transform |0) to the state $\\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}}$, then register X is transformed to\n$|\\psi\\rangle = \\frac{(|0\\rangle+|1\\rangle)(|0\\rangle+|1\\rangle)...(|0\\rangle+|1\\rangle)}{\\sqrt{2}\\sqrt{2}..\\sqrt{2}} = \\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}} \\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}} \\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}}...\\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}}= \\frac{|000\\rangle+|001\\rangle+|010\\rangle+|011\\rangle+|100\\rangle+|101\\rangle+|110\\rangle+|111\\rangle}{\\sqrt{2^3}}=\\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle$\nwhere $N = 2^n$. This state is also called the uniform superposition state.\nThe Grover operator can be written as\n$G = H^{\\otimes n} (2 |0\\rangle \\langle 0| \u2013 I)H^{\\otimes n}O$\nSince $H^{\\dagger}= H$, G can be rewritten as\n$G = H^{\\otimes n}(2|0\\rangle \\langle 0| - I)(H^{\\otimes n})^{\\dagger}O = (2H^{\\otimes n} |0\\rangle \\langle 0| (H^{\\otimes n})^{\\dagger} \u2013 H^{\\otimes n}I(H^{\\otimes n})^{\\dagger}) O = (2 |\\psi\\rangle \\langle \\psi| \u2013 I)O$\nWe now show that the Grover operator is a rotation.\nLemma 1. The Grover operation applied to the uniform superposition state |\u03c8) rotates it by angle $2 arcsin \\sqrt{M/N}$ where M is the number of solutions of $\\phi(x) = 1$.\nProof. Consider the two states\n$|\\alpha\\rangle = \\frac{1}{\\sqrt{N-M}} \\sum_{x:\\phi(x)=0} |x\\rangle$\nThese two states are orthonormal because they do not share any computational basis state. The uniform superposition state |\u03c8) can be written as a linear combination of |\u03b1) and |\u03b2):\n$|\\psi\\rangle = \\sqrt{\\frac{N-M}{N}} |\\alpha\\rangle + \\sqrt{\\frac{M}{N}} |\\beta\\rangle$\nso |\u03c8) belongs to the plane defined by |\u03b1) and |\u03b2). In this plane, the effect of the oracle operation O is to perform a reflection about the vector |\u03b1) because O(|\u03b1\\rangle+|\u03b2)) = |\u03b1\\rangle - |\u03b2), see Figure 4.\nThe other component of the Grover operator, $2 |\\psi\\rangle \\langle \\psi|-I$, also performs a reflection in the plane defined by |\u03b1) and |\u03b2), about the vector |\u03c8). The overall effect is that of a rotation (Aharonov, 1999). If we define $cos \\theta = \\sqrt{(N \u2013 M)/N}$ and $sin \\theta = \\sqrt{M/N}$, then |\u03c8\\rangle = cos \u03b8|\u03b1\\rangle + sin \u03b8 |\u03b2\\rangle.\nFrom Figure 4 we can see that the rotation applied by G is by angle 2\u03b8, so\n$G|\\psi\\rangle = cos 3\u03b8 |\u03b1\\rangle + sin 3\u03b8 |\u03b2\\rangle$\nRepeated applications of G take the state to\n$G^k |\\psi\\rangle = cos(2k + 1)\u03b8 |\u03b1\\rangle + sin(2k + 1)\u03b8 |\u03b2\\rangle$.\nThese rotations bring the state of the system closer to |\u03b2). If we perform the right number of rotations, a measurement in the computational basis will produce one of the outcomes superposed in |\u03b2), i.e., a solution to the search problem, with a non-zero probability. Moreover, since the weights of the computational basis states superimposed in |\u03b2) are all equal, then the measurement produces one of solutions with equal probability, solving CS when Q = X."}, {"title": "Comparison of Quantum Search with Classical Algorithms", "content": "Let us discuss classical algorithms for solving FSAT under a black box model of compu-tation (Nielsen and Chuang, 2010), where the only knowledge we have of the Boolean function $\\phi$ is the ability to evaluate it given an assignment of the Boolean variables, i.e., we have an oracle that answers queries over $\\phi$ of the form \"given assignment x, is $\\phi(x)$ equal to 1?\"\nConsider first the case that M = 1. A deterministic algorithm for finding the single configuration x of n bits such that f(x) = 1 under the black box model clearly requires N = 2n evaluations of $\\phi$ in the worst case.\nLet us consider a probabilistic algorithm, i.e. an algorithm that returns the solution of the problem with probability p, with 0 < p < 1, and returns \"no answer\" with probability 1 \u2013 p.\nA classical probabilistic algorithm for solving the search problem with M = 1 is the following: take s samples of configurations of X with uniform probability. This can be performed by sampling each Boolean variable uniformly and combining the bit samples obtaining a configuration. Then, for each configurations, test whether it is a solution. If it is a solution, return it and stop. The probability of finding the single solution x is $\\frac{s}{N}$ so we need at least pN queries to find x with a probability at least p. We may think that using a sampling distribution different from uniform we may do better, but the following lemma proves that this is not true."}, {"title": "Quantum Weighted Constrained Sampling", "content": "Suppose first that the literal weights sum to 1, i.e., that $w(Xi) + w(\\neg Xi) = 1$ for all bits Xi.\nGiven a Boolean function $\\phi : B^n \\rightarrow B$, a weight function $w : L \\rightarrow [0,1]$ and set of variables Q, we want to sample values for the variables Q so that the probability of sampling configuration q is\n$P(q) = \\frac{\\sum_{y:\\phi(qy)=1} W_{qy}}{WMC(\\Phi, w)}$\nSuppose, without loss of generality, that the query bits Q come first and there are l of them, while there are and there are n-l bits in Y. Assume also that we add an extra bit Xn+1 So $X' = [X_1, ..., X_{n+1}], x' = [x_1,...,x_{n+1}], \\phi' = \\phi \\land X_{n+1}$. Let Y' be Y with the extra bit Xn+1, so overall Y' has n \u2212 l + 1 bits.\nWe perform quantum WCS by modifying the algorithm for quantum search, obtain-ing QWCS. The circuit for performing QWCS differs from the one in Figure 2 because the Hadamard operations applied to the lower register are replaced by rotations $R_y(\\theta_i)$"}, {"title": "Comparison of QWCS with Classical Algorithms", "content": "For classical probabilistic algorithms under a black box model of computation we have the following results.\nTheorem 11. Any classical probabilistic algorithm for solving WCS under the black box model of computation takes $\\Omega(\\frac{1}{WMC})$ oracle queries."}, {"title": "Quantum Model Counting", "content": "The algorithm for quantum model counting uses the quantum Fourier transform and phase estimation, so we review those first."}, {"title": "Quantum Fourier Transform", "content": "The discrete Fourier transform computes a vector of complex numbers $y_0, ..., y_{N-1}$ given a vector of complex numbers $x_0,..., x_{N-1}$ as follows\n$y_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} x_j e^{2\\pi i jk/N}$\nThe quantum Fourier transform (Coppersmith, 2002) is similar, it takes an orthonor-mal basis |0),..., |N \u2212 1) and transforms it as:\n$|j\\rangle \\rightarrow \\frac{1}{\\sqrt{N}} \\sum_{k=0}^{N-1} e^{2\\pi i jk/N}|k\\rangle$\nIt is a Fourier transform because the action on an arbitrary state is\n$\\sum_{j=0}^{N-1} x_j|j\\rangle \\rightarrow \\sum_{k=0}^{N-1} y_k|k\\rangle$\nwith $y_k$ as in the discrete Fourier transform.\nAssuming $N = 2^n$, the quantum Fourier transform can be given a product representation (Cleve et al, 1998; Griffiths and Niu, 1996):\n$|j_1... j_n\\rangle \\rightarrow  \\frac{1}{2^{n/2}} \\sum_{k=0}^{2^n-1} e^{2\\pi i jk/2^n} |k\\rangle =  \\frac{1}{2^{n/2}} \\sum_{k_1=0}^{1}... \\sum_{k_n=0}^{1} e^{2\\pi i j (\\sum_{l=1}^{n} k_1 2^{-l})} |k_1... k_n\\rangle = \\frac{1}{2^{n/2}} \\sum_{k_1=0}^{1}... \\sum_{k_n=0}^{1} \\Pi_{1=1}^{n}  e^{2\\pi i j k_1 2^{-1}} |k_1\\rangle = \\frac{1}{2^{n/2}} \\bigotimes_{l=1}^{n} \\sum_{k_l=0}^{1} e^{2\\pi i j k_l 2^{-l}} |k_l\\rangle = \\frac{1}{2^{n/2}} \\bigotimes_{l=1}^{n}(|0\\rangle + e^{2\\pi i 0.j_{l}j_{l+1}...j_n} |1\\rangle) = (|0\\rangle+e^{2\\pi i 0.j_1} |1\\rangle)(|0\\rangle+e^{2\\pi i 0.j_1j_2} |1\\rangle)\\cdots(|0\\rangle+e^{2\\pi i 0.j_1j_2...j_n} |1\\rangle)$"}, {"title": "Quantum Phase Estimation", "content": "In the problem of quantum phase estimation (Cleve et al, 1998), we are given an operator U and one of its eigenvectors |u) with eigenvalue \u03b52\u03c0\u03af\u03c6 and we want to find the value of \u03c6. We assume that we have black boxes that can prepare the state |u) and perform controlled-U2j operations for non negative integers j.\nPhase estimation uses two registers, one with t qubits initially in state |0) and the other with as many qubits as are necessary to store |u) that is also its initial state.\nThe first stage of phase estimation is shown in Figure 8. A controlled-U2j operation on control qubit b and target register in an eigenvector state u) of U acts as follows. If b is |0), U2j is not applied and the output is |0) |u). If b is |1), then U2j is applied to |u). Since |u) is an eigenvector of U, |u) is brought to e2\u03c0\u03af2j\u03c6 |u) and |1) |u) becomes \u20ac2\u03c0\u03af2j \u03c6|1) |u).\nThe result of the controlled-U2j operation on (H |0)) |u) = $\\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}}$ [u) is\n$\\frac{|0\\rangle + e^{2\\pi i 2^j\\varphi} |1\\rangle}{\\sqrt{2}}|u\\rangle$\nThus the final state of the first register after the first phase of phase estimation is\n$\\frac{1}{2^{t/2}}(|0\\rangle + e^{2\\pi i 2^{t-1}\\varphi} |1\\rangle) \\otimes (|0\\rangle + e^{2\\pi i 2^{t-2}\\varphi} |1\\rangle) ... (|0\\rangle + e^{2\\pi i 2^{0}\\varphi} |1\\rangle)$\nIf the phase can be represented with exactly t bits as \u03c6 = 0.\u03c61... \u03c6t, Eq. (18) can be rewritten as\n$\\frac{1}{2^{n/2}}(|0\\rangle + e^{2\\pi i 0.\\varphi_1} |1\\rangle) \\otimes (|0\\rangle + e^{2\\pi i 0.\\varphi_{1-1}\\varphi_t} |1\\rangle) \\otimes ... (|0\\rangle + e^{2\\pi i 0.\\varphi_1...\\varphi_t} |1\\rangle)$\nThis form is exactly the same as that of Eq. (17) so, if we apply the inverse of the Fourier transform, we obtain \u03c61... \u03c6t). The inverse of an operator is its adjoint so the overall phase estimation circuit is shown in Figure 9.\nIf \u03c6 cannot be represented exactly with t bits, the algorithm provides approxima-tion guarantees: if we want to approximate \u03c6 to m bits with probability of success at least 1 \u2013 \u03b5 we must choose t = m + [log2 (2+1/2\u03b5)] (see (Nielsen and Chuang, 2010) for the derivation of this formula)."}, {"title": "Quantum Counting", "content": "With quantum counting we want to count the number of solutions to the equation \u03c6(x) = 1 where \u03c6 is a Boolean function as above. In the notation we are using, it"}, {"title": "Comparison of Quantum Counting with Classical Algorithms", "content": "Let us now discuss the advantages of quantum counting with respect to classical counting under a black box model of computation where we only have an oracle that answers queries over \u03c6. We want to know what is the minimum number of evaluations that are needed to solve counting problems.\nA classical algorithm for probabilistically solving a model counting problem pro-ceeds by taking s samples uniformly from the search space. For each sample x, we query the oracle and we obtain a value Fi with i = 1,..., s, where Fi is 1 if \u03c6(x) = 1 and Fi is 0 if \u03c6(x) = 0. Then we can estimate the count as\n$S = N \\times \\frac{F}{s} = N \\frac{\\sum_{i=1}^{s} F_i}{s}$\nwhere $F = \\sum_{i=1}^{s} F_i$. Variable F is binomially distributed with s the number of trials and probability of success M/N where M is the model count of \u03c6. Therefore the mean of F is sM/N and the mean of S is (N/s)s(M/N) = M, so S is an unbiased estimate of M.\nThe following theorem appears as Exercise 6.13 in (Nielsen and Chuang, 2010). Here we present it together with a proof that is absent in (Nielsen and Chuang, 2010).\nTheorem 13. The complexity of the classical algorithm for estimating M with a probability of at least 3/4 within an accuracy of \u221aM is \u03a9(N) oracle calls.\nProof. We must prove that\n$P(s \\frac{M-c\\sqrt{M}}{N} < F < s \\frac{M + c\\sqrt{M}}{N}) > \\frac{3}{4}$\nWe have\n$P(s \\frac{M-c\\sqrt{M}}{N} < F < s \\frac{M + c\\sqrt{M}}{N}) = P(F < s \\frac{M+c\\sqrt{M}}{N}) -P(F < s \\frac{M-c\\sqrt{M}}{N})$\nFor a binomially distributed random variable k with number of trials s and probability of success p we have that (Feller, 1968):\n$P(k \\geq r) < \\frac{s(1-p)}{(r \u2013 sp)^2}$\nif r \u2265 sp. Moreover\n$P(k < r) < \\frac{(s - r)p}{(sp - r)^2}$\nif r < sp. Since P(k > r) = 1 \u2013 P(k < r), from (21) we have\n$1-P(k < r) \\leq \\frac{r(1-p)}{(r - sp)^2}$"}, {"title": "Discussion", "content": "The idea of using rotation gates to represent weights was first proposed in (Riguzzi, 2020) but the QWMC algorithm there contained an error: it used the regular Grover operator instead of the weighted Grover operator where H gates are replaced by Rot. This article fixes this problem and proposes one more algorithm, QWCS, for solving the weighted constrained sampling problem. This algorithm exploits the same trick of using rotations to represent weights and basically combines weighted searching together with projection on the variables of interest.\nWe have shown that QWMC has a complexity of $\\Theta(\\sqrt{2^n})$ evaluations of the Boolean formula, while QWCS solve its problem with a complexity of $O(2^{n/2} + 1/\\sqrt{WMC})$, where WMC is the normalized weighted model count of the formula. We have also shown that if we consider the Boolean formula as a black box that we can only query asking for the value of the function given the inputs, QWMC provides a quadratic speedup over classical algorithms with the same limitation. The black box setting may be of interest when the Boolean formula is given by a quantum physical system of which we don't know the internals. In that case the quantum algorithms can plug in the system directly, improving over classical algorithms.\nIn the majority of cases where we want to perform WMC, WCS, we know the Boolean formula and, assuming the cost of implementing the circuit is linear in the number n of variables, the complexity will be worse than classical algorithms for WMC, QWCS unless the treewidth of the model is larger than n/2.\nHowever, QWMC can also be used as a subroutine in the junction tree algorithm (Shenoy and Shafer, 1990; Lauritzen and Spiegelhalter, 1988): after the probabilities are propagated in the tree, the nodes, whose maximum size minus 1 is the treewidth, have to be processed to find the marginals of the individual variables. In this QWMC can help with a complexity of $\\Theta(\\sqrt{2^n})$ with n the number of variables in the node.\nIn general, the algorithms exploit quantum parallelism: all the models of the for-mula are superimposed in the quantum state of the system. Unfortunately, however,"}, {"title": "Conclusions", "content": "We have proposed quantum algorithms for performing WMC and WCS. The algo-rithms modify the quantum search and quantum counting algorithms by taking into account weights.\nUsing the black box model of computation, QWMC makes $\\Theta(\\sqrt{N})$ oracle calls to return a result whose errors is bounded by 2^{-\\frac{n}{2}-\\frac{1}{2}} with probability 11/12. By contrast, the best classical algorithm requires $\\Omega(N)$ calls to the oracle. Thus QWMC offers a quadratic speedup that may be useful, for example, for computing marginals for the variables of a tree node in the junction tree algorithm.\nSimilarly, QWCS requires $O(2^{n/2} + 1/\\sqrt{WMC})$ oracle queries, while classical prob-abilistic algorithms take $\\Omega(1/WMC)$ oracle queries under the black box model of computation, again providing a quadratic improvement.\nIn the future, we plan to investigate the influence of noise on the quality of the results."}, {"title": "A Introduction to Quantum Computing", "content": "Here we provide a brief introduction to quantum computing following (Nielsen and Chuang, 2010). The bit is at the basis of classical computing and has a single value, either 0 or 1. The quantum bit or qubit is a generalization of the bit and is at the basis of quantum computing. A qubit represents a state defined by a pair of complex numbers that can have various physical implementations. From a mathematical point of view, a qubit is a unit vector in the $C^2$ space, where C is the set of complex numbers, i.e.,\n$\\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}$\nwhere the normalization requirement is that $|\\alpha|^2 + |\\beta|^2 = 1$.\nQubits are represented using the Dirac notation, where |\u03c8) (read \u201cket psi\u201d) is a two dimensional column vector and \u3008\u03c8| (read \u201cbra psi\u201d) is a two dimensional com-plex conjugate row vector. The notation \u3008\u03c8|\u03c6\u3009 (read \u201cbraket\u201d) is the inner product of the $C^2$ space, i.e., it is the dot product between |\u03c6\u3009 and the complex conjugate |\u03c8\u3009\u2217. The special states |0\u3009 and |1\u3009 are called computational basis states and form the orthonormal basis\n$\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ and $\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$\nfor $C^2$. Any qubit state |\u03c8\u3009 can be expressed as a linear combination of the computational basis states:\n$|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle = \\alpha \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} + \\beta \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$\nIn this case we say that |\u03c8\u3009 is in a superposition of states |0\u3009 and |1\u3009. Note that computational basis state are orthonormal: \u30080|1\u3009 = \u30081|0\u3009 = 0."}, {"title": "Composite Systems", "content": "Whenever we have more than one qubit, we have a composite physical system (also called a quantum register) and the state space expands accordingly: for n qubits, their state is a unit vector in the $C^{2^n}$ space and there are $2^n$ computational basis states, e.g., if n = 2, the basis states are |00\u3009, |01\u3009, |10\u3009 and |11\u3009, and the state of the qubits can be written as\n$|\\psi\\rangle = \\alpha_{00} |00\\rangle + \\alpha_{00} |01\\rangle + \\alpha_{10} |10\\rangle + \\alpha_{11} |11\\rangle$\nwhere \u03b100,..., \u03b111 are complex numbers that form a unit length vector, i.e., such that |\u03b100|2 + |\u03b101|2 + |\u03b110|2 + |\u03b111|2 = 1. The state space of a composite physical system given the component physical systems can be obtained using the tensor product of the states of the components."}, {"title": "Measurement", "content": "One of the operations that can be performed on a quantum system is measurement. There are various types of measurements, the simplest is measurement in the compu-tational basis. When we have a qubit in the state |\u03c8\u3009 = \u03b1|0\u3009 + \u03b2|1\u3009 and we measure it in the computational basis, we obtain a classical bit as a result: 0 with probabil-ity |\u03b1|2 and 1 with probability |\u03b2|2. Since the states of qubits are unit vectors, then |\u03b1|2 + |\u03b2|2 = 1 and the probabilities of the outcomes are well-defined. We can also measure multi-qubit systems and in that case we obtain a vector of classical bits."}, {"title": "Density Operators", "content": "A qubit in a superposition state encodes uncertainty on the result of its measurement. In this case, the state is known with certainty, it is only the result of measurement that is uncertain. Sometimes we want to represent uncertainty also on the state of the system. For example, we may know that the system is in one of several states Vi\u3009, where i is an index, with respective probabilities pi. In this case we can represent the state of the system using a density operator \u03c1 defined by the equation\n$\\rho = \\sum_i pi |\\Psi_i\\rangle \\langle \\Psi_i|$\nso density operators are matrices. If the state |\u03c8\u3009 of a quantum system is known exactly, the system is said to be in a pure state and the density operator is simply \u03c1 = |\u03c8\u3009 \u3008\u03c8|. Otherwise, the system is said to be in a mixed state and that it is in a mixture of different pure states in the ensemble {(pi, |Vi\u3009)} for \u03c1."}, {"title": "Quantum Circuits", "content": "To present quantum algorithms, we use the quantum circuit model of computation, where each qubit corresponds to a wire and quantum gates are applied to sets of wires. Quantum gates are linear operators represented by matrices with complex elements that must be unitary. A matrix is unitary if MtM = I, where Mt is the adjoint or Hermitian conjugate of a matrix M, i.e., the complex conjugate transpose matrix Mt = (M\u2217)T. We start from gates operating on single qubits that are described by matrices belonging to C2\u00d72. For example, the quantum counterpart of the NOT Boolean gate for classical bits is the X gate, defined as\n$X = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}$\nand drawn in circuits as in Figure 12a. Quantum gates can also be defined by the effect they have on an orthonormal basis. For example, applying the X gate to the computational basis produces:\n$X |0\\rangle = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = |1\\rangle$\nand\n$X |1\\rangle = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = |0\\rangle$\nso X exchanges |0\u3009 and |1\u3009, justifying its role as the quantum counterpart of the NOT Boolean gate.\nThe Z gate (see Figure 12b) is defined as\n$Z = \\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\end{bmatrix}$\ni.e, it transforms |0\u3009 to Z |0\u3009 = |0\u3009 and |1\u3009 to Z |1\u3009 = \u2212 |1\u3009.\nThe Hadamard gate (see Figure 12c) is\n$H = \\frac{1}{\\sqrt{2}} \\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix}$\nand transforms |0\u3009 to H |0\u3009 = $\\frac{1}{\\sqrt{2}}$(|0\u3009 + |1\u3009) and |1\u3009 to H |1\u3009 = $\\frac{1}{\\sqrt{2}}$(|0\u3009 \u2013 |1\u3009).\nAnother useful gate is the parameterized Ry rotation gate (see Figure 12d)\n$R_y(\\theta) = \\begin{bmatrix} cos \\frac{0}{i sin  & cos \\frac\\theta}{2} \\end{bmatrix}$"}]}