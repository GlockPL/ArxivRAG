{"title": "TTT: A Temporal Refinement Heuristic for Tenuously Tractable Discrete Time Reachability Problems", "authors": ["Chelsea Sidrane", "Jana Tumova"], "abstract": "Reachable set computation is an important tool for analyzing control systems. Simulating a control system can show that the system is generally functioning as desired, but a formal tool like reachability analysis can provide a guarantee of correctness. For linear systems, reachability analysis is straightforward and fast, but as more complex components are added to the control system such as nonlinear dynamics or a neural network controller, reachability analysis may slow down or become overly con- servative. To address these challenges, much literature has focused on spatial refinement, e.g., tuning the discretiza- tion of the input sets and intermediate reachable sets. How- ever, this paper addresses a different dimension: temporal refinement. The basic idea of temporal refinement is to automatically choose when along the horizon of the reach- ability problem to execute slow symbolic queries which incur less approximation error versus fast concrete queries which incur more approximation error. Temporal refinement can be combined with other refinement approaches and offers an additional \"tuning knob\" with which to trade off tractability and tightness in approximate reachable set computation. Here, we introduce an automatic framework for performing temporal refinement and we demonstrate the effectiveness of this technique on computing approx- imate reachable sets for nonlinear systems with neural network control policies. We demonstrate the calculation of reachable sets of varying approximation error under vary- ing computational budget and show that our algorithm is able to generate approximate reachable sets with a similar amount of error to the baseline approach in 20-70% less time.", "sections": [{"title": "I. INTRODUCTION", "content": "Every controller needs to be analyzed for performance and reliability. Simulation is useful to get an idea of the general behavior of a control policy, but only formal analysis can guarantee correctness with respect to a model of the system and a specification. In this paper, we focus on reach-avoid specifications which dictate a goal set the system must reach and/or an avoid set it must not reach. For a given discrete time dynamical system with a control policy and set of possible starting states the forward reachable set at time t is the set of states that the system could reach t steps into the future. Given a final set instead of an initial set, the t-step backward reachable set is the set of states that will reach the final set after t steps. For simple settings like linear dynamical systems and convex polytopic initial sets reachability analysis is straightforward and fast [1]. However, many modern control systems operate on nonlinear systems [2], and increasingly contain neural network components. Reachability methods for such complex systems may not exist, and if they do they they almost always require under or over-approximation (also referred to as inner and outer approximation) of the reachable set as the exact set is not computable. It is desirable to produce tight reachable sets which have as little approximation error as possible, but this often trades off with tractability\u2014the computation time needed to compute the reachable set.\nThere have been many approaches in the reachability liter- ature to address tractability and tightness. One of the central concepts used is domain refinement [3], [4]. Domain refine- ment refers to splitting the domain into subsets, e.g., through gridding, and computing the reachable set for each subset. Without domain refinement, the reachable set approximation would be unusably loose, but if gridded too finely the problem can become intractable as there is then exponential complexity in the number of state dimensions.\nAnother concept that has been used in the reachability literature is decomposition [5], [6], [7]. Decomposition refers to re-writing the system dynamics into a collection of uncou- pled or loosely coupled subsystems. If e.g., using gridding to produce tight set approximations, fine gridding can then be used on each low dimensional subsystem without incurring the exponential cost of gridding the original high dimensional system.\nLastly, many methods make use of pre-specified template sets in order to speed up computation [8], [9], [10], [11]."}, {"title": "II. PROBLEM DEFINITION", "content": "Consider a discrete time dynamical system with state $x_t \\in \\mathbb{R}^d$ governed by update equation $x_{t+1} = f(x_t, \\tilde{u}_t)$ with $\\tilde{u}_t \\in \\mathbb{R}^m$. In this paper, we focus on nonlinear update functions $f$ but linear systems may also be considered. The control input $\\tilde{u}_t = c(x_t)$ comes from a feedback control policy.\nWe seek to compute the forward reachable sets $R_t$ of the controlled system at future timesteps $t \\in 1,2,3,....$ The forward reachable set at time $t_n$, $n$ steps into the future from time 0 is defined as follows:\n\n$R_n = \\{ x_n | x_n = f(x_{n-1}, c(x_{n-1})), \\\\\nx_{n-1} = f(x_{n-2}, c(x_{n-2})), \\\\ \\vdots \\\\ x_1 = f(x_0, c(x_0)), \\\\ x_0 \\in X_0 \\}$\n(1)\n\nwhere $X_0$ is the initial set of states. As aforementioned, methods exist to compute the exact reachable set $R_t$ for classes of linear or piecewise linear systems, but for arbitrary smooth nonlinear dynamics, approximation (over or under) must be used. In this paper we denote the overapproximate reachable set $\\bar{R}_t$ where $R_t \\subseteq \\bar{R}_t$. The overapproximation error $e$ at a given time $t$ is defined\n\n$e = \\frac{m(\\bar{R}_t)}{m(R_t)}$\n(2)\n\nwhere $m$ is an error metric and the desired value is $e = 1$. The error over a finite time horizon $t \\in \\{1 . . . n\\}$ is defined\n\n$e = \\frac{\\sum_{t=1}^{n}m(\\bar{R}_t)}{\\sum_{t=1}^{n}m(R_t)}$\n(3)\n\nThus the problem this paper addresses may be stated as follows. When performing finite time hybrid-symbolic reacha- bility analysis of $n$ steps for a discrete time dynamical system, algorithmically select points $t_i \\in \\{1,...,n\\}$ at which to perform symbolic reachability queries and select temporal depths $b_{steps} \\in \\{1...t_i\\}$ for those symbolic queries so as to minimize approximation error (eq. (3)) while adhering to a pre-specified computational budget $b$."}, {"title": "III. REFINEMENT ALGORITHM", "content": "At a high level, the algorithm begins in the \"search\" phase and searches for an estimate of the longest tractable temporal depth (symbolic horizon) $b_{steps}$. The algorithm then moves to a \u201cjump\u201d phase and performs symbolic queries of that temporal depth or shorter until the set at the desired final time $n$ has been reached. Alg. 1 provides more detail. In alg. 1, $X_0$ is the initial set for reachability analysis, $b$ is the time budget in seconds, and $q$ is a query object consisting of a dynamics function $f$, a neural network controller $c(x) := NN(x)$, a final time horizon $n$, a variable to store current temporal depth $h$, and various parameters (e.g., hyperparameters controlling tightness of the nonlinear overapproximation). The method returns $R$ a vector of reachable sets $R_t$, $\\forall t \\in [1 . . . n]$.\nThe motivation for the structure of the algorithm comes partially from the initial work on hybrid-symbolic reachabil- ity [8] which used long symbolic jumps with one-step concrete queries to generate the sets in between. Long symbolic jumps produce tight approximations of the reachable set and be- ginning symbolic jumps from tight approximations limits the wrapping effect. However, in this paper, a reasonable symbolic \"jump\" size is not known a priori so we first search for a long jump size. The search procedure also has the benefit of limiting reachable set growth. Small errors early in the time horizon compound over many timesteps, and because the search phase produces tight reachable sets for early steps, it limits error compounding.\nAlg. 1 begins in the \"search\" phase with a temporal depth of $b_{steps} = 1$ (line 3) beginning from the set $X_0$ at time $t_0$ (lines 4-5). A symbolic reachability query is then performed (lines 7-8), and the new set(s) are then logged (lines 9-13). If there is enough time budget to continue searching, $b_{steps}$ will increment by 1 (line 16). Symbolic reachable set computation queries are performed from the initial set $X_0$ at time $t_0$ to increasingly large temporal depths / numbers of steps $b_{steps}$ into the future until it is estimated that trying a temporal depth one step longer would put the entire reachable set procedure over budget. Once this occurs, the algorithm will enter the \"jump\" phase and perform symbolic queries beginning from the set at $t_{start} := t_{cur}$ (line 18-19) of temporal depth $b_{steps}$ or shorter until the set at the desired final time $n$ has been reached (line 6). Line 21 keeps $b_{steps}$ within correct range; and line 22 updates the early stopping timeout. The early stopping timeout limits budget overruns and is hand-tuned. The algorithm returns the reachable sets from time $t = 1... n$.\nOne of the key pieces of Algorithm 1 lies within the subroutine calc_steps (line 16) which determines whether to continue searching for a longer temporal depth $b_{steps}$ or to move to the \"jump\" phase. The complete algorithm for calc_steps is included in the Appendix (alg. 2) and described here. calc_steps first estimates the amount of time needed compute one symbolic step, $t_{est}$, assuming that the time to compute a symbolic query of $m$ steps is roughly $t_{est} * m$. This is a simplification that is not strictly accurate \u2013 the time a symbolic query takes may be in the worst case exponential in temporal depth for some problems and timing depends on the particular input set \u2013 but it leads to roughly accurate budgeting given that $t_{est}$ is updated at each iteration. The algorithm then estimates the time that future queries will take and uses this to determine if there is enough time budget to continue searching. This time estimate includes a symbolic query from $t_0$ to $b_{steps} + 1$ plus the time to finish finish the temporal horizon in the \"jump\" phase. If the remaining budget $b$ is large enough, the algorithm increments $b_{steps} \\leftarrow b_{steps} + 1$ and if not, the algorithm enters the \"jump\" phase. Finally, if the solver stops early, the phase is also switched to \"jump\". The early stopping is used to ensure the budget is approximately respected given that the estimated time per symbolic step $t_{est}$ is not an upper bound.\nNote that long symbolic queries generally produce tight reachable sets but shorter queries can produce tighter sets if the starting set of the shorter query is tighter itself."}, {"title": "IV. OVERAPPROXIMATE FORWARD REACHABILITY", "content": "Our refinement algorithm is applicable to both forwards and backwards reachability and both over (outer) and under (inner) approximation but in this paper, we demonstrate our refinement algorithm on overapproximate forward reachability of nonlinear neural feedback loops (NFLs). In particular, we use the reachability approach presented in [8]. To briefly sum- marize, the approach computes tight piecewise linear bounds for smooth nonlinear functions in the dynamics and then en- codes these bounds as well as the ReLU neural network control policy into a mixed integer linear program. A hyperrectangular template set is then optimized to obtain an overapproximation of the reachable set. The mixture of symbolic and concrete queries is determined by the refinement algorithm presented here, but the procedure to approximate nonlinear functions and compute approximate reachable sets using mixed integer programs comes from [8] where further details can be found."}, {"title": "V. SOUNDNESS, COMPLETENESS, COMPLEXITY", "content": "The algorithm is sound, i.e. $R_t \\subseteq \\bar{R}_t$, for all $t$, following directly from the soundness of [8]. In terms of complete- ness, the algorithm presented here does not guarantee that the overapproximate reachable sets $\\bar{R}_t$ converge to the true reachable sets $R_t$. The method presented here could in theory be combined with methods that provably converge to the true reachable set for some classes of nonlinear systems [19] to overcome this limitation, but completeness in this sense is beyond the scope of this paper.\nThe algorithm is guaranteed to produce a sequence of reachable sets as even with early stopping, the algorithm will extend the compute time until a finite feasible solution with $< 50\\%$ relative duality gap has been found. The algorithm is guaranteed to terminate under the mild assumption that a feasible solution with $< 50\\%$ relative duality gap exists.\nThe time complexity of this algorithm is in the worst case NP-hard as it involves solving mixed integer linear programs. However, the average case complexity is in practice more reasonable as is demonstrated in the results section."}, {"title": "VI. NUMERICAL EXPERIMENTS", "content": "Numerical experiments were run on examples taken from [8], [20] to assess the tightness and computational speed of the temporal refinement algorithm. Four problems were used: the pendulum dynamical system with a controller of 2 layers, 25 neurons per layer (S1); the TORA dynamical system with a controller of 3 layers, 25 neurons per layer (T1); the car dynamical system with a controller of 1 layer with 100 neurons (C1) and a controller of 1 layer with 200 neurons (C2). The reader is referred to [8] for the details on the neural network controlled dynamical systems."}, {"title": "A. Results", "content": "The temporal refinement algorithm was run multiple times to assess how changing the time budget changes the approxi- mate reachable set error. Figure 3 measures the approximation error of the sets computed by the optimizer using the ratio of the sum of volumes:\n\n$e_{total} = \\frac{\\sum_{t=1}^{n} vol(\\bar{R}_t)}{\\sum_{t=1}^{n} vol(R_t)}$\n(4)\n\nIn fig. 3, one can observe that the approximate error generally decreases with increasing budget. Note that the trend is not monotonic because the algorithm is a heuristic.\nWe compare our algorithm to the hand tuned hybrid sym- bolic approach used in [8] which is represented in fig. 3 as dotted lines. One might expect that the hand tuned approach would produce approximate reachable sets more quickly for a given amount of error. A significant amount of work was presumably done offline to identify good symbolic intervals that must instead be identified at runtime with our approach. However, it turns out that our heuristic can actually produce approximate reachable sets with similar amounts of error as the hand-tuned approach in 20-70% less time, as shown in fig. 3. Furthermore, our approach is able to produce reachable sets for some problems such as the pendulum problem S1 that have 40% less error than the hand-tuned approach when allowed to compute for longer than the time taken by the hand-tuned approach.\nWe also compare sets produced by our algorithm to concrete one step reachable sets. Using one step sets is fast but leads to large approximation error. Examples of the reachable sets computed by our algorithm and baselines can be seen in fig. 4 and fig. 5. Set are compared both using eq. (4) as well as the ratio of the sum of radii:\n\n$e_{total} = \\frac{\\sum_{t=1}^{n} (\\sum_{i=1}^{d} radius(\\bar{R}_{t,i}))}{\\sum_{t=1}^{n} (\\sum_{i=1}^{d} radius(R_{t,i}))}$\n(5)\n\nOne step concrete sets are labeled 'naive' and one can observe that every set produced by our approach is equal to or tighter than those produced with the naive approach. To compare to the hand-tuned approach, we select a run from fig. 3 that had roughly equivalent or less error in a smaller amount of time and calculate the increase in speed by our approach. For the runs selected in fig. 4 and fig. 5, not every set produced by our approach is tighter than sets produced by the hand tuned approach, but when error is calculated over all sets in the trajectory, the total error is roughly equal or smaller. For pendulum problem S1 featured fig. 4, our algorithm is 20.9% faster than the hand-tuned approach for less error by both radius and volume metrics, and for the TORA problem T1 featured in fig. 5, our algorithm is 24% faster for an \u2248 equal amount of error (1.5% less error according to the ratio metric and 1.2% more error according to the volume metric).\nIn fig. 6, we display numerical results for the remaining problems, car problems C1 and C2. For C1 and C2, we select runs that have less error by both radius and volume metrics and are respectively 70.8% faster and 65.2% faster, which translates to 4.7 minutes faster and 4.1 minutes faster.\nLastly, our code will be released as an open source tool and be available here."}, {"title": "B. Limitations", "content": "The approach described here has limitations related to budgeting. A poor choice of initial solution from optimizer can lead to budget overruns as the algorithm will continue to compute if a finite solution has not yet been found. Further, budgeting with the linear time approximation as described is not accurate for all reachability problems, leading to budget overruns and/or conservative solutions for some problems; which may be exacerbated by long horizon queries. As pre- viously mentioned, our algorithm is a heuristic. There does not exist a guarantee that given two budgets $b_A > b_B$ the sets produced with budget $b_A$ will be tighter than those produced using $b_B$."}, {"title": "VII. CONCLUSION", "content": "In this paper we have introduced an algorithm for temporal refinement of tenuously tractable discrete time reachability problems. The algorithm computes reachable sets using con- straints from several timesteps at once in order to produce tighter sets. The temporal depth of timestep constraints con- sidered for a given reachable set is calculated based upon remaining computational budget and estimated future com- putation. The algorithm introduced here makes it possible to do hybrid-symbolic reachability without hand tuning concrete and symbolic intervals. We demonstrated this algorithm on a difficult class of reachability problems: nonlinear dynamical systems with neural network control policies, and demon- strated that it is able to produce reachable sets of varying error given varying computational budget. Additionally, it is able to produce reachable sets 20-70% faster then hand tuned approaches for the same amount of error. Ultimately, this algorithm and associated open-source code represent tools to enable more efficient reachability analysis for complex control systems."}, {"title": "APPENDIX", "content": "Algorithm 2, calc_steps, calculates the next symbolic query for alg. 1. In line 2 of alg. 2, calc_steps calculates the time index of the current step, $t_{cur}$, and then in line 3, calc_steps makes a conservative estimate of the amount of time needed compute one symbolic step, $t_{est}$. If previously, $phase$ = \"search\", (line 4), and we have not stopped early (line 5), we will estimate if there is enough time budget to continue searching (line 6).\nTo estimate if there is enough time budget to continue searching, we must estimate the time that future symbolic queries will take. Assuming that the time it takes to perform 1 symbolic step is roughly constant ($t_{est}$) and that we are in the search phase, the last symbolic query was from step 0 of length $b_{steps}$, and the time cost of a potential next query from time 0 to time $b_{steps} +1$ is $\\approx t_{est}* (b_{steps} +1)$. At any given time, the total remaining computational cost of primary_refinement is the cost of the next search step plus the cost of symbolic jumps to finish the time horizon in the \u201cjump\u201d phase which can be estimated as taking time $(n- (t_{cur}+1))*t_{est}$. As $t_{cur} = b_{steps}$ during the search phase, the total time estimate for one further symbolic query from 0 to $b_{steps} + 1$ plus jumps from $b_{steps} + 1$ to n is then $t_{est} * (b_{steps} + 1) + (n \u2013 (b_{steps} + 1)) * t_{est} = n * t_{est}$ (see line 6).\nThis estimate assumes that the time to compute $m$ symbolic steps is roughly $t_{est} * m$ regardless of whether those steps are computed in 2 symbolic queries of size $t_{est}*m$ or 10 symbolic queries of size $t_{est}*m$. This is a simplification we make that is not strictly accurate \u2013 the time a symbolic query takes may be exponential in temporal depth for some problems and timing depends on the particular input set \u2013 but it leads to roughly accurate budgeting given that $t_{est}$ is updated at each iteration.\nIf the remaining budget $b$ does allow for continued search, $b_{steps}$ is incremented (alg. 2 line 7). If not, we instead calculate a reasonable temporal query depth for finishing the remaining steps of the reachability problem in the jump phase (lines 8- 13). One could use jumps of size $b_{steps}$ but if n is not divisible or close to divisible by $b_{steps}$ this could lead to a short jump at the end of the horizon and a loose final set. Instead, we calculate the $num$ jumps needed to finish the time horizon in jumps of size $b_{steps}$ (line 9-10) and instead use jumps of size $\\lceil \\frac{n}{num jumps} \\rceil$ (line 11) which makes all the jumps closer in size.\nIf the solver has stopped early (line 14), the phase is switched to \"jump\u201d (line 18) and a similar calculation is performed to estimate the jump size (lines 15-17) with the difference being $num_jumps$ is calculated using $b_{steps}$ instead of $b_{steps}$ (line 16). If we are already in the \u201cjump\u201d phase (line 20) we do not change the jump size of $b_{steps}$ unless we stop early (line 21) in which case we decrement $b_{steps}$ by 1 (line 22). The early stopping is used to ensure the budget is approximately respected given that the estimated time per symbolic step $t_{est}$ is not an upper bound."}]}