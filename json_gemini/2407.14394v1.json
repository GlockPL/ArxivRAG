{"title": "TTT: A Temporal Refinement Heuristic for Tenuously Tractable Discrete Time Reachability Problems", "authors": ["Chelsea Sidrane", "Jana Tumova"], "abstract": "Reachable set computation is an important tool for analyzing control systems. Simulating a control system can show that the system is generally functioning as desired, but a formal tool like reachability analysis can provide a guarantee of correctness. For linear systems, reachability analysis is straightforward and fast, but as more complex components are added to the control system such as nonlinear dynamics or a neural network controller, reachability analysis may slow down or become overly con-servative. To address these challenges, much literature has focused on spatial refinement, e.g., tuning the discretization of the input sets and intermediate reachable sets. However, this paper addresses a different dimension: temporal refinement. The basic idea of temporal refinement is to automatically choose when along the horizon of the reachability problem to execute slow symbolic queries which incur less approximation error versus fast concrete queries which incur more approximation error. Temporal refinement can be combined with other refinement approaches and offers an additional \"tuning knob\" with which to trade off tractability and tightness in approximate reachable set computation. Here, we introduce an automatic framework for performing temporal refinement and we demonstrate the effectiveness of this technique on computing approximate reachable sets for nonlinear systems with neural network control policies. We demonstrate the calculation of reachable sets of varying approximation error under vary-ing computational budget and show that our algorithm is able to generate approximate reachable sets with a similar amount of error to the baseline approach in 20-70% less time.", "sections": [{"title": "I. INTRODUCTION", "content": "Every controller needs to be analyzed for performance and reliability. Simulation is useful to get an idea of the general behavior of a control policy, but only formal analysis can guarantee correctness with respect to a model of the system and a specification. In this paper, we focus on reach-avoid specifications which dictate a goal set the system must reach and/or an avoid set it must not reach. For a given discrete time dynamical system with a control policy and set of possible starting states the forward reachable set at time t is the set of states that the system could reach t steps into the future. Given a final set instead of an initial set, the t-step backward reachable set is the set of states that will reach the final set after t steps. For simple settings like linear dynamical systems and convex polytopic initial sets reachability analysis is straightforward and fast [1]. However, many modern control systems operate on nonlinear systems [2], and increasingly contain neural network components. Reachability methods for such complex systems may not exist, and if they do they they almost always require under or over-approximation (also referred to as inner and outer approximation) of the reachable set as the exact set is not computable. It is desirable to produce tight reachable sets which have as little approximation error as possible, but this often trades off with tractability \u2013 the computation time needed to compute the reachable set.\nThere have been many approaches in the reachability liter-ature to address tractability and tightness. One of the central concepts used is domain refinement [3], [4]. Domain refine-ment refers to splitting the domain into subsets, e.g., through gridding, and computing the reachable set for each subset. Without domain refinement, the reachable set approximation would be unusably loose, but if gridded too finely the problem can become intractable as there is then exponential complexity in the number of state dimensions.\nAnother concept that has been used in the reachability literature is decomposition [5], [6], [7]. Decomposition refers to re-writing the system dynamics into a collection of uncou-pled or loosely coupled subsystems. If e.g., using gridding to produce tight set approximations, fine gridding can then be used on each low dimensional subsystem without incurring the exponential cost of gridding the original high dimensional system.\nLastly, many methods make use of pre-specified template sets in order to speed up computation [8], [9], [10], [11]. In these methods, the tightest circumscribing (or inscribing) set of a particular type such as a hyperrectangle, ellipsoid, or zonotope is computed rather than computing the arbitrary non-convex true reachable set.\nIn this work we make use of a concept known as symbolic reachability [8] to define an algorithm for temporal refinement. Many verification methods use concrete reachability which involves computing the approximate reachable set at time t + 1 using only the approximate reachable set at time t, ort\u22121 from t in the backward case [12]. While concrete reachability is fast, it accumulates large approximation error quickly, a phenomenon known as the \u201cwrapping effect\u201d [13]. Symbolic reachability can be used to mitigate this effect [8]. Using symbolic reachability, the approximate reachable set at e.g., time t + 2 is computed from the set at time t while implicitly constraining the system trajectories to pass through the intermediate set at time t+1 (fig. 1). This results in tighter sets than if the set at t + 2 was computed using only the approximate set at time t+1. It is possible to perform symbolic reachability for limited time horizons (temporal depths), each iteration computing a set farther into the future (or further in the past) and implicitly constraining system trajectories to pass through all sets at timesteps in between, but the problem will quickly approach intractability. To address this tradeoff between tightness and tractability, the authors of [8] perform hybrid-symbolic reachability which uses mixtures of concrete and symbolic computations in a hand-tuned, ad-hoc manner.\nIn this paper, we contribute a temporal refinement algorithm to automate hybrid-symbolic reachability analysis for tenu-ously tractable discrete-time dynamical systems. The temporal depth and end timestep of each query are automatically selected to produce tight reachable sets given the remaining computational budget and projected total computation length. Our algorithm is an orthogonal contribution to existing strate-gies for balancing tightness and tractability because it may be combined with concepts such as domain refinement, system decomposition, and pre-specified template sets; among others. We demonstrate our algorithm for temporal refinement on overapproximate forward reachability analysis, but it is similarly applicable to backward reachability analysis and underapproximation. Specifically, we treat a challenging class of problems: computing forward reachable sets for discrete time nonlinear dynamical systems with neural network control policies; also called Neural Feedback Loops (NFLs). For this class of problem, there has been work on computing forward reachable sets [8], backward reachable sets [15], performing domain refinement [16], [4], [17], and using exotic tem-plate polyhedron [18] but there remains difficulty balancing tractability and tightness making it a good class of problem on which to demonstrate our technique. We use several examples from the literature and show that our approach can produce"}, {"title": "II. PROBLEM DEFINITION", "content": "Consider a discrete time dynamical system with state xt \u2208\nRd governed by update equation xt+1 = f(xt, \u0169t) with \u0169t \u2208\nRm. In this paper, we focus on nonlinear update functions f\nbut linear systems may also be considered. The control input\n\u0169t = c(xt) comes from a feedback control policy.\nWe seek to compute the forward reachable sets Rt of the\ncontrolled system at future timesteps t \u2208 1,2,3,.... The\nforward reachable set at time tn, n steps into the future from\ntime 0 is defined as follows:\n$$R_n \\triangleq \\{\nx_n \\mid x_n = f(x_{n-1}, c(x_{n-1})),\nx_{n-1} = f(x_{n-2}, c(x_{n-2})),\n\\vdots\nx_1 = f(x_0, c(x_0)),\nx_0 \\in X_0\n\\}\n$$\nwhere X0 is the initial set of states. As aforementioned,\nmethods exist to compute the exact reachable set Rt for classes\nof linear or piecewise linear systems, but for arbitrary smooth\nnonlinear dynamics, approximation (over or under) must be\nused. In this paper we denote the overapproximate reachable\nset Rt where Rt \u2286 Rt. The overapproximation error e at a\ngiven time t is defined\n$$e = \\frac{m(\\tilde{R}_t)}{m(R_t)}$$\nwhere m is an error metric and the desired value is e = 1.\nThe error over a finite time horizon t \u2208 {1 . . . n} is defined\n$$e = \\frac{\\Sigma_{\\tau=1}^t m(\\tilde{R}_{\\tau})}{\\Sigma_{\\tau=1}^t m(R_{\\tau})}$$\nThus the problem this paper addresses may be stated as\nfollows. When performing finite time hybrid-symbolic reacha-bility analysis of n steps for a discrete time dynamical system,\nalgorithmically select points ti \u2208 {1,...,n} at which to\nperform symbolic reachability queries and select temporal\ndepths bsteps \u2208 {1...ti} for those symbolic queries so as to\nminimize approximation error (eq. (3)) while adhering to a\npre-specified computational budget b."}, {"title": "III. REFINEMENT ALGORITHM", "content": "At a high level, the algorithm begins in the \"search\" phase\nand searches for an estimate of the longest tractable temporal\ndepth (symbolic horizon) bsteps. The algorithm then moves to a\n\u201cjump\u201d phase and performs symbolic queries of that temporal\ndepth or shorter until the set at the desired final time n has been\nreached. Alg. 1 provides more detail. In alg. 1, X0 is the initial\nset for reachability analysis, b is the time budget in seconds,\nand q is a query object consisting of a dynamics function f, a\nneural network controller c(x) := NN(x), a final time horizon\nn, a variable to store current temporal depth h, and various\nparameters (e.g., hyperparameters controlling tightness of the\nnonlinear overapproximation). The method returns R a vector\nof reachable sets Rt, \u2200t \u2208 [1 . . . n].\nThe motivation for the structure of the algorithm comes\npartially from the initial work on hybrid-symbolic reachabil-ity [8] which used long symbolic jumps with one-step concrete\nqueries to generate the sets in between. Long symbolic jumps\nproduce tight approximations of the reachable set and be-ginning symbolic jumps from tight approximations limits the\nwrapping effect. However, in this paper, a reasonable symbolic\n\"jump\" size is not known a priori so we first search for a long\njump size. The search procedure also has the benefit of limiting\nreachable set growth. Small errors early in the time horizon\ncompound over many timesteps, and because the search phase\nproduces tight reachable sets for early steps, it limits error\ncompounding.\nAlg. 1 begins in the \"search\" phase with a temporal depth\nof bsteps = 1 (line 3) beginning from the set X0 at time t0\n(lines 4-5). A symbolic reachability query is then performed\n(lines 7-8), and the new set(s) are then logged (lines 9-13). If\nthere is enough time budget to continue searching, bsteps will\nincrement by 1 (line 16). Symbolic reachable set computation\nqueries are performed from the initial set X0 at time t0 to\nincreasingly large temporal depths / numbers of steps bsteps into\nthe future until it is estimated that trying a temporal depth one\nstep longer would put the entire reachable set procedure over\nbudget. Once this occurs, the algorithm will enter the \"jump\"\nphase and perform symbolic queries beginning from the set at\ntstart := tcur (line 18-19) of temporal depth bsteps or shorter until\nthe set at the desired final time n has been reached (line 6).\nLine 21 keeps bsteps within correct range; and line 22 updates\nthe early stopping timeout. The early stopping timeout limits\nbudget overruns and is hand-tuned. The algorithm returns the\nOne of the key pieces of Algorithm 1 lies within the\nsubroutine calc_steps (line 16) which determines whether to\ncontinue searching for a longer temporal depth bsteps or to move\nto the \"jump\" phase. The complete algorithm for calc_steps\nis included in the Appendix (alg. 2) and described here.\ncalc_steps first estimates the amount of time needed compute\none symbolic step, test, assuming that the time to compute\na symbolic query of m steps is roughly test * m. This is a\nsimplification that is not strictly accurate \u2013 the time a symbolic\nquery takes may be in the worst case exponential in temporal\ndepth for some problems and timing depends on the particular\ninput set \u2013 but it leads to roughly accurate budgeting given that\ntest is updated at each iteration. The algorithm then estimates\nthe time that future queries will take and uses this to determine\nif there is enough time budget to continue searching. This time\nestimate includes a symbolic query from t0 to bsteps + 1 plus\nthe time to finish finish the temporal horizon in the \"jump\"\nphase. If the remaining budget b is large enough, the algorithm\nincrements bsteps \u2190 bsteps + 1 and if not, the algorithm enters\nthe \"jump\" phase. Finally, if the solver stops early, the phase is\nalso switched to \"jump\". The early stopping is used to ensure\nthe budget is approximately respected given that the estimated\ntime per symbolic step test is not an upper bound.\nNote that long symbolic queries generally produce tight\nreachable sets but shorter queries can produce tighter sets if\nthe starting set of the shorter query is tighter itself."}, {"title": "IV. OVERAPPROXIMATE FORWARD REACHABILITY", "content": "Our refinement algorithm is applicable to both forwards and backwards reachability and both over (outer) and under (inner) approximation but in this paper, we demonstrate our refinement algorithm on overapproximate forward reachability of nonlinear neural feedback loops (NFLs). In particular, we use the reachability approach presented in [8]. To briefly sum-marize, the approach computes tight piecewise linear bounds for smooth nonlinear functions in the dynamics and then encodes these bounds as well as the ReLU neural network control policy into a mixed integer linear program. A hyperrectangular template set is then optimized to obtain an overapproximation of the reachable set. The mixture of symbolic and concrete queries is determined by the refinement algorithm presented here, but the procedure to approximate nonlinear functions and compute approximate reachable sets using mixed integer programs comes from [8] where further details can be found."}, {"title": "V. SOUNDNESS, COMPLETENESS, COMPLEXITY", "content": "The algorithm is sound, i.e. Rt \u2286 Rt, for all t, following directly from the soundness of [8]. In terms of complete-ness, the algorithm presented here does not guarantee that the overapproximate reachable sets Rt converge to the true reachable sets Rt. The method presented here could in theory be combined with methods that provably converge to the true reachable set for some classes of nonlinear systems [19] to overcome this limitation, but completeness in this sense is beyond the scope of this paper.\nThe algorithm is guaranteed to produce a sequence of reachable sets as even with early stopping, the algorithm will extend the compute time until a finite feasible solution with < 50% relative duality gap has been found. The algorithm is guaranteed to terminate under the mild assumption that a feasible solution with < 50% relative duality gap exists.\nThe time complexity of this algorithm is in the worst case NP-hard as it involves solving mixed integer linear programs. However, the average case complexity is in practice more reasonable as is demonstrated in the results section."}, {"title": "VI. NUMERICAL EXPERIMENTS", "content": "Numerical experiments were run on examples taken from [8], [20] to assess the tightness and computational speed of the temporal refinement algorithm. Four problems were used: the pendulum dynamical system with a controller of 2 layers, 25 neurons per layer (S1); the TORA dynamical system with a controller of 3 layers, 25 neurons per layer (T1); the car dynamical system with a controller of 1 layer with 100 neurons (C1) and a controller of 1 layer with 200 neurons (C2). The reader is referred to [8] for the details on the neural network controlled dynamical systems."}, {"title": "A. Results", "content": "The temporal refinement algorithm was run multiple times to assess how changing the time budget changes the approxi-mate reachable set error. Figure 3 measures the approximation error of the sets computed by the optimizer using the ratio of the sum of volumes:\n$$e_{total} = \\frac{\\Sigma_{t=1}^n vol(\\tilde{R}_t)}{\\Sigma_{t=1}^n vol(R_t)}$$\nIn fig. 3, one can observe that the approximate error generally decreases with increasing budget. Note that the trend is not monotonic because the algorithm is a heuristic.\nWe compare our algorithm to the hand tuned hybrid sym-bolic approach used in [8] which is represented in fig. 3 as dotted lines. One might expect that the hand tuned approach would produce approximate reachable sets more quickly for a given amount of error. A significant amount of work was presumably done offline to identify good symbolic intervals that must instead be identified at runtime with our approach. However, it turns out that our heuristic can actually produce approximate reachable sets with similar amounts of error as the hand-tuned approach in 20-70% less time, as shown in fig. 3. Furthermore, our approach is able to produce reachable sets for some problems such as the pendulum problem S1 that have 40% less error than the hand-tuned approach when allowed to compute for longer than the time taken by the hand-tuned approach.\nWe also compare sets produced by our algorithm to concrete one step reachable sets. Using one step sets is fast but leads to large approximation error. Examples of the reachable sets computed by our algorithm and baselines can be seen in fig. 4 and fig. 5. Set are compared both using eq. (4) as well as the ratio of the sum of radii:\n$$e_{total} = \\frac{\\Sigma_{t=1}^d (\\Sigma_{i=1}^d radius(\\tilde{R}_t))}{\\Sigma_{t=1}^d (\\Sigma_{i=1}^d radius(R_t))}$$\nOne step concrete sets are labeled 'naive' and one can observe that every set produced by our approach is equal to or tighter than those produced with the naive approach. To compare to the hand-tuned approach, we select a run from fig. 3 that had roughly equivalent or less error in a smaller amount of time and calculate the increase in speed by our approach. For the runs selected in fig. 4 and fig. 5, not every set produced by our approach is tighter than sets produced by the hand tuned approach, but when error is calculated over all sets in the trajectory, the total error is roughly equal or smaller. For pendulum problem S1 featured fig. 4, our algorithm is 20.9% faster than the hand-tuned approach for less error by both radius and volume metrics, and for the TORA problem T1 featured in fig. 5, our algorithm is 24% faster for an \u2248 equal amount of error (1.5% less error according to the ratio metric and 1.2% more error according to the volume metric).\nIn fig. 6, we display numerical results for the remaining problems, car problems C1 and C2. For C1 and C2, we select runs that have less error by both radius and volume metrics and are respectively 70.8% faster and 65.2% faster, which translates to 4.7 minutes faster and 4.1 minutes faster.\nLastly, our code will be released as an open source tool and be available here."}, {"title": "B. Limitations", "content": "The approach described here has limitations related to budgeting. A poor choice of initial solution from optimizer can lead to budget overruns as the algorithm will continue to compute if a finite solution has not yet been found. Further, budgeting with the linear time approximation as described is not accurate for all reachability problems, leading to budget overruns and/or conservative solutions for some problems; which may be exacerbated by long horizon queries. As pre-viously mentioned, our algorithm is a heuristic. There does not exist a guarantee that given two budgets ba > bB the sets produced with budget ba will be tighter than those produced using bB."}, {"title": "VII. CONCLUSION", "content": "In this paper we have introduced an algorithm for temporal refinement of tenuously tractable discrete time reachability problems. The algorithm computes reachable sets using con-straints from several timesteps at once in order to produce\ntighter sets. The temporal depth of timestep constraints con-sidered for a given reachable set is calculated based upon remaining computational budget and estimated future com-putation. The algorithm introduced here makes it possible to do hybrid-symbolic reachability without hand tuning concrete and symbolic intervals. We demonstrated this algorithm on a difficult class of reachability problems: nonlinear dynamical systems with neural network control policies, and demon-strated that it is able to produce reachable sets of varying error given varying computational budget. Additionally, it is able to produce reachable sets 20-70% faster then hand tuned approaches for the same amount of error. Ultimately, this algorithm and associated open-source code represent tools to enable more efficient reachability analysis for complex control systems."}, {"title": "APPENDIX", "content": "A. Calculating temporal depth for Algorithm ??\nAlgorithm 2, calc_steps, calculates the next symbolic query for alg. 1. In line 2 of alg. 2, calc_steps calculates the time index of the current step, tcur, and then in line 3, calc_steps makes a conservative estimate of the amount of time needed compute one symbolic step, test. If previously, phase = \"search\", (line 4), and we have not stopped early (line 5), we will estimate if there is enough time budget to continue searching (line 6).\nTo estimate if there is enough time budget to continue searching, we must estimate the time that future symbolic queries will take. Assuming that the time it takes to perform 1 symbolic step is roughly constant (test) and that we are in the search phase, the last symbolic query was from step 0 of length bsteps, and the time cost of a potential next query from time 0 to time bsteps +1 is \u2248 test* (bsteps +1). At any given time, the total remaining computational cost of primary_refinement is the cost of the next search step plus the cost of symbolic jumps to finish the time horizon in the \u201cjump\u201d phase which can be estimated as taking time (n- (tcur+1))*test. As tcur = bsteps during the search phase, the total time estimate for one further symbolic query from 0 to bsteps + 1 plus jumps from bsteps + 1 to n is then test * (bsteps + 1) + (n \u2013 (bsteps + 1)) * test = n * test (see line 6).\nThis estimate assumes that the time to compute m symbolic steps is roughly test * m regardless of whether those steps are computed in 2 symbolic queries of size test*m or 10 symbolic queries of size test*m. This is a simplification we make that is not strictly accurate \u2013 the time a symbolic query takes may be exponential in temporal depth for some problems and timing depends on the particular input set \u2013 but it leads to roughly accurate budgeting given that test is updated at each iteration.\nIf the remaining budget b does allow for continued search, bsteps is incremented (alg. 2 line 7). If not, we instead calculate a reasonable temporal query depth for finishing the remaining steps of the reachability problem in the jump phase (lines 8-13). One could use jumps of size bsteps but if n is not divisible or close to divisible by bsteps this could lead to a short jump at the end of the horizon and a loose final set. Instead, we calculate the num jumps needed to finish the time horizon in jumps of size bsteps (line 9-10) and instead use jumps of size ceil(num jumps) (line 11) which makes all the jumps closer in size.\nIf the solver has stopped early (line 14), the phase is switched to \"jump\u201d (line 18) and a similar calculation is performed to estimate the jump size (lines 15-17) with the difference being num_jumps is calculated using bsteps instead of bsteps (line 16). If we are already in the \u201cjump\u201d phase (line 20) we do not change the jump size of bsteps unless we stop early (line 21) in which case we decrement bsteps by 1 (line 22). The early stopping is used to ensure the budget is approximately respected given that the estimated time per symbolic step test is not an upper bound."}]}