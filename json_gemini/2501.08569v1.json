{"title": "Evaluating SAT and SMT Solvers on Large-Scale Sudoku Puzzles", "authors": ["Liam Davis", "Tairan \u201cRyan\u201d Ji"], "abstract": "Modern SMT solvers have revolutionized the approach to constraint satisfaction problems by integrating advanced theory reasoning and encoding techniques. In this work, we evaluate the performance of modern SMT solvers in Z3, CVC5 and DPLL(T) against a standard SAT solver in DPLL. By benchmarking these solvers on novel, diverse 25x25 Sudoku puzzles of various difficulty levels created by our improved Sudoku generator, we examine the impact of advanced theory reasoning and encoding techniques. Our findings demonstrate that modern SMT solvers significantly outperform classical SAT solvers. This work highlights the evolution of logical solvers and exemplifies the utility of SMT solvers in addressing large-scale constraint satisfaction problems.", "sections": [{"title": "I. INTRODUCTION", "content": "Sudoku is a well-known puzzle that has been around for many decades. Due to its structure, it can be understood as a type of constraint satisfaction problem, suitable to be solved by SAT and SMT solvers. SAT solvers, like the DPLL algorithm, are effective at solving problems by encoding them with boolean logic. In contrast, SMT solvers extend this capability, enabling them to handle a broader range of constraints. Modern SMT solvers allow for more creative and efficient encodings that lead to more efficient solvers. In this paper, we test modern SMT solvers (Z3, CVC5, and DPLL(T)) against the DPLL algorithm on a benchmark of novel, diverse 25x25 Sudoku puzzles created by our generator to answer a few different questions. First, how have logical solvers evolved over time in terms of performance and capability? Second, how do different encodings of Sudoku affect the efficiency and scalability of these solvers? Lastly, are there specific features or optimizations in SMT solvers that provide a significant advantage over traditional SAT solvers for this class of problem?"}, {"title": "II. MOTIVATION AND BACKGROUND", "content": "Sudoku puzzles, particularly larger variants such as 25x25 grids, present a significant computational challenge. This makes solving such puzzles an excellent case study for evaluating the performance of logical solvers. Traditional SAT solvers, like the DPLL algorithm, are efficient at handling problems defined by Boolean logic. But, they are less efficient when a problem has arithmetic and equality constraints. SMT solvers overcome these limitations by integrating theory solvers, which extend SAT solving capabilities to richer domains such as linear arithmetic, arrays, and equality with uninterpreted functions. Thus, SMT allows for more expressive encodings, and often more efficient problem-solving strategies.\nThe motivation for this work arises from the growing importance of constraint satisfaction problems in real-world applications, such as scheduling, planning, and verification. By exploring the evolution of logical solvers, this project aims to identify how modern SMT solvers have improved over traditional SAT solvers in terms of performance, scalability, and capability on large-scale constraint satisfaction problems."}, {"title": "III. TOOL AND CODE AVAILABILITY", "content": "As part of this project, we developed a Python-based tool for benchmarking SMT and SAT solvers by evaluating their performance on 25x25 Sudoku puzzles. The tool provides implementations of the solvers evaluated in this paper, as well as a generator that creates Sudoku puzzles of various difficulty levels, a Depth First Search (DFS)-based solver used during the generation process, and a framework for benchmarking the SMT and SAT solvers on the generated puzzles.\nThe code, including benchmarks and experiments, is publicly available on GitHub at github.com/liamjdavis/Sudoku-SMT-Solvers. The corresponding Python package is published on PyPI at pypi.org/project/sudoku-smt-solvers/. The documentation is available at liamjdavis.github.io/Sudoku-SMT-Solvers. The project is open source and distributed under the MIT license. We welcome contributions from the community to enhance the tool, add new features, and extend its capabilities."}, {"title": "IV. METHODOLOGY", "content": "The baseline implementation provides a framework to encode and solve Sudoku puzzles, built around the following key components:\n\u2022 Input Validation: Each solver verifies that the input is a 25x25 grid of integers, with each cell containing a value between 0 and 25 (where 0 represents an empty cell). Invalid inputs raise errors to prevent undefined behavior.\n\u2022 Propagation Statistics: Solvers maintain propagation statistics that provide further insight on performance.\n\u2022 Encoding Rules of Sudoku:"}, {"title": "A. Baseline Implementation", "content": "The baseline implementation provides a framework to encode and solve Sudoku puzzles, built around the following key components:\n\u2022 Input Validation: Each solver verifies that the input is a 25x25 grid of integers, with each cell containing a value between 0 and 25 (where 0 represents an empty cell). Invalid inputs raise errors to prevent undefined behavior.\n\u2022 Propagation Statistics: Solvers maintain propagation statistics that provide further insight on performance.\n\u2022 Encoding Rules of Sudoku:\n\u2022 Cell Constraints: Each cell in the grid must have exactly one value between 1 and 25.\n\u2022 Row, Column, and Block Constraints: Logical constraints ensure that no number appears more than once in any row, column, or 5x5 block.\n\u2022 Symmetry-Breaking Constraints: Additional constraints are added to reduce redundant search by eliminating equivalent solutions.\nSolution Extraction and Validation: Once the solving process is complete, variable assignments are mapped back to the Sudoku grid. The solution is validated to ensure correctness and alignment with the initial fixed values."}, {"title": "B. DPLL Solver", "content": "The DPLL solver processes the Sudoku puzzle by encoding it into Conjunctive Normal Form (CNF) and systematically solving it using the PySAT Python package. The solver integrates CNF generation, efficient SAT solving techniques, and solution validation to handle large puzzles like 25x25 Sudoku.\n1) Overview of the DPLL Algorithm: The DPLL algorithm employs a backtracking-based approach for solving Boolean satisfiability (SAT) problems. It operates on CNF formulas and systematically explores the space of variable assignments to generate a satisfying solution. The key steps of the algorithm include:\n1) Unit Propagation: Simplifies the formula by assigning values to variables that must hold true for a clause to be satisfied. This process iteratively reduces the formula's complexity.\n2) Pure Literal Elimination: Identifies literals that appear with only one polarity (either positive or negative) in the formula and assigns them values that satisfy all clauses containing them.\n3) Backtracking Search: Recursively assigns truth values to variables. When a conflict is detected (i.e., a clause cannot be satisfied), the algorithm backtracks to try alternative assignments.\nThe DPLL algorithm forms the foundation for modern SAT solvers, incorporating these fundamental techniques alongside heuristics to improve performance.\n2) Implementation Details: The specific implementation of the DPLL solver for Sudoku includes the following components:\na) CNF Generation: The Sudoku puzzle is converted into a CNF formula, where:\n\u2022 Each cell is represented as a set of Boolean variables, one for each potential value (1-25).\n\u2022 Constraints ensure that each cell contains exactly one value, and each row, column, and 5x5 block contains distinct values.\n\u2022 Pre-filled cells are encoded as fixed assignments to enforce consistency with the initial puzzle.\nb) SAT Solver Integration: The solver uses the PySAT library's low-level SAT solving capabilities to handle Boolean clause propagation, recursive search, and conflict resolution. Key techniques include:\n\u2022 Unit Clause Propagation: Automatically handled by the SAT solver to simplify clauses during solving.\n\u2022 Backtracking: The solver explores alternative variable assignments when conflicts arise, ensuring exhaustive search within the solution space.\nc) Solution Extraction and Validation: If the SAT solver finds a satisfying assignment, the model is decoded into a 2D Sudoku grid. The solution is validated to ensure it satisfies all Sudoku constraints, including unique values in each row, column, and block.\n3) Summary: The DPLL solver serves as a baseline for evaluating more advanced solvers, leveraging efficient SAT-solving techniques to solve large constraint satisfaction problems."}, {"title": "C. DPLL(T) Solver", "content": "The DPLL(T) solver builds upon the traditional DPLL algorithm by incorporating theory-specific reasoning, enabling it to handle richer constraints such as arithmetic and equality. This approach is based on the framework presented by Nieuwenhuis, Oliveras, and Tinelli in their foundational work on DPLL(T) [1]. The implementation uses the PySAT Python package and integrates low-level SAT solving capabilities with Sudoku-specific theory reasoning.\n1) Overview of the DPLL(T) Algorithm: The DPLL(T) algorithm extends the core principles of DPLL with theory-specific reasoning to enhance its solving capabilities. Key components of the algorithm include:\n1) Theory Propagation: In addition to unit propagation for Boolean clauses, the solver propagates constraints based on domain-specific theories (e.g., arithmetic, equality, or Sudoku-specific rules). This integration ensures invalid assignments are detected early.\n2) Theory Conflict Resolution: When a conflict is identified within the theory, the solver generates theory-specific conflict clauses that are added to the Boolean formula. These clauses prevent revisiting invalid states and streamline the search process.\n3) Incremental Solving: DPLL(T) interleaves SAT-solving steps with theory-specific checks, iteratively refining the solution space by combining Boolean and theory-level deductions.\n4) Clause Learning and Backtracking: The algorithm incorporates learned clauses to reduce redundant exploration and employs intelligent backtracking to efficiently explore alternative assignments.\n2) Implementation Details: The DPLL(T) solver for Sudoku incorporates several specialized components:\na) Theory Propagation: The solver dynamically enforces Sudoku-specific constraints during the solving process:\n\u2022 Checks for violations of row, column, and block uniqueness.\n\u2022 Identifies conflicts arising from invalid partial assignments and generates conflict clauses to prevent revisiting the same invalid states.\nb) Conflict Analysis and Clause Learning: When a conflict is detected during theory propagation, the solver generates a conflict clause that captures the root cause of the conflict. This clause is added to the formula to guide subsequent search steps and avoid redundant conflicts.\nc) SAT Clause Management: The solver leverages the PySAT library's SAT solving capabilities to handle Boolean clause propagation, conflict detection, and clause learning:\n\u2022 Original clauses represent the problem's constraints (e.g., cell, row, column, and block rules).\n\u2022 Learned clauses, generated during theory propagation, improve the solver's efficiency by reducing redundant search.\nd) CNF Encoding: The Sudoku puzzle is encoded as a CNF (Conjunctive Normal Form) formula:\n\u2022 Each cell is represented as a Boolean variable encoding its potential values.\n\u2022 Constraints enforce that each cell contains exactly one value, and all rows, columns, and 5x5 blocks contain distinct numbers.\n\u2022 Pre-filled cells are encoded as fixed assignments to ensure consistency with the initial puzzle.\ne) Model Extraction and Validation: If the solver finds a satisfying assignment, the Boolean model is decoded to extract a Sudoku solution. The solution is validated to ensure it satisfies all constraints.\n3) Summary: The DPLL(T) solver demonstrates the advantages of combining low-level SAT-solving techniques with high-level domain-specific reasoning. This hybrid approach extends the DPLL solver to achieve greater scalability for solving large constraint satisfaction problems, such as 25x25 Sudoku puzzles."}, {"title": "D. Z3 Solver", "content": "The Z3 solver leverages the SMT (Satisfiability Modulo Theories) capabilities of the Z3 library to solve 25x25 Sudoku puzzles. It incorporates advanced techniques such as integer variable encoding, efficient constraint propagation, and model evaluation. This solver uses the Z3 Python package, originally developed by Leonardo Mendon\u00e7a de Moura and Nikolaj Bj\u00f8rner [2].\n1) Overview of Z3: SMT solving generalizes SAT solving by incorporating theories that model specific domains. The Z3 solver extends foundational SAT-solving techniques with theory solvers, enabling it to handle richer constraints. Key components include:\n1) Theory Integration: Theories are tightly integrated into the solving process, enabling the solver to handle constraints involving domain-specific properties (e.g., integer arithmetic for Sudoku).\n2) Efficient Propagation and Conflict Resolution: The solver combines Boolean reasoning with theory propagation to quickly identify conflicts and resolve them using learned constraints.\n3) Model Evaluation: If a satisfiable assignment is found, Z3 extracts the model, representing the solution in terms of the original variables and their domains.\n4) Incremental Solving: Z3 allows constraints to be added or removed dynamically, making it versatile for solving problems that evolve over time.\n2) Implementation Details: The Z3 solver applies SMT-solving principles to encode and solve Sudoku puzzles efficiently. The implementation includes the following components:\na) Variable Encoding: Each cell in the Sudoku grid is represented by a Z3 integer variable with a domain of 1\u201325. A 2D array of Z3 integer variables is created, where:\n\u2022 The variable $x_{i,j}$ represents the value in the cell at row i, column j.\nb) Encoding Sudoku Rules: The solver encodes Sudoku rules as logical constraints using Z3's API:\n\u2022 Cell Constraints: Each cell must contain a value between 1 and 25:\n$1 < x_{i,j} \u2264 25$\nRow Constraints: All values in each row must be distinct, enforced using Z3's Distinct function:\n$Distinct({x_{i,1}, x_{i,2},...,x_{i,25}})$ Column Constraints: All values in each column must be distinct:\n$Distinct({x_{1,j}, x_{2,j}, . . . ,x_{25,j}})$ Block Constraints: All values in each 5x5 subgrid must be distinct. Subgrid constraints are systematically applied for all subgrids.\nc) Encoding the Puzzle: The initial Sudoku puzzle is encoded by asserting equality constraints for cells with predefined values. For example, if the value k is already present in cell (i, j), the solver asserts:\n$x_{i,j} = k$\nd) Theory Propagation and Model Checking: Once constraints are added, the Z3 solver performs theory propagation and searches for a satisfying assignment using SMT techniques:\n\u2022 The $check()$ method determines whether the puzzle is satisfiable.\n\u2022 If satisfiable, the $model()$ method extracts the solution.\n3) Summary: The Z3 solver highlights the power of SMT techniques in handling complex constraint satisfaction problems. By combining integer variable encoding, efficient constraint propagation, and advanced model evaluation, it achieves scalability and performance for solving large Sudoku puzzles, including 25x25 grids."}, {"title": "E. CVC5 Solver", "content": "The CVC5 solver leverages its SMT capabilities to solve 25x25 Sudoku puzzles using integer variable encoding, logical constraint propagation, and model evaluation. It is implemented using the CVC5 Python package, originally developed by Clark Barrett et al. [3].\n1) Overview of CVC5: CVC5 builds on SAT-solving foundations, extending them with domain-specific reasoning via theories. The solver interleaves Boolean reasoning with theory-specific propagation and conflict resolution to explore the solution space. Key features include:\n1) Theory Integration: Theories such as linear integer arithmetic are integrated into the solving process, allowing direct handling of domain-specific constraints.\n2) Efficient Conflict Resolution: CVC5 resolves conflicts dynamically by combining Boolean and theory-level reasoning to guide the search process.\n3) Incremental Solving and Model Evaluation: Constraints can be added incrementally, and satisfying assignments (models) are evaluated to extract solutions.\n4) Quantifier-Free Linear Integer Arithmetic (QF_LIA): CVC5 leverages this theory to efficiently represent and solve the integer constraints required for Sudoku.\n2) Implementation Details: The CVC5 solver applies SMT-solving principles to encode and solve Sudoku puzzles. The implementation includes the following components:\na) Variable Creation: Each cell in the Sudoku grid is represented by a CVC5 integer variable with a domain of 1-25. A 2D array of variables is created, where:\n\u2022 The variable $x_{i,j}$ represents the value in the cell at row i, column j.\n\u2022 The solver is configured for Quantifier-Free Linear Integer Arithmetic and supports model production and incremental solving.\nb) Encoding Sudoku Rules: The solver encodes the rules of Sudoku as logical constraints:\n\u2022 Domain Constraints: Each variable must be between 1 and 25.\n\u2022 Row Constraints: Each row contains distinct values, enforced using CVC5's DISTINCT operator.\n\u2022 Column Constraints: Each column contains distinct values.\nBlock Constraints: Each 5x5 subgrid contains distinct values, systematically encoded by grouping variables within the subgrid.\nc) Encoding the Puzzle: The initial Sudoku puzzle is encoded by asserting equality constraints for cells with predefined values. For example, if the value k is already present in cell (i, j), the solver asserts:\n$x_{i,j} = k$\nusing the assertFormula method.\nd) Theory Propagation and Model Checking: After encoding the constraints, the solver uses SMT-based theory propagation and conflict detection:\n\u2022 The $checkSat ()$ method determines whether the puzzle is satisfiable.\nIf satisfiable, the $getValue()$ method retrieves the solution by evaluating the model.\ne) Solution Extraction: The solution is extracted by evaluating the integer variables for each cell. The values are assigned to the Sudoku grid, and the solution is validated to ensure it satisfies all constraints.\n3) Summary: The CVC5 solver demonstrates the power of modern SMT techniques in solving large constraint satisfaction problems. By integrating integer variable encoding, efficient constraint propagation, and advanced model evaluation, it provides robust performance and flexibility for solving complex puzzles such as 25x25 Sudoku grids."}, {"title": "F. Benchmark Suite", "content": "In addition to the solvers, we also implemented a benchmark suite designed to run the solvers on various 25x25 Sudoku puzzles efficiently and systematically. The benchmark suite includes the following key features:\n\u2022 Configurable Timeout Handling: The benchmark suite enforces a user-defined timeout for each puzzle, ensuring that execution is terminated if the solver exceeds the specified time limit.\n\u2022 Detailed Metric Collection: The benchmark suite tracks performance metrics for each solver run. These metrics include the solution status, the total solving time, and the number of clause propagations performed.\n\u2022 Automated Result Aggregation: Performance data is automatically consolidated across solvers. The suite computes aggregate statistics such as the total number of puzzles solved, the average solving time, and the average clause propagation counts.\nResult Exporting: Benchmark results are saved in timestamped CSV files.\nThe benchmark suite serves as a versatile and reliable tool for evaluating solver performance under controlled conditions. It enables rigorous comparisons of different solvers."}, {"title": "G. Development and Testing Practices", "content": "To ensure the reliability, maintainability, and scalability of our solvers, we adopted modern software engineering practices throughout the development process. These practices included:\n\u2022 Automated CI/CD Pipelines: We used GitHub Actions to automate the linting, testing, and code coverage verification processes. Two workflows were implemented:\nStyling Workflow: This workflow runs on every push and pull request, ensuring that the codebase adheres to Python's PEP 8 style guidelines.\nPytest Workflow: This workflow executes unit and integration tests with pytest and measures code coverage using pytest-cov. This workflow is ran for python versions 3.10, 3.11 and 3.12.\nCodeQL Workflow: To enhance code security and quality, we integrated a CodeQL analysis workflow that identifies potential vulnerabilities in the code.\nCode Formatting and Pre-commit Hooks: We enforced consistent code style using the Black formatter with pre-commit hooks."}, {"title": "V. EVALUATION METHODOLOGY", "content": "To evaluate the performance of different solvers, we generated a dataset of 100 25x25 Sudoku puzzles categorized by five difficulty levels, from extremely easy to evil. Two metrics were used to determine the difficulty level of the puzzles:\n1) Number of Cells Given: A greater number of cells already filled in (\"given\") in the initial puzzle reduces the number of choices the solver has to make, so puzzles with fewer givens should be rated as more difficult.\n2) Lower Bound on the Number of Given Cells in Each Row and Column: The distribution of given cells across a puzzle's grid can significantly affect the puzzle's difficulty. Specifically, given two puzzles with the same number of total givens, the one with a higher lower bound is easier to solve because the bound forces a more uniform distribution of givens across the grid, which increases the total number of constraints the solvers can utilize and reduces the search space.\nThe metrics described above are selected from a set of Sudoku evaluation metrics developed by Yuan-Hai et al. [4]. Given the specifications of our project, we selected the two metrics most relevant for determining solving difficulty for SMT and SAT solvers and modified their difficulty level mappings so they can be applied to 25x25 grids. The modified mapping is described in the table below:"}, {"title": "A. Difficulty Level Classification", "content": "To evaluate the performance of different solvers, we generated a dataset of 100 25x25 Sudoku puzzles categorized by five difficulty levels, from extremely easy to evil. Two metrics were used to determine the difficulty level of the puzzles:\n1) Number of Cells Given: A greater number of cells already filled in (\"given\") in the initial puzzle reduces the number of choices the solver has to make, so puzzles with fewer givens should be rated as more difficult.\n2) Lower Bound on the Number of Given Cells in Each Row and Column: The distribution of given cells across a puzzle's grid can significantly affect the puzzle's difficulty. Specifically, given two puzzles with the same number of total givens, the one with a higher lower bound is easier to solve because the bound forces a more uniform distribution of givens across the grid, which increases the total number of constraints the solvers can utilize and reduces the search space.\nThe metrics described above are selected from a set of Sudoku evaluation metrics developed by Yuan-Hai et al. [4]. Given the specifications of our project, we selected the two metrics most relevant for determining solving difficulty for SMT and SAT solvers and modified their difficulty level mappings so they can be applied to 25x25 grids. The modified mapping is described in the table below:"}, {"title": "B. Sudoku Generator", "content": "In their paper, Yuan-Hai et al. [4] described an algorithm they developed for generating diverse 9x9 Sudoku puzzles of desired difficulties by first creating a \"terminal pattern\" (a completely filled-in grid that adheres to the Sudoku game rules) and then digging holes (removing the value in certain cells). We first implemented this algorithm based on descriptions of it in the paper, then generalized it to allow for the generation of puzzles of any size and made substantial optimizations to improve the runtime. Our final algorithm is as follows:\n1) Terminal Pattern Generation: As Yuan-Hai et al. [4] describes, terminal patterns should be generated using the Las Vegas Algorithm to ensure the diversity of the generated puzzles:\na) Starting with an empty grid, choose n random cells to be used as \"seeds\"\nb) Fill in the n seed cells with some combination of values such that all Sudoku rules are satisfied; if no such combinations exist, return to step 1.a\nc) Run a Depth First Search (DFS) Solver on the seeded grid until either a solution/terminal pattern is found (proceed to step 2) or a timeout is hit (return to step 1.a)\nOur implementation of terminal pattern generation and DFS solver utilizes algorithmic techniques not specified in the Yuan-Hai et al. paper, such as the Minimum Remaining Values (MRV) heuristic, to improve efficiency. In addition, we have found that setting the number of seeds n to 80 and the timeout to 5 seconds significantly reduces the time it takes to generate a terminal pattern.\n2) Hole Digging: Starting with a terminal pattern, a Sudoku puzzle of the desired difficulty level can be generated by digging holes in the grid (i.e., erasing the values in certain cells) [4]:\na) Choose difficulty level\nb) Determine the \"digging pattern,\" which corresponds to the order in which cells are examined as potential holes. Based on the analysis made by Yuan-Hai et al., to maximize the diversity of produced puzzles while minimizing runtime, the sequence should:\nBe randomized globally for extremely easy and easy puzzles\nStart at the top left cell and cover every other cell for medium puzzles\nStart at the top left cell and follow an \"S\" pattern for difficult puzzles\nStart at the top left cell and proceed from left to right, then top to bottom for evil puzzles\nc) Based on the selected difficulty level, set the minimum number of givens the puzzle must have and the lower bound on the number of givens in each row and column. These two numbers are uniformly selected from the ranges specified in Table I.\nd) Set all cells in the grid to \"can-be-dug\".\ne) Explore the first cell in the digging sequence by checking if it can be dug (digging will not violate the numbers set in step 2.c) and if digging it will result in a puzzle with a unique solution. In the Yuan-Hai et al. paper, uniqueness was checked for using a novel reduction-to-absurdity-based method that checked using the DFS solver whether the puzzle had a solution if the value in the cell was replaced with each of the 24 other possible values; if no other value resulted in a puzzle with a solution, digging the hole will create a unique puzzle. However, we discovered that it is significantly more efficient to remove the value in the cell and run the DFS solver on the resulting puzzle; as soon as the solver finds two solutions, we can terminate early with the knowledge that digging the hole will not create a unique puzzle. We estimate that our algorithm to check for uniqueness is roughly 24 times faster per cell checked compared to Yuan-Hai et al.'s algorithm.\nf) If the first cell can be dug and if digging will result in a unique puzzle, dig the cell. Then, regardless of whether the cell is dug or not, perform pruning by removing the cell from the list of \"can-be-dug\" cells and explore the next cell in the sequence. Keep exploring until no \"can-de-dug\" cells exist."}, {"title": "C. Experimental Process", "content": "To evaluate the solvers' performance systematically, we followed these steps:\n1) Benchmark Selection: We generated a benchmark set of 100 Sudoku puzzles with the method described earlier that included:\n20 Extremely Easy puzzles\n20 Easy puzzles\n20 Medium puzzles\n20 Difficult puzzles\n20 Evil puzzles\n2) Solver Configuration: Each solver was tested using its default configuration with no additional tuning or optimization.\n3) Execution Environment: All experiments were conducted in the same execution environment.\n4) Testing Procedure:\nEach solver was ran on the set of 100 benchmarks sequentially.\nA timeout of 30 seconds was imposed on each puzzle."}, {"title": "D. Performance Metrics", "content": "To compare the solvers, we collected the following performance metrics:\n\u2022 Success Rate: The percentage of puzzles solved correctly within the timeout.\n\u2022 Solving Time: The total time taken by a solver to find a solution within the timeout.\n\u2022 Propagation Efficiency: The number of clauses or constraints propagated per second, as reported by the solver's internal statistics.\nThese metrics were analyzed to identify trends in solver performance across difficulty levels. The evaluation process provided insights into how different solvers match up on various difficulty categories, highlighting their strengths and weaknesses. This comprehensive analysis helps determine the most effective solver for each class of Sudoku puzzles."}, {"title": "VI. RESULTS", "content": "This section presents the performance evaluation of the solvers across key metrics: success rates, solving times, and propagation efficiency. The results are analyzed to provide a comprehensive understanding of each solver's capabilities."}, {"title": "A. Solver Success Rates", "content": "The success rates indicate that CVC5 and Z3 solved every puzzle within the specified timeout, demonstrating their robustness in handling large and complex Sudoku puzzles. In contrast, DPLL and DPLL(T) encountered failures in 3% of the cases. This highlights the limitations of classical approaches when applied to large-scale problems, compared to modern SMT solvers like Z3 and CVC5."}, {"title": "B. Average Solve Time", "content": "Figure 1 illustrates the average solving time for each solver across all puzzles."}, {"title": "C. Solve Time Scatter Plot", "content": "Figure 2 presents scatter plots of solving times for each puzzle, providing a direct comparison of the solvers' performance."}, {"title": "D. Average Propagations", "content": "Figure 3 highlights the propagation efficiency of the solvers, showing the average number of propagations required to solve a single puzzle."}, {"title": "E. Conclusion of Results", "content": "The results clearly indicate that modern SMT solvers, particularly CVC5 and Z3, outperform a classical SAT solver in DPLL and a legacy SMT solver in DPLL(T) in solving large 25x25 Sudoku puzzles. This performance gap is evident across all evaluated metrics:\n\u2022 Success Rates: CVC5 and Z3 solved 100% of the puzzles, while DPLL and DPLL(T) encountered failures in 3% of cases.\nSolving Times: Z3 and CVC5 demonstrated significantly lower solving times, leveraging advanced SMT techniques for efficient problem-solving.\n\u2022 Propagation Efficiency: CVC5 exhibited the fewest propagations, followed closely by Z3, highlighting their ability to manage constraints and reduce redundant computations effectively.\nThe findings emphasize the advantages of integrating domain-specific reasoning and advanced conflict resolution strategies in SMT solvers. For complex constraint satisfaction problems, such as large-scale Sudoku, SMT solvers offer unparalleled scalability and efficiency. These attributes make them the preferred choice for solving such challenges.\nThe results underscore the need for continued development and refinement of SMT techniques to further enhance their applicability and performance across diverse problem domains."}, {"title": "VII. CONCLUSION", "content": "This paper evaluated the performance of modern SMT solvers, such as Z3 and CVC5, against an older SMT solver in DPLL(T) and a classical SAT solver in DPLL on 25x25 Sudoku puzzles. The results demonstrate that modern SMT solvers significantly outperform SAT solvers on constraint satisfaction problems. Notably, Z3 and CVC5 achieved perfect success rates, significantly lower solving times, and markedly greater propagation efficiency. These findings exemplify the efficiency of modern SMT solvers, and highlight their utility on large-scale constraint satisfaction problems."}, {"title": "VIII. FUTURE WORK", "content": "In this paper, we evaluated the performance of various solvers using standard configurations to solve 25x25 Sudoku puzzles. While the results demonstrate the clear advantages of modern SMT solvers like CVC5 and Z3, there are several promising avenues for future work to enhance solver performance and broaden their applicability."}, {"title": "A. Fine-Tuning SMT Solvers", "content": "Future work could focus on fine-tuning SMT solvers like CVC5 and Z3 for specific problem domains. While the current study used fairly standard configurations, SMT solvers offer a range of parameters that can be optimized to achieve better performance on particular types of problems. For example:\nCustomizing heuristics for branching and variable selection to improve solving efficiency.\nTailoring conflict resolution strategies to better handle specific classes of constraints.\nExploring advanced preprocessing techniques to simplify problem instances before solving.\nSuch targeted optimizations could enable SMT solvers to outperform their standard implementations for specific problem sets, making them even more competitive in diverse application areas."}, {"title": "B. Development of Hybrid Solvers", "content": "Hybrid solvers that integrate the strengths of both SAT and SMT solvers present another exciting direction for future research. Combining the speed and simplicity of SAT solvers for handling Boolean constraints with the advanced theory-reasoning capabilities of SMT solvers could yield significant performance improvements. Potential areas of exploration include:\nDesigning hybrid frameworks that dynamically switch between SAT and SMT solving strategies based on the characteristics of the problem.\nLeveraging SAT solvers for initial preprocessing or rapid conflict detection, followed by SMT solvers for detailed theory reasoning.\nExploring modular solver architectures that allow seamless integration of specialized solvers for different constraint types.\nSuch approaches could lead to solvers that are both efficient and versatile, capable of tackling a wider range of complex problems."}, {"title": "C. Improving Modern SMT Solvers", "content": "There is substantial scope for improving the core components of modern SMT solvers. Key areas of focus include:\nTheory Propagation: Enhancing the efficiency of theory-specific propagation to reduce redundant computations and accelerate solving.\nConflict Resolution Strategies: Developing more sophisticated methods for analyzing conflicts and generating conflict clauses to guide future search steps effectively.\nHeuristics for Branching and Variable Selection: Refining heuristics to make smarter decisions during the search process, thereby reducing the search space and solving time."}, {"title": "D. Machine-Assisted Theorem Proving", "content": "One of the most promising directions for future work lies in the integration of machine learning (ML) techniques and large language models (LLMs) into solvers, creating a new paradigm of machine-assisted theorem proving. By combining the high-level reasoning capabilities of ML with the low-level precision and efficiency of SAT/SMT solvers, this approach could unlock novel solutions to complex problems. Potential advancements include:\nLearning-Based Heuristics: Using machine learning models to dynamically learn and predict effective branching and variable selection strategies based on historical solving data.\nOnline Learning for Sets of Related Problems: Developing methods that allow solvers to continuously learn and adapt while solving a series of related problems can improve solver performance on the fly, enabling more efficient more efficient solving as new problems are encountered.\nIntegrating LLMs: Combining the high level abstract reasoning capabilities of LLMs with the low level reasoning capabilities of SMT solvers is a fairly new approach that has shown the potential to unlock more efficent solutions to complex reasoning tasks.\nThis integration could lead to solvers that not only perform better on traditional benchmarks but also extend their utility to emerging fields like automated theorem proving, formal methods, and AI-driven scientific discovery."}, {"title": "E. Exploring New Application Domains", "content": "Finally, further research can focus on applying these solvers to novel domains beyond Sudoku, such as hardware and software verification, formal verification of AI systems, and even proving mathematical theorems through formal methods. Understanding how solver techniques generalize to diverse applications will provide valuable insights into their versatility and potential for broader impact."}]}