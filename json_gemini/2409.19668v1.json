{"title": "Local Search for Integer Quadratic Programming", "authors": ["Xiang He", "Peng Lin", "Shaowei Cai"], "abstract": "Integer Quadratic Programming (IQP) is an important problem in operations research. Local search is a powerful method for solving hard problems, but the research on local search algorithms for IQP solving is still on its early stage. This paper develops an efficient local search solver for solving general IQP, called LS-IQCQP. We propose four new local search operators for IQP that can handle quadratic terms in the objective function, constraints or both. Furthermore, a two-mode local search algorithm is introduced, utilizing newly designed scoring functions to enhance the search process. Experiments are conducted on standard IQP benchmarks QPLIB and MINLPLIB, comparing LS-IQCQP with several state-of-the-art IQP solvers. Experimental results demonstrate that LS-IQCQP is competitive with the most powerful commercial solver Gurobi and outperforms other state-of-the-art solvers. Moreover, LS-IQCQP has established 6 new records for QPLIB and MINLPLIB open instances.", "sections": [{"title": "Introduction", "content": "Integer Quadratic Programming (IQP) problems are mathematical optimization problems where the objective function, constraints, or both include quadratic polynomial functions, with the variables required to take integer values. IQP is a generalization of Integer Linear Programming (ILP), extending ILP by incorporating quadratic terms into the objective function or constraints.\nWith its strong expressive power, IQP can accommodate the requirements of a variety of real-world scenarios, leading to an extensive range of practical applications. Many combinatorial optimization problems can be described using the IQP formulation, such as the quadratic assignment problem (Anstreicher 2003), max-cut (Burer and Vandenbussche 2005), and maximum clique (Bomze et al. 1999). In the industrial domain, many optimization problems can also be modeled using IQP, including finance portfolio optimization (Deng et al. 2013), quadratic network design (Frangioni, Furini, and Gentile 2016), telecommunications routing (Frangioni, Galli, and Scutell\u00e0 2015), energy management (Frangioni, Galli, and Stea 2017), automatic control (Axehill 2008) and so on.\nInteger Quadratic Programming is NP-hard (Vavasis 1990; Pia, Dey, and Molinaro 2017), making it challenging to solve. There are two classes of methods of solving Integer Quadratic Programming: complete methods and incomplete methods. Complete methods aim to compute the exact optimal solution and prove its optimality, while incomplete methods focus on obtaining high-quality solutions within a reasonable time. Nearly all of the complete solvers addressing IQP are based on the Branch-and-Bound algorithm (Land and Doig 2010). This includes most state-of-the-art IQP solvers (Mittelmann 2023), such as the commercial solvers Gurobi (Gurobi Optimization 2022) and CPLEX (Nickel et al. 2022), as well as the academic solver SCIP (Achterberg 2009). Nonetheless, Branch-and-Bound algorithms require exponential time in the worst case, and unfortunately, their exponential behavior frequently appears in practice (Furini et al. 2019).\nIncomplete methods are usually implemented as local search algorithms, which play an important role in solving NP-hard combinatorial problems (Gu 1992; Goldberg 2004; Lun et al. 2009). These algorithms aim to find good solutions quickly and have shown significant effectiveness in solving pseudo-Boolean optimization (Lei et al. 2021) and integer linear programming (Lin et al. 2023). However, research on local search algorithms for solving Integer Quadratic Programming is still on its early stages.\nIn practice, IQP instances vary widely due to their diverse properties. Many local search algorithms are devotedly tailored for specific IQP types with certain attributes. For instance, MA (Merz and Katayama 2004) and ACSIOM (Boros, Hammer, and Tavares 2007) are developed for quadratic unconstrained binary problems. CQP (Gould, Orban, and Robinson 2013) and DQP (Gould and Robinson 2017) are designed for convex problems with linear constraints, while BQPD (Fletcher 2000) and SQIC (Gill and Wong 2015) are suitable for nonconvex problems with linear constraints. There are several local search solvers for Nonlinear Programming (a problem class that includes IQP), such as CONOPT, IPOPT and SNOPT (Drud 1985; W\u00e4chter and Biegler 2006; Gill, Murray, and Saunders 2005). Nevertheless, these solvers are dedicated to real variables and not to integer ones. Knitro (Byrd, Nocedal, and Waltz 2006) periodically uses local search algorithms to assist its complete algorithm, but these local search algorithms only serve as an auxiliary method and must be dependent on complete algorithms to work."}, {"title": "Preliminary", "content": "Integer Quadratic Program (IQP) is an optimization problem in which either the objective function, or some of the constraints, or both, are quadratic functions. The problem has the general form as follows:\nMinimize $x^T Q^0x + b^0x + q^0$\nsubject to\n$\\frac{1}{2}x^T Q^ix + b^ix \\le d_i \\qquad i \\in M,$\n$l \\le x \\le u \\qquad j \\in N,$\n$x \\in Z$\n(1)\n\u2022 $N = \\{1, ..., n\\}$ is the set of indices of variables;\n\u2022 $M = \\{1,...,m\\}$ is the set of indices of constraints $(Q^i = 0$ when constraint is linear constraint);\n\u2022 $x = [x_j]^n_{j=1}$ is a finite vector of integer variables, the variables are restricted to only attain integer values.\n\u2022 $Q^i$ for $i \\in \\{0\\} \\cup M$ are symmetric $n \\times n$ real (Hessian) matrices;\n\u2022 $b^i, d_i$ for $i \\in \\{0\\} \\cup M$, and $q^0$ are, respectively, real(integer) n-vectors and constants;\n\u2022 $\u2212\u221e < l < u < \u221e$ are the lower and upper bounds on each variable $x_j$ for $j \u2208 N$.\n\u2022 Any problem with a maximization objective can be converted into a minimization problem by negating the objective function.\nTo better introduce the algorithm, additional notations will be supplemented below. For any variable $x_j \u2208$ constraint $i$, the constraint $con_i$ can be expressed using $x_j$ as follows:\n$A\\cdot x_j^2 + H(i, x_j) \\cdot x_j + I(i,x_j) \\le d_i$ (2)\nwhere A is the constant coefficient of $x_j^2$ in $con_i$, $H(i, x_j)$ is the coefficient polynomial of $x_j$ in $con_i$, and $I(i, x_j)$ is the polynomial that represents the terms in $con_i$ that do not contain $x_j$.\nWe use $f$ to denote the objective function. The set of variables in the objective function is denoted as $V(f)$, and the set of variables in a constraint $con_i$ as $V(con_i)$. For any variable $x_j \u2208 V(f)$, let the polynomial $\\Theta(x_j)$ represent the terms in the objective function that involve $x_j$:\n$\\Theta(x_j) = W \\cdot x_j^2 + K(x_j) \\cdot x_j$ (3)\nwhere W is the constant coefficient of $x_j^2$ in objective function, $K(x_j)$ is the coefficient polynomial of $x_j$ in the objective function.\nA complete assignment (assignment for short) a for an IQP instance F is a mapping that assigns to each variable an integer, and $\u03b1(x_j)$ denotes the value of $x_j$ under a. The value of the objective function under a is denoted as $obj(a)$. Also, We denote $\u03b1(H(i,x_j))$, $\u03b1(I(i, x_j))$, and $\u03b1(\u039a(x_j))$, $\u03b1(\u0398(x_j))$ as the values of these polynomials under assignment a, respectively. An assignment a satisfies the constraint $con_i$ if $con_i(a) \u2264 d_i$, otherwise the constraint is violated. An assignment a is feasible if and only if it satisfies all constraints in F. In the remaining part of the paper, a means the current assignment, unless otherwise stated."}, {"title": "Operator for Feasibility", "content": "An operator defines how to modify variables to generate new assignments. When an operator is instantiated with a variable, it produces an operation. A local search algorithm progressively takes operations to generate new assignments and tracks the best assignment obtained.\nIn this section, we propose a new operator quadratic satisfying move for violated quadratic constraints. It considers modifying the value of variables in violated constraints towards making them satisfied.\nDefinition 1. The quadratic satisfying move operator, denoted as $move_{sat}(x_j, con_i, a)$, takes an assignment a and assigns an integer variable $x_j$ to the threshold value making constraint $con_i$ satisfied, where $con_i$ is a violated constraint containing $x_j$.\nNote that for any variable $x_j \u2208 con_i$, $con_i$ is given by $A\\cdot x_j^2 + H(i, x_j) \\cdot x_j + I(i, x_j) \u2264 d_i$ as in Formula (2). We consider modifying the value of $x_j$ while keeping any other variables fixed as constants. There are two possible forms for $con_i$ with respect to $x_j$: it is linear if A = 0; otherwise, it is quadratic. We will discuss these two cases individually below.\nI. Linear Form\nFor any variable $x_j \u2208 con_i$ with a zero quadratic coefficient A = 0, the constraint $con_i$ is given by: $H(i,xj) \\cdot$"}, {"title": "II. Quadratic Form", "content": "For any variable $x_j \u2208 con_i$ with a non-zero quadratic coefficient A $\u2260$ 0, the constraint $con_i$ is given by: $A \u00b7 x_j^2 + H(i, x_j)\u00b7x_j + I(i, x_j) \u2264 d_i$. Under an assignment a, we denote $\u2206 = \u03b1(H(I, x_j)2) \u2212 4 \u00b7 A \u00b7 (\u03b1(I, x_j) \u2013 di)$. Depending on the following conditions, $move_{sat}(x_j, con_i, a)$ varies:\n\u2022 If $\u2206 = 0$, the equation $A\u00b7x_j^2 + H(i, x_j) \u00b7 x_j + I(i, x_j) \u2013 di = 0$ has a single root $xo$ with respect to $x_j$. If $xo$ is an integer, then there is a $move_{sat}(x_j, con_i, a)$ such that $\u03b1(x_{new}) = x_0$.\n\u2022 If $\u25b3 > 0$, the equation $A\u00b7 x_j^2 + H (i, x_j) \u00b7 x_j + I(i, x_j) \u2013 di = 0$ has two roots $x_1$ and $x_2$ with respect to $x_j$, where $x_1 < x_2$, there are two $move_{sat}(x_j, con_i, a)$:\n\u2013 If A > 0, then the two $move_{sat}(x_j, con_i, a)$ are $(x_{new}) = [x_1]$ and $\u03b1(x_{new}) = [x_2]$.\n\u2013 If A < 0, then the two $move_{sat}(x_j, con_i, a)$ are $(x_{new}) = [x_1]$ and $\u03b1(x_{new}) = [x_2]$.\n\u2022 Otherwise, there is no $move_{sat}(x_j, con_i, a)$.\nNote that if $con_i$ is an inequality, the new integer value of $x_j$ will satisfy $con_i$. However, if $con_i$ is an equality, we must check whether the new integer value of $x_j$ satisfies $con_i$. If it does not, the $move_{sat}(x_j, con_i, a)$ operation will be aborted."}, {"title": "Operators for Optimization", "content": "For IQP, satisfying constraints is essential to find feasible solutions, while optimizing the objective function is crucial for achieving a (sub)optimal solution. In this section, we propose 3 new operators for optimizing the objective function."}, {"title": "Inequality Exploration Move Operator", "content": "We first introduce the inequality exploration move operator. It considers modifying the value of $x_j \u2208 V(f)$ and the new value of $x_j$ is calculated based on the satisfied constraint $con_i$, where $con_i$ is an inequality that involves the $x_j$.\nDefinition 2. The inequality exploration move operator, denoted as $move_{exp}(x_j, con_i, a)$, takes an assignment a and assigns an integer variable $x_j \u2208 V(f)$ to a value that both maintains the satisfied state of the inequality constraint $con_i$ involving $x_j$ and maximize the decrease in the value of the objective function.\n$con_i$ is given by: $A \u2022 x_j^2 + H(i,x_j) \u2022 x_j + I(i,x_j) \u2264 d_i$ with respect $x_j$ by Formula (2). If A = 0, the equation $A.x_j^2 + H (i, x_j) \u2022 x_j + I(i, x_j) \u2013 d_i = 0$ has a single root $x_0$. If A $\u2260$ 0 and $\u25b3 > 0$, the equation has two roots $x_1$ and"}, {"title": "Equality Incremental Move Operator", "content": "The equality incremental move operator is designed for $x_j \u2208 V(f)$ and a satisfied constraint $con_i$, where $con_i$ is an equality involving $x_j$. In contrast to inequalities, for a quadratic equality, the feasible region of $x_j$ consists of either a single point or two distinct points. It is challenging to find a value of $x_j$ that keeps the equality satisfied while decreasing the value of the objective function. Therefore, the equality incremental move operator considers modifying both $x_j$ and an auxiliary variable $x'$ to decrease the value of the objective function, where $x'$ is adjusted to maintain the satisfied state of con."}, {"title": "Weighting Scheme and Score Function", "content": "In this section, we introduce techniques that help the local search algorithm perform effective search."}, {"title": "Weighting Scheme", "content": "The weighting scheme guides the search in a promising direction by assigning an additional property called weight (an integer) to constraints and the objective function. These weights are dynamically adjusted during the search and are used to compute the score functions. We denote $w(con_i)$ as the weight of constraint $con_i$ and $w(obj)$ as the weight of the objective function. Both $w(con_i)$ and $w(obj)$ are initially set to 1 and are updated dynamically as follows:\n\u2022 for violated constraint $con_i$, $w(con_i) := w(con_i) + 1$;\n\u2022 if $obj(a) > obj^*$ and $w(obj) < \u03b6$, then $w(obj) := w(obj) + 1$, where $obj^*$ is objective value under best found solution, $\u03b6$ limits the maximum value that objective function weight can get."}, {"title": "Scoring Function", "content": "The scoring function is a crucial component of local search algorithms, used to select best operations. We design the scoring function based on the feasibility of the current solution. For infeasible solutions, the scoring function assesses whether there is a change in the state of the constraints and the objective function. For feasible solutions, we evaluate how significant these changes are. The score consists of two components: constraint score and objective function score. Given the weights for constraints and the objective function, the scoring function for an operation op that changes an assignment a to a' is designed as follows:\nThe constraint score measures the change in the total penalty of constraints. Specifically, if a is infeasible, any violated constraint under a and a' incurs a penalty of $w(coni)$. if a is feasible, the penalty of all constraints under a is $p(con_i, a) = 0$, any violated constraint under a' incurs a penalty of $p(con_i, a') = w(con_i)\u00b7|di \u2212 (x^T Q^0x + b^ix)|$.\nDefinition 4 (Constraint Score). The constraint score for an operation op is the decrease of the total penalty caused by performing op :\n$Constraint Score(op) = \\sum_{i=1}^{m} (p(coni, a) \u2013 p(coni, a'))$\nThe objective function score measures the change in its value. Let $\u2206_{obj}$ as change $(obj(a) \u2013 obj(a'))$. If $\u2206_{obj} \u2260 0$, then $sign(obj) = \\frac{\u2206_{obj}}{|\u2206_{obj}|}$, otherwise, $sign(\u2206_{obj}) = 0$.\nDefinition 5 (Objective Function Score). The objective function score for an operation op is $w(obj) \u00b7 sign(\u2206_{obj})$ if a is infeasible, and score is $w(obj) \u00b7 \u2206_{obj}$ if a is feasible.\nDefinition 6 (Total Score). The score of an operation is the sum of the constraint score and the objective function score.\nAn operation is decreasing if its score is positive, indicating that it moves the search in a promising direction."}, {"title": "Local Search Algorithm", "content": "Our algorithm primarily consists of two aims: Satisfying all violated constraints and optimizing the objective function. To achieve this, we design an algorithm with a two-mode structure: the Satisfying mode and the Optimization mode, each associated with its specific operators. In the Satisfying mode, the algorithm focuses on making violated constraints satisfied, while in the Optimization mode, the algorithm focuses on minimizing the objective function."}, {"title": "Experiments", "content": "In this section, we evaluate the performance of our solver, LS-IQCQP, against state-of-the-art IQP solvers on standard IQP benchmarks. Ablation experiments are conducted to assess the effectiveness of the proposed strategies. We also conduct experiments to verify the stability of our solver. Notably, LS-IQCQP has set new records for 6 open instances."}, {"title": "Experiment Implementation and Setup:", "content": "LS-IQCQP is programmed in C++, compiled by g++ with '-O3' option. All experiments are carried out on a server with AMD EPYC 9654 CPU and 2048G RAM under the system Ubuntu 20.04.4. There are 2 parameters in the solver: t the number of samples for the BMS heuristic, ( for the Upper Limit of objective function weight. The parameters are tuned according to our preliminary experiments and suggestions from the literature, and are set as follows: t = 100. 5 = 100."}, {"title": "Competitors", "content": "We compare LS-IQCQP with 4 state-of-the-art IQP solvers. The binaries for each competitor are downloaded from their respective websites and are run with default settings.\n\u2022 Gurobi (Gurobi Optimization 2022): The most powerful commercial IQP solvers. We use both its exact and heuristic versions, denoted by Gurobi_exact and Gurobi_heur, respectively (version 10.0.0).\n\u2022 SCIP (Achterberg 2009): One of the fastest academic solvers for IQP (version 8.1.0).\n\u2022 Cplex (Nickel et al. 2022): A famous commercial IQP solver to solve IQP models (version 22.1.0)."}, {"title": "Comparison with State-of-the-Art IQP Solvers", "content": "The ability to find feasible(#feas) solutions: As shown in Table 1. LS-IQCQP performs best on both QPLIB and MINLPLIB benchmarks. It consistently finds feasible solutions for all instances in these benchmarks within 10 seconds or more. This result confirms the capability of LS-IQCQP to obtain feasible solutions within reasonable time limits.\nThe ability to find high-quality(#win) solutions: As shown in Table 1. LS-IQCQP consistently leads other solvers in total #win across all time limits, demonstrating its competitive performance. In the QPLIB dataset, LS-IQCQP stands out particularly in the QUBO, QCLP and QCQP categories, showcasing its advantage in handling specific types of problems. In the MINLPLIB dataset, LS-IQCQP also performs exceptionally well in the QCLP and QCQP categories. LS-IQCQP's stable and robust performance across various problem types and time limits demonstrates its potential as an efficient solver. It is worth mentioning that LS-IQCQP outperforms Knitro in all settings, indicating a significant improvement in the field of local search solver for IQP.\nSolving time analysis: The solving time results are presented in Figure 1. We compare LS-IQCQP with the top-performing solvers, Gurob_exact and Gurobi_heur, using a long 300-second time limit. It can be observed that, for instances where the same solution is found, LS-IQCQP consistently obtains solutions in a shorter time. This demonstrates the rapid convergence speed of our solver."}, {"title": "New Records to Open Instances", "content": "In the QPLIB and MINLPLIB datasets, there are instances that remain open, indicating that the optimal solution has not yet been found. The current best-known solutions for each open instance are available on the respective QPLIB and MINLPLIB websites. These open instances represent some of the most challenging IQP problems to solve. Remarkably, LS-IQCQP has established new best-known solutions for 6 open instances. As shown in Table 2, these instances also include different types of IQP from QPLIB and MINLPLIB, demonstrating the powerful solving ability."}, {"title": "Effectiveness of Proposed Strategies", "content": "To evaluate the effectiveness of our proposed strategies, we develop three modified versions of LS-IQCQP. Experiments are conducted with a time limit of 300 seconds. The modifications and corresponding versions are as follows:\n\u2022 Remove Inequality exploration move: version Uno_exp\n\u2022 Remove Equality incremental move: version Uno-inc\n\u2022 Remove Free move: version Uno-free\nThe results of ablation experiment are presented in Table 3 and confirm the effectiveness of the proposed strategies."}, {"title": "Stability Experiments", "content": "Repetitive running with randomness To examine the stability of LS-IQCQP, we execute the algorithm 10 times using seeds from 1 to 10 for each instance. Experimental results show that over 80% of instances have a coefficient of variation less than 0.1, demonstrating that LS-IQCQP exhibits stable performance."}, {"title": "Conclusion and Future Work", "content": "In this paper, we focus on local search algorithms for IQP. We propose 4 novel operators and a two-mode algorithm with new scoring functions to enhance the search process. Experiments show that the performance of our solver is outstanding, setting 6 new records for open instances. Future work aims to combine our solver with other solvers to prune the search space and speed up the search process."}]}