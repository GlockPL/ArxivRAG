{"title": "From Euler to AI: Unifying Formulas for Mathematical Constants", "authors": ["Tomer Raz", "Michael Shalyt", "Elyasheev Leibtag", "Rotem Kalisch", "Yaron Hadad", "Ido Kaminer"], "abstract": "The constant \\(\\pi\\) has fascinated scholars for centuries, inspiring the derivation of countless formulas rooted in profound mathematical insight. This abundance of formulas raises a question: Are they interconnected, and can a unifying structure explain their relationships?\nWe propose a systematic methodology for discovering and proving formula equivalences, leveraging modern large language models, large-scale data processing, and novel mathematical algorithms. Analyzing 457,145 arXiv papers, over a third of the validated formulas for \\(\\pi\\) were proven to be derivable from a single mathematical object - including formulas by Euler, Gauss, Lord Brouncker, and newer ones from algorithmic discoveries by the Ramanujan Machine. Our approach extends to other constants, such as \\(e\\), \\(\\zeta(3)\\), and Catalan's constant, proving its broad applicability. This work represents a step toward the automatic unification of mathematical knowledge, laying a foundation for AI-driven discoveries of connections across scientific domains.", "sections": [{"title": "1. Introduction", "content": "The earliest rigorous approximation for \\(\\pi\\) dates back to Archimedes, around 250 BCE (B. & Dhar, 2020) establishing the bounds \\(\\frac{223}{71} < \\pi < \\frac{22}{7}\\). Modern algorithms for calculating \\(\\pi\\) employ more sophisticated formulas. For example, the Chudnovsky algorithm (Chudnovsky & Chudnovsky, 1989), derived from a formula by Ramanujan (Ramanujan, 1914), remains instrumental for precision records. Similarly, the BBP formula (Bailey et al., 1996) is notable for enabling computation of specific \\(\\pi\\) digits without requiring prior digits. Such breakthroughs inspired fundamental advances in computer science, such as high-precision arithmetic (Bailey et al., 2012), evolutionary optimization (Koza, 1994), and elliptic curve cryptography (Miller, 1986). Recent efforts led to the development of computer algorithms capable of generating numerous formula hypotheses for mathematical constants (Raayoni et al., 2021; Razon et al., 2023; Elimelech et al., 2024)."}, {"title": "2. Methodology for Formula Unification", "content": "In this work, we propose a system for the large-scale harvesting, identification, and unification of mathematical formulas (see Fig. 2). This effort leverages recent advances in content understanding based on large language models (LLMs), the newly discovered concept of Conservative Matrix Fields (CMFs) (Elimelech et al., 2024), and a novel mathematical algorithm that we call coboundary equivalence for finding and proving relations between formulas (Section 2.3.2). The combined system is based on several key steps: harvesting the relevant mathematical expressions from arXiv and other open sources, which are then extracted and validated in a multi-stage process (Section 2.1). This automatic process converts all formulas to a canonical form (Section 2.3.1). The process is completed by a clustering stage in which our coboundary algorithm unifies the formulas in a CMF structure (Section 2.3.2).\nTo demonstrate this methodology, we selected the symbolic case study of formulas explicitly calculating \\(\\pi\\). A total of 457,145 papers from arXiv (in multiple languages) were analyzed, chosen based on their labels (see Appendix E.1), encompassing 278 million mathematical expressions. After a \u201charvesting\u201d process that identifies relevant formulas, 254 different \\(\\pi\\) formulas were validated, of which 37% were found to correspond to different trajectories within a single CMF. We expect near-future improvements of our algorithm to classify all the \\(\\pi\\) formulas into one or just a few unique CMFs that unify all knowledge about \\(\\pi\\) calculation.\nThe success of this study highlights the prospects of such algorithms to autonomously unify vast mathematical knowledge. Beyond the example of \\(\\pi\\), we applied our algorithm to other mathematical constants like \\(e\\), \\(\\zeta(3)\\), and Catalan's constant, and to a variety of formula structures, showcasing its broad potential."}, {"title": "2.1. LLMs for Harvesting Mathematical Formulas", "content": "Our challenge lies in the natural language processing of formulas. We analyze the \\(\\LaTeX\\) source code of 457,145 arXiv articles by combining regular expressions and LLMs. From these files, we extract all mathematical expressions, resulting in 278,242,582 unique strings. Filtering for expressions containing the symbol \\(\\pi\\) identifies 121,684 \\(\\pi\\)-related formulas. The widespread use of the symbol \\(\\pi\\) in scientific literature means that most occurrences are unrelated to calculating the constant itself. To address this, each potential formula is classified as computing \\(\\pi\\) or not, using GPT-4o mini (chosen for its cost-effectiveness), reducing the number of candidates to 3389. Next, GPT-4o categorizes formulas by type: series, continued fraction, or neither. Expressions including additional variables or symbols other than indices for summation or recurrence were mostly discarded, as the current algorithm has no reliable way of interpreting them-resulting in 847 formula candidates. Future work could analyze the text surrounding each equation and extract the definitions of additional symbols. To test the entire algorithm for such cases as well, we handled select cases manually.\nEach formula, represented as a \\(\\LaTeX\\) string, must then be parsed into a Computer Algebra System (CAS) for further manipulations (in our case SymPy (Meurer et al., 2017)). Automatically extracting algebraic forms from \\(\\LaTeX\\) strings is especially complicated due to varied \\(\\LaTeX\\) patterns, which are difficult to systematically convert to executable code using a predefined logic. LLMs help us overcome these obstacles by processing text contextually and attending to relevant parts of the text, solving the natural language processing task that may have required elaborate rules (Radford et al., 2019; Brown et al., 2020). Specifically, we use OpenAI's GPT-4o and GPT-4o mini (OpenAI, 2023) to translate relevant \\(\\LaTeX\\) into executable mathematical code (see Appendix E for the exact prompts used). Since there is no assurance that the LLM-generated formula code is correct, we apply a code-validation loop: code is executed and any errors are sent back to the LLM along with the faulty code to correct it, up to three times."}, {"title": "2.1.1. RETRIEVAL AND EXTRACTION", "content": null}, {"title": "2.1.2. VALIDATION OF THE FORMULAS", "content": "We validate that each extracted formula computes the constant \\(\\pi\\) by running the formula code to get a numerical approximation and then applying PSLQ, an integer relation algorithm (Ferguson et al., 1998). Limit values are not extracted directly from the \\(\\LaTeX\\) string for validation, since we found that GPT-4o got them wrong in some cases (see Table 4). Instead, the PSLQ approach fixes these critical GPT mistakes and reproduces the intended formulas.\nOut of the 847 candidates, 412 were validated as \\(\\pi\\)formulas using PSLQ and 254 yielded recurrences of order 2 (Section 2.3.1), which we analyzed and unified via the coboundary algorithm (Table 5 and Table 7). The remaining validated recurrences, e.g., of order 3, can also be addressed as we show for special cases in Appendix A.3."}, {"title": "2.2. Mathematical Background", "content": "This section introduces the key mathematical objects used by our algorithm. Each formula of a mathematical constant provides a sequence of rational numbers that converge to that constant (known as a Diophantine approximation). Each intermediate element is an approximation of the constant. Formulas\u2014including infinite sums, products, and continued fractions\u2014can be converted into recurrences, providing a cohesive framework for unification.\nA function \\(u_n\\) satisfies a recurrence of order \\(m\\) if \\(u_n = a_{1,n}u_{n-1} + a_{2,n}u_{n-2} + ... + a_{m,n}u_{n-m}\\), which can be represented via the associated companion matrix:"}, {"title": "2.2.1. RECURRENCES AND APPROXIMATIONS", "content": "By incrementally multiplying the companion matrix over \\(n\\) steps, we get the matrix:"}, {"title": "2.2.2. METRICS ON APPROXIMATION FORMULAS", "content": "Since each formula converging to a constant \\(L\\) provides a converging sequence, the formula can be characterized by dynamical metrics capturing properties such as its convergence rate. A recent paper (Shalyt et al., 2025) proposed to use such metrics for formula discovery and clustering. The metrics of convergence rate and irrationality measure are used in our algorithm.\nThe convergence rate is defined as:"}, {"title": "2.2.3. COBOUNDARY EQUIVALENCE", "content": "The concept of coboundary is a key part of our algorithm connecting formulas, finding non-trivial relations between formulas that often seem unrelated (see Appendix C.2 for motivation and context on the coboundary definition).\nTwo matrices \\(A(n), B(n) \\in PGL_m(\\mathbb{Q}(n))\\) are coboundary equivalent if there exist a matrix \\(U(n)\\) such that"}, {"title": "2.2.4. CONSERVATIVE MATRIX FIELDS (CMFS)", "content": "The CMF is the mathematical structure that enables unifying formulas of the same constant. The CMF concept was originally found by generalizing PCFs (Elimelech et al., 2024), and was later realized to be more general (Appendix D). To exemplify the concept, we focus on the CMF that encompasses many of the \\(\\pi\\) formulas. This CMF is 3D, i.e., consisting of three matrices \\(M_x, M_y, M_z\\) with rational function entries in the variables \\((x, y, z)\\), satisfying:"}, {"title": "2.3. Formula Clustering and Unification", "content": "The conversion to canonical forms automatically unifies multiple different formulas. Our harvesting process yields 93 different canonical forms for \\(\\pi\\) from 254 distinct arXiv sources (selected examples in Table 1)."}, {"title": "2.3.1. THE CANONICAL FORM", "content": "The first step in unification is converting each formula to a canonical form, i.e., the simplest linear recurrence with polynomial coefficients (Appendix C.2.1). This canonical form captures a wide range of formulas, including infinite sums. Relying on automated algebraic capabilities for such a task is unpredictable. Thus, we opt to use a computational method for converting the formulas to polynomial recurrences: a Mathematica package by RISC (Kauers & Koutschan, 2022) that fits polynomial-coefficient linear recurrences to each sequence of rational numbers, thus finding the minimal recurrence. Each series is converted to a recurrence using its first 200 partial sums. Out of 412 validated formulas (Section 2.1), 254 have representations as order-2 recurrences, which are equivalent to PCFs."}, {"title": "2.3.2. CLUSTERING BASED ON DYNAMICAL METRICS", "content": "Clustering formulas provides a heuristic as to which coboundary matches should be attempted. Dynamical metrics that can be directly calculated from formulas are effective for clustering, indicating that formulas with the same metrics are likely to be related to the same constant (Shalyt et al., 2025). We find that such metrics also indicate a more intricate connection between the formulas, enabling us to unify them in a systematic way that provides an analytical conversion between them. Specifically, the irrationality measure is the most reliable indicator for whether two formulas can be matched. Formulas in canonical form are thus first compared to each other based on this metric (Fig. 5a). For every new formula that we attempt to unify, we first search for directions in the CMF that correspond to recurrences with the same \\(\\delta\\). Such a search can be improved by using gradient decent on the direction parameters, because \\(\\delta\\) is found to be continuous (Elimelech et al., 2024).\nWe find that \\(\\delta\\) is not sufficient to imply equivalence, and thus complement it using the convergence rates. We analyze the convergence rates of the formulas and evaluate \\(\\frac{r_A}{r_B}\\). Then, canonical form \\(A\\) is folded by \\(r_B\\) and canonical form \\(B\\) is folded by \\(r_A\\) (Fig. 5b)."}, {"title": "2.3.3. MATCHING BY COBOUNDARY EQUIVALENCE", "content": "Having folded two formulas to make them converge at the same rate, the next step is finding the precise algebraic relation between them. The coboundary framework discovers such transformations using a novel algorithm that we developed. A general coboundary equivalence (as in Equation (7)) reads: \\(p_A(n) \\cdot A(n) \\cdot U(n + 1) = p_B(n) \\cdot U(n) \\cdot B(n)\\). Given two order-2 recurrences, there are 6 unknown polynomials: \\(p_A(n), p_B(n)\\) and the 4 entries of \\(U(n)\\). The coboundary equation is nonlinear in the coefficients of the polynomials, making the problem hard to solve. Furthermore, the problem has an undefined number of variables; a degree for each of the polynomials must be chosen before a set of equations can be written.\nWe present a method for finding these connections without solving nonlinear equations, instead leveraging the recurrence limits to compute a sequence of empirical coboundary matrices, whose elements are fitted to rational functions. The algorithm relies on the observation that if two recurrences \\(A(n)\\) and \\(B(n)\\) are coboundary with matrix \\(U(n)\\) and \u201cexternal\u201d polynomials \\(p_A(n), p_B(n)\\), then their limits \\(L_A\\) and \\(L_B\\) are related by the relation \\(L_A = U(1)(L_B)\\), where \\(U(n)(\\cdot)\\) denotes the M\u00f6bius transform defined by \\(U(n)\\) (Equation (18)). In the case of an order-2 recurrence (i.e., PCF), \\(U(1)\\) is four integers solved for by equating coefficients of \\(\\pi\\) on both sides of the equation (Fig. 5c). Using the necessary condition for a coboundary equivalence, we propagate this empirical matrix further along and calculate \\(U(n + 1) = A(n)^{-1} \\cdot U(n) \\cdot B(n)\\) (Fig. 5d). Rational functions are fit to each of the components of \\(U\\), after which \\(U\\) is multiplied by the least common multiple of the denominators of the elements, leading to a polynomial \\(U(n)\\). We can multiply \\(A(n) \\cdot U(n+1)\\) and \\(U(n) \\cdot B(n)\\) and compare. If these products, which are matrices, are the same up to a factor (a function of \\(n\\) times the identity matrix), then we have rigorously proven a polynomial coboundary relation between the two canonical forms (Fig. 5e).\nFig. 5 summarizes the flow of matching two canonical form formulas. Using this method, we find that formulas 1,2 and 5 from Table 1 are equivalent and that formulas 3,4 are also equivalent. Refer to Appendix A.1 for descriptions of how the algorithm is applied to these formulas, and refer to Appendix B for a listing of the algorithms involved. The same procedure is applied to each canonical form formula, measuring its \\(\\delta\\) value and relying on its continuity as a function of direction in the CMF to locate worthy directions that yield potential formula pairs for the coboundary algorithm. The matching algorithm is then applied between formulas and representative recurrences from the CMF. Finding a match between a formula and a CMF representative proves the formula is generated by the CMF. The full list of results is provided in Table 5 and Table 7. Selected results for \\(\\pi\\) are detailed in the following section."}, {"title": "3. Results", "content": "Our automated system proves previously unknown equivalences between formulas. Among the formulas connected are famous examples, such as one of Ramanujan's 1914 formulas, as well as Lord Brouncker's, Euler's, and Gauss's PCFs from the 17th, 18th, and 19th centuries, respectively (Ramanujan, 1914; Osler, 2010; Euler, 1748; Gauss, 1813).\nThe following series by Ramanujan (Ramanujan, 1914) was proven by our algorithm to be equivalent to a newer series from a paper published in 2020 (Sun, 2020):"}, {"title": "3.1. Equivalences Among Famous Formulas", "content": "The equivalence of these two formulas (detailed in Appendix A.2) demonstrates how two previously distinct mathematical expressions, discovered over a century apart, are now proven to be equivalent through a straightforward matrix multiplication, identified by an automated process. Fig. 4d proves the equivalence of another pair of famous formulas: (1) PCF(2n + 3, n(n + 2)), discovered in 2021 as one of the first \\(\\pi\\) formulas discovered by a computer (Raayoni et al., 2021). (2) PCF(2n + 1,n\u00b2), discovered by Gauss in 1813 (Gauss, 1813) and provided at the time an especially efficient way to calculate digits of \\(\\pi\\). These formulas are also unified in the CMF (Fig. 6) in the cluster of trajectory (1,1,2) and \\(\\delta = -0.21\\) (PCF(2n + 3, n(n + 2)) is not marked). Fig. 6 highlights additional well-known formulas that were proved equivalent."}, {"title": "3.2. Formulas Unified by a Conservative Matrix Field (CMF)", "content": "Out of 93 canonical forms (corresponding to 254 validated formulas), 47 (95 validated formulas) were identified as trajectories within a single CMF. The trajectory-arrangement of these formulas is summarized in Fig. 6, showing how the CMF unifies them, with different trajectory directions describing formulas of different dynamical metrics.\nEach cluster contains formulas equivalent via coboundary and fold operations, corresponding to parallel or overlapping trajectories in the CMF. Trajectory (1,0,0) with \\(\\delta = -0.65\\) describes many formulas discovered algorithmically in (Raayoni et al., 2021). Trajectory (2,1,1) with \\(\\delta = -0.48\\) holds three infinite sums, all of which have \\(\\frac{(2k)}{k!}\\) factors in their terms. Trajectory (1,1,1) with \\(\\delta = -1.00\\) describes, among others, famous slowly converging formulas by Lord Brouncker and Euler. The full list of the canonical forms captured by the CMF appears in Table 5. We expect additional formulas (Table 7) to be found in the CMF once the algorithms for finding trajectory candidates for matching are improved."}, {"title": "3.3. Unification of Formulas Beyond \\(\\pi\\)", "content": "Our method is applicable to mathematical constants other than \\(\\pi\\). Consider these two formulas for Ap\u00e9ry's constant, the Riemann zeta function value \\(\\zeta(3)\\):\nThe second formula (Equation (12)) (Kummer, 1837) has faster convergence rate compared to the classical definition of \\(\\zeta(3)\\) (Equation (11)). Our automatic procedure proves their equivalence by the coboundary transform (see Appendix A.2 for a complete exposition).\nAs another example, the following two PCFs for Catalan's constant (Bradley, 2001) are also coboundary equivalent (see Appendix A.2 for the coboundary matrix)."}, {"title": "4. Outlook", "content": "Many of the examples analyzed in this work are second-order recurrences and series or continued fractions. However, the coboundary algorithm and all the other steps in our harvesting and clustering processes are applicable to any formula that generates a sequence of approximations for a given constant, including those involving deeper recurrences. Expanding the system to accommodate these cases is a promising direction for future work.\nCurrently, the harvesting step relies on the LLM's ability to interpret and contextualize mathematical \\(\\LaTeX\\) strings. This step introduces data loss and false negatives in formula classification. Improvements in prompt engineering and in validation techniques will enhance the robustness of this LLM use. As more advanced LLMs become available, this step will become increasingly reliable.\nGoing beyond \\(\\pi\\), we automatically identified equivalent formulas for \\(e\\), \\(\\zeta(3)\\), and Catalan's constant-demonstrating the generality of the approach. A natural next step is to conduct exhaustive searches for other well-known constants, as well as fundamental mathematical structures in fields such as physics and computer science. Successfully unifying formulas across disciplines could reveal scientific insights that would be difficult to uncover without large-scale automated analysis.\nLooking forward, the same approach of collection, analysis, and organization of mathematical knowledge could help establish rigorous connections between different branches of mathematics. From an even broader perspective, the methodology presented in this work could help develop more general frameworks for identifying connections between different scientific theories through their mathematical representations. As the volume of information grows at an accelerating pace, finding automated ways to unify knowledge will become increasingly essential, especially with the goal of providing more intuitive understanding on complex concepts."}, {"title": "Impact Statement", "content": "This paper presents work whose goal is to advance the field of AI for Mathematics. There are many potential societal consequences of our work, none of which we feel must be specifically highlighted here."}, {"title": "A. Examples of Special Results", "content": "The examples shown here were found completely automatically via the algorithms discussed in Section 2. The actions at each step are described as if being applied by a human for clarity, but we emphasize that the connections were made automatically (i.e., patterns of the following paragraphs could have been written a single time and details of specific proofs could be filled in by a computer as it runs the algorithms)."}, {"title": "A.1. Examples for Unification by the Conservative Matrix Field (CMF)", "content": null}, {"title": "A.1.1. UNIFICATION EXAMPLE: FORMULAS 1, 2 AND 5 FROM TABLE 1", "content": "Formulas 1 and 2 have the same canonical form. Are there additional connections here? Could it be that formula 5 is also related to formulas 1 and 2, despite looking very different? Using the methodology showcased in Fig. 5, we attempt to answer this question. First, we compute the irrationality measure, the \\(\\delta\\) parameter, for each of the formulas, resulting in -0.65 for both canonical forms. The first empirically necessary condition for a coboundary equivalence has been passed. Next, we compute convergence rates (see Appendix B.2 for the definition), resulting in 0.69 and 1.38 for formulas 1 and 5, respectively. These are suspiciously similar - dividing the two we get \\(\\frac{1}{2} = \\frac{0.69}{1.38}\\). Folding (Appendix C.3) canonical form 1 by 2 and canonical form 5 by 1 (meaning no change) results in\nApplying the coboundary finding algorithm (Appendix B.3), the following matrix and polynomials connecting \\(PCF_{1,folded}\\) and \\(PCF_5\\) are found:"}, {"title": "A.1.2. UNIFICATION EXAMPLE: FORMULAS 3 AND 4 FROM TABLE 1", "content": "A shortened version of the last proof, but applied to the case of formulas 3 and 4 goes like this:\nThe canonical forms of formulas 3 and 4 have \\(\\delta = -1\\) and convergence rates 0 (they converge polynomially - very slowly). Given the similarity in \\(\\delta\\), we conjecture that the formulas are coboundary. Applying the coboundary-solving algorithm (Appendix B.3) yields the coboundary matrix:\nand trivial external polynomials - \\(p_A(n) = 1, p_B(n) = 1\\). So formulas 3 and 4 are equivalent.\nA trajectory in the CMF that generates a recurrence with similar \\(\\delta\\) is (1, 1, 1). The recurrence generated is precisely the canonical form of formula 3, \\(PCF_3\\), concluding the search.\nThe next example requires a nontrivial coboundary equivalence between a recurrence of the CMF and the formula of interest.\nThis example is implemented and available in the results colab as well as all other formulas we have presented."}, {"title": "A.1.3. UNIFICATION EXAMPLE: CLUSTER (-1, 3, 3) (\u03b4 = \u22120.91)", "content": "The following example pertains to the \\(\\delta = \u22120.91\\) cluster in Table 5. Formula 33 from this cluster is shown in the table for the purpose of this example. We have \\(PCF_{33}\\), taken from the CMF:\nand"}, {"title": "A.1.4. UNIFICATION EXAMPLE: CLUSTER (0, 0, 1) (\u03b4 = \u22121.00)", "content": "Here we show the four formulas listed explicitly in Fig. 6 are all equivalent, these correspond to indices 44-47 of Table 5 (formula 48 is omitted for brevity but can be shown to be equivalent to the others in the same way - it is initially in the cluster of formulas 46,47, see below). Please refer to the top of Appendix A.1 for more verbose explanations of the algorithm steps. All formulas have \\(\\delta = \u22121.00\\) of course, so they proceed to the convergence rate matching stage.\nFirst, consider the two polynomial continued fractions (formulas 44 and 45):\nThese have convergence rates 0, so all combinations of folding up to 2 are passed to the next stage (Appendix B.2). Applying the coboundary algorithm (Appendix B.3), The two turn out to be coboundary to each other with no folds necessary:"}, {"title": "A.2. Additional Equivalences Proven Automatically", "content": null}, {"title": "A.2.1. EQUIVALENCE EXAMPLE: NOTABLE FORMULAS FOR \u03c0", "content": "Equation (9) (Ramanujan, 1914) and Equation (10) (Sun, 2020) are converted to recurrences, both of order 2, after which they are converted to canonical form PCFs, respectively:"}, {"title": "A.3. Polynomial Recurrences for Formulas, Some of Order Greater than 2", "content": "One of Ramanujan's 1914 formulas (shown in Fig. 3) is represented by the following order-2 polynomial recurrence using RISC's Mathematica package for finding minimal recurrences (Kauers & Koutschan, 2022)"}, {"title": "A.1. Unifying Formula for Mathematical Constant", "content": null}, {"title": "B. Algorithms", "content": "This appendix contains an in depth description of the algorithms discussed in Section 2. The algorithms are ordered top-down, from the highest level algorithm to the lowest."}, {"title": "B.1. The Coboundary Graph Growing Algorithm", "content": "Input: Initialized graph with no edges, where each node is a canonical-form recurrence for a formula. Each node has precomputed attributes: irrationality measure (\\(\\delta\\)) and convergence rate (Section 2.2). Each node has a 'source' attribute with possible values: 'cmf' or 'formula', with some nodes being recurrences generated by the CMF (see Appendix B.5). Each node has attribute 'was_hub' initialized to False.\nOutput: The graph as a forest, where each edge contains the rigorous transformation between the two nodes it connects and every CMF-generated recurrence is a root in this forest (but not all roots are CMF-generated). This forest is termed a coboundary graph. Every tree groups formulas that are rigorously-equivalent together. The trees found by the algorithm are actually subgraphs of cliques; not all clique edges are computed during the matching phase to make the algorithm more efficient, but they all exist.\nSteps:"}, {"title": "B.2. Matching Algorithm", "content": "A match is a binary relation between two formulas. To find one, formulas represented as canonical form recurrences (Appendix C.2.1) are clustered based on dynamical metrics (Section 2.3.2). Promising pairs, those with similar irrationality measure \\(\\delta\\) (Equation (5)), are folded according to their convergence rates (Equation (4)), then sent to the coboundary solving algorithm (Appendix B.3). The result is a triple: the fold transform needed to be applied to each of the recurrences, and the coboundary matrix and polynomials as outputted by Appendix B.3.\nInput: Two linear polynomial-coefficient recurrences with matrices \\(A(n)\\) and \\(B(n)\\).\nOutput: A list of three transformations connecting the recurrences (if found)\nSteps:"}, {"title": "B.3. Coboundary Solving Algorithm", "content": "We aim to find a coboundary relation between two recurrences. As discussed in Section 2.3.2, solving explicit equations for a coboundary matrix symbolically constitutes a nonlinear problem. To see why, let us write the equations for the coboundary matrix and polynomials in full. We have, given two polynomial recurrence matrices \\(A(n)\\) and \\(B(n)\\) (not necessarily in companion form Equation (1)"}, {"title": "B.4. Conversion of Formulas to Canonical Form", "content": "We use RISC's package to convert formulas into recurrences, after which the proper initial conditions needed for the recurrence to generate the series are found.\nOur use of RISC's algorithm can be summarized by\nInput: First N approximants of a formula.\nOutput: Minimal polynomial recurrence.\nAs more numbers in a sequence are taken, the probability that a recurrence will produce the first terms of the rational sequence but not the rest decreases. Additionally, once such a recurrence is found for a formula with closed form, the series can be substituted in and shown to obey it, making the method robust.\nFormulas given by a polynomial recurrence of order 2 can be represented as polynomial \\(2 \\times 2\\) companion matrices (polynomial continued fractions): given a recurrence \\(X_n\\)\nthe corresponding canonical form is\nWhich is achieved using inflation by \\(c(n)\\) (see C.2).\nConverting a general series to a continued fraction can be done using a technique devised by Euler, however, this technique relies on algebraic manipulation of the term of the series and also does not necessarily yield polynomial recurrences, let alone recurrences of order 2. A formula can have a recurrence of order 2 that is not polynomial, but have minimal polynomial recurrence of order 3."}, {"title": "B.4.1. CONVERSION OF SERIES LIMIT TO POLYNOMIAL CONTINUED FRACTION (PCF) LIMIT", "content": "Input: Series", "2022).\nOutput": "x \\in \\mathbb{Q}\\) such that the initial conditions\ngenerate the partial sums of the entire series when the continued fraction's recurrence is applied from index 2. By demanding the second convergent of the continued fraction is equal to the second partial sum of the series (recall our notation for the M\u00f6bius transform defined by matrix \\(U\\), -"}]}