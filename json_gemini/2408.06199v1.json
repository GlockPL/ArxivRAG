{"title": "Dynamic Blocked Clause Elimination for Projected Model Counting", "authors": ["Jean-Marie Lagniez", "Pierre Marquis", "Armin Biere"], "abstract": "In this paper, we explore the application of blocked clause elimination for projected model counting. This is the problem of determining the number of models $||\u2203\u03a7.\u03a3||$ of a propositional formula \u2211 after eliminating a given set X of variables existentially. Although blocked clause elimination is a well-known technique for SAT solving, its direct application to model counting is challenging as in general it changes the number of models. However, we demonstrate, by focusing on projected variables during the blocked clause search, that blocked clause elimination can be leveraged while preserving the correct model count. To take advantage of blocked clause elimination in an efficient way during model counting, a novel data structure and associated algorithms are introduced. Our proposed approach is implemented in the model counter d4. Our experiments demonstrate the computational benefits of our new method of blocked clause elimination for projected model counting.", "sections": [{"title": "Introduction", "content": "Propositional model counting consists determines the number of models of a propositional formula \u2211, typically represented in conjunctive normal form (CNF). Many applications however require a projected variant focusing on a specific set X of variables of interest: given a propositional formula \u2211 and a set X of propositional variables to be forgotten, the projected model counting problem consists in computing the number of interpretations over the variables occurring in \u2211 but not in X, which coincide on X with a model of \u03a3. In other words, the goal is to count the number of models of the quantified Boolean formula \u2203\u03a7.\u03a3 over its variables (i.e., those present in \u2211 but absent in X).\nThe projected model counting problem is significant for various application domains of artificial intelligence (AI). For instance, in planning scenarios, it helps to evaluate the robustness of a plan by determining the number of initial states from which the plan execution leads to a goal state [4]. Additionally, its applicability extends beyond AI to formal verification problems [19] and database operations [1]. As a generalization of the standard model counting problem #SAT, for the special case X = 0, the projected model counting problem is at least as complex as #SAT (#P-hard). However, the possibility to eliminate some variables actually also might simplify the problem, such as when all variables in \u2211 belong to X, reducing the problem to simply determining the satisfiability of \u03a3. However, in practice projected model counting often turns out to be more challenging than the standard model counting problem. This can be explained by the additional constraints imposed on the branching heuristic, i.e., in which order variables can be used as decisions, making the problem inherently harder. This is also reflected for instance in upper known bounds in the literature [9] on the time complexity of model counting even formulas with fixed treewidth k, i.e., $O(2^k)$ for standard and $O(2^{2^k})$ projected model counting.\nOne way to speed up model counting is to employ preprocessing which simplifies the formula before tackling the model counting task. Preprocessing methods have shown to be effective across various automated reasoning tasks, notably in SAT solving and QBF solving [6]. Among these preprocessing techniques, blocked-clause elimination (BCE) [15] significantly improves solver performance by emulating several other, more complex preprocessing techniques [16]. Blocked clauses, initially introduced by Kullmann [20] as a generalization of extended resolution clauses, are pivotal in propositional preprocessing techniques. In essence, a clause a is deemed blocked within a CNF formula \u2211 if it includes a literal l for which all conceivable resolvents of a over l yield tautologies. Removal of blocked clauses can significantly enhance the performance of SAT solvers [15]. Furthermore, generalized forms of BCE have demonstrated remarkable performance improvements in solving problems beyond NP, such as QBF [12], DQBF [31] and even first-order theorem proving [18].\nHowever, while several preprocessing techniques used for SAT solving can be adapted to improve model counting [25, 22], others, such as the blocked clause elimination technique, are unsuitable due to their inability to preserve the number of models. In this paper, we address this challenge by delineating conditions under which the use of BCE is correct in projected model counting. Specifically, we demonstrate that focusing on projected variables during the blocked clause search is correct, i.e., gives the same projected count. The rationale behind this lies in the fact that when concentrating on sub-formulas containing only projected variables, the requirement is only to ensure satisfiability. Consequently, clauses blocked on projected variables can safely be removed.\nWhen used for model counting, simplification techniques are typically applied up-front during preprocessing and even though modern SAT solvers make heavily use of interleaving formula simplification with CDCL search, also called inprocesssing [17], this form of simplification is currently performed only at the root-level (decision level zero). In this paper we go beyond root-level simplification and propose to dynamically apply the blocked clause elimination technique dynamically during search at every decision level in the form of dynamic blocked clause elimination. In this sense our approach is similar to look-ahead solving [14], which use simplification techniques during search, i.e., probing techniques, at every decision level.\nTo accomplish this, we introduce novel data structures and associated algorithms tailored for dynamic inprocessing. Our method efficiently identifies clauses eligible for elimination by employing a mechanism akin to watched literals. Importantly, this methodology is not tied to a specific model counter; it seamlessly integrates into any state-of-the-art model counter.\nTo assess the efficiency of our approach, we conducted experiments using the model counter d4 [24], modified to integrate our newly developed data structures and algorithms for projected model counting. We evaluated the performance of this new version of d4 across various benchmarks from recent model counting competitions (available at https://mccompetition.org/). Our experimental results underscore the computational advantages of employing blocked clause elimination for projected model counting. For certain benchmarks, the adoption of BCE dynamic inprocessing led to a substantial reduction in computation time, with time savings of up to one order of magnitude compared to the baseline version of d4. To ensure that the improvements are indeed attributable to the use of BCE inprocessing, we"}, {"title": "Preliminaries", "content": "Let L be a propositional language built up from a finite set of propositional variables P and the standard logical connectives. The symbols \u22a5 and \u22a4 represent the Boolean constants for falsehood and truth, respectively. A literal l is either a propositional variable (e.g., x) or its negation (\u00acx). For a literal l defined over variable x, its complementary literal l is defined as $\\bar{l} = \u00acx$ if $l = x$, and $\\bar{l} = x$ if $l = \u00acx$, with $Var(l) = x$ denoting the variable of l. A term is a conjunction of literals. A clause is a disjunction of literals. Terms and clauses are also interpreted as their sets of literals whenever convenient.\nA clause is a tautology if it contains \u22a4, or both x and \u00acx for some variable x. A CNF formula \u2211 is a conjunction of clauses, also viewed as set of clauses when needed. The set of propositional variables occurring in \u2211 is denoted $Var(\u03a3)$. If a variable $x \u2208 X$ does not belong to $Var(\u03a3)$, then x is said to be free in \u03a3. Each clause is associated with a unique identifier represented as an integer. A clause $a_i$ of a CNF formula \u2211 can be accessed using its identifier through square bracket notation, denoted as \u03a3[i]. Thus $a_i$ is also noted \u03a3[i]. We denote by $S_l(\u03a3)$ the set of clauses of \u2211 that contain literal l. When no ambiguity about \u2211 is possible, we simply use the shorthand notation $S_l$ instead of explicitly writing $S_l(\u03a3)$.\n\nVar(\u03a3) = {X1,X2,X3, Y1, Y2, Y3}, $S_{X_1} (\u03a3) = {\u03b1_1, \u03b1_4, \u03b1_6, \u03b1_9}$, and \u03a3[2] = $\u03b1_2$ = \u00acX2 \u2228 X3.\nAn interpretation (or world) over P, denoted by w, is a mapping from P to {0,1}. Interpretations w are often represented by sets of literals (one per variable in P), of exactly those literals set to 1 by w. The collection of all interpretations is denoted by W. An interpretation w is a model of a formula \u03a3\u2208 L if and only if it satisfies the formula in accordance with the usual truth-functional interpretation. The set of models of the formula \u2211 is denoted by mod(\u03a3), defined as {w \u2208 W | w |= \u03a3}. The symbol |= denotes logical entailment, while = denotes logical equivalence. For any formulas \u03a3, \u03a8\u2208 L, we have \u03a3 |= \u03a8 if and only if mod(\u03a3) \u2286 mod(\u03a8) and \u03a3 = \u03a8 if and only if mod(\u03a3) = mod(\u03a8). The notation $||\u03a3||$ indicates the number of models of \u2211 over Var(\u03a3)."}, {"title": "Dynamic Blocked Clause Elimination for Projected Model Counting", "content": "For a formula \u03a3\u2208 L and a subset X \u2286 P, \u2203\u03a7.\u03a3 represents, up to logical equivalence, the most general consequence of \u2211 that is independent of the variables in X (see for instance [28] for details). We note Var(\u2203\u03a7.\u03a3) = Var(\u03a3) \\ \u03a7.\n\nThe conditioning of a CNF formula \u2211 by a consistent term \u03b3 results in the formula denoted by \u03a3|\u03b3, where \u03a3|\u03b3 is obtained from \u2211 by removing each clause from containing a literal of \u03b3 and simplifying the remaining clauses, by removing from them complementary literals to those in \u03b3. If, during the simplification, a clause becomes empty, then \u03a3|\u03b3 is unsatisfiable. The conditioning of \u2211 on l is equivalent to the formula $Var(l).(\u03a3\u2227l)$. When l is a unit clause of \u03a3, \u03a3|l is satisfiable if and only if \u2211 is satisfiable. Boolean Constraint Propagation (BCP) [29] is the algorithm that, given a CNF formula \u2211, returns a CNF formula closed under unit propagation, i.e., that does not contain any unit clauses. The resulting formula is obtained by repeating the unit propagation of a unit clause of \u2211 in the formula \u2211 while such a unit clause exists. The identifiers assigned to clauses in \u2211 remain unaltered by BCP. Consequently, BCP(\u03a3)[i] will retrieve the clause $\u03b1_i$ resulting from the application of BCP on \u03a3, which could be \u22a5, \u22a4, or a subset of $\u03b1_i$.\n\nThe resolution rule asserts that given two clauses $\u03b1_1$ = {$l,a_1,..., a_n$} and $\u03b1_2$ = {$\\bar{l},b_1,..., b_m$}, the resulting clause \u03b1 = {$a_1,..., a_n, b_1, ..., b_m$}, is the resolvent of $\u03b1_1$ and $\u03b1_2$ on the literal l. This operation is denoted as \u03b1 = $\u03b1_1$ \u2295 $\u03b1_2$. This concept extends naturally to sets of clauses: for two sets $S_l$ and $S_{\\bar{l}}$ containing clauses that all involve l and $\\bar{l}$, respectively, we define $S_l$ \u2295 $S_{\\bar{l}}$ = {$\u03b1_1$ \u2295 $\u03b1_2$ | $\u03b1_1 \u2208 S_l$, $\u03b1_2 \u2208 S_{\\bar{l}}$, and $\u03b1_1 \u2295 \u03b1_2$ is not a tautology}.\n\nThe simplification technique known as Blocked Clause Elimination (BCE) [15, 12], targets the removal of specific clauses termed blocked clauses from CNF formulas [20]. In the context of a CNF formula \u2211, a literal l within a clause \u03b1 is termed a blocking literal if it blocks \u03b1 with respect to \u03a3. This occurs when, for every clause $\u03b1'$ in \u2211 containing $\\bar{l}$, the resulting resolvent \u03b1 \u2295 $\u03b1'$ on l is a tautology. In essence, for a given CNF and its clauses, a clause is considered blocked if it contains a literal that can effectively block it. Applying BCE to \u2211 leads to remove every clause containing a blocking literal and by repeating the process iteratively until no blocked literal exists. [15, 12] illustrates that the outcome of BCE remains satisfiable equivalent regardless of the sequence in which blocked clauses are eliminated. More generally, blocked clause elimination converges to a unique fixed point for any CNF formula, establishing the confluence of the method."}, {"title": "Blocked Clause Elimination for Projected Model Counting", "content": "Our goal is to use blocked clause elimination dynamically during search in projected model counting. The primary challenge is to identify conditions under which such simplification is allowed. Section 3.1 provides novel theoretical insights permitting the removal of blocked clauses and Section 3.2 introduces new algorithms to efficiently identify them."}, {"title": "Theoretical Insights", "content": "As illustrated by Example 6, the BCE rule cannot be applied indiscriminately. When applied to the formula \u2211 provided in Example 1, the result is a tautological formula, indicating that $||BCE(\u03a3)|| = 1$ (since Var(BCE(\u03a3)) = \u2205 this correspond to $2^6 = 64$ models over Var(\u03a3)), which differs from $||\u03a3|| = 9$. It is essential to note that blocked clause elimination guarantees the preservation of satisfiability but not necessarily equivalence or the number of models. However, the picture changes when addressing the projected model counting problem. As we will demonstrate in Proposition 7, it is feasible to eliminate clauses that are blocked on projected variables. The rationale behind this lies in the fact that when focusing on sub- formulas containing only projected variables, the requirement is only to ensure satisfiability. Consequently, clauses blocked on projected variables can be removed in this case:\nProposition 7. Let \u2203x.\u03a3 be an existentially quantified CNF formula. If a non-tautological clause \u03b1 \u2208 \u03a3 is blocked by a literal l \u2208 \u03b1 with $Var(l) = x$, then \u2203x.\u2211 is logically equivalent to \u2203x.\u03a3', where \u03a3' = \u03a3 \\ {\u03b1}.\nProof. To establish the logical equivalence \u2203x.\u2211 = \u2203x.\u03a3', we need to demonstrate both (1) \u2203x.\u2211 |= \u2203x.\u03a3' and (2) \u2203x.\u03a3' |= \u2203x.\u2211. For condition (1) since \u03a3' |= \u03a3 it follows directly that \u2203x.\u2211 |= \u2203x.\u03a3'. Now, let us demonstrate the second condition. We have to prove for any interpretation w satisfying \u2203x.\u03a3', that w also satisfies \u2203x.\u2211. Consider an interpretation w satisfying \u2203x.\u03a3'. This means that w satisfies (\u2211|x \u2227 \u2211|\u00acx). We need to address two scenarios depending on whether w satisfies \u03a3|x or \u03a3|\u00acx. If w satisfies \u03a3|x, then \u03a3'|x |= \u03a3|x. Since \u2203x.\u03a3 entails \u03a3|x \u2227 \u03a3|\u00acx, we conclude that w satisfies \u2203x.\u2211. Let us consider the second scenario where w satisfies \u03a3'|\u00acx but not \u03a3|x (the case when w |= \u03a3|x has just been discussed). First, both \u03a3|x and \u03a3'|\u00acx contain clauses from \u2211' that do not involve variable x. Therefore, if w does not satisfy \u03a3|x but satisfies \u03a3'|\u00acx, there must be a clause $\u03b2 \u2208 \u03a3'$ with $\u00acx \u2208 \u03b2$ and $w \u00a5 \u03b2|\u00acx$. Now, let us demonstrate that w satisfies \u03a3|\u00acx. Since \u03a3|\u00acx = (\u03a3' \u2227 \u03b1)|\u00acx = \u03a3'|\u00acx \u2227 \u03b1|\u00acx, we only need to show that w satisfies \u03b1|\u00acx. As \u03b1 is blocked on x in \u2211, each resolvent between \u03b1 and a clause of \u2211 containing x is a tautology. Particularly, $\\bar{\u03b1|x}$ is a tautology, implying that there exists a literal $y \u2208 \u03b2$ such that $\\bar{y \u2208 \u03b1}$ and $x \u2260 y$. Since we have established that $w |= \u03b2|\u00acx$, this implies that w satisfies \u00acy, hence w satisfies \u03b1|\u00acx. This demonstrates that w satisfies \u03a3'|\u00acx \u2227 \u03b1|\u00acx, and consequently, w satisfies \u03a3|\u00acx. Using similar reasoning as before, we can show that w satisfies \u2203x.\u03a3. Therefore, for any interpretation w that satisfies \u2203x.\u03a3', it follows that w satisfies \u2203x.\u03a3, proving \u2203x.\u03a3' |= \u2203x.\u2211."}, {"title": "Implementation Details", "content": "To improve the efficiency of identifying clauses eligible for removal through the blocked clause elimination rule, we introduce the BlockedClauseManager object in this section. This specialized utility integrates efficient structures and algorithms crafted for this purpose, and is not exclusive to the projected model counter d4. It can be seamlessly employed in any state-of-the-art projected model counter.\nTo identify clauses eligible for elimination due to being blocked by a literal, we use a mechanism akin to the concept of watched literals. Given a formula \u2203\u03a7.\u03a3, we aim to capture scenarios where a clause \u03b1 cannot be eliminated via the blocked clause elimination rule, which occurs when there is no literal $l \u2208 \u03b1$ such that \u03b1 is blocked on $x$, and $Var(l) \u2208 X$. Specifically, a clause \u03b1 is not blocked on a literal $l \u2208 \u03b1$ if there exists another clause $\u03b1'$ such that $\\bar{l} \u2208 \u03b1'$ and $\u03b1 \u2295 \u03b1' \u00a5 T$. Consequently, the invariant we adopt stipulates that for each literal $l \u2208 \u03b1$ such that $Var(l) \u2208 X$, either l is assigned or there must exist a clause $\u03b1'$ where $\\bar{l} \u2208 \u03b1'$, and $\u03b1 \u2295 \u03b1' \u00a5 T$.\nSince blocked elimination can ignore (implied) learned clauses [17], the set $\u03b1 \u2208 S_{\\bar{l}}$, representing possible resolutions on a literal l concerning a clause $\u03b1 \u2208 \u03a3$, can be computed once at the outset. Consequently, when the watched clause to assess whether \u03b1 is blocked on l is deactivated, it suffices to consider clauses in $\u03b1 \u2208 S_{\\bar{l}}$ rather than re-evaluating each clause of $S_{\\bar{l}}$ to determine if the resolution rule yields a tautology. The first data structure incorporated into our BlockedClauseManager is thus a set of triples $(l, \u03b1, \u03b1 \u2295 S_{\\bar{l}})$, referred to as protectedTriple.\nThe function initProtectedTriple, outlined in Algorithm 1, is designed for this purpose. When provided with the existentially quantified CNF formula \u2203\u03a7.\u03a3, it begins by enumerating all variables x in X (lines 2-5). Subsequently, it iterates through each possible triple"}, {"title": "Experimental Evaluation", "content": "Our aim was to empirically assess the advantages of employing blocked clause elimination in solving instances of the projected model counting problem. For our experimentation, we used 500 CNF instances from the three recent model counting competitions (the 2021, 2022, and 2023 editions documented at https://mccompetition.org/). We excluded instances from the 2020 competition due to incompatibility with our software caused by changes in the input format. The instances were categorized into three datasets: 200 from the 2021 competition, 200 from the 2022 competition, and 100 from the 2023 competition. Notably, as the full set of 2023 instances was unavailable at the time of writing, we only included the 100 public instances provided by the organizers.\nThe projected model counter used for the evaluation was d4 [24]. Our experiments were conducted on Intel Xeon E5-2643 processors running at 3.30 GHz with 32 GiB of RAM, operating on Linux CentOS. Regarding the model counting competition, each instance was subject to a time-out of 3600 seconds and a memory limit of 32 GiB. For each instance, we measured the computation times required by three different versions of d4 for counting the numbers of projected models. These versions include:\n*   d4: This is the standard version of d4, as given at https://github.com/crillab/d4v2.\n*   d4+BCEp: This version of d4 incorporates blocked clause elimination performed once during a preprocessing phase.\n*   d4+BCE: In this version of d4, blocked clause elimination is performed dynamically throughout the search achieved by the model counter."}, {"title": "Conclusion and Perspectives", "content": "In conclusion, this paper has explored the utilization of the blocked clause elimination dynamically during projected model counting. Despite its widespread application in the satisfiability problem, the blocked clause elimination rule posed challenges for model counting due to its inability to maintain the number of models unchanged. However, through focused attention on projected variables during the search for blocked clauses, we have demonstrated the feasibility of leveraging this rule while preserving the correct model count. To achieve this, we introduced a new data structure and corresponding algorithms tailored for leveraging blocked clause elimination dynamically during search. This innovative machinery has been integrated into the projected model counter d4, enabling us to conduct comprehensive experiments that showcase the computational benefits of our approach. Our results underscore the efficacy of leveraging the blocked clause elimination rule technique for projected model counting, opening avenues for further exploration and refinement in this domain.\nExploring extensions of blocked clause elimination (BCE) in the context of projected model counting is interesting future work. This particularly includes considering the elimination of resolution asymmetric tautologies (RAT) [17], or even covered [11, 5] or propagation redundant (PR) [13] clauses. These approaches hold the potential to uncover additional redundant clauses, that can be eliminated and thus improve efficiency of projected model counting. In addition, we envision the development of novel branching heuristics designed to prioritize the elimination of clauses that prevent removal of blocked clauses. These improved decision heuristics, could create more instances where clauses become blocked and thus eliminated, again with the goal to improve solver efficiency. Furthermore, we want to explore the applicability of blocked clause elimination to other reasoning tasks, particularly to the weighted Max#SAT problem [3, 2] or counting tree models of QBF formulas [21]."}]}