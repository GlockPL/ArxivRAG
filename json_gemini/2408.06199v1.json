{"title": "Dynamic Blocked Clause Elimination for Projected Model Counting", "authors": ["Jean-Marie Lagniez", "Pierre Marquis", "Armin Biere"], "abstract": "In this paper, we explore the application of blocked clause elimination for projected model counting. This is the problem of determining the number of models ||\u2203\u03a7.\u03a3|| of a propositional formula \u2211 after eliminating a given set X of variables existentially. Although blocked clause elimination is a well- known technique for SAT solving, its direct application to model counting is challenging as in general it changes the number of models. However, we demonstrate, by focusing on projected variables during the blocked clause search, that blocked clause elimination can be leveraged while preserving the correct model count. To take advantage of blocked clause elimination in an efficient way during model counting, a novel data structure and associated algorithms are introduced. Our proposed approach is implemented in the model counter d4. Our experiments demonstrate the computational benefits of our new method of blocked clause elimination for projected model counting.", "sections": [{"title": "1 Introduction", "content": "Propositional model counting consists determines the number of models of a propositional formula \u2211, typically represented in conjunctive normal form (CNF). Many applications however require a projected variant focusing on a specific set X of variables of interest: given a propositional formula \u2211 and a set X of propositional variables to be forgotten, the projected model counting problem consists in computing the number of interpretations over the variables occurring in \u2211 but not in X, which coincide on X with a model of \u03a3. In other words, the goal is to count the number of models of the quantified Boolean formula \u2203\u03a7.\u03a3 over its variables (i.e., those present in \u2211 but absent in X).\nThe projected model counting problem is significant for various application domains of artificial intelligence (AI). For instance, in planning scenarios, it helps to evaluate the robustness of a plan by determining the number of initial states from which the plan execution leads to a goal state [4]. Additionally, its applicability extends beyond AI to formal verification problems [19] and database operations [1]. As a generalization of the standard model counting problem #SAT, for the special case X = 0, the projected model counting problem is at least as complex as #SAT (#P-hard). However, the possibility to eliminate some variables actually also might simplify the problem, such as when all variables in \u2211 belong to X, reducing the problem to simply determining the satisfiability of \u03a3. However, in practice projected model counting often turns out to be more challenging than the standard model counting problem. This can be explained by the additional constraints imposed on the branching heuristic, i.e., in which order variables can be used as decisions, making the problem inherently harder. This is also reflected for instance in upper known bounds in the literature [9] on the time complexity of model counting even formulas with fixed treewidth k, i.e., O(2k) for standard and $(2^{2^k})$ projected model counting.\nOne way to speed up model counting is to employ preprocessing which simplifies the formula before tackling the model counting task. Preprocessing methods have shown to be effective across various automated reasoning tasks, notably in SAT solving and QBF solving [6]. Among these preprocessing techniques, blocked-clause elimination (BCE) [15] signific- antly improves solver performance by emulating several other, more complex preprocessing techniques [16]. Blocked clauses, initially introduced by Kullmann [20] as a generalization of extended resolution clauses, are pivotal in propositional preprocessing techniques. In essence, a clause \u03b1 is deemed blocked within a CNF formula \u2211 if it includes a literal l for which all conceivable resolvents of \u03b1 over \u00acl yield tautologies. Removal of blocked clauses can significantly enhance the performance of SAT solvers [15]. Furthermore, generalized forms of BCE have demonstrated remarkable performance improvements in solving problems beyond NP, such as QBF [12], DQBF [31] and even first-order theorem proving [18].\nHowever, while several preprocessing techniques used for SAT solving can be adapted to improve model counting [25, 22], others, such as the blocked clause elimination technique, are unsuitable due to their inability to preserve the number of models. In this paper, we address this challenge by delineating conditions under which the use of BCE is correct in projected model counting. Specifically, we demonstrate that focusing on projected variables during the blocked clause search is correct, i.e., gives the same projected count. The rationale behind this lies in the fact that when concentrating on sub-formulas containing only projected variables, the requirement boils down to ensure satisfiability. Consequently, clauses blocked on projected variables can safely be removed.\nWhen used for model counting, simplification techniques are typically applied up-front during preprocessing and even though modern SAT solvers make heavily use of interleaving formula simplification with CDCL search, also called inprocesssing [17], this form of simplification is currently performed only at the root-level (decision level zero). In this paper we go beyond root-level simplification and propose to dynamically apply the blocked clause elimination technique dynamically during search at every decision level in the form of dynamic blocked clause elimination. In this sense our approach is similar to look-ahead solving [14], which use simplification techniques during search, i.e., probing techniques, at every decision level.\nTo accomplish this, we introduce novel data structures and associated algorithms tailored for dynamic inprocessing. Our method efficiently identifies clauses eligible for elimination by employing a mechanism akin to watched literals. Importantly, this methodology is not tied to a specific model counter; it seamlessly integrates into any state-of-the-art model counter.\nTo assess the efficiency of our approach, we conducted experiments using the model counter d4 [24], modified to integrate our newly developed data structures and algorithms for projected model counting. We evaluated the performance of this new version of d4 across various benchmarks from recent model counting competitions. Our experimental results underscore the computational advantages of employing blocked clause elimination for projected model counting. For certain benchmarks, the adoption of BCE dynamic inprocessing led to a substantial reduction in computation time, with time savings of up to one order of magnitude compared to the baseline version of d4. To ensure that the improvements are indeed attributable to the use of BCE inprocessing, we"}, {"title": "2 Preliminaries", "content": "Let L be a propositional language built up from a finite set of propositional variables P and the standard logical connectives. The symbols \u22a5 and \u22a4 represent the Boolean constants for falsehood and truth, respectively. A literal l is either a propositional variable (e.g., x) or its negation (\u00acx). For a literal l defined over variable x, its complementary literal \\overline{l} is defined as \\overline{l} = \u00acx if l = x, and \\overline{l} = x if l = \u00acx, with Var(l) = x denoting the variable of l. A term is a conjunction of literals. A clause is a disjunction of literals. Terms and clauses are also interpreted as their sets of literals whenever convenient.\nA clause is a tautology if it contains \u22a4, or both x and \u00acx for some variable x. A CNF formula \u2211 is a conjunction of clauses, also viewed as set of clauses when needed. The set of propositional variables occurring in \u2211 is denoted Var(\u03a3). If a variable x \u2208 X does not belong to Var(\u03a3), then x is said to be free in \u03a3. Each clause is associated with a unique identifier represented as an integer. A clause \u03b1i of a CNF formula \u2211 can be accessed using its identifier through square bracket notation, denoted as \u2211[i]. Thus \u03b1i is also noted \u2211[i]. We denote by Sl(\u03a3) the set of clauses of \u2211 that contain literal l. When no ambiguity about \u2211 is possible, we simply use the shorthand notation Sl instead of explicitly writing Sl(\u03a3).\nExample 1. Consider the CNF formula \u2211 = {\u03b11, \u03b12, ..., \u03b111} with\n1: X1 \u2228 X2\n2: \u00acX2 \u2228 X3\n3: \u00acX1 \u2228 \u00acX2 \u2228 \u00acY1\n4: \u00acX1 \u2228 \u00acX3 \u2228 Y1\n5: \u00acX2 \u2228 \u00acX3 \u2228 Y2\n6: \u00acX1 \u2228 \u00acX3 \u2228 \u00acY2\n7: Y3 \u2228 \u00acX2\n8: Y3 \u2228 \u00acX2 \u2228 \u00acX3\n9: \u00acY3 \u2228 \u00acX1\n10: \u00acY3 \u2228 \u00acY2 \u2228 X3\n11: \u00acY3 \u2228 Y2 \u2228 \u00acX2\nVar(\u03a3) = {X1, X2, X3, Y1, Y2, Y3}, Sx1(\u03a3) = {\u03b11, \u03b14, \u03b16, \u03b19}, and \u2211[2] = \u03b12 = \u00acX2 \u2228 X3.\nAn interpretation (or world) over P, denoted by w, is a mapping from P to {0,1}. Interpretations w are often represented by sets of literals (one per variable in P), of exactly those literals set to 1 by w. The collection of all interpretations is denoted by W. An interpretation w is a model of a formula \u03a3 \u2208 L if and only if it satisfies the formula in accordance with the usual truth-functional interpretation. The set of models of the formula \u2211 is denoted by mod(\u03a3), defined as {w \u2208 W | w |= \u03a3}. The symbol |= denotes logical entailment, while = denotes logical equivalence. For any formulas \u03a3, \u03a8 \u2208 L, we have \u03a3 |= \u03a8 if and only if mod(\u03a3) \u2286 mod(\u03a8) and \u03a3 = \u03a8 if and only if mod(\u03a3) = mod(\u03a8). The notation ||\u03a3|| indicates the number of models of \u2211 over Var(\u03a3).\nExample 2 (Example 1 cont'd). ||\u03a3|| = 9 and the models of \u2211 are:\n{X1, \u00acX2, \u00acX3, Y1, \u00acY2, \u00acY3}\n{\u00acX1, \u00acX2, X3, \u00acY1, Y2, \u00acY3}\n{\u00acX1, \u00acX2, X3, \u00acY1, Y2, Y3}\n{\u00acX1, \u00acX2, X3, \u00acY1, Y2, Y3}\n{\u00acX1, \u00acX2, X3, \u00acY1, Y2, Y3}\n{\u00acX1, \u00acX2, X3, \u00acY1, \u00acY2, \u00acY3}\n{\u00acX1, \u00acX2, X3, \u00acY1, Y2, Y3}\n{\u00acX1, \u00acX2, X3, \u00acY1, Y2, Y3}\n{\u00acX1, \u00acX2, X3, \u00acY1, \u00acY2, Y3}"}, {"title": "3 Blocked Clause Elimination for Projected Model Counting", "content": "Our goal is to use blocked clause elimination dynamically during search in projected model counting. The primary challenge is to identify conditions under which such simplification is allowed. Section 3.1 provides novel theoretical insights permitting the removal of blocked clauses and Section 3.2 introduces new algorithms to efficiently identify them."}, {"title": "3.1 Theoretical Insights", "content": "As illustrated by Example 6, the BCE rule cannot be applied indiscriminately. When applied to the formula \u2211 provided in Example 1, the result is a tautological formula, indicating that ||BCE(\u03a3)|| = 1 (since Var(BCE(\u03a3)) = \u2205 this correspond to $2^{|\u00d8|} = 64$ models over Var(\u03a3)), which differs from ||\u03a3|| = 9. It is essential to note that blocked clause elimination guarantees the preservation of satisfiability but not necessarily equivalence or the number of models. However, the picture changes when addressing the projected model counting problem. As we will demonstrate in Proposition 7, it is feasible to eliminate clauses that are blocked on projected variables. The rationale behind this lies in the fact that when focusing on sub- formulas containing only projected variables, the requirement is only to ensure satisfiability. Consequently, clauses blocked on projected variables can be removed in this case:\nProposition 7. Let \u2203X.\u03a3 be an existentially quantified CNF formula. If a non-tautological clause \u03b1 \u2208 \u03a3 is blocked by a literal l \u2208 \u03b1 with Var(l) \u2208 X, then \u2203X.\u03a3 is logically equivalent to \u2203X.\u03a3', where \u03a3' = \u03a3 \\ {\u03b1}.\nProof. To establish the logical equivalence \u2203X.\u03a3 = \u2203X.\u03a3', we need to demonstrate both (1) \u2203X.\u03a3 |= \u2203X.\u03a3' and (2) \u2203X.\u03a3' |= \u2203X.\u03a3. For condition (1) since \u03a3 |= \u03a3' it follows directly that \u2203X.\u03a3 |= \u2203X.\u03a3'. Now, let us demonstrate the second condition. We have to prove for any interpretation w satisfying \u2203X.\u03a3', that w also satisfies \u2203X.\u03a3. Consider an interpretation w satisfying \u2203X.\u03a3'. This means that w satisfies (\u03a3\u2227 \u03a3\u00acx). We need to address two scenarios depending on whether w satisfies \u03a3x or \u03a3\u00acx. If w satisfies \u03a3x, then \u03a3 = \u03a3x. Since \u03a3x entails \u03a3x \u2227 \u03a3\u00acx, we conclude that w satisfies \u2203X.\u03a3. Let us consider the second scenario where w satisfies \u03a3'\u00acx but not \u03a3x (the case when w |= \u03a3x has just been discussed). First, both \u03a3x and \u03a3\u00acx contain clauses from \u03a3' that do not involve variable x. Therefore, if w does not satisfy \u03a3x but satisfies \u03a3'\u00acx, there must be a clause \u03b2 \u2208 \u03a3' with \u00acx \u2208 \u03b2 and w |= \u03b2\u00acx. Now, let us demonstrate that w satisfies \u03a3\u00acx. Since \u03a3\u00acx = (\u03a3' \u2227 \u03b1)\u00acx = \u03a3'\u00acx \u2227 \u03b1\u00acx, we only need to show that w satisfies \u03b1\u00acx. As \u03b1 is blocked on x in \u03a3, each resolvent between \u03b1 and a clause of \u03a3 containing \u00acx is a tautology. Particularly, \u03b2 \u2295 \u03b1 is a tautology, implying that there exists a literal \u2203y \u2208 \u03b2 such that \u00acy \u2208 \u03b1 and x \\neq y. Since we have established that w |= \u03b2\u00acx, this implies that w satisfies \u00acy, hence w satisfies \u03b1\u00acx. This demonstrates that w satisfies \u03a3'x \u2227 \u03b1\u00acx, and consequently, w satisfies \u03a3\u00acx. Using similar reasoning as before, we can show that w satisfies \u2203X.\u03a3. Therefore, for any interpretation w that satisfies \u2203X.\u03a3', it follows that w satisfies \u2203X.\u03a3, proving \u2203X.\u03a3' |= \u2203X.\u03a3."}, {"title": "3.2 Implementation Details", "content": "To improve the efficiency of identifying clauses eligible for removal through the blocked clause elimination rule, we introduce the BlockedClauseManager object in this section. This specialized utility integrates efficient structures and algorithms crafted for this purpose, and is not exclusive to the projected model counter d4. It can be seamlessly employed in any state-of-the-art projected model counter.\nTo identify clauses eligible for elimination due to being blocked by a literal, we use a mechanism akin to the concept of watched literals. Given a formula \u2203X.\u03a3, we aim to capture scenarios where a clause \u03b1 cannot be eliminated via the blocked clause elimination rule, which occurs when there is no literal l \u2208 \u03b1 such that \u03b1 is blocked on x, and Var(l) \u2208 X. Specifically, a clause \u03b1 is not blocked on a literal l \u2208 \u03b1 if there exists another clause \u03b1' such that \\overline{l} \u2208 \u03b1' and \u03b1 \u2295 \u03b1' is not a tautology. Consequently, the invariant we adopt stipulates that for each literal l \u2208 \u03b1 such that Var(l) \u2208 X, either l is assigned or there must exist a clause \u03b1' where \\overline{l} \u2208 \u03b1', and \u03b1 \u2295 \u03b1' Z T.\nExample 9 (Example 1 cont'd). When evaluating \u03b13, it is not feasible to associate the literal y1 with a clause from \u2211 without resulting in a tautology. Therefore, \u03b13 can be safely removed from \u03a3. Conversely, when examining \u03b111, it is feasible to associate the literal \u00acy3 with clause \u03b19 and the literal y2 with clause \u03b16, demonstrating that \u03b111 cannot be eliminated from the formula using the blocked clause elimination rule.\nSince blocked elimination can ignore (implied) learned clauses [17], the set {\u03b1} \u2295 S\\overline{l}, representing possible resolutions on a literal l concerning a clause \u03b1 \u2208 \u03a3, can be computed once at the outset. Consequently, when the watched clause to assess whether \u03b1 is blocked on l is deactivated, it suffices to consider clauses in {\u03b1} \u2295 S\\overline{l} rather than re-evaluating each clause of S\\overline{l} to determine if the resolution rule yields a tautology. The first data structure incorporated into our BlockedClauseManager is thus a set of triples (l, \u03b1, {\u03b1} \u2295 S\\overline{l}), referred to as protectedTriple.\nThe function initProtectedTriple, outlined in Algorithm 1, is designed for this purpose. When provided with the existentially quantified CNF formula \u2203X.\u03a3, it begins by enumerating all variables x in X (lines 2-5). Subsequently, it iterates through each possible triple\n(l, \u03b1, {\u03b1} \u2295 S\u00acl) such that l \u2208 {x, \u00acx}, l \u2208 \u03b1, and \u03b1 \u2208 Sl (lines 3-5), adding them into protectedTriple (line 5). Moving forward, we will primarily work with clause identifiers rather than the clauses themselves. Therefore, when referring to a clause \u03b1 in the following discussions, we are actually addressing its identifier. This applies similarly to sets of clauses; we will focus on the set of identifiers corresponding to the clauses within the set.\nExample 10 (Example 1 cont'd). Upon invoking the function initProtectedTriple on the existentially quantified formula \u2203X.\u03a3 provided in Example 1, the set protectedTriple contains the following triples: (y1, \u03b14, {}), (\u00acy1, \u03b13, {}), (y2, \u03b15, {\u03b16}), (y2, \u03b111, {\u03b16}), (\u00acy2, \u03b110, {}), (\u00acy2, \u03b16, {\u03b15, \u03b111}), (y3, \u03b17, {\u03b19, \u03b110}), (y3, \u03b111, {\u03b19}), (\u00acy3, \u03b18, {}), (\u00acy3, \u03b19, {\u03b17, \u03b111}), (\u00acy3, \u03b110, {\u03b17}).\nFor each triple (l, \u03b1, C) in protectedTriple, we need to watch a clause from C to ensure that clause \u03b1 is not blocked by l. To achieve this, we incorporate into BlockedClauseManager a map of watching lists, denoted as watches. This structure associates each clause \u03b1 \u2208 \u03a3 with a set of triples watches[\u03b1] that are being watched by \u03b1.\nAlgorithm 2 presents the pseudo-code for the function initWatchList. Given an exist- entially quantified CNF formula \u2203X.\u03a3, this function initializes the watches structure and returns the indices of blocked clauses U, which are the clauses for which it is impossible to associate a sentinel. The function begins by initializing the set of blocked clauses as empty (line 2). Then, it initializes the map watches by associating an empty set with each clause of \u2211 (lines 2-3). Next, it iterates over the triples in the protectedTriple set to associate a sentinel with each of them (lines 4-6). For each triple t = (l, \u03b1, C), where C represents the set of non-tautological clauses, the algorithm checks whether C is empty. If it is, \u03b1 is added to the set of blocked clauses (line 5). Otherwise, a clause \u03b1' from C is selected, and the triple t is added to the watching list of \u03b1' (line 6).\nExample 11 (Example 1 cont'd). Upon calling the function initWatchList on the exist- entially quantified formula \u2203X.\u03a3 provided in Example 1, the following represents a potential initialization of the watched structure:\nwatches[\u03b16] = {(y2, \u03b15, {\u03b16}), (y2, \u03b111, {\u03b16})}\nwatches[\u03b19] = {(y3, \u03b17, {\u03b19, \u03b110}), (y3, \u03b111, {\u03b19})}\nwatches[\u03b15] = {(\u00acy2, \u03b16, {\u03b15, \u03b111})}\nwatches[\u03b17] = {(\u00acy3, \u03b19, {\u03b17, \u03b111}), (\u00acy3, \u03b110, {\u03b17})}\nwatches[\u03b13] = watches[\u03b14] = watches[\u03b18] = watches[\u03b110] = watches[\u03b111] = \u2205\nTo finalize the initialization of the BlockedClauseManager object, we incorporate two arrays for maintaining records of assigned variables and satisfied clauses. The first array, named isAssignedVar, associates each variable in X with a Boolean value set to true if the variable is assigned, and false otherwise. The second array, named isActiveClause, associates each clause of \u2211 (identified by their identifier) with a Boolean variable set to true if the clause is active, and false otherwise. The arrays isAssignedVar and isActiveClause are initialized with false and true, respectively, for all their elements. We also need a stack"}]}