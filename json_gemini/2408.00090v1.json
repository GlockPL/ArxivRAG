{"title": "Execution Semantics of Behavior Trees in Robotics Applications", "authors": ["Enrico Ghiorzi", "Armando Tacchella"], "abstract": "This document aims at describing, in a suitably precise and unambiguous though informal way, the execution semantics of Behavior Trees as used in Robotics applications, with particular attention to the Halt semantics.", "sections": [{"title": "Introduction", "content": "Behaviour Trees (BTs) are a popular formalism to define the behaviour of a system on the architecturally highest layer. They offer some benefit compared to other popular formalisms, such as finite state machines:\nModularity Any BT can be itself a sub-tree of another BT which facilitates reuse of code.\nReactivity The execution of the BT self-adapts to the changing conditions of the envirionment, even going back to previously completed tasks if necessary.\nFor these reasons, BTs have found applications in deliberation systems in robotics [4, 6, 3, 8, 5, 7], and various frameworks are available implementing BTs within robotic control systems [1, 2, 9, 10, 11].\nUnfortunately, BTs don't have a well-defined, universally accepted semantics and terminology, especially for the flavours commonly used in Robotics. Particularly, robotics distinguishes itself from other fields in that components of cyber-physical systems do not advance their state in discrete steps, but, once started, execute continuously till termination or interrupted. This has led to the proposal of a halt semantics, whose details are though not well-defined."}, {"title": "1 Behavior Trees", "content": "A behavior tree is a directed rooted tree having control flow and decorator nodes as internal nodes, and execution nodes as leaves [4].\nA behavior tree executes when it is ticked until it provides a response, which is a message that contains one of the following states: Success, Failure, or Running. The execution flow is the following:\n\u2022 The execution starts by ticking the root node;\n\u2022 Control flow nodes activates when ticked and can propagate the tick to their children;\n\u2022 Execution nodes activates when ticked and respond Success, Failure, or Running;\n\u2022 Control flow nodes receives responses from their children and decide what to respond to their parents;\n\u2022 Finally, a response reach the root node, terminating the execution.\nThis, though, is still unsufficient to handle complex robot control systems. Indeed, robotic and cyberphysical components don't stop executing after responding to a tick, but generally keep running until they get explicitely halted. So, implementations such as [1] introduce a halt semantics:\n\u2022 Execution nodes that are running can be sent a Halt signal;\n\u2022 Halting is a blocking operation and the execution of the BT is suspended till the node returns;\n\u2022 Control nodes can be halted by propagating the Halt signal to their children;\n\u2022 It is assumed that halting can happen quickly enough not to stall the execution of the BT."}, {"title": "1.1 Graph formulation", "content": "The behavior tree can be defined as a graph $BT = (V, E)$, where Vis the set of nodes and E is the set of edges."}, {"title": "1.2 Execution Nodes", "content": "There are two types of execution nodes: action nodes and condition nodes. All execution nodes are decorated with a label that describes what the node does.\nAn action node is thought of as performing an action that can take an indefinite amount of time to complete, so it can return any response when ticked.\nAction nodes can be either in idle or running state. When an action node returns Success or Failure to a Tick, it is in idle state. When it returns Running to a Tick, it is in running state. An action node can also be halted which leaves it in idle state.\nA condition node is thought of as instantaneously verifying a condition, so it can return only Success or Failure when ticked, but not running.\nCondition nodes are always in idle state, and halting has no effect on them."}, {"title": "1.3 Control Flow Nodes", "content": "We have the following types of control flow nodes:\n\u2022 Sequence\n\u2022 Fallback\n\u2022 Parallel"}, {"title": "Reactive Sequence", "content": "The Reactive Sequence node executes Listing 3, which corresponds to routing the ticks to its children from the left until it finds a child that returns either Failure or Running, then it returns Failure or Running accordingly to its own parent. It returns Success if and only if all its children return Success. Note that when a child returns Running or Failure, the Reactive Sequence node does not route the ticks to the next child (if any). The symbol of the the Reactive Sequence node is a box containing"}, {"title": "Reactive Fallback", "content": "The Reactive Fallback node executes Listing 4, which corresponds to routing the ticks to its children from the left until it finds a child that returns either Success or Running, then it returns Success or Running accordingly to its own parent. It returns Failure if and only if all its children return Failure. Note that when a child returns Running or Success, the Reactive Fallback node does not route the ticks to the next child (if any). The symbol of the the Reactive Fallback node is a box containing the label \"?\", shown in Figure 2."}, {"title": "Reactive Parallel", "content": "The Reactive Parallel node with success treshold $k$ (with $0 < k \\leq n$) executes Listing 5, which corresponds to routing the ticks to all its children and returning Success if at lease $k$ children return Success, Failure if more than $n - k$ children return Failure, and Running otherwise. The symbol of the the Reactive Parallel node with success treshold $k$ is a box containing the label \"$\\rightarrow_k$\", shown in Figure 3."}, {"title": "Sequence with Memory", "content": "The Sequence with Memory node executes Listing 6, which corresponds to routing the ticks to its children from the left until it finds a child that returns either Failure or Running, then it returns Failure or Running accordingly to its own parent. Moreover, if a node returns Running, the successive execution will restart from the same node. It returns Success if and only if all its children return Success. Note that when a child returns Running or Failure, the Sequence with Memory node does not route the ticks to the next child (if any). The symbol of the the Sequence with Memory node is a box containing the label \u201c\u2192*\u201d as shown in Figure 4."}, {"title": "Fallback with Memory", "content": "The Fallback with Memory node executes Listing 8, which corresponds to routing the ticks to its children from the left until it finds a child that returns either Success or Running, then it returns Success or Running accordingly to its own parent. Moreover, if a node returns Running, the successive execution will restart from the same node. It returns Failure if and only if all its children return Failure. Note that when a child returns Running or Success, the Fallback with Memory node does not route the ticks to the next child (if any). The symbol of the the Fallback with Memory node is a box containing the label \u201c?*\u201d as shown in Figure 5."}, {"title": "Parallel with Memory", "content": "The Parallel with Memory node with success treshold $k$ (with $0 < k \\leq n$) executes Listing 9, which corresponds to routing the ticks to all its running children and returning Success if at lease $k$ children have returned Success, Failure if more than $n-k$ children have returned Failure, and Running otherwise. The symbol of the the Parallel with Memory node with success treshold $k$ is a box containing the label \u201c$\\rightarrow_k$\u201d, shown in Figure 6."}, {"title": "1.4 Decorator nodes", "content": "A Decorator node is a control flow node with a single child that manipulates the return status of its child according to a user-defined rule and also selectively ticks the child"}, {"title": "Inverter", "content": "The Inverter node (Figure 7) ticks the child once and return Success if the child failed or Failure if the child succeeded. If the child returns Running, this node returns Running too (Listing 10)."}, {"title": "Force Success", "content": "The Force Success node (Figure 8), if the child returns Running, returns Running too. Otherwise, it returns always Success (Listing 11)."}, {"title": "Force Failure", "content": "The Force Failure node (Figure 9), if the child returns Running, returns Running too. Otherwise, it returns always Failure (Listing 12)."}, {"title": "2 Open questions", "content": "There are various topics and issues concerning the definition of Behavior Tree and their semantics that this document does not touch upon, as there is no consensus on how to treat them. We present some of the most notable ones."}, {"title": "2.1 Halt semantics for reactive control nodes", "content": "Reactive nodes try to have at most one running child at a time by stopping all siblings of a child that returns Running (given the execution semantics for reactive nodes, only the siblings following the child that is ticked can be running, while those preceding it must be idle). Though, this means that, between the time the child is ticked and the time all its running siblings are halted, potentially multiple actions are running concurrently.\nOf cousre, the implementator of the Action nodes could account for such behavior on a case-by-case basis. Though, since the potential for unintended side-effects in a large BT and/or in a complex system is elevated, it would be best if the semantics of the BT provided built-in safeguards.\nSome potential solutions have been proposed:\n\u2022 To \"guard\" the children of the reactive node with Condition nodes that prevent a child from running if any of its siblings is running.\n\u2022 To \"probe\" the children of the reactive node to determine if executing an Action"}, {"title": "2.2 Condition leaves", "content": "Can executing a Condition leaf have side-effects? Should a specification for BT semantics prescribe this, or should it be left to the implementation?"}, {"title": "2.3 Halt semantics", "content": "The following points about the Halt semantics have been left unspecified and are a matter of debate:\n\u2022 Can halting an idle Action leaf have side-effects?\n\u2022 Is it responsability of the BT/control flow nodes to determine which (potentially idle) children to send a halt signal? I.e., Should the halt signal be propagated to idle branches/leaves?\n\u2022 What should idle nodes/leaves do with when receiving a halt signal?\n\u2022 How long should an Action leaf take to halt, at most?"}, {"title": "2.4 Tick generation", "content": "Should it be specified when the root node of the BT has to be ticked?\nShould the root node of the BT be ticked at regular time intervals,"}]}