{"title": "SLIM: Style-Linguistics Mismatch Model for Generalized Audio Deepfake Detection", "authors": ["Yi Zhu", "Surya Koppisetti", "Trang Tran", "Gaurav Bharaj"], "abstract": "Audio deepfake detection (ADD) is crucial to combat the misuse of speech synthesized from generative AI models. Existing ADD models suffer from generalization issues, with a large performance discrepancy between in-domain and out-of-domain data. Moreover, the black-box nature of existing models limits their use in real-world scenarios, where explanations are required for model decisions. To alleviate these issues, we introduce a new ADD model that explicitly uses the Style-Linguistics Mismatch (SLIM) in fake speech to separate them from real speech. SLIM first employs self-supervised pretraining on only real samples to learn the style-linguistics dependency in the real class. The learned features are then used in complement with standard pretrained acoustic features (e.g., Wav2vec) to learn a classifier on the real and fake classes. When the feature encoders are frozen, SLIM outperforms benchmark methods on out-of-domain datasets while achieving competitive results on in-domain data. The features learned by SLIM allow us to quantify the (mis)match between style and linguistic content in a sample, hence facilitating an explanation of the model decision.", "sections": [{"title": "Introduction", "content": "The growing interest in generative models has led to an expansion of publicly available tools that can closely mimic the voice of a real person [69]. Text-to-speech (TTS) or voice conversion (VC) systems can now be used to synthesize a fake voice from only a few seconds of real speech recordings [68]. When these generation tools are used by bad actors, their outputs, commonly referred to as 'audio deepfakes' [28], can pose serious dangers. Examples include impersonation of celebrities/family members for robocalls [29], illegal access to voice-guarded bank accounts [14], or forgery of evidence in court [53]. Reliable audio deepfake detection (ADD) tools are therefore urgently needed.\nState-of-the-art (SOTA) detection systems [75, 86] employ self-supervised learning (SSL) encoders as the frontend feature extractors, and append classification backends to map the high-dimensional feature representations to a binary real/fake decision [35, 86, 75]. Common SSL encoders for this task are the Wav2vec [7], WavLM [11], and HuBert [24], among others. These models are usually trained in a fully-supervised manner, with fake samples generated using off-the-shelf TTS/VC tools [34, 86, 12, 75, 49, 85, 27]. However, current ADD systems are known to underperform on deepfakes crafted by unseen generative models (i.e., unseen attacks) [40, 48, 63, 86]. To tackle this issue, some works have focused on extracting more robust features from the input representation [25, 67, 85]. Additional improvements have been reported by finetuning the SSL frontend during downstream supervised training [67, 75, 44] and by increasing the diversity of labelled samples via data augmentation or continual training on vocoded data [66, 80, 76, 77]. While shown to be effective for in-domain deepfakes, frontend finetuning increases the cost of training drastically.\nAdditionally, outputs from existing ADD systems are hard to explain, i.e., it is unclear to a typical user why an ADD makes a certain prediction, which leads to lack of trust [86, 34]. For practical"}, {"title": "Related works", "content": ""}, {"title": "Audio deepfake detection", "content": "State-of-the-art ADD systems mainly rely on fully-supervised training, where the model architectures comprise of one or more speech SSL frontends and a backend classifier [86, 2, 45]. Guo et al. [23] developed a multi-fusion attentive classifier to process the output from a WavLM frontend; Yang et al. [85] fused outputs from multiple SSL frontends and reported improvements over using a single frontend. However, existing ADD systems experience severe degradation in performance when tested on unseen data [48, 63], which questions their applicability and trustworthiness for real-world scenarios. To address this issue, multiple works have explored methods to improve model generalizability. With added training cost, improvements have been reported when frontends are finetuned alongside the backend classifiers during downstream training [67, 75]. Further improvements were achieved with data augmentations such as RawBoost [66, 67] and neural vocoding [76]. More recent works also show that distilled student models can generalize better than large teacher models [43, 77]. Still, large discrepancies between in-domain and out-of-domain performance are common [86, 34].\nIn addition to generalization, existing ADD models also fall short on interpretability. Several studies have shown that current SOTA models may be focusing on artifacts introduced in the frequency spectrum during voice synthesis and/or the artifacts in non-speech segments [63, 47, 40, 88]. While a line of work proposed to extract speech-related features, such as breath [33] and vocal tract and"}, {"title": "Style-linguistics modelling", "content": "One standard approach for modelling speech is to decompose it into two subspaces, style and linguistics. The former refers to short and long-term paralinguistic attributes, such as speaker identity, emotion, accent, and health state [61]. The latter corresponds to the verbal content of speech [31]. For representing style information, early works relied on handcrafted features, such as GeMAPS [19, 18]. Later studies showed improved performance by representations learned end-to-end by deep neural networks (DNN), such as the x-vector [64] and ECAPA-TDNN embeddings [16]. Similarly, the linguistic representations follow a similar trend where DNN-based embeddings, such as Whisper [57], outperform handcrafted features for content-related tasks [17]. More recent studies have shown that style and linguistics information can be efficiently encoded together in the SSL representations [7, 11, 24]. To investigate how speech information is encoded in DNNs, a group of works conducted layer-wise analysis and showed that early to middle layers carry more style related attributes, such as speaker identity [5], emotion [60], and articulatory movement [13]; while later layers encode linguistics attributes, such as phonetic information and semantics [52, 62].\nDespite these approaches, it is unclear if completely disentangling style and linguistics information in speech is possible. Studies have shown that a certain dependency exists between these two subspaces: the link between emotional states and word choices [38], the relation between prosody and language understanding [15], and the impact of age on sentence coherence [55]. Effectively modeling both the independent and dependent aspects of style and linguistics in speech still remains a challenge."}, {"title": "Method", "content": ""}, {"title": "Motivation", "content": "For the majority of generative speech models, the style and linguistic subspaces are assumed to be independent of each other [69, 26, 73, 46]. For example, VC systems change the voice of an utterance by replacing the source speaker's embeddings with those of the target speaker [46, 73], assuming that these embeddings contain no linguistics information. Similarly, modern TTS systems rely on independently learned representations to model different speech aspects (e.g., text, speaker, emotion) to synthesize expressive speech [8, 16, 72].\nBecause of this disentanglement assumption, a mismatch likely exists between the style and linguistics information in TTS/VC speech that differentiates it from real speech. To study this hypothesis, we conduct a proof-of-concept experiment on a sample subset of ASVSpoof2019 [71]. Following previous research [58, 30, 51], we use canonical correlation analysis (CCA) to derive a subspace where the linear projections of the style and linguistics embeddings are maximally correlated for the real class. We choose the last layer output of pretrained wav2vec2-large-xlsr-53-english [22] for linguistics representation, and the pretrained ECAPA-TDNN embeddings [16] for style representation."}, {"title": "Formulation of SLIM", "content": "Our two-stage Style-LInguistics Mismatch (SLIM) learning framework is outlined in Fig. 1. The first stage operates on the real class only and employs self-supervised learning to build style and linguistic representations and their dependencies for real speech. In the second stage, a classifier is fit onto the learned representations via supervised training over deepfake datasets with binary (real/fake) labels."}, {"title": "Stage 1: One-class self-supervised contrastive training", "content": "The goal of the first stage is to learn pairs of dependency features from style and linguistics subspaces, which are expected to be highly correlated for real samples and minimally correlated for deepfakes. Since only real samples are needed, we incorporate other open-source speech datasets to diversify the style variations. Given a speech sample, we first extract the style and linguistics representations separately using pretrained networks. Since recent SSL models achieve superior performance on multiple speech downstream tasks compared to conventional speech representations (e.g., ECAPA-TDNN) [7, 11, 24, 84, 54] we select a group of SSL models finetuned for paralinguistics and linguistics tasks as candidate encoders [20, 74, 54, 78, 6]. In addition, it has been shown that early to middle model layers carry paralinguistics information, while later layers encode linguistics content [51, 5, 37, 62]; we conducted thorough analyses to examine the cross-correlation between pretrained SSL model layers (Appendix A.1) and chose layer 0-10's output from Wav2vec-XLSR finetuned for speech emotion recognition to represent style, and layer 14-21's output from Wav2vec-XLSR finetuned for automatic speech recognition, to represent linguistics information."}, {"title": "Stage 2: Supervised training", "content": "The second stage of SLIM follows a standard supervised training scheme, where the dependency features and subspace representations are concatenated and fed into a classification head to generate a binary real/fake outcome. As shown in Figure 1, the subspace SSL encoders and compression modules are obtained from Stage 1 and are all frozen during Stage 2. Since the dependency features are specifically designed to capture the style-linguistics mismatch alone, we complement them with the original embeddings in order to capture other artifacts that can help separate real samples from the fake class. The original embedding's dimensions are reduced from 1024 to 256 through an attentive statistics pooling (ASP) layer and a multi-layer perceptron (MLP) network. The projected subspace embeddings when concatenated with dependency features result in 1024-dim vectors. The classification head consists of two fully-connected layers and a dropout layer. Binary cross-entropy loss is used to jointly train the ASP and MLP modules alongside the classification head."}, {"title": "Experiments", "content": "Based on the preliminary results from Section 3.1, we systematically assess the in-domain and cross-domain detection performance of SLIM using multiple datasets, and demonstrate how such framework would benefit the interpretation of model decisions."}, {"title": "Experimental set-up", "content": "Stage 1 training. Unlike benchmark models which are trained end-to-end in a supervised manner, our model relies on two-stage training where each stage requires different training data to avoid information leakage. Since only real samples are needed in Stage 1, we take advantage of open-source speech datasets by aggregating subsets from the Common Voice [3] and RAVDESS [41] as training data and use a small portion of real samples from the ASVspoof2019 LA train for validation. Both Common Voice and RAVDESS cover a variety of speaker traits. The former is a crowdsourced dataset collected online from numerous speakers with uncontrolled acoustic environments, while the latter is an emotional speech corpus with large variations in prosodic patterns. Such data variety enables our model to learn a wider range of style-linguistics combinations.\nStage 2 training and evaluation. For a fair comparison with existing works, we adopt the standard train-test partition, where only the ASVspoof 2019 logical access (LA) training and development sets are used for training and validation. For evaluation, we use the test split from ASVspoof2019 LA [71] and ASVspoof2021 DF[40]. ASVspoof2019 LA and ASVspoof2021 DF have been used as"}, {"title": "Experiment results", "content": "Detection performance. Table 2 summarizes the detection performance of all models and compares the number of trainable parameters. We discuss the models with frozen frontend here, and compare the models with finetuned frontend in Section. 4.3. ASVspoof2019 eval set contains 19 types of attacks, out of which 6 are seen during training. This makes it the simplest of the four test datasets. We see that a majority of the models achieve near-perfect performance, with several including SLIM reporting EER below 1%. As expected, degradation is seen when models are tested on ASVspoof2021, where the majority of attacks are unseen. Both W2V-LCNN and SLIM are top-performers, with no significant difference between the two. With the out-of-domain datasets (In-the-wild and MLAAD-EN), more severe degradation is observed, where the majority report EERS over 20%. SLIM, however, outperforms the others with EER of 12.9% and 13.5% on In-the-wild and MLAAD-EN, respectively. It should be noted that although ASVspoof2021 is often used as a standard dataset to evaluate model generalizability to unseen attacks [40], part of the real samples in ASVspoof2021 originate from the same dataset (the VCTK corpus [82]) as the ASVspoof 2019 training data [71, 12, 65, 80, 75]. As a result, the real samples from ASVspoof2019 and ASVspoof2021 share a similar distribution, whereas the In-the-wild and MLAAD-EN samples share nearly no overlap with ASVspoof (further discussion in Appendix A.2). Generalization to In-the-wild and"}, {"title": "Style-linguistics mismatch of deepfakes.", "content": "Figure 2 shows the distribution of cosine distances between the style and linguistics dependency features for the real and fake classes; larger distances indicate a higher mismatch. Since the distance values approximately follow a Gaussian distribution with unequal variances, we further conduct a Welch's t-test [1] to examine the statistical significance of the difference between real and fake samples. For all three datasets, the average cosine distance is found to be significantly lower for real speech than for deepfake samples (p < 1e\u00af5). This further corroborates our hypothesis that a higher style-linguistics mismatch exists for fakes. On the other hand, the distance distributions of real and fake samples still share a large overlap, indicating that dependency features alone are not sufficient for perfectly discriminating between the two classes."}, {"title": "Analysis of style-linguistics dependency features.", "content": "Table 2 demonstrates that style-linguistics dependency features can provide better generalizability than the subspace embeddings (Table 2 SLIM variants, rows 1-4). To examine these results, we first aggregate ASVspoof2021, In-the-wild, and MLAAD-EN, and project the dependency features as well as the concatenated subspace embeddings to a"}, {"title": "Interpretation of model decisions.", "content": "Next, we perform a qualitative evaluation of the model decisions. Figure 4 shows the mel-spectrograms of four samples selected from In-the-wild. These four demonstrate typical acoustic characteristics that represent a larger group of recordings: (1) top-left is a fake sample with audible artifacts at high-frequency region; (2) top-right is a fake sample with unnaturally long pauses heard before and after the phrase \"but not\u201d; (3) bottom left is a real sample with an atypical speech style where the word pronunciations are elongated; (4) bottom right is a real speech recorded in a noisy condition. We find that among the top-performing systems shown in Table 2, only SLIM classified all four samples correctly (both frozen and fine-tuned versions; with all features), while others mostly failed on (2) and (4). Findings here suggest that SLIM provides guidance when abnormalities in style and linguistics occur. Such guidance can be complemented via post-hoc analysis tools such as human evaluations or saliency maps [4] for further interpretation.\nAdditionally, we note that the decisions made by dependency features and the original subspace representations are complementary to each other. Samples in the right column are correctly identified as fake by the dependency features but missed by the original subspace representations, and vice versa (left column missed by dependency features). These results corroborate with the nature of the two feature types. The dependency features are learned by modelling the general style-linguistics"}, {"title": "Ablation studies", "content": ""}, {"title": "Effects of finetuning SSL frontend.", "content": "From Table 2, we see that the frontend finetuning helps to further decrease the EER for SLIM. The finetuned version of SLIM performs better than the rest on (In-the-wild, MLAAD-EN), while providing comparable performance on (ASVspoof2019, 2021). However, it should be noted that the interpretation of style-linguistics mismatch becomes difficult after finetuning, since the two subspace representations may no longer be disentangled."}, {"title": "Effects of classification backend.", "content": "In the Stage 2, subspace representations are sent into ASP+MLP layers, which output 256-dim embeddings to fuse with the dependency features. Previous works have shown that different backend architectures may lead to a significant difference in the detection performance [75]. With the input fixed (dependency features and subspace embeddings), we find that removing the ASP and MLP layers degrades EER across the four datasets (Table 4, Appendix A.5), while using the LCNN [80] or LLGF [75] backends improves EER on ASVspoof2019 and ASVspoof 2021, but not on In-the-wild and MLAAD-EN."}, {"title": "Conclusion", "content": "We present SLIM, a new ADD framework that models the style-linguistics mismatch to detect deepfakes. Without requiring more labelled data or the added cost of end-to-end finetuning on pretrained encoders, SLIM outperforms existing benchmarks on out-of-domain datasets, while being competitive on in-domain datasets. The learned style-linguistics dependency features are complementary to the individual pretrained style and linguistics subspace representations and also facilitate result interpretation."}, {"title": "Limitations", "content": "Since our framework explicitly focuses on style-linguistics mismatch, it is possible that real speech samples with atypical style-linguistics dependency (e.g., samples similar Figure 4 or dysarthric speech [56]) may be misclassified as fakes. One countermeasure is to increase the diversity of real speech in the Stage 1 self-supervised training. Also, although SLIM can benefit from frontend finetuning and more advanced backends, this would affect the feature interpretation and will require modified training approaches. We plan to explore these directions in the future."}, {"title": "Appendix", "content": ""}, {"title": "Layer-wise analysis of pretrained SSL models", "content": "As mentioned in Section. 3.2.1, we use the Wav2vec-XLSR model finetuned for emotion recognition (Wav2vec-SER) and speech recognition (Wav2vec-ASR) tasks to extract the style and linguistics representations, respectively.\nThe style representation is based on the pretrained model obtained from https://huggingface. co/ehcalabres/wav2vec2-lg-xlsr-en-speech-emotion-recognition and the linguistics"}, {"title": "Dataset details", "content": "Table 3 describes the details of datasets used for Stage 1 and Stage 2 training and evaluation. Figure 6 shows the projected WavLM embeddings for real and fake samples from the four employed datasets using t-SNE. We choose WavLM since it is the top-performing model in the single-encoder category (Table 2). For both classes, an overlap can be seen between ASVspoof2019 and ASVspoof2021 samples, while samples from In-the-wild and MLAAD-EN can be separated nearly perfectly. This corroborates with the results reported in Table 2 where all employed ADD systems trained on ASVspoof2019 perform better on ASVspoof2021 than In-the-wild and MLAAD-EN."}, {"title": "Details of the compression module", "content": "Figure 7 shows the architecture of the compression module. The input is first passed through a pooling layer to obtain an average of different SSL layer outputs. Since the goal of compression modules is to project the original style/linguistics embeddings to a subspace where the compressed embeddings can be maximally correlated, we use bottleneck layers to remove the redundant information that is not shared across the two subspaces. Similar to the design of an autoencoder [70], the bottleneck layer first compresses the feature dimension from 1024-dim to 256-dim, then recovers it back to 1024-dim. In practice, we found using only one bottleneck layer is enough to obtain meaningful compressed representations. A projection head is applied at the end to reduce the final output dimension to 256."}, {"title": "PyTorch implementation of the Stage 1 training objective", "content": "Algorithm 1 shows a PyTorch-style implementation of the Stage 1 training objective, which minimizes the cross-subspace distance loss and an intra-subspace redundancy loss. The subspace embeddings are first normalized across the whole batch before passing into the loss calculations. We experimented with two types of distance for the cross-subspace loss: Euclidean and Cosine distance. While no significant difference is found when comparing the performance achieved by the two, the former provides slightly better results, hence is adopted as the final distance measure."}, {"title": "Performance comparison of different backend classifiers", "content": "Table 4 shows the performance obtained when the ASP+MLP layers are swapped with other layer choices."}, {"title": "Hyperparameters and computation resources", "content": "Table 5 describes the optimal hyperparameters and architecture details of SLIM used for Stage 1 and Stage 2 training. The hyperparameter names of the data augmentation modules can be found in SpeechBrain v1.0.0."}], "equations": ["L_{con} = L_{cross} + L_{intra},\\\\ L_{cross} = \\frac{1}{T} \\sum_{t=0}^{T} || S_{f,t} - L_{f,t} ||, \\\\ L_{intra} = L_{style} + L_{linguistics}", "L_{intra} = ||\\bar{S_f} || + ||\\bar{L_f} ||"]}