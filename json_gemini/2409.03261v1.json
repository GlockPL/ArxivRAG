{"title": "Bones Can't Be Triangles:\nAccurate and Efficient Vertebrae Keypoint\nEstimation through Collaborative Error Revision", "authors": ["Jinhee Kim", "Taesung Kim", "Jaegul Choo"], "abstract": "Recent advances in interactive keypoint estimation methods\nhave enhanced accuracy while minimizing user intervention. However,\nthese methods require user input for error correction, which can be costly\nin vertebrae keypoint estimation where inaccurate keypoints are densely\nclustered or overlap. We introduce a novel approach, KeyBot, specifically\ndesigned to identify and correct significant and typical errors in exist-\ning models, akin to user revision. By characterizing typical error types", "sections": [{"title": "1 Introduction", "content": "Accurate vertebrae keypoint estimation from X-ray images is crucial for effec-\ntive medical diagnosis and treatment planning [20, 23], with errors having sig-\nnificant impacts on clinical decisions, such as in spinal surgeries and pain man-\nagement [6, 13, 15]. This task presents a distinct set of challenges due to the\ncomplex anatomy of the spine [17,27]. The similar and repetitive shapes of ver-\ntebrae complicate distinguishing between individual vertebrae and accurately\nestimating their keypoints, as shown in Fig. 1. This requires a deep understand-\ning of sequential context and anatomy, unlike more distinct keypoints found in\nhuman pose [5,9,14, 19] or facial keypoint [1,3] estimation tasks.\nSuch challenges often result in significant errors during automated vertebrae\nkeypoint estimation, including vertex misidentification, bone misidentification,\nand left-right inversion, as illustrated in Fig. 2. Manual revision of these er-\nrors is time-consuming and labor-intensive, especially as the number of verte-\nbrae increases. Missing even a single vertebra can lead to extensive adjustments,\nthereby significantly increasing the time and effort required for accurate anno-\ntation. To mitigate these, interactive keypoint estimation approaches have been\ndeveloped, significantly improving performance with minimal user input [10,26].\nThese methods aim to automatically refine inaccurate keypoints with minimal\nuser feedback, using the feedback as a hint to adjust the remaining errors, as\nshown in Fig. 3(a). However, they heavily rely on users to identify and cor-\nrect errors, which can be time-consuming and labor-intensive, especially when\nerroneous keypoints are densely clustered or overlapped.\nIn response, we introduce a novel method named KeyBot, designed to au-\ntonomously detect and correct specific errors in vertebrae keypoint estimation\nbefore user evaluation, building upon existing interactive keypoint estimation\nmodels, as illustrated in Fig. 3(b). Initially, the interaction model predicts key-\npoints based on the input image. During refinement, KeyBot autonomously pre-\nevaluates these predictions, identifies specific errors, and provides corrective feed-\nback similar to user input. In contrast to previous models requiring at least one\nuser input, KeyBot autonomously refines model predictions before user input.\nWe generate synthetic data characterizing typical error types, vertex misiden-\ntification, bone misidentification, and left-right inversion, and train KeyBot using\nthis data to focus specifically on predefined error types. Independently trained\nfrom the interaction model, KeyBot effectively identifies errors that might be"}, {"title": "2 Related work", "content": "Automated error refinement. Despite the advancements in deep learning,\nerrors in model predictions remain a formidable challenge. To mitigate these in-\naccuracies, a specialized area of research dedicated to refining prediction results\nhas emerged, leading to the development of advanced methods for identifying\nand correcting errors in model outputs [4,14,16,25]. For example, Qu et al. [16]\nintroduced a method leveraging attention maps to detect label errors in CT\ndata, markedly improving annotation efficiency and facilitating the collection\nof extensive datasets. Similarly, efforts to refine keypoint estimation have been\nnoteworthy. For instance, Ronchi et al. [18] analyzed human pose estimation\nresults to categorize three main types of errors, while Moon et al. [14] devel-\noped a method that specifically addresses and corrects these categorized errors,\nachieving state-of-the-art human pose estimation performances.\nDespite these advancements, estimating vertebrae keypoints from X-ray im-\nages introduces additional challenges due to the complex sequential structure of\nthe spine. Error patterns, such as the mislocalization of an entire vertebra, often\nrequire extensive user inputs for correction. In response, we propose KeyBot,"}, {"title": "3 KeyBot", "content": "We introduce KeyBot, a novel method designed to enhance vertebrae keypoint\nestimation by identifying and correcting errors prior to user intervention. We\nemploy an existing interactive model that can incorporate user feedback for in-\nteractive modifications. Given model predictions, KeyBot identifies erroneous\nkeypoints and generates their pseudo-corrections, which are then fed to the in-\nteraction model for updates. KeyBot consists of two components: The detector\ndiscerns whether each input keypoint is accurate, and the corrector refines input\nkeypoints accurately. Both components are trained with synthetic errors to focus\nspecifically on the target error types."}, {"title": "3.1 Overview of the propose approach", "content": "Interactive keypoint estimation framework. Consider an interactive key-\npoint estimation model \\(F_\\theta\\) with parameters \\(\\theta\\), operating on an image \\(x\\). The\nmodel aims to precisely estimate K target keypoints through user-interactive"}, {"title": "The KeyBot framework", "content": "KeyBot offers an automated keypoint refinement\nstep that precedes and complements the existing user-based refinement, effec-\ntively reducing the need for user interaction in the process. KeyBot consists of\nthe detector \\(G_{\\phi_D}\\) and corrector \\(G_{\\phi_C}\\), which together identifies and corrects in-\naccurate keypoints predicted by \\(F_\\theta\\). Following each prediction iteration of \\(F_\\theta\\),\nKeyBot evaluates yt and suggests necessary corrections, identifying erroneous\nkeypoints \\(v_{t,n+1}\\) and their pseudo corrections \\(z_{t,n+1}\\):\n\\(v_{t,n+1} = G_{\\phi_D}(x, y_{t,n}) \\) and \\(z_{t,n+1} = G_{\\phi_C}(x, y_{t,n}),\\)\nwith \\(y_{t,0} : = y_t\\). This step is similar to the user interaction step outlined in\nEq. (2). Here, KeyBot can detect multiple inaccurate keypoints at once and\nsimultaneously offer corrective feedback for each identified error. If no inaccu-\nracies are detected by the detector, KeyBot concludes and \\(y_{t,n}\\) becomes the\nfinal prediction. Revision information, \\(c_{t,n}\\), now includes both user \\((u_{t,n})\\) and\nmodel \\((z_{t,n})\\) corrections. Here, user modifications are prioritized as the defini-\ntive ground truth. Thus, keypoints already revised by the user are exempt from\nfurther updates by the pseudo-corrections from KeyBot.\n\\(c_{i,n+1} = z_{i,n+1} \\) for \\(i \\in v_{t,n+1} \\setminus p_t.\\)\nPrevious work [10,22] relies solely on the prediction at the most recent step as the\nprevious prediction, as described in Eq. (3). However, this approach can result\nin losing track of erroneous predictions once they are corrected in the model.\nHence, our approach accumulates predictions identified as erroneous by either\nKeyBot or the user across all iterations. These false predictions retain the history\nof incorrect predictions and serve to inform the model about specific prediction\nerrors to avoid, thereby guiding it toward more accurate future predictions:\n\\(e_{i,n+1} = y_{i,n} \\) for \\(i \\in v_{t,n+1} \\setminus v_{t,:n} \\setminus p_t.\\)\nHere, e denotes predictions modified by either the user or KeyBot. Finally, these\nare then fed back into the backbone interaction network for a new, corrected\nprediction akin to user feedback:\n\\(y_{t,n+1} = F_\\theta(x, c_{t,n+1}, e_{t,n+1}).\\)\nEach iteration of KeyBot contributes progressively towards enhancing the overall\naccuracy and reliability of the keypoint predictions. This cycle repeats until the\ndetector detects no errors or the maximum KeyBot iteration count N is reached.\nUpon the KeyBot process concludes, say, after n+1 iterations, the prediction\n\\(y_{t,n+1}\\) is established as the final output for the t-th iteration of the interactive\nkeypoint estimation process. For the subsequent (t+1)-th user-side phase, given\nnew user feedback as Eq. (2), \\(c_{t,n+1}\\) and \\(e_{t,n+1}\\) are updated to \\(c_{t+1,0}\\) and \\(e_{t+1,0}\\),\n\\(c_{t+1,0} = u_{t+1}\\) and \\(e_{i,t+1,0} = y_{i,n+1} \\) for \\(i \\in p_{t+1},\\)\nand the keypoints are revised accordingly:\n\\(y_{t+1,0} = F_\\theta(x, c_{t+1,0}, e_{t+1,0}).\\)\nThe complete procedure is summarized in Algorithm 1 in Appendix B."}, {"title": "3.2 Model design of KeyBot", "content": "KeyBot integrates the detector and corrector to identify potential errors and\ngenerates corrective feedback for their revision.\nError detector. The error detector specializes in identifying up to K erroneous\nkeypoints, focusing on prevalent error types in vertebrae keypoint estimation.\nOur empirical analysis indicates that evaluating the entire bone structure at once\nis less effective for error detection. Therefore, the detector evaluates keypoints\nin smaller groups, examining \\(k \\leq K\\) keypoints simultaneously. This approach\nsimplifies the task and improves its performance. During training, we randomly\nselect a set of consecutive groundtruth keypoints y* and either maintain their\naccuracy or introduce errors. The cropped image area around these keypoints,\nalong with their corresponding Gaussian keypoint heatmaps, are input to the\ndetector. It then predicts the likelihood of error presence in each keypoint.\nLet \\(\\varepsilon\\) denote the function that induces synthetic errors in groundtruth key-\npoints, and \\(v\\) represents the anomaly labels for the keypoints. The detector\nperforms multi-label binary classification to differentiate between normal and\nabnormal keypoints using a sigmoid function in its output layer. It is supervised\nto minimize the Binary Cross-Entropy (BCE) loss between the anomaly labels\n\\(v\\) and the predictions:\n\\(\\Phi_r \\leftarrow \\phi_r - \\eta_r \\nabla_{\\phi_r} L_{bce}(v, G_{\\phi_r}(x, \\varepsilon(y^*)),\\)\nwith \\(\\eta_r\\) representing the learning rate for the detector.\nDuring inference, the detector iteratively detects errors across all keypoints,\nexamining k keypoints at a time with a stride of s. To facilitate a comprehensive\nassessment of each keypoint in different contexts, we set the stride s to be smaller\nthan k. This results in multiple predictions for a single keypoint, and if any\nprediction indicates an anomaly, the keypoint is flagged as erroneous."}, {"title": "3.3 Training KeyBot via realistic error simulation", "content": "KeyBot aims to address significant and typical errors in vertebrae keypoint es-\ntimation. The key idea is to train KeyBot to identify and correct three error\ntypes commonly observed in vertebrae keypoint estimation: vertex misidentifi-\ncation, bone misidentification, and left-right inversion. During training, KeyBot\nis provided with both accurate keypoints and keypoints with synthetic errors.\nWe randomly simulate the predefined error types, as shown in Fig. 5. Rather\nthan relying on highly variable and not clearly defined real errors, we use char-\nacterized and consistent synthetic errors.\nBy employing this training approach, we expose KeyBot to a wide range of er-\nror scenarios, equipping it with the proficiency to detect and correct these errors\neffectively. As a result, KeyBot provides a targeted evaluation of the keypoints\npredicted by the interaction model, focusing on specific error types.\nVertex misidentification (misvertex). Misvertex is a type of error where\na keypoint is correctly identified on a vertex of a vertebrae but is incorrectly\nattributed to the wrong vertex. For instance, a keypoint intended for the first\nvertex is inaccurately predicted at the third vertex. To simulate misvertex, we\nrandomly displace a keypoint to its neighbors within a [-r, +r] index range for a\npredefined number r, excluding its original position. Keypoints moving beyond\ntheir index range wrap around cyclically.\nBone Misidentification (misbone). Misbone errors represent errors where\nthe entire vertebra is incorrectly classified. Our simulation randomly shifts key-\npoints up or down by one vertebra. This is achieved by selecting start and end\nkeypoint indices and moving all-encompassed keypoints to an adjacent vertebra.\nLeft-right inversion (lr-inversion). LR-inversion occurs when keypoint pairs\nare incorrectly positioned on the opposite lateral side. To simulate LR-inversion\nin our model, we randomly interchange the positions of keypoint pairs that\ndelineate one side of each vertebra."}]}