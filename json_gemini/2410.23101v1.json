{"title": "Guided Game Level Repair via Explainable AI", "authors": ["Mahsa Bazzaz", "Seth Cooper"], "abstract": "Procedurally generated levels created by machine learning models can be unsolvable without further editing. Various methods have been developed to automatically repair these levels by enforcing hard constraints during the post-processing step. However, as levels increase in size, these constraint-based repairs become increasingly slow. This paper proposes using explainability methods to identify specific regions of a level that contribute to its unsolvability. By assigning higher weights to these regions, constraint-based solvers can prioritize these problematic areas, enabling more efficient repairs. Our results, tested across three games, demonstrate that this approach can help to repair procedurally generated levels faster.", "sections": [{"title": "Introduction", "content": "Procedural Content Generation via Machine Learning (PCGML) involves generating game content using models trained on existing game content (Summerville et al. 2018). These models aim to produce solvable levels, which players can complete by moving from the start to the end of the level through a series of valid movements while completing tasks and avoiding obstacles.\nHowever, due to the noisy nature of ML-based generation, a repair step is often necessary in PCGML approaches to make the generated levels usable (Chen et al. 2020). The initial outputs from these models often include levels that are impossible to complete or contain broken structures with missing or incorrectly arranged elements (e.g., pipes in platformer games or broken decorations in puzzle games). Consequently, recent research has focused on developing methods to repair these levels by making the necessary adjustments.\nOne popular approach to level repair involves using constraint satisfaction. This method represents the problem as a collection of constraints over variables and seeks an assignment of values to these variables that satisfies all constraints. Constraint solvers are software tools that search through possible assignments to find one that satisfies the constraints or they prove that no such assignment exists.\nIn the context of level repair, the process generally starts with the largest possible set of candidate values for each"}, {"title": "Related Work", "content": "Solvability is a crucial aspect of procedural level generation. However, unsolvable levels are almost inevitable since current machine learning models cannot consistently ensure the satisfaction of a constraint like solvability. As a result, various \"generate-then-repair\" approaches have been developed to address this issue. Cooper and Sarkar (2020) introduced a pathfinding agent capable of repairing levels as part of testing levels for solvability. Their results show that the repair agent could improve the solvability of the level at the cost of an increase in time. Jain et al. (2016) leveraged the lossy nature of AutoEncoder reproduction to repair broken levels and classify them into different styles. Mott, Nandi, and Zeller (2019) applied long-short term memory recurrent neural network (LSTM) to repair locally incoherent sections of GAN-generated levels. Zhang et al. (2020) constructed a framework to repair GAN-generated levels using a mixed-integer linear program (MILP) with solvability constraints. Chen et al. (2020) tried repairing the results of translating image representation (pixels) into a level representation (tiles) with Autoencoders and Markov chains. Most relevant to our work, Shu et al. (2020) attempted to repair errors in pipe tile placement using a combination of multi-layer perceptron and genetic algorithms; their approach, similar to ours, trains a model to directly find locations of misplaced tiles. However, in their approach, information about misplaced tiles is used by an evolutionary repairer, and focuses mainly on local tile placements. On the other hand, our work uses the attributions from explainable classifiers to inform weighted level repair and concentrates primarily on the global solvability of levels."}, {"title": "Solvability Analysis", "content": "Path-finding agents and level classifiers have been utilized in order to help generate solvable levels.\nSnodgrass and Onta\u00f1\u00f3n (2014), Volz et al. (2018), and other studies, used Robin Baumgarten's A* controller (Togelius et al. 2011) to divide the generated maps into solvable and unsolvable. The tile-based agent of Summerville, Philip, and Mateas (2015) has also been utilized in many projects in order to determine if levels are solvable or unsolvable (Summerville and Mateas 2016; Snodgrass and Ontan\u00f3n 2016). More recently, deep neural network classifiers have been employed for level solvability classification as well. ? used Pool-based Active learning to train solvability classifiers that require very few labeled levels."}, {"title": "Model Explainability", "content": "Given that recent work has applied deep learning methods to classifying level solvability, explainable classifiers become relevant. Model explainability refers to the degree to which a human is able to understand the reasons behind a choice or prediction made by the model. Explainable machine learning methods can be used to discover knowledge, to debug or justify the model and its predictions, and to improve the model. Machine learning models can be categorized as glass-box or black-box (Rai 2020). Glass-box models are inherently explainable to the user, but black-box models need explainability methods to generate explanations. There are multiple techniques used in explainable artificial intelligence (XAI) to understand the decisions made by these complex machine learning models, particularly deep neural networks.\nTwo widely adopted explainability methods in computer vision are Deep SHAP and Integrated Gradients, which help in understanding decisions made by classifiers.\nDeep SHAP is an explainability technique that can be used for models with a neural network architecture (Shrikumar et al. 2016). It combines Shapley values with the DeepLIFT algorithm to approximate the conditional expectations of Shapley values using a selection of background samples (Lundberg and Lee 2017a). Shapley values (Shapley et al. 1953) are one of the measures of feature importance from cooperative game theory, to attribute the contribution of each feature to the model's output. It computes the importance of each feature by considering all possible combinations of features and their effects on the prediction.\nIntegrated Gradients provide a robust and interpretable method for understanding the contributions of input features to the predictions of the classifier. It computes the integral of the gradients of the model's output concerning its input along a straight path from a baseline to the input of interest. By integrating the gradients, Integrated Gradients assign importance scores to input features, indicating how much they contribute to the model's decision (Sundararajan, Taly, and Yan 2017).\nZhu et al. identified Model Explainability as a valuable research area and proposed various research questions and case study scenarios. For example, one suggestion was to make the noise vector in a GAN model explainable, allowing users to control the output by modifying the noise vector."}, {"title": "System Overview", "content": "Traditionally in explainable AI, feature attribution refers to how much each feature (e.g., pixels of an image) influences the model's output. For example, in a model designed to detect cats in images, feature attribution might highlight specific areas of the image, such as the shape of the ears or the pattern of the fur, indicating that these features significantly contribute to the model's decision that the image contains a cat. This work proposes training a solvability classifier with a dataset of solvable and unsolvable levels. The classifier will then provide relative attributions indicating the contribution of each tile to the classification of a level's solvability. In out work, these attributions can be converted into penalty weights to guide the repair process, where tiles with higher attributions to the classification receive lower weights and are thus less penalized for changes during the repair. Ideally, this guidance helps the constraint solver to repair the level more efficiently.\nTo evaluate the effectiveness of weights derived from explainable classification, we developed a controlled pipeline for unsolvable level repair, allowing comparison of various"}, {"title": "Domains", "content": "This work experiments on three different game domains of Super Mario Bros. (Mario) (Nintendo 1985), Cave, and Super Cat Tales (Supercat) (Neutronized 2016). The Mario levels are based on the level 1-1 from the VGLC (Summerville et al. 2016). Cave is a top-down cave map introduced by Cooper (2022a); this custom game is created with image tiles from Kenney (Kenney 2022). Supercat is also a platforming game with wall and ledge jumps; a simplified version of the actual game's movement patterns is used. The example levels as well as patterns and reachability templates used in this work are borrowed from the original work on Sturgeon (Cooper 2022a). The Mario levels are in size 14 \u00d7 18, Cave levels 15 \u00d7 12, and Super Cat Tales levels 20 x 20."}, {"title": "Level Generation", "content": "In this work, we used the Sturgeon constraint-based level generation system (Cooper 2022b), which generates levels by converting high-level design rules into constraint satisfaction problems and can use different \"low-level\" solvers to find solutions. This system is also capable of generating unsolvable levels by incorporating additional constraints that a level's goal is not reachable from its start (Cooper and Bazzaz 2024). This constraint-based level generator gave us the controllability to evaluate the performance of weight generation methods regardless of the level generation model."}, {"title": "Explainable Classification", "content": "Figure 4 illustrates sample attributions of a Mario level and the rescaled values into weights. We used a unified classifier for the solvability classification of levels in all three domains. We used a minimal representation version of games to train the classifier that consists of 4 tile types. We created a unified simple affordances that include Solid, Empty, Start, End and we simplified all games into these affordances. Figure 3 shows this new representation for all three domains."}, {"title": "Weight Generation", "content": "The tile attributions are processed into weights for the repair solver. The primary goal at this stage is to identify regions of the level with the highest attribution values. To achieve this, the 80th percentile threshold of the attributions is calculated. This threshold captures the top 20% of values, effectively filtering out lower values.\nNext, a binary map is created by comparing each attribution value against the percentile threshold. Connected component labeling is then employed to extract regions from the original level, focusing exclusively on components that are connected. Using OpenCV's connectedComponentsWithStats function (Bradski 2000), we analyze the connected components within the binary map to identify the label corresponding to the largest connected component in terms of area.\nSolvers that accept weights as an additional input consider the weights as penalties for changing a tile. Consequently, we assign the largest connected component within the attributions the lowest weight, increasing the likelihood that the solver will modify this area of the level. After identifying the regions with higher attribution values and determining the connected region from the original level, we scale the high values to weight 1 and the others to weight 10."}, {"title": "Level Repair", "content": "Sturgeon is capable of repairing unsolvable levels by making minimal changes to the original level (Cooper 2022b). This is accomplished by converting the repair task into a constraint satisfaction problem and using constraint solvers to either find a solution or prove that none exists.\nUnlike agent-based repair methods, this approach ensures the level is in a definite state after repair. The solver either finds a solution, which may take a considerable amount of time, or confirms that no solution exists, eliminating the need for agents to play the level to verify the repair.\nThe repair process asks the solver to create a solvable level while imposing soft constraints to match the original level's tile placements as closely as possible. Because this procedure can be more time-consuming than generating a new level, we introduce an enhancement to Sturgeon's original method: the option to assign per-location tile weights. This allows each tile in the level to have a different penalty for deviating from the original layout. These weights are integrated into the constraint problem for the solver.\nEssentially, Sturgeon applies a reachability constraint from the start to the end of the level as a hard constraint and uses per-location tile weights as soft constraints to guide the solver in finding a solvable level."}, {"title": "Mixed-Integer Linear Programming Solver", "content": "Sturgeon uses a small \u201cmid-level\" API to translate constraint satisfaction problems into \u201clow-level\u201d solvers, which do the actual solving (Cooper 2022b). Although previous to this work, Sturgeon had support for several SAT- and ASP-based solvers, in the preliminary development of this project we explored the potential of using Linear Programming approaches for a new low-level solver. While Linear Program-ming has been used previously for level repair by Zhang et al. (2020), in their work, they directly encoded the specific problem of level repair, whereas we indirectly encode it through the functions available in Sturgeon's mid-level API in such a way that the encoding could be used for other applications using Sturgeon (e.g. level generation).\nBecause Sturgeon's use of a MILP solver is introduced in this work, we provide more information about its implementation. However, the details of the MILP solver are not necessary to follow the other contributions of this work.\nHere we describe how Sturgeon formulates its constraint problems for a low-level Mixed-Integer Linear Programming (MILP) solver (The SciPy community 2024). The goal of a MILP is to find assignments for a vector of numerical variables x that minimizes the weighted sum of the variables, where the weights are given by another vector c, i.e. finding argmin.cx. The variables can have bounds placed on them directly, i.e. s < x < t, and bounds can be placed on weighted sums of the variables, i.e. u < Ax < v. Additionally, given elements of x can be required to be integers.\nTo convert the Boolean constraint satisfaction problem into a MILP, each Boolean variable v in the original problem is given a corresponding numerical variable $x_v$, as well as a corresponding entry in the weight vector $c_v$. A numerical variable value of 1 corresponds to a Boolean value of true, and a numerical value of 0 corresponds to false. As Boolean constraints include Boolean literals both a variable and a polarity (i.e. v or \u00acv) for a given literal l, we also use $x_l$ to refer to the numerical variable for a literal's Boolean variable $x_v$. Note that additional variables can be allocated as needed (described below).\nThen, all variables $x_i \\in x$ have the constraint that they are integers ($x_i \\in Z$) and are either zero or one (0 \u2264 x \u2264 1), thus s = 0 and t = 1. Although this setup could be formulated as a zero-one integer program, in practice we use MILP solvers, which support real-valued variables, but constrain them to be integers.\nWhat remains to complete the MILP is then to fill in the values for the matrix A and the weight vector c. The weight for all the variables in the initial problem is set to 0 as there is no preference for their being true or false, i.e.\n$c_v = 0$\nexcept for the additional weighting variables described below. To fill in A, we specify additional linear constraints on the variables, also described below.\nThe core of the approach is that, when using the numerical variables to constrain counts of Boolean literals that evaluate to true, positive variables can be included in the constraint directly as $x_v$, and negative variables can be included as 1 - $x_v$ with the 1 then incorporated into the bounds. For example, a constraint that at most 1 of the literals i and \u00acj are true would be:\n$x_i + (1 - x_j) \\le 1$\nor,\n$x_i - x_j \\le 0$"}, {"title": "Evaluation", "content": "We evaluated the performance of this level repair approach based on the duration that it takes to repair a level (including running an explainable classifier if used), the number of changes made to the level to be repaired, and the winning solver that repaired the level. Figure 5 shows the cumulative number of repaired levels in time. We used a time limit of 4000 seconds for each level to be repaired. Our results indicate that repair assistance with attributions can accelerate the repair process, particularly for larger and more complex game levels. The Cave levels, being generally easy and quick to repair, did not show as large an improvement with aided repair. On the other hand, Mario and Supercat levels, which are more challenging to repair, showed a reduction in repair time with the aid of attributions. Note that not all the 1000 has been repaired as some of the repairs were cut off by the time limit. Table 1 shows the corresponding detailed statistics of the repair times of different games with different methods, excluding the repair times of levels that were not completed due to the time limit.\nWe also examined the number of changes made to repair each level to determine if any method requires fewer changes or if any method is prone to making more unnecessary changes. Table 2 demonstrates no major difference in the number of changes among the methods. Across different games, the median number of changes is consistent, although the means and standard deviations vary. This might be due to the inclusion of different sets of levels, with some methods repairing levels not addressed by others."}, {"title": "Discussion", "content": "This work focuses exclusively on repairing levels using attribution values derived from an explainable solvability classifier. We see potential in leveraging attribution values from classifiers for other features, such as amusingness, linearity, and more, to generate new levels from existing ones.\nIt is important to note that to obtain valuable attribution values, it is crucial to use high-quality classifiers. Although training the classifier adds some overhead, this investment pays off by enabling faster level repairs. This approach could be particularly advantageous for larger, more complex segments, where solvers typically encounter the greatest difficulties. In these challenging scenarios, providing the solver with weighted inputs can offer significant benefits. While this project did not address working on larger levels, future research should focus on exploring this area.\nFor the sake of controllability, this study concentrated on the repair pipeline and employed Sturgeon's impossible level generator to produce unsolvable levels. We acknowledge that using Sturgeon in this pipeline is a current limitation. However, it provided a reliable method for running experiments across a large number of levels and evaluating the performance. We believe this approach can be extended to other level generators that produce undesirable outputs beyond solvability, such as local patterns, structures, and style. Although this work utilized 2D grid-based levels, we believe the general approach can be applied to other repair contexts where an explainable classifier can attribute features that inform the repair process, such as edges on a mesh or notes in a melody."}, {"title": "Conclusion", "content": "Level repair using constraint solvers is a practice applied in Procedural Content Generation via Machine Learning (PCGML). However, these solvers often require significant time to complete the repair process. To address this issue, we propose the use of explainable solvability classifiers to expedite the repair process. By calculating the contribution of each tile location to the level's unsolvability, we assist the constraint solver with weighted inputs that correspond to these contributions. Our results indicate that this method reduces the repair time while typically changing same number of tiles from the levels."}]}