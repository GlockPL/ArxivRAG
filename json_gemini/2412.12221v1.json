{"title": "Parallel Greedy Best-First Search with a Bound on the Number of Expansions Relative to Sequential Search", "authors": ["Takumi Shimoda", "Alex Fukunaga"], "abstract": "Parallelization of non-admissible search algorithms such as GBFS poses a challenge because straightforward parallelization can result in search behavior which significantly deviates from sequential search. Previous work proposed PUHF, a parallel search algorithm which is constrained to only expand states that can be expanded by some tie-breaking strategy for GBFS. We show that despite this constraint, the number of states expanded by PUHF is not bounded by a constant multiple of the number of states expanded by sequential GBFS with the worst-case tie-breaking strategy. We propose and experimentally evaluate One Bench At a Time (OBAT), a parallel greedy search which guarantees that the number of states expanded is within a constant factor of the number of states expanded by sequential GBFS with some tie-breaking policy.", "sections": [{"title": "1 Introduction", "content": "Best-first search (BFS) algorithms such as A*(Hart, Nilsson, and Raphael 1968) and GBFS (Doran and Michie 1966) are a key component of planning and scheduling systems. In order to fully exploit the increasing number of cores on modern CPUs, it is necessary to parallelize these BFS algorithms. Successful approaches to parallelization have been developed for admissible BFS algorithms such as A*(Burns et al. 2010; Kishimoto, Fukunaga, and Botea 2013; Phillips, Likhachev, and Koenig 2014).\nParallelization of GBFS has turned out to be more challenging. Parallel portfolios which execute completely independent instances of GBFS (with a different tie-breaking on each thread), e.g., (Kuroiwa and Fukunaga 2020) are a simple approach. However, this approach does not exploit the potential for explicit cooperation among threads.\nA natural approach to implement a more \u201ccooperative\" multi-threaded search is to use shared data structures (Open, Closed), similar to parallel A*. It is easy to implement a state expansion policy which seems similar to sequential GBFS, e.g., \"expand a state with the best heuristic value in the (shared) Open list\". However the resulting state expansion behavior of such a parallel GBFS can deviate drastically from that of sequential GBFS. This poses two issues: (1) the relationship between the states expanded by parallel vs. sequential GBFS is nontrivial to analyze theoretically, and it is difficult to answer basic questions such as: \"what is the worst-case performance of this parallel GBFS relative to sequential GBFS?\" (2) For some problems, the empirical performance of parallel GBFS is much worse than sequential GBFS, resulting in orders of magnitude of slowdown on some IPC benchmarks (Kuroiwa and Fukunaga 2019), and in general, the number of states expanded by simple approaches to parallel GBFS with shared Open and/or Closed lists is not bounded by a constant factor relative to sequential GBFS (Kuroiwa and Fukunaga 2020).\nPrevious work proposed PUHF (Kuroiwa and Fukunaga 2020), a parallel GBFS algorithm which is constrained to only expand states in the Bench Transition System (BTS), the set of states that can be expanded by some tie-breaking strategy for GBFS (Heusner, Keller, and Helmert 2017). The BTS provides a natural theoretical constraint on the states expanded by an algorithm which \"behaves similarly to sequential GBFS\", somewhat analogous to the (much stronger) constraint that a parallel A*must expand all states with evaluation value less than the optimal. However, although PUHF guarantees that only states in the BTS are expanded, it does not guarantee a bound on the number of states expanded compared to sequential GBFS, i.e., PUHF provides a qualitative guarantee about search behavior, but it does not provide any performance guarantee.\nThus, previous parallel GBFS algorithms with shared Open/Closed lists pose an unbounded risk on any given instance, parallel GBFS may outperform sequential GBFS, or it may perform much worse, with no known general bound on how badly search performance can degrade. In this paper, we directly address the problem of establishing a bound on the number of states expanded by parallel GBFS relative to sequential GBFS. While PUHF constrained expansion to only states which could be expanded by sequential GBFS with some tie-breaking strategy, we propose a new algorithm which further constrains the search so that it explores only one bench at a time. This allows us to bound the number of state expansions by parallel search to be no worse than the number of states expanded by sequential search with some tie-breaking policy plus a small constant."}, {"title": "2 Preliminaries and Background", "content": "State Space Topology State space topologies are defined following Heusner, Keller, and Helmert (2018).\nDefinition 1. A state space is a 4-tuple \\(S = (S, succ, S_{init}, S_{goal})\\), where \\(S\\) is a finite set of states, \\(succ : S \\rightarrow 2^S\\) is the successor function, \\(S_{init} \\in S\\) is the initial state, and \\(S_{goal} \\subseteq S\\) is the set of goal states. If \\(s' \\in succ(s)\\), we say that \\(s'\\) is a successor of \\(s\\) and that \\(s \\rightarrow s'\\) is a (state) transition. \\(\\forall s \\in S_{goal}, succ(s) = \\emptyset\\). A heuristic for \\(S\\) is a function \\(h : S \\rightarrow R\\) and \\(\\forall s \\in S_{goal},h(s) = 0\\). A state space topology is a pair \\((S, h)\\), where \\(S\\) is a state space.\nWe call a sequence of states \\((s_0,..., s_n)\\) a path from \\(s_0\\) to \\(s_n\\), and denote the set of paths from \\(s\\) to \\(s'\\) as \\(P(s, s')\\). \\(s_i\\) is the \\(i\\) th state in a path \\(p\\) and \\(|p|\\) is the length of \\(p\\). A solution of a state space topology is a path \\(p\\) from \\(s_{init}\\) to a goal state. We assume at least one goal state is reachable from \\(s_{init}\\), and \\(\\forall s \\in S, s \\notin succ(s)\\).\nBest-First Search Best-First Search (BFS) is a class of search algorithms that use an evaluation function \\(f : S \\rightarrow \\mathbb{IR}\\) and a tie-breaking strategy \\(\\tau\\). BFS searches states in the order of evaluation function values (f-values). States with the same f-value are prioritized by \\(\\tau\\). In Greedy Best-First Search (GBFS; Doran and Michie 1966), \\(f(s) = h(s)\\).\nK-Parallel GBFS (KPGBFS) K-Parallel BFS (Vidal, Bordeaux, and Hamadi 2010) is a straightforward, baseline parallelization of BFS. All k threads share a single Open and Closed. Each thread locks Open to remove a state \\(s\\) with the lowest f-value in Open, locks Closed to check duplicates and add \\(succ(s)\\) to Closed, and locks Open to add \\(succ(s)\\) to Open. KPGBFS is KPBFS with \\(f(s) = h(s)\\). Algorithm 1 shows the pseudocode for KPGBFS."}, {"title": "T-bounded and T-pathological", "content": "Kuroiwa and Fukunaga (2020) proposed the following in order to classify the quantitative behavior of parallel BSF algorithms.\nDefinition 2. Given a state space topology T, a search algorithm A is t-bounded relative to search algorithm B on T iff A performs no more than t-times as many expansions as B. A is t-pathological relative to search algorithm B on T iff A is not t-bounded relative to B on T.\nA is t-bounded relative to B iff A is t-bounded relative to B for all state space topologies. A is t-bounded relative to B on state space topologies with the property P iff A is t-bounded relative to B for all state space topologies with P.\nA is pathological relative to B iff for all \\(t > 0\\) there exists a state space topology T, such that A is t-pathological relative to B on T. A is pathological relative to B on state space topologies with property P iff for all \\(t > 0\\) there exists a state space topology T with property P such that A is t-pathological relative to B on T.\nKuroiwa and Fukunaga (2020) showed that straightforward parallelizations of GBFS with shared Open and/or Closed, including KPGBFS, are pathological."}, {"title": "Bench Transition Systems", "content": "Heusner et al. (2017) defined progress states and bench transition systems in order to characterize the behavior of GBFS, building upon the definition of high-water marks by Wilt and Ruml (2014).\nDefinition 3. Let \\((S, h)\\) be a state space topology with states S and \\(P(s) = {p \\in P(s,s') | s' \\in S_{goal}}\\}. The high-water mark of \\(s \\in S\\) is\n\n\n\n\\(hwm(s) := \\begin{cases} min_{p\\in P(s)} (max_{s'\\in p} h(s')) & \\text{if } P(s) \\neq \\emptyset \\\\  \\infty & \\text{otherwise} \\end{cases}\\)\n\n\nThe high-water mark of a set of states \\(S' \\subseteq S\\) is defined as\n\n\\(hwm(S') := min_{s\\in S'} hwm(s)\\)"}, {"title": "3 Pathological Behavior of PUHF", "content": "In this section, \u201cPUHF\" refers to PUHF (Kuroiwa and Fukunaga 2020) and PUHF2-4 (Shimoda and Fukunaga 2023) \u2013 although these PUHF variants use slightly different state expansion constraints, the arguments and conclusions below are unaffected by these differences.\nWhile PUHF is guaranteed to only expand states in the BTS, previous work did not guarantee a bound on the number of states expanded relative to sequential GBFS. We show that in fact PUHF is pathological relative to sequential GBFS. The example we use in the proof motivates OBAT, the new bounded approach we propose in Section 4.\nConsider the search space in Figure 1. GBFS, under any tie-breaking policy must expand either \\(s_0 \\rightarrow s_{1,1} \\rightarrow s_{2,1} \\rightarrow s_{3,1} \\rightarrow S_{goal}, s_0 \\rightarrow s_{1,2} \\rightarrow s_{2,2} \\rightarrow s_{3,2} \\rightarrow s_{4,2} \\rightarrow S_{goal}\\), or \\(s_0 \\rightarrow s_{1,2} \\rightarrow s_{2,3} \\rightarrow s_{3,3} \\rightarrow s_{4,3} \\rightarrow S_{goal}\\) where \\(s^i\\) denotes a line of \\(x\\) states.\nHowever, PUHF with \\(k \\geq 2\\) (k is the number of threads) may (depending on tie-breaking) expand states in the order: \\(s_0 \\rightarrow (s_{1,1} & s_{1,2}) \\rightarrow s_{2,1} \\rightarrow (s_{2,2} & s_{2,3}) \\rightarrow (s_{3,2} \\cup"}, {"title": "4 One Bench At a Time (OBAT)", "content": "We now propose One Bench At a Time (OBAT), a BTS-constrained parallel BFS which behaves similarly to GBFS in that it is constrained to explore one bench at a time. The main idea is to enforce this constraint by carefully controlling the expansion of potential progress states so that if multiple potential progress states are expanded simultaneously, only the successors of one of these potential progress states are allowed to be inserted into Open. For example, if \\(s_1\\) and \\(s_2\\) are expanded simultaneously, and they are both potential progress states, then only the successors of \\(s_1\\) are inserted into Open, because if both \\(succ(s_1)\\) and \\(succ(s_2)\\) are inserted into Open, we may start to explore multiple benches simultaneously.\nOBAT classifies states into two categories, a-states and b-states. A state s is an a-state if it does not have any successor with a lower h-value than h(s). An a-state cannot be a progress state (because if \\(s' \\in succ(s)\\) and \\(h(s) \\leq h(s')\\), then \\(hwm(s) < hwm(s')\\), so if no successor of s has a lower h-value than s, then s cannot satisfy Definition 4). A state s is a b-state if it has a successor with a lower h-value than h(s). A b-state is potentially a progress state. It is possible to determine whether a state is an a-state or b-state immediately after its successors are generated and their h-values are evaluated.\nIf s is an a-state, OBAT proceeds normally as with standard GBFS, inserting its successors in Open. However, if s is a b-state, it is a potential progress state, so instead of inserting the successors of s into Open, it inserts s into Deferred, a priority queue (priority function is h-value). A state s in Deferred is \"on hold\" \u2013 its successors are not inserted in Open until s is removed from Deferred. Thus, if multiple b-states are simultaneously expanded from Open, Deferred prevents their successors from being simultaneously inserted into Open.\nThe sequence in which a state moves among the data structures in OBAT (i.e., its \u201clife cycle\u201d) depends on whether it is an a-state or b-state. a-states are: (al) generated and evaluated, (a2) inserted in Open and Closed, (a3) removed from Open. b-states are: (b1) generated and evaluated, (b2) inserted in Open and Closed, (b3) removed from Open, (b4) inserted in Deferred, (b5) removed from Deferred.\nDefinition 8. A state is committed after it leaves Open or Deferred for the last time. Specifically, a-states are committed after (a3), and b-states are committed after (b5).\nDefinition 9. A state s is completely expanded if it is committed and succ(s) have all been inserted in Open.\nAlgorithm 2 shows the pseudocode for OBAT. \\(top(Q)\\) returns a highest priority (minimal h-value, ties broken according to a tie-breaking policy) state from queue Q. By convention, \\(h(top(Q)) = \\infty\\) if Q is empty. For all threads in parallel, OBAT proceeds as follows."}, {"title": "5 Analysis of State Expansions by OBAT", "content": "We now compute a bound on the number of states expanded by OBAT. The number of states expanded by OBAT is the sum of (1) the number of completely expanded states and (2) the number of states remaining in Deferred when the algorithm terminates.\nTheorem 2. The number of states completely expanded by OBAT is less than or equal to the number of states expanded by GBFS with some tie-breaking policy.\nProof. Let \\(s_1,s_2,s_3...\\) be a serialized ordering of the states which are completely expanded by OBAT, in the order in which they are committed. We show that there exists a tie-breaking policy for sequential GBFS which expands states in this same order. The proof is by induction. For both sequential GBFS and OBAT, the first (completely) expanded state \\(s_1\\) corresponds to the initial state \\(S_{init}\\). Next, assume that for the ordering \\(s_1, ..., s_i\\), there exists a tie-breaking policy for GBFS which expands states in that order. We show that there exists a tie-breaking policy for sequential GBFS which will expand \\(s_{i+1}\\) after \\(s_i\\).\nWhen sequential GBFS removes \\(s_{i+1}\\) from Open, the set of states in Open are are \\(U_{k=1}^i succ(s_k)\\backslash U_{k=1}^i s_k\\) (the set of all generated states minus the set of all expanded states). Now consider when OBAT commits \\(s_{i+1}\\). Let A and B denote the set of a-states and b-states currently being expanded by other threads. Let A' denote the set of successors of all states in A. \\(U_{k=1}^i succ(s_k)\\backslash U_{k=1}^i s_k = (Open \\cup Deferred \\cup B \\cup (A' \\backslash U_{k=1}^i s_k))\\). \\(s_{i+1}\\) has the smallest h-value among all states in Deferred \\(U Open\\).\nA \\cup B cannot contain any states taken from Deferred, because Open and Deferred are locked while a thread removes a state from Deferred and inserts its successors into Open, so this cannot occur simultaneously with the complete expansion of \\(s_{i+1}\\), which requires access to Open and Deferred. Thus, all states in A \\cup B were taken from Open. All states in B will later be inserted in Deferred, so are not in \\(s_1,...s_i\\). All states in A will be included in \\(s_1, ..., s_i\\). By"}, {"title": "6 OBATS: OBAT with SGE", "content": "Like PUHF and its variants, OBAT is a constrained parallel GBFS, and threads can be forced to be idle while they wait until a state which is guaranteed to satisfy the expansion constraint becomes available, resulting in worse performance than unconstrained algorithms such as KPGBFS which never leave threads idle. As with PUHF, this issue can be alleviated using Separate Generation and Evaluation (Shimoda and Fukunaga 2024), an implementation technique which decouples successor generation and evaluation to reduce idle waiting.\nApplying SGE to OBAT is straightforward. Algorithm S.3 in the Supplement shows OBATS, which is OBAT with SGE. As SGE does not change the set of states which are possibly expanded, it can be proven straightforwardly that the upper bound on the number of states expanded by OBAT (Theorem 4) also holds in OBATS."}, {"title": "7 Experimental Evaluation", "content": "We evaluated the performance of OBAT and OBATs with 4, 8, 16 threads. As baselines, we also evaluate KPGBFS, KPGBFSS (KPGBFS with SGE), PUHF3, PUHF3 S (PUHF3 with SGE), and single-thread GBFS.\nExperimental Settings We compared the algorithms using a set of instances based on the Autoscale-21.11 satisficing benchmark set (42 STRIPS domains, 30 instances/domain, 1260 total instances) (Torralba, Seipp, and Sievers 2021), an improved benchmark suite based on the IPC classical planning benchmarks. However, for domains where (1) all methods solved all instances (i.e., the instances were too"}, {"title": "S.2 Explanation of Benchmark Selection", "content": "We compared GBFS, OBAT, OBATS, KPGBFS, KPGBFSs (KPGBFS with SGE), PUHF3, PUHF3s (PUHF3 with SGE) using a set of instances based on the Autoscale-21.11 satisficing benchmark set (42 STRIPS domains, 30 instances/domain, 1260 total instances) (Torralba, Seipp, and Sievers 2021). The Autoscale benchmarks are an improved benchmark suite based on the IPC classical planning benchmarks which were designed to compare the performance of different solvers, as advances in solvers sometimes made performance comparisons among modern solvers difficult using the classic IPC competition benchmark instances.\nHowever, even on the Autoscale-21.11 benchmark set, there were several domains which were too easy \u2013 all methods solved all instances, rendering these instances useless for the purpose of comparing coverage among the methods.\nTherefore, for domains where (1) all methods solved all instances for k = 4, k = 8, and k = 16 threads, and (2) a parameterized instance generator for the domain is available in the Autoscale repository, we replaced the Autoscale-21.11 instances with more difficult instances generated using the same Autoscale instance generator. Specifically, the domains where criteria (1) and (2) above applied were gripper, and miconic."}, {"title": "S.5 The performance impact of SGE on KPGBFS", "content": "Our experimental results show that KPGBFSs (KPGBFS with SGE) had higher overall coverage (472/500/532 for 4/8/16 threads) than KPGBFS (462/488/529 for 4/8/16 threads).\nIn contrast, (Shimoda and Fukunaga 2024), the experimental evaluation of SGE on KPGBFS showed that KPGBFSs had slightly lower total coverage (507/529/565 for 4/8/16 threads) than KPGBFS (510/534/567 for 4/8/16 threads).\nThese results are not contradictory \u2013 the difference is due to the fact that Shimoda and Fukunaga (2024) used the unmodified version of the AutoScale-21.11 benchmark set, while we used a modified version of the AutoScale-21.11 benchmark set. As explained in Section 7 and Supplement Section S.2, we replaced gripper and miconic with harder instances as all 30 of the original instances were solved by all methods and therefore unsuitable (too easy) for a performance evaluation.\nIf we remove the new gripper and miconic instances from the total coverage, and then replace them with the much easier, original, AutoScale-21.11 gripper and miconic instances used by (Shimoda and Fukunaga 2024), the total coverage for KPGBFSS is 509/530/556 for 4/8/16 threads, and total coverage for KPGBFS is 509/532/573 for 4/8/16 threads, which is similar to the results in (Shimoda and Fukunaga 2024)."}]}