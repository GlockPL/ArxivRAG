{"title": "Certifying Pareto-Optimality in Multi-Objective Maximum Satisfiability", "authors": ["Christoph Jabs", "Jeremias Berg", "Bart Bogaerts", "Matti J\u00e4rvisalo"], "abstract": "Due to the wide employment of automated reasoning in the analysis and construction of correct systems, the results reported by automated reasoning engines must be trustworthy. For Boolean satisfiability (SAT) solvers\u2014and more recently SAT-based maximum satisfiability (MaxSAT) solvers\u2014trustworthiness is obtained by integrating proof logging into solvers, making solvers capable of emitting machine-verifiable proofs to certify correctness of the reasoning steps performed. In this work, we enable for the first time proof logging based on the VERIPB proof format for multi-objective MaxSAT (MO-MaxSAT) optimization techniques. Although VERIPB does not offer direct support for multi-objective problems, we detail how preorders in VERIPB can be used to provide certificates for MO-MaxSAT algorithms computing a representative solution for each element in the non-dominated set of the search space under Pareto-optimality, without extending the VERIPB format or the proof checker. By implementing VERIPB proof logging into a state-of-the-art multi-objective MaxSAT solver, we show empirically that proof logging can be made scalable for MO-MaxSAT with reasonable overhead.", "sections": [{"title": "1 Introduction", "content": "Automated reasoning is central in enabling the analysis and construction of correct systems. Practical solvers developed in the realm of automated reasoning, such as Boolean satisfiability (SAT) solvers [9], facilitate the development of more complex automated reasoning systems. One successful example of such generic SAT-based approaches are solvers developed for maximum satisfiability (MaxSAT) [3]\u2014the optimization extension of SAT\u2014enabling solving various NP-hard real-world optimization problems [3]. Further, SAT-based approaches are being generalized and developed for MaxSAT under multiple objectives, i.e., multi-objective MaxSAT [11,13,14,29,35,36,37,49,50], with the aim of extending the success of MaxSAT to more efficiently solving real-world multi-objective optimization problems, from, e.g., staff scheduling [18] through package upgradeability [39] to finding interpretable classifiers [44].\nThe more SAT and MaxSAT solvers are used in real-world settings, the more important it is to be able to trust the results solvers provide. While solutions are generally easy to confirm, solvers should be trustworthy also when they report unsatisfiability or, in the context of optimization, when the solvers claim that a solution is optimal and hence no better solutions exist. In response to these concerns, proof logging and checking techniques for SAT solvers have been developed and widely adopted [28,15,16], among which DRAT [30,31] remains today the de facto standard in the context of SAT solving. However, DRAT and other SAT proof formats work purely on propositional clauses, which makes them unsuitable for proof logging MaxSAT solvers. Instead, the VERIPB format [27,10], which is based on pseudo-Boolean constraints (i.e., 0-1 linear inequalities) and offers direct support for reasoning about objective values in single-objective optimization problems, has enabled proof logging for various optimization contexts [7,10,17,22,23,24,25,26,27,32,33,52], including MaxSAT solving [6,7,33,51,52].\nIn this work, we enable proof logging for various recently-proposed multiobjective MaxSAT solving techniques. To the best of our knowledge, this is the first work enabling proof logging in multi-objective optimization.  Our solution builds on the VERIPB format. It is critical to note that VERIPB does not offer direct support for multiple objective functions, and is thereby seemingly restricted to proof logging single-objective optimization algorithms. However, as we will detail, proof logging for MO-MaxSAT can in fact be enabled without extending the VERIPB format or the proof checker. In particular, in order to provide certificates for MO-MaxSAT algorithms developed for computing a representative solution for each element in the so-called non-dominated set of the search space under Pareto-optimality [21], we make in a specific way use of preorders supported by VERIPB. While preorders were first introduced to VERIPB for certifying symmetry and dominance breaking [10], here we show that, in fact, a single preorder suffices for certifying that an MO-MaxSAT algorithm has computed a representative solution at each element of the non-dominated set. As representative MO-MaxSAT techniques, we detail VERIPB-based proof logging for variants of the P-minimal [43,49], BIOPTSAT [37], and LOWERBOUND [14] approaches, as well as the recently-proposed MO-MaxSAT preprocessing/reformulation technique of core boosting [36] which has been shown to provide considerable runtime improvements to MO-MaxSAT solvers. By adding VERIPB proof logging to the implementations of these approaches in the MO-MaxSAT solver Scuttle [34,35,36], we show empirically that proof logging can be made scalable for MO-MaxSAT, with average proof logging overhead ranging from 14% to 29% depending on the solving approach."}, {"title": "2 Preliminaries", "content": "We begin with necessary preliminaries related to multi-objective MaxSAT and VeriPB proofs."}, {"title": "2.1 Clauses and Pseudo-Boolean Constraints", "content": "A literal l is a {0,1}-valued Boolean variable x or its negation $\\overline{x} = 1 - x$. A propositional clause $C = (l_1 \\lor ... \\lor l_k)$ is a disjunction of literals. A formula in conjunctive normal form (CNF) $F = C_1 \\land... C_m$ is a conjunction of clauses. We often think of clauses as sets of literals and formulas as sets of clauses.\nA (normalized) pseudo-Boolean (PB) constraint is a 0-1 linear inequality $C = \\sum_{i}a_i l_i \\geq b$ where $a_i$ are positive integers and b a non-negative integer. We will assume wlog that all PB constraints are in normal form, meaning that the $l_i$ are over different variables and all coefficients $a_i$ and the bound are positive. A pseudo-Boolean (PB) formula is a conjunction (or set) of PB constraints. We identify the propositional clause $C = (l_1 \\lor ... \\lor l_k)$ with the PB constraint $\\sum_{i}l_i \\geq 1$. This is convenient as the algorithms and solvers that we develop proof logging for expect propositional clauses as input, and as detailed in this work-produce their proofs in pseudo-Boolean format. If C is the PB constraint $\\sum_{i} a_i l_i \\geq b$, we write $\\overline{C}$ for its negation $\\sum_{i} a_i l_i \\geq \\sum_{i} a_i - b + 1$. If p is furthermore a variable, we write $p \\Leftrightarrow C$ for the two constraints expressing that p implies C and vice versa, i.e., $Mp + \\sum_{i} a_i l_i > M$ and $\\overline{b}p + \\sum_{i} a_i l_i \\geq b$ where $M = \\sum_{i} a_i - b + 1$. An objective O is an expression $\\sum_{i} a_i l_i + L$ where the $a_i$ and L are integers.\nA substitution w maps each variable in its domain to a truth value (either 0 or 1) or to another literal. We denote by $C|_{w}$ the constraint obtained from C by replacing each variable x in the domain of w by w(x); the notations $O|_{w}, F|_{w}$, and $v|_{w}$ for a tuple of variables v are defined analogously. An assignment a is a substitution that maps only onto {0,1}. When convenient, we view an assignment as the set of literals it sets to 1. An assignment a is complete for a constraint, formula, or objective if a maps each variable in them to a value, and partial otherwise. The assignment a satisfies a constraint C if the constraint $C|_{a}=\\sum_{i} a_i l_i \\geq b'$ obtained after normalization has b' = 0, and falsifies C if $\\sum_{i} l_i < b'$. In other words, a satisfies C if simplifying C by a leads to a trivial constraint and falsifies $\\overline{C}$ if no extension of a satisfies C. An assignment a is a solution to a formula F if a satisfies all constraints in F. A constraint C is implied by F (denoted by $F \\models C$) if all solutions of F also satisfy C."}, {"title": "2.2 Multi-Objective MaxSAT", "content": "An instance (F, O) of multi-objective MaxSAT (MO-MaxSAT) consists of a CNF formula F and a set $O = (O_1, ..., O_p)$ of p objectives under minimization. This definition for MO-MaxSAT captures standard (single-objective, weighted partial) MaxSAT by setting p = 1; see, e.g., [37]. Given two assignments a and \u03b2"}, {"title": "2.3 Multi-Objective MaxSAT Solving", "content": "We consider the multi-objective MaxSAT problem of finding a representative solution of each element in the non-dominated set. Various algorithms for this problem setting have been proposed recently [13,14,37,49,50]. These algorithms make incremental use of a SAT solver [19,45] while adding constraints to the working formula, ending with an unsatisfiable working formula once all elements in the non-dominated set have been discovered.\nFor many of the existing algorithms for MO-MaxSAT, a crucial building block is what we call a Pareto-dominance cut, or PD cut for short. A PD cut is a (set of) constraint(s) that, given a solution a, is falsified exactly by all solutions that are weakly dominated by a (including a itself). Adding a PD cut to the working formula therefore excludes solutions weakly dominated by a from further consideration. Note that for the single-objective case (p = 1), a PD cut is identical to a solution-improving constraint, admitting only \u201cbetter\u201d solutions. This no longer holds when p > 1 since Pareto-dominance is not a total order: solutions that are incomparable to a will satisfy the PD cut.\nFor objectives $O = (O_1, ..., O_p)$ and solution a, let $w_i$ be fresh variables for each $O_i$ with their semantics defined by\n$\\begin{equation} w_i \\Leftrightarrow O_i \\geq O_i[a.\\tag{1} \\end{equation}$"}, {"title": "2.4 VERIPB", "content": "We now overview a simplified version of the VERIPB proof system, only discussing the rules that are relevant for our current exposition. For instance, while VERIPB supports single-objective optimization, we will only use the decision version of this proof system. We refer the interested reader to earlier work [10,27] for an exposition of the full proof system.\nGiven a PB input formula F, the VERIPB proof system maintains a proof configuration (C, D, O, Z), consisting of two sets of constraints, the core set C and the derived set D, a pseudo-Boolean formula O(\u0e19\u0e35, \u0e1b\u0e35) over two tuples of variables \u0e19\u0e35, \u0e1b\u0e35 that do not appear in C, and a tuple of variables Z. The core set can be thought of as being equal to F and the derived set as consisting of all constraints derived in the proof. The order O defines a preorder \u227a on assignments as follows. If a and \u03b2 are assignments, then a \u227a \u03b2 iff O(Za, Z|\u03b2) is true. The proof system will guarantee that \u227a is indeed a preorder, i.e., a reflexive and transitive relation. The preorder in this configuration was originally introduced in the context of symmetry and dominance breaking [10]. Here we will use the preorder for a different purpose and will in fact not use the dominance rule introduced in [10]. The precise role of the preorder in our proofs for MO-MaxSAT will be detailed in Section 3.\nThe configuration is initialized by setting C = F, D = 0, O = 0 (the empty, and hence trivially true formula) and \u2248 = (), the empty tuple. Afterwards, the configuration is updated using the rules detailed next.\nNew constraints can be added to D by deriving them from previously derived constraints in CUD using the cutting planes proof system [12] consisting of the following rules.\nLiteral Axioms. For any literal l, l\u2265 0 is an axiom and can be derived.\nLinear Combination. Any positive integer linear combination of two previously derived PB constraints can be inferred.\nDivision. Given the normalized PB constraint $\\sum_{i} w_i l_i > A$ and a positive integer c, the constraint $\\sum_{i} \\lfloor w_i/c\\rfloor l_i \\geq \\lfloor A/c \\rfloor$ can be inferred.\nConveniently, VERIPB also allows adding an implied constraint without giving an actual cutting planes derivation, namely, when the constraint is implied by reverse unit propagation (RUP), a generalization of the same notion in SAT [28]. RUP states that if applying integer bounds consistency propagation on CUDU {C} results in a contradiction, then C is implied by CUD and can hence be derived.\nAdditionally, VERIPB also allows for deriving non-implied constraints as long as the constraints are guaranteed to preserve satisfiability. Specifically VERIPB"}, {"title": "3 Proof Logging for Multi-Objective MaxSAT", "content": "As our main contributions, we will now detail how VERIPB can be used for enabling proof logging in the multi-objective setting-despite the fact that VERIPB does not directly support multiple objectives. Our solution is based on a new type of use of the preorder O in VERIPB."}, {"title": "3.1 The General Setup", "content": "Preorders were originally introduced in VERIPB to enable proofs for symmetry breaking [10]. However, the preorder turns out to be applicable for multiobjective proof logging as well. Since all rules in VERIPB are guaranteed to preserve solutions that are minimal with respect to the defined preorder, the preorder generalizes a single objective O: computing a solution optimal wrt O is equivalent to computing a solution that is smallest in the order \u227a defined by the formula that is true iff $O_i[a\u2264 O_i[\u00df$. As a first step towards the multi-objective setting, we introduce a suitable order for encoding Pareto-dominance. In the following definition, if u and v are two tuples of variables of equal length, we write $w_{u \\rightarrow v}$ for the substitution that maps every $u_i$ to $v_i$ and all other variables to themselves.\nDefinition 1. Let $O = (O_1,...,O_p)$ be a tuple of p objectives over variables $X = (x_1,...,x_k)$, and define $Op(\uad50, \uad70)$ over fresh variables u and v as the PB formula $\\mathbb{O}_P(\\vec{u}, \\vec{v}) = {O_1[w_{x \\rightarrow v} \u2264 O_1[w_{x \\rightarrow v},\u2026\u2026\u2026, O_P[w_{x \\rightarrow v} \u2264 O_P[w_{x \\rightarrow v}}}.\nThe following proposition summarizes the properties of $O_P^<$ that are important for our setting.\nProposition 1. Let $O = (O_1,...,O_p)$ be a tuple of objectives and $Op(u, v)$ the PB formula from Definition 1. Then the following hold:\n$O_P^<$ encodes a preorder, i.e., a reflexive ($O_P(\u1ee7, \u1ee7)$ is trivially satisfied) and transitive (if $O_P(u, v)$ and $O_P(v, w)$ also $O_P(\u1ee7, \u1f66)$ holds) relation.\n$O_P(Xa, X [s)$ is satisfied if and only if a $\u2aaf_p$ \u03b2 wrt O, i.e., if a weakly dominates \u03b2.\nWhen the objectives are clear from context, we drop the superscript and use $O_P(\u0e19\u0e35\u0e49, \u0e1b\u0e35)$ for the order that encodes Pareto-dominance over the objectives.\nWith the transfer and order change rules, the order can be changed arbitrarily in VERIPB proofs. In our setting, however, we will use $O_P^<$ unchanged throughout the entire proof. From now on, a VERIPB proof for (F, O) refers to a standard VERIPB proof for F that (i) as the first derivation step loads the order $O_P^<$ over the variables X in the objectives O, and (ii) at no other point in the proof changes the order. Our observations on valid VERIPB proofs assume that the conditions (i) and (ii) are satisfied. The VERIPB proof checker will not verify these two conditions for us; however, these are merely syntactic restrictions that can be verified easily (e.g., by checking that no other lines in the proof starts with load_order).\nThe following result now guarantees the correctness of the proofs produced for the different MO-MaxSAT algorithms.\nTheorem 1. Let P be a VERIPB proof for (F, O) that derives a contradiction. Let S be the set of non-dominated solutions logged in P, i.e., logged solutions that are not dominated by other solutions logged in P. Then S contains a representative solution for each element in the non-dominated set of (F, O)."}, {"title": "3.2 Proof Logging for Pareto Dominance Cuts", "content": "A key step in proof logging the different multi-objective algorithms is the derivation of a constraint called a PD cut given a solution a. In particular, given a solution a of F, we will derive a constraint that states that we are no longer interested in solutions worse than or equally good as a in terms of Paretodominance. In single-objective VERIPB, there is a dedicated rule that allows for deriving a so-called solution-improving constraint. However we will show that PD cuts can be derived only relying on the redundance-based strengthening and solution logging rules.\nWe will make use of some auxiliary variables wi for each objective $O_i$ (recall Equation (1)). Firstly, introducing such (reified) constraints can be done with redundance-based strengthening in a standard way [27]. The introduced constraints guarantee that iff \u03b2 is worse than or equal to a in $O_i$, then variable wi holds in B. Now let $w_a$ be the substitution that maps every variable to their value in a and each wi to 1. We claim that with the redundance-based strengthening rule and this witness we can derive the constraint\n$\\begin{equation} C_a := \\sum_{i=1}^p w_i + \\sum_{lea}\\geq |a|.\\tag{} \\end{equation}$\nIntuitively, this constraint maps each solution weakly dominated by a to a. In doing so it excludes all solutions the PD cut excludes (the solutions weakly dominated by a) except for a itself. To see that this constraint can be derived with redundance-based strengthening, we can verify that all proof obligations are indeed met."}, {"title": "3.3 Proof Logging Multi-Objective MaxSAT Algorithms", "content": "To enforce bounds on the values of the different objectives, multi-objective MaxSAT algorithms make use of CNF encodings of (reified) pseudo-Boolean constraints. For certifying the correctness of MO-MaxSAT algorithms, the cor rectness of these encodings needs to be certified as well. All algorithms covered in this paper make use of the incremental (generalized) totalizer encoding [5,41,46]. The totalizer encoding can be visualized as a tree where each node has a set of output literals that \"count\" how many of the literals at the leaves of its subtree are 1. In earlier work [52] it has been shown how the clauses of the totalizer encoding can be derived in the VERIPB proof system from the constraints de scribing the semantics of the output and internal variables. For certifying the generalized totalizer encoding, the semantics of the output variables are slightly different. Each output variable $o_b$ of a node is defined by the two constraints $o_b \\Leftrightarrow \\sum_{i=1}^{n} a_i l_i \\geq b$ over the n literals at the leaves of the subtree. In contrast to the unweighted case, $a_i$ can be larger than 1 here and values of b that are not subsetsums of {$a_i$ | i = 1,..., n} are omitted. Deriving the clauses of the gen eralized totalizer encoding now follows the cutting planes procedure described in [52].\nMany implementations of MaxSAT algorithms employing the totalizer en coding only derive clauses for enforcing the $o_b = \\sum_{i=1}^{n} a_i l_i \\geq b$ constraint, since these are enough for enforcing upper bounds on the objective values by setting $o_b$ to 0. As observed in [37], for the generalized totalizer it is additionally nec essary to enforce all output variables in the range [b, max{$a_i$ | i = 1,..., n}) to 0 in order to enforce $\\sum_{i=1}^{n} a_i l_i < b$. With this modification, also for the gener alized totalizer encoding, deriving only one \u201cdirection\u201d of clauses is enough from the perspective of the solver. In the proof, however, we will make use of both directions of the definition of these output variables; this means that a solu tion found by the SAT solver is not necessarily a solution to the constraints in the proof. When using a solution found by the SAT solver as a witness for the redundance-based strengthening rule for deriving a PD cut (recall Section 3.2), we therefore need to adjust the assignment to satisfy the stricter semantics of the proof first. This is done during proof generation by traversing through all nodes of the (generalized) totalizer encodings and manually assigning the output variables to values following the strict semantics described above. This adjusted assignment is still guaranteed to satisfy all clauses in the SAT solver.\nNext, we detail three state-of-the-art MO-MaxSAT algorithms and how to generate proofs for them.\nP-minimal [43,49]. Starting from any solution a, the P-minimal algorithm in troduces a PD cut excluding all solutions that are weakly dominated by a. A SAT solver is then queried while temporarily enforcing the next-found solution to dominate a. Both steps are achieved using the generalized totalizer encoding. If no solution dominating the latest one can be found, the previous solution is guaranteed to be Pareto-optimal. In this case P-minimal drops the temporary constraints and starts over. If the working formula is unsatisfiable at this point, P-minimal terminates. An example of a search path of P-minimal in objective space is illustrated on the left-hand side of Fig. 2. The blue circles and red dots represent the solutions found by the SAT solver, with the red dots representing Pareto-optimal solutions. In such an execution, P-minimal introduces a PD cut for each of these solutions.\nFor proof logging P-minimal we certify the generalized totalizer objective encodings and the added PD cuts in the VERIPB proof (as already described). This allows a contradiction to be derived in the proof iff a PD cut was added for each element in the non-dominated set. The temporary constraints that enforce domination are not required in the proof since they are merely heuristics guiding"}, {"title": "3.4 Proof Logging Core Boosting", "content": "Core boosting [36] is a recently-proposed preprocessing/reformulation technique for MO-MaxSAT, consisting of applying the single-objective core-guided opti mization algorithm OLL [2,47] wrt each objective individually, before executing an MO-MaxSAT algorithm on the reformulated objectives obtained from OLL. With this, core boosting shrinks the search space that needs to be considered by the MO-MaxSAT algorithm by deriving lower bounds for each objective. Core boosting also alters the structure of the CNF objective encodings since the total izer structures built by OLL during core boosting can be reused in the objective encodings built by the MO-MaxSAT algorithm.\nWe give a brief overview of the single-objective core-guided OLL MaxSAT algorithm to the extent relevant for understanding how proof logging for core boosting works. Given an objective O, OLL invokes a SAT solver with the as sumptions that none of the literals in O incurs cost. If these assumptions are not satisfiable, the SAT solver returns an implied clause C-referred to as an unsat isfiable core-over the objective literals. OLL now introduces counting variables $\\forall_i$ = $\\sum_{l \\in C}l \\geq i$ for i = 2,...,|C| (encoded by the totalizer encoding) and reformulates the objective by adding c c . ($\\sum_{l \\in C}l$ + $\\sum\\forall{i}$+ 1) to it, where $c_c$ is the minimum objective coefficient of any literals in C. Iteratively applying"}, {"title": "4 Experiments", "content": "We extended all algorithms implemented in the Scuttle [34,35,36] MO-MaxSAT solver-namely, P-minimal [43,49], LOWERBOUND [14], and (the SAT-UNSAT variant of) BIOPTSAT [37], each with and without core boosting\u2014with the justdescribed VERIPB proof logging. We used CaDiCaL 2.0.0 [8] as the SAT solver within Scuttle and the VERIPB 2.2.2 proof checker [1] for checking the produced proofs. The proof logging Scuttle implementation is available in open source [34,38]. We evaluate the implementation on the same set of benchmark instances used in the original work proposing core boosting [36]. This set of benchmarks consists of 300 instances from 6 domains with the number of ob jectives ranging from 2 to 5. The experiments were run on 2.50-GHz Intel Xeon Gold 6248 machines with 381-GB RAM in RHEL under a 32-GB memory limit and 1 hour time limit for Scuttle."}, {"title": "5 Conclusions", "content": "We realized for the first time proof logging for multi-objective MaxSAT solving. Circumventing the fact that VERIPB does not offer direct support for multiple objectives, we detailed how preorders in VERIPB can be used to provide cer tificates for MO-MaxSAT algorithms that compute a representative solution for each element of the non-dominated set (with respect to the Pareto order). We achieved this without changes to the VERIPB format or the proof checker. In tegrating VERIPB proof logging into a state-of-the-art multi-objective MaxSAT solver, we empirically showed that proof logging can be made scalable for MO MaxSAT. While we in this work detailed how VERIPB can be employed for proof logging SAT-based multi-objective approaches, the same concepts are ap plicable to enabling proof logging for similar algorithmic ideas instantiated for other contexts, e.g., in the context of pseudo-Boolean optimization. Developing proof logging methods that capture the computation of all Pareto-optimal solu"}]}