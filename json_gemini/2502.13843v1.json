{"title": "Enhancing Cross-Domain Recommendations with Memory-Optimized LLM-Based User Agents", "authors": ["Jiahao Liu", "Shengkang Gu", "Dongsheng Li", "Guangping Zhang", "Mingzhe Han", "Hansu Gu", "Peng Zhang", "Tun Lu", "Li Shang", "Ning Gu"], "abstract": "Large Language Model (LLM)-based user agents have emerged as a powerful tool for improving recommender systems by simulating user interactions. However, existing methods struggle with cross-domain scenarios due to inefficient memory structures, leading to irrelevant information retention and failure to account for social influence factors such as popularity. To address these limitations, we introduce AgentCF++, a novel framework featuring a dual-layer memory architecture and a two-step fusion mechanism to filter domain-specific preferences effectively. Additionally, we propose interest groups with shared memory, allowing the model to capture the impact of popularity trends on users with similar interests. Through extensive experiments on multiple cross-domain datasets, AgentCF++ demonstrates superior performance over baseline models, highlighting its effectiveness in refining user behavior simulation for recommender systems. Our code is available at https://anonymous.4open.science/r/AgentCF-plus.", "sections": [{"title": "1 Introduction", "content": "Recommender systems play a pivotal role in the dissemination of information today [19-24, 31, 44]. However, their development is hindered by challenges in effectively understanding user behavior [32]. One promising approach to overcoming these challenges is the reliable simulation of user interaction behavior in a controlled, privacy-preserving manner, thereby improving recommender systems by offering insights into user preferences and system performance [48]. Recent advancements in large language models (LLMs), renowned for their capabilities in understanding, reasoning, and generating content [55], have inspired significant efforts to develop LLM-based agents [39]. These agents often incorporate memory modules [53], utilize external tools [45], and engage in advanced reasoning [14], enabling them to exhibit emergent human-like behaviors [28]. In this context, researchers have begun investigating the potential of LLM-based agents to simulate user interaction behavior in the field of recommender systems [3, 36, 40, 47, 50, 54].\nAccurately representing user preferences is crucial for a user agent to realistically simulate user behavior. While various terms are used across studies, this paper uniformly refers to these preferences as being stored in memory. In real-world scenarios, users' interactions with recommender systems often exhibit cross-domain characteristics [46]. Additionally, individual behaviors are frequently influenced by those of others [12]. For instance, popularity-related factors suggest that even in the absence of explicit social networks, such influences can be inferred from interaction graphs and propagated through interaction paths [52]. However, the current memory design causes the user agent to exhibit two significant limitations: First, user preferences from multiple domains are mixed into a single memory. However, only a portion of the preferences is relevant to decision-making in the target domain, leading the user agent to process a considerable amount of irrelevant information. Second, memory construction relies exclusively on individual user interactions, neglecting how external factors, such as popularity influences, shape user preferences.\nIn this paper, we present AgentCF++, an enhanced version of AgentCF [50]. Our approach introduces a dual-layer memory architecture comprising domain-separated memory and domain-fused memory, designed to prioritize target-domain-relevant information in decision-making for cross-domain scenarios. To refine this architecture, we propose an attention-inspired two-step fusion mechanism. This mechanism first identifies valuable cross-domain knowledge pertinent to the target domain and then integrates these critical preferences. Furthermore, we introduce the concept of interest groups and propose a group-shared memory mechanism to facilitate the transfer of popularity effects within the same interest group. By utilizing interest groups, we ensure that a user's behavior impacts only those with similar interests, effectively preventing the spread of popularity effects to unrelated users. Our experimental results on five cross-domain datasets demonstrate the effectiveness of the proposed modules. Additionally, several case studies underscore the enhanced capabilities of AgentCF++."}, {"title": "2 Preliminaries", "content": null}, {"title": "2.1 AgentCF", "content": "Unlike previous studies [3, 36, 40, 47, 54] that consider only users as agents, AgentCF [50] treats both users and items as agents. Each user agent is equipped with a memory to store individual preferences, while each item agent maintains a memory to track the interest levels of users with varying preferences towards it. At each step, leveraging LLMs for decision-making and reflection, these agents autonomously interact, compare their actions with real-world data, and collaboratively adjust their memories to better align with observed behaviors. As illustrated in Figure 1(a), user and item memories gradually propagate over time through interactions, embodying the principles of collaborative filtering."}, {"title": "2.2 Limitations of AgentCF", "content": "AgentCF employs a single memory for each user agent and item agent. In cross-domain scenarios, the propagation process integrates information from multiple domains into the memory of each user and item. On one hand, the mixing of cross-domain preferences in the user agent may introduce noise, thereby complicating decision-making on target domain. On the other hand, such intermingling may cause the item agent to lose its original domain characteristics. We illustrate this with a case study in Section 4.3.\nAdditionally, while AgentCF employs collaborative filtering to capture the influence of others' interactions, memory updates for user and item agents occur only during direct interactions, limiting its capacity to comprehensively model how popularity factors shape user behavior. To illustrate this limitation, consider the following example. Figure 1(b) visualizes user-item interaction dynamics using a timestamped bipartite graph. At t\u2081, Alice, Bob, and Carl purchase outdoor activity items; at t\u2082, Bob and Carl buy rain gear; at t\u2083, Carl purchases camping equipment. Under the AgentCF framework, Alice, who ceases interactions after t\u2081, is still assumed to engage in outdoor activities, despite worsening weather conditions at t\u2082. Similarly, Bob shows no interest at t\u2083, failing to account for the improved weather conditions. This indicates that, within the AgentCF framework, users' memories remain static in the absence of additional interactions. In practice, however, even without further direct participation, Alice might infer the weather changes at t\u2082 and t\u2083 by observing Bob's and Carl's actions. This underscores the need for user agents to update their memories not only through their own interactions with item agents but also in response to interactions by other user agents. In essence, a user's memory should evolve dynamically, even without direct participation-a critical capability currently missing in the AgentCF framework.\nClarification. As shown in Figure 1(c), user behavior (Y) is influenced by both user preferences (X) and popularity factors (P). Unlike debiasing approaches, which seek to model user preferences by removing the effects of popularity factors [4, 8], user behavior simulation aims to model user behavior. Therefore, in user behavior simulation, popularity factors are not a nuisance to be mitigated but a critical factor to be explicitly modeled."}, {"title": "3 AgentCF++", "content": "Similar to AgentCF, AgentCF++ simulates interactions between user agents and item agents from multiple domains and performs reflection during this process to update the memories of both sides, thereby aligning with user behavior."}, {"title": "3.1 Memory Architecture", "content": "AgentCF++ employs a similar memory architecture to AgentCF for the item agent, using a single memory to record the interest levels of users with various preferences towards it. Initially, the item's memory is seeded with its side information. However, AgentCF++ has meticulously designed the memory architecture for the user agent to enhance its functionality.\nFirstly, each user agent in AgentCF++ is equipped with a dual-layer memory architecture. Specifically, each user agent maintains two types of memory for each domain: (1) Domain-separated memory retains the user's preferences specific to a single domain. (2) Domain-fused memory also stores preferences within a particular domain but integrates domain-separated memories from other domains. Initially, both memories are empty.\nAdditionally, each user agent is assigned to several interest groups through the following process: (1) Building user-tag relationships: The user agent's domain-fused memory is processed by an LLM to derive a set of interest tags representing the user's preferences. (2) Merging synonymous tags: The LLM transforms all tags into embedding vectors, which are then grouped into clusters based on semantic similarity using a K-means clustering algorithm. Each cluster corresponds to a specific area of interest, encompassing tags with high semantic similarity. (3) Refining interest groups: The LLM synthesizes the tags in each cluster to generate a consolidated interest group name. Ultimately, only the largest few interest groups are retained, collectively covering the majority of the user's interests. AgentCF++ periodically re-segments the interest groups to ensure they reflect any updates in user preferences.\nEach interest group is equipped with a group-shared memory, enabling all user agents within the group to collaboratively access shared information. The shared memory is of fixed size, designed to store the recent interaction history of its associated users."}, {"title": "3.2 Inference Phase", "content": "We assume that the current interaction is (u, i, d), where u represents a user agent, i represents an item agent, and d denotes the domain of i. First, a negative sample j is selected from the domain d. Then, u receives the memories of i and j and is tasked with identifying the positive sample while explaining its reasoning. To mitigate potential position bias, in which LLMs tend to favor earlier options, j is deliberately placed before i. Note that u's decisions depend simultaneously on both domain-separated memory and domain-fused memory within domain d, as well as on the group-shared memories it can access.\nDiscussion. The dual-layer memory architecture includes a domain-separated memory and a domain-fused memory corresponding to each domain. With this memory enhancement, only information relevant to the target domain is utilized during decision-making, effectively reducing noise in cross-domain scenarios. On the other hand, the sharing mechanism allows user behavior to influence related users without directly updating their individual memories, incorporating the influence of popularity factors into preferences modeling. For instance, in the scenario depicted in Figure 1(b), Bob and Carl insert the behavior of purchasing rain gear into the memory shared with Alice at t\u2082. At t\u2083, Carl adds the behavior of purchasing camping gear into the memory shared with both Alice and Carl. This results in Alice's willingness to go outdoors decreasing at t\u2082 and increasing at time t\u2083, reflecting real-world patterns where user behavior is influenced by trends and popularity factors. Note that we segment users based on their interests rather than the similarity of their interaction history, to more precisely identify populations influenced by popularity factors."}, {"title": "3.3 Update Phase", "content": "The memories are updated using a reflection mechanism [25, 27, 35]. Specifically: (1) According to the results of the inference phase, u updates its domain-separated memory in domain d using the memories of i and j. This step enables u to learn what it like and dislike from the latest interaction. (2) We propose a two-step fusion mechanism to effectively integrate information from multiple domains. Firstly, u extracts preferences related to the target domain d from domain-separated memories of other domains. Then, u updates its domain-fused memory in domain d based on the extracted preferences. (3) i and j update their item memories using u's domain-fused memory in domain d. In this step, i learns which user preferences it appeals to, while j learns which user preferences it does not appeal to.\nDiscussion. Figure 1(d) illustrates the process of update phase. The two-step fusion mechanism implicitly incorporates the idea of the attention mechanism, ensuring that the domain-fused memory effectively integrates preferences from other domains while retaining only preferences relevant to the corresponding domain. Specifically, in the first step, only preferences related to the target domain are extracted, akin to the computation of attention scores. In the second step, the extracted preferences from different domains are integrated, akin to the weighted aggregation process in the attention mechanism. Additionally, with the aid of the reflection mechanism, the cyclic updates of item memory, domain-separated memory, and domain-fused memory enable all memories to achieve self-improvement."}, {"title": "4 Experiments", "content": null}, {"title": "4.1 Settings", "content": null}, {"title": "4.1.1 Datasets.", "content": "We experimented with the Amazon review dataset [10]. As summarized in Table 1, we constructed cross-domain datasets Cross-1-Cross-5 by combining datasets from the Books, CDs, Movies, and Games domains. Then, we retained interaction records with ratings \u2265 4 and timestamps spanning six months, from October 2021 to March 2022. We further filtered the data to include only records of users who interacted across multiple domains and had > 10 total interactions. Following AgentCF, we randomly sampled 100 users to minimize API call expenses. Next, we sorted these interaction records chronologically and split them into training, validation, and test sets with an 8:1:1 ratio."}, {"title": "4.1.2 Evaluation.", "content": "For each ground truth item, we randomly sample 9 items from the same domain that the user has not interacted with to construct the candidate set. The user agent is then tasked with ranking these items, and the ranking performance is measured using NDCG and MRR. We report the average results over 5 runs."}, {"title": "4.1.3 Baselines.", "content": "We used two traditional recommendation models, BPR-MF [30] and SASRec [16], as well as four training-free methods, Pop, LLMSeqSim [9], LLMRank [11], and AgentCF [50], as baseline methods for comparison. Specifically, Pop ranks candidates based on item popularity, LLMSeqSim evaluates candidates by measuring their similarity to the user's interaction history, and LLMRank employs an LLM as a zero-shot ranker to prioritize candidate items.\nWe compared solely with AgentCF, omitting other LLM-based user agent methods. Our goal is to demonstrate that the proposed module enhances AgentCF. Performance differences with other methods may stem from differing agent construction paradigms, making it challenging to attribute improvements directly to the proposed module. On the other hand, they all construct memory directly through the user's interaction history, which can, to some extent, be considered equivalent to LLMRank.\nWe also designed three ablation variants for AgentCF++: (1) AgentCF + dual: Extends AgentCF with only the dual-layer memory architecture. (2) AgentCF + shared: Extends AgentCF with only interest groups and group-shared memory. (3) AgentCF++ w/o group: Users are grouped based on their full interaction history rather than their interests. The other components, including treating users as agents, treating items as agents, the automatic interaction process, and the reflection mechanism, have already been validated as effective by AgentCF. Therefore, these components were not included in the ablation study."}, {"title": "4.2 Overall Performance", "content": "As shown in Table 2, on cross-domain datasets, AgentCF achieves comparable performance to training-free methods such as LLMRank but fails to surpass traditional recommendation models like SASRec. This suggests that traditional models inherently capture popularity factors and cross-domain collaborative information through their training mechanisms, giving them a clear advantage over LLM-based user agents in predicting user behavior. Encouragingly, the proposed AgentCF++ consistently outperforms both its ablation variants and all baselines. Moreover, the ablation variants consistently outperform AgentCF, further validating the effectiveness of the proposed modules. Notably, AgentCF++ w/o group performs not only worse than AgentCF++ but also worse than AgentCF + dual, further underscoring the importance of dividing users into interest groups. This indicates that assigning users to groups based on their full interaction history is too coarse, allowing the popularity factor to influence unrelated users, introducing noise, and ultimately reducing accuracy."}, {"title": "4.3 Case Studies", "content": null}, {"title": "4.3.1 Memory.", "content": "Figure 2 (a) and (c) illustrate the memory of AgentCF++ and AgentCF in the Game & Book domains, respectively. It is evident that the user agent in AgentCF intermixes preferences from different domains, with its memory containing both game-related preferences (e.g., role-playing) and book-related preferences (e.g., economics). As memory propagates, this mixing effect further causes its item agent to gradually lose domain-specific information.\nIn contrast, AgentCF++ separates preferences by domain and fuse information via a two-step fusion mechanism. First, as shown in Figure 2 (b), this mechanism extracts target-domain preferences from other domains based on cross-domain mappings (e.g., role-playing and open-world in the game domain correspond to fantasy and adventure in the book domain). Then, the mechanism fuses the extracted preferences to ensure broad coverage across domains while maintaining domain specificity. This mechanism ensures that the item agent retains information relevant to its domain."}, {"title": "4.3.2 Interest Group.", "content": "Figure 2 (d) illustrates two interest groups along with their agenda items, each named to represent its focus."}, {"title": "5 Related Work", "content": "LLM-based agents in recommender systems can be broadly divided into two categories. The first category focuses on recommendation agents that leverage LLMs to generate or improve recommendations [13, 34, 42, 43, 49, 51, 56]. The second category explores user agents that leverage LLMs to simulate user behavior. While some studies focus on simulating user dialogues in conversational recommendation [6, 17, 41, 57, 58], our emphasis is on simulating user interaction behavior. RecAgent [40] and Agent4Rec [47] employ LLM-based agents, incorporating user profiles, memory, and action modules, to simulate interactions with recommender systems. RAH [36] places LLM-based multi-agents between users and recommender systems, serving both as recommendation agents and as proxies for user interactions. FLOW [3] facilitates collaboration between recommendation agents and user agents by establishing a feedback loop. Zhang et al. [54] integrate explicit user preferences, LLM-driven sentiment analysis, a human engagement model, and a statistical framework to robustly simulate user interactions."}, {"title": "6 Conclusions", "content": "We propose AgentCF++, which consists of: (1) a dual-layer memory architecture and a two-step fusion mechanism that allow the user agent to avoid introducing irrelevant in cross-domain scenarios; (2) the concept of interest groups and a shared memory mechanism that captures the influence of popularity among users with similar interests. Comprehensive experiments demonstrate the effectiveness of AgentCF++. In the future, we aim to adapt these designs to other LLM-based user agent frameworks."}]}