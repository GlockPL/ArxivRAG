{"title": "CFAULTS: Model-Based Diagnosis for Fault Localization in C with Multiple Test Cases", "authors": ["Pedro Orvalho", "Mikol\u00e1\u0161 Janota", "Vasco Manquinho"], "abstract": "Debugging is one of the most time-consuming and expensive tasks in software development. Several formula-based fault localization (FBFL) methods have been proposed, but they fail to guarantee a set of diagnoses across all failing tests or may produce redundant diagnoses that are not subset-minimal, particularly for programs with multiple faults. This paper introduces a novel fault localization approach for C programs with multiple faults. CFAULTS leverages Model-Based Diagnosis (MBD) with multiple observations and aggregates all failing test cases into a unified MaxSAT formula. Consequently, our method guarantees consistency across observations and simplifies the fault localization procedure. Experimental results on two benchmark sets of C programs, TCAS and C-PACK-IPAS, show that CFAULTS is faster than other FBFL approaches like BUGASSIST and SNIPER. Moreover, CFAULTS only generates subset-minimal diagnoses of faulty statements, whereas the other approaches tend to enumerate redundant diagnoses.", "sections": [{"title": "1 Introduction", "content": "Localizing system faults has always been one of the most time-consuming and expensive tasks. Given a buggy program, fault localization (FL) involves identifying locations in the program that could cause a faulty behaviour (bug).\nGiven a faulty program and a test suite with failing test cases, current formula-based fault localization (FBFL) methods encode the localization problem into several optimization problems to identify a minimal set of faulty statements (diagnoses) within a program. Typically, these methods find a minimal diagnosis considering each failing test case individually rather than simultaneously with all failing test cases. Moreover, these FBFL methods enumerate all Minimal Correction Subsets (MCSes) [22] to cover all diagnoses.\nFor instance, BUGASSIST [17,18], a prominent FBFL tool, implements a ranking mechanism for bug locations. For each failing test, BUGASSIST enumerates all diagnoses of a Maximum Satisfiability (MaxSAT) formula corresponding to bug locations. Subsequently, BUGASSIST ranks diagnoses based on their frequency of appearance in each failing test. Other FBFL tools, like SNIPER [21], also enumerate all diagnoses for each failing test. However, the set of SNIPER's diagnoses is obtained by taking the Cartesian product of the diagnoses gathered using each failing test. As a result, while FBFL methods can determine minimal diagnoses per failing test, BUGASSIST cannot guarantee a minimal diagnosis considering all failing tests, and SNIPER may enumerate a significant number of redundant diagnoses that are not minimal [16]. These limitations may pose challenges for programs with multiple faulty statements, as shown in Example 1."}, {"title": "2 Preliminaries", "content": "This section provides definitions and notations that are used throughout the paper. We start by presenting basic definitions of propositional logic and programs and then address standard model-based diagnosis (MBD) definitions.\nThe Boolean Satisfiability (SAT) problem is the decision problem for propositional logic [3]. A propositional formula in Conjunctive Normal Form (CNF) is a conjunction of clauses where each clause is a disjunction of literals. A literal is a propositional variable xi or its negation \u00acxi. Given a CNF formula \u03c6, the SAT problem corresponds to deciding if there is an assignment to the variables in \u03c6 such that \u03c6 is satisfied or prove that no such assignment exists. When applicable, set notation will be used for formulas and clauses. A formula can be represented as a set of clauses (meaning its conjunction) and a clause as a set of literals (meaning its disjunction).\nThe Maximum Satisfiability (MaxSAT) problem is an optimization version of the SAT problem. Given a CNF formula \u03c6, the goal is to find an assignment that maximizes the number of satisfied clauses in \u03c6. In partial MaxSAT, \u03c6 is split into hard clauses (\u03c6h) and soft clauses (\u03c6s). Given a formula \u03a6 = (\u03a6h, \u03a6s), the goal is to find an assignment that satisfies all hard clauses in \u03c6h while minimizing the number of unsatisfied soft clauses in \u03c6s. Moreover, in the weighted version of the partial MaxSAT problem, each soft clause is assigned a weight, and the goal is to find an assignment that satisfies all hard clauses and minimizes the sum of the weights of the unsatisfied soft clauses. Let \u03a6 = (\u03a6h, \u03a6s) be a partial MaxSAT formula. A Minimal Correction Subset (MCS) \u00b5 of \u03c6 is a subset \u00b5 \u2286 \u03c6s where \u03c6h \u222a (\u03c6s \\ \u00b5) is satisfiable and, for all c\u2208 \u00b5, \u03c6h \u222a (\u03c6s \\ \u00b5) \u222a {c} is unsatisfiable. A dual concept of MCSes are Minimal Unsatisfiable Subsets (MUSes) [22,16].\nPrograms. A program is considered sequential, comprising standard statements such as assignments, conditionals, loops, and function calls, each adhering to their conventional semantics in C. A program is deemed to contain a bug when an assertion violation occurs during its execution with input I. Conversely, if no assertion violation occurs, the program is considered correct for input I. In cases where a bug is detected for input I, it is possible to define an error trace, representing the sequence of statements executed by program P on input I.\nA Trace Formula (TF) is a propositional formula that is SAT iff there exists an execution of the program that terminates with a violation of an assert statement while satisfying all assume statements. For further information on TFs, interested readers are referred to [5,8].\nModel-Based Diagnosis (MBD). The following definitions are commonly used in the MBD theory [34,16,24]. A system description P is composed of a set of components C = {C1, ..., Cn}. Each component in C can be declared healthy or unhealthy. For each component c\u2208 C, h(c) = 0 if c is unhealthy, otherwise, h(c) = 1. As in prior works [16,25], P is described by a CNF formula, where Fc denotes the encoding of component c:"}, {"title": "3 Model-Based Diagnosis with Multiple Test Cases", "content": "This paper encodes the fault localization problem as a Model-Based Diagnosis with multiple observations using a single optimization problem. We simultaneously integrate all failing test cases (observations) in a single MaxSAT formula. This approach allows us to generate only minimal diagnoses capable of identifying all faulty components within the system, in our case, a C program.\nGiven m observations, O = {o1,...,om}, a distinct replica of the system, denoted as Pi, is required for each observation oi. The hard clauses, \u03c6h, in our MaxSAT formulation correspond to each observation's encoding (oi) and m system replicas, one for each observation, Pi. Hence, \u03a6h = \u2227oi\u2208O (Pi\u2227oi). Additionally, we aim to maximize the set of healthy components. Therefore, the soft clauses are formulated as: \u03c6s = \u2227c\u2208C h(c). Thus, given the MaxSAT solution of (\u03a6h, \u03a6s), its complement, i.e., the set of unhealthy components (h(c) = 0), corresponds to a subset-minimal aggregated diagnosis. This diagnosis is a subset-minimal of components that, when declared unhealthy (deactivated), make the system consistent with all observations, as follows:\n$\\bigwedge_{o_i \\in O} (P_i \\land o_i) \\land \\bigwedge_{c \\in C} ( h(c) ) \\land \\bigwedge_{c \\in C} ( \\neg h(c) ) \\bot$\nWe assume that the system remains unchanged given different observations, where the components are replicated for each observation, but the healthy variables are shared. This is necessary because we analyze all observations jointly, which can affect the component's behaviour. In our work, the observations consist of a test suite containing failing test cases.\nThe HSD [16] algorithm was proposed to localize single faults in circuits given multiple observations. The HSD algorithm is based on hitting set dualization (HSD). For each observation oi, this algorithm computes minimal unsatisfiable subsets (MUSes) of the MaxSAT formula encoded by (4). Next, the HSD algorithm computes a minimum hitting set H on the MUSes, and checks if H makes the system consistent with each observation individually. Hence, to compute all subset-minimal aggregated diagnoses of a faulty system P, the algorithm performs at least m oracle calls for each minimum hitting set computed, where m is the number of observations. Each oracle call uses a different system replica (4).\nOur approach encodes the problem into a single MaxSAT formula, while HSD [16] divides the problem into m MaxSAT formulas, one for each observation. Additionally, for each minimal hitting set computed in HSD, m oracle calls are needed to check if a diagnosis is consistent with all observations. However, in our case, we just need to perform a single MaxSAT call that returns a minimal diagnosis, which is, by definition, consistent with all observations since all observations are encoded into the formula. Furthermore, the HSD algorithm was solely evaluated using single faults in circuits given multiple observations, and it was not implemented to work with programs. A potential drawback is that our MaxSAT formula grows with the number of observations. This could result in a large formula and affect the performance of the MaxSAT solver. However, this scenario was not observed in our experimental results (see Section 5)."}, {"title": "4 CFAULTS: MBD with Multiple Observations for C", "content": "CFAULTS is a new model-based diagnosis (MBD) tool for fault localization in C programs with multiple test cases. Unlike previous works, CFAULTS uses the approach proposed in Section 3, and C programs are relaxed at the code level, enabling users to leverage other bounded model checkers effectively. Figure 1 provides an overview of CFAULTS consisting of six main steps: program unrolling, program instrumentalization, bounded model checking (CBMC), encoding to MaxSAT, an Oracle (MaxSAT solver), and a refinement step. Hence, CFAULTS formulates the MBD problem with multiple test cases as the 3-tuple (P,C,O), where the observations O consist of failing test cases (inputs and assertions), the components C represent the set of program statements, and the system description P is a trace formula of the unrolled and instrumentalized program. The program is instrumented at the code level with relaxation variables corresponding to our healthy variables.\nProgram unrolling. CFAULTS starts the unrolling process by expanding the faulty program using the set of failed tests from the test suite. In this context, an unrolled program signifies the original program expanded m times (m program scopes), where m denotes the number of failed test cases. An unrolled program encodes the execution of all failing tests within the program, along with their corresponding inputs and specifications (assertions).\nThe unrolling process encompasses three primary steps. Initially, CFAULTS generates fresh variables and functions for each of the m program scopes, ensuring each scope possesses unique variables and functions. Subsequently, CFAULTS establishes variables representing the inputs and outputs for each program scope corresponding to the failing tests. Input operations, such as scanf, undergo translation into read accesses to arrays corresponding to the inputs, while output operations, such as printf, are replaced by write operations into arrays representing the program's output. Every exit point of the program (e.g., a return statement in the main function) is replaced with a goto statement directing the program flow to the next failing test's scope. Lastly, at the end of the unrolled program, CFAULTS embeds an assertion capturing all the specifications of the failing tests. Consequently, the unrolled program encapsulates the execution of all failing tests within a single program.\nProgram Intrumentalization. After integrating all possible executions and assertions from failing tests during the unrolling step, CFAULTS proceeds to instrumentalize the unrolled C program by introducing relaxation variables for each program component (statement/instruction). Each relaxation variable activates (or deactivates) the program component being relaxed when assigned to true (or false) respectively. CFAULTS ensures that there are no conflicts between the names of the relaxation variables and the names of the program's original variables. For this step, CFAULTS needs to receive a maximum number of iterations that the program should be unwound.\nIn more detail, the rule for relaxing a general program statement is to envelop the statement with an if-statement, whose condition is a relaxation variable. For example, consider lines 5 and 6 in the program on Listings 1.3. These lines are relaxed by CFAULTS using relaxation variables _rv1 and _rv2 respectively, appearing as lines 11 and 12 on Listings 1.4.\nFurthermore, when relaxing if-statements, the statements inside the then and else blocks adhere to the previously explained relaxation rule. However, the conditions of if-statements are relaxed using a ternary operator, as shown in line 14 of Listings 1.4. Note that if the relaxation variable is assigned true, then the original if condition is executed. Otherwise, a different relaxation variable (e.g., _ev4 in Listings 1.4) determines whether the program execution enters the then-block or the else-block (if one exists). These relaxation variables (else's relaxation variables) are local to each failing test scope and enable different tests to determine whether to enter the then or else-block.\nWhen handling expression lists, CFAULTS adopts a comparable strategy to that of generic program statements, enclosing each expression within a ternary operator instead of an if-statement. If the program component is deactivated, the expression is replaced by 1. For example, the initialization of variable i in line 11 of Listings 1.3 is relaxed into the ternary operation in line 17 of Listings 1.4.\nLastly, all relaxation variables inside a loop are Boolean vectors to relax statements within a loop. Each entry of these vectors relaxes the loop's statements for a given iteration. The maximum number of iterations of the loops is defined by the CFAULTS user. CFAULTS follows a similar approach for inner loops, creating arrays of arrays. Thus, for simple program statements within a loop, CFAULTS encapsulates them with if-statements, with the relaxation variables indexed to the iteration number. Line 20 of Listings 1.4 illustrates a relaxed statement inside a loop. The loop's condition is relaxed by implication of the relaxation variable, as demonstrated in line 18 of Listings 1.4. Furthermore, each loop has its own offsets to index relaxation variables. These offsets are initialized just before the loop and incremented at the end of each iteration (e.g., line 19 in Listing 1.4).\nWhen handling auxiliary functions, CFAULTS declares the relaxation variables needed in the main scope of the program and passes these variables as parameters. Hence, CFAULTS ensures that the same variables are used throughout the auxiliary functions' calls.\nListing 1.5 depicts the program resulting from the instrumentalization process of Listing 1.2 performed by CFAULTS. The same program components (statements/instructions) across different failing test scopes are assigned the same relaxation variable declared in the main scope. Consequently, if a relaxation variable is set to 0, the corresponding program component is deactivated across all test executions. Additionally, the relaxation variables are left uninitialized, allowing CFAULTS to determine the minimal number of faulty components requiring deactivation. Note that relaxation variables are not declared as global variables but as local variables within the main scope. This is to prevent the C compiler from automatically initializing all these variables to 0.\nCBMC. After unrolling and instrumentalizing the C program, CFAULTS invokes CBMC, a bounded model checker for C [5]. CBMC initially transforms the unrolled and relaxed program into Static Single Assignment (SSA) form, an intermediate representation ensuring that variables are assigned values only once and are defined before use [9]. SSA achieves this by converting existing variables into multiple versions, each uniquely representing an assignment. Next, CBMC translates the SSA representation into a CNF formula, which represents the trace formula of the program. During the CNF formula generation, CBMC negates the program's assertion (\u00ac(\u00acA1 V\u00b7\u00b7\u00b7\u2228 \u00acAm)) to compute a counter-example. Moreover, the CNF formula, \u03c6, encodes each failing test's input (Ii), assertion (Ai), and all execution paths of the unrolled and relaxed incorrect program encoded by the trace formula (P), i.e., \u03c6 = (I1 ^ ... > Im) ^P^ (A1\u2227\u00b7\u00b7\u00b7\u2227Am). Thus, if \u03c6 is SAT, an assignment exists that activates or deactivates each relaxation variable and makes all failing test assertions true. Hence, each satisfiable assignment is a diagnosis of the C program, considering all failing tests.\nMaxSAT Encoder. Let \u03c6 denote the CNF formula generated by CBMC in the previous step. Next, CFAULTS generates a weighted partial MaxSAT formula (H, S) to maximize the satisfaction of relaxation variables in the program, aiming to minimize the necessary code alterations. The set of hard clauses is defined by CBMC's CNF formula (i.e., H = \u03c6), while the soft clauses consist of unit clauses representing relaxation variables used to instrument the C program, expressed as S = \u2227c\u2208C (rvc). Additionally, we assign a hierarchical weight to each relaxation variable based on the height of its sub-AST (Abstract Syntax Tree). For instance, in the case of an if-statement without an else-block, the relaxation variable for its condition will be assigned a weight equal to the sum of the weights of the relaxation variables within the then-block. Furthermore, to prioritize the identification of faulty statements within the program's logic over evaluating issues in the input/output, these statements (such as scanf and printf) are assigned a significantly higher cost compared to other program statements. Moreover, due to the use of hierarchical weights in the relaxation variables, CFAULTS enumerates all MaxSAT solutions to identify all subset-minimal diagnoses since there can be more than one MaxSAT solution (with the same cost) that differ in the number of relaxed program statements.\nOracle. CFAULTS invokes a MaxSAT solver to determine the program's minimal set of faulty statements, aligning with the principles of Model-Based Diagnosis (MBD) theory. By consolidating all failing tests into a unified, unrolled, and instrumentalized program, the MaxSAT solution identifies the minimum subset of statements requiring removal to fulfil the assertions of all failing tests.\nRefinement. The standard Model-Based Diagnosis (MBD) theory focuses on faulty components (program statements) whose removal can rectify the system (program's assertions). However, addressing program faults in software may necessitate introducing, relocating, or replacing statements. Hence, CFAULTS incorporates a refinement step that introduces nondeterminism into the program, enabling the Oracle to simulate actions such as introducing, reallocating or replacing existing program statements. During the first iteration of CFAULTS, the refinement step is invoked to introduce non-determinism, with the aim of minimizing the number of faulty statements. This step can improve fault localization by conducting a more detailed analysis of previously identified faulty statements. For example, in the scenario outlined in Example 1, refining line 5 into\nif ((_rv1? (f <s): nondet_bool()) && (_rv2? (f >= t) : nondet_bool()))\nenables CFAULTS to determine that only the left part of the binary operation (f <s) is faulty, while the right part remains unaffected. This fine-grained approach allows for more precise detection of program faults. When the refinement step is triggered, CFAULTS instrumentalizes the program again, introducing non-determinism exclusively to the statements previously identified as faulty during the initial Oracle call. Through this process, CFAULTS aims to reduce the set of faulty program components by executing them or assigning them to nondeterministic functions. All remaining program components are executed, meaning their relaxation variables are activated during this step."}, {"title": "5 Experimental Results", "content": "All of the experiments were conducted on an Intel(R) Xeon(R) Silver computer with 4210R CPUs @ 2.40GHz running Linux Debian 10.2, using a memory limit of 32 GB and a timeout of 3600s, for each program. CFAULTS has been evaluated using two distinct benchmarks of C programs: TCAS [10] and C-PACK-IPAS [27]. TCAS stands out as a well-known program benchmark extensively utilized in the fault localization literature [18,21]. This benchmark comprises a C program from Siemens and 41 versions with intentionally introduced faults, with known positions and types of these faults. Conversely, C-PACK-IPAS is a set of student programs collected during an introductory programming course. For this evaluation, we used the first lab class of C-PACK-IPAS, which consists of ten programming assignments, comprising 486 faulty programs and 799 correct implementations. C-PACK-IPAs has proven successful in evaluating various works across program analysis [32], program transformation [29], and clustering [28].\nCFAULTS uses pycparser [33] for unrolling and instrumentalizing C programs. Additionally, CBMC version 5.11 is used to encode C programs into CNF formulas. Furthermore, since the source code of BUGASSIST and SNIPER is either unavailable or no longer maintained (resulting in compilation and linking issues), prototypes of their algorithms were implemented. It is worth noting that the original version of SNIPER could only analyze programs that utilized a subset of ANSI-C, lacked support for loops and recursion, and could only partially handle global variables, arrays, and pointers. In this work, both SNIPER and BUGASSIST handle ANSI-C programs, as their algorithms are built on top of CFAULTS's unroller and instrumentalizer modules. For the MaxSAT oracle, RC2Stratified [15] from the PySAT toolkit [14] (v. 0.1.7.dev19) was used.\nFurthermore, all three FBFL algorithms evaluated (CFAULTS, BUGASSIST, and SNIPER) consistently generate diagnoses that are consistent with (5), indicating that all proposed diagnoses undergo validation by CBMC once the algorithm provides a diagnosis. However, this validation primarily serves to verify diagnoses generated by BUGASSIST, as it has the capability to produce diagnoses that may not align with all failing test cases. In contrast, CFAULTS' MaxSAT solution, by definition, aligns with all observations, and SNIPER's aggregation method (Cartesian product) produces only valid diagnoses, although they may not always be subset-minimal. When considering BUGASSIST, we iterate through all computed diagnoses based on BUGASSIST's voting score, until we identify one diagnosis that is consistent with all observations, i.e., conforms to (5).\nIn TCAS, CFAULTS, whether invoking the refinement step or not, identifies faults in the entire dataset. However, in C-PACK-IPAS, CFAULTS localizes faults in one additional program when the refinement step is not called. Even if the refinement step reaches the time limit, CFAULTS still possesses a subset-minimal diagnosis from the preceding step that has not undergone refinement.\nAdditionally, Figure 2d illustrates a scatter plot comparing the diagnoses' costs achieved by CFAULTS (x-axis) against BUGASSIST (y-axis) on C-PACK-IPAS. BUGASSIST fails to provide an optimal diagnosis in almost 6% of cases. In the TCAS benchmark, although BUGASSIST manages to localize faults in all programs, it yields a non-optimal diagnosis in 10% of the programs. Furthermore, Figure 2e depicts a scatter plot comparing the number of diagnoses generated by CFAULTS (x-axis) against SNIPER (y-axis). While CFAULTS needs to enumerate all MaxSAT solutions due to the weighted MaxSAT formula, it is evident that SNIPER generates significantly more diagnoses than CFAULTS. This discrepancy suggests that SNIPER overlooks the possibility of redundant diagnoses being computed. The number of such redundant diagnoses is much larger than the subset-minimal diagnoses generated by CFAULTS."}, {"title": "6 Related Work", "content": "Fault localization (FL) techniques typically fall into two main families: spectrum-based (SBFL) and formula-based (FBFL). SBFL methods [1,38,26,39,40,2] estimate the likelihood of a statement being faulty based on test coverage information from both passing and failing test executions. While SBFL techniques are generally fast, they may lack precision, as not all identified statements are likely to be the cause of failures [23,35]. In contrast, FBFL approaches [17,18,21,11,20,12,41,42,19] are considered exact. FBFL methods encode the fault localization problem into several optimization problems aimed at identifying the minimum number of faulty statements within a program. Typically, these methods perform a MaxSAT call for each failing test, allowing them to individually identify a minimal set of faults for each failing test case rather than simultaneously addressing all failing test cases. Program slicing [37,35,43] has also emerged as a technique for localizing faults within programs. A more syntactic FBFL approach [35] is to use program slicing to enumerate all minimal sets of repairs for a given faulty program. Another method for identifying the causes of faulty program behaviour involves analyzing the variances between various versions of the software [43]. Refinement has a long-standing tradition in verification; particularly for refining abstractions of reachable states [7,6,4]. In that sense, our form of refinement is different because it enables us to more precisely pinpoint faults of the user, at the sub-expression level."}, {"title": "7 Conclusion", "content": "This paper introduces a novel formula-based fault localization technique for C programs capable of addressing any number of faults. Leveraging Model-Based Diagnosis (MBD) with multiple observations, CFAULTS consolidates all failing test cases into a unified MaxSAT formula, ensuring consistency in the fault localization process. Experimental evaluations on TCAS and C-PACK-IPAS, show that CFAULTS is faster than other FBFL approaches like BUGASSIST and SNIPER. Furthermore, CFAULTS only generates minimal diagnoses of faulty statements, while other methods tend to produce redundant diagnoses."}]}