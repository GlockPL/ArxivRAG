{"title": "On the Equivalence between Logic Programming\nand SETAF", "authors": ["Jo\u00e3o Alc\u00e2ntara", "Renan Cordeiro", "Samy S\u00e1"], "abstract": "A framework with sets of attacking arguments (SETAF) is an extension of the well-known Dung\u2019s\nAbstract Argumentation Frameworks (AAFs) that allows joint attacks on arguments. In this\npaper, we provide a translation from Normal Logic Programs (NLPs) to SETAFs and vice versa,\nfrom SETAFs to NLPs. We show that there is pairwise equivalence between their semantics,\nincluding the equivalence between L-stable and semi-stable semantics. Furthermore, for a class\nof NLPs called Redundancy-Free Atomic Logic Programs (RFALPs), there is also a structural\nequivalence as these back-and-forth translations are each other's inverse. Then, we show that\nRFALPs are as expressive as NLPs by transforming any NLP into an equivalent RFALP through\na series of program transformations already known in the literature. We also show that these\nprogram transformations are confluent, meaning that every NLP will be transformed into a\nunique RFALP. The results presented in this paper enhance our understanding that NLPs and\nSETAFs are essentially the same formalism. Under consideration in Theory and Practice of\nLogic Programming (TPLP).", "sections": [{"title": "1 Introduction", "content": "Argumentation and logic programming are two of the most successful paradigms in arti-\nficial intelligence and knowledge representation. Argumentation revolves around the idea\nof constructing and evaluating arguments to determine the acceptability of a claim. It\nmodels complex reasoning by considering various pieces of evidence and their interrela-\ntionships, making it a powerful tool for handling uncertainty and conflicting information.\nOn the other hand, logic programming provides a formalism for expressing knowledge\nand defining computational processes through a set of logical rules.\nIn this scenario, the Abstract Argumentation Frameworks (AAFs) proposed by Dung\nin his seminal paper (Dung 1995b) have exerted a dominant influence over the devel-"}, {"title": "2 Preliminaries", "content": "2.1 SETAF\nIn (Nielsen and Parsons 2006), an extension of Dung's Abstract Argumentation Frame-\nworks (AAFs) (Dung 1995b) to allow joint attacks on arguments was proposed. The\nresulting framework, called SETAF, is defined next:\nDefinition 1 (SETAF (Nielsen and Parsons 2006))\nA framework with sets of attacking arguments (SETAF for short) is a pair A = (A, Att),\nin which A is a finite set of arguments and Att \u2286 (2A \\ {0}) \u00d7 A is an attack relation such\nthat if (B, a) \u2208 Att, there is no B' \u2282 B such that (B', a) \u2208 Att, i.e., B is a minimal set\n(w.r.t.\u2286) attacking a1. By Att(a) = {B \u2286 A | (B, a) \u2208 Att}, we mean the set of attackers\nof a.\nIn AAFs, only individual arguments can attack arguments. In SETAFs, the novelty is\nthat sets of two or more arguments can also attack arguments. This means that SETAFS\n(A, Att) with |B| = 1 for each (B, a) \u2208 Att amount to (standard Dung) AAFs.\nThe semantics for SETAFs are generalisations of the corresponding semantics for AAFs\n(Nielsen and Parsons 2006) and can be defined equivalently in terms of extensions or\nlabellings (Flouris and Bikakis 2019). Our focus here will be on their labelling-based\nsemantics.\nDefinition 2 (Labellings (Flouris and Bikakis 2019))\nLet A = (A, Att) be a SETAF. A labelling is a function L : A \u2192 {in, out, undec}. It is\nadmissible iff for each a \u2208 A,\n\u2022 If L(a) = in, then for each B\u2208 Att(a), it holds L(b) = out for some b\u2208 B."}, {"title": "2.2 Logic Programs and Semantics", "content": "Now, we take a look at propositional Normal Logic Programs. To delve into their defini-\ntion and semantics, we will follow the presentation outlined in (Caminada et al. 2015b),\nwhich draws from the foundation laid out in (Przymusinski 1990)."}, {"title": "3 From NLP to SETAF", "content": "In this section, we revisit the three-step process of argumentation framework instan-\ntiation as employed in (Caminada et al. 2015b) for translating an NLP into an AAF.\nThis method is based on the approach introduced by (Wu et al. 2009) and shares sim-\nilarities with the procedures used in ASPIC (Caminada and Amgoud 2005; 2007) and\nlogic-based argumentation (Gorogiannis and Hunter 2011). Its first step involves taking\nan NLP and constructing its associated AAF. Then, we apply AAF semantics in the\nsecond step, followed by an analysis of the implications of these semantics at the level\nof conclusions (step 3). In our case, starting with an NLP P, we derive the associated\nSETAF (Ap, Attp). Unlike the construction described in (Caminada et al. 2015b), rules\nwith identical conclusions in P will result in a single argument in Ap. This distinction is\ncapital for establishing the equivalence results between NLPs and SETAFs. Additionally,\nit simplifies steps 2 and 3, making them more straightforward to follow. We now detail\nthis process."}, {"title": "3.1 SETAF Construction", "content": "We will devise one translation from NLP to SETAF that is sufficiently robust to guar-\nantee the equivalence between various kinds of NLPs models and SETAFs labellings.\nSpecifically, our approach will establish the correspondence between partial stable mod-\nels and complete labellings, well-founded models and grounded labellings, regular models\nand preferred labellings, stable models and stable labellings, L-stable models and semi-\nstable labellings. Our method is built upon a translation from NLP to AAF proposed\nin (Caminada et al. 2015b), where NLP rules are directly translated into arguments. We\nwill adapt this approach for SETAF by employing the translation method outlined in\n(Caminada et al. 2015b) to construct statements, and then statements corresponding to\nrules with the same head will be grouped to form a single argument. Taking an NLP P,\nwe can start to construct statements recursively as follows:\nDefinition 8 (Statements and Arguments)\nLet P be an NLP.\n\u2022 If c \u2190 not b\u2081,..., not bn is a rule in P, then it is also a statement (say s) with\nConc(s) = c,\nRules(s) = {c \u2190 not b\u2081, ..., not bn},\nVul(s) = {b\u2081,..., bn}, and\nSub(s) = {s}.\n\u2022 If c \u2190 a1,..., am, not b\u2081,...,not bn is a rule in P and for each ai (1 \u2264 i \u2264 m) there\nexists a statement si with Conc(si) = ai and c \u2190 a1,..., am, not b\u2081,...,not bn is not\ncontained in Rules(si), then c \u2190 (81), ..., (sm), not b\u2081,..., not bn is a statement (say\ns) with\nConc(s) = c,\nRules(s) = Rules(s\u2081) \u222a...\u222a Rules(sm) \u222a {c \u2190 a1,..., am, not b\u2081,..., not bn}\nVul(s) = Vul(s\u2081) \u222a...\u222a Vul(sm) \u222a {b1,..., bn}, and\nSub(s) = {s} \u222a Sub(s1) \u222a . . . \u222a Sub(sm)."}, {"title": "3.2 Equivalence Results", "content": "Once the SETAF has been constructed, we show the equivalence between the semantics\nfor an NLP P and their counterpart for the associated SETAF Ap. One distinguishing\ncharacteristic of our approach in comparison with K\u00f6nig et al.'s proposal (K\u00f6nig et al.\n2022) is that it is more organic. We prove the equivalence results by identifying con-\nnections between fundamental notions used in the definition of the semantics for NLPs\nand SETAFs. With this purpose, we introduce two functions: L2Ip associates an inter-\npretation to each labelling while I2Lp associates a labelling to each interpretation. We\nthen investigate the conditions under which they are each other's inverse and employ\nthese results to prove the equivalence between the semantics. These functions essentially\npermit us to treat interpretations and labellings interchangeably.\nDefinition 11 (L2Ip_and I2LP Functions)\nLet P be an NLP, Ap = (Ap, Attp) be its associated SETAF, Int be the set of all the\n3-valued interpretations of P and Lab be the set of all labellings of Ap. We introduce a\nfunction L2Ip : Lab \u2192 Int such that L2Ip(L) = (T, F), in which\n\u2022 T = {c\u2208 HBp|c\u2208 Ap_and L(c) = in};\n\u2022 F = {c \u2208 HBp|c\u2209 Ap_or c\u2208 Ap and L(c) = out};\n\u2022 TUF = {c\u2208 HBp | c\u2208 Ap_and L(c) = undec}.\nWe introduce a function I2Lp : Int \u2192 Lab such that for any I = (T, F) \u2208 Int and\nany c\u2208 Ap,\n\u2022 I2Lp(I)(c) = in if c \u2208 T;\n\u2022 I2Lp(I)(c) = out if c \u2208 F;\n\u2022 I2Lp(I)(c) = undec if c \u2209 T \u222a F.\nI2Lp(I)(c) is not defined if c \u2209 Ap.\nThe correspondence between labellings and interpretations is clear for those atoms\nc\u2208 HB p in which c\u2208 Ap. In this case, we have that c is interpreted as true iff c is labelled\nas in; c is interpreted as false iff c is labelled as out. In contradistinction, those atoms\nc\u2208 HBp not associated with arguments (c \u2209 Ap) are simply interpreted as false. This\nwill suffice to guarantee our results; next theorem assures us that I2Lp(L2Ip(L)) = L:\nTheorem 3\nLet P be an NLP and Ap = (Ap, Attp) be the associated SETAF. For any labelling L\nof Ap, it holds I2Lp(L2Ip(L)) = L.\nIn general, L2Ip(I2Lp(I)) is not equal to I, because of those atoms c occurring in an\nNLP P, but not in Ap. However, when M is a partial stable model, L2Ip(I2Lp(M)) =\nM:\nTheorem 4\nLet P be an NLP, Ap = (Ap, Attp) be the associated SETAF and M = (T, F) be a\npartial stable model of P. It holds that L2Ip(I2Lp(M)) = M.\nThis means that when restricted to partial stable models and complete labellings,\nL2Ip and I2Lp are each other's inverse. From Lemma 1, and Theorems 3 and 4, we can\nobtain the following result:"}, {"title": "4 From SETAF to NLP", "content": "Now we will provide a translation in the other direction, i.e., from SETAFs to NLPs. As\nin the previous section, this translation guarantees the equivalence between the semantics\nfor NLPs and their counterpart for SETAFs.\nDefinition 12\nLet A = (A, Att) be a SETAF. For any argument a \u2208 A, we will assume Va = {V |\nV is a minimal set (w.r.t. set inclusion) such that for each B\u2208 Att(a), there exists b \u2208\nB \u2229 V}. We define the associated NLP Pa as follows:\nPa = {a \u2190 not b\u2081,...not bn | a \u2208 A, V \u2208 Va_and V = {b1,...,bn}}."}, {"title": "5 On the relation between RFALPs and SETAFS", "content": "We will recall a particular kind of NLPs, called Redundancy-Free Atomic Logic Programs\n(RFALPs). From an RFALP P, we obtain its associated SETAF Ap via Definition 10;\nfrom Ap, we obtain its associated NLP Pap via Definition 12. By following the other\ndirection, from a SETAF A, we obtain its associated NLP Pa, and from Pa, its associated\nSETAF AP. An important result mentioned in this section is that P = Pap_and A =\nAP, i.e., the translation from an NLP to a SETAF and the translation from a SETAF\nto an NLP are each other's inverse. Next, we define RFALPs:\nDefinition 14 (RFALP (K\u00f6nig et al. 2022))\nWe define a Redundancy-Free Atomic Logic Program (RFALP) P as an NLP such that\n1. P is redundancy-free, i.e., HBp = {head(r) | r \u2208 P} and if c \u2190 not b\u2081,...,not bn \u2208 P,\nthere is no rule c \u2190 not c\u2081,...,not Cn' \u2208 P such that {c1,..., Cn' } \u2282 {b1, ..., bn}.\n2. P is atomic, i.e., each rule has the form c \u2190 not b\u2081, ..., not bn (n \u2265 0).\nFirstly, Proposition 12 sustains that for any SETAF A, its associated NLP Pa will\nalways be an RFALP:\nProposition 12\nLet A = (A, Att) be a SETAF and P\u00e5 its associated NLP. It holds Pa is an RFALP.\nThe following results guarantee that A = AP (Theorem 13) and P = Pap (Theorem\n14):\nTheorem 13\nLet A = (A, Att) be a SETAF, Pa its associated NLP and Apr the associated SETAF\nof Pa. It holds that A = APA\nTheorem 14\nLet P be an RFALP, Ap its associated SETAF and Pap the associated NLP of Ap. It\nholds that P = PAp\u00b7"}, {"title": "6 On the Expressiveness of RFALPS", "content": "Dvor\u00e1k et al. comprehensively characterised the expressiveness of SETAFs (Dvo\u0159\u00e1k et al.\n2019). Now we compare the expressiveness of NLPs with that of RFALPs. In the previous\nsection, we established that SETAFs and RFALPs are essentially the same formalism.\nWe demonstrated that from the SETAF Ap associated with an NLP P, we can obtain\nP; and conversely, from the NLP Pa associated with a SETAF A, we can obtain A. Here,\nwe reveal that this connection between SETAFs and RFALPs is even more substantial:\nRFALPs are as expressive as NLPs when considering the semantics for NLPs we have\nexploited in this paper. With this aim in mind, we transform any NLP P into an RFALP\nP* by resorting to a specific combination (denoted by \u21a6UTPM) of some program trans-\nformations proposed by Brass and Dix (Brass and Dix 1994; 1997; 1999). Although each\nprogram transformation in \u2192 UTPM was proposed in (Brass and Dix 1994; 1997; 1999),\nthe combination of these program transformations (as far as we know) has not been in-\nvestigated yet. Then, we show that P and P* share the same partial stable models. Since\nwell-founded models, regular models, stable models, and L-stable models are all settled\non partial stable models, it follows that both P and P* also coincide under these seman-\ntics. Based on Dunne et al.'s work (Dunne et al. 2015), where they define the notion of\nexpressiveness of the semantics for AAFs, we define formally expressiveness in terms of\nthe signatures of the semantics for NLPs:\nDefinition 15 (Expressiveness)\nLet P be a class of NLPs. The signature PSM of the partial stable models associated\nwith P is defined as\n\u03a3 PSM = {\u03c3(P) | P \u2208 P},\nwhere \u03c3(P) = {I|I is a partial stable model of P} is the set of all partial stable models\nof P."}, {"title": "7 Conclusion and Future Works", "content": "This paper investigates the connections between frameworks with sets of attacking ar-\nguments (SETAFs) and Normal Logic Programs (NLPs). Building on the research in\n(Alc\u00e2ntara et al. 2019; Alc\u00e2ntara and S\u00e1 2021), we employ the characterisation of the\nSETAF semantics in terms of labellings (Flouris and Bikakis 2019) to establish a map-\nping from NLPs to SETAFs (and vice versa). We further demonstrate the equivalence\nbetween partial stable, well-founded, regular, stable, and L-stable models semantics for\nNLPs and respectively complete, grounded, preferred, stable, and semi-stable labellings\nfor SETAFs.\nOur translation from NLPs to SETAFs offers a key advantage over the translation\nfrom NLPs to AAFs presented in (Caminada et al. 2015b). Our approach captures the\nequivalence between semi-stable labellings for SETAFs and L-stable models for NLPs. In\naddition, their translation is unable to preserve the structure of the NLPs. While an NLP\ncan be translated to an AAF, recovering the original NLP from the corresponding AAF\nis generally not possible. In contradistinction, we have revisited a class of NLPs called\nRedundancy-Free Atomic Logic Programs (RFALPs). For RFALPs, the translations from\nNLPs to SETAFs, and from SETAFs to NLPs also preserve their structures as they are\neach other's inverse. Hence, when compared to the relationship between NLPs and AAFs,\nthe relationship between NLPs and SETAFs is demonstrably more robust. It extends\nbeyond semantics to encompass structural aspects.\nSome of these results are not new as they have already been obtained independently in\n(K\u00f6nig et al. 2022). In fact, their translation from NLPs to SETAFs and vice versa co-\nincide with ours, and the structural equivalence between RFALPs and SETAFs has also\nbeen identified there. Notwithstanding, our proofs of these results stem from a signifi-"}]}