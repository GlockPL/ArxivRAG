{"title": "Open Digital Rights Enforcement Framework (ODRE): from descriptive to enforceable policies", "authors": ["Andrea Cimmino", "Juan Cano-Benito", "Ra\u00fal Garc\u00eda-Castro"], "abstract": "From centralised platforms to decentralised ecosystems, like Data Spaces, sharing data has become a paramount challenge. For this reason, the definition of data usage policies has become crucial in these domains, highlighting the necessity of effective policy en-forcement mechanisms. The Open Digital Rights Language (ODRL) is a W3C standard ontology designed to describe data usage policies, however, it lacks built-in enforcement capabilities, limiting its practical application. This paper introduces the Open Digital Rights Enforcement (ODRE) framework, whose goal is to provide ODRL with enforce-ment capabilities. The ODRE framework proposes a novel approach to express ODRL policies that integrates the descriptive ontology terms of ODRL with other languages that allow behaviour specification, such as dynamic data handling or function evaluation. The framework includes an enforcement algorithm for ODRL policies and two open-source implementations in Python and Java. The ODRE framework is also designed to support future extensions of ODRL to specific domain scenarios. In addition, current limitations of ODRE, ODRL, and current challenges are reported. Finally, to demonstrate the en-forcement capabilities of the implementations, their performance, and their extensibility features, several experiments have been carried out with positive results.", "sections": [{"title": "1. Introduction", "content": "In recent decades, proposals for sharing and consuming data from a set of wide-ranging domains among different actors have evolved; from large centralised data plat-forms to decentralised ones [1]. Many of these proposals follow a policy-based ap-proach [2]; such as European Data Spaces [3]. On the one hand, they rely on a vocabulary that is used to unequivocally specify conditions and terms set by the data owner under which such data can be used by a third party, and, on the other hand, they rely on a software mechanism that must verify whether these conditions are met, that is, an enforcement procedure implementation. Some of these proposals are standards, such as XACML [4] or ODRL [5]. However, not all of them provide enforcement, and some are only tailored to describe usage policies without the enforcement capabilities, like ODRL.\nThe Open Digital Rights Language (ODRL) is a W3C standard ontology that pro-vides the vocabulary to describe policies in decentralised ecosystems, such as the Web, promoting data sovereignty. The ODRL vocabulary is widespread in numerous data"}, {"title": "2. Classification of ODRL enforceable policies", "content": "ODRL is an ontology that provides the vocabulary to describe or express usage policies following the model depicted in Figure 1. From now on, the prefix odrl: for the ODRL ontology namespace is assumed. These policies may have a set of rules; which may denote permission, duty, or prohibition. Regardless of their type, rules consist of an action and a set of constraints that encode the conditions under which the action must be performed. The constraints have three main descriptive elements: an operator, a left operand, and a right operand. The operands must be either con-cepts defined in the ontology that represent a certain information that is not explic-itly written in the policy (for example, `odrl:dateTime` represents the current date with time), or data constants that have a value and a xsd datatype (for example, { `@value`: `2018-01-01`, `@type`:`xsd:dateTime`}). Operators are always concepts defined in the ontology and represent predicates, i.e., functions that always output a Boolean result.\nIn order to enforce an ODRL policy, first its operands, which are ontology concepts, must be replaced in the policy by a data constant with the information they stand for. In the case of `odrl:dateTime`, a constant representing the actual date and time; which will look similar to the one shown above. Then, the operator must be computed taking"}, {"title": "3. Enforcement Algorithm", "content": "This section presents the ODRE framework algorithm endowed for enforcing ODRL policies expressed the approach explained in the previous section. However, before delve into the details, several concepts used by the algorithm must be defined.\nPolicy. $P_i$ is defined as a policy written with the terms from the ODRL ontology (or any ontological extension of it) and which level is denoted by $i$ that takes as value the letter of the level it represents, for instance, an A-Level policy is denoted as $P_A$. In the case the policy level is unknown, or does not matter (it could be either A, B1, B2, or C), the policy is denoted as $P_*$.\nPolicy reduction. Reducing a policy is the process of enforcing any policy which level is above A-Level (B1, B2, or C levels) and producing as output an A-Level policy. To this end, the procedure reduce is defined, which receives as input a policy $P_*$, a set $M$ that contains data variables and their values, and a set $F$ that contains function vari-ables and their implementations with a coded language. Both sets can be empty in the case no dynamic data is handled or no functions are implemented with the coded language.\nPolicy filtering. Three filtering operations are needed to enforce a given policy. To this end, the procedures rules, constrais, and action are defined. The first, rules, takes as argument an A-Level policy and returns a set $R_{id}$ containing all the ids of every rule written in the policy; each of one denoted as $r_{id}$. The second, constrais, takes as argument an A-Level policy and the id of a rule it contains ($r_{id}$); produces as result a set $C_R$ containing tuples of the form $(O, O_L, O_R)$ where $o$ is an operator, $O_L$ and $O_R$ are its left and right operand respectively. The third, action, takes as argument an A-Level policy and the id of a rule it contains ($r_{id}$); provides as result the action associated to that rule denoted by $a$.\nPolicy transformation. In order to enforce the constrains of a policy these have to be expressed into an interpreted language. To this end, the `transformConstraints` procedure is defined; which takes as argument the set $C_R$ that contains tuples of the form $(O, O_L,O_R)$ being $o$ an operator, and being $O_L$ and $O_R$ its left and right operand respectively. As a result, transformConstraints produces a policy expressed using an interpreted language denoted by $P_1$."}, {"title": "3.1. Running Sample", "content": "In order to provide a running sample using Algorithm 1, let us assume two imple-mentations that use Python and SPARQL as interpreted language, respectively, and Freemarker as templated language. Table 1 shows a glance of how Algorithm 1 would en-force the policies of Listing 1, Listing 2, Listing 3, and Listing 4. For this running sample, it is also assumed as input of Algorithm 1 the values {`requestToken`: `eyJhbGciO...`} for the set M and the set F containing the function request implemented with a Java method (since Listing 4 is expressed with Freemarker that supports Java-coded functions as coded language)."}, {"title": "3.2. Discussion: limitations and challenges ahead", "content": "Once the approach on how to express the ODRL policies to enforce them and handle dynamic data is presented (Section 2) and Algorithm 1, it is important to analyse and highlight several limitations: about the ODRL vocabulary and how it affects Algorithm 1 and about our proposal. In addition, future challenges are discussed.\nODRE bad practices: The approach presented in the article presents a drawback that may imply having different ODRL policies that may seem different but are the same. In addition, these policies would not clearly codify the constraints under which a resources can be used. This is due to the fact that certain policies may mix RDF and an interpolated or templated language which may also inject some behaviour using a coded language. Specifying these constraints without the semantics provided by the ODRL ontology is possible but is a bad practice since, on the one hand, looses the goal of using an ontology that provides a unequivocally definition of a concept, and, on the other hand, makes policies harder to compare, understand by a person, or to write since they will enclose a large amount of behaviour with languages different from the descriptive.\nSynchronous vs asynchronous enforcement: the enforcement of a policy may happen synchronously; whether someone desires to access a certain resource and then the enforcement procedure is invoked. Alternatively, enforcement may occur asynchronously, the constraints of a policy are continuously evaluated and when they enforce positively their related action is performed. Note that these two methods are not exclusive and, instead, there should be policies that must be enforced synchronously and others asyn-chronously. To this end, ODRL lacks of the semantics to label this feature in a policy and it will be a future challenge to tackle. Also, the Algorithm 1 from the ODRE framework has been endowed and tested only to perform synchronous enforcement.\nODRL abstract definitions: the ODRL vocabulary presents some important limi-tations in terms of expressiveness for its operands, operators, and actions. Some of them have abstract definition and, therefore, it is almost impossible to implement them or, several implementations may drastically differ one from the other depending on the par-ticular use case. For instance, the action `read` can be interpreted as gaining the access to a certain API or as if the result of the enforcement is the output of reading such API; other interpretations are also possible, as if someone can read in the physically world a document. This issue can be handled using ODRE by relying on the interpolated/tem-plated language however, this also entails losing certain semantics as already explained before. This can be view as a benefit that ODRE offers, but also, as a bad practice.\nThe only approach to solve this issue correctly, without losing semantics or incurring in bad practices, is to extend the ODRL ontology to such specific use cases, providing operands, operators, and actions that are unequivocally described and, therefore, can only be implemented and interpreted in a unique way."}, {"title": "4. Evaluation", "content": "In order to evaluate Algorithm 1 and prove that the ODRE approach is language agnostic, which means that different languages can be used as interpreted, interpolated, templated, or coded, two implementations are provided: pyodre and odre-java. Both implementations are published on GitHub and distributed as open-source under the APACHE 2.0 licence. Pyodre relies on Python as interpreted language, Jinja2 as inter-polated and templated language, and Python as coded language. This implementation is also distributed through the pip package installer. The odre-java relies on SPARQL as interpreted language, Freemarker as interpolated and templated language, and Java as coded language. This implementation is distributed through maven central.\nBoth implementations cover most of the operands from ODRL, namely: odrl:lt, odrl:lteq, odrl:eq, odrl:neq, odrl:gt, odrl:gteq. Also, they implement the left operand odrl:dateTime. In addition, to prove the extensibility of our proposal, a small extension of the ODRL vocabulary about time has been created. The ontology of this extension is available at https://w3id.org/def/odre-time#, let us assume otime as its prefix. The ontology extension includes a new operand named otime:time that provides the current time, a new operator otime:between that returns true if the current time is between the ones specified as the left and right operands. Finally, as another extension, the action dummy:read has been provided to test the enforcement of the actions. This action reads a dummy API and provides as output its result. Note that this action has no ontology related, since it has been created only to show how actions can be enforced but is not meant to be used in real scenarios."}, {"title": "5. Related Work", "content": "The definition of policies for the usage of data resources has been extensively analysed by researchers [17]. However, it is important to differentiate between two types of research proposals; those focussing on the description of these policies and related challenges, and those focussing on the enforcement of these policies [18]. In addition, another feature to take into account when analysing proposals similar to ODRE is the fact that they rely, or not, on standards vocabularies to express the policies. In this article, the proposals are narrowed down to those that rely on policies expressed with the W3C ODRL standard and which scope is the enforcement of ODRL policies, discarding the rest as out of scope. The proposals related to enforcement are numerous [11, 19], in order to ease their review, the authors have classified them into the following types:\nTheoretical enforcement - these are proposals that promote theoretical ideas to perform the enforcement of ODRL policies, or challenges, but without implementations to support their claims. The proposal of Munoz-Arcentales et al. [20] presents the need for flexible usage control solutions that can be adapted and used in different scenarios, but enforcing ODRL is out of the scope. The proposal of Cirillo et al. [21] rely on a subset of ODRL and does not tackle how to enforce the ODRL policies, but instead, policies expressed with an extended version of ODRL for specific use cases. The proposal of Cirillo et al. [21] is not considered to enforce ODRL since it does not support policies expressed only with ODRL terms. The proposal of Akaichi et al. [3] presents an architecture to handle ODRL policies in scenarios that require dynamic constraints (addressing the limitation ODRL Stone-written conditions). Their proposal focuses on a specific client-server scenario and do not delve in the details of how to express the ODRL policies from a generic point of view of the enforcement. In addition, their proposal extends the ODRL ontology in such a way that their solution works only with it. Finally, their proposal is theoretical and has no implementation related.\nDiscussion: some of these proposals [20, 21] do not actually aim to support ODRL enforcement but, instead, use a subset of the ODRL for certain limited scenarios not promoting a general purpose enforcement solution. Furthermore, these two proposals do not provide a generic algorithm for enforcing ODRL. The proposal closer to ODRE is the one of Akaichi et al. [3] since they addressed one of the limitations that also ODRE"}, {"title": "6. Conclusions", "content": "In this article, the ODRE framework has been presented including: a novel approach to write and classify ODRL policies enabling their enforcement, a generic enforcement algorithm, and two implementations. In addition, an analysis on the current limitations of ODRE and ODRL has been presented along with future challenges. Previous propos-als have delved into how to enforce ODRL: some exclusively from the theoretical point of view, others providing only implementations without research articles, and others traversing the enforcement to other initiatives. These latest proposals have mainly relied on translating ODRL policies into other vocabularies that already supported enforce-ment (such as XACML). However, these proposals fall short when used to enforce any ODRL policy, since the expressiveness (operands, operators, actions, and more) present in the ODRL ontology does not always exist in that target vocabulary. To the best of our knowledge, ODRE is the first proposal that provides a solution to enforce ODRL and is flexible enough to support future extensions of ODRL for specific domain chal-lenges. In addition, the experiments carried out prove that the implementations perform enforcement efficiently for real-world scenarios.\nIn the future, the authors will address the limitations of ODRL and try to tackle challenges identified; such as defining N-ary operators or operands or addressing how to express synchronous and asynchronous enforcement in policies and extend ODRE to support the second. In addition, specific extensions will be developed for the time and geospatial domains. Regarding ODRE limitations, the authors plan to publish good-practices and guidelines documentation to prevent bad practices. Finally, the authors will analyse the impact on the enforcement that may produce using ODRL with other related vocabularies, preferably standard, such as the Data Privacy Vocabulary (DPV) to enrich the expressiveness of usage and privacy use cases."}]}