{"title": "A A-evaluation function for column permutation problems", "authors": ["J\u00fanior R. Lima", "Vin\u00edcius Gandra M. Santos", "Marco Antonio M. Carvalho"], "abstract": "In this study, a new \u2206-evaluation method is introduced for solving a column\npermutation problem defined on a sparse binary matrix with the consecutive\nones property. This problem models various NP-hard problems in graph theory\nand industrial manufacturing contexts. The computational experiments com-\npare the processing time of the A-evaluation method with two other methods\nused in well-known local search procedures. The study considers a compre-\nhensive set of instances of well-known problems, such as Gate Matrix Layout\nand Minimization of Open Stacks. The proposed evaluation method is gener-\nally competitive and particularly useful for large and dense instances. It can\nbe easily integrated into local search and metaheuristic algorithms to improve\nsolutions without significantly increasing processing time.", "sections": [{"title": "Introduction", "content": "The Column Permutation Problem (CPP), a complex and intriguing challenge in the realm\nof matrix operations and optimization problems, can be succinctly described as follows:\ngiven a sparse binary matrix, the task is to identify the corresponding permutation matrix\nthat minimizes the maximum column sum, while adhering to the consecutive ones property.\nGiven a binary m \u00d7 n matrix P, Q\u2122 is the matrix obtained from a permutation \u03c0\u03bff\nthe {1,2,..., n} columns of matrix P. Q\u2122 holds the consecutive ones property, meaning\nall entries between two nonzero entries are also considered to have nonzero value in every\nrow. The elements that switch values from zero to nonzero are called fill-ins. A contiguous\nsequence of nonzero entries (fill-in or not) defines a 1-block in a row. Equation (1) defines\nthe elements of matrix Q={q}, where function \u03c0(i) returns the order of column i in\npermutation \u03c0.\n\n[1, if \u2203x,\u2203y|n(x) \u2264 j \u2264 \u03c0(y) and Piz = Piy = 1\n0, otherwise.\n\nCritical columns have the largest sum in Q\u2122 (i.e., considering fill-ins) and represent\nthe bottleneck of a solution to the CPP. Equation (2) defines the critical columns' value\nZcc(Q).\nZCC(Q", "Q": "content\": \"The Column Permutation Problem (CPP), a complex and intriguing challenge in the realm\nof matrix operations and optimization problems, can be succinctly described as follows:\ngiven a sparse binary matrix, the task is to identify the corresponding permutation matrix\nthat minimizes the maximum column sum, while adhering to the consecutive ones property.\nGiven a binary m \u00d7 n matrix P, Q\u2122 is the matrix obtained from a permutation \u03c0\u03bff\nthe {1,2,..., n} columns of matrix P. Q\u2122 holds the consecutive ones property, meaning\nall entries between two nonzero entries are also considered to have nonzero value in every\nrow. The elements that switch values from zero to nonzero are called fill-ins. A contiguous\nsequence of nonzero entries (fill-in or not) defines a 1-block in a row. Equation (1) defines\nthe elements of matrix Q={q}, where function \u03c0(i) returns the order of column i in\npermutation \u03c0.\n$q^{\\pi}_{ij} = \\begin{cases}\n1, \\text{ if } \\exists x, \\exists y | \\pi(x) \\leq j \\leq \\pi(y) \\text{ and } p_{ix} = p_{iy} = 1 \\\\\n0, \\text{ otherwise.}\n\\end{cases}$ (1)\nCritical columns have the largest sum in Q\u2122 (i.e., considering fill-ins) and represent\nthe bottleneck of a solution to the CPP. Equation (2) defines the critical columns' value\nZcc(Q).\n$Z_{CC}(Q^{\\pi}) = \\max_{j \\in \\{1, ..., n\\}} \\sum_{i=1}^{m} q^{\\pi}_{ij}$ (2)\nThe CPP objective is to find a permutation \u03c0\u2208 \u03a0of columns of P such that the\nmaximum critical column value is minimized in Q"}, {"title": "Related column permutation problems", "content": "The next sections briefly describe each related problem considered in this study and give an\noverview of related studies. The problems are relevant to the industry and are still being\nstudied today with recent meaningful research."}, {"title": "Minimization of open stacks", "content": "The problem of minimizing the maximum number of simultaneous open stacks (Yuen, 1991)\narises in industrial environments, in which a factory needs to supply specific combinations\nof products that have associated given demands. A single machine manufactures all the\nproducts in batches and handles a single product type at each stage. Whenever a customer\norders a set of products, a new open stack is associated with it, meaning that physical space\naround the machine is assigned to it until that order is fulfilled - the stack's closure. There\nis an implicit assumption of a physical limit on the space around the machine because\nthere is not enough free room to simultaneously place all customers' orders. Thus, to\nbetter use that physical space, it is necessary to determine the sequence of the products'\nmanufacturing.\nThe Minimization of Open Stacks Problem (MOSP) is an NP-Hard problem (Linhares\nand Yanasse, 2002) defined on a binary sparse matrix P, where the n rows correspond to\nthe customers' orders and the m columns correspond to each product type available. Entry"}, {"title": "Gate matrix layout", "content": "In the context of Very Large Scale Integration (VLSI) design, a Gate Matrix is a bidimen-\nsional programmable logical device used to implement combinatorial logic circuits. Different\nconnections among OR and AND logical gates are necessary to produce specific logical func-\ntions in those circuits. Each connection uses a wire and a subset of gates called net. Nets\nthat do not share gates among them can be implemented into tracks (i.e., physical rows).\nThe circuit's underlying logic is not changed if the gates sequencing (i.e., their layout) is\naltered. The overall circuit area is a function of the number of tracks needed to implement\nthe nets on the printed circuit.\nThe Gate Matrix Layout Problem (GMLP) is an NP-Hard problem (Kashiwabara and"}, {"title": "Methods", "content": "This section briefly describes the basic idea of the two basic evaluation methods. Further-\nmore, the proposed A-evaluation method is presented in detail. The implementation in\nC++ is available at GitHub for noncommercial use."}, {"title": "Complete matrix evaluation", "content": "Matrices initially represent the problems presented in the previous section. To evaluate\nsuch problems, the most intuitive way is to go through the matrix every time a change in\nthe solution is made. Hence, the evaluation of a solution using matrix representation is\nperformed in O(nm) complexity. This operation is time-consuming and, depending on the\nsize of the instance, it becomes impractical for, for example, the aforementioned local search\nprocedures. In the worst-case scenario, the complexity of these procedures is bounded by\n\u03a9(n\u00b3m) each when using the complete matrix evaluation."}, {"title": "Indirect evaluation", "content": "The indirect evaluation method adopts a list to represent the input matrix. The idea is\nto store only the nonzero entries per column in a list A of n elements, one representing\neach column. Each element of A is also a list, which stores the indices of rows containing\nnonzero entries in that column. Furthermore, this method relies on two support structures\nto evaluate the solution: an array that stores the number of nonzero entries per row and\na Boolean array that, given a partial solution, informs which rows have 1-blocks being\nconsidered in the evaluation at each column being analyzed. In the worst-case scenario,\nthe indirect evaluation method is bounded by O(nm) complexity when the instance has no\nzero entries. Hence, this representation is particularly efficient when the input matrix is\nlarge and sparse. However, the complexity of the local search procedures is still bounded\nby O(n\u00b3m)."}, {"title": "\u0394-evaluation", "content": "Given an initial solution \u03c0, a move removes a column from its original position in\u03c0and\ninserts it in a target position. The insertion move, considering origin < target, is carried by\nshifting the column forward one position at a time until the target position is reached. This\nshift can be interpreted as swapping a column on position i with a column immediately\nto its right on position i + 1. The behavior of the elements of Q\u2122 were grouped into four\ndifferent sets:\n\u2022 leading ones (L): nonzero entries at the beginning of a 1-block in a row;\n\u2022 trailing ones (T): nonzero entries at the end of a 1-block in a row;\n\u2022 consecutive ones (C): zero entries positioned in between nonzero entries in a row;\n\u2022 intermediate ones (I): nonzero entries in a row that neither are in the beginning\nnor the end of a 1-block.\nThe representation of these sets was performed with the aid of a bitset structure. This\nstructure stores only one bit (value 0 or 1), indicating the presence or absence of elements\nin a particular set.\nEach column i of the matrix Q\u2122 has its own sets Li, Ti, Ci and Ii. Consequently, there\nis a bit that represents for each stage if, for a given row, occurs or not leading or trailing\nones, if there is a discontinuity in a 1-block, or if there is one that is neither a leading nor a\ntrailing one. In this way, Boolean logic is applied bitwise in the sets of two columns affected\nby the swap move and is sufficient to evaluate the new solution value of Q"}, {"title": "Calculate A", "content": "The value of A indicates the difference between the original solution and the new solution\nobtained after changing the position of the columns. From the proposed approach, the A\ncalculation is summarized in the following steps:\n1. Initialize the contents of each set considered for each column of Q. This procedure\nhas complexity bounded by O(nm) and is called only once;\n2. Simulate the insertion move in the solution and update the contents of each set\nconsidered for each column of Q between the origin and the target position;\n3. Calculate the difference between the values of both solutions:\n\u2022 If the result value is negative, the solution improved because the sum of the\nelements on the critical columns in the new solution is lower. At this point the\nsolution is updated effecting the movement.\n\u2022 Otherwise, the value of the critical columns increased or remained the same. In\nthis case, the solution remains the same without performing the movement.\nAll sets must be updated at each swap move of two consecutive columns. The update\nof each set, for the stages i and i + 1 are given by the following Boolean expressions:\n$L_{i} = L_{i+1} \\lor (L_{i} \\land I_{i+1}) \\lor (L_{i} \\land T_{i+1})$ (4)\n$L_{i+1} = L_{i} \\land (\\neg I_{i+1} \\land \\neg T_{i+1})$ (5)\n$I_{i} = (T_{i+1} \\land I_{i}) \\lor (I_{i+1} \\land \\neg L_{i})$ (6)\n$I_{i+1} = (L_{i} \\land I_{i+1}) \\lor (I_{i} \\land \\neg T_{i+1})$ (7)\n$T_{i} = T_{i+1} \\land (\\neg I_{i} \\land \\neg L_{i})$ (8)\n$T_{i+1} = T_{i} \\lor (T_{i+1} \\land I_{i}) \\lor (T_{i+1} \\land L_{i})$ (9)\n$C_{i} = (C_{i+1} \\land \\neg L_{i}) \\lor T_{i}$ (10)\n$C_{i+1} = (C_{i} \\land \\neg T_{i+1}) \\lor L_{i+1}$ (11)\nNote that the order in which those operations are processed is not important since each\noperation uses a copy of the original content of each set. Hence, if the Li set is updated\nfirst, the Li set used to calculate, for example, the set Ci will be a copy of the original Li\nbefore its update. After calculating the new content of the eight sets, the original sets are\nupdated."}, {"title": "Update leading ones", "content": "The leading ones set represents nonzero entries that start a 1-block in a particular stage.\nThe stage in which the 1-block starts can directly influence the obtained result. Equation\n(12) shows how to update the leading ones on stage i when swapping it with stage i + 1.\nIn the sequence, each component of the equation is analyzed and explained.\n$L_{i} = L_{i+1} \\lor (L_{i} \\land I_{i+1}) \\lor (L_{i} \\land T_{i+1})$ (12)\n\u2022 Li+1: The column referring to stage i + 1 will become the column referring to stage\ni. Thus, leading ones on stage i + 1 will become leading ones on stage i, starting the\n1-block one column earlier;\n\u2022 (LiIi+1): Express the relationship between leading ones on stage i and the presence\nof intermediate ones on stage i + 1. If both are true, the intermediate ones on stage\ni + 1 will become the leading ones on stage i and vice versa. If there are no leading\nones on stage i, it is impossible to have intermediate ones on stage i + 1. Thus, the\nswap will result in both zero entries.\n\u2022 (LiTi+1): Express the relationship between leading ones on stage i and trailing ones\non stage i + 1. If a 1-block starts on stage i and immediately ends on stage i + 1, the\nswap of these two columns will result in no change in the leading ones on stage i. If\nthere are leading ones on stage i and no trailing ones on stage i + 1, the leading ones\nwill happen on stage i + 1, and stage i will be empty.\nBased on Equation (12), it is possible to notice that the new leading ones on stage i are\na result of the relationship between leading ones, intermediate ones, and trailing ones on\nstage i + 1 and the former leading ones on stage i.\nEquation (13) presents the Boolean expression to update the leading ones on stage i+1\nwhen swapping it with stage i. The explanation of each component comes next.\n$L_{i+1} = L_{i} \\land (\\neg I_{i+1} \\land \\neg T_{i+1})$ (13)\n\u2022 (Li\u00acIi+1): Express the relationship between leading ones on stage i and the absence\nof intermediate ones on stage i + 1. The column referring to stage i will be moved to\nstage i + 1, thus, if there is no intermediate ones on stage i + 1, the 1-block will start\non stage i + 1, instead of on stage i;\n\u2022 (L\u00bf\u00acTi+1): Certifies that the 1-block starting on stage i is not immediately ending\non stage i + 1. If there are no trailing ones on stage i + 1, the leading ones from stage\ni will be moved to stage i + 1.\nEquation (13) states that leading ones on stage i + 1 are given by the leading ones on\nstage i less the intermediate ones and trailing ones on stage i + 1."}, {"title": "Update intermediate ones", "content": "Intermediate ones represent rows that have already had their 1-block started in earlier\nstages but have not finished or ended. In other words, they are nonzero entries in a given\ncolumn but not leading or trailing. Depending on the movements of columns, intermediate\nones can fall at the beginning or end of a 1-block and, in turn, become a leading or trailing\none."}, {"title": "Update trailing ones", "content": "Trailing ones represent nonzero entries that close a 1-block in a specific stage. After swap-\nping stages, stages with trailing ones might turn into intermediate or even leading ones.\nEquation (16) shows how to update trailing ones on stage i when swapping it with stage\ni+1.\n$T_{i} = T_{i+1} \\land (\\neg I_{i} \\land \\neg L_{i})$ (16)\n\u2022 Ti+1: Initially, the new stage i can only have trailing ones if there were trailing ones\non the former stage i + 1. Thus, the 1-block will end sooner.\n\u2022 (\u00acIi\u00acLi): Determines the relationship between trailing ones on stage i and the\nabsence of intermediate ones and leading ones on stage i. In case there are no leading\nor intermediate ones on stage i, the trailing ones on stage i + 1 are moved to stage i\nafter the swap."}, {"title": "Update consecutive ones", "content": "The consecutive ones represent zero entries between two nonzero entries; these values are\nswitched to nonzero entries and are also known as fill-ins. In other words, they are entries\nbetween leading ones and trailing ones that are not intermediate ones. Minimizing the\nnumber of consecutive ones directly affects the maximum value of critical columns per stage.\nMoving stages with consecutive ones often result in these consecutive ones disappearing.\nGiven a swap of two stages, to update the consecutive ones on stage i, it is necessary\nto consider consecutive ones on stage i + 1 and leading ones and trailing ones on stage i.\nEquation (18) shows how to update the consecutive ones on stage i.\n$C_{i} = (C_{i+1} \\land \\neg L_{i}) \\lor T_{i}$ (18)\n\u2022 (Ci+1\u00acLi): Determines the relationship between consecutive ones on stage i +1 and\nthe absence of leading ones on stage i. After the swap of the two stages, consecutive\nones on stage i + 1 will continue to be consecutive ones on stage i unless there are\nleading ones on stage i. In this case, the 1-block would start later, on stage i + 1, and\nthe consecutive ones on stage i would cease to exist.\n\u2022 Ti: For each trailing one on stage i, after the swap, the 1-block will have its ending\npostponed to stage i + 1. This results in stage i having a consecutive one.\nThe analysis to update the consecutive ones on stage i + 1 involves the consecutive ones\non stage i and the trailing and leading ones on stage i + 1. Equation (19) shows how to\nupdate the consecutive ones on stage i + 1.\n$C_{i+1} = (C_{i} \\land \\neg T_{i+1}) \\lor L_{i+1}$ (19)\n\u2022 (Ci\u00acTi+1): Express the relationship between consecutive ones on stage i and the\nabsence of trailing ones on stage i +1. Consecutive ones on stage i will also be carried\nto stage i + 1 as consecutive ones unless the 1-block ends on stage i + 1."}, {"title": "Computational results", "content": "The computational experiments were conducted on an Intel Core i7-8700 3.2 GHz processor\nwith 16 GB RAM using Ubuntu 18.04 LTS. The proposed methods were coded in C++\nand compiled with GCC 7.4.0 and the -03 optimization option. The implemetations are\navailable for download at GitHub for noncommercial use.\nFour different sets of artificial instances for MOSP and GMLP were considered. To\nbetter evaluate the processing time, the instance sets selected for the experiments are\nrestricted to sets with larger instances. Firstly, Becceneri instance set (Becceneri et al.,\n2004) contains 710 instances ranging from 10 to 150 rows and columns. Chu and Stuckey\n(2009) proposed an instance set, Chu&Stuckey, with 200 instances ranging from 30 to 125\nrows and columns. The Larger&Harder instance set, proposed by Carvalho and Soma\n(2015), contains 150 instances with 150, 175, or 200 rows and columns. Finally, Frinhani\net al. (2018) proposed an even larger instance set, Very Hard, containing 610 instances with\n400, 600, 800, or 1000 rows and columns.\nThis study focuses on assessing each evaluation method's performance rather than\nachieving optimal solutions. Hence, three well-known and simple descent local search meth-\nods will be applied to a random initial solution. The procedures are the best insertion, first\nimprovement 2-swap, and 2-opt.\nThe procedures apply consecutive moves on the solution and preserve the move only in\ncase of improvement of the solution value. Otherwise, the move is discarded. If the move\nimproves the solution, the local search starts over again. The procedure stops when all\npossible moves have been considered, and no further improvement has been made. Dis-\nregarding restarts, the three presented procedures have neighborhoods, i.e., the number\nof possible moves, bounded by O(n\u00b2). Each instance was run ten independent times for\neach local search procedure. For each time, one numerically predetermined seed was used\nto generate random numbers; hence, for each instance, the three local searches found the\nsame solution and number of improvements, leading to the procedure restart, allowing for\na fair comparison.\nThe time comparison presented in the following graphs for each local search procedure\nwas converted into a logarithm scale for better data visualization. Moreover, the time val-\nues for instances bigger than 600\u00d7600, in Figures (d), for the matrix evaluation method\nis an interpolation based on the size of the instance. Finally, for each local search pro-\ncedure, statistical experiments were conducted between the A-evaluation and the indirect\nevaluation method on the Very Hard instance set time results to analyze their different per-\nformance further. A standard test is performed first, Shapiro-Wilk normality test (Shapiro\nand Wilk, 1965), and rejected the null hypothesis that the results could be modeled ac-\ncording to a normal distribution. Then, given that the results are not normally distributed,\nthe non-parametric Wilcoxon signed-rank test Rey and Neuh\u00e4user (2011) was employed\nto investigate if there is a significant difference between the time performance of the A-\nevaluation and the indirect evaluation method."}, {"title": "Best Insertion", "content": "This local search randomly selects one column per time and inserts it in every possible\nposition of the solution. The column is fixed in the position that yields the best result\nvalue. Figure 1 shows the time comparison for the three evaluation methods."}, {"title": "2-Swap", "content": "All pairs of columns are generated and swapped for this local search in a random sequence.\nFigure 2 shows the time comparison for the three evaluation methods.\nThe A-evaluation method makes two insertion movements for this local search. Hence,\nit requires more processing time. However, the method is still competitive, mainly for\nlarge and dense instances. The proposed method only has a superior time average for the\nChu&Stuckey instance set, outperforming the indirect and matrix evaluation method on\nthe other three instance sets.\nThe A-evaluation can maintain a more linear processing time for instances of the same\nsame, independent of its density. On the other hand, the indirect evaluation is faster for\nless dense instances and significantly increases time for more dense instances. For example,\nthe indirect evaluation takes 14.52 seconds to process the first 1000\u00d71000 instance and\n1053.36 for the last and more dense 1000\u00d71000 instance. The A-evaluation takes 174.55\nand 246.85 seconds for the same two instances. The matrix evaluation is not influenced as\nmuch by the instance density. However, its running time is, without question, much slower.\nThe number of calls is the same for the three methods, given that the methods need\nto be invoked only once for each swap. The Wilcoxon signed-rank test (V = 96898, p-\nvalue = 0.8036) indicates no statistical difference between the A-evaluation and indirect\nevaluation method regarding the time performance on the Very Hard instance set. However,\nthe proposed method has a lower time average, is more consistent, and can be employed\ninstead of the indirect method without performance loss."}, {"title": "2-Opt", "content": "The last local search also generates all pairs of columns. The procedure inverts the position\nof all the column sequences from the first column in the pair to the second one. Figure 3\nshows the time comparison for the three evaluation methods."}, {"title": "Conclusion", "content": "We have addressed a generic column permutation problem on binary matrices that produce\npermutation matrices that hold the consecutive ones property. This generic problem models\nmany theoretical and real-world optimization NP-Hard problems from different contexts\nsuch as graph theory, very large-scale integration design, and industrial production plan-\nning. A new evaluation method, A-evaluation, was proposed and proved to be faster in two\nout of three test scenarios compared to more intuitive evaluation methods. The average\nrunning time is lower in almost all the instance sets used in the computational experiments.\nThe proposed method is significantly faster for larger and more dense instances. Statisti-\ncal tests proved that the proposed method outperforms the more intuitive methods in two\ncommonly used local search procedures. The proposed method can be employed in descent\nlocal search procedures, especially for the best insertion method, with a minimum time\ncost."}]}