{"title": "Counting and Reasoning with Plans", "authors": ["David Speck", "Markus Hecher", "Daniel Gnad", "Johannes K. Fichte", "Augusto B. Corr\u00eaa"], "abstract": "Classical planning asks for a sequence of operators reaching a given goal. While the most common case is to compute a plan, many scenarios require more than that. However, quantitative reasoning on the plan space remains mostly unexplored. A fundamental problem is to count plans, which relates to the conditional probability on the plan space. Indeed, qualitative and quantitative approaches are well-established in various other areas of automated reasoning.\nWe present the first study to quantitative and qualitative reasoning on the plan space. In particular, we focus on polynomially bounded plans. On the theoretical side, we study its complexity, which gives rise to rich reasoning modes. Since counting is hard in general, we introduce the easier notion of facets, which enables understanding the significance of operators. On the practical side, we implement quantitative reasoning for planning. Thereby, we transform a planning task into a propositional formula and use knowledge compilation to count different plans. This framework scales well to large plan spaces, while enabling rich reasoning capabilities such as learning pruning functions and explainable planning.", "sections": [{"title": "1 Introduction", "content": "The overarching objective of classical planning is to find a plan, i.e., a sequence of operators, that transforms the current state into a goal state. While in some scenarios a single plan is sufficient, in others, it may not be clear which plan is preferable based on the description of the planning task. To address this, solvers like top-k or top-quality planners have been developed to enumerate the k shortest plans or all plans up to a certain length bound allowing for post hoc consideration of the plan space and selection [Katz et al., 2018; Katz and Sohrabi, 2020; Speck et al., 2020; von Tschammer et al., 2022; Chakraborti et al., 2024]. Although this paradigm has been successfully applied in practical areas such as malware detection [Boddy et al., 2005] and scenario planning for risk management [Sohrabi et al., 2018], it remains an indirect method for reasoning about the plan space of a planning task.\nConsidering fundamental problems in computer science, such as the propositional satisfiability problem (SAT), answer set programming (ASP), and constraint satisfaction problems (CSP), more directed reasoning schemes exist that are anchored around counting. The most prominent and canon-ical counting problem is #SAT, also called model counting, which asks to compute the number of models of a formula. While #SAT is considered computationally harder than asking whether a single model exists (SAT), it also allows for automated reasoning about the solution space [Darwiche, 2001a; Darwiche and Marquis, 2002]. Recent competitions illustrate that, despite high computational com-plexity, state-of-the-art solvers are effective in practice [Fichte et al., 2021]. Due favorable reasoning power and vast applications, counting techniques have been extended to other fields [Aziz et al., 2015; Fichte et al., 2017; Hahn et al., 2022; Eiter et al., 2024b].\nIn this paper, we bridge the gap between model counting and classical planning by introducing a new framework for reasoning and analyzing plan space. To do so, we consider all plans for a given planning task with polynomially bounded length, consistent with the approach used in top-quality planning [Katz and Sohrabi, 2020]."}, {"title": "Contributions", "content": "Our main contributions are as follows:\n1. We introduce a taxonomy of counting and reasoning problems for classical planning with polyno-mially bounded plan lengths and establish the computational complexity of these problems.\n2. We identify a class of reasoning problems on the plan space, called facet reasoning, that are as hard as polynomially bounded planning and thus can be solved more efficiently than counting problems.\n3. We present a practical tool, Planalyst, that builds on existing planning and knowledge compilation techniques to answer plan-space reasoning queries and demonstrate its practical feasibility."}, {"title": "In more detail", "content": "on the theoretical side, we formally define a taxonomy of counting and reasoning problems for planning and analyze the computational complexity of these problems. Among other results, we show that the problem of probabilistic reasoning about the plan space such as determining how many plans contain a given operator is CP-complete, which is considered computationally harder than counting the number of plans, known to be #P-complete [Speck et al., 2020]. We also introduce the notion of facet reasoning in the context of planning, which has origins in computational complexity [Papadimitriou and Yannakakis, 1982] and is well studied in ASP [Alrabbaa et al., 2018; Fichte et al., 2022a]. We show that facet reasoning in planning is NP-complete, and thus probably much simpler than counting the number of plans. This theoretical result is significant because it allows more efficient answers to complex reasoning queries about the plan space, such as identifying which operators can complement a given partial plan and which provide more flexibility for further complementation.\nOn the practical side, we present a solution to the studied counting and reasoning problems by transforming a planning task into a propositional formula, where satisfying assignments correspond one-to-one to plans, followed by subsequent knowledge compilation into a d-DNNF [Darwiche and Marquis, 2002]. We implement this as a tool called Planalyst, which builds on existing tools from planning [Rintanen, 2014] and knowledge compilation [Lagniez and Marquis, 2017; Sundermann et al., 2024] and thus readily allows plan counting and automated reasoning in plan space. Empirically, we compare Planalyst to state-of-the-art top-quality planners on the computationally challenging problem of counting plans, and show that our tool performs favorably, especially when the plan space is large and reasoning over trillions of plans is critical. Finally, by constructing a d-DNNF, our approach not only supports plan counting, but can also answer reasoning questions such as conditional probability, faceted reasoning, and unbiased uniform plan sampling, all through efficient d-DNNF queries."}, {"title": "Related Work", "content": "Darwiche and Marquis [2002] detailed the theoretical capabilities and limitations of normal forms in knowledge compilation. Established propositional knowledge compilers are c2d [Darwiche, 2004] and d4, new developments are extensions of SharpSAT-TD [Kiesel and Eiter, 2023]. Incremental and approximate counting has been considered for ASP [Kabir et al., 2022; Fichte et al., 2024]. In SAT and ASP, advanced enumeration techniques have also been studied [Masina et al., 2023; Spallitta et al., 2024; Gebser et al., 2009; Alviano et al., 2023], which can be beneficial for counting if the number of solutions is sufficiently low or when (partial) solutions need to be materialized. Exact uniform sampling using"}, {"title": "2 Preliminaries", "content": "We assume that the reader is familiar with basics of propositional logic [Kleine B\u00fcning and Lettmann, 1999] and computational complexity [Papadimitriou, 1994]. Below, we follow standard definitions [Bylander, 1994; Speck et al., 2020] to summarize basic notations for planning.\nBasics For an integer $i$, we define $[i] := \\{0,1,...,i\\}$. We abbreviate the domain of a function $f: D\\rightarrow R$ by $dom(f)$. By $f^{-1} : R \\rightarrow D$ we denote the inverse function $f^{-1} := \\{f(d) \\rightarrow d \\mid d \\in dom(f)\\}$ of function $f$, if it exists. Let $\\sigma = (s_1,s_2,...,s_l)$ be a sequence, then we write $s\\in\\sigma$ if $s = s_i$ for some $1 \\leq i \\leq l$ and $\\nabla(\\sigma)$ the set of elements that occur in $\\sigma$, i.e., $\\nabla(\\sigma) := \\{s \\mid s \\in \\sigma\\}$. For a propositional formula $F$, we abbreviate by $vars(F)$ the variables that occur in $F$ and by $Mod(F)$ the set of all models of $F$ and the number of models by $\\#(F) := | Mod(F)|$.\nComputational Complexity We follow standard terminology in computational complexity [Papadimitriou, 1994] and the Polynomial Hierarchy (PH) [Stockmeyer and Meyer, 1973; Stockmeyer, 1976; Wrathall, 1976]. The complexity class DP captures the (independent) combination of an NP and a coNP problem, i.e., $D^P := \\{L_1 \\cap L_2 \\mid L_1 \\in NP, L_2 \\in coNP\\}$ [Papadimitriou and Yannakakis, 1982]. Class PP [Gill, 1977] refers to those decision problems that can be characterized by a nondeterministic Turing machine, such that the positive instances are those where at least 1/2 of the machine's paths are accepting. Counting class #P captures counting problems that can be solved by counting the number of accepting paths of a nondeterministic Turing machine [Valiant, 1979]. Class CP [Fenner et al., 1999] refers to decision problems that can be characterized via nondeterministic Turing machines where positive instances are those with the same number of accepting and rejecting paths.\nClassical Planning A planning task is a tuple $\\Pi = (A, O, I, G)$, where $A$ is a finite set of propositional state variables. A (partial) state $s$ is a total (partial) mapping $s : A \\rightarrow \\{0, 1\\}$. For a state $s$ and a partial"}, {"title": "Example 1 (Running Example)", "content": "Consider a planning task $\\Pi_1$ consisting of a scenario with a slightly chaotic researcher, who has to wake up and give a talk at AAAI. Depending on how late they are, they can go straight to the talk without any preparation. However, they could also spend time getting ready. Less pleasant to the audience, they could also continue sleeping and not give the talk at all. Figure 1 illustrates the state space. The initial state is $s_0$, and the single goal state is $s^*$. The labels in each edge identify the operator being applied. We can easily identify two plans:\n(i) wake-up; get-ready; go-to-AAAI; give-talk.\n(ii) wake-up; go-to-AAAI; give-talk.\nPlan (i) has length 4, while Plan (ii) has length 3. Observe that action sleep does not appear in any plan."}, {"title": "Landmarks", "content": "A fact landmark is a state variable that occurs in every plan [Porteous et al., 2001]. An operator landmark is an operator that occurs in every plan [Richter et al., 2008; Karpas and Domshlak, 2009]. We can extend these notions to bounded landmarks where we assume bounded length $l$.\nExample 2. Consider planning task $\\Pi_1$ from Example 1. We observe that wake-up, go-to-AAAI, and give-talk are operator landmarks."}, {"title": "Planning as Satisfiability (SAT)", "content": "Let $\\Pi = (A, O,I,G)$ be a planning task and $l > 0$ an integer to bound the length of a potential plan. We can employ a standard technique to encode finding a plan into a propositional formula and ask for its satisfiability (SAT) [Kautz and Selman, 1992; Rintanen, 2012]. In more detail, we can construct a formula $F^{plan}_{<l}[\\Pi]$ whose models are in one-to-one correspondence with the $l$-bounded plans of $\\Pi$. For space reasons, we present only the core idea. The variables are as follows: $vars(F^{plan}_{<l}) = \\{a^i \\mid a \\in A, i \\in [l]\\} \\cup \\{o^i \\mid o \\in O, i \\in [l]\\}$. Variable $a^i$ indicates the value of state variable $a$ at the $i$-th step of the plan. Hence, if $M\\in Mod(F^{plan}_{<l}[\\Pi])$ and $a^i \\in M$, then state variable $a$ has value 1 after applying operators $o^0, ..., o^{l-1}$ to the initial state. We assume sequential encodings, where the following constraints hold.\n1. a set of clauses encoding the value of each state variable at the initial state;\n2. a set of clauses encoding the value of each state variable in the goal condition;\n3. a set of clauses guaranteeing that no two operators are chosen at the same step; and\n4. a set of clauses guaranteeing the consistency of state variables after an operator is applied. If $o^i$ is true and the effect of operator $o$ makes $a$ true, then $a^{i+1}$ must be true.\nSince plans might be shorter than $l$, we move \u201cunused\u201d steps to the end using the formula $\\bigwedge_{i\\in[l]} (\\bigwedge_{o\\in O} \\neg o^i \\rightarrow \\bigwedge_{o\\in O} \\neg o^{i+1})$, which encodes that if no operator was assigned at step $i$, then no operator can be assigned at step $i + 1$. Thereby, we obtain a one-to-one mapping between models of $F^{plan}_{<l} [\\Pi]$ and $l$-bounded plans for the task."}, {"title": "3 From Qualitative to Quantitative Reasoning", "content": "Classical planning aims at finding one plan or enumerating certain plans. But what if we want plans that contain a certain operator, or to count the number of possible plans given certain assumptions, or if we want to identify the frequency of an operator among all possible plans? Currently, there is no unified reasoning tool to deal with these types of questions. We introduce more detailed qualitative and quantitative reasoning modes for planning and analyze its complexity. We start with two extreme reasoning modes that consider whether an operator is part of some or all plans.\nDefinition 3. Let $\\Pi = (A, O,I,G)$ be a planning task, $o \\in O$ an operator, and $l$ an integer. We define the\n*   brave operator by $BO_l(\\Pi) := \\bigcup_{\\pi\\in Plan_l(\\Pi)} \\nabla(\\pi)$ and\n*   cautious operator by $CO_l(\\Pi) := \\bigcap_{\\pi\\in Plan_l(\\Pi)} \\nabla(\\pi)$.\nThe problem POLY-BRAVE-PLAN-EXIST asks to decide whether $o \\in BO_l(\\Pi)$. The problem POLY-CAUTIOUS-PLAN-EXIST asks to decide whether $o \\in CO_l(\\Pi)$.\nNote that we use $\\nabla(\\cdot)$ to convert sequences into sets, as we aim only for an operator occurring at any time-point.\nRemark 4. Our definition of cautious operators is similar to operator landmarks [Zhu and Givan, 2003], but for plans with up to a given bounded length."}, {"title": "Example 5", "content": "Consider task $\\Pi_1$ from Example 1 and Plans (i) and (ii). Furthermore, let $l = 4$. Then, the brave and cautious operators of our task are the following:\n$BO_4(\\Pi_1) = \\{\\text{wake-up}, \\text{get-ready}, \\text{go-to-AAAI}, \\text{give-talk}\\}$,\n$CO_4(\\Pi_1) = \\{\\text{wake-up}, \\text{go-to-AAAI}, \\text{give-talk}\\}$.\nOperator get-ready is brave but not cautious, as it appears in Plan (i) but not in Plan (ii). Operator sleep is neither brave nor cautious, as it does not appear in any plan."}, {"title": "3.1 Probability Reasoning", "content": "Both problems POLY-BRAVE-PLAN-EXIST and POLY-CAUTIOUS-PLAN-EXIST give rise to extreme rea-soning modes on plans. Cautious reasoning is quite strict and so unlikely to hold in general. Brave reasoning is too general and permissive, and thus quite weak in practice. Figure 2 illustrates the two reasoning modes and a more fine-grained mode, which we introduce below. This new mode asks whether the conditional probability of an operator is above a given threshold. It generalizes the known POLY-BOUNDED-TOP-K-EXIST planning problem, which only asks whether at least $k$ plans exists. The crucial ingredient is counting the number of possible plans and relating them to the number of possible plans which contain a given operator. More formally: Let $\\Pi = (A, O,I,G)$ be a planning task, $o$ be an oper-ator. We abbreviate the set of all plans of $\\Pi$ containing $o$ by $Plan_l(\\Pi, o) := \\{\\pi\\mid \\pi\\in Plan_l(\\Pi), o \\in \\pi\\}$. Then, we define the conditional probability of $o$ in plans of $\\Pi$ by\n$P_l[\\Pi, o] := \\frac{| Plan_l (\\Pi, o)|}{\\max(1, | Plan_l (\\Pi)|)}.$\nNote that the usage of max prevents division by zero in case of no possible plan. Analogously, we can talk about operator $o$ in position $i$ by replacing $o \\in \\pi$ with $o = \\pi(i)$. With the help of conditional probability, we can define a fine-grained reasoning mode.\nTo be more flexible, we define a query $Q$ as a propositional formula in conjunctive normal form (CNF) and assume its meaning as expected. We let $Q$ contain variables corresponding to the set $A$ of state variables, the set $O$ of operators, as well as of states and operators in position $i$ (similar to $F^{plan}$). Let $\\pi\\in Plan_l(\\Pi)$ be a plan with $\\pi = (o_0,..., o_{n-1})$ that generates sequence $s_0,...,s_n$. $\\pi$ satisfies a variable $v \\in A$ if there is some $i \\in [l]$ such that $s_i(v) = 1$; $\\pi$ satisfies an operator $o \\in O$ if there is some $i \\in [l]$ such that $\\pi(i) = o$, analogously for fixed time-points $i$. Then, $\\pi$ satisfies $\\neg v$ if $\\pi$ does not satisfy $v$. A plan $\\pi$ satisfies a clause $C$ in $Q$, if $\\pi$ satisfies one of its literals; $\\pi$ satisfies $Q$, denoted $\\pi |= Q$, if it satisfies every clause in $Q$. We define $Plan_l(\\Pi, Q) := \\{\\pi \\mid\\pi\\in Plan_l(\\Pi), \\pi |= Q\\}$.\nDefinition 7 (Probability Reasoning). Let $\\Pi = \\langle A, O,I,G\\rangle$ be a planning task, $l > 0$ be an integer, $Q$ be a query, and $0<p<1$ with $p \\in Q$. Then, probability reasoning on $Q$ asks if $P_l[\\Pi, Q] = p$, where\n$P_l [\\Pi, Q] = \\frac{| Plan_l (\\Pi, Q)|}{\\max(1, | Plan_l (\\Pi)|)}.$"}, {"title": "Example 8 (Probability Reasoning)", "content": "Again, consider planning task $\\Pi_1$ from Example 1 and let $l = 4$. Take the following probability reasoning queries: (i) $P_l[\\Pi_1, \\text{wake-up}] = 1$, (ii) $P_l[\\Pi_1, \\text{get-ready}] = 0.5$, and (iii) $P_l[\\Pi_1, \\text{sleep}] = 0$. Reasoning (i) illustrates that the researcher must always use operator wake-up to reach a goal; (ii) indicates that get-ready occurs in half of the plans; (iii) allows us to conclude"}, {"title": "Probability reasoning can be achieved by counting twice, which is computationally hard", "content": "In more detail, we obtain:\nTheorem 9 (*). The problem POLY-PROBABILISTIC-REASON is CP-complete."}, {"title": "4 Faceted Reasoning", "content": "Above, we introduced three different reasoning modes, namely brave, probability, cautious reasoning. Unfortunately the most precise reasoning mode -the probability mode is the computational most expensive one and requires to count plans. Therefore, we turn our attention to reasoning that is less hard than probabilistic reasoning and allows us still to filter plans and quantify uncertainty among plans. We call this reasoning faceted reasoning following terminology from combinatorics [Papadimitriou and Yannakakis, 1982] and ASP [Alrabbaa et al., 2018]. At the heart of these tasks is a combination of brave and cautious reasoning. These are particularly useful if we want to develop plans gradually/in-crementally to see at a given time point, which operators are still possible or have the biggest effect. We focus on operators that belong to some (brave) but not to all plans (cautious).\nMore formally, for a planning task $\\Pi$ and an integer $l$, we let $F^+ (\\Pi) := BO_l(\\Pi) \\setminus CO_l(\\Pi)$ and call the elements of $F^+ (\\Pi)$ inclusive facets. In addition, we distinguish excluding facets $F^-(\\Pi)$, which indicate that operators are not part of a plan. More formally, we let $F^- := \\{\\neg o \\mid o\\in F^+(II)\\}$ and define the set $F_l(\\Pi)$ of all facets by $F_l(\\Pi) := F^+_l (\\Pi) \\cup F^-_l (\\Pi)$. Interestingly, a facet $p\\in \\{o, \\neg o\\}$ is directly related to uncertainty, since the operator $o$ can either be included in or be excluded from a plan. When we enforce that a facet $p \\in \\{o, \\neg o\\}$ is present in a plan, which we abbreviate by $\\Pi[p]$, we immediately reduce uncertainty on operators among the plans. Based on this understanding, we define the notion of significance for a planning task $\\Pi = (A, O, 1, G)$ and an operator $o \\in O$:\n$S_l(\\Pi, o) := \\frac{|F_l(\\Pi)| - |F_l(\\Pi[o])|}{|F_l(\\Pi)|}.$\nNote that the notion of significance is particularly interesting when we already have a prefix $w_k = (o_0,..., o_k)$ and are interested in plans that complete the prefix. Here, facets can assist in understanding which operator is the most significant for the next step or some step in the future. Furthermore, we can include state variables into significance notations without effect on the complexity. We omit these cases from the presentation due to space constraints and readability of our introduced notion."}, {"title": "4.1 Computational Aspects of Facets", "content": "Next, we study the computational complexity for problems related to facets. We limit ourselves to including facets, assume the case where an operator occurs in some step, and we omit prefixes in the following. These restrictions have only a negligible effect on the complexity. We start with a natural reasoning problem: The FACETREASON problem asks, given a planning task $\\Pi$ and an operator $o \\in O$, to decide whether $o \\in F(\\Pi)$. We start with a lower and upper bound on the FACETREASON problem.\nTheorem 10 (*). Let $\\Pi$ be a planning task and $o \\in O$. The problem FACETREASON is NP-complete.\nNext, we look into counting facets and first observe that the number of facets is bound by $0 \\leq |F(\\Pi)| \\leq |O|$ for a planning task $\\Pi$. Therefore, we consider a parameterized version by taking a bound $k$ on the number of facets as input. Then, the problem EXACT-K-FACETS asks, given a planning task $\\Pi$ and an integer $k$, to decide whether $|F(\\Pi)| = k$. Before, we look into upper and lower bounds by the problems ATLEAST-K-FACETS and ATMOST-K-FACETS, which ask whether $|F(\\Pi)| \\geq k$ and $|F(\\Pi)| \\leq k$, respectively."}, {"title": "5 Discussion: Applications of Plan Reasoning", "content": "Our new reasoning modes offer a rich framework to query the solution space of planning tasks. In Remark 4, we discussed the connection between landmarks and cautious reasoning. Similarly, with brave and cautious reasoning it is easy to answer questions such as \"does operator o appear on any plan?\", or \"does partial state p occur on any trajectory?\"\nThe expressiveness of the queries goes way beyond and can be leveraged in many existing planning techniques. For example, determining the set of operators that are always or never part of a plan is important for learning pruning functions [Gnad et al., 2019]. We can generalize these more global queries to reason about operators being only (never) applied in states that satisfy certain conditions, which is essential for learning policies [Krajnansk\u00fd et al., 2014; Bonet and Geffner, 2015]. Furthermore, brave and cautious reasoning can be helpful for model debugging, offering a convenient tool to find out if an operator expected to occur in a plan does in fact never appear [Lin et al., 2023; Gragera et al., 2023]. In over-subscription planning [Smith, 2004], we can determine the achievability of soft goals or compute the achievable maximum set of soft goals by answering multiple queries. This can be utilized in explainable planning, providing reasons for the absence of solutions that achieve the desired set of soft goals [Eifler et al., 2020; Krarup et al., 2021]. We can even generalize the notion of soft goals to desired state atoms that are achieved along a plan, but which might no longer hold in the goal.\nWith faceted reasoning, we are able to answer plan-space queries without actually counting the number of solutions. This reduces the complexity of answering queries to NP-completeness, making reasoning much more practically usable. What makes facet reasoning particularly interesting is that it allows to efficiently answer conditional queries, such as \"if I want operator o to occur at step k, how much choice is left for the remaining operators?\". Similar to previous work in ASP, facet reasoning allows for an interactive querying mode in which users can gain insights about the particular solution space of a planning task [Fichte et al., 2022a]. For tasks with a large set of plans that cannot possibly be navigated manually, facets offer the possibility to systematically navigate the solution space, narrowing down the set of plans by committing to desired operators. The Planalyst tool, which we describe in more detail in the next section, enables this form of interactive exploration in the context of classical planning."}, {"title": "6 Empirical Evaluation", "content": "We implemented our reasoning framework for classical planning as a tool called Planalyst. Therefore, we transform planning tasks into SAT formulas based on the Madagascar planner [Rintanen, 2011; Rintanen, 2014]. To efficiently carry out counting, we use d4 [Lagniez and Marquis, 2017; Audemard et al., 2022], which compiles (potentially large) formulas into a specialized normal form called d-DNNF [Darwiche and Marquis, 2002], enabling fast reasoning. Finally, we reason over the plan space via counting queries using the ddnnife reasoner [Sundermann et al., 2024], which works in poly-time on d-DNNFs."}, {"title": "6.1 Experimental Setup", "content": "We focus on solving #BOUNDED-PLAN, i.e., counting the number of plans, which is the computationally hardest problem studied above. This allows us to address all reasoning questions discussed, including computing conditional probabilities. For each task of the benchmark set, we defined an upper bound by collecting known bounds from planning.domains [Muise, 2016] and running winning planners from the most recent International Planning Competitions (IPC) [Taitler et al., 2024]. In the experiments, we count plans of length up to a multiplicative factor $c \\in \\{1.0, 1.1, 1.2, 1.3, 1.4, 1.5\\}$ of the collected upper bounds. We consider two different configurations for our approach: Count, which only counts the number of plans, and Enum, which additionally enumerates all plans, resulting in a novel top-quality planner for classical planning with unit operator costs. For comparison, we have chosen two top-quality planners, K* [Katz et al., 2018] and SymK [Speck et al., 2020], both of which can be readily used to count the number of plans as they enumerate them, and both of which are considered to scale well to large numbers of plans. We ran both baseline planners in their recommended configurations: K*, which implements orbit-space search [Katz and Lee, 2023] with the landmark-cut heuristic [Helmert and Domshlak, 2009], and SymK, which implements a variant of bidirectional symbolic search [Torralba et al., 2017]. For enumeration approaches (K*, SymK, Enum), we let these solvers enumerate the plans only internally to avoid writing billions (or more) of plans to the disk. All experiments ran on Intel Xeon Silver 4114 processors running at 2.2 GHz. We used a time limit of 30 minutes and a memory limit of 6 GiB per task. Our benchmarks include all optimal planning domains from IPCs 1998-2023 with unit operator costs and without conditional effects or axioms. Source code, benchmarks, and data are available online [Speck et al., 2024]."}, {"title": "6.2 Overall Performance", "content": "compares the coverage, i.e., the number of tasks for which different approaches can determine the number of plans, for different multiplicative length bounds. K* has the best coverage for a length bound of 1.0. Our enumeration approach, Enum, ranks overall last, although being able to solve a notable number of tasks by first creating a d-DNNF, followed by a subsequent enumeration query for all models, and finally mapping them to actual plans. For the 1.0 bound, our counting approach Count performs worse than K*, but has better coverage than the Symk planner. When considering higher length bounds, the counting approach, Count, has the highest coverage. The gap between Count and the other approaches gets larger as the length bound increases. This can be explained by the increasing number of plans, see"}, {"title": "6.3 Domain-Wise Performance", "content": "shows a domain-wise comparison of the different approaches for the two extreme bounds in our experiments, 1.0 and 1.5. For both bounds, the performance differs a lot depending on the domain. Our SAT-based approach performs particularly well in the blocksworld and psr-small domains in both cases. In blocksworld, the largest task that we could still solve had 1.5 10\u00ba plans, while in psr-small the largest solved task had 8.9.1012. In contrast, K* could only count up to a 10 million plans in these"}, {"title": "6.4 Beyond Counting", "content": "As illustrated above, our Planalyst tool effectively counts plans by compiling into a d-DNNF and performing a counting query. This method can not only answer conditional probability questions, such as the quantity of an operator in plans, but also addresses other reasoning questions more directly and efficiently through d-DNNF queries using ddnnife [Sundermann et al., 2024]. Consider reasoning questions about the plan space of a given planning task, while respecting a cost bound. Given the d-DNNF representing the plan space, questions about brave and cautious operators can be answered directly, even without traversing the entire d-DNNF, when the number of plans is known [Sundermann et al., 2024]. This can be achieved by traversing the literal nodes of the d-DNNF and collecting the backbone variables, i.e., the variables that are always true (core) or false (dead). In addition, given the d-DNNF, it is possible to uniformly sample plans without enumerating the full set by d-DNNF traversing with ddnnife. This allows to address planning biases when selecting plans [Paredes et al., 2024; Frank et al., 2024] and thus collect unbiased training data for different learning approaches [Shen et al., 2020; Areces et al., 2023; Chen et al., 2024; Bachor and Behnke, 2024]. We omit empirical results for these queries, as their overhead is negligible once the d-DNNF is constructed. Our experiments with the Count configuration of Planalyst have shown that this construction is feasible for many planning tasks."}, {"title": "7 Conclusion and Future Work", "content": "We count plans and reason in the solution space, which is orthogonal to previous works in planning [Katz et al., 2018; Speck et al., 2020; Katz and Sohrabi, 2020", "2021": "grounding via learning [Gnad et al., 2019", "2024": ".", "2019": "and certifying results [Alviano et al., 2019; Fichte et al., 2022c", "2020": ".", "2012": "or lifted encodings"}]}