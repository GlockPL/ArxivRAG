{"title": "Logic-Constrained Shortest Paths for Flight Planning", "authors": ["Ricardo Euler", "Pedro Maristany de las Casas", "Ralf Bornd\u00f6rfer"], "abstract": "The Logic-Constrained Shortest Path Problem (LCSP) combines a one-to-one shortest path problem with satisfiability constraints imposed on the routing graph. This setting arises in flight planning, where air traffic control (ATC) authorities are enforcing a set of traffic flow restrictions (TFRs) on aircraft routes in order to increase safety and throughput. We propose a new branch and bound-based algorithm for the LCSP.\nThe resulting algorithm has three main degrees of freedom: the node selection rule, the branching rule and the conflict. While node selection and branching rules have been long studied in the MIP and SAT communities, most of them cannot be applied out of the box for the LCSP. We review the existing literature and develop tailored variants of the most prominent rules. The conflict, the set of variables to which the branching rule is applied, is unique to the LCSP. We analyze its theoretical impact on the B&B algorithm.\nIn the second part of the paper, we show how to model the Flight Planning Problem with TFRs as an LCSP and solve it using the branch and bound algorithm. We demonstrate the algorithm's efficiency on a dataset consisting of a global flight graph and a set of around 20000 real TFRs obtained from our industry partner Lufthansa Systems GmbH. We make this dataset publicly available. Finally, we conduct an empirical in-depth analysis of node selection rules, branching rules and conflicts. Carefully choosing an appropriate combination yields an improvement of an order of magnitude compared to an uninformed choice.", "sections": [{"title": "1 Introduction", "content": "The problem of routing an aircraft from a source airport to a target airport while minimizing the operational cost is called the Flight Planning Problem (FPP) and its multiple variants and constraints have been thoroughly studied in the literature [1, 2, 3, 4, 5, 6, 7, 8]. FPP is a time-dependent one-to-one shortest path problem defined on a directed graph called an airway network with arc cost functions that depend on fuel consumption, weather, and overflight costs. The two input airports are called an origin-destination pair or, in short, an OD pair.\nA cornerstone for commercial aircraft routing systems is the handling of so-called Traffic Flow Restrictions (TFR) imposed on the airway network. A TFR can, for example, specify that any aircraft that enters Germany using a node on the frontier with Switzerland and heads to the southern part of the UK must leave the European mainland via Bruges. This mandatory rule gives the air traffic controllers some predictability and enables a single controller to survey more aircraft simultaneously. That is why Flight Planning solvers need to compute optimal routes that adhere to the TFR system. Otherwise, the computed routes are not accepted by air traffic controllers.\nTFRs are stated as propositional formulae that can be formulated in disjunctive normal form (DNF) where the literals correspond to nodes and arcs in the airway network. Currently, there are around 20000 active TFRs that are updated every day. The TFR example above exhibits a general algorithmic problem arising in TFR handling: the resolution (after Bruges) of a rule can be geographically far away from its activation (entering Germany via Switzerland). Suppose two subpaths p and q meet in Germany while computing a route from Croatia to the UK. Assume pentered Germany via Switzerland and q did not. Moreover, let q be more expensive than p when both paths meet. State-of-the-art shortest path algorithms would at this point discard q because it is more expensive. In our situation, however, we cannot discard q because p is forced to leave the European mainland via Bruges and this might result in a more expensive route at the end. The high amount of TFRs in real-world scenarios thus invalidates solution approaches in which every subpath has a logical subsystem attached to it [5, 4, 7]. In such approaches, subpaths only become comparable via their cost when their logical systems involve the same TFRs. This causes an exponential number of incomparable paths to be stored until shortly before the target airport is reached, only to keep a single path as an optimal solution.\nIn this paper, we model the flight planning problem with traffic flow restrictions as a Logic-Constrained Shortest Path Problem (LCSP) and suggest a branch and bound (B&B) algorithm to solve it. In every node of the B&B tree, an FPP instance is solved without considering TFRs. The resulting path is then evaluated w.r.t. the TFRs and the resulting logical infeasibilities are used to branch. This black box approach circumvents the above-mentioned memory consump- tion and running time issues caused by the incomparability of paths. Across world regions, the distribution of TFRs is heterogeneous. For example, there is a large amount of TFRs in Central Europe and the Persian Gulf but very few in Australia or Southern Africa (cf. Fig. 1). For many OD pairs, our algorithm thus solves the LCSP instances in the root node of the B&B tree creating very little overhead compared to a standard FPP search.\nSince our approach repeatedly recomputes shortest paths, we can make use of one of the several dynamic shortest path algorithms in the literature [9, 10, 11, 12, 13, 14, 15]. These approaches enable us to warm-start the shortest-path queries in the B&B tree. They are meant to avoid the re-exploration of the search space (graph) on, e.g., a route from Australia to Europe, if the only TFR violations are close to the destination airport.\nShortest path problems with logical constraints have been studied on occasion in the litera- ture. Aloul et al. [16] propose a pseudo-Boolean formulation for the shortest path problem that lends itself to the integration of logical constraints. They obtain poor run times even on small graphs and even in the absence of logical constraints. Nishino et al. [17] propose a framework in which logical constraints are formulated as binary decision diagrams (BDDs). TFRs are, however, not given as BDDs but as propositional formulae and even a minimum size BDD can be exponential in the size of the propositional formula [18]. The formal language constrained shortest path problems (FLCSP) [19] demands that the shortest path is accepted by a formal"}, {"title": "1.1 Contribution", "content": "In this paper, we make three contributions. First, we formalize the Logic-Constrained Shortest Path Problem on acyclic directed graphs and present a B&B-based algorithm to solve it. Second, we adapt several branching strategies from the MIP and SAT communities for the LCSP"}, {"title": "2 An Algorithm for the Logic-Constrained Shortest Path Problem", "content": "We consider a directed acyclic graph (DAG) G = (V, A) and a propositional formula \u03a6 over a set of propositional variables X. Some variables Y\u2264 X correspond to arcs in G via a bijection \u03c1: A\u2192Y. We call variables in Y graph variables and variables in Z := X\\Y free variables."}, {"title": "2.1 Notation for Propositional Logic", "content": "W.l.o.g., we assume I to be in conjunctive normal form (CNF), i.e., \u03a6 is a conjunction of clauses and each clause is a disjunction of literals l \u03b5 \u222ax\u2208X{x,\u00acx}. This assumption is justified since any propositional formula can be transformed into a CNF in linear time using the Tseitin encoding [23]. The resulting formula contains additional variables representing subformulae, but the size increase is linear w.r.t. the original size of \u03a6. Indexing clauses with I and the literals in a clause i\u03b5 I with Ji, I can be written in set notation as\n$\\Phi = \\{\\{l_{ij} : j\\in J_i\\}:i\\in I\\}.$  (1)\nA set of literals T \u2286 \u222ax\u2208x {x,\u00acx} is called an assignment T if it does not contain a contra- diction, i.e., for all l\u03b5T we have \u00acl \u2209 T. An assignment assigns truth values to the variables X, i.e., x \u2208 X is assigned true if x \u2208 T and assigned false if \u00acx \u2208 T. If neither x \u2208T nor \u00acx \u2208T, the variable x is called unassigned. An assignment T is complete if it assigns all variables, i.e, |T| = |X|.\nUsing the notation from [24], we may condition I on some literal I by letting\n$\\Phi|_l := \\{\\alpha\\{\\neg l\\}: \\alpha\\in\\Phi,l \\notin \\alpha\\},$ (2)\ni.e., in Il all clauses containing I are deleted and \u00acl is removed from the remaining ones. All other clauses remain unchanged.\nFor an assignment T, we let \u03a6|\u03a4 := \u03a6|l1| ... |lk for any ordering (11,..., lk) of T. The expres- sion is well-defined, since conditioning is order-invariant.\nFinally, an assignment T satisfies \u00de if P|T = \u00d8. Specifically, it satisfies a clause a if {a}|T = \u00d8. If there is no assignment that satisfies I, it is unsatisfiable. If IT contains the empty clause {}, it contradicts I certifying that no assignment T'\u2287T can satisfy \u03a6."}, {"title": "2.2 The Logic-Constrained Shortest Path Problem", "content": "The formula determines feasibility of paths in G in the following way: Every path p induces a unique assignment Tp := {\u03c1(a) : \u03b1 \u03b5 p} \u222a {\u00ac\u03c1(\u03b1) : a \u2209 p}. This assignment assigns all graph variables Y and leaves the free variables Z unassigned. We say that a path p and an assignment Tagree if p induces T\u2229Y. The path p satisfies I if there exists a complete assignment T that agrees with p and satisfies \u03a6.\nDefinition 2.1 (The Logic-Constrained Shortest Path Problem). An instance of the Logic- Constrained Shortest Path Problem (LCSP), denoted (G, \u03a6, p, s, t), consists of a non-negatively weighted acyclic directed graph G = (V, A, w) with weights wa, a \u2208 A, two nodes s, t \u2208 V, a CNF formula over propositional variables X = Y Z, and a bijection p: A\u2192Y. A path's cost is the sum of the weights of the path's arcs. The set of feasible paths from stotis denoted by Ps,t() and contains all paths that satisfy \u03a6. Then, the LCSP is to find an s-t-path p\u0454 Ps,t()\nof minimal cost.\nThe LCSP is NP-hard. This follows directly from the NP-hardness of the shortest path problem with forbidden pairs (SPFP) [22]. The SPFP asks for an s,t-path in a graph that does not contain any pair of nodes from a list of pairs. An SPFP instance can be transformed into an LCSP instance in which all clauses in I have size two in polynomial time. Thus, the NP-hardness of the SPFP on DAGs implies the NP-hardness of LCSP."}, {"title": "2.3A B&B algorithm for the LCSP", "content": "We derive a B&B algorithm for the LCSP from the following two observations: First, given an LCSP instance (G, \u03a6, p, s, t) and a (partial) assignment T, it is possible to construct a subgraph GT of G in which all s,t-paths agree with T. This means that if for some y\u2208 Y the literal \u00acy is in T no s-t-path may contain p\u207b\u00b9(y). Otherwise, if y is in T, any s-t-path in Gr contains the arc p\u207b\u00b9(y). This can be achieved by deleting a carefully chosen set of arcs from G. We call this procedure the enforcement of T. For now, we postpone the details on enforcement to Section 2.6.\nSecond, I can be simplified to the equisatisfiable formula IT that contains no variable assigned by T. Combined, this allows us to derive a new LCSP instance that assumes all literals in T to be assigned and a corresponding shortest path relaxation.\nDefinition 2.2 (Subproblems associated with T). Consider an LCSP instance as in Defini- tion 2.1 and an assignment T of \u03a6. The graph induced by T, denoted by GT, is the subgraph of G = (V, A) obtained by enforcing every arc that is set to true in T and forbidding every arc that is set to false. We denote by A(GT) \u2286 A the arc set of GT. Then, (GT, \u03a6|T, p, s, t) is a new LCSP instance called the subproblem induced by T. We call the One-to-One Shortest Path instance (GT, s, t) the shortest path relaxation induced by T.\nThe algorithm works by repeatedly selecting a subproblem (GT, \u03a6|T, p, s, t) from a queue of subproblems, generating the subgraph GT, and then solving the shortest path relaxation (GT, s, t).\nClearly, an optimal solution p to (GT, s, t) may not satisfy \u03a6\u03a4. When this happens, our algorithm chooses an unassigned variable x \u2208 X, branches, and creates two new subproblems (G\\TU{x}, \u03a6|T\u222a {x}, p, s, t) and (G\\T\u222a{\u00acx}, \u03a6|T\u222a {\u00acx}, p, s, t).\nBoth the variable assignment in the branching step and the enforcement of T might cause logical implications in T. These implications further simplify T and may even lead to contradictions. Deriving these implications is called propagation and is discussed in detail in"}, {"title": "2.3.1 Initialization", "content": "The algorithm maintains an incumbent path p* \u0454 Ps,t(\u0424) and, implicitly, a B&B tree. Each node in the tree corresponds to an assignment T of I. A queue Q stores the nodes that have not yet been processed. The root node of the B&B tree corresponds to the empty assignment, which we denote by \u00d8. It is pushed to Q in Line 2."}, {"title": "2.3.2 Main Loop", "content": "In Line 4, an unprocessed assignment T is selected from Q using a node selection rule (Sec- tion 3.1) and dequeued in Line 5. In Line 8, a propagation heuristic on IT assigns additional literals in T, thereby simplifying T (see Section 2.5). If IT then contains the empty clause {}, \u03a6\u2758T is unsatisfiable, certifying infeasibility of the subproblem (GT, \u03a6|T, p, s, t).\nIf no logical infeasibility is detected, we build the shortest path instance (GT, s, t) associated to T in Line 11. This is done by deleting arcs from G that conflict with the literals in T. The procedure is explained in detail in Section 2.6. The remaining s,t-paths in Gr are precisely those agreeing with T (cf. Proposition 2.2).\nFor any deleted arc \u0430 \u0454 A\\A(Gr), p(a) must be assigned false in T. If any such arcs exists that is assigned true in T, we have found a contradiction in T and the current subproblem is infeasible. This is checked in Line 13. Then, the unassigned (a) variables are assigned false in T in Lines 14 and 15. This may trigger new propagations such that we return to Line 7. This process is repeated until either infeasibility is detected or no new propagations can be made.\nThen, the shortest path instance (GT, s, t) is solved in Line 18. Let p be the solution obtained for (Gr, s, t). If p = NULL, s and t are disconnected in Gr implying that there exists no path that agrees with T. Again, we find (Gr, \u03a6|T, p, s, t) to be infeasible. Otherwise, if w(p) < w(p*),\nwe compute the union T of T and the assignment Tp induced by p in Line 20. By construction of GT, T contains no contradiction and is hence an assignment. In Line 21, we check whether p\u2208 Ps,t(\u03a6\u03a4). Recall that T contains Tp and since Tp is an assignment induced by a path, it assigns all graph variables. Hence, \u03a6\u03a4 contains only free variables, and, to determine whether pe Ps,t(IT), it suffices to solve a pure SAT problem over the formula \u03a6|T. If \u03a6\u2758T is satisfiable, p satisfies and it becomes the new incumbent p* (Line 22). If IT is unsatisfiable, we select any variable y not yet in T and add two new assignments T\u222a {y} and T\u222a {y} to the queue (Line 25, Line 26)."}, {"title": "2.4 Termination", "content": "The algorithm terminates when the queue Q is found to be empty at the beginning of an iteration of the main loop. When this happens, the incumbent path p* is returned (Line 27).\nProposition 2.1. Algorithm 1 solves the LCSP.\nProof. If the check in Line 19 never fails, Algorithm 1 will enumerate all complete assignments T that satisfy \u0424 and, for each T, compute a cost minimal s, t-path in Gr. If the check in Line 19 fails, either Gr is disconnected or any s, t-path in Gr has higher weight than p*. Both hold for any GT with T' \u05dbT as well. Hence, T need no longer be considered."}, {"title": "2.5 Propagation", "content": "The goal in Line 8 is to strengthen the current subproblem by assigning additional variables in T and thereby simplify \u03a6\u03a4. To do so, we employ unit propagation which is the core propagation technique at the heart of Davis-Putnam-Logemann-Loveland (DPLL) [25] and conflict-driven clause learning (CDCL) SAT solvers [26, 27, 28]. The technique searches for a unit clause in \u0424T, i.e, a clause containing only one literal 1. As adding -l to T would generate the empty clause, we can then replace T by TU {1}. By doing so, clauses containing I are fulfilled, and, most importantly, clauses containing -l decrease in size and can become unit clauses. This procedure is repeated until no more unit clauses are found.\nUnit propagation is sound, i.e., it generates new valid clauses but not refutation-complete, i.e., it might be unable to produce the empty clause even if |\u03a4 is unsatisfiable [29]. Depending on the problem structure, it may be worthwhile to employ a refutation-complete resolution method, e.g, linear resolution [30].\nOn free variables in Z, we may also perform pure literal elimination [25], i.e., if a literal l appears in IT but not its negation \u00acl, we can set T \u2190 T\u222a{1}. This technique does not extend to graph variables, as assigning them has an effect on the routing graph G|T."}, {"title": "2.6 Enforcing Literals and Shortest Path Search", "content": "In Line 11 of Algorithm 1, enforce(G, T) builds a subgraph Gr of G in which all s,t-paths agree with T. This is ensured as follows: For literals -y, we delete p\u207b\u00b9(y) from the arc set A. For literals y, we enforce p\u207b\u00b9(y) to be contained in every s, t-path by deleting a set of alternative arcs. As Gis acyclic, we compute a topological order t : V \u2192 Nof Vin linear time w.r.t. G's size [31]. Then, to enforce p\u207b\u00b9(y) = (u,v), we delete all arcs d\u207a(u)\\{(u,v)} as well as all arcs (i, j) with t(i) < t(u) and t(j) > t(u).\nProposition 2.2. The s,t-paths in Gr are exactly those agreeing with T.\nProof. For each \u00acy \u2208T, p\u207b\u00b9(y) is deleted in Gr. For each y \u2208 T, p\u207b\u00b9(y) is a bridge separating s and t and hence part of any s,t-path in Gr. Let (u,v) be an arc deleted in Gr. By the topological sorting, no s, t-path agreeing with T may use one of the deleted edges.\nIn Line 18, shortestPath(G|T, s, t) solves the shortest path relaxation (Gr, s, t) by com- puting a shortests, t-path p in Gr. Here, any shortest path algorithm may be used. Note that, to speed up the algorithm, any (sub)path processed in the shortest path algorithm that exceeds the costs of the incumbent p* can be neglected.\nThe shortest path search can be performed using a dynamic shortest path algorithm in the following way: The shortest path search manages a single shortest path tree and keeps a reference to the last assignment T' and graph Gr, on which a shortest s,-path was calculated. When a shortest path search on Gr is triggered for a new assignment T, all differences between Gr and Gr are processed in the initialization phase of the algorithm. Then, the main phase is started to obtain a shortest path tree for Gr. Since T need not be a predecessor of T' in the B&B-tree, the new graph G\u2081r may contain inserted and deleted arcs with respect to Gr'. There are several options available in the literature [9, 10, 11, 12, 13] that can deal with arc insertions and deletions. The best choice, however, depends heavily on the graph structure [14, 15] such that no general recommendation can be made here.\nFinally, for some assignment T, the shortest path computed in Line 18 may be identical to the one computed in its parent node, denoted by parent (T). Before running shortestPath(GT),\nwe hence check whether\n$\\arg \\min_{p\\in P_{s, t}(parent(T))} w(\\rho) \\varepsilon \\sigma_T.$ (3)"}, {"title": "2.7 Validation and Conflict Generation", "content": "The shortest path p computed in Line 18 induces an assignment Tp. By construction of G\u0442, \u0440 agrees with T. Hence, it agrees with T := TUT\u300f (Line 20). Since Tp assigns all graph variables, T does as well, and the formula \u03a6\u2758T contains only free variables. If \u0424\u2758T is satisfiable, we have hence found a shortest path in Pst(T) \u2286 Pst(\u03a6\u03a4) \u2286 Pst() and can update the incumbent solution p* in Line 22.\nIf T is unsatisfiable, we need to choose an unassigned variable to branch on. Algorithm 1 is correct for any choice from X\\T. It is, however, preferable to identify a subset of variables CCXT that we suspect to be in some way responsible for the unsatisfiability. We call such a set a conflict.\nThe conflict hence plays a similar role to the set of fractional variables in MIP solving. It is, however, not necessarily unique. It is also not to be confused with the learned conflicts in CDCL solvers, which are formed by variables from T.\nA conflict can be obtained, for example, as the set of all variables occurring in an unsatisfiable core of IT, that is, a subset of clauses that remains unsatisfiable. Computing unsatisfiable cores is a standard feature of incremental SAT solvers like MiniSAT [32, 33]. As only graph variables lead to new enforcements in the graph, it might be worthwhile to only consider conflicts consisting of graph variables.\nProposition 2.3. Branching exclusively on graph variables and performing the check in Eq. (3) guarantees that Algorithm 1 computes no shortest s,t-path more than once.\nProof. Let p be a shortest path in both Gr\u2081 and GT\u2082 for two assignments T1, T2 that were derived from the empty assignment by branching exclusively on graph variables. Let T = T\u2081\u2229T2 be the lowest common ancestor of T\u2081 and T2 in the B&B tree. The path p must be a feasible s, t-path in Gr. After branching on any graph variable y \u2208 Y\\T, p will be infeasible in at least one of the child nodes T\u222a{y} and T\u222a{\u00acy}. W.l.o.g. assume this is T\u222a{y}. Since G\u2081\u2081, \u2286 G\\T\u222a{y}\nfor all assignments T' \u2287 T \u222a {y}, this also holds for any child node of T\u222a {y}. This means that all assignments for which p is an optimal shortest path must lie on an oriented path in the B&B tree. Therefore, checking Eq. (3) suffices to avoid recomputations of p."}, {"title": "3 Node Selection and Branching Rules", "content": "In Algorithm 1, we have two important degrees of freedom: the node selected for processing in Line 4 and the branching decision in Line 24. It is well known in the SAT and MIP communities that selecting the right node to branch on has a significant impact on the size of the search tree [34, 24]. Variable choices for branching are referred to as branching rules [34] in the MIP community and as variable selection heuristics [29] in the SAT community.\nIn the following, we recap various node selection and branching rules from both communities and adapt them for the LCSP. In Section 5, we evaluate their performance."}, {"title": "3.1 Node Selection", "content": "Depth-first search (DFS) [35] selects a child of the current node. If there is none, it backtracks until a child is found. DFS aims to quickly improve the primal bound as feasible solutions are usually more likely to appear deep in the B&B tree [36] but neglects to consider improvements to the dual bound. For pure feasibility problems, as, e.g. SAT, it is hence the preferred strategy [24, 34].\nIn B&B trees for MIP, the (LP) subproblem in a node differs only little from the one in the node's parent node. Using DFS node selection hence allows for an especially efficient resolving of the subproblem [34]. If a dynamic shortest path is used in Line 18, a similar effect may appear for the LCSP.\nMost-feasible search [37] focuses on primal improvements as well. In MIP solving, it selects the node with the smallest sum of fractional values in its LP solution. We adapt it for Algo- rithm 1 by choosing a node whose parent's shortest path solution violates the smallest number of clauses.\nBest-first search selects the node with the lowest dual bound first, aiming to improve the global dual bound. For a fixed branching order, best-first search (with appropriate tie-breaking)"}, {"title": "3.2 MIP-inspired Branching Rules", "content": "MIP branching rules choose a variable among the fractional variables in the current LP solution. For the LCSP, this corresponds to choosing an unassigned variable that is part of a conflict. Classical rules are strong branching [41] and pseudocost branching [40] as well as combinations thereof, for example reliability branching [34]. The current state-of-the-art [42, 43], hybrid branching [44], extends reliability branching with domain reduction rules and conflict-based variable scoring. Pseudocost branching and its derivatives rely on a measure of fractionality of individual variables in an LP solution. They are therefore not applicable for the LCSP. Instead, we will focus on strong branching. In full strong branching, we consider all variables contained in a conflict. Let Tup(x) := T\u222a {x} and Tdown(x) := T\u222a {\u00acx} be the up and down branches for any such variable x. In Algorithm 1, after performing unit propagation (Line 8), enforcement (Line 11), and the shortest path search (Line 18), we either derive infeasibility or find two paths pup and Pdown. For i \u2208 {up, down}, we let i := w(pi) \u2013 w(p) with w(pi) := \u221e in case of infeasibility. We select the branching variable using the product rule [34]\n$\\text{score} (x) = \\max (\\epsilon, \\gamma_{\\text{up}}) \\max (\\epsilon, \\gamma_{\\text{down}}).$ (5)\nThe parameter \u20ac > 0 avoids the score collapsing to zero if no improvement was made in one branch. Full strong branching results in small search trees at the expense of computing additional subproblems to compute Yi, usually resulting in a slower overall search [45]. Therefore, strong branching with working limits [34] stops evaluating variables if no improvement to the score has been made after L (1 - \u00a7) evaluations [43, 46]. Here, L is called the look-ahead parameter, and \u00a7 is the fraction of uninitialized unsolved nodes in the conflict. MIP solvers usually also limit the number of Simplex iterations [34], which is not applicable here."}, {"title": "3.3 SAT-inspired Branching Rules", "content": "Nowadays, SAT variable selection appears to be studied exclusively for CDCL solvers, where the best rules all are based on learned clauses [24]. These rules are often derived from the variable state independent decaying sum rule (VSIDS) [24], first introduced with the solver Chaff [27]."}, {"title": "4 Application: Flight Planning Subject to Traffic Flow Restrictions", "content": "We discuss the Flight Planning Problem with Traffic Flow Restrictions as this paper's appli- cation of the LCSP. A projected airway network Dproj is a directed graph representing the two-dimensional projection of a 3-dimensional aircraft routing graph D\u00b3d. Vertices in Dproj cor- respond to coordinates on Earth. Thus, the distance between two vertices is well-defined as the great circle distance (gcd) between them. In flight planning, the distance between the departure and the destination airport is usually not an objective. However, commonly used objectives like the fuel consumption or the duration correlate with the flight's distance.\nThe (implicit) routing graph D\u00b3d is obtained by copying Dproj in every flight level. A flight level is an altitude at which commercial aircraft are allowed to cruise between vertices that are adjacent in Dproj. The set of available flight levels L is part of our dataset."}, {"title": "4.1 Dynamic Shortest Path Search", "content": "We solve the SP-relaxations (Dproj, s, t) using a variant of the Lifelong Planning A* algorithm (LPA*) [13]. LPA* is a dynamic shortest path algorithm combining A* search [50] with ideas from the Dynamic-SWFP algorithm [10]. We tailor the algorithm to the specific structure of airway networks.\nFor the FPP with real aircraft performance functions, appropriate heuristics for A* are available in the literature [8]. Using our simplified aircraft model, we define the heuristic h(v) for a vertex v \u2208 V(D3d) as an underestimator of the fuel consumption of reaching the target from v. It is calculated based on the great circle distance between v and the target, assuming the optimal flight level.\nLPA* maintains two labels for each vertex in v \u2208 V(D3d) , a distance estimate d(v) and a look-ahead estimate rhs(v) := arg minues- (v) d(u) + Wuv. A vertex v \u2208 V(D3d) is inconsis- tent if d(v) = rhs(v). An inconsistent vertex is overconsistent if d(v) > rhs(v) and under- consistent otherwise. LPA maintains a priority queue of inconsistent vertices v ordered by min(d(v), rhs(v)) + h(v).\nLet To,..., Tr be the sequence of assignments in order of their extraction from the queue in Line 5 of Algorithm 1. The invocation of LPA* on Gr, is equivalent to an A* search.\nEach subsequent search on GT\u2081, 0 < i < r then begins with an initialization phase. First, we record the symmetric difference D of A(GT-1) and A(GT.). For each arc (u, v) \u2208 D, we update the value rhs(v). All pairs that become inconsistent by this operation are added to the priority queue (of LPA*).\nDuring the main phase of LPA*, inconsistent vertices v are extracted from the priority queue of LPA*. If v is overconsistent, its distance label d(v) is set to rhs(v). If it is underconsistent, it is set to \u221e. Then, rhs(u) is updated for all u in the out-neighborhood of v. If v was overcon- sistent, we only need to compute min(rhs(u), d(v) + wvu) to obtain the new value of rhs(u).\nOtherwise, however, the recomputation requires the full iteration over the in-neighborhood of u.\nThe graph D\u00b3d is characterized by large neighborhoods: The in-neighborhood d\u207b(u) of u = (u, l) \u0454 V(D3d) is of size Ld\u207b(u). In our data set, we have L = 181 flight levels. Moreover, there is no guarantee that the distance labels of vertices in d\u207b(u) are correct when rhs(u) is calculated and rhs(u) might be recomputed many times before it reaches its correct value.\nTi-1\nWe avoid this issue by modifying a trick that Bauer and Wagner [14] adapted from Nar- vaez et al. [12] for Dynamic-SWFP [10]. Let B be the shortest path tree calculated in Dad1 in the i 1'th invocation of LPA*. In the initialization phase, for any deleted arc (u, v) e A(D)\\A(D) with (u, v) \u2208 B, we identify the subtree B' of B rooted at v. For each u\u2208 \u0392', we set the distance label d(u) to infinity. In a second step, we recompute rhs(v) for all v for which d(v) was set to infinity. In contrast to Bauer and Wagner [14], we do not propagate inserted arcs along the search tree. With these changes, each vertex's in-neighborhood is iter- ated at most once, namely in the initialization phase, and in the main phase only overconsistent vertices are encountered."}, {"title": "5 Computational Experiments", "content": "In the following, we evaluate the branching and node selection rules from Section 3 on a real- world airway network and TFR system obtained from our industry partner Lufthansa Systems GmbH. All input data and experimental results from this section are available in the supple- mentary material [51]. Real aircraft performance functions are not part of our dataset. Instead, we use an artificial aircraft model described in Section 5.2."}, {"title": "5.1 Input Data", "content": "Our 2d airway network Dproj has 138923 vertices and 962145 arcs covering the whole globe. Together with 181 available flight levels at different altitudes, the 2d airway network defines an implicit 3d airway network D3d with roughly 25 million vertices and 51 billion arcs. Due to the network's large size, we only keep Dproj in storage and create only necessary parts of D3d on the fly.\nOur TFR system consists of 18238 TFRs from our industry partner's system, that were active at some point during the 24 hours after February 22, 2022 22:00, which is the departure time of all flights in our experiments. The latest TFRs are also published by Eurocontrol [52].\nFor each s, t-pair, we compute a fuel consumption minimal trajectory in a subgraph of D3d in which every vertex fulfills gcd(s,v) + gcd(v,t) \u2264 1.2gcd(s,t). All TFRs outside the resulting search space are dropped. Per s, t-pair, we thus considered a TFR system with on average 4615 restrictions on 9032 variables. After assigning arrival and departure variables, we applied the Tseitin transformation, resulting in a CNF formula with 15533 variables and 30964 clauses on average."}]}