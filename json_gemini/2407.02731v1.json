{"title": "Artificial intelligence and machine learning generated conjectures with TxGraffiti", "authors": ["Randy Davila"], "abstract": "TxGraffiti is a machine learning and heuristic based artificial intelligence designed to automate the task of conjecturing in mathematics. Since its inception, TxGraffiti has generated many surprising conjectures leading to publication in respectable mathematical journals. In this paper we outline the machine learning and heuristic techniques implemented by TxGraffiti. We also recall its contributions to the mathematical literature and announce a new online version of the program available for anyone curious to explore conjectures in graph theory.", "sections": [{"title": "1 Introduction", "content": "The ability of carefully designed computer programs to generate meaningful mathematical conjectures has been demonstrated since the late 1980s, notably by Fajtlowicz's GRAFFITI program [23]. Indeed, this heuristic-based program was the first artificial intelligence to make significant conjectures in matrices, number theory, and graph theory, attracting the attention of renowned mathematicians like Paul Erd\u0151s, Ronald Graham, and Odile Favaron. Inspired by the pioneering work of Fajtlowicz, and by interactions with mathematicians who considered conjectures of GRAFFITI, we developed the TxGraffiti program, a modern conjecturing artificial intelligence named in homage to this rich history of conjectures made by GRAFFITI and now available as an interactive website. While our program TxGraffiti draws inspiration from GRAFFITI and its successor Graffiti.pc by DeLaVi\u00f1a [19], it was developed independently and features several distinct design elements and conjecturing capabilities, which we detail in this paper.\nWhen discussing computer-assisted conjecturing, we remark that it is easy for a computer to generate many plausible conjectures. For example, one might gather a set of mathematical objects and test various functions applied to these objects to identify potential relationships (inequalities). If a relationship holds across all objects in the database, it becomes a plausible conjecture. For instance, given a database of graphs and the ability to compute various parameters on said graphs, a computer might quickly discover the relation:\n$\\alpha(G) \\leq n(G)$,\nwhere $\\alpha(G)$ is the independence number (the cardinality of a maximum set of pairwise non-adjacent vertices in $G$) and $n(G)$ is the order (the number of vertices in $G$). A more refined bound for $\\alpha(G)$ in nontrivial, connected graphs is:\n$\\alpha(G) \\leq n(G) \u2013 1$.\nBoth inequalities 1 and 2 hold under specific conditions, and TxGraffiti is designed to consider various hypotheses to form such conjectures. The mechanism for considering different hypotheses is a heuristic called Theo, detailed in Section 3.\nTo discover relationships like inequalities 1 and 2, TxGraffiti employs a machine learning, data-driven approach using linear optimization methods. This approach allows the program to find optimal parameters $m, b \\in R$ for example conjecturing on $\\alpha(G)$ in terms of another graph invariant, say $i(G)$, presenting conjectures in the form:\nBy integrating machine learning techniques with the Theo and Dalmation heuristics (see Section 2), TxGraffiti generates novel conjectures suitable for publication in mathematical journals. In Section 2, we discuss the historical development of AI-assisted conjecturing and relevant techniques. Section 3 details TxGraffiti's implementation, Section 4 presents conjectures produced by TxGraffiti that have led to mathematical publications, and Section 5 provides concluding remarks."}, {"title": "2 Related Work", "content": "In 1948, Turing proposed that intelligent machines could be a significant asset in mathematical research, requiring substantial intelligence while involving \"minimal interaction with the external world\u201d [33]. Following this vision, early work in computer-assisted mathematics includes Newell and Simon's Logic Theorist program developed in the 1950s. This program was capable of proving some theorems in first-order logic, and they boldly predicted that a computer would eventually discover and prove a crucial mathematical theorem [32]. This program, among others, focused heavily on theorem proving, including a notable achievement in 1996 being the computer proof of the Robbins Conjecture [30]."}, {"title": "3 Methodology", "content": "In designing a computer program that generates mathematical conjectures, the first requirement is a database of mathematical objects. In the case of TxGraffiti, these objects are edge lists of simple connected graphs. It is crucial to underscore the importance of data quality. An extensive database is optional for the computer to identify non-trivial relationships among object properties. Instead, what is needed is a collection of unique instances of the objects in question, such as special counter-examples or interesting families of graphs from the literature. In our implementations, we utilized databases of several hundred objects, though we have also experimented with thousands with little to no meaningful returns in conjecture quality."}, {"title": "3.1 Feature Generation", "content": "After a collection of mathematical objects is collected, the next step in the design of TxGraffiti is to generate a table (a csv file representing a database) of various precomputed functions on the objects in this database. Our framework mandates that at least two of these functions return numerical values (for pairwise comparison), while others can return numerical or Boolean values. See Figure 1 for an illustration of this process; numerical properties are denoted by Pi, and Boolean properties are denoted by Hi.\nIndeed, once a table of data like the one is available, TxGraffiti may conjecture on the data; regardless if the data represents graph object data. Thus, if one were to generate conjectures on different types of data, one would first create such a table and then implement the steps in the following subsections."}, {"title": "3.2 Inequality Generation", "content": "In this section, we propose and implement a simplified version of the following steps for a computer program to generate inequalities relating properties of the objects under consideration, with an emphasis on conjecture simplicity and on conjecture strength.\n1. Select a target property Pi a precomputed and numerically valued function on the objects in the database.\n2. Choose an inequality direction (upper or lower) to bound the property Pi.\n3. For each precomputed numerical function $P_j$, with $j \\neq i$, use a supervised machine learning technique or linear program to find a function $f$ such that $P_i(O) \\leq f((P_j(O))$ holds for each object $O$ in the database, and the number of instances where the inequality is an equality is maximized.\n4. If $P_i(O) \\neq f((P_j(O))$ for all objects $O$ in the database, disregard $f$ as a conjectured upper (or lower) bound on $P_i$. Otherwise, $f$ is called a sharp bounding function; store $f(P_j)$ as a conjectured upper (or lower) bound on $P_i$ and record the set of objects $O$ where $P_i(O) = f(P_j(O))$; the size of this set is the touch number of the conjecture.\nTxGraffiti follows these steps at each instance of a user requesting a desired conjecture, with conjectured upper and lower bounds computed automatically through linear programming formulations. For example, consider producing one conjectured upper bound on $P_i(O)$ in terms of another numerical valued function $P_j(O))$. This is achieved by solving a linear optimization problem, and in the simplest case, TxGraffiti aims to minimize a some linear function $f(m, b)$ subject to a set of constraints.\nminimize     $f(m,b)$\nsubject to $P_i(O) \\leq mP_j(O) + b,\\forall O \\in Database$,"}, {"title": "3.3 Sorting and Filtering", "content": "Once the optimal bounding functions for a given target invariant are found, we are left with a list of possible conjectures, along with detailed data for each conjecture. This data includes the set of objects that satisfy the conjecture's hypothesis, the graphs that attain equality, and the count of these graphs. At this point, our program implements a sorting procedure. That is, the list of conjectures is then sorted in nonincreasing order with respect to the touch number of the conjectures. Thus, the conjectures at the top of the list hold with equality more than the conjectures towards the bottom of the list. Thus, this sorting aspect implemented by our program insures the conjectures at the top of the list are \"stronger\" than those at the bottom of the list.\nAfter the conjectures have been sorted according to their respective touch numbers, our program then implements the first of two filtering heuristics, called Theo.\nThis heuristic checks if any proposed inequality relation appears more than once in the list of conjectures, and then only selects the proposed conjectures with this inequality that have the most general hypothesis statement. For example, consider the following two conjectures.\n$\\alpha(G) \\leq \\mu(G)$,\nand this bound is sharp.\n$\\alpha(G) \\leq \\mu(G)$,\nand this bound is sharp.\nThe Theo heuristic would automatically detect that the inequality $\\alpha(G) \\leq \\mu(G)$ appears in both Conjecture 2 and in Conjecture 3, and thereafter, check if the set of graphs in the database that satisfy the hypothesis of Conjecture 2 also satisfy the hypothesis of Conjecture 3. Since every cubic graph is also a regular graph, but not vice versa, Theo would remove Conjecture 2 from the possible conjectures to present to the user. The reasoning for this heuristic is to put more emphasize on the more general conjecture, and thus, remove any conjecture that may follow from a more general statement.\nThe list of conjectures is (optionally) further filtered by a variation of the Dalmatian heuristic which we call Dalmation-static. Unlike the original Dalmation heuristic used by GRAFFITI [24], our version of Dalmation takes as input a static list of conjectures and works as following:"}, {"title": "Dalmation-Static Heuristic:", "content": "1. Let G be the set of graphs attaining equality in Conjecture 1 in the current list of conjectures, recalling that the conjectures are sorted according to their respective touch number.\n2. For i = 2,..., N, if the set of graphs attaining equality in Conjecture i does not contain a which is also graph not contained in G, then remove Conjecture i from the list of conjectures, otherwise, let G = GUGi, where Gi is the set of graphs attaining equality in Conjecture i.\nFinally, the conjectures are further filtered by removing any known conjectures. This aspect of TxGraffiti requires maintenance and is one area where the program would benefit from many mathematicians contributing to. Moreover, since conjectures are computed at each prompt to the program, anytime a new counter-example is added to the database, new conjectures appear. This aspect motivated further development of the program, where users may enter in counter-examples to better the conjectures of the program. This functionality is available by emailing the author via the online website, but will in the future allow for a more straight-forward approach.\nThe resulting set of conjectures is a set of conjectures that can be viewed as \"mathematical strong\". That is, the linear optimization methods first find proposed inequalities that are guaranteed to be sharp on a maximum number of graph instances, thereafter, the Theo heuristic insures generality of the hypothesis for a conjectures inequality, then the Dalmation-static heuristic insures presented conjectures only consist of inequalities providing \"new\" information, and finally the touch number sorting insures conjectures at the beginning of a list are sharper than ones that follow. In the following section we demonstrate how these processes show promise for new mathematical insight in the realm of graph theory."}, {"title": "3.4 Code and Reproducibility", "content": "For readily available examples of this process, see the GitHub repository associated with the interactive website [12]."}, {"title": "4 Results", "content": "In this section we present some results stimulated by conjectures of TxGraffiti. More specifically, we highlight the following results inspired by conjectures of TxGraffiti and listed in Table 1. Of the results listed in Table 1, we now focus on the result pertaining to the independence number and matching number of regular graphs. The originial conjecture that stimulated this result states that for any 3-regular and connected graph G, the independence number $\\alpha(G)$ is at most the matching number $\\mu(G)$.\nIf G is a connected and cubic (3-regular) graph, then\n$\\alpha(G) \\leq \\mu(G)$,\nwhere $\\alpha(G)$ is the independence number and $\\mu(G)$ is the matching number.\nNotably, Conjecture 4 relates three of the oldest studied properties in graph theory; namely, independent sets, matching sets, and regular graphs. For this reason, the author did not share Conjecture 4 for many months, believing it to be trivial known. However, once shared with collaborators, it became apparent that not only was this conjecture not known in the literature, but was also true. Indeed, this conjecture was then generalized and proven, resulting in the following theorem; the proof of which appears in [6], but is also given below to demonstrate this simple and meaningful result.\n(Caro et al. [6]). If G is an r-regular graph with r > 0, then\n$\\alpha(G) \\leq \\mu(G)$,\nand this bound is sharp.\nLet G be an r-regular graph with r > 0. Let $X \\subseteq V(G)$ be a maximum independent set, and let $Y = V(G) \\setminus X$. By removing edges from G that have both endpoints in Y, we form a bipartite graph H with partite sets X and Y.\nSince the removed edges were only those with both endpoints in Y, any vertex in X will have the same open neighborhood in H as it does in G. Given that G is r-regular and X is an independent set, each vertex in X will have exactly r neighbors in Y.\nLet $S \\subseteq X$ be chosen arbitrarily, and let $e(S, N_H(S))$ denote the number of edges from S to $N_H(S)$. Since each vertex in S has exactly r neighbors in Y, it follows that $e(S, N_H(S)) = r|S|$. Additionally, since each vertex in $N_H(S)$ has at most r neighbors in X, we also have $e(S, N_H(S)) \\leq r|N_H(S)|$. Thus, $r|S| \\leq r|N_H(S)|$, implying that $|S| \\leq |N_H(S)|$. By Hall's Theorem; see West [35], there exists a matching M that can match X to a subset of Y. Since X is a maximum independent set and M is also a matching in G, we conclude that $\\alpha(G) = |M| \\leq \\mu(G)$, proving the theorem.\nNotably, by confirming Conjecture 2 with Theorem 5, we were inspired to include the more general hypothesis of regular graphs in conjectures presented by TxGraffiti, and this resulted in the more general statement of Theorem 5 being presented as a conjecture by the program. From an application point of view, the resulting theorem due to Conjecture 2 is further interesting since the computation of the matching number $\\mu(G)$ is computable in polynomial time, whereas the computation of the independent number $\\alpha(G)$ is NP-hard. Thus, the resulting theory gathered from investigating Conjecture 2 has practical applications in graph theory and the sciences."}, {"title": "5 Conclusion", "content": "In this paper, we have described the artificial intelligence program TxGraffiti and also provided evidence for its usefulness in mathematical research as its conjectures span various areas of graph theory; many leading to significant publications. Moreover, we provide a new web-based interaction for TxGraffiti which may lead to even further mathematical insight. We anticipate that further development and application of the ideas underpinning TxGraffiti will lead to further insights into computer assisted mathematics."}]}