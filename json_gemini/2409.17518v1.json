{"title": "Multi-Designated Detector Watermarking for Language Models", "authors": ["Zhengan Huang", "Gongxian Zeng", "Xin Mu", "Yu Wang", "Yue Yu"], "abstract": "In this paper, we initiate the study of multi-designated detector watermarking (MDDW) for large language models (LLMs). This technique allows model providers to generate watermarked outputs from LLMs with two key properties: (i) only specific, possibly multiple, designated detectors can identify the watermarks, and (ii) there is no perceptible degradation in the output quality for ordinary users. We formalize the security definitions for MDDW and present a framework for constructing MDDW for any LLM using multi-designated verifier signatures (MDVS). Recognizing the significant economic value of LLM outputs, we introduce claimability as an optional security feature for MDDW, enabling model providers to assert ownership of LLM outputs within designated-detector settings. To support claimable MDDW, we propose a generic transformation converting any MDVS to a claimable MDVS. Our implementation of the MDDW scheme highlights its advanced functionalities and flexibility over existing methods, with satisfactory performance metrics.", "sections": [{"title": "1 Introduction", "content": "Generative artificial intelligence (AI) technique, e.g., large language models (LLMs), has been widely adopted in the field of language generation and has achieved excellent performance in a variety of downstream tasks. These tasks span from machine translation [HAS+23], dialogue system [HD23] to code generation [NIR+23] and medicine [TTE+23].\nHowever, the abuse of LLMs may lead to several potential harms, including the generation of fake news [HS24] and instances of academic dishonesty, such as cheating on writing and coding assignments [KGW+23]. Another potential risk is that the proliferation of data fabricated by LLMs complicates the acquisition of superior models, as this data is not sourced from the real world and has to be excluded before training [RKX+23].\nThus, a crucial challenge lies in distinguishing between texts generated by LLMs and those written by humans."}, {"title": "2 Preliminaries", "content": "Notations. We assume that the security parameter Ais an (implicit) input\nto all algorithms. For any n \u2208 N, let [n] := {1,2,\u2026,n}. For a finite set S,\nlet |S| denote the number of elements in S, and x \u2190 S denote the process of\nsampling x from S uniformly at random. For a distribution Dist, we use x \u2190 Dist\nto denote the process of sampling x from Dist. A function f of A is negligible if\nf\u2208 O(poly(x)) for any polynomial poly(.). For simplicity, we write f(x) \u2264 negl(x)\nto mean that f is negligible. Throughout this paper, let denote the empty list\nor empty string.\nFor a random variable X, the min-entropy H\u221e(X) is \u2013 log(maxx Pr[X = x]).\nLet alb denote the tail-to-head concatenation of a and b. In a bit string a,\na\u017c represents the ith bit of a, unless indicated otherwise.\nThroughout this paper, bold lower-case letters denote vectors or sequence of\ntokens, e.g., t = (t1, ..., t|t|) is a |t|-dimension vector, and usually the number of\ndimensions can be inferred from the context. For a vector or sequence of tokens\nt, let t[i] denote the ith element of (t1,\u2026\u2026,t|t|), and t[-i] denote the ith last\nelement of (t1,\u2026\u2026,t\t\\). For i < j, t[i : j] denotes (ti,ti+1,\u2026, tj), and t[-i :]\ndenotes the last i elements of (t1,\u2026\u2026, t|t|). We sometimes adapt these notations\nto bit strings, such as a [1] and a[i]."}, {"title": "2.1 Language models", "content": "We follow [KGW+23,CGZ24,FGJ+23] in our definition of a language model, and\nrefer to language models simply as models in this paper.\nDefinition 1 (Auto-regressive model). An auto-regressive model Model over\ntoken vocabulary T is a deterministic algorithm that takes as input a prompt\np\u2208T and tokens previously output by the model t \u2208 T and outputs a probability\ndistribution p = Model(p, t) over T.\nFor all l\u2208 N, GenModele wraps around Model to implement a generative\nmodel. GenModele iteratively generates l tokens. Decode is the specific decoding\nmethod, e.g., argmax."}, {"title": "2.2 Multi-designated verifier signature", "content": "We recall the definition of multi-designated verifier signature (MDVS) from\n[DHM+20,MPR22], with some adjustments.\nAn MDVS scheme, associated with message space M, is a tuple of algorithms\nMDVS = (Setup, SignKG, VerKG, Sign, Verify), where\n\u2022 Setup(1) \u2192 pp: On input the security parameter A, the setup algorithm\noutputs a public parameter pp.\n\u2022 SignKG(pp) \u2192 (spk, ssk): On input pp, the signing key generation algorithm\noutputs a public key spk and a secret key ssk for a signer.\n\u2022 VerKG(pp) \u2192 (vpk, vsk): On input pp, the verification key generation algorithm\noutputs a public key vpk and a secret key vsk for a verifier.\n\u2022 Sign(pp, sski, {vpkj}jes,m) \u2192 \u03c3: On input pp, a signing secret key sski, pub-\nlic keys of the designated verifiers {vpk;}jes, and a message m, the signing\nalgorithm outputs a signature \u03c3.\n\u2022 Verify(pp, spk\u012f, vskj', {vpkj}jes, m, \u03c3) \u2192 b: On input pp, a signing public key\nspk, a secret key vsk; of a verifier such that j' \u2208 S, public keys of the\ndesignated verifiers {vpkj}jes, a message m, and a signature \u03c3, the verification\nalgorithm outputs a bit b \u2208 {0,1}."}, {"title": "3 Multi-designated detector watermarking", "content": "In this section, we introduce a primitive called multi-designated detector water-\nmarking (MDDW), and formalize its security notions.\nAn MDDW scheme for an auto-regressive model Model over token vocabulary\nTis a tuple of algorithms MDDW = (Setup, WatKG, DetKG, WatMar, Detect),\nwhere\n\u2022 Setup(1\u5165) \u2192 pp: On input the security parameter A, the setup algorithm\noutputs a public parameter pp.\n\u2022 WatKG(pp) \u2192 (wpk, wsk): On input pp, the watermarking key generation al-\ngorithm outputs a public/secret key pair (wpk, wsk) for watermarking.\n\u2022 DetKG(pp) \u2192 (dpk, dsk): On input pp, the detection key generation algorithm\noutputs a public/secret key pair (dpk, dsk) for a detector.\n\u2022 WatMar(pp, wski, {dpkj}jes, p) \u2192 t: On input pp, a watermarking secret key\nwski, public keys of the designated detectors {dpk;}jes, and a prompt p \u2208 T,\nthe watermarking algorithm outputs t \u2208 T."}, {"title": "4 MDDW construction", "content": "In this section, we present a framework for building MDDW from MDVS and\ndemonstrate its fulfillment of the required security properties. Additionally, we\nshow that if the underlying MDVS scheme is off-the-record for any subset, the\nconstructed MDDW also achieves the off-the-record property for any subset.\nFurthermore, by introducing the notion of claimability for MDVS, we demon-\nstrate that our generic MDDW scheme achieves claimability when the underlying\nMDVS scheme possesses this property. Finally, we provide a generic method for\nconstructing claimable MDVS by showing a transformation that converts any\nMDVS scheme into one that is claimable."}, {"title": "4.1 Generic construction of MDDW", "content": "Let MDVS = (MDVS.Setup, SignKG, VerKG, Sign, Verify) be an MDVS scheme\nwith signature length lensig. Let M denote the message space of MDVS, and SG\ndenote the signature space of MDVS. Let H\u2081 : {0,1}* \u2192 M, H2 : {0,1}* \u2192 SG\nand H3: {0,1}* \u2192 {0, 1} be hash functions, which will all be modeled as random\noracles in the security proof.\nOur MDDW scheme MDDWn,l,lensig = (Setup, WatKG, DetKG, WatMar, Detect),\nfor some predefined parameters n and l, is as follows.**\n\u2022 Setup(1^): Compute pp \u2190 MDVS.Setup(1\u5165), and return pp as the public pa-\nrameter of MDDW.\n\u2022 WatKG(pp): Generate (spk, ssk) \u2190 SignKG(pp), and set wpk = spk and wsk =\nssk. Return (wpk, wsk).\n\u2022 DetKG(pp): Generate (vpk, vsk) \u2190 VerKG(pp), and set dpk = vpk and dsk =\nvsk. Return (dpk, dsk).\nNote that according to Assumption 1, any contiguous block of l tokens contains at\nleast a bits of min-entropy."}, {"title": "4.2 MDDW construction with claimability", "content": "To make the above generic MDDW scheme achieve claimability, the underlying\nMDVS scheme needs to meet some corresponding security property. However, to\nthe best of our knowledge, no claimability notion for MDVS has been introduced\nbefore. Here, we firstly introduce the notion of claimability for MDVS, and then\nformally prove that if the underlying MDVS scheme meets claimability, the above\ngeneric MDDW scheme is claimable.\nClaimability for MDVS. The notion of claimability for MDVS extends from\nthe established claimability concepts for ring signature [PS19] and designated-\nverifier signature [YHW+23]. It is crucial to emphasize that in this paper, claima-\nbility is defined as an optional requirement for MDVS."}, {"title": "4.3 Instantiation of claimable MDVS", "content": "To instantiate claimable MDVS (CMDVS), we show a transformation that con-\nverts any MDVS into a CMDVS, with the help of a standard digital signature, a\npseudorandom function and a commitment scheme. Our method is inspired by\n[PS19, YHW+23], where [PS19] shows how to construct claimable ring signature\nand [YHW+23] shows how to construct claimable DVS from ring signature.\nThe intuition of our method is as follows. To generate a CMDVS signature,\nthe signer firstly generates an MDVS signature MDVS with the signing algorithm\nof the underlying MDVS, signs OMDVS with the the standard signature scheme\nto obtain a standard signature osig, and then takes the commitment scheme to\ncommit osig, obtaining a commitment com. The generated CMDVS signature\nconsists of (MDVS, com). When making a claim, the signer just opens the com-\nmitment com, outputting osig and the randomness used to generate com. To\nverify the claim, one firstly checks if the opening is correct, and then checks\nif the standard signature is valid. The unforgeability of the standard signature\nscheme guarantees that the claim is indeed generated by the signer.\nThe detailed construction of CMDVS is as follows.\nLet MDVS = (Setup, SignKG, VerKG, Sign, Verify) be an MDVS scheme. Let\nSig = (Setup, KG, Sign, Verify) be a signature scheme, PRF = (KG, Eval) be a\npseudorandom function, and Commit = (Setup, Com, Decom) be a commitment\nscheme. The definitions of signature, pseudorandom function and commitment\nare given in Appendix B for completeness.\nOur CMDVS scheme CMDVS = (Setup, SignKG, VerKG, Sign, Verify, Claim,\nClmVer) is shown in Fig. 10."}, {"title": "5 Evaluation", "content": "In this experiment section, we evaluate our proposed scheme from the perspective\nof computational overhead. Specifically, we analyze the time required for text\ngeneration and watermark detection using three different LLMs. The details are\nas follows:\nSchemes. To highlight the performance of our scheme, we will implement the\nfollowing schemes."}, {"title": "HA more efficient DDW construction", "content": "In this section, we delve into a particular case within the MDDW framework,\nnamely DDW, characterized by the existence of only one designated verifier (i.e,\n|S| = 1). We propose a more efficient construction by leveraging a concrete DVS\nscheme."}, {"title": "H.1 DVS construction", "content": "The DVS scheme is shown in Fig. 16, which was firstly proposed in [LV05] and\nextended from [SBWP03].\nThe correctness is trivial, so we omit the analysis of it here. Since there is\nonly one designated verifier, we do not need to consider consistency and there\nis only one kind of off-the-record property. For the analysis of the existential\nunforgeability and off-the-record property, please refer to [SBWP03,LV05].\nIn addition, we will prove that the scheme supports pseudorandomness (please\nrefer to the definition in Sec. H.3). In other words, without the secret key of the\ndesignated verifier, it is difficult to distinguish the output of the DVS scheme\nwith a random string.\nThen, we have the following theorem.\nTheorem 6. If Ho and H\u2081 are collision resistant hash functions, the DVS scheme\nDVS above is existentially unforgeable, off-the-record and pseudorandom in the\nrandom oracle model, under the CBDH, DBDH and GBDH assumptions.\nWe postpone the proof of Theorem 6 to Appendix H.3. In fact, the DVS\nscheme in Fig. 16 supports pseudorandomness for free. Then, when constructing\nDDW using the framework in Sec. 4, we can eliminate some steps, which we will\nelaborate on later."}, {"title": "H.2 Some concrete DDWs and their comparison", "content": "Schemes. Here we will introduce some concrete DDWs.\nScheme I. In Sec. 4.1, we introduce a framework that shows how to construct a\nMDDW from a MDVS. When adopting the MDVS [AYSZ14], which is recalled\nin Appendix. C, and letting |S| = 1, we can obtain a DDW.\nScheme II. On the other hands, incorporating the DVS scheme shown in Fig. 16\ninto the MDDW framework in Sec. 4.1, we can obtain another DDW scheme.\nScheme III. Scheme III can be viewed as an improvement of Scheme II. We could\nfurther reduce the size of the DVS, when plugging it into our MDDW framework\nin Sec. 4.1. The details are as follows.\nIn Fig. 16, the DVS signature contains a random string rand a hash value s.\nWhen plugging the DVS into our framework, we can adopt the hash of previously\nsigned message (i.e., in DDW, the previously signed message could be the prompt\nor the some tokens just output by the model) to generate the random string r\ninstead. In this way, the signature could only contain a hash value s.\nIn addition, since the DVS supports pseudorandomness, we do not need to\nperform XOR computation of the signature and the tokens before sampling new\ntokens. More exactly, codes in Line 7 of Algorithm 14 and codes in Line 8 of\nAlgorithm 15 are removed. Then, the algorithms use the signature output by\nthe DVS directly to proceed the computation."}, {"title": "H.3 Proof of Theorem 6", "content": "As analysis in the aforementioned section, we omit the analysis of the ex-\nistential unforgeability and off-the-record property, since you can find it in\n[SBWP03,LV05]. Therefore, we only focus on the pseudorandomness here.\nDefinition of Pseudurandomness. The definition of pseudorandomness is as fol-\nlows.\nDefinition 22. (Pseudorandomness). We say that DVS is pseudorandom, if\nfor all PPT adversary A,\nAdvps\u2212rand\nDVS,A(\u03bb) = |Pr[GDVSps\u2212rand(\u03bb) = 1] \u2212 1/2| \u2264 negl(\u03bb),\nwhere GDVSps\u2212rand(\u03bb) defined in Fig. 17.\nProof for pseudorandomness. We prove the pseudorandomness in the random\noracle model, so we add a random oracle ORO, which inputs a string and outputs\na random string. We assume that every time calling signing algorithm Sign, Sign\nwould query str = e(vpkj, hssk) to the random oracle ORO, where h = Ho(m,r)."}]}