{"title": "Temporal Numeric Planning with Patterns", "authors": ["Matteo Cardellini", "Enrico Giunchiglia"], "abstract": "We consider temporal numeric planning problems II expressed in PDDL 2.1 level 3, and show how to produce SMT formulas (i) whose models correspond to valid plans of II, and (ii) that extend the recently proposed planning with patterns approach from the numeric to the temporal case. We prove the correctness and completeness of the approach and show that it performs very well on 10 domains with required concurrency.", "sections": [{"title": "Introduction", "content": "We consider temporal numeric planning problems expressed in PDDL 2.1 level 3 (Fox and Long 2003). Differently from the classical case, where plans are sequences of instantaneous actions and variables are Boolean, in these problems actions may have a duration, are executed concurrently over time, and can affect Boolean and numeric variables at both the start and end of their execution. These two extensions make the problem of finding a valid plan much more difficult -even undecidable in the general case (Helmert 2002; Gigante et al. 2022)\u2013 and extending state-of-the-art solving techniques from the classical/numeric to the temporal numeric setting is far from easy.\nIn this paper, we extend the recently proposed Symbolic Pattern Planning (SPP) approach (Cardellini, Giunchiglia, and Maratea 2024) to handle temporal numeric problems. Specifically, given one such problem II and a bound n \u2208 N\u22650, we show how to produce a Satisfiability Modulo Theory (SMT) formula (Barrett et al. 2021) (i) whose models correspond to valid plans of II (correctness), (ii) which is ensured to be satisfiable for some value of the bound n when II has a valid plan (completeness), and (iii) which is equivalent to the pattern encoding proposed by Cardellini, Giunchiglia, and Maratea when the problem is numeric, i.e., when all the actions are instantaneous. These results significantly advance the state-of-the-art, as all symbolic temporal numeric planners are based on the standard encoding with effect and explanatory frame axioms. Given this, we expect to obtain also in the temporal setting the substantial improvements achieved in the numeric case, where it\nwas shown (i) that the pattern encoding dominates (i.e., is able to produce valid plans with a bound n possibly lower and never higher than) both the relaxed-relaxed R2\u2203 encoding (Balyo 2013; Bofill, Espasa, and Villaret 2017), and the action rolling R encoding (Scala et al. 2016b); (ii) that both the R2 and R encodings dominate the standard one, and (iii) that theoretical dominance leads to improved experimental performance, as shown by the analysis in (Cardellini, Giunchiglia, and Maratea 2024) on the numeric benchmarks of the 2023 International Planning Competition.\nTo test the effectiveness of our approach, we compare our planner with all publicly available temporal planners (both symbolic and based on search) on 10 temporal domains with required concurrency (Cushing et al. 2007). The results highlight the strong performances of our planner, which achieved the highest coverage (i.e., number of solved problems) in 9 out of 10 domains, while the second-best planner had the highest coverage in 4 domains. Additionally, compared to the other symbolic planners, our system is able to find a valid plan with a lower bound on all the problems.\nThe main contributions of this paper are thus:\n1. We extend the SPP approach to handle temporal numeric problems specified in PDDL 2.1.\n2. We prove the correctness and completeness of our SMT encoding.\n3. We conduct an extensive comparative analysis with all available temporal numeric planners, both search-based and symbolic-based, and show that our approach achieves the highest coverage in 9 out of 10 domains.\nAfter the preliminary definitions, we present the basic ideas underlying current standard encodings in SMT, followed by the presentation of our approach, the experimental comparative analysis and the conclusions. A running example is used to illustrate the features of our encoding."}, {"title": "Preliminaries", "content": "In PDDL2.1 (Fox and Long 2003) a temporal numeric planning problem is a tuple II = (VB, VN, A, I, G), where\n1. VB and VN are finite sets of Boolean and numeric variables, ranging over {T, \u22a5} and Q respectively,\n2. I is a selected initial state, and a state is a function mapping each variable to an element in its domain,\n3. G is a finite set of conditions, called goals. A condition is either v = T or v = \u22a5 or \u03c8 \u25b7 0, with v \u2208 VB, \u03c8 a linear expression in VN and \u25b7 \u2208 {<, \u2264, =, >, \u2265}.\n4. A is a finite set of (instantaneous/snap) actions and durative actions. An action a is a pair (pre(a), eff(a)) in which (i) pre(a) are the (pre)conditions of a, and (ii) eff(a) are the effects of a of the form v := T, v := \u22a5, x := \u03c8, with v \u2208 VB, x \u2208 VN and \u03c8 a linear expression in VN. For each action a, every variable v \u2208 VB\u222a VN must occur in eff(a) at most once to the left of the assignment operator \u201c:=\", and when this happens v is said to be assigned by a. A durative action b is a tuple (b+, bH, b\u22a5, [L, U]), where b+, b\u22a5, bH are the actions starting, lasting and ending b, respectively, and L,U \u2208 Q> are bounds on the duration d of b, L \u2264 U. The action bH has no effects, and its preconditions pre(bH) must hold throughout the execution of b. From here on, for simplicity, we consider only durative actions, as snap actions can be treated as durative actions without lasting and ending actions, as in (Panjkovic and Micheli 2023).\nLet II = (VB, VN, A, I, G) be a temporal numeric planning problem. A timed durative action is a pair (t, b) with t\u2208 Q\u22650 and b a durative action (b+, bH, b\u22a5, [L, U]) in which [L, U] is replaced with a single duration value d \u2208 [L, U]: t (resp. t + d) is the time in which b+ (resp. b\u22a5) is executed. A temporal (numeric) plan \u03c0 for II is a finite set of timed durative actions. Thus, in \u03c0, multiple snap actions can be executed at the same time, but any two such actions a and a' must be non mutex, i.e., a must not interfere with a', and vice versa. An action a does not interfere with an action a' if for every variable v assigned by a\n1. v does not occur in the preconditions of a', and\n2. if v \u2208 VB, either v is not assigned by a' or v := T \u2208 eff (a) if and only if v := T \u2208 eff (a'), and\n3. if v \u2208 VN then either v does not occur in the effects of a' or the only occurrences of v in both a and a' are within linear increments of v. An expression v := v + \u03c8 is a linear increment of v if v does not occur in \u03c8.\nIf a and a' are not in mutex, the order in which they are executed in any state s is not relevant, i.e., res(a, res(a', s)) = res(a', res(a, s)). The expression res(a, s) is the result of executing a in state s, which (i) is defined when s satisfies the preconditions of a, and (ii) is the state s' = res(a, s) such that for each v \u2208 VB UVN, s'(v) = e if v := e \u2208 eff(a), and s'(v) = s(v) otherwise. Given a set A = {a1,..., an} of pairwise non mutex actions, we write res(A, s) as an abbreviation for res(a1,...,res(an, S)...), order not relevant.\nConsider a temporal plan \u03c0. The execution of \u03c0 induces a sequence of states s0, s1; . . . ; sm, each state si with an associated time ti > ti\u22121 at which a non empty set Ai of actions, each starting/ending a durative action in \u03c0, is executed. The temporal plan is valid if:\n1. s0 is the initial state, si+1 = res(Ai+1, si) and sm satisfies the goal formulas, with i \u2208 [0, m);\n2. \u03f5-separation: for any pair of mutex actions a \u2208 Ai and a' \u2208 Aj, |ti \u2212 tj| \u2265 \u03f5 > 0 (and thus i \u2260 j);\n3. no self-overlapping: for any two distinct timed durative actions (t, b) and (t', b) with durations d and d' respectively, if t' > t in \u03c0, then t' > t + d;\n4. lasting-action: for each timed durative action \u27e8t, \u27e8b+, bH, b\u22a5, d\u27e9\u27e9 in \u03c0, if b+ and b\u22a5 are executed at ti = t and tj = ti + d respectively, the preconditions of bH are satisfied in each state si,..., Sj\u22121.\nWe thus considered the standard notion of validity used, e.g., in (Fox and Long 2003; Rankooh and Ghassem-Sani 2015; Haslum et al. 2019; Panjkovic and Micheli 2024), in which, assuming VN = 0, the problem of deciding the existence of a valid temporal plan is in PSPACE. Other, more general definitions of plan validity can be given, relaxing the second condition to allow for |ti - tj| > 0 and/or removing the third condition. With such generalizations, the complexity of deciding the existence of a valid temporal plan, still with VN = 0, can become EXPSPACE-complete (Rintanen 2007) and can even become undecidable (Gigante et al. 2022).\""}, {"title": "Standard Encodings in SMT", "content": "Several approaches for computing a valid plan of II have been proposed, either based on search (see, e.g., (Benton, Coles, and Coles 2012; Gerevini, Saetti, and Serina 2010; Eyerich, Mattm\u00fcller, and R\u00f6ger 2012)) or on planning as satisfiability (see, e.g., (Shin and Davis 2004, 2005; Rankooh and Ghassem-Sani 2015; Rintanen 2015; Cashmore et al. 2016; Rintanen 2017; Cashmore, Magazzeni, and Zehtabi 2020; Panjkovic and Micheli 2023, 2024)). We follow the second approach, in which (i) a bound or number of steps n (initially set to 0) is fixed, (ii) a corresponding SMT formula is produced, and (iii) a valid plan is returned if the formula is satisfiable, while n is increased and the previous step iterated, otherwise. In more detail, given a temporal numeric planning problem II = (VB, VN, A, I, G) and a value for the bound n \u2265 0, in the second step, these works:\n1. Make n + 1 copies of a set X of state variables which includes VB\u222aVN, each copy Xi meant to represent the state at the i-th step; make n copies of a set A of (Boolean) durative action variables which includes A, each copy Ai meant to represent the durative actions executed at the i-th step; and introduce a set {t0, . . ., tn} of time variables, each ti being the time associated to the i-th state Xi.\n2. Impose proper axioms defining the value of the variables in Xi+1 based on the values of the variables in Xi, and of the snap actions which are executed in the state Xi. In particular, these axioms enforce in the state Xi+1 the effects of the actions executed in the state Xi, and also that no two mutex actions are executed in Xi.\nA similar construction underpins also the standard encoding used for classical and numeric planning problems. However, in these contexts, the standard encoding is known to underperform compared to the R encoding by Scala et al. (2016b), the R2\u2203 encoding by Bofill, Espasa, and Villaret (2016), and the pattern \u4eba-encoding by Cardellini, Giunchiglia, and Maratea (2024). Indeed, at each step i \u2208 [0, n),\n1. in the R encoding, each action variable can be \"rolled-up\" taking a value in N\u22650 representing how many times\nthe action is consecutively executed,\n2. the R2\u2203 encoding allows for the execution of actions in mutex and/or with contradictory effects, and\n3. the \u4eba-encoding allows for the consecutive execution of actions, even if in mutex and with contradictory effects.\nAs a consequence, the \u4eba-encoding dominates the R2\u2203 and R encodings, which in turn dominate the standard encoding. This dominance usually leads to better performance, as the number of solver calls, along with the number of variables and the encoding size, all increase linearly with the bound n. To highlight the potential benefits of moving from the standard encoding to the \u4eba-encoding also in the temporal numeric setting, consider the following simplified version of the bottle example from (Shin and Davis 2005).\nExample. There is a set {1, . . ., q} of bottles, the first p of which containing li litres of liquid (i \u2208 [1, p]), and the action prij of pouring from the i-th bottle (with effects at start) in [1,p] into the j-th bottle in (p,q] (with effects at end), one litre every di,j seconds. In the current encodings, each prij is Boolean and thus can be executed at most once in between two consecutive states. Further, time variables are associated to the states. For these reasons, with a current encoding S, the goal of emptying the bottles in [1,p] needs a number of steps n \u2265 \u2211ip=1 li, how many depending also on the specific di,j values since each executed pri,j can start/end at a different time from the others. Further, \u0160 needs at least n = \u2211ip=1li steps when q = p + 1, due to the conflicting effects of pouring to a single bottle.\nDespite the apparent complexity introduced by the temporal aspects, (Cushing et al. 2007) demonstrated that these problems are no more difficult than their numeric counterparts without the temporal requirements. Indeed, in the above domain each problem admits a solution in which all the durative actions are sequentially executed, one after the other. For this reason, such problems are said to be without required concurrency (Cushing et al. 2007), and they can be (more easily) solved by non-temporal planners by (i) replacing each durative action b with a snap action combining the preconditions and effects of b+, bH, b\u22a5, (ii) finding a sequential solution to the resulting non-temporal problem, and (iii) post-process the found solution to introduce execution times. We thus consider the following example, whose problems require concurrency.\nExample (cont'd). Consider the previous example extended with nck which at start uncaps the bottle k \u2208 [1, q] and then caps it back after dk seconds. Any problem in which all the bottles are initially capped requires concurrency, since pouring from i to j is possible only if both bottles i and j are uncapped. This scenario can be modelled in PDDL 2.1 with VB = {Ck | k \u2208 [1, q]}, VN = {lk | k \u2208 [1, q]} and the set of durative actions A = {nck | k \u2208 [1,q]} \u222a {prij | i \u2208 [1, p], j\u2208 (p, q]} whose actions are:\nprij+: {{ci = 1, li > 0, cj = \u22a5}, {li -= 1}),\nprijH: {{ci = 1, cj = 1}, \u2205), prij\u22a5: (\u2205, {lj += 1}),\nnck+: {{Ck = T}, {ck := \u22a5}), nck\u22a5: {{Ck = \u22a5}, {Ck := T}).\nAs customary, v += \u03c8 (resp. v -= \u03c8) is an abbreviation for v := v + \u03c8 (resp. v := v \u2212 \u03c8). With q = 2 and p = 1, there are three durative actions pr1,2, nc1 and nc2. Considering the starting/ending actions, pr+1,2 is mutex with nct1, nct2, nct1, nct2. If the bottles are initially capped and the durations allow to pour all the litres with just one execution of nc1 and nc2), we need a bound\n1. n = l1 + 3 with the standard encoding (one step for uncapping the bottles, 1 step for starting the first pour action after \u03f5 time, l1 steps for pouring the litres and the final step for executing the capping of the bottles),\n2. n = 4 if we generalize the R encoding since we can roll-up the pr1,2 action and collapse the l1 steps into 1,\n3. n = l1 if we generalize the R2\u2203 encoding since we can execute all the actions (even the mutex ones) in one step except for the repeated execution of pr1,2 (action variables are still Boolean),\n4. n = 1 if we generalize the \u4eba-encoding since we can execute all the actions in one step.\nIf, e.g., q = 4 and p = 2 in the standard encoding we need n = l1 + l2 + 3 steps if the durations of the pour actions forces them to start/end at different times, while we can maintain n = 1 generalizing the \u4eba-encoding."}, {"title": "Temporal Numeric Planning with Patterns", "content": "Let II = (VB, VN, A, I, G) be a temporal numeric planning problem. Here, we extend the SPP approach to the temporal setting by (i) formally defining the notion of pattern \u4eba and defining the sets X, A\u4eba,T\u4eba, X' of variables used in our encoding; (ii) extending the definition of rolling to durative actions; (iii) defining the pattern state encoding formula, T\u4eba(X, A\u4eba, X'), setting the value of each variable in X' as a function of X and A\u4eba; (iv) defining the pattern time encoding formula, T<\u4eba(A\u4eba, T\u4eba), enforcing the desired temporal properties of the actions; and (v) proving the correctness and completeness of the presented encoding. Each point is treated in a separate subsection. Intuitively, a pattern is a sequence of starting/ending actions. For each of these actions, the encoding sets (i) an integer specifying how many times the corresponding durative action is executed in sequence, (ii) the conditions for its executability and effects, and (iii) the time at which each durative action sequence has to be started/ended. While durative action sequences that do not interfere might swap order, those that interfere need to maintain the ordering given in the pattern for their starting/ending actions, to ensure executability."}, {"title": "Pattern and Language Definition", "content": "A pattern is a finite sequence < = a1; a2; ...; ak of actions, each starting/ending a durative action in A. A pattern is arbitrary, allowing for multiple occurrences of the same action, even consecutively. Each action occurrence in the pattern corresponds to a distinct variable in the encoding, and, given the variable name, we have to be able to uniquely identify\n1. which durative action it is starting/ending, and\n2. which of the possible multiple occurrences of the action in \u4eba we are considering.\nFor these reasons, we perform the following two initial steps which do not affect the generality of our approach:\n1. Whenever in A there are two distinct durative actions b1 and b2 with b+1 = b+2 or b\u22a51 = b\u22a52 or bH1 = bH2, we break the identity by adding to the preconditions of one of the two actions an always satisfied condition like 0 = 0, and\n2. In a pattern \u4eba, repeated occurrence of an action a are replaced with distinct copies a'. Both a and a' are assumed to be starting/ending the same durative action b, and, abusing notation, we write, e.g., a = b+ and a' = b+.\nWe can therefore take the action in the pattern to be the action variables in our encoding, and we can assume that each action starts/ends exactly one durative action.\nConsider a pattern < = a1; a2; ... ; ak, k \u2265 0. Our encoding is based on the following sets of variables:\n1. X = VB UVN to represent the initial state;\n2. X' containing a next state variable x' for each state variable x \u2208 X, used to represent the goal state;\n3. A consisting of the set of actions in the pattern <, each variable ai ranging over N\u22650 and whose value represents the number of times the durative action started/ended by ai is consecutively executed/rolled up, with i \u2208 [1, k];\n4. T\u4eba, with (i) a variable ti \u2208 Q\u22650 representing the time in which the i-th action ai in \u4eba is executed; (ii) if ai is starting b, a variable di \u2208 Q\u22650 representing the time taken by the consecutive execution of b for p times, where p \u2265 0 is the value assumed by the variable ai \u2208 A\u4eba, and (iii) for convenience, a variable t0 0 as the initial time.\nIn the following we keep using v, w, x for state variables, \u03c8 for a linear expression, a for a (snap) action, b for a durative action, t for a time variable and d for a duration, each symbol possibly decorated with subscripts/superscripts."}, {"title": "Rolling Durative Actions", "content": "We start by defining when a durative action b can be rolled up. Intuitively, b can be consecutively executed more than once when (i) the Boolean effects of its starting/ending actions do not disable the repetition of b given the preconditions of its starting/lasting/ending actions, (ii) the numeric effects of b+ and b\u22a5 do not interfere between themselves, and (iii) it might be useful to execute b more than once. Formally, we say that b is eligible for rolling if the following three conditions are satisfied:\n1. if V, V' \u2208 {\u22a5, T}, V  V', then (i) v = V \u2208 pre(b+) iff v := V \u2208 eff(b\u22a5) or v := V' \u2209 eff(b+) U eff(bH), and (ii) v = V \u2208 pre(b+) U pre(b\u22a5) iff v := V \u2208 eff (b+) or v := V' \u2209 eff(b+) U eff(bH);\n2. if v := \u03c8 is a numeric effect of b+ or b\u22a5, then (i) v does not occur in any other effect of b+ or b\u22a5, and (ii) either v does not occur in H or v := \u03c8 is a linear increment;\n3. H or b\u22a5 include a linear increment in their effects (this last condition imposed for the usefulness of rolling).\nIf b has a duration in [L, U] and is eligible for rolling, consecutively executing b for p > 1 times\n1. has a duration in [p \u00d7 L + (p \u2212 1) \u00d7 \u03f5\u266d, p \u00d7 U + (p \u2212 1) \u00d7 \u03f5\u266d], where \u03f5\u266d = \u03f5 if b+ and b\u22a5 are mutex, and \u03f5\u266d = 0 otherwise. Such interval allows for \u03f5-separation if b+ and b\u22a5 are mutex;\n2. causes v to get value (p \u00d7 \u03c8) if v += \u03c8 is a linear increment of b+ or b\u22a5, while all the other variables keep the value they get after the first execution of b.\nNotice that it is assumed that all the consecutive executions of b have the same duration. Indeed, according to the semantics, the duration of b can be arbitrarily fixed as long as each single execution respects the duration constraints, which are part of the domain specification. This assumption does not affect the completeness of our encoding. Should every valid plan require two consecutive executions of b with different durations, we will find a plan when considering a pattern with two or more occurrences of the starting/ending actions of b. Indeed, rolling is an optimization, and our procedure is complete even if we rule out rolling by adding the constraint ai \u2264 1 for each action a.\nThen, for each i\u2208 [0, k], the value of a variable v \u2208 VB\u222a VN after the sequential execution of a1; ...; ai, each action possibly repeated multiple times, is given by \u03c3i(v), inductively defined as \u03c30(v) = v, and, for i > 0,\n1. if v is not assigned by ai, \u03c3i(v) = \u03c3i\u22121(v);\n2. if v := T \u2208 eff(ai), \u03c3i(v) = (\u03c3i\u22121(v) \u2228 ai > 0);\n3. if v := \u22a5 \u2208 eff(ai), \u03c3i(v) = (\u03c3i\u22121(v) \u2227 ai = 0);\n4. if v += \u03c8 \u2208 eff(ai) is a linear increment,\n$$\u03c3_i(v) = \u03c3_{i-1}(v) + a_i \u00d7 \u03c3_{i-1}(\u03c8)$$\ni.e., the value of v is incremented by \u03c3i\u22121(\u03c8) a number of times equal to the value assumed by the variable ai;\n5. if v := \u03c8 \u2208 eff (ai) is not a linear increment,\n$$\u03c3_i(v) = ITE(a_i > 0, \u03c3_{i-1}(\u03c8), \u03c3_{i-1}(v))$$\nwhere ITE(c, t, e) (for \u201cIf (c) Then t Else e\u201d returns t or e depending on whether c is true or not, and is a standard function in SMTLIB (Barrett, Fontaine, and Tinelli 2016).\nAbove and in the following, for any linear expression \u03c8 and i \u2208 [0, k], \u03c3i(\u03c8) is the expression obtained by substituting each variable v \u2208 VN in \u03c8 with \u03c3i(v).\nGiven a durative action b eligible for rolling and a state s, to determine the maximum number of times that b can be executed consecutively in s, we rely on the following Theorem, in which \u03c8[p, b+, q, b\u22a5] represents the value of \u03c8 after p and q repetitions of the actions b+ and b\u22a5, respectively. Formally, \u03c8[p, b+, q, b\u22a5] is the expression obtained from \u03c8 by substituting each variable x with\n1. x + p \u00d7 \u03c8' (resp. x + q \u00d7 \u03c8'), when x += \u03c8' \u2208 eff(b+) (resp. x += \u03c8' \u2208 eff(b\u22a5)) is a linear increment, and\n2. \u03c8", "x": "\u03c8"}, {"title": "The Pattern State Encoding", "content": "Let < = a1; a2; ... ; ak, k \u2265 0, be a pattern. The pattern state encoding defines the executability conditions of each action and how to compute the value of each variable in X' based on the values of the variable in X and in A\u4eba. Formally, the pattern state \u4eba-encoding T\u4eba(X, A\u4eba, X') of II is the conjunction of the formulas in the following sets:\n1. pre(A\u4eba): for each i \u2208 [1, k] and for each v = \u22a5, w = T, \u03c8 \u25b7 0 in pre(ai):\n(a) v and w must hold to execute ai:\nai > 0 \u2192 (\u00ac\u03c3i\u22121(v) \u2227 \u03c3i\u22121(W)),\n(b) and, if ai is starting b, (i.e., if ai = b+) (Theorem 1):\nai > 0 \u2192 \u03c3i\u22121(\u03c8[0, b+, 0,b\u22a5]) \u25b7 0,\nai > 1 \u2192 \u03c3i\u22121(\u03c8[ai \u2212 1, b+, ai \u2212 1, b\u22a5]) \u25b7 0,\n(c) if ai is ending b, (i.e., if ai = b\u22a5) (Theorem 1, noting that in \u03c3i\u22121, b has been executed ai times):\nai > 0 \u2192 \u03c3i\u22121(\u03c8[\u2212ai +1,b+, 0,b\u22a5]) \u25b7 0,\nai > 1 \u2192 \u03c3i\u22121(\u03c8[0, b+, ai \u2212 1, b\u22a5]) \u25b7 0.\n2. amo(A\u4eba): for each i \u2208 [1, k], if ai is starting a durative action which is not eligible for rolling:\nai \u2264 1.\n3. frame (VB\u222a VN): for each variable v \u2208 VB and w\u2208 VN :\nv' \u2194 \u03c3k(v), w' = \u03c3k(w).\nExample (cont'd). Assume p = 2 and q = 4. Let\n< =\nnct1; nc+2; nc\u22a51; nc\u22a52; pr+1,3\npr+1,3; pr+1,4; pr+2,3; pr+2,4;\npr\u22a52,3; pr\u22a52,4\n(1)\nbe the fixed pattern \u4eba. Assume i \u2208 [1,2], j\u2208 [3,4], k \u2208 [1,4]. The pattern state encoding entails (nc+k \u2264 1) since the durative action nc is not eligible for rolling, and\nnck+ >0\u2192ck, nck\u22a5 > 0 \u2192 \u00ac(ck \u2227 nck+ = 0),\nprij+ > 0 \u2192 (\u00ac(ci \u2227 nck+ = 0) \u2227 \u00ac(cj \u2227 nck+ = 0)),\nprij+ > 0 \u2192 li > 0,\npri+1,3>0 \u2192 li-pr+1,3>0,\npr+1,3>1\u2192pr+1,3 li,\npr+1,4>1\u2192pr+1,4pri+1,3,\nck' = (ck \u2227 nck\u22a5 = 0) \u2228 nck+ > 0,\nli' = li - pr1,3- pr1,4,\nlj' = lj + pri,j + pr2,j.\nThe first four lines define the preconditions for executing each action, and the last two specify the frame axioms.\nAs the frame axioms in the example make clear, the \u4eba-encoding allows in the single state transition from X to X' (i) the multiple consecutive execution of the same action, as in the rolled-up R encoding (Scala et al. 2016b), and (ii) the combination of multiple even contradictory effects on a same variable by different actions, as in the R2\u2203 encoding (Bofill, Espasa, and Villaret 2016)."}, {"title": "The Pattern Time Encoding", "content": "Let < = a1; a2; ... ; ak, k \u2265 0, be a pattern. The pattern time \u4eba-encoding associates to each action ai in < a starting time ti and duration di, which are both set to 0 when ai is not executed, i.e., when ai = 0. In defining the constraints for ti and di they have to respect the semantics of temporal planning problems and also the causal relations between the actions in the pattern and exploited in the pattern state \u4eba-encoding. Consider for instance two actions ai and aj in < with i < j, ai > 0 and aj > 0. We surely have to guarantee that ti < tj if ai and aj are in mutex: the formulas checking that the preconditions of aj (resp. ai) are satisfied, take into account that ai (resp. aj) has been (resp. has not been) executed before aj (resp. ai). Even further, we have to impose that ti + \u03f5 < tj for the \u03f5-separation rule. If, on the other hand, ai and aj are not in mutex, then it is not necessary to guarantee ti < tj unless aj is ending the durative action started by ai or because of the lasting action of the durative action started by aj. As an example of the impact of the lasting action on the encoding, assume aj is starting action b+. Then, it may be the case ai is not in mutex with aj but it is in mutex with the lasting action bH of b. Hence, the formulas checking the executability of bH encode that ai precedes aj in the pattern, and consequently we will have to guarantee ti < tj.\nGiven the above, the pattern time \u4eba-encoding T<\u4eba(A\u4eba, T\u4eba) of \u4eba is the conjunction of (t0 = 0) and the following formulas:\n1. dur(A\u4eba): for each durative action \u27e8b+, b\u22a5, bH, [L, U]\u27e9 \u2208 A and for each action ai = b+ and aj = b\u22a5 in <:\nai > 0 ti\u2265 t0 + \u03f5,\nai = 0 \u2192 ti = t0 \u2227 di = 0, aj = 0 \u2192 tj = t0,\nai > 0 \u2192 ai \u00d7 (L + \u03f5\u266d) \u2264 di + \u03f5\u266d \u2264 ai \u00d7 (U + \u03f5\u266d).\nThe last formula guarantees also \u03f5-separation when b is consecutively executed, and b+ and b\u22a5 are in mutex.\n2. start-end(A\u4eba): for each durative action b, each starting action ai = b+ (resp. ending action aj = b\u22a5) in < must have a matching ending (resp. starting) action:\nai > 0 \u2192 \u2228j\u2208Ei (ai = aj \u2227 tj = ti + di),\naj > 0 \u2192 \u2228i\u2208Sj (ai = aj \u2227 tj = ti + di),\nwhere Ei = {j \u2208 (i,k] | ai = b+,aj = b\u22a5}, and Sj =\n{i \u2208 [1, j) | aj = b+, ai = b+}.\n3. epsilon(A\u4eba): every two actions ai and aj in < with j < i are \u03f5-separated if they are mutex or different copies of the same action:\nai > 0 \u2192 (ti \u2265 tj + \u03f5).\nFurther, for every two actions ai and aj starting respectively b and b', if the starting or ending action of b is mutex with the starting or ending action of b':\nai > 1 \u2192 (ti \u2265 tj + dj \u2228 tj \u2265 ti + di\u2228\naj = 1 \u2227 ti \u2265 tj \u2227 ti + di < tj + dj).\nThis formula ensures that the start/end actions of b' are not executed during the multiple consecutive executions of b, thereby guaranteeing \u03f5-separation."}, {"title": "Correctness and Completeness Results", "content": "Let < = a1; a2; ... ; ak, k \u2265 0, be a pattern. Though the pattern < can correspond to any sequence of starting/ending actions of a durative action in A, it is clear that it is pointless to"}]}