{"title": "NeoPhysIx: An Ultra Fast 3D Physical Simulator as Development Tool for AI Algorithms", "authors": ["J\u00f6rn Fischer", "Thomas Ihme"], "abstract": "Traditional AI algorithms, such as Genetic Pro- gramming and Reinforcement Learning, often require extensive computational resources to simulate real-world physical scenarios effectively. While advancements in multi-core processing have been made, the inherent limitations of parallelizing rigid body dynamics lead to significant communication overheads, hindering substantial performance gains for simple simulations.\nThis paper introduces NeoPhysIx, a novel 3D physical simula- tor designed to overcome these challenges. By adopting innovative simulation paradigms and focusing on essential algorithmic elements, NeoPhysIx achieves unprecedented speedups exceed- ing 1000x compared to real-time. This acceleration is realized through strategic simplifications, including point cloud collision detection, joint angle determination, and friction force estimation. The efficacy of NeoPhysIx is demonstrated through its appli- cation in training a legged robot with 18 degrees of freedom and six sensors, controlled by an evolved genetic program. Remarkably, simulating half a year of robot lifetime within a mere 9 hours on a single core of a standard mid-range CPU highlights the significant efficiency gains offered by NeoPhysIx. This breakthrough paves the way for accelerated AI development and training in physically-grounded domains.", "sections": [{"title": "I. INTRODUCTION", "content": "To develop effective robot controllers, optimize robots' planning behavior, or enable offline learning techniques such as Reinforcement Learning, very fast and stable physical simulators are essential. These simulators must handle 3D rigid bodies, as well as various types of sensors and actuators, to accurately model complex robotic systems [1]-[7].\nOver the years, simulation algorithms have been signifi- cantly optimized to deliver faster results [8]. Many simulators now meet the real-time performance criterion. However, with the 4.0 GHz clock frequency barrier for CPUs in place [9], further improvements in simulation speed have stagnated.\nReal-time simulation is particularly important for the gam- ing industry, where the most advanced simulators are opti- mized to meet real-time requirements even in complex sce- narios. Despite these improvements, extremely fast simulation speeds are still required for applications such as evolving learning neuro-controllers, executing real-time planning in complex environments, or optimizing robot construction pa- rameters.\nSimulators like PhysX (NVIDIA), ODE (Open Dynamics Engine), Havok, and Bullet are fine-tuned to deliver data at rates exceeding real-time. However, achieving a frame rate that is a multiple of real-time often requires substantial software restructuring or implementing unconventional solutions, such as using separate threads for each computed scene. These optimizations reflect the primary focus on meeting game physics requirements rather than the unique needs of robotics.\nProjects involving Artificial Intelligence, where algorithms require the capability to test behaviors across diverse scenarios, demand specialized simulators. These simulators must not only meet real-time performance requirements but also deliver results at the highest possible speeds.\nThe following sections introduce a new simulator, Neo- PhysIx, capable of achieving up to one million frames per second on a single thread of a standard Intel i5 processor. Key methods that enable this speedup, such as point cloud collision detection, joint angle calculation, and friction force estimation, will be discussed in detail."}, {"title": "II. RELATED WORK", "content": "Numerous commercial and open-source rigid body simu- lators exist, each developed with significant effort to ensure accurate and consistent physical behavior. This raises the question: why introduce yet another simulator? What specific applications might this new simulator target?\nTo address these questions, we can categorize applications that rely on simulation as follows:\n1) High-precision physical simulations for predictive pur- poses (e.g., architecture, medical simulations, crash test- ing).\n2) Real-time simulations with lower precision (e.g., game engines, virtual reality).\n3) Simulations faster than real time (e.g., weather forecast- ing, tsunami warning systems).\n4) Ultra-fast simulations for AI applications such as plan- ning, evolutionary algorithms, and reinforcement learn- ing.\nTraditionally, planning algorithms, reinforcement learning, and evolutionary algorithms have relied on simulation environ- ments developed for the gaming industry, using simulators like ODE, Bullet, Havok, and PhysX [1,2]. When simulating mod- erately complex robots, these tools typically achieve speedups ranging from 1 to 20 times real time. This performance is often insufficient, resulting in longer scenario testing times, smaller population sizes, and prolonged waiting times for results.\nIn particular, evolving complex neural controllers with self- modifying synapses is challenging and has been demonstrated in only a few specific cases [10].\nOne study on the Webots simulator [11] mentions a \"fast simulation\" mode that is reported to run up to 300 times faster than real time. However, the study lacks details on the robot's architecture and the required hardware specifications to achieve this acceleration, making the reported data insufficient as a benchmark. Another study [12] failed to reproduce these results: \"This could not be validated with the examples provided in the evaluation version (Ver. 5, Mac OS 10.5.4, 2.5 GHz Dual Core, 4 GB RAM). The maximum speed achieved was approximately seven times faster than real time.\"\nOne notable project from Cornell University focuses on optimizing the PhysX simulation framework specifically for neuro-evolution. In this setup, a four-legged robot with eight joints was simulated at speeds 264 times faster than real time. This significant speedup was achieved using special- ized NVIDIA hardware, disabling visualization, and \"forcing multiple threads managing scene models onto local threads or processor cores\" [13]. By comparison, NeoPhysIx can accelerate the same model to 2,235 times real time.\nThe following sections describe the functioning of Neo- PhysIx. Sections V and VI demonstrate the simulation frame- work's capabilities in a genetic programming context, where a genetic programming algorithm discovers solutions for con- trolling a complex walking machine within approximately six months of accumulated robot runtime. The final sections present conclusions and an overview of the NeoPhysIx API commands."}, {"title": "III. COMPUTATION PRINCIPLES", "content": "Since rigid bodies can be viewed as approximations of extremely stiff objects, there is no single physically accurate model for their behavior. As a result, various solution methods are available, and the goal is to establish consistent rules that provide stable and realistic behavior at the highest possible speed.\nSimulation speed is influenced by the algorithm's com- plexity, the simulated object's complexity, and the program's structure. Multi-threading may be beneficial when communi- cation overhead is minimal and when other processor cores are available. In applications like planning, reinforcement learn- ing, or evolutionary algorithms, a multi-threaded framework could enable testing robots in separate environments, each in a dedicated thread. However, NeoPhysIx runs on a single thread to simplify its structure and enhance performance.\nNeoPhysIx was developed using Microsoft Visual C++ with 64-bit compilation and optimization flags enabled. Profiling tools were employed throughout development to eliminate unnecessary code and optimize performance. The graphi- cal output is minimal and platform-independent, relying on OpenGL. The same codebase also compiles on 64-bit Debian Linux, achieving comparable speed.\nTo achieve realistic behavior with minimal computational power, the methods described in the following sections are applied."}, {"title": "A. Point Cloud Collision", "content": "The robot model comprises a set of mass points, which collectively represent the robot's structure. These mass points serve two main purposes: calculating the center of gravity (CoG) and determining the robot's momentum. Although a triangular mesh is defined along these mass points for visual representation, it currently serves no role in collision detection. However, future implementations may incorporate this mesh to enable more precise collision detection between different robots.\nSince detecting collisions using triangle intersections is computationally intensive, we adopt a simplified approach that considers only the interaction between the robot's mass points and a predefined height map representing the environ- ment. This approach is implemented through a straightforward single-loop algorithm. In this algorithm, the x-y coordinates of each mass point are scaled by a factor of 10, converting them into integer indices. These indices are used to look up the associated height value in a 2D array, representing the height map as a look-up table.\nThe choice of a scaling factor of 10, when using meters, kilograms, and seconds (MKS units), yields a height map resolution of 0.1 meters, sufficient for modeling basic indoor and outdoor environments. For scenarios involving smaller robots or environments that require higher precision, this scaling factor may be increased accordingly."}, {"title": "B. Joint Angle Determination", "content": "A key distinction between this system and conventional physics engines is the treatment of the robot as a single rigid body. Relative movements between different robot segments are computed directly, bypassing the need for force-based calculations. This approach is valid only when the motors are sufficiently powerful to achieve the desired angles within the given time frame, and when movements occur at a pace slow enough relative to the simulation's timestep.\nNeoPhysIx updates the physical state of the simulation every 10 ms of simulated time. Calculating new joint angles at each frame introduces significant computational overhead. To optimize performance, joint angle calculations are typically spaced over multiple timesteps. Empirical tests indicate that updating joint angles every 80 ms yields realistic behavior while maintaining computational efficiency. This interval is adjustable, allowing for tuning based on specific simulation requirements to balance accuracy with performance."}, {"title": "C. Friction Force Estimation", "content": "As discussed in Section III-A, even utilizing a look-up table for collision detection demands significant computational resources. Conventionally, friction forces are computed at each contact point and then summed for integration. However, Neo- PhysIx employs an alternative approach by modeling friction as the maximum static friction and formulating the friction computation as an optimization problem. Specifically, at each time step, the algorithm minimizes the distance between a contact point at time t and the corresponding contact point at time t + 1, allowing for both displacement and rotation of the robot.\nFor example, in a 2D case involving both displacement and rotation, the following equation describes the new contact point position:\n$\\begin{pmatrix} x^{t+1} \\ z^{t+1} \\end{pmatrix} = \\begin{pmatrix} cos(\\alpha) & -sin(\\alpha) \\\\ sin(\\alpha) & cos(\\alpha) \\end{pmatrix} \\begin{pmatrix} x^{t} \\ z^{t} \\end{pmatrix} + \\begin{pmatrix} a_1 \\ a_2 \\end{pmatrix}$ (1)\nHere, $x^t$ and $z^t$ are the coordinates of the contact point at time t, $(a)$ represents the displacement vector, and $\\alpha$ is the rotation angle necessary to adjust the robot's position such that the distance to the same contact point at time t + 1 is minimized. This nonlinear equation is then approximated via a first-order Taylor expansion:\n$\\begin{pmatrix} x^{t+1} \\ z^{t+1} \\end{pmatrix} \\approx \\begin{pmatrix} x^{t} \\ z^{t} \\end{pmatrix} + \\begin{pmatrix} -a_3 z^{t} + a_1 \\ a_3 x^{t} + a_2 \\end{pmatrix}$ (2)\nThe resulting optimization problem is then solved using a least squares approach:\n$\\sum_{i} [(x_i^t - a_3 z_i^t + a_1 - x_i^{t+1})^2 + (x_i^t a_3 + z_i^t + a_2 - z_i^{t+1})^2] = 0$ (3)\nwhere i indexes all contact points existing in both time steps. Solving this results in a system of three linear equations, solvable when more than two contact points are involved:\n$\\sum_i 2(x_i^t - a_3 z_i^t + a_1 - x_i^{t+1}) = 0$ (4)\n$\\sum_i 2(x_i^t a_3 + z_i^t + a_2 - z_i^{t+1}) = 0$ (5)\n$\\sum_i [2(x_i^t - a_3 z_i^t + a_1 - x_i^{t+1})(-z_i^t) + 2(x_i^t a_3 + z_i^t + a_2 - z_i^{t+1})(x_i^t)] = 0$ (6)\nHere, $(a)$ is the displacement vector, and $a_3 \\approx sin(\\alpha)$ is an approximation for the sine of the rotation angle. Despite these simplifications, the resulting friction model yields remarkably realistic outcomes. For greater accuracy, forces inducing rota- tions around both the x- and z-axes should also be considered. Further refinement may be achieved by weighting each term in the sum by the force pressing the contact point against the ground."}, {"title": "IV. THE APPLICATION PROGRAMMING INTERFACE", "content": "NeoPhysIx is meticulously engineered to provide a compre- hensive and user-friendly application programming interface (API) that streamlines the process of robot simulation. The API prioritizes intuitive design principles, enabling researchers and developers to efficiently construct and manipulate virtual robotic systems.\nAt the core of NeoPhysIx's API lies the 'robot' class, which serves as the foundational building block for constructing robot models. This class encapsulates a suite of essential functions required for robot simulation, simplifying the development workflow."}, {"title": "A. Body Definition and Customization", "content": "NeoPhysIx offers a diverse library of primitive body types to facilitate the creation of intricate robotic structures. Users can readily generate various geometric shapes, including mass points, boxes, cylinders, spheres, and rays, through dedicated function calls for each body type. This modular approach al- lows for rapid prototyping and experimentation with different robot configurations.\nFurthermore, each body possesses an optional color at- tribute, enabling users to visually distinguish individual com- ponents within the simulated environment. This feature proves invaluable for debugging and understanding complex robotic systems."}, {"title": "B. Assembly and Joint Definition", "content": "The 'connectBodies() function serves as the cornerstone for assembling the constituent bodies into a cohesive robot structure. This function accepts a list of body objects as input, establishing connections between them based on user-defined parameters.\nTo endow robots with mobility and articulation, NeoPhysIx provides the 'createJoint() function. This function enables the creation of hinge joints between connected bodies, al- lowing for controlled movement and manipulation within the simulated environment. The joint parameters, such as axis of rotation and range of motion, can be meticulously defined to accurately replicate real-world robotic behavior.\nThis comprehensive API empowers users to construct so- phisticated robot models with ease, fostering a streamlined and efficient development process for robotics research and simulation."}, {"title": "C. Simplifying Robot Construction for Faster Simulation", "content": "To further optimize simulation speed, users can employ the simplifyMode() function, which modifies the body shapes to simpler forms before creation. For instance, this feature can represent a cylindrical shape as a box, or in some cases, reduce it to one or two points. Such simplifications can significantly enhance performance. The simplifyMode (mode) function ac- cepts different modes for varying levels of simplification, as outlined below:\n0: No simplification\n1: Convert cylinders and spheres to boxes\n2: Convert cylinders and spheres to two points\n3: Convert cylinders and spheres to a single point"}, {"title": "V. THE EVOLUTION OF THE GP ROBOT CONTROLLER", "content": "To evaluate the functionality and stability of NeoPhysIx, we applied an optimization scenario using Genetic Program- ming (GP). GP was tasked with evolving a compact machine language program to control a six-legged walking robot. The fitness function guiding this evolution was straightforward: \"Walk as far as possible.\""}, {"title": "VI. RESULTS", "content": "This section presents the findings from our extensive robot lifetime evaluation, spanning approximately six months of sim- ulated operation. The simulation exhibited remarkable stabil- ity throughout the experiment, consistently yielding effective controllers for the robotic agent.\nFigure 4 illustrates the evolution of performance over gen- erations. Notably, the simulation was conducted on a single thread of an Intel i5 processor operating at 2.4 GHz, demon- strating the efficiency of our approach. The computational time required to simulate two minutes of robot lifetime across 100 robots, spanning 1,364 generations, amounted to approxi- mately nine hours. This translates to an impressive simulation duration of 189 days, effectively representing over half a year of simulated robot lifespan.\nThe optimization process successfully generated a machine language program that resulted in an unconventional sideways walking gait for the robot. This behavior demonstrates the algorithm's ability to discover novel solutions and adapt to the complexities of the environment. Importantly, no memory leaks were observed during the nine-hour runtime, indicating the robustness and stability of our implementation. The sim- ulation remained operational throughout this period and was ultimately terminated manually due to time constraints.\nThe successful completion of this extensive simulation provides compelling evidence for the efficacy of our approach in developing robust and adaptable robotic controllers. Further analysis of the generated machine language programs and their corresponding behaviors will provide valuable insights into the learning process and pave the way for future improvements."}, {"title": "VII. CONCLUSION", "content": "This paper presents a novel physical simulator, termed Neo- PhysIx, which incorporates simplified yet robust simulation principles. The architecture of NeoPhysIx and the methodolo- gies employed for key functionalities such as point cloud col- lision detection, joint angle determination, and friction force estimation were meticulously described in previous sections.\nThe efficacy of NeoPhysIx was rigorously validated through a comprehensive Genetic Programming (GP) scenario. A complex robotic system with 18 degrees of freedom and six integrated sensors was simulated within the NeoPhysIx environment. Over an extended period exceeding half a year of simulated robot lifetime, the simulator facilitated the evolution and testing of more than 100,000 distinct controller programs. This extensive experimentation demonstrated the capability of NeoPhysIx to handle intricate robotic systems and complex evolutionary algorithms.\nThe successful implementation of NeoPhysIx establishes a new paradigm in physical simulation, offering a unique plat- form for advancing research in areas such as robot learning, evolution, planning, and controller testing."}, {"title": "VIII. FUTURE WORK", "content": "While NeoPhysIx demonstrates significant potential, several avenues for improvement and expansion exist. A key area of focus is the refinement of the current friction model to enhance its accuracy and realism. Furthermore, incorporating function- alities for simulating robot-robot collisions will significantly broaden the scope of applications.\nExpanding sensor capabilities by integrating camera sensors will provide richer environmental perception for simulated robots, enabling more sophisticated control strategies. To facilitate wider adoption and accessibility, a Python wrapper for NeoPhysIx is planned. This wrapper will enable seamless integration with existing Python ecosystems, allowing for efficient simulation execution across diverse operating systems such as Linux, Windows, and MacOS.\nCurrently, evolutionary and neural algorithms implemented within NeoPhysIx primarily serve as proof-of-concept demon- strations. To fully realize the simulator's potential, integrating state-of-the-art methods in these domains is crucial. This will empower researchers to explore cutting-edge control strategies and push the boundaries of robotic intelligence within the robust and versatile NeoPhysIx environment."}, {"title": "APPENDIX", "content": "To get an idea of which commands the API offers to be able to construct a robot we give a short overview here:\n1) createPoint: A mass point is defined by its coordinates (x, y, z) and its mass (m). In addition a color (red, green, blue) using floating point values between 0 and 1 may be defined. Building a robot out of simple mass points is supposed to lead to the greatest speedup possible. The body ID of the mass point is given back. body ID createPoint(x,y,z,m,r,g,b);"}]}