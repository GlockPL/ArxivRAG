{"title": "Misspecified Q-Learning with Sparse Linear Function Approximation: Tight Bounds on Approximation Error", "authors": ["Ally Yalei Du", "Lin F. Yang", "Ruosong Wang"], "abstract": "The recent work by Dong and Yang [2023] showed for misspecified sparse linear bandits, one can obtain an $O(\\epsilon)$-optimal policy using a polynomial number of samples when the sparsity is a constant, where $\\epsilon$ is the misspecification error. This result is in sharp contrast to misspecified linear bandits without sparsity, which require an exponential number of samples to get the same guarantee. In order to study whether the analog result is possible in the reinforcement learning setting, we consider the following problem: assuming the optimal Q-function is a $d$-dimensional linear function with sparsity $k$ and misspecification error $\\epsilon$, whether we can obtain an $O(\\mathcal{H}\\epsilon)$-optimal policy using number of samples polynomially in the feature dimension $d$. We first demonstrate why the standard approach based on Bellman backup or the existing optimistic value function elimination approach such as OLIVE [Jiang et al., 2017] achieves suboptimal guarantees for this problem. We then design a novel elimination-based algorithm to show one can obtain an $O(\\mathcal{H}\\epsilon)$-optimal policy with sample complexity polynomially in the feature dimension $d$ and planning horizon $\\mathcal{H}$. Lastly, we complement our upper bound with an $\\Omega(\\mathcal{H}\\epsilon)$ suboptimality lower bound, giving a complete picture of this problem.", "sections": [{"title": "1 Introduction", "content": "Bandit and reinforcement learning (RL) problems in real-world applications, such as autonomous driving [Kiran et al., 2021], healthcare [Esteva et al., 2019], recommendation systems [Bouneffouf et al., 2012], and advertising [Schwartz et al., 2017], face challenges due to the vast state-action space. To tackle this, function approximation frameworks, such as using linear functions or neural networks, have been introduced to approximate the value functions or policies. However, real-world complexities often mean that function approximation is agnostic; the function class captures only an approximate version of the optimal value function, and the misspecification error remains unknown. A fundamental problem is understanding the impact of agnostic misspecification errors in RL.\nPrior works show even minor misspecifications can lead to exponential (in dimension) sample complexity in the linear bandit settings [Du et al., 2020, Lattimore et al., 2020] if the goal is to learn a policy within the misspecification error. That is, finding an $O(\\epsilon)$-optimal action necessitates at least $(\\exp(d))$ queries (or samples) to the environment, where $\\epsilon$ is the misspecification error. Recently, Dong and Yang [2023] demonstrated that, by leveraging the sparsity structure of ground-truth parameters, one can overcome the exponential sample barrier in the linear bandit setting. They showed that with sparsity $k$ in the ground-truth parameters, it is possible to learn an $O(\\epsilon)$-optimal action with only $O((d/\\epsilon)^k)$ samples. In particular, when $k$ is a constant, their algorithm achieves a polynomial sample complexity guarantee."}, {"title": "1.1 Our Contributions", "content": "In this paper, we propose an RL algorithm that can handle linear function approximation with sparsity structures and misspecification errors. We also show that the suboptimality achieved by our algorithm is near-optimal, by proving information-theoretic hardness results. Here we give a more detailed description of our technical contributions.\nOur Assumption. Throughout this paper, we assume the RL algorithm has access to a feature map $\\phi$ where, for each state-action pair $(s, a)$, we have the feature $\\phi(s, a)$ with $|\\phi(s, a)| \\leq 1$. We make the following assumption, which states that there exists a sequence of parameters $\\theta^* = (\\theta^*_0,..., \\theta^*_{\\mathcal{H}-1})$ where each $\\theta^*_h \\in \\mathbb{R}^{d-1}$ is $k$-sparse, that approximates the optimal Q-function up to an error of $\\epsilon$.\nAssumption 1.1. There exists $\\theta^* = (\\theta^*_0,..., \\theta^*_{\\mathcal{H}-1})$ where each $\\theta^*_h \\in \\mathbb{R}^{d-1}$ is $k$-sparse, such that\n$|\\langle \\phi(s, a), \\theta^*_h \\rangle - Q^*(s, a)| \\leq \\epsilon$\nfor all $h \\in [\\mathcal{H}]$, all states $s$ in level $h$, and all actions $a$ in the action space.\nWe can approximate $\\theta^*$ using an $\\epsilon$-net of the sphere $\\mathbb{S}^{k-1}$ and the set of all $k$-sized subset of $[d]$. Therefore, when $k$ is a constant, we may assume that each $\\theta^*_h$ lies in a set with size polynomial in $d$. Then, a natural idea is to enumerate all possible policies induced by the parameters in that finite set, and choose the one with the highest cumulative reward. However, although the number of parameter candidates in each individual level has polynomial size, the total number of induced policies would be exponential in $\\mathcal{H}$, and the sample complexity of such an approach would also be exponential in $\\mathcal{H}$.\nThe Level-by-level Approach. Note that when the horizon length $\\mathcal{H} = 1$, the problem under consideration is equivalent to a bandit problem, which can be solved by previous approaches [Dong and Yang, 2023]. For the RL setting, a natural idea is to first apply the bandit algorithm in Dong and Yang [2023] on the last level, and then apply the same bandit algorithm on the second last level based on previous results and Bellman-backups, and so on. However, we note that to employ such an approach, the bandit algorithm needs to provide a \"for-all\" guarantee, i.e., finding a parameter $\\theta$ that approximates the rewards of all arms, instead of just finding a near-optimal arm. On the other hand, existing bandit algorithms will amplify the approximation error of the input parameters by a constant factor, in order to provide a for-all guarantee. Concretely, existing bandit algorithms can only find a parameter $\\theta$ so that $\\theta$ approximates the rewards of all arms by an error of $2\\epsilon$. As we have $\\mathcal{H}$ levels in the RL setting, the final error would be exponential in $\\mathcal{H}$, and therefore, such a level-by-level approach would result in a suboptimality that is exponential in $\\mathcal{H}$.\nOne may ask if we can further improve existing bandit algorithms, so that we can find a parameter $\\theta$ that approximates the rewards of all arms by an error of $\\epsilon$ plus a statistical error that can be made arbitrarily small, instead of $2\\epsilon$. The following theorem shows that this is information-theoretically impossible unless one pays a sample complexity proportional to the size of the action space."}, {"title": "Theorem 1.2.", "content": "Under Assumption 1.1 with $d = k = 1$, any bandit algorithm that returns an estimate $\\hat{r}$ such that $|r(a) - \\hat{r}(a)| < 2\\epsilon$ for all arms $a$ with probability at least $0.95$ requires at least $0.9n$ samples, where $n$ is the total number of arms.\nTherefore, amplifying the approximation error by a factor of 2 is not an artifact of existing bandit algorithms. Instead, it is information-theoretically impossible.\nGeometric error amplification is a common issue in the design of RL algorithm with linear function approximation [Zanette et al., 2019, Weisz et al., 2021, Wang et al., 2020a, 2021]. It is interesting (and also surprising) that such an issue arises even when the function class has sparsity structures."}, {"title": "Optimistic Value Function Elimination.", "content": "Another approach for the design of RL algorithm is based on optimistic value function elimination. Such an approach was proposed by Jiang et al. [2017] and was then generalized to broader settings [Sun et al., 2019, Du et al., 2021, Jin et al., 2021, Chen et al., 2022b]. At each iteration of the algorithm, we pick the value functions in the hypothesis class with maximized value. We then use the induced policy to collect a dataset, based on which we eliminate a bunch of value functions from the hypothesis class and proceed to the next iteration.\nWhen applied to our setting, existing algorithms and analysis achieve a suboptimality that depends on the size of the parameter class, which could be prohibitively large. Here, we use the result in Jiang et al. [2017] as an example. The suboptimality of their algorithm is $\\mathcal{H}\\sqrt{M}\\epsilon$, where $M$ is Bellman rank of the problem. For our setting, we can show that there exists an MDP instance and a feature map that satisfies Assumption 1.1, whose induced Bellman rank is large."}, {"title": "Proposition 1.3.", "content": "There exists an MDP instance $\\mathcal{M} = (\\mathcal{S}, \\mathcal{A}, \\mathcal{H}, P, r)$ with $|\\mathcal{A}| = 2$, $\\mathcal{H} = \\log d$, $|\\mathcal{S}| = d - 1$, with $d$-dimensional feature map $\\phi$ satisfying Assumption 1.1 with $k = 1$, such that its Bellman rank is $d$.\nGiven Proposition 1.3, if one na\u00efvely applies the algorithm in Jiang et al. [2017], the suboptimality would be $O(\\mathcal{H}\\sqrt{d}\\epsilon)$ in our setting, which necessitates new algorithm and analysis. In Section 4, we design a new RL algorithm whose performance is summarized in the following theorem."}, {"title": "Theorem 1.4.", "content": "Under Assumption 1.1, with probability at least $1 - \\delta$, Algorithm 1 returns a policy with suboptimality at most $(4\\epsilon_{\\text{stat}}+2\\epsilon_{\\text{net}}+2\\epsilon)^{\\mathcal{H}}$ by taking $O\\left(k d^{k} \\mathcal{H}^{3} \\cdot \\ln \\left(\\frac{d \\mathcal{H}}{\\epsilon_{\\text{net}} \\delta}\\right) \\cdot \\frac{1}{\\epsilon_{\\text{net}} \\epsilon_{\\text{stat}}}\\right)$ samples.\nHere $\\epsilon_{\\text{stat}}$ is the statistical error. Compared to the existing approaches, Theorem 1.4 achieves a much stronger suboptimality guarantee. Later, we will also show that such a guarantee is near-optimal.\nAlthough based on the same idea of optimistic value function elimination, our proposed algorithm differs significantly from existing approaches [Jiang et al., 2017, Sun et al., 2019, Du et al., 2021, Jin et al., 2021, Chen et al., 2022b] to exploit the sparsity structure. While existing approaches based on optimistic value function elimination try to find a sequence of parameters that maximize the value of the initial states, our new algorithm selects a parameter that maximizes the empirical roll-in distribution at all levels. Also, existing algorithms eliminate a large set of parameters in each iteration, while we only eliminate the parameters selected during the current iteration in our algorithm.\nThese two modifications are crucial for obtaining a smaller suboptimality guarantee, smaller sample complexity, and shorter running time. In existing algorithms, parameters at different levels are interdependent, i.e. the choice of parameter at level $h$ affects the choice of parameter at level $h + 1$. Our new algorithm simplifies this by maintaining a parameter set for each level, so each level operates independently. Further, we can falsify and eliminate any parameter showing"}, {"title": "The Hardness Result.", "content": "One may wonder if the suboptimality guarantee can be further improved. In Section 3, we show that the suboptimality guarantee by Theorem 1.4 is near-optimal.\nWe first consider a weaker setting where the algorithm is not allowed to take samples, and the function class contains a single sequence of functions. I.e., we are given a function $Q : \\mathcal{S} \\times \\mathcal{A} \\rightarrow \\mathbb{R}$, such that $|Q(s, a) - Q^*(s, a)| \\leq \\epsilon$ for all $(s, a) \\in \\mathcal{S} \\times \\mathcal{A}$.\nWe show that for this weaker setting, simply choosing the greedy policy with respect to $Q$, which achieves a suboptimality guarantee of $O(\\mathcal{H}\\epsilon)$, is actually optimal. To prove this, we construct a hard instance based on a binary tree. Roughly speaking, the optimal action for each level is chosen uniformly random from two actions $a_1$ and $a_2$. At all levels, the reward is $\\epsilon$ if the optimal action is chosen, and is $0$ otherwise. For this instance, there exists a fixed $Q$ that provides a good approximation to the optimal $Q$-function, regardless of the choice of the optimal actions. Therefore, $Q$ reveals no information about the optimal actions, and the suboptimality of the returned policy would be at least $\\Omega(\\mathcal{H}\\epsilon)$. The formal construction and analysis and construction will be given in Section 3.1.\nWhen the algorithm is allowed to take samples, we show that in order to achieve a suboptimality guarantee of $\\mathcal{H}/T\\epsilon$, any algorithm requires $\\exp(\\Omega(T))$ samples, even when Assumption 1.1 is satisfied with $d = k = 1$. Therefore, for RL algorithms with polynomial sample complexity, the suboptimality guarantee of Theorem 1.4 is tight up to log factors.\nTo prove the above claim, we still consider the setting where $d = k = 1$, i.e., a good approximation to the $Q$-function is given to the algorithm. We also use a more complicated binary tree instance, where we divide all the $\\mathcal{H}$ levels into $\\mathcal{H}/T$ blocks, each containing $T$ levels. For each block, only one state-action pair at the last level has a reward of $\\epsilon$, and all other state-action pairs in the block has a reward of $0$. Therefore, the value of the optimal policy would be $\\mathcal{H}/T \\epsilon$ since there are $\\mathcal{H}/T$ blocks in total. We further assume that there is a fixed function $Q$, which provides a good approximation to the optimal $Q$-function universally for all instances under consideration.\nSince $Q$ reveals no information about the state-action pair with $\\epsilon$ reward for all blocks, for an RL algorithm to return a policy with a non-zero value, it must search for a state-action pair with non-zero reward in a brute force manner, which inevitably incurs a sample complexity of $\\exp(\\Omega(T))$ since each block contains $T$ levels and $\\exp(\\Omega(T))$ state-action pairs at the last level. The formal construction and analysis and construction will be given in Section 3.2."}, {"title": "1.2 Related Work", "content": "A series of studies have delved into MDPs that can be represented by linear functions of predetermined feature mappings, achieving sample complexity or regret that depends on the feature mapping's dimension. This includes linear MDPs, studied in Jin et al. [2020], Wang et al. [2019], Neu and Pike-Burke [2020], where both transition probabilities and rewards are linear functions of feature mappings on state-action pairs. Zanette et al. [2020a,b] examines MDPs with low inherent Bellman error, indicating value functions that are almost linear with respect to these mappings. Another focus is on linear mixture MDPs [Modi et al., 2020, Jia et al., 2020, Ayoub et al., 2020, Zhou et al., 2021, Cai et al., 2020], characterized by transition probabilities that combine several basis kernels linearly. While these studies often assume known feature vectors, Agarwal et al. [2020] investigates a more challenging scenario where both features and parameters of the linear model are unknown."}, {"title": "2 Preliminaries", "content": "Throughout the paper, for a given positive integer $n$, we use $[n]$ to denote the set $\\{0, 1, 2, ..., n-1\\}$. In addition, $f(n) = O(g(n))$ denotes that there exists a constant $c > 0$ such that $|f(n)| \\leq c|g(n)|$. $f(n) = \\Omega(g(n))$ denotes that there exists a constant $c > 0$ such that $|f(n)| \\geq c|g(n)|."}, {"title": "2.1 Reinforcement Learning", "content": "Let $\\mathcal{M} = {\\mathcal{S}, \\mathcal{A}, \\mathcal{H}, P,r}$ be a Markov Decision Process (MDP) where $\\mathcal{S}$ is the state space, $\\mathcal{A}$ is the action space, $\\mathcal{H} \\in \\mathbb{Z}^+$ is the planning horizon, $P : \\mathcal{S} \\times \\mathcal{A} \\rightarrow \\Delta(\\mathcal{S})$ is the transition kernel which takes a state-action pair as input and returns a distribution over states, $r : \\mathcal{S} \\times \\mathcal{A} \\rightarrow \\Delta([0, 1])$ is the reward distribution. We assume $\\sum_{h \\in [\\mathcal{H}]} r_h \\in [0, 1]$ almost surely. For simplicity, throughout this paper, we assume the initial state $s_0$ is deterministic. To streamline our analysis, for each $h \\in [\\mathcal{H}]$, we use $\\mathcal{S}_h \\subseteq \\mathcal{S}$ to denote the set of states at level $h$, and assume $\\mathcal{S}_h$ do not intersect with each other.\nA policy $\\pi : \\mathcal{S} \\rightarrow \\mathcal{A}$ chooses an action for each state, and may induce a trajectory denoted by $(s_0, a_0, r_0,..., s_{\\mathcal{H}-1}, a_{\\mathcal{H}-1}, r_{\\mathcal{H}-1})$, where $s_{h+1} \\sim P(s_h, a_h)$, $a_h = \\pi(s_h)$, and $r_h \\sim r(s_h, a_h)$ for all $h \\in [\\mathcal{H}]$. Given a policy $\\pi$ and $h \\in [\\mathcal{H}]$, for a state-action pair $(s, a) \\in \\mathcal{S}_h \\times \\mathcal{A}$, the Q-function and value function is defined as\n$Q^{\\pi}(s, a) = \\mathbb{E} \\left[ \\sum_{h'=h}^{\\mathcal{H}-1} r(s_{h'}, a_{h'}) | s_h = s, a_h = a, \\pi \\right], \\quad V^{\\pi}(s) = \\mathbb{E} \\left[ \\sum_{h'=h}^{\\mathcal{H}-1} r(s_{h'}, a_{h'}) | s_h = s, \\pi \\right]$\nWe use $V^{\\pi}$ to denote the value of the policy $\\pi$, i.e., $V^{\\pi} = V^{\\pi}(s_0)$. We use $\\pi^*$ to denote the optimal policy. For simplicity, for a state $s \\in \\mathcal{S}$, we denote $V^*(s) = V^{\\pi^*}(s)$, and for a state-action"}, {"title": "3 Hardness Results", "content": "We prove our hardness results. In Section 3.1, we prove that the suboptimality of any RL algorithm is $\\Omega(\\mathcal{H}\\epsilon)$ if the algorithm is not allowed to take samples. This serves as a warmup for the more complicated construction in Section 3.2, where we show that for any $T$ satisfying $1 < 2T < \\mathcal{H}$, any RL algorithm requires $\\exp(\\Omega(T))$ samples in order to achieve a suboptimality of $\\Omega(\\mathcal{H}/T\\cdot \\epsilon)$."}, {"title": "3.1 Warmup: Hardness Result for RL without Samples", "content": "We prove that the suboptimality of any RL algorithm without sample is $\\Omega(\\mathcal{H}\\epsilon)$.\nTheorem 3.1. Given a MDP instance satisfying Assumption 1.1, the suboptimality of the policy returned by any RL algorithm is $\\Omega(\\mathcal{H}\\epsilon)$ with a probability of 0.99 if the algorithm is not allowed to take samples. This holds even when the dimension and sparsity satisfies $d = k = 1$ and the underlying MDP is a deterministic system.\nThe formal proof of Theorem 3.1 is given in Section A.1 in the Appendix. Below we give the construction of the hard instance together with an overview of the hardness proof.\nThe Hard Instance. Our hardness result is based on a binary tree instance. There are $\\mathcal{H}$ levels of states, and level $h \\in [\\mathcal{H}]$ contains $2^h$ distinct states. Thus we have $2^{\\mathcal{H}} - 1$ states in total. We use $s_0, ..., s_{2^{\\mathcal{H}}-2}$ to denote all the states, where $s_0$ is the unique state at level 0, and $s_1, s_2$ are the states at level 1, etc. Equivalently, $\\mathcal{S}_h = {s_{2^{h-1}},..., s_{2^{h+1}-2}}$. The action space $\\mathcal{A}$ contains two actions, $a_1$ and $a_2$. For each $h \\in [\\mathcal{H} - 1]$, a state $s_i \\in \\mathcal{S}_h$, we have $P(s_i, a_1) = s_{2i+1}$ and $P(s_i, a_2) = s_{2i+2}$.\nFor each $h \\in [\\mathcal{H}]$, there exists an action $a_h^* \\in {a_1, a_2}$, such that $\\pi^*(s) = a_h^*$ for all $s \\in \\mathcal{S}_h$. Based on $a_0^*, a_1^*,..., a_{\\mathcal{H}-1}^*$, for a state $s \\in \\mathcal{S}_h$, we define the reward function as $r(s, a) = \\epsilon$ if"}, {"title": "The Lower Bound.", "content": "Since the RL algorithm is not allowed to take samples, the only information that the algorithm receives is the feature function $\\phi$. However, $\\phi$ is always the same no matter how we set $a_0^*, a_1^*,..., a_{\\mathcal{H}-1}^*$, which means the RL algorithm can only output a fixed policy. On the other hand, if $a_h^*$ is drawn uniformly at random from $\\{a_1, a_2\\}$, for any fixed policy $\\pi$, its expected suboptimality will be $\\mathcal{H}\\epsilon/2$, which proves Theorem 3.1. Our formal proof in Section A.1 of the Supplementary Material is based on Yao's minimax principle in order to cope with randomized algorithms."}, {"title": "3.2 Hardness Result for RL with Samples", "content": "In this section, we show that for any $1 < 2T < \\mathcal{H}$, any RL algorithm requires $\\exp(\\Omega(T))$ samples in order to achieve a suboptimality of $\\Omega(\\mathcal{H}/T\\cdot \\epsilon)$.\nTheorem 3.2. Given a RL problem instance satisfying Assumption 1.1 and $1 < 2T < \\mathcal{H}$, any algorithm that returns a policy with suboptimality less than $\\mathcal{H}/(2T) \\cdot \\epsilon$ with probability at least $0.9$ needs least $0.1 \\cdot T \\cdot 2^{T}$ samples.\nIn the remaining part of this section, we give an overview of the proof of Theorem 3.2. We first define the MULTI-INDEX-QUERY problem, which can be seen as a direct product version of the INDEX-QUERY problem introduced in Du et al. [2020]."}, {"title": "Definition 3.3. (MULTI-INDEX-QUERY)", "content": "In the $m$-INDQ$_n$ problem, we have a sequence of $m$ indices $(i_0^*, i_1^*,..., i_{m-1}^*) \\in [n]^m$. In each round, the algorithm guesses a pair $(j, i) \\in [m] \\times [n]$ and queries whether $i_j = i$. The goal is to output $(j, i_j^*)$ for any $j \\in [m]$, using as few queries as possible."}, {"title": "Definition 3.4. ($\\delta$-correct)", "content": "For $\\delta \\in (0, 1)$, we say a randomized algorithm $\\mathcal{A}$ is $\\delta$-correct for $m$-INDQ$_n$ if for any $i^* = \\{i_j^*\\}_{j \\in [m]}$, with probability at least $1 - \\delta$, $\\mathcal{A}$ outputs $(j, i_j^*)$ for some $j$.\nWe first prove a query complexity lower bound for solving $m$-INDQ$_n$."}, {"title": "Lemma 3.5.", "content": "Any $0.1$-correct algorithm that solves $m$-INDQ$_n$ requires at least $0.9n$ queries."}, {"title": "4 Main Algorithm", "content": "Algorithm 1: Elimination Algorithm for Finding the Optimal Hypotheses\nInput: feature map $\\phi$, sparsity $k$, approximation error $\\epsilon$, statistical error $\\epsilon_{\\text{stat}}$ and $\\epsilon_{\\text{net}}$, failure rate $\\delta$\nFor each $h \\in [\\mathcal{H}]$, initialize $\\mathcal{P}_{h} = \\mathcal{P}_{0}^{h} = {\\theta : \\theta_{M} \\in \\mathcal{N}^{k}, |M| = k, M \\subseteq [d]}$, where $\\mathcal{N}^{k}$ is the maximal $\\epsilon_{\\text{net}}/2$-separated subset of the Euclidean sphere $\\mathbb{S}^{k}$.\nCalculate $m = \\frac{16 k \\ln \\left((1+4 / \\epsilon_{\\text {net}}) d\\right)+16 \\ln (\\mathcal{H} / \\delta)}{\\epsilon_{\\text{stat }}^{2}}$\nfor iteration $t = 0, 1, 2, \\ldots$ do\nChoose $\\theta^{t} = \\underset{\\theta \\in \\mathcal{P}_{0}^{0}}{\\operatorname{argmax}} V_{\\theta_{0}}(s_{0})$.\nfor $h = 1, 2, \\ldots, \\mathcal{H} - 1$ do\nDefine a policy $\\pi_{\\theta^{t, h}}$, where $\\pi_{\\theta^{t, h}}(s) = \\pi_{\\theta_{h'}^{t, h}}(s)$ if $s \\in \\mathcal{S}_{h'}$ with $h' < h$, and arbitrary otherwise. Collect $m$ trajectories following $\\pi_{\\theta^{t, h}}$ as a dataset\n$\\mathcal{D}_{h}^{t} = \\{(s_{0}, a_{0}, r_{0}, \\ldots, s_{\\mathcal{H}-1}, a_{\\mathcal{H}-1}, r_{\\mathcal{H}-1})\\}_{i \\in [m]}$.\nChoose $\\theta_{h}^{t} = \\underset{\\theta \\in \\mathcal{P}_{h}^{t}}{\\operatorname{argmax}} \\underset{\\mathcal{D}_{h}^{t}[m]}{\\Sigma i \\in[m]} V_{\\theta}(s_{h})$, where $s_{h}^{i}$ are from dataset $\\mathcal{D}_{h}^{t}$.\nend for\nCollect $m$ trajectories following a policy $\\pi^{t} = \\pi_{\\theta^{t}}$ as a dataset\n$\\mathcal{D}^{t} = \\{(s_{0}, a_{0}, r_{0}, \\ldots, s_{\\mathcal{H}-1}, a_{\\mathcal{H}-1}, r_{\\mathcal{H}-1})\\}_{i \\in [m]}$.\nFor each $h \\in [\\mathcal{H}]$, calculate using dataset $\\mathcal{D}^{t}$:\n$\\hat{E}_{h}^{t} = \\begin{cases}\\frac{1}{m} \\sum_{i=1}^{m} \\left(\\left\\langle \\phi(s_{h-1}^{i}, a_{h-1}^{i}), \\theta_{h-1}^{t} \\right\\rangle - r(s_{h-1}^{i}, a_{h-1}^{i}) - V_{\\theta_{h+1}^{t}}(s_{h+1}^{i})\\right), & \\text{if } h \\in [\\mathcal{H}-1] \\\\\n\\frac{1}{m} \\sum_{i=1}^{m} \\left(\\left\\langle \\phi(s_{\\mathcal{H}-1}^{i}, a_{\\mathcal{H}-1}^{i}), \\theta_{\\mathcal{H}-1}^{t} \\right\\rangle - r(s_{\\mathcal{H}-1}^{i}, a_{\\mathcal{H}-1}^{i})\\right), & \\text{if } h = \\mathcal{H} - 1\\end{cases}$\nif $\\hat{E}_{h}^{t} \\leq 2 \\epsilon + 2 \\epsilon_{\\text {net}} + 3 \\epsilon_{\\text {stat}}$ for each $h \\in [\\mathcal{H} - 1]$, and $\\hat{E}_{\\mathcal{H}-1}^{t} \\leq \\epsilon + \\epsilon_{\\text {net}} + \\epsilon_{\\text {stat}}$ then\nTerminate and output $\\pi_{\\theta^{t}}$.\nelse\nUpdate $\\mathcal{P}_{h} = \\mathcal{P}_{h} \\backslash {\\theta_{h}^{t}\\}$, for all $h \\in [\\mathcal{H} - 1]$ satisfying $\\hat{E}_{h}^{t} \\leq 2 \\epsilon + 2 \\epsilon_{\\text {net}} + 3 \\epsilon_{\\text {stat}}$, or $h = \\mathcal{H} - 1$ satisfying $\\hat{E}_{\\mathcal{H}-1}^{t} \\leq \\epsilon + \\epsilon_{\\text {net}} + \\epsilon_{\\text {stat}}$.\nend if\nend for\nOverview. Here we give an overview of the design of Algorithm 1.\nFirst, we approximate all candidate parameter $\\theta$ with a finite set by creating a maximal $\\epsilon_{\\text{net}}/2$-separated subset of the euclidean sphere $\\mathbb{S}^{k-1}$, denoted by $\\mathcal{N}^{k}$, and a set of all $k$-sized subset of $[d]$. Then, for each $h \\in [\\mathcal{H}]$, we maintain a set of parameter candidates $\\mathcal{P}_{h}$. Initially, $\\mathcal{P}_{h}$"}, {"title": "A Proofs in Section 3", "content": "We prove our hardness results. In Section 3.1, we prove that the suboptimality of any RL algorithm is $\\Omega(\\mathcal{H}\\epsilon)$ if the algorithm is not allowed to take samples. This serves as a warmup for the more complicated construction in Section 3.2, where we show that for any $T$ satisfying $1 < 2T < \\mathcal{H}$, any RL algorithm requires $\\exp(\\Omega(T))$ samples in order to achieve a suboptimality of $\\Omega(\\mathcal{H}/T\\cdot \\epsilon)$."}, {"title": "A.1 Proof of Theorem 3.1", "content": "Proof. Consider an input distribution where $a_h^*$ is drawn uniformly random from $\\{a_1, a_2\\}$. By Yao's minimax principle, it suffices to consider the best deterministic algorithm, say $A$. Note that, since we have no sampling ability, a deterministic algorithm in this setting can be seen as a function that takes in feature function $\\phi$ and returns a policy $\\pi$. Also, for all instances supported by this distribution, their inputs $\\phi$ are the same. Thus, the policy returned by $A$ is fixed. Denote the policy as $\\pi$, and denote the trajectory following $\\pi$ as $(s_0, a_0, r_0, s_1, a_1, r_1,..., s_{\\mathcal{H}-1}, a_{\\mathcal{H}-1}, r_{\\mathcal{H}-1})$. The suboptimality of $\\pi$ can be written as\n$V^* - V^{\\pi} = \\sum_{h=0}^{\\mathcal{H}-1} \\epsilon\\cdot\\mathbb{I}[a_h^* \\neq a_h]$\nSince $a_h$ is fixed and $a_h^*$ is drawn uniformly random from $\\{a_1, a_2\\}$, $\\mathbb{I}[a_h^* \\neq a_h] = 1$ with probability $1/2$. Thus, $(V^* - V^{\\pi})/\\epsilon$ is a binomial random variable, or $(V^* - V^{\\pi})/\\epsilon \\sim B(\\mathcal{H}, 1/2)$. The expectation of $(V^* - V^{\\pi})$ is then $\\mathcal{H}\\epsilon/2$, and its variance is $\\mathcal{H}\\epsilon^2/4$. Using Chebyshev inequality, with probability 0.99, we have\n$V^* - V^{\\pi} > \\frac{1}{2} \\mathcal{H}\\epsilon - 5 \\epsilon \\sqrt{\\mathcal{H}} = \\Omega(\\mathcal{H}\\epsilon)$\nfor sufficiently large $\\mathcal{H} > 100$."}, {"title": "A.2 Proof of Lemma 3.5", "content": "Proof. Consider an input distribution where $i^* = (i_0^*"}, {"title": "Misspecified Q-Learning with Sparse Linear Function Approximation: Tight Bounds on Approximation Error", "authors": ["Ally Yalei Du", "Lin F. Yang", "Ruosong Wang"], "abstract": "The recent work by Dong and Yang [2023] showed for misspecified sparse linear bandits, one can obtain an $O(\\epsilon)$-optimal policy using a polynomial number of samples when the sparsity is a constant, where $\\epsilon$ is the misspecification error. This result is in sharp contrast to misspecified linear bandits without sparsity, which require an exponential number of samples to get the same guarantee. In order to study whether the analog result is possible in the reinforcement learning setting, we consider the following problem: assuming the optimal Q-function is a $d$-dimensional linear function with sparsity $k$ and misspecification error $\\epsilon$, whether we can obtain an $O(\\mathcal{H}\\epsilon)$-optimal policy using number of samples polynomially in the feature dimension $d$. We first demonstrate why the standard approach based on Bellman backup or the existing optimistic value function elimination approach such as OLIVE [Jiang et al., 2017] achieves suboptimal guarantees for this problem. We then design a novel elimination-based algorithm to show one can obtain an $O(\\mathcal{H}\\epsilon)$-optimal policy with sample complexity polynomially in the feature dimension $d$ and planning horizon $\\mathcal{H}$. Lastly, we complement our upper bound with an $\\Omega(\\mathcal{H}\\epsilon)$ suboptimality lower bound, giving a complete picture of this problem.", "sections": [{"title": "1 Introduction", "content": "Bandit and reinforcement learning (RL) problems in real-world applications, such as autonomous driving [Kiran et al., 2021], healthcare [Esteva et al., 2019], recommendation systems [Bouneffouf et al., 2012], and advertising [Schwartz et al., 2017], face challenges due to the vast state-action space. To tackle this, function approximation frameworks, such as using linear functions or neural networks, have been introduced to approximate the value functions or policies. However, real-world complexities often mean that function approximation is agnostic; the function class captures only an approximate version of the optimal value function, and the misspecification error remains unknown. A fundamental problem is understanding the impact of agnostic misspecification errors in RL.\nPrior works show even minor misspecifications can lead to exponential (in dimension) sample complexity in the linear bandit settings [Du et al., 2020, Lattimore et al., 2020] if the goal is to learn a policy within the misspecification error. That is, finding an $O(\\epsilon)$-optimal action necessitates at least $(\\exp(d))$ queries (or samples) to the environment, where $\\epsilon$ is the misspecification error. Recently, Dong and Yang [2023] demonstrated that, by leveraging the sparsity structure of ground-truth parameters, one can overcome the exponential sample barrier in the linear bandit setting. They showed that with sparsity $k$ in the ground-truth parameters, it is possible to learn an $O(\\epsilon)$-optimal action with only $O((d/\\epsilon)^k)$ samples. In particular, when $k$ is a constant, their algorithm achieves a polynomial sample complexity guarantee."}, {"title": "1.1 Our Contributions", "content": "In this paper, we propose an RL algorithm that can handle linear function approximation with sparsity structures and misspecification errors. We also show that the suboptimality achieved by our algorithm is near-optimal, by proving information-theoretic hardness results. Here we give a more detailed description of our technical contributions.\nOur Assumption. Throughout this paper, we assume the RL algorithm has access to a feature map $\\phi$ where, for each state-action pair $(s, a)$, we have the feature $\\phi(s, a)$ with $|\\phi(s, a)| \\leq 1$. We make the following assumption, which states that there exists a sequence of parameters $\\theta^* = (\\theta^*_0,..., \\theta^*_{\\mathcal{H}-1})$ where each $\\theta^*_h \\in \\mathbb{R}^{d-1}$ is $k$-sparse, that approximates the optimal Q-function up to an error of $\\epsilon$.\nAssumption 1.1. There exists $\\theta^* = (\\theta^*_0,..., \\theta^*_{\\mathcal{H}-1})$ where each $\\theta^*_h \\in \\mathbb{R}^{d-1}$ is $k$-sparse, such that\n$|\\langle \\phi(s, a), \\theta^*_h \\rangle - Q^*(s, a)| \\leq \\epsilon$\nfor all $h \\in [\\mathcal{H}]$, all states $s$ in level $h$, and all actions $a$ in the action space.\nWe can approximate $\\theta^*$ using an $\\epsilon$-net of the sphere $\\mathbb{S}^{k-1}$ and the set of all $k$-sized subset of $[d]$. Therefore, when $k$ is a constant, we may assume that each $\\theta^*_h$ lies in a set with size polynomial in $d$. Then, a natural idea is to enumerate all possible policies induced by the parameters in that finite set, and choose the one with the highest cumulative reward. However, although the number of parameter candidates in each individual level has polynomial size, the total number of induced policies would be exponential in $\\mathcal{H}$, and the sample complexity of such an approach would also be exponential in $\\mathcal{H}$.\nThe Level-by-level Approach. Note that when the horizon length $\\mathcal{H} = 1$, the problem under consideration is equivalent to a bandit problem, which can be solved by previous approaches [Dong and Yang, 2023]. For the RL setting, a natural idea is to first apply the bandit algorithm in Dong and Yang [2023] on the last level, and then apply the same bandit algorithm on the second last level based on previous results and Bellman-backups, and so on. However, we note that to employ such an approach, the bandit algorithm needs to provide a \"for-all\" guarantee, i.e., finding a parameter $\\theta$ that approximates the rewards of all arms, instead of just finding a near-optimal arm. On the other hand, existing bandit algorithms will amplify the approximation error of the input parameters by a constant factor, in order to provide a for-all guarantee. Concretely, existing bandit algorithms can only find a parameter $\\theta$ so that $\\theta$ approximates the rewards of all arms by an error of $2\\epsilon$. As we have $\\mathcal{H}$ levels in the RL setting, the final error would be exponential in $\\mathcal{H}$, and therefore, such a level-by-level approach would result in a suboptimality that is exponential in $\\mathcal{H}$.\nOne may ask if we can further improve existing bandit algorithms, so that we can find a parameter $\\theta$ that approximates the rewards of all arms by an error of $\\epsilon$ plus a statistical error that can be made arbitrarily small, instead of $2\\epsilon$. The following theorem shows that this is information-theoretically impossible unless one pays a sample complexity proportional to the size of the action space."}, {"title": "Theorem 1.2.", "content": "Under Assumption 1.1 with $d = k = 1$, any bandit algorithm that returns an estimate $\\hat{r}$ such that $|r(a) - \\hat{r}(a)| < 2\\epsilon$ for all arms $a$ with probability at least $0.95$ requires at least $0.9n$ samples, where $n$ is the total number of arms.\nTherefore, amplifying the approximation error by a factor of 2 is not an artifact of existing bandit algorithms. Instead, it is information-theoretically impossible.\nGeometric error amplification is a common issue in the design of RL algorithm with linear function approximation [Zanette et al., 2019, Weisz et al., 2021, Wang et al., 2020a, 2021]. It is interesting (and also surprising) that such an issue arises even when the function class has sparsity structures."}, {"title": "Optimistic Value Function Elimination.", "content": "Another approach for the design of RL algorithm is based on optimistic value function elimination. Such an approach was proposed by Jiang et al. [2017] and was then generalized to broader settings [Sun et al., 2019, Du et al., 2021, Jin et al., 2021, Chen et al., 2022b]. At each iteration of the algorithm, we pick the value functions in the hypothesis class with maximized value. We then use the induced policy to collect a dataset, based on which we eliminate a bunch of value functions from the hypothesis class and proceed to the next iteration.\nWhen applied to our setting, existing algorithms and analysis achieve a suboptimality that depends on the size of the parameter class, which could be prohibitively large. Here, we use the result in Jiang et al. [2017] as an example. The suboptimality of their algorithm is $\\mathcal{H}\\sqrt{M}\\epsilon$, where $M$ is Bellman rank of the problem. For our setting, we can show that there exists an MDP instance and a feature map that satisfies Assumption 1.1, whose induced Bellman rank is large."}, {"title": "Proposition 1.3.", "content": "There exists an MDP instance $\\mathcal{M} = (\\mathcal{S}, \\mathcal{A}, \\mathcal{H}, P, r)$ with $|\\mathcal{A}| = 2$, $\\mathcal{H} = \\log d$, $|\\mathcal{S}| = d - 1$, with $d$-dimensional feature map $\\phi$ satisfying Assumption 1.1 with $k = 1$, such that its Bellman rank is $d$.\nGiven Proposition 1.3, if one na\u00efvely applies the algorithm in Jiang et al. [2017], the suboptimality would be $O(\\mathcal{H}\\sqrt{d}\\epsilon)$ in our setting, which necessitates new algorithm and analysis. In Section 4, we design a new RL algorithm whose performance is summarized in the following theorem."}, {"title": "Theorem 1.4.", "content": "Under Assumption 1.1, with probability at least $1 - \\delta$, Algorithm 1 returns a policy with suboptimality at most $(4\\epsilon_{\\text{stat}}+2\\epsilon_{\\text{net}}+2\\epsilon)^{\\mathcal{H}}$ by taking $O\\left(k d^{k} \\mathcal{H}^{3} \\cdot \\ln \\left(\\frac{d \\mathcal{H}}{\\epsilon_{\\text{net}} \\delta}\\right) \\cdot \\frac{1}{\\epsilon_{\\text{net}} \\epsilon_{\\text{stat}}}\\right)$ samples.\nHere $\\epsilon_{\\text{stat}}$ is the statistical error. Compared to the existing approaches, Theorem 1.4 achieves a much stronger suboptimality guarantee. Later, we will also show that such a guarantee is near-optimal.\nAlthough based on the same idea of optimistic value function elimination, our proposed algorithm differs significantly from existing approaches [Jiang et al., 2017, Sun et al., 2019, Du et al., 2021, Jin et al., 2021, Chen et al., 2022b] to exploit the sparsity structure. While existing approaches based on optimistic value function elimination try to find a sequence of parameters that maximize the value of the initial states, our new algorithm selects a parameter that maximizes the empirical roll-in distribution at all levels. Also, existing algorithms eliminate a large set of parameters in each iteration, while we only eliminate the parameters selected during the current iteration in our algorithm.\nThese two modifications are crucial for obtaining a smaller suboptimality guarantee, smaller sample complexity, and shorter running time. In existing algorithms, parameters at different levels are interdependent, i.e. the choice of parameter at level $h$ affects the choice of parameter at level $h + 1$. Our new algorithm simplifies this by maintaining a parameter set for each level, so each level operates independently. Further, we can falsify and eliminate any parameter showing"}, {"title": "The Hardness Result.", "content": "One may wonder if the suboptimality guarantee can be further improved. In Section 3, we show that the suboptimality guarantee by Theorem 1.4 is near-optimal.\nWe first consider a weaker setting where the algorithm is not allowed to take samples, and the function class contains a single sequence of functions. I.e., we are given a function $Q : \\mathcal{S} \\times \\mathcal{A} \\rightarrow \\mathbb{R}$, such that $|Q(s, a) - Q^*(s, a)| \\leq \\epsilon$ for all $(s, a) \\in \\mathcal{S} \\times \\mathcal{A}$.\nWe show that for this weaker setting, simply choosing the greedy policy with respect to $Q$, which achieves a suboptimality guarantee of $O(\\mathcal{H}\\epsilon)$, is actually optimal. To prove this, we construct a hard instance based on a binary tree. Roughly speaking, the optimal action for each level is chosen uniformly random from two actions $a_1$ and $a_2$. At all levels, the reward is $\\epsilon$ if the optimal action is chosen, and is $0$ otherwise. For this instance, there exists a fixed $Q$ that provides a good approximation to the optimal $Q$-function, regardless of the choice of the optimal actions. Therefore, $Q$ reveals no information about the optimal actions, and the suboptimality of the returned policy would be at least $\\Omega(\\mathcal{H}\\epsilon)$. The formal construction and analysis and construction will be given in Section 3.1.\nWhen the algorithm is allowed to take samples, we show that in order to achieve a suboptimality guarantee of $\\mathcal{H}/T\\epsilon$, any algorithm requires $\\exp(\\Omega(T))$ samples, even when Assumption 1.1 is satisfied with $d = k = 1$. Therefore, for RL algorithms with polynomial sample complexity, the suboptimality guarantee of Theorem 1.4 is tight up to log factors.\nTo prove the above claim, we still consider the setting where $d = k = 1$, i.e., a good approximation to the $Q$-function is given to the algorithm. We also use a more complicated binary tree instance, where we divide all the $\\mathcal{H}$ levels into $\\mathcal{H}/T$ blocks, each containing $T$ levels. For each block, only one state-action pair at the last level has a reward of $\\epsilon$, and all other state-action pairs in the block has a reward of $0$. Therefore, the value of the optimal policy would be $\\mathcal{H}/T \\epsilon$ since there are $\\mathcal{H}/T$ blocks in total. We further assume that there is a fixed function $Q$, which provides a good approximation to the optimal $Q$-function universally for all instances under consideration.\nSince $Q$ reveals no information about the state-action pair with $\\epsilon$ reward for all blocks, for an RL algorithm to return a policy with a non-zero value, it must search for a state-action pair with non-zero reward in a brute force manner, which inevitably incurs a sample complexity of $\\exp(\\Omega(T))$ since each block contains $T$ levels and $\\exp(\\Omega(T))$ state-action pairs at the last level. The formal construction and analysis and construction will be given in Section 3.2."}, {"title": "1.2 Related Work", "content": "A series of studies have delved into MDPs that can be represented by linear functions of predetermined feature mappings, achieving sample complexity or regret that depends on the feature mapping's dimension. This includes linear MDPs, studied in Jin et al. [2020], Wang et al. [2019], Neu and Pike-Burke [2020], where both transition probabilities and rewards are linear functions of feature mappings on state-action pairs. Zanette et al. [2020a,b] examines MDPs with low inherent Bellman error, indicating value functions that are almost linear with respect to these mappings. Another focus is on linear mixture MDPs [Modi et al., 2020, Jia et al., 2020, Ayoub et al., 2020, Zhou et al., 2021, Cai et al., 2020], characterized by transition probabilities that combine several basis kernels linearly. While these studies often assume known feature vectors, Agarwal et al. [2020] investigates a more challenging scenario where both features and parameters of the linear model are unknown."}, {"title": "2 Preliminaries", "content": "Throughout the paper, for a given positive integer $n$, we use $[n]$ to denote the set $\\{0, 1, 2, ..., n-1\\}$. In addition, $f(n) = O(g(n))$ denotes that there exists a constant $c > 0$ such that $|f(n)| \\leq c|g(n)|$. $f(n) = \\Omega(g(n))$ denotes that there exists a constant $c > 0$ such that $|f(n)| \\geq c|g(n)|."}, {"title": "2.1 Reinforcement Learning", "content": "Let $\\mathcal{M} = {\\mathcal{S}, \\mathcal{A}, \\mathcal{H}, P,r}$ be a Markov Decision Process (MDP) where $\\mathcal{S}$ is the state space, $\\mathcal{A}$ is the action space, $\\mathcal{H} \\in \\mathbb{Z}^+$ is the planning horizon, $P : \\mathcal{S} \\times \\mathcal{A} \\rightarrow \\Delta(\\mathcal{S})$ is the transition kernel which takes a state-action pair as input and returns a distribution over states, $r : \\mathcal{S} \\times \\mathcal{A} \\rightarrow \\Delta([0, 1])$ is the reward distribution. We assume $\\sum_{h \\in [\\mathcal{H}]} r_h \\in [0, 1]$ almost surely. For simplicity, throughout this paper, we assume the initial state $s_0$ is deterministic. To streamline our analysis, for each $h \\in [\\mathcal{H}]$, we use $\\mathcal{S}_h \\subseteq \\mathcal{S}$ to denote the set of states at level $h$, and assume $\\mathcal{S}_h$ do not intersect with each other.\nA policy $\\pi : \\mathcal{S} \\rightarrow \\mathcal{A}$ chooses an action for each state, and may induce a trajectory denoted by $(s_0, a_0, r_0,..., s_{\\mathcal{H}-1}, a_{\\mathcal{H}-1}, r_{\\mathcal{H}-1})$, where $s_{h+1} \\sim P(s_h, a_h)$, $a_h = \\pi(s_h)$, and $r_h \\sim r(s_h, a_h)$ for all $h \\in [\\mathcal{H}]$. Given a policy $\\pi$ and $h \\in [\\mathcal{H}]$, for a state-action pair $(s, a) \\in \\mathcal{S}_h \\times \\mathcal{A}$, the Q-function and value function is defined as\n$Q^{\\pi}(s, a) = \\mathbb{E} \\left[ \\sum_{h'=h}^{\\mathcal{H}-1} r(s_{h'}, a_{h'}) | s_h = s, a_h = a, \\pi \\right], \\quad V^{\\pi}(s) = \\mathbb{E} \\left[ \\sum_{h'=h}^{\\mathcal{H}-1} r(s_{h'}, a_{h'}) | s_h = s, \\pi \\right]$\nWe use $V^{\\pi}$ to denote the value of the policy $\\pi$, i.e., $V^{\\pi} = V^{\\pi}(s_0)$. We use $\\pi^*$ to denote the optimal policy. For simplicity, for a state $s \\in \\mathcal{S}$, we denote $V^*(s) = V^{\\pi^*}(s)$, and for a state-action"}, {"title": "3 Hardness Results", "content": "We prove our hardness results. In Section 3.1, we prove that the suboptimality of any RL algorithm is $\\Omega(\\mathcal{H}\\epsilon)$ if the algorithm is not allowed to take samples. This serves as a warmup for the more complicated construction in Section 3.2, where we show that for any $T$ satisfying $1 < 2T < \\mathcal{H}$, any RL algorithm requires $\\exp(\\Omega(T))$ samples in order to achieve a suboptimality of $\\Omega(\\mathcal{H}/T\\cdot \\epsilon)$."}, {"title": "3.1 Warmup: Hardness Result for RL without Samples", "content": "We prove that the suboptimality of any RL algorithm without sample is $\\Omega(\\mathcal{H}\\epsilon)$.\nTheorem 3.1. Given a MDP instance satisfying Assumption 1.1, the suboptimality of the policy returned by any RL algorithm is $\\Omega(\\mathcal{H}\\epsilon)$ with a probability of 0.99 if the algorithm is not allowed to take samples. This holds even when the dimension and sparsity satisfies $d = k = 1$ and the underlying MDP is a deterministic system.\nThe formal proof of Theorem 3.1 is given in Section A.1 in the Appendix. Below we give the construction of the hard instance together with an overview of the hardness proof.\nThe Hard Instance. Our hardness result is based on a binary tree instance. There are $\\mathcal{H}$ levels of states, and level $h \\in [\\mathcal{H}]$ contains $2^h$ distinct states. Thus we have $2^{\\mathcal{H}} - 1$ states in total. We use $s_0, ..., s_{2^{\\mathcal{H}}-2}$ to denote all the states, where $s_0$ is the unique state at level 0, and $s_1, s_2$ are the states at level 1, etc. Equivalently, $\\mathcal{S}_h = {s_{2^{h-1}},..., s_{2^{h+1}-2}}$. The action space $\\mathcal{A}$ contains two actions, $a_1$ and $a_2$. For each $h \\in [\\mathcal{H} - 1]$, a state $s_i \\in \\mathcal{S}_h$, we have $P(s_i, a_1) = s_{2i+1}$ and $P(s_i, a_2) = s_{2i+2}$.\nFor each $h \\in [\\mathcal{H}]$, there exists an action $a_h^* \\in {a_1, a_2}$, such that $\\pi^*(s) = a_h^*$ for all $s \\in \\mathcal{S}_h$. Based on $a_0^*, a_1^*,..., a_{\\mathcal{H}-1}^*$, for a state $s \\in \\mathcal{S}_h$, we define the reward function as $r(s, a) = \\epsilon$ if"}, {"title": "The Lower Bound.", "content": "Since the RL algorithm is not allowed to take samples, the only information that the algorithm receives is the feature function $\\phi$. However, $\\phi$ is always the same no matter how we set $a_0^*, a_1^*,..., a_{\\mathcal{H}-1}^*$, which means the RL algorithm can only output a fixed policy. On the other hand, if $a_h^*$ is drawn uniformly at random from $\\{a_1, a_2\\}$, for any fixed policy $\\pi$, its expected suboptimality will be $\\mathcal{H}\\epsilon/2$, which proves Theorem 3.1. Our formal proof in Section A.1 of the Supplementary Material is based on Yao's minimax principle in order to cope with randomized algorithms."}, {"title": "3.2 Hardness Result for RL with Samples", "content": "In this section, we show that for any $1 < 2T < \\mathcal{H}$, any RL algorithm requires $\\exp(\\Omega(T))$ samples in order to achieve a suboptimality of $\\Omega(\\mathcal{H}/T\\cdot \\epsilon)$.\nTheorem 3.2. Given a RL problem instance satisfying Assumption 1.1 and $1 < 2T < \\mathcal{H}$, any algorithm that returns a policy with suboptimality less than $\\mathcal{H}/(2T) \\cdot \\epsilon$ with probability at least $0.9$ needs least $0.1 \\cdot T \\cdot 2^{T}$ samples.\nIn the remaining part of this section, we give an overview of the proof of Theorem 3.2. We first define the MULTI-INDEX-QUERY problem, which can be seen as a direct product version of the INDEX-QUERY problem introduced in Du et al. [2020]."}, {"title": "Definition 3.3. (MULTI-INDEX-QUERY)", "content": "In the $m$-INDQ$_n$ problem, we have a sequence of $m$ indices $(i_0^*, i_1^*,..., i_{m-1}^*) \\in [n]^m$. In each round, the algorithm guesses a pair $(j, i) \\in [m] \\times [n]$ and queries whether $i_j = i$. The goal is to output $(j, i_j^*)$ for any $j \\in [m]$, using as few queries as possible."}, {"title": "Definition 3.4. ($\\delta$-correct)", "content": "For $\\delta \\in (0, 1)$, we say a randomized algorithm $\\mathcal{A}$ is $\\delta$-correct for $m$-INDQ$_n$ if for any $i^* = \\{i_j^*\\}_{j \\in [m]}$, with probability at least $1 - \\delta$, $\\mathcal{A}$ outputs $(j, i_j^*)$ for some $j$.\nWe first prove a query complexity lower bound for solving $m$-INDQ$_n$."}, {"title": "Lemma 3.5.", "content": "Any $0.1$-correct algorithm that solves $m$-INDQ$_n$ requires at least $0.9n$ queries."}, {"title": "4 Main Algorithm", "content": "Algorithm 1: Elimination Algorithm for Finding the Optimal Hypotheses\nInput: feature map $\\phi$, sparsity $k$, approximation error $\\epsilon$, statistical error $\\epsilon_{\\text{stat}}$ and $\\epsilon_{\\text{net}}$, failure rate $\\delta$\nFor each $h \\in [\\mathcal{H}]$, initialize $\\mathcal{P}_{h} = \\mathcal{P}_{0}^{h} = {\\theta : \\theta_{M} \\in \\mathcal{N}^{k}, |M| = k, M \\subseteq [d]}$, where $\\mathcal{N}^{k}$ is the maximal $\\epsilon_{\\text{net}}/2$-separated subset of the Euclidean sphere $\\mathbb{S}^{k}$.\nCalculate $m = \\frac{16 k \\ln \\left((1+4 / \\epsilon_{\\text {net}}) d\\right)+16 \\ln (\\mathcal{H} / \\delta)}{\\epsilon_{\\text{stat }}^{2}}$\nfor iteration $t = 0, 1, 2, \\ldots$ do\nChoose $\\theta^{t} = \\underset{\\theta \\in \\mathcal{P}_{0}^{0}}{\\operatorname{argmax}} V_{\\theta_{0}}(s_{0})$.\nfor $h = 1, 2, \\ldots, \\mathcal{H} - 1$ do\nDefine a policy $\\pi_{\\theta^{t, h}}$, where $\\pi_{\\theta^{t, h}}(s) = \\pi_{\\theta_{h'}^{t, h}}(s)$ if $s \\in \\mathcal{S}_{h'}$ with $h' < h$, and arbitrary otherwise. Collect $m$ trajectories following $\\pi_{\\theta^{t, h}}$ as a dataset\n$\\mathcal{D}_{h}^{t} = \\{(s_{0}, a_{0}, r_{0}, \\ldots, s_{\\mathcal{H}-1}, a_{\\mathcal{H}-1}, r_{\\mathcal{H}-1})\\}_{i \\in [m]}$.\nChoose $\\theta_{h}^{t} = \\underset{\\theta \\in \\mathcal{P}_{h}^{t}}{\\operatorname{argmax}} \\underset{\\mathcal{D}_{h}^{t}[m]}{\\Sigma i \\in[m]} V_{\\theta}(s_{h})$, where $s_{h}^{i}$ are from dataset $\\mathcal{D}_{h}^{t}$.\nend for\nCollect $m$ trajectories following a policy $\\pi^{t} = \\pi_{\\theta^{t}}$ as a dataset\n$\\mathcal{D}^{t} = \\{(s_{0}, a_{0}, r_{0}, \\ldots, s_{\\mathcal{H}-1}, a_{\\mathcal{H}-1}, r_{\\mathcal{H}-1})\\}_{i \\in [m]}$.\nFor each $h \\in [\\mathcal{H}]$, calculate using dataset $\\mathcal{D}^{t}$:\n$\\hat{E}_{h}^{t} = \\begin{cases}\\frac{1}{m} \\sum_{i=1}^{m} \\left(\\left\\langle \\phi(s_{h-1}^{i}, a_{h-1}^{i}), \\theta_{h-1}^{t} \\right\\rangle - r(s_{h-1}^{i}, a_{h-1}^{i}) - V_{\\theta_{h+1}^{t}}(s_{h+1}^{i})\\right), & \\text{if } h \\in [\\mathcal{H}-1] \\\\\n\\frac{1}{m} \\sum_{i=1}^{m} \\left(\\left\\langle \\phi(s_{\\mathcal{H}-1}^{i}, a_{\\mathcal{H}-1}^{i}), \\theta_{\\mathcal{H}-1}^{t} \\right\\rangle - r(s_{\\mathcal{H}-1}^{i}, a_{\\mathcal{H}-1}^{i})\\right), & \\text{if } h = \\mathcal{H} - 1\\end{cases}$\nif $\\hat{E}_{h}^{t} \\leq 2 \\epsilon + 2 \\epsilon_{\\text {net}} + 3 \\epsilon_{\\text {stat}}$ for each $h \\in [\\mathcal{H} - 1]$, and $\\hat{E}_{\\mathcal{H}-1}^{t} \\leq \\epsilon + \\epsilon_{\\text {net}} + \\epsilon_{\\text {stat}}$ then\nTerminate and output $\\pi_{\\theta^{t}}$.\nelse\nUpdate $\\mathcal{P}_{h} = \\mathcal{P}_{h} \\backslash {\\theta_{h}^{t}\\}$, for all $h \\in [\\mathcal{H} - 1]$ satisfying $\\hat{E}_{h}^{t} \\leq 2 \\epsilon + 2 \\epsilon_{\\text {net}} + 3 \\epsilon_{\\text {stat}}$, or $h = \\mathcal{H} - 1$ satisfying $\\hat{E}_{\\mathcal{H}-1}^{t} \\leq \\epsilon + \\epsilon_{\\text {net}} + \\epsilon_{\\text {stat}}$.\nend if\nend for\nOverview. Here we give an overview of the design of Algorithm 1.\nFirst, we approximate all candidate parameter $\\theta$ with a finite set by creating a maximal $\\epsilon_{\\text{net}}/2$-separated subset of the euclidean sphere $\\mathbb{S}^{k-1}$, denoted by $\\mathcal{N}^{k}$, and a set of all $k$-sized subset of $[d]$. Then, for each $h \\in [\\mathcal{H}]$, we maintain a set of parameter candidates $\\mathcal{P}_{h}$. Initially, $\\mathcal{P}_{h}$"}, {"title": "A Proofs in Section 3", "content": "We prove our hardness results. In Section 3.1, we prove that the suboptimality of any RL algorithm is $\\Omega(\\mathcal{H}\\epsilon)$ if the algorithm is not allowed to take samples. This serves as a warmup for the more complicated construction in Section 3.2, where we show that for any $T$ satisfying $1 < 2T < \\mathcal{H}$, any RL algorithm requires $\\exp(\\Omega(T))$ samples in order to achieve a suboptimality of $\\Omega(\\mathcal{H}/T\\cdot \\epsilon)$."}, {"title": "A.1 Proof of Theorem 3.1", "content": "Proof. Consider an input distribution where $a_h^*$ is drawn uniformly random from $\\{a_1, a_2\\}$. By Yao's minimax principle, it suffices to consider the best deterministic algorithm, say $A$. Note that, since we have no sampling ability, a deterministic algorithm in this setting can be seen as a function that takes in feature function $\\phi$ and returns a policy $\\pi$. Also, for all instances supported by this distribution, their inputs $\\phi$ are the same. Thus, the policy returned by $A$ is fixed. Denote the policy as $\\pi$, and denote the trajectory following $\\pi$ as $(s_0, a_0, r_0, s_1, a_1, r_1,..., s_{\\mathcal{H}-1}, a_{\\mathcal{H}-1}, r_{\\mathcal{H}-1})$. The suboptimality of $\\pi$ can be written as\n$V^* - V^{\\pi} = \\sum_{h=0}^{\\mathcal{H}-1} \\epsilon\\cdot\\mathbb{I}[a_h^* \\neq a_h]$\nSince $a_h$ is fixed and $a_h^*$ is drawn uniformly random from $\\{a_1, a_2\\}$, $\\mathbb{I}[a_h^* \\neq a_h] = 1$ with probability $1/2$. Thus, $(V^* - V^{\\pi})/\\epsilon$ is a binomial random variable, or $(V^* - V^{\\pi})/\\epsilon \\sim B(\\mathcal{H}, 1/2)$. The expectation of $(V^* - V^{\\pi})$ is then $\\mathcal{H}\\epsilon/2$, and its variance is $\\mathcal{H}\\epsilon^2/4$. Using Chebyshev inequality, with probability 0.99, we have\n$V^* - V^{\\pi} > \\frac{1}{2} \\mathcal{H}\\epsilon - 5 \\epsilon \\sqrt{\\mathcal{H}} = \\Omega(\\mathcal{H}\\epsilon)$\nfor sufficiently large $\\mathcal{H} > 100$."}, {"title": "A.2 Proof of Lemma 3.5", "content": "Proof. Consider an input distribution where $i^* = (i_0^*, i_2^*, ..., i_{m-1}^*)$ is drawn uniformly random from $[n"}]}]}