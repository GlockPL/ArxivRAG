{"title": "SymGPT: Auditing Smart Contracts via Combining Symbolic Execution with Large Language Models", "authors": ["Shihao Xia", "Mengting He", "Tingting Yu", "Yiying Zhang", "Shuai Shao", "Linhai Song"], "abstract": "To govern smart contracts running on Ethereum, multiple Ethereum Request for Comment (ERC) standards have been developed, each having a set of rules to guide the behaviors of smart contracts. Violating the ERC rules could cause serious security issues and financial loss, signifying the importance of verifying smart contracts follow ERCs. Today's practices of such verification are to manually audit each single contract, use expert-developed program-analysis tools, or use large language models (LLMs), all of which are far from effective in identifying ERC rule violations.\nThis paper introduces SymGPT, a tool that combines the natural language understanding of large language models (LLMs) with the formal guarantees of symbolic execution to automatically verify smart contracts' compliance with ERC rules. To develop SymGPT, we conduct an empirical study of 132 ERC rules from three widely used ERC standards, examining their content, security implications, and natural language descriptions. Based on this study, we design SymGPT by first instructing an LLM to translate ERC rules into a defined EBNF grammar. We then synthesize constraints from the formalized rules to represent scenarios where violations may occur and use symbolic execution to detect them. Our evaluation shows that SymGPT identifies 5,783 ERC rule violations in 4,000 real-world contracts, including 1,375 violations with clear attack paths for stealing financial assets, demonstrating its effectiveness. Furthermore, SymGPT outperforms six automated techniques and a security-expert auditing service, underscoring its superiority over current smart contract analysis methods.", "sections": [{"title": "1 INTRODUCTION", "content": "Ethereum and ERC. Since the creation of Bitcoin, blockchain technology has evolved significantly. One of the most important developments is Ethereum [30, 73], a decentralized, open-source blockchain platform. Ethereum enables the creation and execution of decentralized applications (DApps) like financial services and smart contracts, which are self-executing agreements with the terms of the contracts directly written into code [31, 34].\nTo govern smart contracts running on Ethereum, a set of formal standards called Request for Comments (ERCs) have been developed [66]. For example, the ERC20 standard defines a common set of rules for fungible tokens-tokens (digital assets) that are interchangeable with one another [70]. ERCs play a crucial role in the Ethereum ecosystem by providing a common set of rules and specifications that developers can follow when implementing smart contracts.\ncontracts. ERCs ensure interoperability and compatibility between different Ethereum-based projects, wallets, and DApps [31].\nERC violations. The violation of an ERC rule could result in interoperability issues where a violating contract may not work properly with wallets or DApps. ERC violations could also lead to security vulnerabilities and financial loss. Additionally, ERC violations could result in de-listing of tokens from exchanges, as many exchanges have listing requirements of following ERC standards [32].\nFigure 1 shows a violation of an ERC20 rule in a real smart contract. The _balances field in line 2 monitors the number of tokens held by each address. Function transferFrom() in lines 6-10 transfers amount tokens from one address to another. ERC20 imposes multiple rules on transferFrom(), such as the necessity to fire an Transfer event for logging purposes and to treat the transfer of zero tokens the same as transferring other amounts, both of which the contract follows. However, transferFrom() violates a crucial ERC20 rule that mandates transferFrom() to verify whether its caller has the privilege to transfer amount tokens, which ensures financial security. Due to this violation, anyone can steal tokens from any address by invoking transferFrom() to transfer tokens to his address. The patch in line 7 illustrates how to fix the violation. The patch uses a two-dimensional map, allowances, to track how many tokens \"from\" allows \"msg.sender\" to manipulate. The subtraction operation in this line triggers an exception and the termination of the transaction in case of underflow, thus preventing\na caller of the function from transferring tokens if they do not have enough privilege.\nState of the art. Following ERC rules is crucial, but developers often struggle due to the need for a thorough understanding of all the requirements and corresponding contract code. ERC standards encompass numerous rules; for the three ERCs we examine, there are 132 rules in total. A single operation can involve multiple rules. For example, ERC20 requires that the public transferFrom() function of all ERC20 contracts comply with six rules, covering the function's API, return value generation, caller privilege validation, logging, and input handling. The failure to check caller privileges leads to the issue above. Additionally, ERC rules are often described in different formats, with some being code declarations and others being natural languages, further complicating compliance.\nMeanwhile, contract implementations are often complex as well. One contract and its dependent code usually contain hundreds to thousands of lines of source code in multiple files. Some code details may be obscured within intricate caller-callee relationships, while others may involve numerous objects and functionalities possibly written by different programmers. All these complexities in ERC rules and smart contracts make it extremely hard for programmers to manually check for ERC violations. As a result, ERC rule violations widely exist in real-world smart contracts [22].\nToday's practices to avoid ERC violations are on three fronts. First, program-analysis tools have been developed to automatically verify certain criteria of smart contracts [23, 47, 56, 57, 69]. These tools are limited by the types of verifications they can perform, and often fail to validate many complex ERC requirements like the rule violated in Figure 1. A fundamental reason is that many ERC rules involve semantic information (e.g., caller privileges) and require customization for individual contracts (e.g., configuring where caller privileges are stored)-a process that is time-consuming if not unfeasible. Second, there are several auditing services provided by security experts [2, 7, 15, 22, 42, 58, 65]. Although auditing services are more thorough and comprehensive than program-analysis tools, they are often costly and involve lengthy processing time, likely involving manual efforts behind the scenes. Third, there have been some primitive proposals to rely exclusively on large language models (LLMs) to check smart contracts for ERC compliance [39, 53]. Unfortunately, these techniques suffer from LLMs' hallucinations and have high false positives and false negatives, as shown in our experiments.\nOur proposal. The goal of this research is to develop a cheaper, automated, thorough, and accurate ERC rule verification approach. We believe that a well-structured method is grounded in a deep understanding of ERC rules. To this end, we commence our work with an empirical study of ERC standards. Specifically, we analyze three widely-used ERC standards and their 132 rules, focusing on the nature of these rules, the security implications of their non-compliance, and their articulation in natural language. Our study reveals four key insights that are valuable for Solidity developers, security analysts, and ERC protocol designers. Notably, we find that approximately one-sixth of ERC rules are dedicated to verifying whether an operator, token owner, or token recipient has the necessary privileges to perform specific operations. Violations of these rules can create clear attack paths, potentially leading to significant"}, {"title": "3 EMPIRICAL STUDY ON ERC RULES", "content": "This section presents our empirical study on ERC rules, including the methodology employed for the study and the categories established for the rules."}, {"title": "3.1 Methodology", "content": "From the 102 ERCs in the final status, we choose ERC20, ERC721, and ERC1155 as our study targets. We base our selection on their popularity, their complexity, and their significance in the Ethereum ecosystem.\nERC20 is a technical standard for fungible tokens (e.g., cryptocurrencies) and is the most famous ERC standard. It outlines operational requirements for minting, burning, and transferring tokens [70]. Presently, there are over 450,000 ERC20 tokens on Ethereum [9], with many boasting a market capitalization surpassing $1 billion [72, 75, 76].\nERC721 is designed for non-fungible tokens (NFTs), where each token is distinct and indivisible [29]. ERC721 specifies how ownership of NFTs is managed. As the most popular NFT standard, it is adhered to by major NFT marketplaces [55, 64].\nERC1155 aims to enable a single contract to oversee both fungible and non-fungible tokens [63]. Additionally, it facilitates batch operations. ERC1155 has found adoption in various gaming and charity donation projects [4, 6, 74].\nWe carefully review the official documents (including text descriptions and associated code) and manually identify rules by evaluating their relevance to contract implementations, whether\nthey have clear restricting targets, and whether they offer actionable checking criteria. Certain rules explicitly use terms like \"must\" or \"should\" to convey obligations. We identify a total of 132 rules across the three ERCs: 32 from ERC20, 60 from ERC721, and 40 from ERC1155. Our study primarily answers three key questions regarding the identified rules: 1) what rules are specified? 2) why are they specified? and 3) how are they specified in natural languages? The objective is to garner insights for building techniques to automatically detect rule violations. To maintain objectivity, all study results are examined by at least two paper authors."}, {"title": "3.2 Rule Content (What)", "content": "An ERC rule generally requires that a public function includes a specific piece of code. Based on the semantic nature of the code, we classify the rules into four categories.\nPrivilege Checks. 24 rules delineate the necessary privileges for executing specific token operations. Regarding the pattern of required code, 20 rules involve performing a condition check and throwing an exception if the check fails, while others require calling a function for a subsequent check. We further analyze the object being checked in each rule. Among the 24 rules, 10 pertain to verifying if the operator (e.g., a message caller) possesses the required privilege. For example, the implementation in Figure 1 violates an ERC20 rule about transferFrom(), which requires the implementation to verify the message caller is authorized to transfer the tokens. Additionally, three rules address whether the token owner holds sufficient privilege. For example, function safeTransferFrom() in ERC1155 sends tokens of a particular type from one address to another, and ERC1155 mandates the source has enough tokens. The remaining 11 rules focus on the recipients of token transfer operations. For instance, ERC721 specifies the recipient cannot be address zero for safeTransferFrom(). Moreover, it also mandates calling onERC721Received() on the recipient when the receipt is a contract. It further requires the caller to check whether the return value is a magic number and mandates the caller to throw an exception if not.\nFunctionality Requirements. Five types of code are required by rules in this category. First, 24 rules specify how to generate the return value of a function. For example, ERC1155 mandates that balanceOf(address _owner, uint256 _id) should return the amount of tokens of type_id owned by_owner. In particular, when a function returns a Boolean value, it implicitly requires returning true upon successful execution and false otherwise. Second, 12 rules address the validation of input parameters and whether an exception should be thrown under certain conditions. For instance, ERC20 dictates that transferFrom() treats the transfer of zero tokens the same as the transfer of a non-zero amount. Figure 1 adheres to this rule. Third, two rules explicitly mandate the associated function to throw an exception when any error occurs. Fourth, three rules specify how to update particular variables. For instance, one ERC20 rule requires approve(address _spender, uint256 _value) to overwrite the allowance value that the message caller allows_spender to manipulate with_value. The remaining rule is from ERC1155 which allows transferring multiple types of tokens together and requires the balance update for each input token type to follow their order in the input array."}, {"title": "3.3 Violation Impact (Why)", "content": "We analyze the security implications of rule violations to understand why the rules are specified, and categorize the rules' impacts into three levels in Table 1.\nHigh. A rule is deemed to have a high-security impact if there exists a clear attack path exploiting its violation, resulting in financial loss. As shown in Table 1, 36 rules fall into this category, encompassing all rules related to privilege checks. For instance, the failure to verify an operator's privilege can enable a hacker to pilfer tokens (e.g., Figure 1) and neglect to inspect whether a recipient address is non-zero can lead to tokens being lost permanently.\nRegarding the rules governing the functionalities, non-compliance with 12 of them can also result in financial loss. Of these, 9 rules outline how to generate return values representing token ownership or privileges to operate tokens, such as balanceOf() returning the number of tokens of an address. Errors that provide incorrect returns for these functions can lead to valid tokens being trapped in an address or allow an address to manipulate tokens without necessary privilege. The remaining three rules pertain to the correct updating of token ownership. For instance, ERC20 requires function approve (address _spender, uint256 _value) to use_value\nto overwrite the amount of tokens the message caller authorizes _spender to manage.\nMedium. A rule has a medium impact if its violation can lead to unexpected contract or transaction behavior, while not having a clear attack path to causing financial loss. For example, if a public function's API fails to adhere to its ERC declaration requirement, invoking the function with a message call following the requirement would trigger an exception. Another example is ERC20's requirement that the function transferFrom() (e.g., Figure 1) treats the transfer of zero tokens the same way as transferring non-zero values. If a contract does not adhere to this rule, its behavior would be unexpected for the message caller.\nLow. All event-related rules are about logging. We consider their security impact as low."}, {"title": "3.4 Linguistic Patterns (How)", "content": "Among the 132 rules, 42 specifically address function or event declarations, which are clearly defined using the Solidity code in the ERCs. The remaining 90 rules are described in natural language. As shown in Table 2, we have identified 11 linguistic patterns to classify how these rules are presented. These 11 patterns correspond to six types of code implementations, as indicated by their ID prefixes (column ID in Table 2): TP indicates throwing or not throwing an exception under certain conditions; CP involves calling a function, possibly with specific argument requirements; EP denotes emitting"}, {"title": "4 THE DESIGN OF SYMGPT", "content": "As shown in Figure 2, SymGPT is an automated tool that takes contract source code and ERC documents as input. It outputs the ERC rules violated by the contracts, along with details about which lines of the source code violate which specific rules.\nThe components of SymGPT can be divided into two parts. The upper part processes input ERC documents, involving extracting ERC rules, converting the rules into an intermediate representation (IR), and generating constraints representing when rules are violated. To automate the rule extraction and translation, we leverage an LLM due to its strong natural language understanding capabilities [81]. As discussed in Section 3, ERC rules cover various contact semantics, making manual extraction and translation a tedious and error-prone process. Additionally, an automated approach enables easier extension of SymGPT to support more ERCs (See Section 5.4).\nThe lower part analyzes contract files. The static analysis component checks if all function and event declarations comply with ERC requirements and gathers necessary information for symbolic execution. The symbolic execution component, using the generated constraints, evaluates each public function and its callees to determine if any inputs could trigger an execution satisfying the constraints and reports rule violations if so. This section follows the workflow to detail the key components of SymGPT."}, {"title": "4.1 ERC Rule Extraction", "content": "SymGPT aims to verify a contract adheres to all the rules outlined in the ERC document it implements. Thus, its first step is to extract rules from ERC documents. While we acknowledge that some correctness and performance rules can be identified and extracted from smart contract code [40, 47], validating compliance with these\nrules is beyond the scope of this paper. Furthermore, as shown by the experimental results in Section 5.2, the rules extracted from contract code cover only a small subset of ERC requirements.\nA na\u00efve way to extract rules from an ERC document with an LLM is to provide the entire ERC document and ask the model to identify all the rules. However, this makes it difficult for the LLM to accurately and completely extract all rules. Instead, we break each ERC document into subsections and send each one to the LLM. Specifically, since each ERC's rules are detailed in the specification section and precede the relevant function or event declarations, we use regular expressions to isolate the specification section and divide the section into subsections, ending at each function or event declaration. We then instruct the LLM to analyze each function or event declaration along with the preceding text description.\nWe design prompts based on the linguistic patterns in Table 2. Each prompt begins with a brief introduction, followed by a set of specific linguistic patterns (all sharing the same ID prefix). It then provides the text description and declaration of a function (or event) and asks the LLM to extract rules from the description, including any relevant value requests (e.g., emitting an event with a specific parameter), based on the patterns. Finally, the prompt explains the JSON schema for outputting the extracted rules. We include linguistic patterns in the prompts to help the LLM better understand what ERC rules are, leading to more accurate extraction results. The prompt template extracting rules in the TP linguistic group is shown in Figure 6 in the Appendix. As discussed in Section 3.4, most rules follow a limited number of patterns, making it likely that the patterns will also apply to ERC rules we have not yet studied. The extracted rules are indexed with their corresponding functions and pattern groups."}, {"title": "4.2 ERC Rule Translation", "content": "Generating constraints directly from natural language rules is challenging for the LLM due to the vast space of possible constraints, which increases uncertainty and the likelihood of hallucinations. To mitigate this, we define an EBNF grammar to formalize ERC rules and instruct the LLM to translate the extracted rules into this IR. The EBNF grammar effectively limits the LLM's output space, improving accuracy. Additionally, formalizing the rules with the EBNF simplifies processing for subsequent tasks. The EBNF essentially acts as a bridge between natural languages and constraint inputs for symbolic execution, addressing Challenge-II in Section 1. We design the EBNF grammar based on the empirical study in Section 3. This grammar covers a wide range of ERC requirements and represents a key technical contribution of this paper, effectively addressing Challenge-I in Section 1. Additionally, it is a one-time effort with long-term benefits, as it can accommodate future ERCs not yet studied (see Section 5.4).\nEBNF Grammar. As shown by line 1 in Figure 3, the EBNF grammar contains five top-level non-terminals (symbols enclosed by \u201c<>\") corresponding to five linguistic pattern groups in Table 2. The grammar encompasses all groups except the one related to return value generation. This omission stems from the difficulty of using contract elements explicitly required by ERCs to define the required return values. For instance, ERC20 specifies that the name() function of every ERC20 contract must return the name of\""}, {"title": "4.3 Constraint Synthesizing", "content": "Since smart contracts have diverse implementations for the same ERC, to eliminate the need for customizing symbolic execution for each contract, we define a set of constraint variables to represent generic contract execution states shared across contracts, along with their update mechanisms during symbolic execution. These designs are essential for expressing ERC requirements and generating constraints equivalent to the EBNF grammar. They differentiate SymGPT from existing symbolic execution techniques [14, 21, 59] and serve as the second major technical contribution of this paper.\nConstraint Variables. For each public function fun, we define six types of state variables to track whether fun or its callees perform specific actions, thereby entering corresponding states. Specifically, we define a TH variable to indicate whether fun throws an exception, possibly triggered by require, revert, assert, or throw. Solidity programmers often use modifiers to enforce checks, and exceptions may be thrown if these checks fail. Those modifiers are naturally supported through inter-procedural analysis. Additionally, we define an EM variable for each event declared in the contract to track whether fun emits that event, and a CA variable for each contract function to track whether fun calls it. For each contract field, we define BI, BD, and BC variables to indicate whether fun increases, decreases, or modifies the field, respectively. These variables are initialized to false before analyzing fun and are set to true when the corresponding actions are performed by fun or its callees.\nFor example, if the condition in line 12 of Figure 1 evaluates to false, function transferFrom() throws an exception, and thus, the TH variable is set to true. After executing line 15, BI_balances is set to true, representing the sum of all mapping elements has ever been increased.\nIn addition to the state variables, we define an O variable for each executed instruction, representing the instruction sequence along a concrete execution path. We also define value variables for contract fields, formal and actual function parameters, event parameters, local variables, and values defined by Ethereum (e.g., msg.sender). These value variables are updated during symbolic execution or constrained by path conditions.\nGenerating Violation Constraints. For the five top-level non-terminals, we generate constraints for if's condition (if), the check part (check), and with's condition (with). We then combine these to form violation constraints based on the rules in Table 3. Specifically, if a rule requires an action (e.g., assign), its violation occurs when the action is not performed. If a rule requires an action under a condition, its violation happens when the condition is met but the action is not performed (e.g., ), or when the action is performed, but the action's parameters do not meet the requirements (e.g., ). For rules that require no exceptions under certain conditions, we design validation constraints\nas \u201cif ^ \u00ac\u0424check.\u201d A violation is reported only when the violation constraints are met, but the validation constraints are not met, ensuring that the exception is indeed due to the specified conditions. Additionally, for call and emit, we inspect whether analyzed contacts contain the called functions or emitted events before synthesizing constraints.\nWhen synthesizing Dif, check, and with, we use defined value variables to replace relevant contract elements (e.g., formal and real parameters, contract fields) and utility functions with the \"get\" prefix. We use the checks of state variables to replace utility functions with the \"check\" prefix. Additionally, for each constraint variable, we consider two key values when synthesizing constraints: its initial value before executing a public function and its final value afterward. Except for formal parameters and contract fields accessed through formal parameters, we use the final values of all other variables to generate constraints.\nConsider the rule violated in Figure 1. The generated constraints are\u201c\u00ac(allowances[fromfirst][msg.senderlast]first \u2265 amountfirst)^ (THlast = true)."}, {"title": "4.4 Static Analysis and Symbolic Execution", "content": "We develop static analysis routines to verify API compliance and compute auxiliary information, along with a symbolic execution engine to check against the formalized ERC rules.\nStatic Analysis. We implement static analysis routines for three purposes: 1) verifying contracts include the necessary functions and events specified by the corresponding ERC, and their declarations meet the required parameters, 2) implementing utility functions, such as getFieldName() and getOrder(), and 3) identifying contract fields with constant values and constraints enforced by the implementations (e.g., keys of a mapping field being all non-zeros).\nSymbolic Execution. As discussed in Section 3.2, most rules apply to a public function. For these, we perform symbolic execution on the function. For the remaining rules, which apply to the entire contract, we analyze each public function individually.\nGiven a public function, we initialize all state variables to false and set contract fields to the identified constants, if applicable. All other constraint variables are treated as symbolic. At the end of each execution path, we use static analysis to determine O variable values and employ a solver (i.e., Z3 [61]) to compute the values of all other variables. Additionally, we initialize the constraint set to reflect common Ethereum requirements (e.g., msg.sender > 0) and type-enforced constraints.\nThe symbolic execution process is similar to existing techniques [14, 21, 59], with the key difference being how we update state variables. We change the values of these variables to true, if the corresponding actions are performed. For example, when an event is emitted, we set the corresponding EM variable to true. To manage path explosion, we limit each loop to a maximum of two iterations. When a path reaches the end of the public function (i.e., the function's return) or throw an exception, we compute the conjunction of the"}, {"title": "5 EVALUATION", "content": "Implementation. We utilize the GPT-4 Turbo model [54] of ChatGPT as the LLM in SymGPT, and interact with it via OpenAI's APIs. The remaining functionality is developed in Python, including generating prompts to automatically extract rules from ERC documents and translate natural language rules into the EBNF grammar, synthesizing constraints, and performing symbolic execution.\nThe symbolic execution engine is built using Slither [24]. It inspects each public function, along with its called functions, to verify compliance with the rules specified for it in the ERC. We employ the SSA form during symbolic execution, ensuring a clear distinction between values defined prior to function execution and those defined within the function.\nResearch Questions. Our experiments are designed to answer the following research questions:\n\u2022 Effectiveness: Can SymGPT accurately pinpoint ERC rule violations?\n\u2022 Advancement: Does SymGPT outperform existing auditing solutions?\n\u2022 Cost: What are the monetary and time costs of using SymGPT?\n\u2022 Generality: Can SymGPT detect violations for ERCs beyond those studied in Section 3?\nExperimental Setting. We configure the temperature parameter to zero to make our experimental results stable when interacting with the LLM. All our experiments are performed on a server machine, with Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz, 256GB RAM, and Red Hat Enterprise Linux 9."}, {"title": "5.1 Effectiveness of SymGPT", "content": "5.1.1 Methodology. We create a large dataset with 4,000 contracts for this evaluation, consisting of 3,400 ERC20 contracts, 500 ERC721 contracts, and 100 ERC1155 contracts. These contracts are randomly sampled from etherscan.io [35] and polygonscan.com [60]. We choose the former platform because of its prominence and the latter due to its higher contract deployment compared to other platforms (e.g., Arbitrum [3], BscScan [12]). All contracts are relatively\nnew, deployed between September 2023 and July 2024. On average, each contract contains 469.3 lines of Solidity source code.\nWe run SymGPT on the dataset and count the violations and false positives SymGPT reports to assess its effectiveness. For each flagged violation, we manually review the result of symbolic execution, the rule description, and the relevant smart contract code to determine whether it is a true violation or a false positive. Each reported violation is reviewed by at least two paper authors, with any disagreements resolved through multiple rounds of discussion. Since the number of the contracts in the dataset is large, we do not manually analyze the contracts to identify all their ERC rule violations, so false negatives are not evaluated in this experiment.\n5.1.2 Experimental Results. As shown in Table 4, SymGPT identifies 5,783 ERC rule violations, including 1,375 with a high-security impact, 3,720 with a medium impact, and 688 with a low impact. The substantial number of violations detected highlights SymGPT's effectiveness in validating ERC rule compliance. Across the three ERCs, SymGPT detects violations for all of them, including 5,211 violations from ERC20 contracts, 542 from ERC721 contracts, and 30 from ERC1155 contracts. This demonstrates that SymGPT's violation detection capability extends across multiple ERCs.\nHigh-Security Impact. Among the 1,353 high-security impact violations detected in ERC20 contracts, 14 are due to failing to validate that the message caller of transferFrom(address _from, address_to, uint256 _value) has sufficient privileges to transfer the_value tokens. An example of this violation is shown in Figure 1, with similar code patterns found in the other 13 cases. Another 1,266 cases violate the same rule, but stem from a different issue: instead of comparing the allowed amount with_value, these implementations check whether the allowed amount equals type (uint256). max. Furthermore, they fail to update the allowed amount after the transfer, which we believe creates a backdoor in the contract. This loophole potentially enables one address to drain any amount of tokens from another account. Another 73 violations breach the rule that transfer() should revert if the message caller does not have enough tokens to transfer. Exploiting these violations could allow an address to spend more tokens than it actually possesses. The flawed implementations either use unchecked to bypass the underflow check when reducing the caller's balance or include a path that does not decrease the caller's balance at all.\nSymGPT identifies 18 high-security violations that do not comply with ERC721 requirements. These violations are related to functions responsible for transferring NFT ownership. The flawed implementations fail to check whether the sender is the rightful owner of the NFT or whether the recipient address is not the zero address. Exploiting these vulnerabilities could lead to NFTs being stolen or permanently lost at the zero address."}, {"title": "5.2 Comparison with Baselines", "content": "5.2.1 Methodology. Since the large dataset lacks \u201cground-truth\u201d labels and cannot assess violation coverage, we create a small, ground-truth dataset to compare SymGPT with existing auditing solutions. Specifically, we randomly select 30 ERC20 contracts audited by the Ethereum Commonwealth Security Department (ECSD), a group of experts who handle auditing requests submitted as GitHub issues and release audit results in response [22]. These contracts and their audit results enable a comparison between automated techniques and expert reviews. For ERC721 and ERC1155, we only find one contract for each of them from ECSD's GitHub. Additionally, we randomly sample eight more contracts for the two ERCs from the website of ERCx [69].\nIn total, the ground-truth dataset contains 40 contracts, including 30 ERC20 contracts, 5 ERC721 contracts, and 5 ERC1155 contracts. Each contract contains an average of 553 lines of code. These contracts are either audited by ECSD from January 2019 to October 2023 or analyzed by ERCx from May 2024 to December 2024. Since some contracts are written in outdated Solidity versions and cannot be analyzed by certain baseline techniques, we update all contracts"}, {"title": "5.3 Monetary and Time Costs", "content": "5.3.1 Methodology. We evaluate the time and monetary costs using the ground-truth dataset. Since SymGPT's analysis of an ERC applies to all contracts of the ERC, its execution time is calculated as the sum of the analysis time for three ERCs and the code analysis time for all contracts. Measurements are performed three times, with the average reported. For baseline techniques, each tool is executed on every contract file three times, and the average execution time is recorded. The time for ECSD is measured only for contracts collected from ECSD's GitHub. It is measured as the time between when an auditing request is submitted on GitHub and when a security expert provides the result, reflecting the waiting period required for a Solidity programmer to receive feedback.\nThe monetary costs for SymGPT, GPT-All, and GPT-O are the fees charged by OpenAI. GPT-A requires a $20 monthly subscription, while analyzing the ground-truth dataset with ERCx costs $100 for a team plan. For ECSD, we have cost data for one contract, amounting to $1,000. To estimate costs for other ECSD contracts, we calculate the average hourly rate by dividing $1,000 by the hours spent on the contract and then apply this rate to other contracts. For ERCx contracts, we cannot estimate auditing costs by ECSD experts due to the lack of information on how many hours ECSD experts would spend on the contracts. SCE and ZS are open-source, so they incur no monetary costs."}, {"title": "5.4 Validating ERC3525 Contracts", "content": "5.4.1 Methodology. We select ERC3525 to test whether SymGPT can validate contracts beyond the ERCs we have studied. ERC3525 was released two years after the studied ERCs and has already been used in financial instruments [13, 36], making it a representative and more recent standard. After a thorough review, we identify 58 rules in ERC3525, including 15 with a high-security impact, 27 with a medium impact, and 16 with a low impact. We search GitHub for ERC3525 contracts but find only one. After auditing it, we confirm it complies with all ERC3525 rules and has no violations. Then, we decide to inject violations into the contract to create a testing dataset. Specifically, to inject a violation of a rule, we remove the code ensuring compliance with the rule. In the end, the created dataset contains ten ERC3525 contracts, and each contract violates three randomly selected rules, resulting in 30 violations in total.\n5.4.2 Experimental Results. After applying SymGPT to the ten contracts, it successfully identifies all 30 violations, while reporting zero false positives. We further analyze the results at each step. During rule extraction, the LLM in SymGPT correctly extracts all required rules but mistakenly includes six additional ones that are not part of ERC3525. These extra rules require a function to call a non-existent function with the same name as an event in ERC3525. However, during constraint generation, SymGPT detects the absence of these callee functions and disregards the extraneous rules, leading them not to affect the final results. SymGPT does not make any errors in the subsequent steps."}, {"title": "6 CONCLUSION", "content": "In this paper, we present an empirical study of the implementation rules specified in ERCs, examining three key aspects: their content, security implications, and the detailed specifications provided in the ERCs. Based on our findings, we have developed an automated tool called SymGPT, which integrates an LLM with symbolic execution to evaluate whether smart contracts comply with ERC requirements. SymGPT has proven effective in identifying numerous rule violations and outperforms six baseline techniques and a manual auditing service. We anticipate that this research will enhance the understanding of ERC rules and their violations, fostering further exploration in this field. Additionally, our work highlights the benefits of combining LLMs with formal methods and encourages continued research in this area."}, {"title": "APPENDIX", "content": null}]}