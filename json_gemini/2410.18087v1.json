{"title": "CUPID: A Real-Time Session-Based Reciprocal Recommendation System for a One-on-One Social Discovery Platform", "authors": ["Beomsu Kim", "Sangbum Kim", "Minchan Kim", "Joonyoung Yi", "Sungjoo Ha", "Suhyun Lee", "Youngsoo Lee", "Gihoon Yeom", "Buru Chang", "Gihun Lee"], "abstract": "This study introduces CUPID, a novel approach to session-based reciprocal recommendation systems designed for a real-time one-on-one social discovery platform. In such platforms, low latency is critical to enhance user experiences. However, conventional session-based approaches struggle with high latency due to the demands of modeling sequential user behavior for each recommendation process. Additionally, given the reciprocal nature of the platform, where users act as items for each other, training recommendation models on large-scale datasets is computationally prohibitive using conventional methods. To address these challenges, CUPID decouples the time-intensive user session modeling from the real-time user matching process to reduce inference time. Furthermore, CUPID employs a two-phase training strategy that separates the training of embedding and prediction layers, significantly reducing the computational burden by decreasing the number of sequential model inferences by several hundredfold. Extensive experiments on large-scale Azar datasets demonstrate CUPID's effectiveness in a real-world production environment. Notably, CUPID reduces response latency by more than 76% compared to non-asynchronous systems, while significantly improving user engagement.", "sections": [{"title": "I. INTRODUCTION", "content": "Azar is a leading real-time social discovery platform that connects users for one-on-one video conversations. To facilitate these interactions, the platform gathers users who signal their readiness for immediate video calls into a matching pool. The platform then matches users from this pool aiming to maximize overall user satisfaction, measured by the total chat duration across all pairs. Longer chat durations are indicative of more engaging and satisfying interactions, thus serving as a proxy for user satisfaction. In such reciprocal recommendation systems, where both users need to be mutually satisfied, the recommendations must reflect the preferences of both parties [1\u20133]. Furthermore, as users engage with the platform, their preferences can change dynamically [4, 5]. For example, a user might start by wanting to chat casually about favorite hobbies but later seek deeper conversations about social issues.\nIn real-time social discovery platforms, adapting to evolving user preferences is crucial for maintaining engagement and satisfaction. One effective approach is session-based recommendations [6\u20138], where a session represents a single visit or interaction period during which the user actively engages with the platform. By focusing solely on the current session, session-based recommendations consider a user's behavior within that session rather than building a user profile from long-term historical data. This approach leverages session-specific information, enabling the system to respond to dynamic preferences [9\u201313] and address the cold-start problem [14\u201318], where new users lack sufficient historical data, by relying on data from the current session.\nHowever, applying session-based recommendations to reciprocal recommendation systems with strict real-time constraints presents unique and significant challenges. First, conventional session-based systems build user profiles through computationally intensive session modeling [6, 19\u201321], which can take several seconds and thereby far exceeding the immediate response times required by platforms like Azar. This delay results in a bottleneck in delivering timely recommendations. Second, user behavior in reciprocal systems can evolve rapidly within a single session, even after each interaction. For example, a positive interaction might make a user more inclined toward similar profiles, while a negative experience could shift their preferences entirely. Moreover, conventional session based recommendations mostly assume static item representations [6, 22, 23]. In reciprocal systems [2, 24, 25], however, both user preferences and the items (i.e., other users) change dynamically since users act as both consumers and items. Consequently, each interaction not only updates a user's preferences but also impacts other users' representations, complicating the recommendation algorithm. These factors make real-time session-based reciprocal recommendations more complex than conventional systems. The differences between conventional session-based recommendation and its application in real-time reciprocal recommendation are illustrated in Figure 1.\nTo address these challenges, we propose CUPID, a session-based reciprocal recommendation system specifically designed for real-time social discovery platforms. For the inference efficiency, CUPID aims to minimize the overall time consumption of the recommendation pipeline by decoupling it from the computationally intensive session modeling for each user. More specifically, CUPID adopts an asynchronous session"}, {"title": "II. PROBLEM FORMULATION", "content": "A real-time social discovery platform connects online users enabling immediate, one-on-one conversations. Let $U$ represent the set of all users on such a platform. At any given time $t$, the matching pool $U(t) = \\{u_1, u_2,..., u_n\\}$ consists of $n$ users available for matching. As illustrated in Figure 1, the matching pool $U(t)$ is dynamic, constantly changing as users log in or out and conversations begin or end. Each user $u_i \\in U(t)$ is characterized by a set of features $X_i$ (e.g., gender, country code, and other match-related statistics) and session information $S_i = [m_{i,1},m_{i,2},...,m_{i,h}]$, which includes $h$ matching histories. Each matching history $m_{ik} \\in S_i$ consists of the chat counterpart $u_j$ and the chat duration $\\gamma_{ij}$ as follows:\n$$\nMatching \\ History: m_{i,k} = (u_i, u_j, \\gamma_{ij}).\n$$\nThe goal of the session-based reciprocal recommendation system is to optimally pair suitable users from $U(t)$ by considering their features and matching histories to maximize overall user satisfaction. We define a recommendation model $f(\\cdot)$, which estimates satisfaction scores $s_{ij}$ for all possible pairs of users $(u_i, u_j)$:\n$$\nSatisfaction \\ Score: s_{ij} = f(u_i, u_j).\n$$\nFor the satisfaction score, chat duration $\\gamma_{ij}$ is used as a proxy for satisfaction scores, based on the assumption that longer conversations correlate with higher user satisfaction. Therefore, the recommendation model's objective is revised to predict chat durations $\\hat{\\gamma}_{ij}$ for each user pair:\n$$\nPredicted \\ Chat \\ Duration: \\hat{\\gamma}_{ij} = f(u_i, u_j).\n$$\nThese predictions are used to connect users through efficient matching algorithms designed according to the service's business logic. By predicting chat durations, the system can expedite connections that likely enhance user satisfaction, successfully addressing the challenges of dynamic user preferences in real-time social discovery platforms."}, {"title": "III. PROPOSED APPROACH: CUPID", "content": "In this section, we introduce CUPID, our session-based reciprocal recommendation system designed for real-world social discovery services with a focus on low-latency performance. We describe the implementation of Cupid and present a novel training method that efficiently captures mutual interests among users based on extensive matching histories.\nAs highlighted earlier, delivering recommendations with minimal delay is crucial for real-time social discovery platforms. Any latency may lead to longer wait times for users, harming user experience and potentially causing them to leave the service. A key challenge is efficiently modeling short-term, dynamic user behaviors to capture real-time preferences and intents. CUPID addresses two primary considerations: (i) rapidly computing satisfaction scores for all potential user pairs in the matching pool to minimize latency, and (ii) overcoming the slower processing times associated with sequence modeling architectures, such as RNNs or transformers. To tackle these challenges, we have developed two core strategies for score computation and session modeling.\nWe compute the expected satisfaction score $\\hat{\\gamma}_{ij}$ (i.e., chat duration) by applying a simple linear transformation to the dot product of user representations as follows:\n$$\n\\hat{\\gamma}_{ij} = f(u_i, u_j) = w(e_i \\cdot e_j) + b,\n$$\nwhere $e_i$ and $e_j$ are the $d$-dimensional representation of users $u_i$ and $u_j$, respectively. This approach allows us to compute the matrix of predicted satisfaction scores $\\hat{\\Gamma} \\in \\mathbb{R}^{nxn}$ for all user pairs efficiently using a single matrix multiplication by leveraging optimized BLAS [26] libraries.\nWe decouple the computationally intensive user session modeling from the real-time matching pipeline by handling it asynchronously. This design significantly enhances the responsiveness of our recommendation system, enabling CUPID to deliver swift recommendations, which is essential for maintaining user engagement, as illustrated in Figure 2. An overview of Cupid's architecture is provided in Figure 3. The performance of CUPID is measured by the Mean Squared Error (MSE) as follows:\n$$\nL_{MSE} = \\frac{1}{D}\\Sigma (\\gamma_{ij} - \\hat{\\gamma}_{ij})^2,\n$$\nwhere $D$ is the dataset match history of all users. Further details of CUPID are presented in the subsequent sections."}, {"title": "B. Asynchronous Session Embedding Layer $f_s$", "content": "To ensure low-latency recommendations, CUPID models user behaviors in their sessions asynchronously rather than synchronously with matching requests. As illustrated in Figure 2(b), when a user $u_i$'s previous match ends, the session representation vector $e_i^s$ is computed asynchronously using the session embedding layer $f_s$. More specifically, each matching history $m$ in user $u_i$'s session information $S_i$ is embedded into a representation $e_m$ using Wide& Deep model [27]. This incorporates features $X_i$ from the user $u_j$, and the features $X_j$ from the chat counterpart user $u_j$, along with the chat duration $\\gamma_{ij}$. The user session representation $e_i^s$ is then formed from these matching history representations $[e_1, e_2, ..., e_h]$, employing a causal transformer, ensuring that each output $e_k$ represents the user's state after the $k$-th match, influenced only by preceding matches. The final session representation $e_i^s$ is stored in an embedding memory $E$, replacing any existing representation. When user $u_i$, requests a new match, the stored embedding $e_i^s$ is retrieved to predict chat durations. Note that the session representation may not be updated before the session representation lookup occurs, as the computation might still be in progress when a new match is requested. In such cases, we refer to the session representation retrieved as a delayed session representation.\nThis design provides significant advantages: it decouples the slower user session modeling from the synchronous matching pipeline, improving both recommendation speed and efficiency. However, asynchronously updating session representations may cause recent information to be displaced during inference, as new match data could arrive while the session representations are still being updated. Despite this, the system incurs only a few seconds of delay, so the impact on performance is negligible. Furthermore, by handling session information asynchronously, the overall throughput of session processing is enhanced through the batching of multiple inferences, which also reduces computational costs."}, {"title": "C. Synchronous User Feature Embedding Layer $f_u$", "content": "Along with session information, Cupid incorporates user features such as demographic details (e.g., gender, country) and other match statistics to capture general user preferences. We use Wide&Deep [27] as the user feature embedding layer $f_u$, which processes the user features $X_i$ to generate a representation $e_i^f = f_u(X_i)$. This representation $e_i^f$ is then used in the prediction layer to estimate chat duration of users."}, {"title": "D. Chat Duration Prediction Layer $f_o$", "content": "The chat duration prediction layer $f_o$ aims to accurately predict the chat duration for a user pair $(u_i, u_j)$ by combining their session and feature representations:\n$$\ne_i = e_i^f + e_i^s, \\ e_j = e_j^f + e_j^s.\n$$\nWhile a simple method to predict chat duration may involve computing the dot product of these user representations $(e_i \\cdot e_j)$, this can lead to overestimating chat duration for users with similar profiles, resulting in sub-optimal recommendations when recommending similar users is not always ideal [28, 29]. To more accurately capture mutual interest while avoiding overestimation for similar users, we linearly project user representations into separate latent spaces:\n$$\n\\bar{e_i} = W_1e_i + b_1, \\bar{e_j} = W_2e_j + b_2,\n$$\nwhere $W_1$ and $b_1$ are the learnable weight matrix and bias for the projection of the representation of user $u_i$, and $W_2$ and $b_2$ are the corresponding weight matrix and bias for their chat counterpart $u_j$. Then, the predicted chat duration is estimated by the dot product of the mapped representations $\\bar{e_i}$ and $\\bar{e_j}$:\n$$\n\\hat{\\gamma}_{ij} = \\bar{e_i} \\cdot \\bar{e_j}.\n$$\nAs plotted in Figure 4, the actual chat durations follow a long-tailed distribution in real-world social discovery platforms (blue histogram) in practice. However, when trained with naive MSE objective, predictions based on the dot product tend to follow a normal distribution (red histogram), which deviates from the true distribution."}, {"title": "Algorithm 1 Two-Phase Training Strategy", "content": "Input: feature embedding layer $f_u$, auxiliary feature embedding layer $f_u'$, session embedding layer $f_s$, and chat duration prediction layer $f_o$\nOutput: the trained layers $f_u$, $f_s$, and $f_o$\nPhase 1 Training (Embedding Layer)\nrepeat\nfor $u_i \\in U$ do\ncompute $f_s(S_i) = [e_{i,0}^s, e_{i,1}^s, e_{i,2}^s,..., e_{i,h}^s]$\nfor $m_k = (u_i, u_j, \\gamma_{ij,k}) \\in S_i$ do\ncompute $e_{i,k}^f = f_u'(X_{i,k}), \\bar{e_{j,k}}^f = f_u'(X_{j,k})$\ncompute $L_{MSE} = (f_o(e_{i,k}^f + e_{i,k-1}^s,\\bar{e_{j,k}}^f) - \\gamma_{ij,k})^2$\nupdate $f_u, f_u', f_s, f_o$ with $L_{MSE}$\nend for\nend for\nuntil CUPID converges\nPhase 2 Training (Prediction Layer)\nfreeze the feature embedding layer $f_u$ and session embedding layer $f_s$\ncompute $e_i^f, e_i^s, e_i^f, e_i^s$ in advance\nrepeat\nfor $m = (u_i, u_j, \\gamma_{ij}) \\in D$ do\ncompute $L_{MSE} = (f_o(e_i^f + e_i^s, e_j^f + e_j^s) - \\gamma_{ij})^2$\nupdate $f_o$ with $L_{MSE}$\nend for\nuntil CUPID converges\nlayer $f_u$ and the asynchronous session embedding layer $f_s$. We introduce an auxiliary user feature embedding layer $f_u'$ to assist in training these layers excluding session information from the chat counterparts. This reduces the input to $(X_i; S_i, X_j)$, allowing us to leverage the causal transformer to generate session representations $e_k^s$ with a single forward pass per user. This phase is aimed at minimizing the following objective:\n$$\nL_{MSE} = \\frac{1}{D}\\Sigma_{u_i \\in U} \\Sigma_{m_k \\in S_i} (f_o (e_{i,k}^f + e_{i,k-1}^s, \\bar{e_{j,k}}^f) - \\gamma_{ij,k})^2,\n$$\nwhere $e_{i,k-1}^s$ is the session state of user $u_i$ after the $(k-1)$-th match for predicting the chat duration of the $k$-th match.\nIn this phase, we enhance the chat duration prediction layer $f_o$ by fully incorporating session information from both users in each match $(X_i; S_i, X_j; S_j)$. Thereby, the objective becomes:\n$$\nL_{MSE} = \\Sigma_{u_i \\in U} \\Sigma_{m_k \\in S_i} (f_o (e_{i,k}^f + e_{i,k-1}^s, e_j^f + e_j^k-1) - \\gamma_{ij,k})^2.\n$$\nIn this final phase, we discontinue using the auxiliary user feature embedding layer $f_u'$ from the first phase and freeze the embedding layers $(f_u, f_s)$ to improve processing efficiency. By computing the user feature representations in advance, subsequent calculations can be optimized."}, {"title": "E. Two-Phase Training", "content": "Training session-based recommendation systems in real-time contexts poses significant computational challenges due to the dynamic nature of user representations. Each user's preferences evolve after each interaction, requiring the system to frequently update their session representations to accurately reflect their current state. To make precise recommendations, the system must consider the updated session data for both users involved in each match. Traditionally, this involves processing and updating the session data for both the initiating user $u_i$ and their chat counterpart $u_j$ separately using complex models like transformers. For each user, the causal transformer processes their session history with a computational complexity of $O(S^2)$, where $S$ is the average session length per user. Modeling both users separately effectively doubles the computational cost, making it computationally intensive.\nMoreover, accurately predicting matches requires jointly modeling how the sessions of $u_i$ and $u_j$ interact, which significantly increases computational overhead. This is because every interaction in $u_i$'s session might influence and be influenced by every interaction in $u_j$'s session, expanding the interaction space exponentially. In a naive approach, considering cross-attention between both users' sequences could lead to a theoretical complexity of $O(|S|^4)$. Such high computational demands make real-time processing prohibitive, especially in large-scale platforms with millions of users and high interaction rates like Azar. The sequential dependencies inherent in causal transformers further exacerbate the issue, as each interaction's representation depends on all previous interactions, leading to extensive computations. To address this challenge and improve training efficiency, we propose a Two-Phase Training Strategy, outlined in Algorithm 1, which significantly reduces computational overhead during training without substantially compromising the model's performance.\nPhase 1: Training Embedding Layers The primary goal of this phase is to efficiently train the user feature embedding"}, {"title": "Computational Complexity Analysis", "content": "We analyze how our two-phase training strategy enhances training efficiency, as detailed in Table I. Let $N$ denote the total number of training epochs in standard learning, with $N_1$ and $N_2$ for the first and second phases, respectively. $D$ denotes the number of matching histories in the dataset, and $|S|$ indicates the average session length per user. In standard training, modeling session"}, {"title": "IV. EXPERIMENTS", "content": "The performance of CUPID is evaluated in both offline and online environments. In the offline evaluation, its performance is tested in a controlled setting. A large-scale matching history from Azar is used, consisting of a billion-scale dataset from millions of user sessions generated over a month. Data from the last two days is used for validation and testing, while the remaining data is used as the training set. In the online evaluation, CUPID's effectiveness is validated in real-world conditions to ensure that the gains observed are consistent in a live service environment.\nWe adopt two baseline models based on Wide&Deep [27], which were previously used in Azar before adopting session-based recommendations as follows:\nA widely adopted recommendation method that captures higher-order interactions among input features using neural networks. It employs user representations $e_i = e_i^f$ and $e_j = e_j^f$ are employed in Equation 6 without session representations $e_i^s$ and $e_j^s$. Consequently, it relies solely on static user features and does not include any real-time information from user sessions.\nA variant of Wide&Deep that incorporates real-time features generated during user sessions. It captures user behaviors while maintaining low latency by leveraging aggregated features from recent match histories, such as average chat duration, along with existing user features. This baseline serves to demonstrate the effectiveness of our sequential approach for modeling user sessions.\nFor performance evaluation, we use MSE and Area Under the Receiver Operating Characteristic (AUROC). MSE measures the average squared difference between actual and predicted chat durations by applying log-scaled chat durations (ms) to minimize the impact of noise in shorter intervals. The same log-scaling is also used during the training of our recommendation models. In contrast, AUROC assesses the model's ability to distinguish between potential matches that result in quality interactions and those that do not. A quality match is defined as one where the chat duration exceeds a specific threshold. As latency is another critical factor for real-time reciprocal recommendation, we also evaluate the latency improvement achieved by adopting CUPID in the real-world deployment of Azar."}, {"title": "Online Production Performance", "content": "While CUPID shows a significant improvement in predicting satisfaction scores in offline experiments, it may not always lead to increased user engagement online. To evaluate its real-world impact, we test CUPID in the production environment of Azar, comparing it with the baselines. We conduct a Switchback [30] test instead of an A/B test due to the shared matching pool, which makes it difficult to independently separate A/B groups. The results in Table II show improvements in metrics such as average chat duration and the ratio of long to short matches, defined by a preset threshold. For all user segments, CUPID consistently increases the average chat duration and improves match quality. This demonstrates that CUPID not only accurately predicts satisfaction scores but also enhances user experience in a live setting. Meanwhile, Table V shows the latency improvement achieved by CUPID, emphasizing its primary goal of delivering low-latency recommendations through asynchronous session modeling. In the real-world deployment of Azar, CUPID reduces latencies at the 90th and 99th percentiles by up to 79.7% compared to synchronous computation of session representations in the matching pipeline. This significant reduction ensures stable latency, which is essential for real-time services."}, {"title": "D. Effect of Delayed Session Representation", "content": "In real deployment, the session representation $e^s$ might miss the latest matching histories if a user requests a new match before the update is complete. The system then uses a delayed representation, which lacks data from the most recent matches. To study the impact of this delay, we simulate an environment where the representation update is delayed for $t'$ milliseconds and predict chat durations for users in the matching pool $U(t)$ using this delayed data. The results are summarized in Table III. Two main observations emerge. First, prediction performance slightly decreases as delay time increases, which is expected since the system design decouples session modeling from the synchronous matching pipeline to avoid latency issues. This compromise is acceptable, as it prevents session modeling from becoming a bottleneck. Second, even with this delay, the models still outperform the Wide&Deep-S baseline by a significant margin in all cases while maintaining similar latency. This shows that the approach, with its decoupled session modeling, achieves an optimal balance between latency and prediction performance."}, {"title": "E. Ablation Study", "content": "An ablation test is conducted to evaluate the impact of individual components on CUPID's performance, focusing on session representation $e^s$, the Exponential Transformation (ET), and the second phase of the two-phase training strategy. The results, shown in Table IV, indicate a performance drop when any component is removed. Excluding the session representation results in a significant decline, especially for cold-start users, underscoring its role in capturing mutual interests. Skipping the second-phase training also negatively impacts performance, highlighting its importance in using session data from both users to improve chat duration predictions. Additionally, omitting the exponential transformation leads to poorer performance, underscoring its value in aligning predicted chat durations with the actual distribution and stabilizing model training."}, {"title": "V. RELATED WORK", "content": "Reciprocal recommendation systems differ from conventional in the sense of they aim to enhance mutual satisfaction through user-to-user recommendations, instead of focusing on item-to-user recommendations [4, 31, 32]. These systems have been widely studied, especially in contexts like online dating [33\u201336], and job search platforms [29, 37-39]. Our work shifts the focus to real-time reciprocal recommendations, where candidates appear and disappear dynamically. This is the first comprehensive study to investigate these complex dynamics in real-time.\nSession-based recommendation systems predict the next item by capturing dynamic user behaviors and intents within a session. Various models, such as Markov Chains [40, 41], recurrent neural networks [22, 42, 43], graph neural networks [44-47], transformers [20, 48-51], and other attention mechanisms [52-54] have been utilized for this purpose. Our study extends session-based recommendations into the underexplored area of reciprocal recommendation tasks. While [55] examines sequential recommendations in a two-sided market, it does not address the low-latency requirements essential for real-time one-on-one social discovery platforms. In contrast, our work specifically focuses on meeting these extreme low-latency constraints, facilitating rapid and efficient user matching in reciprocal session-based recommendation systems."}, {"title": "VI. CONCLUSION", "content": "To the best of our knowledge, this is the first study to develop a session-based reciprocal recommendation system optimized for real-time social discovery platforms. Our approach tackles stringent latency requirements by using asynchronous session modeling, which significantly reduces the time required for processing. Additionally, we introduce an efficient two-phase training method that simplifies the complexities of combining session-based and reciprocal recommendations. Our system, validated on a large-scale offline dataset and in a real-world environment, increases average chat duration by 6.8% for warm-start users and 5.9% for cold-start users. Moreover, it achieves over a 76% reduction in latency compared to purely synchronous methods. This research opens a new direction for session-based real-time reciprocal recommendations."}, {"title": "Ethical Statement", "content": "By introducing CUPID, we aim to enhance user engagement and satisfaction through efficient, personalized matchmaking in social discovery. Using asynchronous session modeling and a two-phase training strategy, CUPID addresses low latency and dynamic user preferences. However, deploying such a system involves ethical considerations, including user privacy, data security, and potential algorithmic biases. To address these, we ensure strict adherence to data protection laws, implement robust security measures, and commit to developing fairness-aware algorithms with regular audits to prevent unintended discrimination."}]}