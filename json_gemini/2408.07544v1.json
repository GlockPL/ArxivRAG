{"title": "Planning with OWL-DL Ontologies (Extended Version)", "authors": ["Tobias John", "Patrick Koopmann"], "abstract": "We introduce ontology-mediated planning, in which planning problems are combined with an ontology. Our formalism differs from existing ones in that we focus on a strong separation of the formalisms for describing planning problems and ontologies, which are only losely coupled by an interface. Moreover, we present a black-box algorithm that supports the full expressive power of OWL DL. This goes beyond what existing approaches combining automated planning with ontologies can do, which only support lim-ited description logics such as DL-Lite and description logics that are Horn. Our main algorithm relies on rewritings of the ontology-mediated planning specifications into PDDL, so that existing plan-ning systems can be used to solve them. The algorithm relies on jus-tifications, which allows for a generic approach that is independent of the expressivity of the ontology language. However, dedicated opti-mizations for computing justifications need to be implemented to en-able an efficient rewriting procedure. We evaluated our implementa-tion on benchmark sets from several domains. The evaluation shows that our procedure works in practice and that tailoring the reasoning procedure has significant impact on the performance.", "sections": [{"title": "Introduction", "content": "Automated planning continues to play a central role in many appli-cation domains such as robotics. Systems for automated planning compute plans for a planning domain which defines a set of avail-able actions that describe how states of the system can be modified. A planning problem then consists of an initial state, a domain of objects and a goal that needs to be reached, for which the planner computes a plan in the form of a sequence of actions that would lead from the initial state to a state satisfying the goal [11, 25].\nPlanning problems classically operate under a closed world se-mantics, meaning that the initial state and all states that the system can go through are represented as finite first-order interpretations, which requires a suitable abstraction of the real world. In more com-plex scenarios, this assumption is not realistic, as agents have only limited knowledge about the world, and need to reason over com-plex domains. Ontologies are a widely used formalism for describing complex domain knowledge under open world semantics. Here, we assume our knowledge of the world to be generally incomplete [4]. The ontology defines terminology and background knowledge rele-vant for the application scenario, which allows to infer new infor-mation from an incomplete description of the world. This also gives further flexibility when specifying planning problems: for example, the available actions might depend on a configuration of the robot, whose abilities can be derived through the technical knowledge de-fined in the ontology.\nOur first contribution is to propose ontology-mediated planning specifications as a new framework for linking planning problems with ontologies, inspired by ontology-mediated model checking [9]. The idea is to have an ontology describing static knowledge de-scribed in description logics (DL), the central formalism for speci-fying ontologies, together with a specification of a planning problem in PDDL, the classical language for specifying planning problems. These two are then linked together through an interface that specifies how to translate between PDDL and DL. Each state in the planning space has then two perspectives that we also distinguish syntacti-cally: as ground atoms in PDDL and as DL axioms. By separating the two formalisms for planning and ontologies, existing formalizations can easily be integrated, and planning and ontology experts do not have to learn a new formalism. Moreover, we achieve a true separa-tion of concerns, allowing to specify planning problems and domain knowledge relatively independently and in dedicated languages.\nOntology-mediated planning specifications (OMPSs) are strongly related to extended Knowledge Action Bases (eKABS) [14, 8], which extend classical DL knowledge bases with actions formulated over the DL signature. One syntactical difference between eKABs and ontology-mediated planning specifications is that there is an inte-gration rather than a separation of concerns. Another difference is that eKABs allow to refer in both pre- and post-conditions of actions to objects outside of the domain. Existing techniques for planning with eKABs rely on the idea of compilation schemes that translate the actions in an eKAB into a PDDL planning domain, so that a PDDL planning system can be used out of the shelf. The compilation scheme introduced in [8] supports DLs of the DL-Lite family, while the compilation scheme introduced in [7] supports Horn-DLs. [7] also studies the limitations of such compilation schemes in general: for DLs such as Horn-SROIQ, under common complexity theo-retic assumptions, no compilation scheme that increases the size of the planning domain at most polynomially exists. Moreover, since the approach relies on Datalog rewritings, it is not applicable to DLs that are not Datalog-rewritable, such as DLs beyond the Horn frag-ment. This means, in this approach, disjunction, unrestricted nega-tion and value restrictions, as well as cardinality restrictions are not allowed. For instance, it is impossible to express in a Horn DL that a robot can carry at most five objects, since this would require a cardi-nality restriction that is not available in Horn logics."}, {"title": "Preliminaries", "content": "Planning Problems We consider the common syntax and seman-tics of PDDL planning problems introduced in [11, 25] and described in detail in [10], with the extension for derived predicates [16]. Let Np be a set of predicate names, and let O be a set of constants. A state s over O is a finite set of ground atoms over Np and O, which we identify with the corresponding first-order interpretation.\nWe denote a special set NP,D \u2286 Np of predicates called derived predicates. A derivation rule is of the form r = p(x) \u2190 \u03c6(x), where x is a vector of variables, p \u2208 NP,D, and (2) is a first-order formula with free variables z in which derived predicates occur only positively. We call p(x) the head and \u03c6(x) the body of the rule. The result of applying such a rule on a state s is obtained by adding to s all p(c) for which s |= \u03c6(c), where c is a vector of constants with the length of z. Given a set D of derivation rules and a state s, D(s) denotes the result of applying the rules in D until a fixpoint is reached.\nAn action is a tuple a = (x, pre, eff) where x is a vector of vari-ables, pre is a first-order formula with free variables from z, and eff = (add, del), where add and del are finite sets of atoms using only variables from 7 and no derived predicates. We call pre the precondi-tion of a, and eff the effect. If x = (), a is called ground. An instance of a under O is a ground action a obtained by replacing all variables from x by constants from O. Let \u03c3: x \u2192 O be the function de-scribing the replacement. A ground action is applicable on a state s if s |= \u03c3(pre) (where s is treated as an interpretation), in which case the result of applying a on s is defined as s(a) := (s \\ \u03c3(del)) \u222a \u03c3(add).\nA planning domain is a tuple D = {A, D} of a set A of ac-tions and a set D of derivation rules. A planning problem is a tuple P = (O, s0, G) with O a set of constants, s0 a state over O called the initial state, and G a first-order formula called goal. A PDDL plan-ning specification is now a tuple S = (D, P) of a planning domain D and a planning problem P. A plan for such a planning specification is a sequence of states s0... sn s.t. 1) s0 is the initial state from P, 2) for every i, 0 \u2264 i < n, si+1 = si (a), where a is an instance of an action from A over O that is applicable on D(si), and 3) sn |= G, where sn is treated as an interpretation.\nDescription Logics and Ontologies A DL ontology is a formal-ization of domain knowledge based on pair-wise disjoint, countably infinite sets NC of concepts names (unary predicates), NR of role names (binary predicates) and NI of individual names (constants), which are used to build complex expressions called concepts that de-scribe sets of individuals. For the context of this paper, ontologies are sets of axioms, which either describe terminological knowledge (TBox axioms) by putting concepts into relation with each other (e.g. by saying that a concept name describes the same set of objects than a complex concept) or describe assertional knowledge (ABox axioms) by assigning concepts and role names to specific individuals. ABox axioms are of the forms C(a), r(a, b), \u00acr(a, b), a = b, a != b, where C is a concept, a, b are individual names, and r is a role name. Each (TBox or ABox) axiom can be translated into a sentence in first-order logic, so that we can define entailment between axioms and of axioms from ontologies based on this translation. Specifically, for an ontology O and an axiom a, we write O |= \u03b1 if \u03b1 is logically en-tailed by the axioms in O. For details on the different concept and axiom constructs, see [4].\nOur examples rely on the DL ALCQ, which is a fragment of OWL DL, and in which concepts C follow the following syntax rule:\nC ::= T | A | \u00acC | C \u2293 C | C \u2294 C | \u2203r.C | \u2200r.C | \u2265nr.C | \u2264nr.C,\nwhere A \u2208 Nc, r \u2208 NR. TBox axioms in ALCQ are of the form C \u2291 D or C = D, with C and D concepts."}, {"title": "Framework", "content": "3.1 Ontology-Mediated Planning\nWe capture our framework formally via ontology-mediated planning specifications, which are inspired by the ontologized programs intro-"}, {"title": "Optimized Generation of Justifications", "content": "Since the axioms in the static ontology Os are always part of the DL perspective of a state, it makes no sense to try to modify them with an action. In the following, we thus assume Os \u2229 F = 0.\nLet Q be the set of assertions for which we need to compute ent(a). Due to the monotonicity of entailment, it is sufficient to con-sider those subsets F \u2286 F in Equation (1) that are subset mini-mal. Thus, to obtain ent(a) we need to compute all pairs (a, F) \u2286 Q \u00d7 2 s.t. Og \u222a F |= a and F is minimal, where Os is the static ontology. For this, we reduce our problem to the problem of finding minimal inconsistent subsets, also called justifications [21].\nDefinition 4 (Justification). Given an ontology O, a subset of axioms J \u2286 O is a justification iff J |= \u22a5 and for all J' \u2282 J : J' \u22ac \u22a5. We denote the set of all justifications by AllJust(O).\nIndeed, justifications can be used to compute what we need:\nLemma 2. For sets O and F of axioms s.t. O \u2229 F = \u00d8 and some axiom a, the following two sets are identical:\n1. {F \u2286 F | O \u222a F |= a, F is minimal}"}, {"title": "Basic Algorithm", "content": "Our basic algorithm is based on the Hitting-Set-Tree algorithm pro-posed by Reiter [32], which can also be used to generate the set of all justifications for DL ontologies [21].\nThe algorithm assumes a method SINGLEJUST(O) that returns an arbitrary justification for O. There are standard implementa-tions available, i.e. as part of the OWL API [17], that compute SINGLEJUST(O) using a black box approach. The algorithm builds a hitting-set tree (HST) where each node is labeled with a justifica-tion, and edges are labeled with axioms. The HST has the property that, if a path from the root is labeled with axioms A and ends on a node labeled with a justification J, then J is a justification for O \\ A.\nTo compute the HST, we use a recursive algorithm that starts with an arbitrary justification J for O, and then generates successor nodes by considering all possibilities of removing an axiom a \u2208 J from O, so that eventually all justifications are found. More details on the algorithm and a proof why this algorithm works in general for DL ontologies can be found in [21].\nThe general algorithm is depicted in Figure 2. For simplicity, we omit the common optimization of cutting branches, if their path con-dition is a superset of an already completed path, which we still use in our implementation. The main function COMPUTEHST builds the hitting-set tree given an ontology Os, a set of fluent axioms F, the set of all already found justifications J and the content of the cur-rent path leading to the node. In lines 7-9, the algorithm checks if we already found a fitting justification, to reduce the number of calls to SINGLEJUST. Otherwise, we use SINGLEJUST in Line 11. The func-tion SUCCESSORS generates the set of axioms to branch on. This function will be changed in the optimized versions of the algorithm. While the algorithm in [21] branches on all axioms in the justifica-tion, we only branch on the fluent axioms. This is sufficient since we do not really need all justifications, but only the ones that differ in their intersections with F.\nTheorem 3. Given an ontology O and a set F of axioms, ALLJUSTIFICATIONS(O \u222a F, F) computes all minimal subsets F \u2286 Fs.t. O \u222a F |= \u22a5.\nProof. The theorem follows directly from the original proof by Re-iter [32, Theorems 4.4 and 4.8], where our set of fluents F corre-sponds to the set of \"components\" in Reiter's proof.\nIt follows from Theorem 3 and Lemma 2 that we can use this al-gorithm to compute all required pairs (a, F) and thus ent(a)."}, {"title": "Concept-Based Algorithm", "content": "Our first optimization of the basic algorithm considers Observa-tions O1 and O2: If we compute the justifications of Os \u222a F \u222a {a} for each a separately, we will compute all justifications for Os \u222a F several times. We avoid these redundant computations with the concept-based algorithm, which generates one HST that contains the justifications needed for all queries of the same form. For simplicity, we assume that every a \u2208 Q is a concept assertion, i.e. an axiom of the form C(a). This is possible wlog since in OWL DL, every ABOX axiom can be equivalently expressed as concept assertion.\nFix a concept C and some I \u2282 N\u2081 so that Qc = {C(a) | a \u2208 I} is a set of assertions for which we want to compute justifications. We introduce a fresh concept name Ac, and add to the ontology the axiom C \u2293 Ac \u2286 \u22a5 and the assertions Qc = {Ac(a) | a \u2208 I}.\nThe following lemma shows that this ontology can be used to gen-erate the required sets of fluent.\nLemma 4. For O' = O \u222a F \u222a {C \u2293 Ac \u2286 \u22a5} \u222a Q'c, the following are identical:\n1. {(a, F) \u2286 Qc \u00d7 2F | O\uff61 \u222a F |= a, F is minimal}\n2. {{C(a), J \u2229 F) | J \u2208 AllJust(O', F), and Ac(a) \u2208 J or J \u2229 Qc = \u2205}."}, {"title": "Schema-Leveraging Algorithm", "content": "Looking at the generated HSTs, e.g. in Figure 3, we observe that many justifications are structurally the same and only differ in the individuals used in the ABox axioms (Observation O3). This is es-pecially undesired in cases where there are many individuals that oc-cur in the same Abox axioms. This can e.g. happen if the individuals describe waypoints that can all be occupied by all mobile objects. Calling SINGLEJUST is relatively costly, since each time it has to explore the space of subsets of the current ontology, and check their consistency using calls to the black box reasoner. We can thus im-prove the run time of our algorithm significantly if we can reduce the number of calls to SINGLEJUST.\nWe fix a set X of variables. A valuation is a partial function val: X \u2192 N\u2081. An axiom pattern is an axiom where some indi-vidual names may be replaced by variables. Given an axiom pattern A, val(A) denotes the set of axiom patterns obtained from A by re-placing each variable x for which val(x) is defined by val(x).\nDefinition 5. A justification schema is a pair (J, Val) s.t. J is a set of axiom patterns, Val is a set of valuations, and for each val \u2208 Val, val(J) is a subset-minimal set s.t. val(J) |= \u22a5 and val(J) is minimal. We then call val(J) an instantiation of (J, Val).\nWhenever a justification J is found, we construct the correspond-ing axiom patterns A by replacing every individual by a distinct vari-able in the axioms of the justification. After that, we identify the associated justification schema (J, Val), i.e. we search in the ontol-ogy (O \u222a F \u222a Qc) for fitting axioms to compute all valid valuations val, taking into account also the static type of the query. This check is purely syntactic and therefore much faster than computing the justifi-cations with a reasoner. Using the justification schema, we compute all justifications that follow the same schema by computing val(J) for all valuations val in the schema. The found justification are then added to the set of all found justifications. This change in the algo-rithm does not affect the correctness result from Theorem 5 as it does not affect the structure of the hitting-set tree."}, {"title": "Evaluation", "content": "5.1 Implementation\nWe implemented all the tailored hitting-set-tree algorithms. We used the reasoner system HermiT [12] for our implementation but it is in general agnostic to which reasoner is used.\nWe add the generated derivation rules to the otherwise unchanged PDDL domains. We used the fast-downward planning system [15] with the heuristic A* for planning. Although not the most advanced heuristic, this is, as far as we know, the best that can handle the struc-ture of the derivation rules as generated by our algorithm.\n5.2 Experiments\nBenchmark Sets As we are the first to present a planning approach that works with OWL-DL ontologies, finding benchmark sets that use ontologies based on OWL-DL is difficult. In total, we gathered 116 planning problems from five different domains. Three bench-mark domains (drones, queens and robotConj) come from existing work on planning with Horn-DLs [7]. We choose from this work the benchmark sets with the the most expressive TBox axioms, namely the ones that go beyond DL-Lite, as we are looking for ontologies based on expressive DLs.\nThe two other benchmark sets were created by ourselves. The do-main \"blocksworld\" is adapted from the blocksworld domain as de-scribed in Example 1. The ontology describes the parts and capabil-ities of a robot interacting with the blocks. The axioms in this on-tology go beyond what can be handled by other existing approaches."}, {"title": "Proofs of Lemmas and Theorems", "content": "Lemma 2. For sets O and F of axioms s.t. O \u2229 F = \u00d8 and some axiom a, the following two sets are identical:\n1. {F \u2286 F | O \u222a F |= a, F is minimal}\n2. {J \u2229 (F \\ {\u00aca}) | J \u2208 AllJust(O \u222a F \u222a {\u00aca})}.\nProof. \"\u2282\": Let F \u2286 F be a minimal set with O \u222a F |= q. Then, there is a minimal set J \u2286 O \u222a F with J |= q. Because F is minimal, it is completely contained in J, i.e. F \u2286 J. J \u222a {\u00acq} |= \u22a5, because q can be inferred from J. Hence, J \u222a {\u00acq} or J are a justification for the ontology O \u222a F \u222a {\u00acq} (because J is minimal). Using the facts that q \u2209 F, because \u00acq can not be part of a minimal explanation of q, and O \u2229 F = \u00d8 it follows that F = J \u2229 (F \\ {\u00acq}).\n\"\u2283\": Let J \u2208 AllJust(O \u222a F \u222a {\u00acq}) be a justification. Let J' = J \\ {\u00acq} and we show that J' |= q. If {\u00acq} \u2209 J, we know that J' is inconsistent and models everything, including q. If {\u00acq} \u2208 J, we know that J' is consistent as all justifications are minimal. Hence, we can infer q from J' as this is the only reason for an inconsistency together with \u00acq. We split J' = O' \u222a F such that O' \u2282 O and F \u2282 F. Because J' |= q, we infer that O' \u222a F \u2282 O \u222a F |= q.\nTheorem 5. Given an ontology O, a set of fluent axioms F and a set of queries Q, the concept-based algorithm computes all minimal subsets F \u2286 F s.t. O \u222a F |= \u22a5.\nProof. Correctness of the algorithm is trivial as a black-box expla-nation generator is used to generate the justifications.\nThe argumentation for completeness needs more work. According to Theorem 3, the algorithm works correctly, if it only branches by fluent and query axioms independently. We need to show, that the additional restrictions, i.e. the Ac(a) axioms on the branches do not omit valid justifications. To do so, we fix a node v and show that each of the justifications occurring in one of the child nodes in the tree of the original algorithm can also occur in a child node in the tree of the concept-based algorithm. Assume that the node v contains the axiom C \u2293 Ac \u2286 \u22a5. Otherwise, the labels on the branches are the same as for the basic algorithm, so the algorithm is trivially correct. Then, the node v contains exactly one assertion of the form Ac(a) (at least one, because otherwise C \u2293 Ac \u2286 \u22a5 is not required; at most one, because of the minimality of justifications.) Every justification in a child that does not contain Ac(a) can occur in the tree below the branch labeled with Ac(a). Every other child contains Ac(a) and therefore no other Ac(b) (because of the minimality of justifica-tions). In the tree of the basic algorithm, there is a fluent axiom f that is a label of the branch to the sub-tree that contains the child. In the tree of the concept-algorithm, the child node can occur in the sub-tree where the branch is labeled with {f} \u222a {Ac(b) | b \u2208 N\u2081, b != a}.\nLemma 4. For O' = O \u222a F \u222a {C \u2293 Ac \u2286 \u22a5} \u222a Q'c, the following are identical:\n1. {(a, F) \u2286 Qc \u00d7 2F | O\uff61 \u222a F |= a, F is minimal}\n2. {{C(a), J \u2229 F) | J \u2208 AllJust(O', F), and Ac(a) \u2208 J or J \u2229 Qc = \u2205}.\nProof. \"\u2282\": Let (Q(i), F) with O \u222a F |= Q(i) such that F is min-imal. Then, there is a minimal set J \u2282 O \u222a F with J |= Q(i). Because F is minimal, it is completely contained in J, i.e. F \u2286 J. As Q(i) can be inferred from J, the set J' = J \u222a {Q' | Q' \u2286 \u22a5, Q'(i)} is inconsistent. Hence, one of the sets J, or J' is a justification for the inconsistency of O' (because J is minimal). The sets J \u222a {Q'(i)} and J \u222a {Q | Q' \u2286 \u22a5} can not be such justifications because the concept Q' only occurs in the axiom Q \u2293 Q' \u2286 \u22a5 and Q' does not occur in O or F. Hence, if J \u222a {Q'(i)} or J \u222a {Q | Q' \u2286 \u22a5} is inconsistent, so is J. No matter if J or J' is a justification, they are relevant for the second set and J \u222a F = J' \u222a F = F. Hence, (Q(i), F) is contained in the second set.\n\"\u2283\": Let J \u2208 AllJust(O') be a justification. We distinguish two cases. (i) If J \u2229 Q' = \u00d8, the pair (Q(i), J \u2229 F) is in the set for all Q(i) \u2208 Q. Because J is minimal, contains no assertion from Q' and the concept Q' occurs nowhere else, we know that {Q \u2293 Q' \u2286 \u22a5} \u2209 J. Hence, J \u2282 O \u222a F. Let F = (J \u2229 F) be the set of all fluent axioms in J. As J is inconsistent, so is O \u222a F and therefore O \u222a F |= Q(i) for all Q(i). (ii) If there is a Q'(i) with Q'(i) \u2208 J \u222a Q', we know that J' = J \\ {Q \u2293 Q' \u2286 \u22a5} must be consistent as J is minimal. Therefore, J' |= Q(i) as this is the only possibility that J is inconsistent. As the concept Q' occurs in neither O nor F, the assertion Q'(i) is not be necessary to infer Q(i) in J' and we infer that J' \u2229 (O \u222a F) |= Q(i). Therefore, there is a set F = J' \u222a F = J \u222a F with O \u222a F |= Q(i)."}, {"title": "Further Plots", "content": "We compare the time needed to solve the planning problems for HORN and SCHEMA in more detail. Figure 6 shows comparisons for the time used for reasoning, planning and the total time.\nThe first plot shows how different the first computation step of the two algorithms is. Because HORN only translates the ontology axioms into derivation rules, the computation time is always short (around 1s). On the other hand, SCHEMA generates all explanations for the queries for the different individuals. Hence, the reasoning needs way more time, especially when there are many individuals. However, this initial effort can pay off for instances where a large portion of the search space needs to be explored.\nThe second plot shows, why this is the case: the algorithm SCHEMA results in fewer time spend by the reasoner to find a plan. Depending on the example, the advantage can be by an order of mag-nitude or even higher. This is due to the structure of the generated derivation rules. While HORN generates rules that hierarchical de-pend on each other, the rules created by SCHEMA creates rules that only add one layer on top of the planning atoms. Thus, evaluating a state is much faster for SCHEMA. This pays especially off for the instances where many states need to be evaluated, i.e. the hardest planning problems.\nIn total, this results in a mixed picture for the total time (depicted in the third plot). While HORN is faster for most instances, there are some instances for which SCHEMA is faster."}]}