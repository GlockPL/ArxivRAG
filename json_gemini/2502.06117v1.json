{"title": "Revisiting Dynamic Graph Clustering via Matrix Factorization", "authors": ["Dongyuan Li", "Satoshi Kosugi", "Ying Zhang", "Manabu Okumura", "Feng Xia", "Renhe Jiang"], "abstract": "Dynamic graph clustering aims to detect and track time-varying clusters in dynamic graphs, revealing the evolutionary mechanisms of complex real-world dynamic systems. Matrix factorization-based methods are promising approaches for this task; however, these methods often struggle with scalability and can be time-consuming when applied to large-scale dynamic graphs. Moreover, they tend to lack robustness and are vulnerable to real-world noisy data. To address these issues, we make three key contributions. First, to improve scalability, we propose temporal separated matrix factorization, where a single matrix is divided into multiple smaller matrices for independent factorization, resulting in faster computation. Second, to improve robustness, we introduce bi-clustering regularization, which jointly optimizes graph embedding and clustering, thereby filtering out noisy features from the graph embeddings. Third, to further enhance effectiveness and efficiency, we propose selective embedding updating, where we update only the embeddings of dynamic nodes while the embeddings of static nodes are fixed among different timestamps. Experimental results on six synthetic and five real-world benchmarks demonstrate the scalability, robustness and effectiveness of our proposed method. Source code is available at https://github.com/Clearloveyuan/DyG-MF.", "sections": [{"title": "1 Introduction", "content": "Dynamic graph clustering, also known as dynamic community detection, aims to leverage graph topological structures and temporal dependencies to detect and track evolving communities [4, 34, 48]. As an effective tool to reveal the complex evolutionary rules behind complex real-world systems, dynamic graph clustering has drawn great attention in various fields, such as social analysis [18, 30, 76, 81], recommendation [55, 64, 73, 77], and AI4Science [19, 27, 53, 56].\nMuch research in recent years has been proposed for dynamic graph clustering, which can be broadly classified into two classes [50]. (i) Neural Network-based methods [14, 35, 66, 68] generally focus on learning dynamic node embedding, with clustering methods often applied as a post-processing step. These methods separate node embedding learning and clustering into two independent steps, leading to sub-optimal performance [10, 26]. To relieve this issue, (ii) Matrix Factorization-based methods [3, 8, 26, 32, 33, 38] have been widely proposed. These methods can jointly optimize clustering and dynamic node embedding learning simultaneously, i.e., they cluster nodes at each timestamp while maintaining temporal smoothness of node embedding among different timestamps, achieving overall optimal performance on many benchmarks.\nDespite the great success of matrix factorization-based methods, there are still two challenges. (i) Weak Scalability. Matrix factorization is an NP-hard problem with a time complexity of approximately O(n\u00b3) and a space complexity of O(n\u00b2) for a single graph containing n nodes [41, 61]. (ii) Low Robustness. Real-world dynamic graphs contain noise and missing data, which disrupt their regular evolution patterns and pose significant challenges for dynamic graph clustering [70, 75].\nTo address these issues, we propose a scalable and robust dy-namic graph clustering framework via seperated matrix factoriza-tion, called DyG-MF, containing three key contributions. Firstly, to enhance scalability, we propose (i) Temporal Separated Matrix Factorization. We apply temporal matrix factorization in a \u201cdivide and conquer\" manner [31, 54], where we randomly divide the nodes into subsets and transform the original large-scale matrix factoriza-tion problem into several independent matrix factorization of these subsets. Since matrix factorization is applied separately to these smaller subsets, it also reduces computational cost. To achieve this, we design the temporal landmark selection, ensuring coherence of node embeddings across different subsets at current timestamp and maintaining consistency of node embedding between differ-ent timestamps. Secondly, to improve robustness, we introduce (ii) Bi-clustering Regularization, which reduces the impact of noisy features on dynamic graph clustering by optimizing the rank of the matrix. We further proof this regularization can be spreadable and applied as a constraint in the matrix factorization of each node subset. Finally, to further enhance effectiveness and efficiency, we propose (iii) Selective Embedding Updating. We first divide the nodes into dynamic and static groups by jointly considering their topological and embedding changes. We then only update node embeddings of the dynamic group while keeping the node embed-dings in the static group fixed across different timestamps. The main contributions of this study can be summarized as follows.\n\u2022 To enhance scalability and efficiency of matrix factorization-based methods, we design a temporal separated matrix fac-torization framework, where we divide a single large matrix into multiple smaller matrices for independent factorization.\n\u2022 To improve robustness, we adopt separable bi-clustering reg-ularization to filter out noisy features from node embeddings.\n\u2022 To further enhance effectiveness and efficiency, we propose selective embedding updating, where only the node embed-dings of the dynamic group are updated at each timestamp.\n\u2022 Experimental results on 11 benchmarks show the scalability, robustness, efficiency, and effectiveness of DyG-MF."}, {"title": "2 Related Work", "content": "Neural Network-based Methods. Some neural network-based methods employ coupled approaches, which first condense dynamic graphs into one static graph and then apply clustering methods, such as CNN-based [51, 79] and GNN-based methods [71, 80], to identify clusters. Other methods employ two-stage approaches, which first learn dynamic graph embeddings [1, 16, 72] and then apply clustering methods to these embeddings to identify clus-ters [6, 7, 37, 45, 65, 78]. For example, RNNGCN [66] and DGCN [14] use RNNs or LSTM to capture temporal dependencies for graph embeddings, which are then clustered using graph convolutional layers. CI-GCL [57] adopts a community invariance graph con-trastive learning framework for graph clustering and classification. ROLAND [68] extends static GNN-based graph embedding meth-ods to dynamic graphs by using gated recurrent units to capture temporal information. To reduce time consumption, SpikeNet [29] uses spiking neural networks to model the evolving dynamics of graph embeddings, achieving better performance with lower com-putational costs. For more related work, refer to [2, 24, 74, 82]. The main issue with NN-based methods is their separation of dynamic graph embedding and clustering into two independent processes, making it difficult to ensure that graph embedding provides the most suitable features for clustering [10, 26]. Furthermore, most of them face weak scalability and interpretability issues on large-scale graphs [20, 62]. Thus, we focus on separated matrix factorization, jointly optimizing dynamic graph embedding and clustering, and improving scalability and interpretability.\nMatrix Factorization-based Methods. Matrix factorization-based methods cluster nodes at each timestamp using matrix factorization while optimizing the temporal smoothness of node embeddings among different timestamps. Recently, numerous methods with dif-ferent strategies have been proposed to improve temporal smooth-ness. For example, sE-NMF [39], jLMDC [26], and NE2NMF [28] esti-mate temporal smoothness by analyzing topology changes between graphs at the current and previous timestamps, while PisCES [32] smooths clusters by considering topology changes across the entire dynamic graph. In contrast, other methods use clustering metrics or reconstruction loss to measure temporal smoothness. For example, DynaMo [83] improves temporal smoothness by incrementally max-imizing modularity between successive graphs, and PMOEO [52] and MODPSO [67] employ evolutionary algorithms to minimize the NMI of clusters across different timestamps. Although these meth-ods can simultaneously optimize clustering accuracy and temporal smoothness, they often suffer from low robustness and lack fine-grained node-level temporal smoothing strategies. In this study, we address these issues and enhance robustness, scalability, and practicality for large-scale real-world dynamic graphs."}, {"title": "3 Preliminary", "content": "Dynamic Graph Clustering. We consider a dynamic graph as a sequence of snapshots and the t-th snapshot Gt = (Vt, &t), defined for 0 \u2264 t \u2264 \u03c4. Here, Vt and Et represent the set of nodes and edges in the t-th snapshot. Let the graph contain n nodes and Wt \u2208 Rnxn and Mt \u2208 Rnxn represent the weighted adjacency matrix and pointwise mutual information matrix [47] for the t-th snapshot Gt, respectively. In M\u2081, each element mij = log $\\frac{W_{ij}E_k}{d_id_k}$, with di as the degree of the i-th node. Dynamic graph clustering seeks to detect a set of non-overlapping clusters for Gt, which corresponds to a partition of Vt. This partition is represented as Vt = {Vi,t}, where et represents the number of clusters.\nMatrix Factorization. We first introduce a matrix factorization-based baseline, which we refer to as temporal matrix factorization. Inspired by Qiu et al. [47], factorizing pointwise mutual information"}, {"title": "4 Methodology", "content": "As shown in Figure 2, our method DyG-MF consists of three main components: (i) temporal separated matrix factorization jointly learns graph embedding and clustering in Sec 4.1, (ii) bi-clustering regularization reduces noise and enhance robustness in Sec 4.2, and (iii) selective embedding updating aims at better embedding alignment in Sec 4.3. We will introduce each component in order."}, {"title": "4.1 Temporal Separated Matrix Factorization", "content": "Directly optimizing Eq.(4) is unacceptable time-consumption for large-scale dynamic graphsm, since its time and space complexity is O(n\u00b3) and O(n\u00b2) for a graph with n nodes. To solve this issue, we propose temporal separated matrix factorization which transforms one large matrix factorization problem into several small matrix factorization sub-problems. The key point is to select a few nodes, called landmarks, to ensure consistency and coherence in node embeddings across all small matrix factorization.\nTemporal Landmark Selection in Fig 2(a). A simple idea is to select the nodes closest to each cluster center as landmarks, ensur-ing that these nodes are representative at the current timestamps. If we follow K-means clustering, the 1-th cluster centers at the t-th timestamp 01, can be found by repeating the following process:\narg  min\\n{\u0398\u2081}\u2081=\u2081 \u03a3\u2081=\u2081 \u03a3\u03b1\u2208\u03b8\u2081 (||mat \u2013 01,t||12), (5)\nwhere ma.,t is the a-th row vector of Mt, Qt is the number of clus-ter centers, automatically determined by the elbow method [60], {\u0398\u2081}\u2081=\u2081 represent current nodes' clusters, a \u2208 \u0398\u03b9\u00b8t indicates that the a-th row vector ma.,t is closest to the 1-th cluster center 01. The problem with the above strategy is that it does not consider successive timestamps. To solve this issue, we propose a temporal landmark selection strategy. We re-formulate Eq.(5) as follows:\nargmin\\n{\u0398\u2081} \u03a3 \u03a3 (||mat \u2013 01,t||12 + \u03bb||ma,t-1 - 01,t||2), (6)"}, {"title": "4.2 Bi-clustering Regularization", "content": "Real-world dynamic graphs always contain much noise and irregu-lar evolution patterns, directly obtaining communities from Ct will be easily affected by noisy data (Figure 6). To improve robustness against noise and jointly optimize graph embedding and clustering, we introduce bi-clustering theory [44] as a regularization item into our overall objective function Eq.(12). To realize this goal, we first introduce the nuclear norm theory as follows."}, {"title": "4.3 Selective Embedding Updating", "content": "The item \u03a3=\u2081 ||C \u2013 C_1 || in Eq. (13) ensures temporal smooth-ness between timestamps; however, the primary focus is on overall smoothness, and the fine-grained smoothness between individual node pairs is overlooked. This results in heterogeneity in node em-bedding between successive snapshots, thus severely undermining interpretability and visualizability during the analysis of dynamic community trajectories. To avoid this issue and further improve clustering efficiency and accuracy, we devise a fine-grained node-level temporal smoothing strategy. We first separating nodes into static and dynamic groups and then update only the embeddings of those dynamically changing nodes, while the embeddings of static nodes are fixed and shared between each timestamp.\nMost nodes in dynamic graphs follow gradual and stable evolu-tion patterns, maintaining their embeddings relatively unchanged over time [36]. The remaining dynamic nodes are defined as those"}, {"title": "4.4 Complexity Analysis", "content": "Time Complexity. The time complexity of selecting |Ut| land-marks with et clustering centers of all nodes |V1| using Eq.(7) is O(|Vt etl1|), where l\u2081 is the number of iterations for converging to the optimal global solution. The time complexity of performing It and It is O(|Ut|2rl2), where r is the number of dimensions and 12 is the number of iterations to optimize Eq.(15) by gradient descent. The time complexity of updating F for block C with |\u0413| nodes is O(\\U\u2081|\u00b3+|U\u2081|2|\u0413\u2021]) [44]. Taking into account the above complexity, the total time complexity of using our method for dynamic graphs with t timestamps is O(|U\u2081|\u00b3 + |U\u2081|2|\u0413| + |Ut|\u00b2rl2 + |Vt|etl1) = O(max{ |Ut |, |\u0413|, rl2 } |U1|2), while standard matrix factorization methods need time complexity of O(|V1|\u00b3). Compared to standard matrix factorization methods, our method is more efficient.\nSpace Complexity. Since our method takes only snapshots Gt-1, Gt, and Gt+1 as input to identify communities in the t-th timestamp, the space complexity is O(|V1|2) including the space O(|V1|r) to store the matrices Ct and Ht with r as the dimensions of matrix."}, {"title": "5 Experiment", "content": "Datasets. In Table 1, we evaluate baselines on six synthetic dy-namic graphs and five real-world dynamic graphs. Synthetic dy-namic graphs are generated following regular evolution rules. SYN-FIX/SYN-VAR [21] randomly exchange communities of some nodes. Green datasets [13] consider four evolution events including Birth-Death, Expand-Contract, Hide, and Merge-Split. We also evaluate on real-world domains, including Academic Graphs: arXiv [23]; Social Graphs: Dublin [17] and Flickr [40] and Website Interaction Graphs: Wikipedia [22] and Youtube [40].\nBaselines. We compare our method with 14 best-performing base-lines, i.e., Neural Network-based methods: CSEA [12], DSCPCD [63], SepNE [31], node2vec [15], LINE [59], RNNGCN [66], ROLAND [68], and TGC [35]; and Matrix Factorization-based methods: PisCES [32], DYNMOGA [13], NE2NMF [28], RTSC [69], RDMA [48], and jL-MDC [26].\nImplementation Details. Following previous works [32, 39], we use normalized mutual information (NMI) [8] and normalized F1-score (NF1) [49] to measure clustering accuracy. We reproduced the baselines using their optimal parameters and reported average performance over five repeated runs with different random seeds. We conducted multiple t-tests to assess the statistical significance of the performance. We took Birth-Death-30K as validation datasets for hyperparameter tuning. With grid search, DyG-MF achieves the best performance when s = 50, dimension of embeddings r = 1,000, percentage of landmarks ||Ut || = 0.5, percentage of dynamic nodes \u03bc = 0.16, \u03bb = 0.2 and \u03b2 = 20."}, {"title": "5.1 Performance Evaluation", "content": "The performance of various baselines in terms of NMI and NF1 scores on synthetic and real-world dynamic graphs is shown in Ta-ble 2. We observe that DyG-MF achieves the highest NMI and NF1 scores across all dynamic graphs. This can be attributed to its tem-poral separated matrix factorization, bi-clustering regularization, and selective embedding updating. Specifically, compared to the neural network-based methods RNNGCN and ROLAND, DyG-MF improves NMI scores by 5% and 3.8% on Flickr and Youtube, since DyG-MF jointly optimizes node embeddings and clustering, ensur-ing that node embeddings provide the most suitable features for clustering. In comparison with matrix factorization-based baselines, DyG-MF outperforms them by leveraging fine-grained temporal smoothness to capture dynamics at the node level"}, {"title": "5.2 Scalability Evaluation", "content": "Table 3 shows the detailed running time of DyG-MF and baselines on large-scale dynamic graphs. Compared to the fastest baseline, SepNE, DyG-MF reduces the running time by 44.61% across all dynamic graphs, with a 52.27% reduction on synthetic dynamic graphs and 37.00% on real-world ones."}, {"title": "5.3 Robustness Evaluation", "content": "Real-world dynamic graphs often contain much noise and exhibit ir-regular evolution patterns. Table 2 and Figure 3 show that DyG-MF outperforms all baselines on real-world dynamic graphs, demon-strating its ability to filter out noise and capture more complex evolution patterns. To further support our statement, as shown in Figure 6, we contaminate dynamic graphs by adding 5%~30% noisy edges in each snapshot, following Tan et al. [58]. Compared to the best-performing baselines, DyG-MF shows a less performance degradation, indicating its robustness against temporal noisy edges. We also observe that w/o bi-clustering regularization significantly decreases the NMI score, showing that bi-clustering regularization serves as the main component of DyG-MF in maintaining robust-ness against noise attacks in dynamic graphs."}, {"title": "5.4 Ablation Study", "content": "We conduct an ablation study to evaluate the necessity of each component of DyG-MF. We consider the following three variants of DyG-MF: (i) without Temporal Separated Matrix Factorization (w/o TSMF): remove separated matrix factorization introduced in Sec 4.1 and replace it with Eq.(4); (ii) without Bi-clustering Regularization (w/o BR): remove bi-clustering regularization in-troduced in Sec 4.2; (iii) without Selective Embedding Updating"}, {"title": "5.5 Hyperparameters Analysis", "content": "We use the first snapshot of four synthetic event datasets as val-idation data to tune the hyperparameters {s, r, \u03b2, \u03bc, |Ut|}, where s represents the number of separated subsets, r is the dimension of the node embeddings, \u03b2 is the balanced parameter in Eq.(16), \u03bc indicates the number of dynamic nodes, and Ut\u2758 refers to the number of landmarks. Following previous studies [66, 68], we adopt a grid search method to tune each hyperparameter while keeping the other parameters fixed. In Figure 7(A), the number of clusters p is automatically determined by the elbow method. Figure 7(B)-(C) shows that with r = 1,000, \u03b2 = 20 and s = 50, DyG-MF achieves the highest NMI scores on the validation dataset. We do not display these parameters for the other three synthetic datasets, as they follow a similar trend. Figure 7(D)-(E) shows that when \u03bc\u2208 [16, 20] and Ut \u2208 [0.48, 0.52], DyG-MF achieves the best performance. Thus, we set \u03bc = 16 and |U1| = 0.5 for the rest experiments. Note that for small-scale datasets like SYN-FIX/SYN-VAR, we set s = 1."}, {"title": "5.6 Case Study", "content": "To clearly demonstrate the effectiveness of DyG-MF, we present a visualization of the detected clusters using the t-SNE plot of the second snapshot from Wikipedia. As shown in Figure 8(A), the initialized node embeddings are randomly distributed in the two-dimensional space, without any discernible community structures. After optimizing by DyG-MF, we learn representative and suitable node embeddings that can automatically cluster nodes into distinct clusters. To further illustrate the effectiveness, interpretability, and ro-bustness of DyG-MF, we provide a case study using a Sankey plot to show community structures in the 3rd and 4th snapshots of the SYN-VAR, as shown in Figure 8(C1)-(C2). DyG-MF can effectively track the evolution patterns of individual node, i.e., nodes from the second cluster in the 3rd snapshot are split into the second and third clusters in the 4th snapshot, highlighting DyG-MF's effectiveness and interpretability. Benefiting from the bi-clustering regulariza-tion, we can easily obtain the community evolution of nodes, where each diagonal block represents a community and the middle parts illustrate the transitions and changes between communities."}, {"title": "6 Conclusion", "content": "In this study, we proposed a novel scalable and robust temporal separated matrix factorization method to reveal the evolution mech-anism of complex real-world complex systems. By jointly estimating graph embedding and clustering with Bi-clustering regularization and selective embedding updating, our method can achieve SOTA performance on synthetic and real-world dynamic graphs, illus-trating its scalability, robustness, and effectiveness. In the future, we will design more separated matrix factorization strategies to preserve more global information, use incremental clustering to reduce time complexity during landmark selection, introduce dif-fusion models to enhance robustness, and extend our method to continuous-time dynamic graphs to enhance its flexibility."}, {"title": "A Limitations", "content": "The first limitation of this study is that DyG-MF only addresses non-overlapping clustering, while its performance on overlapping clustering remains underexplored. The second limitation is that DyG-MF has only been evaluated on large-scale real-world datasets containing up to 3,200,000 nodes, leaving its performance on even larger datasets still unexamined. Finally, with the advancement of natural language processing, many graph foundation models have been proposed. Exploring how to integrate these graph foundation models to obtain well-initialized node embeddings for improved performance is a promising area for future research."}, {"title": "B Pseudocode of DyG-MF", "content": "We give a Pseudocode of DyG-MF in Algorithm 1."}, {"title": "C More Details about Datasets", "content": "We conducted experiments on 11 widely used datasets, including six synthetic and five real-world datasets, as shown in Table 1. SYN Datasets. SYN-FIX and SYN-VAR were constructed with dif-ferent dynamic settings for vertices and communities [21]. SYN-FIX fixes the number of communities at four and generates snapshots by randomly moving three vertices from each original community to new communities from the second to the final timestamp. In contrast, SYN-VAR consists of 256 vertices belonging to four equal-sized communities, randomly moving eight vertices from each of the four communities to form a new community with 32 vertices from the second to the fifth timestamp. The generated snapshots are then copied and reversed to create the final five snapshots. Green Datasets. Considering the network sizes and the limited dynamic evolution of SYN-FIX/VAR, we generated four event-based temporal networks starting from the second timestamp [13]:\n\u2022 Birth-Death: 5% existing communities are removed/generated by randomly selecting vertices from other communities;\n\u2022 Expansion: 10% of communities are expanded or contracted by 50% of their original size;\n\u2022 Hide: 10% of the communities are randomly hidden;\n\u2022 Merge-Split: 20% of communities are split or merged.\nWe repeated the above process (t-1) times to construct the corre-sponding temporal networks, setting the number of timestamps"}]}