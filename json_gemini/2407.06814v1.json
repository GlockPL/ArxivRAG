{"title": "Historical Review of Variants of Informal Semantics for Logic Programs under Answer Set Semantics:\nGL'88, GL'91, GK'14, D-V'12", "authors": ["YULIYA LIERLER"], "abstract": "This note presents a historical survey of informal semantics that are associated with logic programming\nunder answer set semantics. We review these in uniform terms and align them with two paradigms: Answer\nSet Programming and ASP-Prolog- two prominent Knowledge Representation and Reasoning Paradigms\nin Artificial Intelligence. Under consideration in Theory and Practice of Logic Programming (TPLP).", "sections": [{"title": "Introduction", "content": "The transcript of the talk by Donald E. Knuth titled Let's Not Dumb Down the History of Com-\nputer Science published by ACM (2021) includes the statement:\nit would really be desirable if there were hundreds of papers on history written by computer\nscientists about computer science.\nThis quote was inspirational for this technical note devoted to a historical survey of informal\nsemantics that are associated with logic programming under answer set semantics (in the sequel\nwe mostly drop under answer set semantics when referring to logic programming and logic\nprograms).\nWe focus on four seminal publications and align informal semantics discussed there using the\nsame style of presentation and propositional programs. We trust that within such settings key\nideas and tangible differences between the distinct views come to the surface best. The earliest\npublication of the four dates back to 1988, and the latest dates back to 2014. It would seem\nthat the subject of informal semantics is only peripheral scoring at such a low count of major\nreferences. Rather, the word informal makes this subject rare in the discussions of logic pro-\ngramming. Nevertheless, the 2014 reference is an introductory chapter titled Informal Semantics\nof the textbook on Knowledge Representation, Reasoning, and Design of Intelligent Agents by\nGelfond and Kahl. The prominent position of this chapter points at the importance of the subject,\nespecially when we consider passing on the knowledge and practice of logic programming to a\nbroad audience.\nAs the presentation unfolds, a story of two views on logic programs will emerge. One view is\nvia the prism of answer set programming (ASP) and another view is via the prism of ASP-Prolog.\nWe reserve the term - ASP to a constraint programming paradigm, where an ASP practitioner\nwhile coding specifications of a considered problem ensures that the solutions to this problem\ncorrespond to answer sets of the coded program (Brewka et al., 2011). ASP is frequently asso-\nciated with solving difficult combinatorial search problems via a programming methodology of"}, {"title": "Formal and informal semantics of basic programs by GL'88", "content": "We start by recalling the formal and informal semantics of basic logic programs as they were\nintroduced by Gelfond and Lifschitz (1988).\nA basic rule is an expression of the form\n\\(A\\leftarrow B_1,..., B_n, not C_1,..., not C_m,\\)\nwhere A, Bi, and Cj are propositional atoms. The atom A is the head of the rule and the expression\n\\(B_1,..., B_n, not C_1, ..., not C_m\\) is its body. A basic (logic) program is a finite set of such rules. In\nthe sequel, we introduce rules of somewhat different syntactic structure, yet we agree to call the\nleft-hand side of the rule operator/connective, denoted by \u2190, head and the right-hand side body.\nA rule whose body is empty (n = m = 0) is called a fact; in such rules connective \u2190 is often\ndropped.\nFor a ruler of the form (1) and a set X of atoms, the reduct \\(r^X\\) is defined whenever there is no\natom Cj for \\(j \\in \\{1,...,m\\}\\) such that \\(C_j \\in X\\). If the reduct \\(r^X\\) is defined, then it is the rule\n\\(A\\leftarrow B_1,..., B_n.\\)\nThe reduct \\(\\Pi^X\\) of the program I consists of the rules \\(r^X\\) for all \\(r\\in \\Pi\\), for which the reduct is\ndefined. A set X of atoms satisfies rule (2) if A belongs to X or there exists \\(i \\in \\{1, ..., n\\}\\) such that\n\\(B_i \\notin X\\). We say that a set X of atoms is a model of a program consisting of rules of the form (2)\nwhen X satisfies all rules of this program. A set X is a stable model/answer set of I, denoted\n\\(X^{\\mathit{st}} \\models \\Pi\\), if it is a subset minimal model of \\(\\Pi^X\\).\nQuotes by Gelfond and Lifschitz (1988) on Intuitive Meaning of Basic Programs (verbatim mod-\nulo names for programs and sets of atoms):\nQuote 1: The intuitive meaning of stable sets\u00b9 can be described in the same way as the intuition\nbehind \"stable expansions\u201d in autoepistemic logic: they are \"possible sets of beliefs that a rational agent\nmight hold\u201d (Moore 1985) given I as his premises. If X is the set of (ground) atoms that I consider\ntrue, then any rule that has a subgoal not C with \\(C \\in X\\) is, from my point of view, useless; furthermore,\nany subgoal not C with \\(C \\notin X\\) is, from my point of view, trivial. Then I can simplify the premises \u03a0\nand replace them by \\(\\Pi^X\\). If X happens to be precisely the set of atoms that logically follow from the\nsimplified set of premises \\(\\Pi^X\\), then I am \u201crational\u201d.\nLater, Gelfond and Lifschitz (1991) say about a basic program the following:"}, {"title": "ASP and ASP-Prolog", "content": "Answer Set Programming Marek and Truszczynski (1999) and Niemel\u00e4 (1999) open a new era\nfor stable model semantics by proposing the use of logic programs under this semantics as con-\nstraint programming paradigm for modeling combinatorial search problems. This marks the birth\nof ASP. Here is what the abstract of the paper by Marek and Truszczynski says:\nWe demonstrate that inherent features of stable model semantics naturally lead to a logic program-\nming system that offers an interesting alternative to more traditional logic programming2... The pro-\nposed approach is based on the interpretation of program clauses as constraints. In this setting programs\ndo not describe a single intended model, but a family of stable models. These stable models encode so-\nlutions to the constraint satisfaction problem described by the program. ... We argue that the resulting\nlogic programming system is well-attuned to problems in the class NP, has a well-defined domain of\napplications, and an emerging methodology of programming.\nIn other words, Marek and Truszczynski and Niemel\u00e4 propose to see logic rules of the program\nas specifications of the constraints of a problem at hand. Logic programming is seen as a provider\nof a general-purpose modeling language that supports solutions for search problems. Let us make\nthese claims precise by considering the notion of a search problem following the lines by Brewka\net al. (2011). A search problem P consists of a set of instances with each instance I assigned a\nfinite set \\(S_P(I)\\) of solutions. In the proposal by Marek and Truszczynski and Niemel\u00e4, to solve\na search problem P, one constructs a logic program \\(I_P\\) that captures problem specifications so\nthat when extended with facts \\(F_I\\) representing an instance I of the problem, the answer sets of\n\\(I_P \\cup F_I\\) are in one to one correspondence with members in \\(S_P(I)\\). In other words, answer sets of\n\\(\\Pi_P \\cup F_I\\) describe all solutions of problem P for the instance I. Thus, solving a search problem P is\nreduced to finding a uniform logic program that we denoted as \\(\\Pi_P\\) which encodes problem's\nspecifications/constraints.\nThe logic rules of the program the key syntactic building blocks of logic pro-\ngramming become the vehicles for stating constraints/specifications of a problem un-\nder consideration. A program is typically evaluated by means of a grounder-solver pair. A"}, {"title": "\u201cFormalizing\u201d Quotes 1 and 2 or Informal Semantics of Basic Programs by GL\u201988", "content": "Before we attempt to make the claims of Quote 1 by Gelfond and Lifschitz (1988) precise it is\ndue to discuss three interrelated and yet different concepts and how we understand them within\nthis note:\n\u2022 a state of affairs,\n\u2022 a belief state, and\n\u2022 a set of beliefs/belief set.\nThe following example is our key vehicle in this discussion.\nExample 1\nConsider a toy world with four possible states of affairs that fully describe it:\nMary is a student\n1\nJohn is a student\n2 Mary is a student\nJohn is not a student\n3 Mary is not a student 4 Mary is not a student\nJohn is a student\nJohn is not a student\nA belief state is associated with/represented by a conglomeration of states of affairs. In other\nwords, a belief state assumes that multiple states of affairs can be deemed as possible by an agent.\nThus, a belief state is often associated with an agent who has partial knowledge of the world.\nReturning to our toy world, the powerset of the listed four states of affairs forms the set of\nbelief states for an agent operating in this world. For example, if an agent assumes a belief state\nconsisting of states 1, 2, 3, 4 of affairs let us denote it as bs\u2081\u2212, we may conclude that this agent\ndeems everything possible (or knows nothing factual about the world). If an agent assumes a\nbelief state consisting of states 1 and 2 of affairs let us denote it as bs2-, we may conclude that\nthis agent is aware of the fact that Mary is a student, whereas John may or may not be a student.\nIn turn, if an agent assumes a belief state consisting of a single state 1 let us denote it as bs3\u2212,\nthen we may conclude that this agent is aware of the two facts: Mary is a student and John is a\nstudent.\nWe now connect the concepts of a belief set (or, a set of beliefs) and a belief state. The former\nis an abstraction of the latter. In other words, we understand belief sets as entities that cap-\nture/encode belief states. This encoding may lose some information so that multiple belief states\nmay be \u201cconsistent\u201d with a single belief set. For instance, in the context of our toy world, a belief\nset consisting of a single proposition Mary is a student is consistent with any belief state that\ncontains either state 1 of affairs or state 2 of affairs. Note how this belief set cannot distinguish\nbetween these different belief states. Indeed, a belief set consisting of a single proposition Mary\nis a student cannot distinguish between belief states bs1, bs2, and bs3.\nWe are now ready to return to the claims of Quote 1 by Gelfond and Lifschitz (1988) and\nattempt to make these precise with the allowance that programs with multiple answer sets that\ncorrespond to possible sets of beliefs/possible interpretations are as valid programs as so-called\nwell-behaved programs. In other words, per Quote 1 each answer set represents a set of beliefs\nof a rational agent (or I); thus this agent may have multiple sets of beliefs. In the sequel, we drop\nthe reference to \u201cor I\u201d and use \u201can agent\u201d in the discourse\u2074. In the case of basic programs, we\ntake an understanding that\nthe absence of an atom A in a stable model represents the fact that A is false.\nThis understanding is consistent with the view by Gelfond and Lifschitz, which is reiterated in\nQuote 4 in Section 3.\nClaim (3) on the interpretation of answer sets has profound ramifications. Namely, this claim\nmakes the three concepts a state of affairs, a belief state, and a set of beliefs/belief set\nexemplified earlier by highlighting their differences collapse into a single entity. Let us use an\nexample to illustrate this point.\nExample 2\nRecall the toy world from Example 1. Let us take atoms student(mary) and student(john) to\nrepresent propositions Mary is a student and John is a student, respectively. If our signature of\ndiscourse is composed only of these two atoms, we can construct four distinct subsets of atoms\nwithin this signature, namely,\n\\(\\mathit{\\{student(mary), student(john)\\}; \\{student(mary)\\}; \\{student(john)\\}; 0.}\\)"}, {"title": "Formal and informal semantics of extended programs by GL\u201991", "content": "Here, we recall the formal and informal semantics of extended logic programs by\nGelfond and Lifschitz (1991). An alternative view of the informal semantics for extended logic\nprograms is provided in (Gelfond and Kahl 2014, Section 2.2.1) reviewed next.\nA literal is either an atom A or an expression \u00acA, where A is an atom. An extended rule is an\nexpression of the form (1), where A, B\u00a1, and Cj are propositional literals. An extended program\nis a finite set of extended rules. Gelfond and Lifschitz (1991) also considered disjunctive rules of\nthe form \\(D_1 \\text{ or } ... \\text{ or } D_1 \\leftarrow B_1, ..., B_n, not C_1, ..., not C_m\\), where Dk, Bi, and Cj are propositional\nliterals. Yet, the discussion of such rules is outside the scope of this note.\nA consistent set of propositional literals is a set that does not contain both A and its comple-\nment \u00abA for any atom A. A believed literal set X is a consistent set of propositional literals. A"}, {"title": "Informal semantics of extended logic programs by GK\u201914", "content": "Gelfond and Kahl (2014) consider a language of extended logic programs with the addition of\n(i) disjunctive rules and (ii) rules called constraints that have the form\n\\(\\leftarrow B_1,..., B_n, not C_1,..., not C_m,\\)\nwhere Bi, and Cj are propositional literals (empty head can be identified with \u22a5). It is due to note\nthat constraints have been in the prominent use of ASP/ASP-Prolog for some time. In particular,\nthey are the kinds of rules that populate the test group of generate-define-test programs mentioned\nearlier. We come back to this point in the next section. To generalize the concept of an answer set\nto extended programs with constraints it is sufficient to provide a definition of rule satisfaction\nwhen the head of the rule is empty: A believed literal set X satisfies a constraint (6), if there\nexists an \\(i\\in \\{1,...,n\\}\\) such that \\(B_i \\notin X\\) or a \\(j \\in \\{1,...,m\\}\\) such that \\(C_j \\in X\\). As before, we do\nnot present definitions for programs with disjunctive rules."}, {"title": "Informal semantics of GDT theories by D-V'12", "content": "As discussed earlier Lifschitz (2002) coined a term generate-define-test for the commonly used\nmethodology when applying ASP towards solving difficult combinatorial search problems. Un-\nder this methodology, a program typically consists of three parts: the generate, define, and test\ngroups of rules.\nThe role of generate is to generate the search space. In modern dialects of ASP choice rules\nof the form\n\\{\\text{A\\}} \\leftarrow B_1,..., B_n, not C_1,...,not C_m,\nare typically used within this part of the program. Symbols A, B\u2081, and Cj in (7) are propositional\natoms. The define part consists of basic rules (1). This part defines concepts required to state nec-\nessary conditions in the generate and test parts of the program. The test part is usually modeled\nby constraints of the form (6), where Bi, and Cj are propositional atoms.\nDenecker et al. (2012) defined the logic ASP-FO, where they took the generate, define, and test\nparts to be the first-class citizens of the formalism. In particular, the ASP-FO language consists\nof three kinds of expressions G-modules, D-modules, and T-modules. The authors then present\nformal and informal semantics of the formalism that can be used in practicing ASP. Here we\nsimplify the language ASP-FO by focusing on its propositional counterpart. We call this language\nGDT. Focusing on the propositional case of ASP-FO helps us in highlighting the key contribution\nby Denecker et al. (2012) the development of objective informal semantics for logic programs\nused within ASP or generate-define-test approach."}, {"title": "Conclusions and Acknowledgments", "content": "In this note, we reviewed four papers and their accounts on informal semantics of logic programs\nunder answer set semantics. We put these accounts into a uniform perspective by focusing on\nthree components of each of the considered informal semantics, namely, (i) the interpretation of\nanswer sets; (ii) the interpretation of syntactic expressions; and (iii) the interpretation of semantic\nsatisfaction relation. We also discussed the relations of the presented informal semantics to two\nprogramming paradigms that emerged in the field of logic programming after the inception of\nthe concept of a stable model: ASP and ASP-Prolog.\nWe would like to thank Michael Gelfond, Marc Denecker, Jorge Fandinno, Vladimir Lifschitz,\nMiroslaw Truszczynski, Joost Vennekens for fruitful discussions on the topic of this note. Marc\nDenecker brought my attention to the subject of informal semantics and his enthusiasm for the\nquestions pertaining to this subject was contagious.\nThe author was partially supported by NSF 1707371."}]}