{"title": "Historical Review of Variants of Informal Semantics for Logic Programs under Answer Set Semantics: GL'88, GL'91, GK'14, D-V'12", "authors": ["YULIYA LIERLER"], "abstract": "This note presents a historical survey of informal semantics that are associated with logic programming under answer set semantics. We review these in uniform terms and align them with two paradigms: Answer Set Programming and ASP-Prolog- two prominent Knowledge Representation and Reasoning Paradigms in Artificial Intelligence. Under consideration in Theory and Practice of Logic Programming (TPLP).", "sections": [{"title": "1 Introduction", "content": "The transcript of the talk by Donald E. Knuth titled Let's Not Dumb Down the History of Computer Science published by ACM (2021) includes the statement:\nit would really be desirable if there were hundreds of papers on history written by computer scientists about computer science.\nThis quote was inspirational for this technical note devoted to a historical survey of informal semantics that are associated with logic programming under answer set semantics (in the sequel we mostly drop under answer set semantics when referring to logic programming and logic programs).\nWe focus on four seminal publications and align informal semantics discussed there using the same style of presentation and propositional programs. We trust that within such settings key ideas and tangible differences between the distinct views come to the surface best. The earliest publication of the four dates back to 1988, and the latest dates back to 2014. It would seem that the subject of informal semantics is only peripheral scoring at such a low count of major references. Rather, the word informal makes this subject rare in the discussions of logic programming. Nevertheless, the 2014 reference is an introductory chapter titled Informal Semantics of the textbook on Knowledge Representation, Reasoning, and Design of Intelligent Agents by Gelfond and Kahl. The prominent position of this chapter points at the importance of the subject, especially when we consider passing on the knowledge and practice of logic programming to a broad audience.\nAs the presentation unfolds, a story of two views on logic programs will emerge. One view is via the prism of answer set programming (ASP) and another view is via the prism of ASP-Prolog. We reserve the term - ASP to a constraint programming paradigm, where an ASP practitioner while coding specifications of a considered problem ensures that the solutions to this problem correspond to answer sets of the coded program (Brewka et al., 2011). ASP is frequently associated with solving difficult combinatorial search problems via a programming methodology of"}, {"title": "2 Formal and informal semantics of basic programs by GL'88", "content": "We start by recalling the formal and informal semantics of basic logic programs as they were introduced by Gelfond and Lifschitz (1988).\nA basic rule is an expression of the form\n$A\\leftarrow B_1,..., B_n, not C_1,..., not C_m,$\nwhere A, Bi, and Cj are propositional atoms. The atom A is the head of the rule and the expression B1,..., Bn, not C1, ..., not Cm is its body. A basic (logic) program is a finite set of such rules. In the sequel, we introduce rules of somewhat different syntactic structure, yet we agree to call the left-hand side of the rule operator/connective, denoted by $\\leftarrow$, head and the right-hand side body. A rule whose body is empty (n = m = 0) is called a fact; in such rules connective $\\leftarrow$ is often dropped.\nFor a ruler of the form (1) and a set X of atoms, the reduct rx is defined whenever there is no atom Cj for $j \\in {1,...,m}$ such that $C_j \\in X$. If the reduct rx is defined, then it is the rule\n$A\\leftarrow B_1,..., B_n$.\nThe reduct IX of the program I consists of the rules rx for all r\u2208 \u03a0, for which the reduct is defined. A set X of atoms satisfies rule (2) if A belongs to X or there exists $i \\in {1, ..., n}$ such that $B_i \\notin X$. We say that a set X of atoms is a model of a program consisting of rules of the form (2) when X satisfies all rules of this program. A set X is a stable model/answer set of I, denoted Xst I, if it is a subset minimal model of IX.\nQuotes by Gelfond and Lifschitz (1988) on Intuitive Meaning of Basic Programs (verbatim modulo names for programs and sets of atoms):\nQuote 1: The intuitive meaning of stable sets\u00b9 can be described in the same way as the intuition behind \"stable expansions\u201d in autoepistemic logic: they are \"possible sets of beliefs that a rational agent might hold\" (Moore 1985) given I as his premises. If X is the set of (ground) atoms that I consider true, then any rule that has a subgoal not C with C \u2208 X is, from my point of view, useless; furthermore, any subgoal not C with C \u2209 X is, from my point of view, trivial. Then I can simplify the premises \u03a0 and replace them by IX. If X happens to be precisely the set of atoms that logically follow from the simplified set of premises IX, then I am \u201crational\u201d.\nLater, Gelfond and Lifschitz (1991) say about a basic program the following:"}, {"title": "2.1 ASP and ASP-Prolog", "content": "Answer Set Programming Marek and Truszczynski (1999) and Niemel\u00e4 (1999) open a new era for stable model semantics by proposing the use of logic programs under this semantics as constraint programming paradigm for modeling combinatorial search problems. This marks the birth of ASP. Here is what the abstract of the paper by Marek and Truszczynski says:\nWe demonstrate that inherent features of stable model semantics naturally lead to a logic program-ming system that offers an interesting alternative to more traditional logic programming2... The pro-posed approach is based on the interpretation of program clauses as constraints. In this setting programs do not describe a single intended model, but a family of stable models. These stable models encode so-lutions to the constraint satisfaction problem described by the program. ... We argue that the resulting logic programming system is well-attuned to problems in the class NP, has a well-defined domain of applications, and an emerging methodology of programming.\nIn other words, Marek and Truszczynski and Niemel\u00e4 propose to see logic rules of the program as specifications of the constraints of a problem at hand. Logic programming is seen as a provider of a general-purpose modeling language that supports solutions for search problems. Let us make these claims precise by considering the notion of a search problem following the lines by Brewka et al. (2011). A search problem P consists of a set of instances with each instance I assigned a finite set Sp(I) of solutions. In the proposal by Marek and Truszczynski and Niemel\u00e4, to solve a search problem P, one constructs a logic program Ip that captures problem specifications so that when extended with facts F\u2081 representing an instance I of the problem, the answer sets of \u041f\u0440UF\u2081 are in one to one correspondence with members in Sp(I). In other words, answer sets of \u041f\u0440UF\u2081 describe all solutions of problem P for the instance I. Thus, solving a search problem P is reduced to finding a uniform logic program \u2013 that we denoted as Ip \u2013 which encodes problem's specifications/constraints.\nThe logic rules of the program the key syntactic building blocks of logic pro-gramming become the vehicles for stating constraints/specifications of a problem un-der consideration. A program is typically evaluated by means of a grounder-solver pair. A"}, {"title": "2.2 \u201cFormalizing\u201d Quotes 1 and 2 or Informal Semantics of Basic Programs by GL\u201988", "content": "Before we attempt to make the claims of Quote 1 by Gelfond and Lifschitz (1988) precise it is due to discuss three interrelated and yet different concepts and how we understand them within this note:\n\u2022 a state of affairs,\n\u2022 a belief state, and\n\u2022 a set of beliefs/belief set.\nThe following example is our key vehicle in this discussion."}, {"title": "3 Formal and informal semantics of extended programs by GL\u201991", "content": "Here, we recall the formal and informal semantics of extended logic programs by Gelfond and Lifschitz (1991). An alternative view of the informal semantics for extended logic programs is provided in (Gelfond and Kahl 2014, Section 2.2.1) reviewed next.\nA literal is either an atom A or an expression \u00acA, where A is an atom. An extended rule is an expression of the form (1), where A, Bi, and Cj are propositional literals. An extended program is a finite set of extended rules. Gelfond and Lifschitz (1991) also considered disjunctive rules of the form D\u2081 or ... or D\u2081 \u2190 B1, ..., Bn, not C1, ..., not Cm, where Dk, Bi, and Cj are propositional literals. Yet, the discussion of such rules is outside the scope of this note.\nA consistent set of propositional literals is a set that does not contain both A and its complement \u00acA for any atom A. A believed literal set X is a consistent set of propositional literals. A"}, {"title": "4 Informal semantics of extended logic programs by GK\u201914", "content": "Gelfond and Kahl (2014) consider a language of extended logic programs with the addition of (i) disjunctive rules and (ii) rules called constraints that have the form\n$\\leftarrow B_1,..., B_n, not C_1,..., not C_m,$\nwhere Bi, and Cj are propositional literals (empty head can be identified with \u22a5). It is due to note that constraints have been in the prominent use of ASP/ASP-Prolog for some time. In particular, they are the kinds of rules that populate the test group of generate-define-test programs mentioned earlier. We come back to this point in the next section. To generalize the concept of an answer set to extended programs with constraints it is sufficient to provide a definition of rule satisfaction when the head of the rule is empty: A believed literal set X satisfies a constraint (6), if there exists an $i\\in {1,...,n}$ such that $B_i \\notin X$ or a $j \\in {1,...,m}$ such that $C_j \\in X$. As before, we do not present definitions for programs with disjunctive rules."}, {"title": "5 Informal semantics of GDT theories by D-V'12", "content": "As discussed earlier Lifschitz (2002) coined a term generate-define-test for the commonly used methodology when applying ASP towards solving difficult combinatorial search problems. Under this methodology, a program typically consists of three parts: the generate, define, and test groups of rules.\nThe role of generate is to generate the search space. In modern dialects of ASP choice rules of the form\n${A} \\leftarrow B_1,..., B_n, not C_1,...,not C_m,$\nare typically used within this part of the program. Symbols A, B\u2081, and Cj in (7) are propositional atoms. The define part consists of basic rules (1). This part defines concepts required to state necessary conditions in the generate and test parts of the program. The test part is usually modeled by constraints of the form (6), where Bi, and Cj are propositional atoms.\nDenecker et al. (2012) defined the logic ASP-FO, where they took the generate, define, and test parts to be the first-class citizens of the formalism. In particular, the ASP-FO language consists of three kinds of expressions G-modules, D-modules, and T-modules. The authors then present formal and informal semantics of the formalism that can be used in practicing ASP. Here we simplify the language ASP-FO by focusing on its propositional counterpart. We call this language GDT. Focusing on the propositional case of ASP-FO helps us in highlighting the key contribution by Denecker et al. (2012) the development of objective informal semantics for logic programs used within ASP or generate-define-test approach.\nA G-module is a set of choice rules with the same atom in the head; this atom is called open. A D-module is a basic logic program whose atoms appearing in the heads of the rules are called defined or output. A T-module is a constraint. A GDT theory is a set of G-modules, D-modules, and T-modules so that no G-modules or D-modules coincide on open or defined atoms. To define the semantics for GDT theory we introduce several auxiliary concepts including that of an input answer set (Lierler and Truszczy\u0144ski, 2011) and G-completion. For a basic program I, we call a set X of atoms an input answer set of I if X is an answer set of a program \u03a0\u222a (X \\Heads(\u03a0)), where Heads(I) denotes the set of atoms that occur in the heads of the rules in \u03a0.\nRules occurring in modules of GDT theory are such that their bodies have the form\n$B_1,..., B_n, not C_1, ..., not C_m.$\nGiven Body of the form (8) by Bodycl we denoted a classical formula of the form\n$B_1 \\land...\\land B_n \\land \\lnot C_1 \\land...\\land \\lnot C_m.$\nFor a G-module G of the form\n${{A} \\leftarrow Body_1,..., {A} \\leftarrow Body_n}$\nby G-completion, Gcomp(G) we denote the classical formula\n$A \\rightarrow Body_1 \\lor... \\lor Body_n$.\nFor a GDT theory P composed of G-modules G1, . . ., Gi, D-modules D1, ..., Dj, T-modules\n$\\leftarrow Body_1,...,\\leftarrow Body_k,$\nwe say that set X of atoms is an answer set of I, denoted $X |=_{st} \\Pi$, if\n\u2022 X satisfies formulas Gcomp(G1), . . ., Gcomp(Gi) (we associate a set X of atoms with an interpretation of classical logic that maps propositional atoms in X to truth value true and propositional atoms outside of X to truth value false; we then understand the concept of satisfaction in usual terms of classical logic.);\n\u2022 X is an input answer set of D-modules D\u2081 . . . Dj; and\n\u2022 X satisfies formulas Body \u2192 1, . . ., Body \u2192 1.\nWe refer the reader to Denecker et al. (2019) to the discussion of Splitting Theorem results that often allows us to identify ASP logic programs with GDT theories.\nWe now provide the informal semantics for GDT theory I by Denecker et al. (2012; 2019). We denote it by DV\u2081 and detail its three components DV, DV and DVF. To begin with DV coincides with G. We summarize DV by (i) the entries in rows 1-3 of Table 2, where we replace G+ by DV, and (ii) the entries in Table 8. Table 9 presents DV. Note how an entry in the right column of Table 9 gives us clues on how to simplify the parallel entry in the right column of Table 3. We can rewrite it as follows: For basic program I, property G(I) holds in the state G(X) of affairs.\nProvided account of informal semantics of GDT theories echos the interpretation of an answer set of a basic program as a possible \u201cinterpretation\" and can be seen as an informal semantics for the syntactic constructs that are fundamental in ASP practice nowadays.\""}, {"title": "6 Conclusions and Acknowledgments", "content": "In this note, we reviewed four papers and their accounts on informal semantics of logic programs under answer set semantics. We put these accounts into a uniform perspective by focusing on three components of each of the considered informal semantics, namely, (i) the interpretation of answer sets; (ii) the interpretation of syntactic expressions; and (iii) the interpretation of semantic satisfaction relation. We also discussed the relations of the presented informal semantics to two programming paradigms that emerged in the field of logic programming after the inception of the concept of a stable model: ASP and ASP-Prolog.\nWe would like to thank Michael Gelfond, Marc Denecker, Jorge Fandinno, Vladimir Lifschitz, Miroslaw Truszczynski, Joost Vennekens for fruitful discussions on the topic of this note. Marc Denecker brought my attention to the subject of informal semantics and his enthusiasm for the questions pertaining to this subject was contagious.\nThe author was partially supported by NSF 1707371."}]}