{"title": "Handling irresolvable conflicts in the Semantic Web:\nan RDF-based conflict-tolerant version of\nthe Deontic Traditional Scheme", "authors": ["Livio Robaldo", "Gianluca Pozzato"], "abstract": "This paper presents a new ontology that implements the well-known Deontic Tra-\nditional Scheme in RDFs and SPARQL, fit to handle irresolvable conflicts, i.e.,\nsituations in which two or more statements prescribe conflicting obligations, prohi-\nbitions, or permissions, with none of them being \"stronger\" than the other one(s).\nIn our view, this paper marks a significant advancement in standard theoretical\nresearch in formal Deontic Logic. Most contemporary approaches in this field are\nconfined to the propositional level, mainly focus on the notion of obligation, and\nlack implementations. The proposed framework is encoded in RDF, which is not\nonly a first-order language but also the most widely used knowledge representation\nlanguage, as it forms the foundation of the Semantic Web. Moreover, the proposed\ncomputational ontology formalizes all deontic modalities defined in the Deontic Tra-\nditional Scheme, without specifically focusing on obligations, and offers constructs\nto model and reason with various types of irresolvable conflicts, violations, and the\ninteraction between deontic modalities and contextual constraints in a given state\nof affairs. To the best of our knowledge, no existing approach in the literature\naddresses all these aspects within a unified integrated framework.", "sections": [{"title": "Introduction: contradictions vs conflicts", "content": "Normative reasoning aims at formalizing norms from existing legislation in formal logic,\nfit to enable automated compliance checking and other legal reasoning tasks. In this\npaper, we are specifically interested in automated compliance checking on data encoded\nin Resource Description Framework (RDF), the standard format for data interchange and\nlinking on the World Wide Web.\nRecent literature, e.g., (Robaldo et al., 2023a), has highlighted the need of devising\nautomated solutions for compliance checking fully interoperable with the RDF standard,\ngiven the increasing availability of Big Data in this format and, consequently, the need to\ncheck their compliance with respect to the in-force regulations. Nevertheless, the work in\n(Robaldo et al., 2023a), which reviews and compares main currently available automated\nlegal reasoners, showed that only few of these reasoners are able to directly process RDF\ndata; for the others, it is first necessary to translate the RDF triples into their input\nformats, a solution that is not practical when dealing with Big Data because it would\nincrease the overall computational time beyond an acceptable level.\nIn addition, (Robaldo et al., 2023a) highlighted the need of defining a common concep-\ntualization of the norms to be shared among the legal reasoners, in order to enable com-\nparisons thus researching optimal solutions. This paper aims at filling this gap, namely\nat developing a computational ontology compatible with Semantic Web technologies.\nTo define such an ontology, we reviewed past literature in deontic logic, the research\narea that investigates how to represent deontic statements such as obligations, prohibi-\ntions, permissions, etc. and related concepts in formal logic. Deontic logic has been used\nsince the 1950s as the main formal tool for modelling normative reasoning (Gabbay et\nal., 2013). From the literature review, which will be summarized, although not exhaus-\ntively, below in section 4, we decided to ground the design of the proposed computational\nontology on the distinction between contradictions and conflicts.\nLet us exemplify this distinction by consider the following two obligations:\n(1) a. It is obligatory to leave the building.\nb. It is obligatory to not leave the building.\n(1.a) could hold, for instance, in a state of affairs where there is some danger inside the\nbuilding, e.g., a fire, while (1.b) could hold in a state of affairs where there is some danger\noutside the building, e.g., a sand storm.\nThe interesting question is of course what to do when there is both a fire in the building\nand a sand storm outside. In such a context, we must necessarily decide which one of the\ntwo dangers we want to take the risk with and we must violate the obligation associated\nwith that danger.\nIn light of this, this paper assumes that all deontic logics that represent the conjunc-\ntion of (1.a) and (1.b) as contradictory, first of all Standard Deontic Logic (von Wright,\n1951), are inadequate for modelling normative reasoning.\nContradictions should be associated with statements that are illogical in the state of\naffairs in which they are uttered and, as such, always false. For instance, the statement\n\"Yoof is a dog and Yoof is a cat\" is contradictory in states of affairs where the set of dogs\nand the set of cats are disjoint. This would be illogical.\nOn the contrary, the conjunction of (1.a) and (1.b) does not seem to be illogical,\nnot even when there is both a fire in the building and a sand storm outside. In such a\ncontext, we will simply have to violate one of the two obligations; however, as it is well-\nknown, violations are not contradictions and so there is no apparent reason to stipulate\nthat, on the contrary, a situation in which it is necessary to violate some obligations is\ncontradictory, i.e., illogical.\nTherefore, the framework proposed in this paper will not model (1.a) and (1.b) as\ncontradictory, but rather as conflicting of one another, in which a conflict is defined as"}, {"title": null, "content": "a situation in which two deontic statements hold in the context but complying with one\nof them entails violating the other one. This notion of conflict, originally investigated\nby Hans Kelsen (Kelsen, 1991), also encompasses cases where one of the two deontic\nstatements is a permission, although (Vranes, 2006) suggests that in such cases the conflict\nis \"unilateral\", i.e., it exists in only one direction. A simple example is:\n(2) a. It is prohibited to leave the building. [logically equivalent to (1.b)]\nb. It is permitted to leave the building.\nIf both (2.a-b) hold and we do not leave the building in order to comply with (2.a),\nwe cannot say that we are actually \"violating\" (2.b): the latter does not state that we\nmust leave the building, i.e., that this is an obligation. On the contrary, if we leave the\nbuilding, in virtue of what (2.b) authorizes us to do, we do violate (2.a).\nA final category of conflicts discussed by Kelsen is exemplified in (3).\n(3) a. It is obligatory to pay in cash.\nb. It is obligatory to pay by card.\nKelsen classifies conflicts like the one between (3.a) and (3.b) as \u201cpartial conflicts\" because\nwhat is in conflict here is only a part of the same obligatory action: (3.a-b) prescribe\ntwo different instruments for paying and the conflict stems from the fact that these\ninstruments are mutually exclusive: payments made in cash are not made by card and\npayment made by card are not made in cash.\nIn this paper, however, we are not interested in subcategorizing conflicts; therefore,\nall conflicts exemplified in (1), (2), and (3) are here considered as conflicts of the same\ntype.\nIn deontic logic literature, conflicts as such are also known as \"irresolvable conflicts\",\nin which \"irresolvable\" means that none of the two deontic statements is stronger than,\ni.e., can override, the other one, in which case the latter is not actually violated. Several\nconflict-tolerant deontic logics have been proposed to formalize conflicts, although they\nmostly focus on conflicts between obligations, i.e., they do not consider conflicts such as\nthe one exemplified in (2), in which one of the two deontic statements is a permission.\nLou Goble is perhaps the author who mostly investigated the formalization of conflicts\nin deontic logic; his seminal work in (Goble, 2013b) is still considered nowadays as a\nreference survey\u00b9 on the topic.\nAll conflict-tolerant deontic logics reviewed in (Goble, 2013b) represent conflicts as\nconsistent formulae; in that sense these logics are said to be \"conflict-tolerant\". However,\nas it will be clarified below, in almost all approaches reviewed in (Goble, 2013b) conflicts\ncannot be distinguished from other consistent formulae. In our view, this is not desirable\neither because, although conflicts are not contradictions, they still need to be notified as\nthey must be removed."}, {"title": null, "content": "It is not so infrequent for existing legislation to include conflicts among norms. These\nconflicts are rather difficult to be manually identified by humans, e.g., the legislators in\ncharge of updating the law. Artificial Intelligence could be then of great help here, as it\nmay lead to the creation of LegalTech applications able to detect them, for the legislators\nto update the law fit to remove them.\nSimilar considerations might be found in a recent interview to Leon van der Torre and\nDov Gabbay published in (Steen and Benzmuller, 2024), in which the explicit represen-\ntation of fallacies, violations, mistakes, etc., (henceforth referred under the general term\n\"abnormalities\") fit to reason about them, has been identified as a crucial gap of contem-\nporary logical frameworks for AI. Indeed, even in the LegalTech application envisioned\nabove, if conflicts would be explicitly represented, the application could not only notify\nthem to the legislator, but also reason about them fit to suggest alternative solutions for\nsolving them, while assessing pros and cons of each solution, etc., for the legislator to\nbetter ponderate the decision on how to revise the law.\nFurthermore, in our view conflicts are not the only type of \"abnormality\" that ought\nto be notified. The state of affairs may include physical constraints that either prevent\ncompliance with obligations and prohibitions or that prevent to execute what is permit-\nted. Situations as these must be notified as well because, of course, agents cannot be\nsanctioned if it was impossible for them to comply with their obligations.\nContextual constraints might be also used by agents in order to infer how they can\ncomply with their obligations. For instance, consider the obligation in (4.a) and the\nconstraint in (4.b).\n(4) a. Whoever parks in a parking spot is obliged to pay \u00a33 at the parking meter\nassociated with that spot.\nb. The parking meter in Sketty only accepts cash.\n(4.b) states that, in Sketty, it is necessary to pay by cash. Therefore, if John is parking\nin Sketty, not only he will infer that he is obliged to pay \u00a33; more specifically, he will\ninfer that he is obliged to pay the \u00a33 in cash.\nFinally, contextual constraints might also interact with conflicts. For instance, sup-\npose that, in the future, the government will decide to abolish cash as a way to contrast\ncorruption. In the new context, only payments by digital means, e.g., credit card, are\nallowed. The following prohibition is then added to the normative system:\n(5) It is prohibited to pay by cash.\nNow, it became impossible for John to comply with both (4.a) and (5) when he parks in\nSketty: the physical constraint in (4.b) prevents to comply with the prohibition in (5),\nso either John will violate this prohibition or he will violate his obligation to pay \u00a33; in\neither case, John's violation is justified and so he should not be sanctioned for that.\nThe interplay between norms and contextual knowledge holding in the state of affairs\nhas been scarcely considered in past conflict-tolerant deontic logics, at least at the level\nof granularity exemplified in (4) and (5). Most deontic logics proposed in past literature\nuse propositional symbols as atomic formulae while, in order to model examples (4) and"}, {"title": null, "content": "(5) above, we need a first-order framework capable of distinguishing the actions, e.g.,\npaying, from their thematic roles, e.g., the instrument of paying (cash rather than card).\nThis paper presents a novel computational ontology to represent and reason with\nconflicts between deontic statements in all cases exemplified so far, most of which are\nnot currently covered by state-of-the-art conflict-tolerant deontic logics. The proposed\ncomputational ontology aims at being the first step to define, in the future, LegalTech\napplications able to notify and reason with conflicts between norms from legislation.\nRDF and the other W3C standards provide the required level of granularity. Most\nimportant of all, they provide interoperability with Big Data in RDF format publicly\navailable in the World Wide Web, which are expected to grow in number in the forth-\ncoming years.\nIn light of this, we envision a future in which, whenever new norms will enter into\nforce, LegalTech applications such as the one advocated above will be able to automati-\ncally download publicly available data and to identify which norms either conflict of one\nanother or they cannot be complied with and why. For instance, with respect to the\nexample in (4) and (5), we might assume that, in the future, the websites of the mu-\nnicipalities will publish online, in RDF format, information about the city services and\ninfrastructures, including information about the parking meters located in the city. With\nthese data at disposal, applications will be able to automatically infer and notify that it\nis impossible to comply with (5) in the specific case of the parking meter in Sketty.\nIn light of all considerations above, the research questions of this paper are summa-\nrized as follows:\n(6) a. How is it possible to explicitly represent conflicts between norms, while distin-\nguishing them from contradictions, with an eye on future LegalTech applica-\ntions that might notify them to the legislators?\nb. What else should be also explicitly represented, in light of what is impossible\nor necessary in the context?\nc. How is it possible to implement an automated reasoner to represent and reason\nwith (a) and (b) by using W3C standards only, in order to enhance interoper-\nability with publicly available RDF datasets?\nThe next section will review recent literature on compliance checking on RDF data; the\naim of the next section is to explain which W3C standards we have specifically chosen to\ndevelop the proposed computational ontology.\nSection 3 will then illustrate the second main building block from the literature that\nwe imported in our solution. This is the framework for Natural Language Semantics\ndescribed in (Gordon and Hobbs, 2017), which in turn summarizes the lifetime research\nwork of Jerry R. Hobbs, developed throughout many of his previous papers, e.g., (Hobbs,\n1986), (Hobbs et al., 1993), (Hobbs, 1985), and (Hobbs, 2008). We have chosen Hobbs's\nframework because, in order to formalize natural language statements, e.g., those from\nexisting legislation, we need a framework explicitly designed for Natural Language Se-\nmantics. Hobbs's is formally simple yet very expressive, as well as grounded on theories\nof commonsense psychology that we consider valid. In addition, Hobbs's formulae can"}, {"title": null, "content": "be straightforwardly implemented in RDF and the other Semantic Web technologies, as\nit will shown below, making it particularly suitable for the objectives of this paper.\nIt must be also pointed out that the first author of this paper has already used\nHobbs's framework to define a particular deontic logic tailored for Natural Language\nSemantics called \"reified Input/Output logic\" (Robaldo and Sun, 2017)(Robaldo et al.,\n2020). In reified Input/Output logic, Hobbs's framework is plugged into Input/Output\nlogic (Makinson and van der Torre, 2000), a well-known deontic logic more computation-\nally efficient than other deontic logics grounded on possible-world semantics (Sun and\nRobaldo, 2017). Nevertheless, reified Input/Output logic is not suitable to address the\nresearch questions in (6) because also its axiomatization represents conflicts as contra-\ndictions\u00b3. Thus, the proposed solution will keep Hobbs's framework but it will define a\nnew axiomatization to properly address the research questions in (6.a-b).\nIn order to understand how the new axiomatization is capable to achieve (6.a-b),\nsection 4 will review past literature on conflict-tolerant deontic logics, while highlighting\ninsights and limitations of the main approaches.\nSection 5 will then present the core research of this paper: how to integrate the\ncontributions from the three research strands illustrated in sections 2, 3, and 4 into a\nsingle unified RDF-based framework to model and reason with deontic modalities while\nachieving the research questions in (6.a-c). After that, sections 6 and 7 will compare the\nproposed computational ontology with state-of-the-art conflict-tolerant deontic logics,\nalong two different and orthogonal perspectives. Finally, section 8 will address some\nfuture works and section 9 will conclude the paper."}, {"title": "Background: compliance checking on RDF data", "content": "As it is well-known, RDF is a graph-based data model that only represents knowledge,\nwhile it does not provide inference mechanisms to compute what logically follows from\nwhat is explicitly asserted. These mechanisms are instead needed for compliance checking,\nin order to infer whether a given state of affairs is compliant or not with respect to a\ngiven set of norms. In light of this, approaches from the past literature in modelling\ncompliance checking with RDF data use a separate executable format, compatible with\nRDF, to encode the norms as inference rules; then, an automated reasoner able to process\nthis format executes the inference rules.\nSome of the first approaches belonging to this literature are (Gordon, 2008) and (Ceci,\n2013); these respectively formalize norms in Semantic Web Rule Language4 (SWRL) and\nLegal Knowledge Interchange Format (LKIF) rules5. SWRL is a proposed language for"}, {"title": "The lightweight automated reasoner used in this paper", "content": "The inference rules defined below in the paper are implemented as SPARQL rules, specifi-\ncally as SPARQL rules in the form CONSTRUCT-WHERE, similarly to what is done in (Anim,\nRobaldo, and Wyner, 2024). As explained above, such rules are not expressive enough for\nnormative reasoning in general because, for instance, they do not have priorities or other\nconstructs to implement defeasibility. However, since this paper is not concerned with\ndefeasibility, we opted for a simpler implementation to help the reader remain focused\non the objectives of this paper.\nThe SPARQL rules are also part of the proposed computational ontology. In par-\nticular, the ontology includes a special class called InferenceRule whose individuals\nrefer to the SPARQL rules. A special RDF property has-sparql-code associate these\nindividuals with the strings encoding the rules in standard SPARQL v1.1.\nIn all examples shown below or included in the GitHub repository the inference rules"}, {"title": null, "content": "are anonymous RDF individuals, so they adhere to the following template9:\n(7) [a: InferenceRule;\n:has-sparql-code \"\"\"CONSTRUCT{...}WHERE{...}\"\"\"]\nThe empty prefix \":\" is associated with the following namespace:\nhttps://w3id.org/ontology/conflict-tolerantdeontictraditionalscheme#\nThis is the namespace of the RDF resources included in the proposed computational\nontology. We will use another prefix \"soa:\", for the RDF resources that are part of the\nstates of affairs, i.e., the ABoxes, encoding the examples:\nhttps://w3id.org/ontology/conflict-tolerantdeontictraditionalscheme#soa\nThe automated reasoner processing the SPARQL rules, freely downloadable from the\nGitHub repository associated with this paper together with all examples shown below and\nclear instructions to re-execute them, has been implemented in Java by using the Apache\nJena library10 (v4.10), which is perhaps the most popular open source Java framework\nfor building Semantic Web and Linked Data applications. As already mentioned earlier,\nthe reasoner iteratively re-apply the rules to the inferred knowledge graph until no new\nRDF triples are inferred.\nNote that this is exactly what is also done in standard OWL reasoners, e.g., HermiT\n(Glimm et al., 2014), which re-execute the OWL axioms until no further new RDF\ntriple is inferred. Nevertheless, while the set of triples that might be iteratively inferred\nthrough OWL axioms are finite in number, and so the OWL reasoner will necessarily\nterminate after a finite number of iterations, the iterative re-execution of SPARQL rules\nmay loop infinitely. The reason is that OWL axioms cannot extend the set of RDF\nresources; therefore, if R is the set of RDF resources and PCR the set of RDF properties,\nthe cardinality of the maximal set of triples that can be created is \u2500R\u2500\u00d7\u2500P\u2500\u00d7\u2500R\u2500.\nConversely, SPARQL rules in the form CONSTRUCT-WHERE can also add new (anonymous)\nindividuals to the knowledge graph, thus extending its set of resources. This might easily\nlead to infinite loops. For instance, by iteratively re-executing the following rule, each\nman in the knowledge graph will be associated with an infinite number of wives, each\ncorresponding to a new anonymous individual added by the rule to the knowledge graph\nin each iteration:\n(8) [a: InferenceRule;\n:has-sparql-code \"\"\"CONSTRUCT{[soa:wife-of ?x]}\nWHERE{?x a soa:Man}\"\"\"]\nTo avoid infinite loops, all SPARQL rules shown below and that create new anonymous\nindividuals will include special clauses in the form NOT EXISTS{...} that block these\nloops. Specifically, the SPARQL rules shown below will create new anonymous indi-\nviduals only if the knowledge graph does not already contain individuals with the same\ncharacteristics. For instance, the SPARQL rule in (9) is revised as follows:"}, {"title": null, "content": "(9) [a: InferenceRule;\n:has-sparql-code \"\"\"CONSTRUCT{[soa:wife-of ?x]}\nWHERE{?x a soa:Man. NOT EXISTS{?w soa:wife-of ?x}}\"\"\"]\nThe revised rule creates a new wife and associate her with a man only if the man does\nnot already have a wife.\nAlthough this solution is acceptable for all cases considered in this paper, it is not\napplicable in the general case in that it introduces restrictions that do not necessarily\nhold in all contexts; for instance, (9) is not applicable in contexts in which men are\nallowed to have more than one wife, for which more complex WHERE clauses ought to be\nasserted. Nevertheless, the development of a proper reasoner for SPARQL rules is beyond\nthe scope of this paper."}, {"title": "Background: encoding natural language statements\nin (Gordon and Hobbs, 2017)", "content": "This section presents the framework illustrated in (Gordon and Hobbs, 2017) as well as\nin previous publications by Jerry R. Hobbs; this framework sets the groundwork for the\ncomputational ontology proposed in this paper.\n(Gordon and Hobbs, 2017) presents a first-order logical framework for Natural Lan-\nguage Semantics massively grounded on the notion of reification. In philosophical terms,\nreification is the action of conceptualizing abstract entities as things of the world. In\nformal logic, this amounts at formalizing them as first-order individuals, i.e., constants\nor variables of the logic. The notion of reification was originally introduced by Donald\nDavidson in (Davidson, 1967); however, Donald Davidson was using reification with a\nlimited set of abstract entities. Conversely, as stated above, (Gordon and Hobbs, 2017)\nis massively grounded on the notion of reification, meaning that any abstract entity can\nbe reified into a first-order individual; then, new assertions can be made on these indi-\nviduals and the fact that one of these assertions hold for one of these individuals can be\nrecursively reified again into a new first-order individual.\nAccording to (Gordon and Hobbs, 2017) and its philosophical and psycholinguistic\nfoundations, reification parallels how people think about events, actions, and states in\nthe world; for this reason, (Gordon and Hobbs, 2017) is particularly suitable to handle\nthe semantics of natural language statements and it has been chosen as the underlying\nlogic of the proposed computational ontology.\nLet's see how reification works on a simple example: the assertion \"John leaves\". This\nassertion is usually represented in standard first-order logic as leave(John), where leave\nis a first-order predicate and John is a first-order individual. Conversely, in (Gordon and\nHobbs, 2017) this first-order assertion is associated with another first-order individual\nelj, which is called an \u201ceventuality\". In (Gordon and Hobbs, 2017)'s terminology, it is\nsaid that the assertion is \"reified into\" the eventuality elj; in this paper we will also use\nthe phrase \"the fact that\" to talk about the relation between the eventualities and the\ncorresponding assertions; therefore, elj denotes the fact that John leaves. Being first-\norder individuals, eventualities can be inserted as argument of first-order predicates; in\nparticular, eventualities that reify actions or states such as \"to leave\" might be inserted"}, {"title": null, "content": "as argument of predicates that denote particular modalities holding for the action or\nstate. In light of this, (Gordon and Hobbs, 2017) converts leave(John) into the following\nformalization:\n$Rexist(elj) \\land leave'(elj, John)$\nIn which the predicate leave has been converted in the primed predicate leave', which\nincludes an additional argument: the reification of the action. This reification is then\ninserted as argument of another predicate Rexist, which represents the modality of John's\nleaving. In particular, Rexist(elj) states that elj really exists in the state of affairs. The\nuse of the predicate Rexist marks a neat difference between the way in which meaning\nis usually represented in standard first-order logic, e.g., leave(John), and the way in\nwhich this is done in (Gordon and Hobbs, 2017)'s framework. According to (Gordon and\nHobbs, 2017), actions cannot be true or false; they can instead take place in the real\nworld or not.\nHowever, Rexist is not the single available modality. As (Gordon and Hobbs, 2017)\nexplains, an eventuality could be part of someone's beliefs but not occur in the real\nworld, it could exist in some fictional universe, it could be merely possible or likely\nbut not real, etc. Each of these alternative modalities must be represented by a unary\npredicate different from Rexist. This paper will introduce predicates that implement\ndeontic modalities, in section 5 below.\nFurthermore, in this paper, in order to facilitate the encoding of (Gordon and Hobbs,\n2017)'s formulae in RDFs, rather than defining primed predicate associated with their\nnon-primed versions, we will adhere to the specific pattern proposed in (Robaldo et al.,\n2023a) and shown in (10). In (10), e denotes an eventuality, M denotes a modality, AoS\ndenotes an action or state while t denote thematic roles; the latter are represented as\nbinary predicates having the eventuality e as first argument and the value of the thematic\nrole v as second one.\n(10) $M(e) \\land Aos (e) \\land \\bigwedge_{i=1}^{n} ti (e, vi)$\nIn this pattern, \"John leaves\" is represented as in (11.a). Another example is shown in\n(11.b), which represents the assertion \"John pays \u00a33 in cash\".\n(11) a. $Rexist(elj) \\land Leave(elj) \\land has\\text{-}agent(elj, John)$\nb. $Rexist(epj) \\land Pay(epj) \\land has\\text{-}agent(epj, John) \\land$\n$has\\text{-}object(epj, \u00a33) \\land has\\text{-}instrument(epj, cash)$\nIn (11.a), Leave is a predicate different from the previous predicate leave, in that it\napplies to an eventuality rather than to a person. Therefore, while leave(John) states\nthat John belongs to the set of leavers, Leave(elj) states that elj belongs to the set of\nleaving actions. On the other hand, Leave(elj) does not state whether elj also really\nexists in the state of affairs or only in someone's imagination, etc. To state that elj\nreally exists in the state of affairs, Rexist(elj) must be asserted, so that elj will also\nbelong to the set of really existing eventualities."}, {"title": null, "content": "The framework in (Gordon and Hobbs, 2017) covers a fairly large theory of common-\nsense psychology while formalizing sets, abstract and instantiated eventualities, causal\nand temporal reasoning, composite entities, defeasibility, etc. via reification. The objec-\ntives of this paper do not need all these notions; therefore, this paper will import only\nthe predicates and axioms from (Gordon and Hobbs, 2017) strictly needed to address the\nresearch questions in (6) above. Section 8, devoted to future works, will discuss some\nextensions that we plan to incorporate within the proposed computational ontology in\nthe future."}, {"title": "Negation, conjunction, and disjunction of eventualities", "content": "(Gordon and Hobbs, 2017) defines the three predicates not, and, and or to relate pairs\nor triples of eventualities. As it will explained below, although these predicates have the\nsame name of the three well-known standard boolean connectives, they do not have the\nsame meaning. The predicates not, and, and or are intuitively defined as follows:\n(12) a. \"not (en, e)\" states that en and e are opposite eventualities; e.g., if e refers\nto the fact that \"John leaves\", en may refer to the fact that \"John does not\nleave\".\nb. \"and (ea, e1, e2)\" states that ea is the co-occurrence of e1 and e2; e.g., if e1\nand e2 respectively refer to the facts that \"John eats\" and \"John drinks\", ea\nmay refer to the fact that \"John eats and drinks\".\nc. \"or(eo, el, e2)\" states that eo is the disjunctive occurrence of e1 and e2;\ne.g., if e1 and e2 respectively refer to the facts that \"John eats\" and \"John\ndrinks\", eo may refer to the fact that \"John eats or drinks\".\nThe modalities holding on en, ea, and eo may be related with the modalities holding\non e, e1, and e2. For instance, with respect to the Rexist modality, the bi-implications\nin (13) are stipulated as valid. Note that the bi-implications in (13) make use of the\nstandard boolean connectives\u00ac, ^, and V.\n(13) a. $\u2200e, en [not(e, en) \u2192 (Rexist(e) \u2194 \u00acRexist(en))]$\nb. $\u2200ea, e1, e2[and(ea, e1, e2) \u2192 (Rexist(ea) \u2194 (Rexist(e1) \u2227 Rexist(e2))) ]$\nc. $\u2200eo, e1, e2 or (eo, e1, e2) \u2192 (Rexist(eo) \u2194 (Rexist(e1) \u2228 Rexist(e2))) ]$\nTherefore, if the fact that John leaves really exists, then the fact that John does not\nleave does not really exist (and vice versa), if the fact that John eats and drinks really\nexists, then also the fact that John eats and the fact that John drinks really exist (and\nvice versa), and if the fact that John eats or drinks really exists, then also the fact that\nJohn eats or the fact that John drinks really exist (and vice versa).\nHowever, the bi-implications in (13) only concern the Rexist modality whereas cor-\nresponding bi-implications for other modalities could not be as valid as those in (13). For\ninstance, the fact that John is obliged to leave is not equivalent to the fact is not obliged\nto stay (i.e., to not leave): the meaning of the former is that John must leave otherwise"}, {"title": "Abstract and instantiated eventualities", "content": "The second main ingredient that this paper imports from (Gordon and Hobbs, 2017) is\nthe distinction between abstract eventualities and their instantiations. This distinction\nis needed in particular to represent partial conflicts such as the one exemplified in above\nin (3). Let us introduce the notion of abstract eventuality via the following example,\nmuch simpler than (3):\n(15) a. John pays in cash.\nb. John pays by card.\nThe two sentences in (15) contradict of one another only if it is assumed that they refer to\nthe same payment. Same considerations hold for the conflict in (3): the two obligations\nare in conflict only under the assumption that they refer to the same payments. Under\nthis assumption, the contradiction in (15) and the conflict in (3) stem from the fact that\ncash and card are two mutually exclusive instruments for paying11.\nNevertheless, the two sentences in (15.a-b) do not explicitly states anywhere that\nthey refer to the same payment: what John is paying is unknown in (15.a) and (15.b)."}, {"title": "Encoding (Gordon and Hobbs, 2017) in RDFs and SPARQL", "content": "So far, this section illustrated the portion of (Gordon and Hobbs, 2017)'s framework\nneeded for our formalization. This subsection explains how this portion is encoded in\nRDFs and SPARQL rules within the proposed computational ontology. The SPARQL\nrules shown below are executable through the lightweight reasoner described above in\nsubsection 2.1.\nAll predicates seen in the previous subsection can be directly encoded in RDFs. For in-\nstance, formula (11) is directly implementable in RDFs by mapping the predicates Leave\nand Rexist into homonym RDFs classes, has-agent into an homonym RDF property,\nand elj and John into homonym RDF individuals. Furthermore, in order to state that\nall leaving actions are eventualities, Rexist is a modality, and has-agent is a thematic"}]}