{"title": "Enumerating Minimal Unsatisfiable Cores of LTL \u0192 formulas", "authors": ["Antonio Ielo", "Giuseppe Mazzotta", "Rafael Pe\u00f1aloza", "Francesco Ricca"], "abstract": "Linear Temporal Logic over finite traces (LTLf) is a widely used formalism with applications in AI, process mining, model checking, and more. The primary reasoning task for LTLf is satisfiability checking; yet, the recent focus on explainable AI has increased interest in analyzing inconsistent formulas, making the enumeration of minimal explanations for infeasibility a relevant task also for LTLf. This paper introduces a novel technique for enumerating minimal unsatisfiable cores (MUCs) of an LTLf specification. The main idea is to encode a LTLf formula into an Answer Set Programming (ASP) specification, such that the minimal unsatisfiable subsets (MUSes) of the ASP program directly correspond to the MUCs of the original LTLf specification. Leveraging recent advancements in ASP solving yields a MUC enumerator achieving good performance in experiments conducted on established benchmarks from the literature.", "sections": [{"title": "Introduction", "content": "Linear temporal logic over finite traces (LTLf) (De Giacomo and Vardi 2013) is a simple, yet powerful language for expressing and reasoning about temporal specifications, that is known to be particularly well-suited for applications in Artificial Intelligence (AI) (Bacchus and Kabanza 1998; Calvanese, De Giacomo, and Vardi 2002; De Giacomo et al. 2016; De Giacomo and Vardi 1999).\nPerhaps its most widely recognised use to-date is as the logic underlying temporal process modelling languages such as Declare (Pesic, Schonenberg, and van der Aalst 2007). Very briefly, a Declare specification is a set of contraints on the potential evolution of a process, which is expressed through a syntactic variant of a subclass of LTLf formulas. The full specification can thus be seen as a conjunction of LTLf formulas. As specifications become bigger-specially when they are automatically mined from trace logs (Di Ciccio and Montali 2022), it is not uncommon to encounter inconsistencies (i.e., business process models which are intrinsically contradictory) or other errors.\nTo understand and correct these errors, it is thus important to highlight the sets of formulas in the specification that are responsible for them (Niu et al. 2023; Roveri et al. 2024)."}, {"title": "Related Work", "content": "The task of computing MUCs has been considered, under different names, for several representation languages including propositional logic (Liffiton and Sakallah 2008), constraint satisfaction problems (Menc\u00eda and Marques-Silva 2014), databases (Meliou, Roy, and Suciu 2014), description logics (Schlobach and Cornet 2003), and ASP (Alviano et al. 2023) among many others. For a general overview of the task and known approaches to solve it, see (Pe\u00f1aloza 2020).\nAlthough the task was briefly studied for LTL (over infinite traces) in (Baader and Pe\u00f1aloza 2010), it was only recently considered for the specific case of LTLf (Niu et al. 2023; Roveri et al. 2024). Interestingly, for LTLf the focus has been only on computing one (potentially non-minimal) unsatisfiable core. To our knowledge, we are the first to propose a full-fletched LTLf MUC enumerator.\nThe idea of using a highly optimised reasoner from one language to enumerate MUCs from another one was already considered, first exploiting SAT solvers (Sebastiani and Vescovi 2009) and later on using ASP solvers (Pe\u00f1aloza and Ricca 2022). Our approach falls into the latter class. Our reduction to ASP is inspired on the automata-based satisfiability procedure, previously used for SAT-based satisfiability checking (Fionda and Greco 2018; Li et al. 2020a), alongside an incremental approach that verifies the (non-)existence of models up to a certain length."}, {"title": "Preliminaries", "content": "We briefly recap required notions of Linear Temporal Logic over Finite Traces (LTLf) (De Giacomo and Vardi 2013) and Answer Set Programming (ASP) (Brewka, Eiter, and Truszczynski 2011)."}, {"title": "Answer Set Programming", "content": "Syntax and semantics. A term is either a variable or a constant, where variables are alphanumeric strings starting with uppercase letter, while constants are either integer number or alphanumeric string starting with lowercase letter. An atom is an expression of the form $p(t_1,...,t_n)$ where p is a predicate of ariety n and $t_1,..., t_n$ are terms; it is ground if all its terms are constants. We say that an atom $p(t_1,..., t_k)$ has signature p/k. An atom a matches a signature p/k if $a = p(t_1,...,t_k)$. A literal is either an atom a or its negation not a, where not denotes the negation as failure. A literal is said to be negative if it is of the form not a, otherwise it is positive. For a literal l, $\\bar{l}$ denotes the complement of l. More precisely, $\\bar{l} = a$ if l = not a, otherwise $\\bar{l} = not a$. A normal rule is an expression of the form $h\\leftarrow b_1,..., b_n$ where h is an atom referred to as head, denoted by $H_r$, that can also be omitted, $n \\geq 0$, and $b_1,..., b_n$ is a conjunction of literals referred to as body, denoted by $B_r$. In particular a normal rule is said to be a constraint if its head is omitted, while it is said to be a fact if n = 0. A normal ruler is safe if each variable r appears at least in one positive literal in the body of r. A program is a finite set of safe normal rules. In what follows we will use also choice rules, which abbreviate complex expressions (Calimeri et al. 2020). A choice element is of the form $h : l_1,...,l_k$, where h is an atom, and $l_1, . . . , l_k$ is a conjunction of literals. A choice rule is an expression of the form ${e_1;...; e_m} \\leftarrow b_1,...,b_n$, which is a shorthand for the set of normal rules $h_i \\leftarrow l^\\prime_1, ..., l^\\prime_{k_i}, b_1,..., b_n, not \\text{ } nh_i$; $nh_i \\leftarrow l^\\prime_1, ..., l^\\prime_{k_i}, b_1,..., b_n, not \\text{ } h_i$, for each i $\\in$ 1,...,m where $e_i$ are of the form $h_i : l^\\prime_1,...,l^\\prime_{k_i}$, and nhi is a fresh atom not appearing anywhere else.\nGiven a program P, the Herbrand Universe of P, $U_P$, denotes the set of constants that appear in P, while the Herbrand Base, $B_P$, denotes the set of ground atoms obtained from predicates in P and constants in $U_P$. Given a program P, and r $\\in$ P, ground(r) denotes the set of ground instantiations of r obtained by replacing variables in r with constants in $U_P$. Given a program P, ground(P) denotes the union of ground instantiations of rules in P. An interpretation $I \\subseteq B_P$ is a set of atoms. Given an interpretation I, a positive (resp. negative) literal l is true w.r.t. I if l $\\in$ I (resp. l $\\notin$ I); otherwise it is false. A conjunction of literal is true w.r.t I if all its literals are true w.r.t. I. An interpretation I is a model of P if for every ruler $\\in$ ground(P), $H_r$ is true whenever $B_r$ is true. Given a program P and an interpretation I, the (Gelfond-Lifschitz) reduct (Gelfond and Lifschitz 1991), denoted by $P^I$, is defined as the set of rules obtained from ground(P) by deleting those rules whose body is false w.r.t I and removing all negative literals that are true w.r.t. I from the body of remaining rules. Given a program P, and a model I, then I is also a answer set of P if no such $I^\\prime \\subset I$ exists such that $I^\\prime$ is a model of $P^{I}$. For a program P, let $AS(P)$ denotes the set of answer sets of P, then P is said to be coherent if AS $\\neq$ 0, otherwise it is incoherent. Given an answer set S and a signature $\\sigma$, the projection of S on $\\sigma$ is the set $S_\\sigma = {\\alpha \\in S : a \\text{ matches } \\sigma}$."}, {"title": "MUSes and MSMS", "content": "Consider a program P and a set of objective atoms $O \\subset B_P$. For S $\\subseteq$ O, we denote by enforce(P, O, S) the program obtained from P by adding a choice rule over atoms in O (i.e. ${o_1; ... ; o_n} \\leftarrow$) and a set of constraints of the form $\\leftarrow not \\text{ } o$, for every o $\\in$ S. Intuitively, enforce(P, O, S) denotes an augmentation of the program P in which the objective atoms can be arbitrarily choosen (i.e. either as true or false) but the atoms in S are enforced to be true.\nAn unsatisfiable subset for P w.r.t. the set of objective atoms O is a set of atoms U $\\subseteq$ O such that enforce(P, O, U) is incoherent. US(P, O) denotes the set of unsatisfiable subsets of P w.r.t. O. An unsastisfiable subset U $\\in$ US(P, O) is a minimal unsatisfiable subset (MUS) of P w.r.t. O iff for every $U^\\prime \\subset U$, $U^\\prime \\notin$ US(P, O). Analogously, an answet set $M\\in AS(P)$ is a minimal stable model (MSM) of P w.r.t. the set of objective atoms O if there is no answer set $M^\\prime \\in AS(P)$ with $(M^\\prime \\cap O) \\subset (M \\cap O)$."}, {"title": "Linear Temporal Logic over Finite Traces", "content": "Linear Temporal Logic (LTL) (Pnueli 1977) is an extension of propositional logic which allows to reason over infinite sequences of propositional interpretations or traces. LTLf (De Giacomo and Vardi 2013) is a variant of this logic that considers only finite traces. Let A be a finite set of propositional symbols. The class of LTLf formulas over A is defined"}, {"title": "Method", "content": "Technique approach proposed in this paper relies on leveraging ASP minimal unsatisfiable sets (MUSes) enumeration algorithms to generate a sequence of candidate minimal unsatisfible cores (MUCs) for an LTLf formula. In order to put in place such approach, a formal connection between these objects must be established. In this section, we introduce the notion of probe and k-MUC to investigate this relationship. A probe is an abstraction over the class of logic programs with suitable properties to apply the approach herein presented; k-MUCs are a relaxation wrt model length of the concept of MUC, which reveals to be more suitable for ASP-based reasoning."}, {"title": "MUS and Probes", "content": "In the rest of the paper we adopt the notation introduced in in (Niu et al. 2023). Let $\\varphi = {\\phi_1,...,\\phi_n}$ be a formula in conjunctive form, where $\\phi_i$ is a conjunct of $\\varphi$. With a slight abuse of notation, we will identify $\\varphi$ with the set of its conjuncts.\nOur first assumption is that there exists an uniform way to encode LTLf formulae in conjunctive normal form into logic programs. In particular, we are interested in encodings where original conjuncts of $\\varphi$ can be told apart by means of special atoms. More formally:"}, {"title": "Definition 1 (Reification Function)", "content": "A reification function for a formula $\\varphi$ is a function that maps $\\varphi$ into a logic program whose Herbrand base contains an atom phi(i) for each $\\phi_i \\in \\varphi$. We denote the set of atoms matching signature phi/1 by $O(\\varphi)$."}, {"title": "Definition 2 (k-Probe)", "content": "Let k $\\in$ N. A reification function p is a probe of depth k (or k-probe for short) for $\\varphi$ if for each set S $\\subseteq$ O($\\varphi$) it holds that Formula(S) admits a model of length at most k if and only if there exists an answer set M of p($\\varphi$) such that S = $M_\\uparrow O(\\varphi)$."}, {"title": "Lemma 3", "content": "Let p be a probe of depth k for $\\varphi$. Let S be a minimal unsatisfiable subset of p($\\varphi$) wrt the objective atoms O($\\varphi$). Then Formula(S) is either an MUC of $\\varphi$ or it is satisfiable but its shortest satisficing trace has length greater than k."}, {"title": "Proof", "content": "Assume S is a minimal unsatisfiable subset wrt O($\\varphi$). Then, all its (proper) subsets can be extended to answer sets thus, interpreting them as formulae yields an LTLf formula that admits a model of length at most k, by Definition 2. Hence, all proper subsets of Formula(S) are satisfiable, while Formula(S) itself is either unsatisfiable or its shortest model trace has a length greater than k. In the former case, it matches the definition of MUC."}, {"title": "Example 4", "content": "Consider the formula $\\varphi$ = {X5$\\beta$, X5$\\neg$$\\beta$}. This formula has a unique MUC, namely X5$\\beta$$\\wedge$X5$\\neg$$\\beta$. If we consider a probe $p_3$ = p(3,$\\varphi$), it has two MUSes, namely {X5$\\beta$}, {X5$\\neg$$\\beta$}, since these formulae do not admit models of length at most 3. If we consider instead probes of depth at least 5, it is now possible to detect the MUC through the (unique) MUS {X5$\\beta$,X5$\\neg$$\\beta$}."}, {"title": "Definition 5 (k-bound MUC)", "content": "Let k $\\in$ N. A k-bound MUC (or k-MUC) for the formula $\\varphi$ is a minimal subset of $\\varphi$ that does not admit a model of length at most k. We denote by $MUC_k(\\varphi)$ the set of all k-MUCs for a formula $\\varphi$."}, {"title": "Lemma 6", "content": "Let S $\\in$ $MUC_k(\\varphi)$. If S is unsatisfiable, then S is a MUC for $\\varphi$."}, {"title": "Proof", "content": "Follows from the fact that since S$\\in$ $MUC_k(\\varphi)$, it means that any proper subset of S admits a model of length at most k, hence it satisfiable. If S is also unsatisfiable, it matches the definition of MUC."}, {"title": "Lemma 7", "content": "Let $\\varphi$ be a formula, k $\\in$ N. S is a minimal unsatisfiable subset of the k-probe p($\\varphi$) if and only if Formula(S) is a k-MUC for $\\varphi$."}, {"title": "Algorithm 1", "content": "Enumerate unsatisfiable k-MUCs"}, {"title": "MUC enumeration by MUS enumeration", "content": "Applying Theorem 8 we can enumerate MUCs of $\\varphi$ by enumerating MUSes of a complete probe for $\\varphi$. In general, computing the completeness threshold for $\\varphi$ is not feasible. However, by Lemma 6, we also know that some k-MUCS, with k $\\leq$ h($\\varphi$) could also be MUCs. These results suggest two anytime algorithms that could be useful in the realm of LTLf MUC enumeration: (i) an algorithm (cfr. Algorithm 1) that computes all MUCs among the k-MUCs for a given k and (ii) an iterative deepening variant of Algorithm 1 (cfr. Algorithm 2) which expands the probe depth k whenever a k-MUC reveals not to be unsatisfiable. Algorithm 1 and 2 provide pseudo-code for such approaches. Both algorithms make use of the subroutines probe, enumerate_mus,\nto_formula, check_satisfiability, that are explained next.\nprobe($\\varphi$, k) builds the logic program from which we will extract k-MUCs. This is the counterpart of p(k, $\\varphi$).\nenumerate_mus(P) invokes an ASP solver to extract MUSes of the probe P wrt the objective atoms $\\Phi$;\nto_formula(x) given an MUS x of P, rebuilds the LTLf formula Formula(x);\ncheck_satisfiability($\\varphi$) determines wheter an LTLf formula is satisfiable or not; if $\\varphi$ is satisfiable, returns the length of a satisficing trace; otherwise, it returns 0;\nWe remark both algorithms are compatible with any ASP solver that implements MUS enumeration (that is, an implementation of the procedure enumerate_mus) and (complete) LTLf solvers that can (i) provide a satisficing trace length for satisfiable formulae (ii) prove unsatisfiability (that is, an implementation of the procedure check_satisfiability).\nAlgorithm 1 is straightforward. We enumerate MUSes of a k-probe, which yields a sequence of k-MUCs. Each k-MUC is a candidate MUC for $\\varphi$, that can be certified or"}, {"title": "Algorithm 2", "content": "Enumerate MUCs - Iterative Deepening"}, {"title": "A concrete example of probe", "content": "Probes can be obtained with slight modifications from any ASP encoding to perform bounded satisfiability of LTLf formulae. In this section, we show how to obtain a probe from the encoding proposed by (Fionda, Ielo, and Ricca 2024), which repurposes to ASP the SAT-based approach presented in (Fionda and Greco 2018). This will also be the probe we use in the experimental section. In rest of the section, we will provide ASP encoding using the clingo input language, for further detail we refer the reader to (Gebser et al. 2019).\nWe start by a brief recap of the ASP approach to bounded satisfiability (Fionda, Ielo, and Ricca 2024), then show how the encoding can be seamlessy adapted into a probe."}, {"title": "Encoding formulae", "content": "The starting point is to encode an LTLf formula into a set of facts. Each subformula of $\\varphi$ is assigned an unique integer identifier. This identifier is used as a term in the predicates until/3, release/3, negate/2,\nconjunction/2, disjunction/2 and atom/1 to reify the syntax tree of into a directed acyclic graph."}, {"title": "Example 9", "content": "As an example, consider the formula $\\varphi$ = (a$\\land$ b)$\\land$ (c U b) with two conjuncts is encoded through the"}, {"title": "The probe", "content": "The above program encodes whether $\\varphi$ admits a model of length up to k. In order to comply with definition of probe (i.e. Definition 2), we require that there exists $I_{satisfiability}$ admits an answer set for each subset of $\\varphi$ that admits a model of length up to k. This is obtained by replacing each fact of the form conjunction(0, id) $\\in$ [$\\varphi$], where id is an identifier of a most immediate subformula of $\\varphi$, with a rule of the form conjunction(0, id) $\\leftarrow$ phi(id), as well as the choice rule {phi(id)} $\\leftarrow$."}, {"title": "Experiments", "content": "This section presents an experiment conducted to empirically evaluate the performance of our system mus2muc. We performed different experiments addressing the following issues:\nExtraction of Single MUC: How does mus2muc perform in computing a single MUC?\nEnumeration of MUCs: How effective is mus2muc in enumerating LTLf MUCs?\nGeneration vs. Certification: How does MUSes generation and LTLf satisfiability checks affect the overall performance of mus2muc?\nDomain agnostic MUCs enumeration techniques: How does mus2muc compare with SAT-based MUCs enumeration techiques, suitably adapted from LTL to LTLf domain?\nIn what follows, we describe the implementation of our system, and then shift the attention to an analysis aimed at answering the above questions."}, {"title": "Implementation", "content": "The implementation of mus2muc closely follows the pseudo-code in Algorithm 2. In particular, our implementation uses the ASP solver wasp as a MUS Generator, and the LTLf solver aaltaf as a satisfiability solver. More in detail, the solver wasp takes as input the probe described in the previous section, and then performs the MUS enumeration. As soon as a candidate k-MUC (i.e., a MUS of the probe) becomes available an instance of the LTLf solver is invoked as a certifier, in a typical producer-consumer architecture. Furthermore, since multiple k-probes (for increasing value of k) are used, it is possible for k-MUCs to be produced multiple times (for different values of k). To avoid redundant calls to the LTLf solver, we adopt a caching strategy on the MUS generator side. As stated in the previous section, our system is anytime, and outputs MUCs as soon as they are certified at the smallest k that allows to do so."}, {"title": "Systems", "content": "For the single MUC extraction task, we compare with the aaltaf-muc system, which computes a single minimal unsatisfiable core, in four configurations as described in (Niu et al. 2023). We also include aaltaf-uc, which computes a single unsatisfiable core (with no minimality guarantees), and black, which implements a linear elimination strategy to extract a minimal unsatisfiable core. An in-depth comparison between aaltaf-uc and aaltaf-muc is available in (Niu et al. 2023). For the MUCs enumeration task we consider a general purpose tool must (Bend\u00edk and Cerna 2018), which supports three LTL MUC enumeration algorithms (namely, ReMUS, MARCO and TOME). Note that, since must supports the LTL domain but not the LTLf domain, we patch must by applying the well-known LTL-to-LTLf transformation presented in (De Giacomo and Vardi 2013) before evaluating LTLf constraints within the MUC enumeration procedure."}, {"title": "Benchmarks", "content": "In our experiments we consider a benchmark suite consisting of common formulae families used in LTL and LTLf literature to evaluate solvers. In particular, we use all unsatisfiable formulae that appear in (Schuppan and Darmawan 2011), and randomly generated formulae from (Li et al. 2020b). These formulae have been previously used by (Niu et al. 2023) to benchmark single MUC computation, and by (Roveri et al. 2024) for single UC (with no minimality guarantee) extraction. This benchmark suite contains unsatisfiable instances from 15 different applications domains, each with different formula shapes and feature. In particular, they comprise both instances from applications (13 domains) and randombly generated (2 domains)."}, {"title": "Extraction of a single MUC", "content": "First of all we assess the performance of our implementation in the computation of"}, {"title": "Enumeration of MUCs", "content": "Our second experiment consists in evaluating mus2muc effectiveness in enumerating MUCs of the formulae in the benchmark suite. Table 1 reports statistics about the number of found MUCs, probe depth and size of MUCs (i.e., number of conjuncts).\nIn general, different formula families exhibit heterogeneous behavior, ranging from easy (e.g., fully enumerated within seconds) to hard yielding a number of MUCs in"}, {"title": "Generation vs. Certification", "content": "In the mus2muc system, following Algorithm 2, each (unique) MUS extracted from the probe is checked for satisfiability by an LTLf solver, to be either certified (e.g., found unsatisfiable) or disproved (e.g., there exists a satisficing trace whose length exceeds the current probe depth). In our implementation, MUS search and MUS certification run concurrently rather than in an interleaved fashion. Given the modularity of our approach, it is interesting to study which component affects runtimes the most. To this end, we consider formula families that are not fully enumerated within timeout, but behave differently from the ones considered in the previous experiment."}, {"title": "Domain-agnostic MUCs enumeration techniques", "content": "As far as we know, no publicly available systems work out of the box to enumerate MUCs of LTLf formulae. However, a number of general purpose, domain-agnostic MUC extraction algorithms (which also support LTL as a domain) are available (Bend\u00edk and Cerna 2018). The survey by (Roveri et al. 2024), does not compare with algorithms proposed in (Bend\u00edk and Cerna 2018)."}, {"title": "Conclusions", "content": "Satisfiability of temporal specifications expressed in LTLf play an important role in several artificial intelligence application domains (Bacchus and Kabanza 1998; Calvanese, De Giacomo, and Vardi 2002; De Giacomo et al. 2016; De Giacomo and Vardi 1999; De Giacomo et al. 2019). Therefore, in case of unsatisfiable specifications, detecting reasons for unsatisfiability e.g., computing its minimal unsatisfiable cores - is of particular interest. This is especially true whenever the specification under analysis is expected to be satisfiable.\nRecent works (Niu et al. 2023; Roveri et al. 2024) propose several approaches for single MUC computation, but do not investigate enumeration techniques for MUCs.\nHowever, enumerating MUCs for LTLf specifications is pivotal to enabling several reasoning services, such as some explainability tasks (Miller 2019), as it is the case for propositional logic (Marques-Silva 2010; Marques-Silva, Janota, and Menc\u00eda 2017).\nIn this paper, we propose an approach for characterizing MUCs of LTLf formulae as minimal unsatisfiable subprograms (MUS) of suitable logic programs, introducing the notion of probe. This enables to implement LTLf MUC enumeration techniques by exploiting off-the-shelf ASP and LTLf reasoners, similarly to SAT-based domain agnostic MUC enumeration techniques \u00e0 la (Bend\u00edk and Cerna 2018).\nThe approach presented herein is modular with respect to ASP & LTLf reasoners, which essentially constitute two sub-modules of the system, and with respect to the logic program that is used to extract MUCs via its MUSes.\nWe implement this strategy in mus2muc, using the ASP solver wasp and the LTLf solver aaltaf. Our experiments show mus2muc is effective at enumerating MUCs of unsatisfiable formulae that are commonly used in LTLf literature as benchmarks, as well as being competitive with available state-of-the-art for single MUC computation.\nTo the best of our knowledge, this represent the first attempt to address this task in the LTLf setting.\nAs far as future works are concerned, we are interested in studying how the choice of probes affect MUCs computation in our setting, as well as providing ad-hoc implementations for closely related LTLf tasks, such explaining and repairing incosistent Declare specification in the realm of process mining."}]}