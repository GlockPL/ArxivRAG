{"title": "IGMaxHS \u2013 An Incremental MaxSAT Solver with Support for XOR Clauses", "authors": ["Ole L\u00fcbke"], "abstract": "Recently, a novel, MaxSAT-based method for error correction in quantum computing has been proposed that requires both incremental MaxSAT solving capabilities and support for XOR constraints, but no dedicated MaxSAT solver fulfilling these criteria existed yet. We alleviate that and introduce IGMaxHS, which is based on the existing solvers iMaxHS and GaussMaxHS, but poses fewer restrictions on the XOR constraints than GaussMaxHS. IGMaxHS is fuzz tested with xwcnfuzz, an extension of wenfuzz that can directly output XOR constraints. As a result, IGMaxHS is the only solver that reported neither incorrect unsatisfiability verdicts nor invalid models nor incoherent cost-model combinations in a final fuzz testing comparison of all three solvers with 10000 instances. We detail the steps required for implementing Gaussian elimination on XOR constraints in CDCL SAT solvers, and extend the recently-proposed re-entrant incremental MaxSAT solver application program interface to allow for incremental addition of XOR constraints. Finally, we show that IGMaxHS is capable of decoding quantum color codes through simulation with the Munich Quantum Toolkit.", "sections": [{"title": "1. Introduction", "content": "Modern, incrementally-usable Boolean satisfiability (SAT) solvers have enabled us to solve its even more complex extensions, such as Maximum Satisfiability (MaxSAT) [1, 2], as well as practical problems in different application domains, e.g., bounded model checking and hardware validation [3, 4], more efficiently. The re-entrant incremental satisfiability application program interface (IPASIR) [? ] describes the common functionality of such solvers and has become the de-facto standard interface for SAT-based applications. Recently, as an optimization counterpart to IPASIR, the re-entrant incremental MaxSAT solver application program interface (IPAMIR) has been introduced to enable solving increasingly complex constrained optimization problems [5]. Usually, (incremental) (Max)SAT solvers expect their input in conjunctive normal form (CNF), which can result in prohibitively large formulas for applications where exclusive-OR (XOR) is an important operation, e.g., cryptography [6] or hashing-based approximate model counting [7]. A single XOR constraint of length n results in $2^{n-1}$ constraints of length n in CNF. However, a set of XOR constraints forms a set of linear equations that can be solved by Gaussian elimination, which can be integrated in (Max)SAT solvers to resolve XOR constraints more quickly [7, 6].\nOff-the-shelf (Max)SAT solvers are well-known for their efficiency, and employed in novel applications where either no dedicated algorithm exists yet, or where they can even outperform existing solutions [8, 9]. A recent such example is decoding quantum color codes (QCCs) for error correction in quantum computing [10]. However, this MaxSAT-based method requires both incrementality and support for XOR constraints, but no off-the-shelf dedicated MaxSAT solver currently provides both. The Z3 satisfiability modulo theories (SMT) solver does provide both of these features, yet usually dedicated MaxSAT solvers are more efficient on MaxSAT instances than general optimization solvers [11].\nWe aim to alleviate that and introduce IGMaxHS (IncrementalGaussMaxHS)\u00b9, a novel, incremental MaxSAT solver with support for incrementally adding XOR constraints. The solver is based on a"}, {"title": "2. Preliminaries", "content": "When referring to variables, we mean Boolean variables that can take the values true or false (or 1 or 0, respectively). A literal is either a variable v, or the negation of a variable, denoted by \u00acv. A clause is a disjunction of literals, the length of a clause is its number of literals, e.g., (a \u2228 \u00acb V c) is a clause of length three. Clauses of length one are also called unit clauses or just units. An XOR clause is an XOR chain of literals, e.g., (a \u2295 \u00acb \u2295 c) is an XOR clause of length three. Boolean satisfiability (SAT) is the problem of deciding whether for a given propositional logic formula there exists an assignment such that the formula evaluates to true. Such an assignment is called a satisfying assignment or model. A propositional logic formula is in conjunctive normal form (CNF) if it is a conjunction of clauses, e.g., a \u2227 (\u00acb V c) is in CNF. In this paper Maximum Satisfiability (MaxSAT) means partial, weighted MaxSAT (PWMS). Given a set of hard clauses, and a set of soft clauses, each associated with a weight, PWMS is the problem of finding a model that satisfies all hard clauses, and maximizes the weight of satisfied soft clauses.\nUnit propagation (UP) is the process of removing a unit from a set of clauses in the following way [16]: remove the literal from each clause in which it is falsified, and remove each clause in which it is satisfied. It is a core procedure in modern conflict-driven clause learning (CDCL) SAT solvers, which commonly proceed as follows [17]: Initially, UP is applied until there are no more units to propagate (if there are conflicting units, unsatisfiability can already be determined). Then, as long as not all variables are assigned and unsatisfiability has not yet been determined, a new decision level is introduced, a variable is selected and assigned a value, and UP is applied. If UP finds a conflict, it is"}, {"title": "3. Combining iMaxHS and GaussMaxHS", "content": "Because IGMaxHS combines features of iMaxHS and GaussMaxHS, both of which are based on MaxHS, a logical first step is to combine both solvers on source code level. Yet, the underlying MaxHS versions differ, and so do the integrated SAT solvers. IGMaxHS is based on MaxHS 4 [13] and uses CaDiCaL [?], while GaussMaxHS is based on MaxHS 3 [12] and uses MiniSat [20]. Furthermore, MaxHS (and iMaxHS) still use some of the data structures of MiniSat, most notably the Lit struct for representing literals. With so many complex and different components, the combination process is necessarily error-prone and demands thorough testing.\nAs a first step, we copied all files that only occur in either one of the two solver code bases, and files that are shared by both, but have binary equal content. Next, we turned to the files shared by both programs, but which had different content. We used a standard diff tool to merge them manually. During this phase we re-enabled the seedtype command line argument of MaxHS (disabled in GaussMaxHS), which, in essence, determines to what extent the built-in MIP solver can be used to solve the MaxSAT instance [14]. We also encountered an assertion that would let GaussMaxHS crash when it encounters XOR constraints shorter than three literals, which we removed.\nXOR constraints behave similar to CNF constraints during UP [6]: falsified literals are removed (and an empty XOR clause signals unsatisfiability), but satisfied literals do not immediately satisfy the entire clause. Instead, they invert the (implicitly-maintained) right-hand side (RHS) of the clause. The RHS of an XOR-clause determines whether it should evaluate to true or false. As an example, consider the XOR clause a\u2295b\u2295c. If a is falsified, b\u2295c must be true (a is removed). If a is satisfied, b\u2295c must be false (the RHS is inverted), which is equivalent to \u00acb \u2295 c, or b\u2295 \u00acc must be true (allowing for implicitly maintaining the RHS by inverting a literal). Lifting the restriction on the length of XOR clauses is especially important when such clauses can be added incrementally, because some literals may already have fixed values, resulting in shorter XOR constraints. XOR constraints of length one are exactly the same as CNF constraints of the same length, and thus units that can immediately be propagated. For XOR clauses of length two the cost of converting them to CNF is low, so for any XOR clause a\u2295b we add the equivalent CNF clauses (a \u2228 b) \u2227 (\u00aca \u2228 \u00acb) when the RHS is true, and (a \u2228 \u00acb) \u2227 (\u00aca \u2228 b) when the RHS is false.\nWhen we integrated the Gaussian elimination code of GaussMaxHS into iMaxHS we found that it often interfaces with MiniSat, which is not present anymore in iMaxHS, so the calls need to be"}, {"title": "3.1. Generic Interface for Integrating Gaussian Elimination", "content": "As mentioned above, the functions to perform Gaussian elimination on the XOR clauses query the SAT solver for information and also trigger certain SAT solving routines. We have captured all functionality the SAT solver needs to provide in a generic C++ header file, shown in Listing 1 in appendix A. All 39 functions are designed as function templates and many use automatic return type deduction to maximize flexibility and allow for integration with different solvers. Not all of them are strictly required for implementing Gaussian elimination; some are included for convenience (they can be expressed in terms of the other functions), and some are helpful for debugging. In the following we give an overview to highlight which functionalities a SAT solver needs to provide for Gaussian elimination to be integrated.\nOne set of functions (cf. ll. 12 \u2013 89) is concerned with obtaining information from the SAT solver: the number of variables in the formula, whether the formula has already been determined to be (un)satisfiable, the current decision level, the trail of decisions (and its length), the current values of variables (and literals), on which decision level a variable has been assigned, and the number of XOR clauses. Furthermore, functions to convert between variables, literals, and corresponding zero-based indices are required.\nThe XOR clauses are actually managed by the SAT solver (in this architecture). This is also true for the Gauss matrices, yet the SAT solver needs to provide read and write access to them and the XOR clauses alike (cf. ll. 91 \u2013 99). The interface also expects the SAT solver to be able to \u201cclean\u201d the XOR clauses (cf. ll. 101 \u2013 105), i.e., to remove literals which are assigned as described above (section 3).\nFinally, the Gaussian elimination code needs a way to tell the solver that it has determined the formula to be unsatisfiable, trigger UP, enqueue literals for UP, backtrack to arbitrary decision levels, and add new (CNF conflict) clauses to the solver (cf. ll. 107 \u2013 130)."}, {"title": "3.2. Fuzz Testing with xwcnfuzz", "content": "To ensure that IGMaxHS does not output incorrect results, we employed fuzz testing, which can effectively uncover faults in MaxSAT solvers [15]. Our testing routine is built upon the existing fuzz tool wenfuzz [15], which can output MaxSAT instances in the WCNF format used in the MaxSAT evaluations\u00b2 (MSEs). Yet, to find problems related to XOR clauses, we need the tool to output such, which it was originally not capable of (XOR clauses are not part of the WCNF format). However, wenfuzz actually generates XOR clauses of length three and four, but encodes them in CNF. Therefore, we extended wenfuzz and added a new command line switch --xor, which instructs the tool to output hard XOR clauses like, e.g., (v1 \u2295 V2 \u2295 V3) as x h123 0. There is no direct support for soft XOR clauses, yet those are realized using a hard XOR clause and a soft unit clause with an activation literal [7]. For a soft XOR clause like, e.g., (v1 \u2295 V2 \u2295 v2) with weight 10, an activation literal, e.g., V4 is added to form a hard clause x h4 1 2 3 0 and a soft clause 10 -4 0. We refer to the resulting tool as xwcnfuzz, and to the resulting output file format as XWCNF.\nWe performed multiple testing rounds, starting with only 10 instances, and multiplying the number of instances with 10 when no incorrect results were found, until IGMaxHS was able to reliably solve 10000 instances without producing erroneous results. For comparison, we used MaxHS (in the MSE 2021 version, which iMaxHS is based on), iMaxHS and GaussMaxHS, which were executed on equivalent"}, {"title": "4. Incrementally Adding XOR Clauses", "content": "With the IPAMIR, hard CNF clauses are added literal by literal with the function void ipamir_add_hard(void* solver, int32_t lit_or_zero). Using 0 for the lit_or_zero argument signals the end of the clause. To extend IPAMIR to allow for the incremental addition of XOR clauses, we decided to use the same function. For signalling whether the clause that is currently added is a CNF or XOR clause, we equipped the function with an additional Boolean argument with a default value: bool is_xor = false. This way, compatibility with existing implementations is maintained, and the IPAMIR is not cluttered with additional functions.\nOur implementation closely follows that of iMaxHS for adding hard CNF clauses and that of Gauss-MaxHS for adding hard XOR clauses. The is_xor flag only needs to be set on the clause-finalizing call of the function, as all other calls only store the provided literals in a vector (as in iMaxHS). When the clause is finalized, we first check its size. If it is a unit, we fall back to the clause adding routine of iMaxHS. Otherwise, duplicate literals, and literals whose values are already fixed are removed from the clause as in GaussMaxHS. If, afterward, the clause is empty and its RHS is false, it is already satisfied and ignored. Otherwise, the clause is added to the solver (if it is empty, this signals unsatisfiability). Finally, we check whether the current model satisfies the clause. If not, the current model is invalidated."}, {"title": "5. Decoding Quantum Color Codes", "content": "Recently, a MaxSAT based method to decode quantum color codes (QCCs) has been proposed that requires a solver that is capable of incrementally updating the problem instance and has support for XOR clauses [10]. As no dedicated MaxSAT solver with these features existed at the time, the authors turned to the Z3 SMT solver [21]. In this section we demonstrate that IGMaxHS is capable of decoding QCCs by integrating it with the Munich Quantum Toolkit (MQT) [10] and executing the corresponding simulations.\nThe QCC decoding method is based on an analogy to the Lights Out Puzzle (LOP) [10, 22]. Explaining the method in detail is beyond the scope of this paper; a brief introduction to the LOP is sufficient to understand the resulting MaxSAT instances. Consider a grid of n \u00d7 n lights, each equipped with a light switch. Toggling a switch turns off the corresponding light and all directly adjacent lights (i.e., excluding diagonals). Given an initial configuration of turned-on lights, find a minimum-size set of switches that turn all lights off. Note, that toggling a switch twice is equivalent to not using it at all, so each switch in the resulting set must only be toggled once [22]."}, {"title": "6. Summary & Future Work", "content": "IGMaxHS is a novel MaxSAT solver that implements the re-entrant incremental MaxSAT solver application program interface (IPAMIR) and additionally supports (the incremental addition of) XOR clauses. Through fuzz testing with xwenfuzz we ensured it neither reports incorrect unsatisfiability verdicts nor invalid models nor incoherent cost-model combinations. On the one hand, this distinguishes IGMaxHS from other, similar solvers, as outlined in section 3.2. On the other hand, it is often slower than these solvers. We described its development process, detailed the steps required to implement Gaussian elimination in (Max)SAT solvers, and captured which functionalities they need to provide in a C++ template header. Finally, we demonstrated that IGMaxHS is practically capable of decoding quantum color codes (QCCs)."}]}