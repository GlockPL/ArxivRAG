{"title": "THE CARDINALITY OF IDENTIFYING CODE SETS FOR SOCCER\nBALL GRAPH WITH APPLICATION TO REMOTE SENSING", "authors": ["Anna L.D. Latour", "Arunabha Sen", "Kaustav Basu", "Chenyang Zhou", "Kuldeep S. Meel"], "abstract": "In the context of satellite monitoring of the earth, we can assume that the surface of the earth is divided\ninto a set of regions. We assume that the impact of a big social/environmental event spills into neighboring\nregions. Using Identifying Code Sets (ICSes), we can deploy sensors in such a way that the region in\nwhich an event takes place can be uniquely identified, even with fewer sensors than regions. As Earth is\nalmost a sphere, we use a soccer ball as a model. We construct a Soccer Ball Graph (SBG), and provide\nhuman-oriented, analytical proofs that 1) the SBG has at least 26 ICSes of cardinality ten, implying that\nthere are at least 26 different ways to deploy ten satellites to monitor the Earth and 2) that the cardinality of\nthe minimum Identifying Code Set (MICS) for the SBG is at least nine. We then provide a machine-oriented\nformal proof that the cardinality of the MICS for the SBG is in fact ten, meaning that one must deploy at\nleast ten satellites to monitor the Earth in the SBG model. We also provide machine-oriented proof that\nthere are exactly 26 ICSes of cardinality ten for the SBG.", "sections": [{"title": "1 Introduction", "content": "We study an event monitoring problem with satellites as sensors. The events that we focus on may be environmental\n(drought/famine), social/political (social unrest/war) or extreme events (earthquakes/tsunamis). Such events take place\nin regions on the surface of the earth, where a region may be a continent, a country, or a set of neighboring countries.\nThe sensors that we envisage for monitoring such events are satellites placed in orbits surrounding the earth. A\nsatellite constellation that can be deployed for such monitoring purposes is shown in Figure 1a. Examples of such\nconstellations include the Global Positioning System (GPS) for navigation, the Iridium and Globalstar satellite telephony,\nand the Disaster Monitoring Constellation (DMC) for remote sensing. In particular, DMC is designed to provide earth"}, {"title": "2 Related Work", "content": "We first briefly discuss existing work on the topic of Identifying Codes. Then, we provide a short history of machine-\ngenerated proofs in the context of combinatorial solving."}, {"title": "2.1 Identifying Codes", "content": "The study of Identifying Codes and its applications in sensor network domains has a history that spans two and a\nhalf decades. Karpovsky et al. introduced the concept of Identifying Codes in 1998 and provided results for\nIdentifying Codes for graphs with specific topologies, such as binary cubes and trees. Charon et al. studied complexity\nissues related to computation of minimum Identifying Codes for graph and showed that in several types of graph,\nthe problem is NP-hard . Auger showed that the problem can be solved in linear time if the graph\nhappened to be a tree, but even for a planar graph the problem remains NP-complete .\nUsing Identifying Codes, Laifenfeld et al. studied covering problems in  and joint monitoring and routing\nin wireless sensor networks in . Basu et al. recently applied Identifying Codes in problems regarding the\nidentification of criminals in social networks  and the identification of spreaders of misinformation in online\nnetworks . Ray et al. in  generalized the concept of Identifying Codes, to incorporate robustness\nproperties to deal with faults in sensor networks.\nA classical approach to solving Identifying Code problems for networks, is to encode the problem as an integer-\nlinear program (ILP) or mixed-integer program (MIP)  and to solve it with an off-the-shelf MIP solver.\nRecently, Latour et al. proposed an alternative method, in which they reduce the problem of finding a particular type of\nIdentifying Codes in a network to the computationally harder problem of finding an Independent Support of a Boolean\nformula, allowing for an exponentially smaller encoding of the problem . Approximation algorithms for\ncomputation of Identifying Codes for some special types of graphs are presented in .\nThe problem of finding Identifying Codes in graphs is closely related to that of graph-constrained group test-\ning , which uses the monitoring of paths rather than nodes in the network to uniquely identify network failures.\nThis field, known as network tomography, has seen some recent advances, including, for example, quantitative studies\nof the maximum number of simultaneous failures that can be uniquely identified .\nTopological and combinatorial properties of soccer balls have been studied extensively in ."}, {"title": "2.2 Machine-Verifiable Formal Proofs", "content": "Over the five decades, different communities (including, but not limited to, the Programming Languages community,\nthe Mathematics community, and the Boolean Satisfiability Solving community) have discovered the merits of formal,\nmachine-readable proofs of mathematical conjectures. The generation and verification for such proofs is motivated by\nthe observation that, in practice, mathematical proofs often turn out to be wrong (even if the conjecture they 'prove' is\nactually correct), see, e.g., Lamport's website on the topic .\nIn a recent commentary article for the American Mathematical Society, Benzm\u00fcller expressed the dream that, in the\nfuture, math papers will contain proofs that integrate human-oriented 'traditional' proofs (to provide intuition to the"}, {"title": "3 Problem Formulation", "content": "In this section, we first provide some preliminaries regarding graphs, and give the definitions of the variations of\nthe Identifying Code Set problem that we study in this work. We also reformulate the Identifying Code Set problem,\npresenting it as a variant of the Graph Coloring problem. Then, we give a specification of the Soccer Ball Graph that we\nuse as a model of planet Earth in this work."}, {"title": "3.1 Graphs, Identifying Codes and Identifying Code Sets", "content": "In this work, we study a combinatorial problem that we model on an undirected graph G := (V, E), where V denotes\nthe set of nodes of the graph, and E denotes the set of edges. We use N(v) to denote the neighborhood of a node\nv \u2208 V, i.e., the set of nodes that are adjacent to v. Similarly, we denote the closed neighborhood of a node v \u2208 V as\nN+(v) := {v} \u222a N(v).\nThe notion of Identifying Codes  has been established as a useful concept for optimizing sensor deployment\nin multiple domains. In this paper, we use Identifying Codes of the simplest form, meaning that we only consider the\n1-hop neighbourhood of a node to determine its identifying code. In the more general version, we might consider the\nk-hop neighbourhood, with k \u2208 N+. For the scope of this work, however, we define Identifying Codes as follows.\nDefinition 1 A vertex set V' \u2286 V of a graph G = (V, E) is called an Identifying Code Set (ICS) if, for all v, w \u2208 V\nwith v \u2260 w, it holds that N+(v) \u2229 V' \u2260 N+(w) \u2229 V'.\nUsing the notion of an Identifying Code Set, we define the define the following combinatorial decision and optimisation\nproblems::\nDefinition 2 Given an undirected graph G := (V, E) on nodes V and E and a set V' \u2286 V, the Identifying Code Set\ndecision problem asks to determine if V' an ICS of G.\nDefinition 3 The Minimum Identifying Code Set (MICS) problem is to find an Identifying Code Set of smallest\ncardinality.\nThe vertices of the set V' may be viewed as alphabets of the code, and the string made up with the alphabets of\nN+(v) may be viewed as the unique \"code\" for the node v. For instance, consider the graph G = (V, E) shown in\nFigure 1c. In this graph V\u2032 = {V1, V2, V3, V4 } is an ICS, as it can be seen from Table 1 that N+ (v) \u2229 V' is unique for\nall vi \u2208 V."}, {"title": "3.2 Graph Coloring Problems", "content": "The MICS computation problem can be viewed as a novel variation of the classical Graph Coloring problem. We will\nrefer to this version as the Graph Coloring with Seepage (GCS) problem. In the classical graph coloring problem, when\na color is assigned (or injected) to a node, only that node is colored. The goal of the standard graph coloring problem to"}, {"title": "3.3 The Soccer Ball Graph", "content": "From the soccer ball, we construct a graph (referred to as a Soccer Ball Graph (SBG)) where each of the 32 regions is\nrepresented as a node and two nodes have an edge between them if the corresponding regions share a boundary. The\nconstruction rules for the SBG are given in Section 3 and a two-dimensional layout of the SBG is shown in Figure 2b.\nUsing a human-oriented, analytical proof, we establish that the upper and lower bounds of the MICS problem for the\nSBG are ten and nine respectively. Using a machine-oriented formal proof, we then establish that the lower bound of\nnine is not strict, and that there are in fact no solutions to the MICS problem for the SBG with a cardinality of less than\nten. We prove that there exist at least 26 different Identifying Code Sets of size ten for the SBG, using a human-oriented,\nanalytical proof, and establish that there are in fact exactly 26 different Identifying Code Sets of size ten for the SBG,\nusing a machine-oriented proof.\nA Soccer Ball Graph (SBG) G = (V, E) is defined in the following way."}, {"title": "4 Upper Bound of MICS of SBG", "content": "In this section, we first show that MICS of the SBG is at most ten and there exists at least 26 ICSes of size ten.\nTheorem 1 The MICS of SBG is at most ten.\nProof 1 Inject colors A, B, C, D, E to the nodes H2,j,1 \u2264 j \u2264 5 and colors E, F, G, H, I, J to the nodes H5,j, 1 \u2264\nj \u2264 5. Injection of ten different colors at these ten nodes, will cause color seepage to all other nodes of SBG. The"}, {"title": "5 Combinatorial Lower Bound of MICS of SBG", "content": "In Figure 2, we have provided a layered representation of the SBG, where 32 nodes of the SBG is placed in six layers,\nindicated by L1 through L6. The layers L1 through L3 constitute the top half of the SBG and the layers L4 through L6\nconstitute the bottom half. As the two halves are symmetric, similar argument can be applied to both of them.\nLemma 1 A MICS must select at least 4 nodes from each half. In other words, at least 4 distinct colors need to be\ninjected in each half.\nProof 3 We provide arguments for the top half of the SBG, and we first show that three distinct colors are necessary to\nensure that each node in top half receives a distinct color (either through injection, seepage or combination of the two).\nConsider layers L1 and L2. No matter which nodes in bottom half are injected with colors, these colors will not seep\ninto the nodes in L1 and L2 (colors seep only to adjacent nodes), coloring in bottom half nodes will not affect the colors\nassociated with nodes in L1 or L2. Since L1 and L2 have six nodes, six distinct colors need to be associated with them.\nIt can be easily verified that in the SBG, in order to ensure distinct colors to each one of the six nodes in L1 and L2\nat least three colors must be injected to three nodes in the top half of the SBG. Clearly at least three nodes must be\nselected from each half so that nodes in L1, L2, L5 and L6 receive distinct colors. With injection of three colors, up to\n$2^3 - 1 = 7$ colors (excluding an empty combination) can be generated.\nNext we show that three colors are not sufficient to color L1 and L2. Without loss of generality, we use alphabets\n{A, B, C} to represent three colors. As mentioned above, 7 distinct colors can be generated with these three colors\n(three primary and four composite), {A, B, C, AB, AC, BC, ABC}. Simple counting shows that each alphabet (color)\nappears exactly 4 times. Suppose there is a proper injection using A, B, C that ensures all nodes in L1 and L2 received\ndistinct colors. Since seven distinct colors can be generated with three primary colors, and L1 and L2 has only six\nnodes, it implies that one of the seven colors (primary or composite) is not used while coloring the nodes of L1 and L2.\nThis implies that at least one of the alphabets A, B, C is appearing three times instead of four in the alphabet strings\n(representing colors) associated with the nodes of L1 and L2. Without loss of generality, we assume that color A is\nappearing 3 times. There are four possible locations for injection of color A in the top half of the SBG. In the following,\nwe examine them all."}, {"title": "6 Machine-Verifiable Proofs of Unsatisfiability", "content": "We can prove that the strict lower bound of MICS of SBG is ten, by using a machine-verifiable proof of unsatisfiability\nof sets of pseudo-Boolean constraints (\u2018PB constraints', for short). In this section, we first review some basic concepts\nand notation of pseudo-Boolean satisfiability. Then, we give a brief introduction to, and motivation for the use of,\nmachine-verifiable proofs of unsatisfiability. We then describe the basic principles of cutting-planes, a proof system for\ncreating proofs of unsatisfiability of PB formulae, and briefly describe a way to encode those proofs, such that they can\nbe read by an automated verifier. In Section 7, we describe the steps and the tools that we used to obtain a proof that the\ncardinality of the MICS of SBG is at least ten."}, {"title": "6.1 Pseudo-Boolean Satisfiability", "content": "For the formal proof part of this work, we will use pseudo-Boolean formulae (PB formulae) to model a We briefly recall\nsome concepts and notation of pseudo-Boolean Satisfiability. For a more detailed overview, we refer the reader to, e.g.,\nChapter 28 of the Handbook of Satisfiability .\nWe denote a set of Boolean variables with the capital letter X and denote individual Boolean variables with\nlowercase letters x \u2208 X. We denote truth values with 1 (true) and 0 (false). A literal l is a variable or its negation (e.g.,\nx or $\\overline{x}$, respectively), where $\\overline{x} = 1 - x$. For simplicity, we write $\\overline{\\overline{x}} = x$. We also note that $\\overline{1} = 0$ and $\\overline{0} = 1$.\nIn this work, we only consider linear pseudo-Boolean (PB) constraints. A linear PB constraint on Boolean variables\nX has, or can trivially be rewritten to have, the following form:\n$C := \\sum a_i l_i \\geqslant b$,\nwhere $a_i, b \\in \\mathbb{Z}$, and $\\triangleright \\in {=, <, >, \\leqslant, \\geqslant }$. The $a_i$s are called the coefficients of the constraint. The right-hand side b is\ncalled the degree of the PB constraint. We call the set of variables that are present in a PB constraint C the support of\nC, denoted as sup(C).\nA full assignment $\\sigma : X \\rightarrow {0, 1}$ assigns a truth value to each variable in X. We denote the truth value that $\\sigma$\nassigns to a variable x \u2208 X by $\\sigma(x)$. We can evaluate a PB constraint to see if it is satisfied by an assignment $\\sigma$. This\nis done by substituting the literals in C for their values in $\\sigma: \\sigma(C) := C({x \\leftrightarrow \\sigma(x) | x \\in sup(C)})$, evaluating the\nleft-hand side and the right-hand side, and checking that they yield integers that satisfy the relational operator $\\triangleright$.\nA PB formula F(X) is a set of PB constraints on Boolean variables X. We say that F(X) is satisfiable iff there\nexists an assignment $\\sigma$ that satisfies each constraint C \u2208 F. If no such $\\sigma$ exists, we say that F is unsatisfiable.\nThe process of showing that a PB formula is unsatisfiable, is called refuting, and a proof of unsatisfiability is called\na refutation. A solver that solves the decision problem of determining whether a PB formula is satisfiable, is called a PB\nsolver."}, {"title": "6.2 Verifying Unsatisfiability", "content": "Given a candidate solution $\\sigma$ to a PB formula F(X), it is straightforward to verify that $\\sigma$ is indeed a solution to F(X).\nAll that it requires, is to substitute every variable in F(X) by the truth value that is assigned to it by $\\sigma$, and check that\neach constraint C \u2208 F is satisfied by $\\sigma$. However, it is less trivial to verify that a PB formula F(X) is unsatisfiable\nand thus has no solutions. If a PB solver returns \"unsatisfiable\", our confidence in the correctness of that conclusion is\ntherefore based on the solver's reputation, e.g., on who developed the solver or on how thoroughly it was tested.\nSince PB solvers can be complex tools, they may contain bugs or even implementation mistakes due to conceptual\nerrors. Hence, for applications where the stakes are high, a solver's reputation may not be enough to ensure the social\nacceptability of the refutations that it produces.\nThis does not only hold for PB solvers, but also for other solvers, like Boolean satisfiability (SAT) solvers. For the\nlast two decades, the Boolean Satisfiability community has therefore been investigating the practices of proof logging\nand proof verification . Since 2013, it has become common\npractice for SAT solvers to produce a certificate of unsatisfiability or proof log along with their unsatisfiability results.\nThis (potentially very large) file contains a log of the reasoning steps that justify the solver's conclusion. SAT solvers\nparticipating in Boolean Satisfiability competitions  are required to produce certificates of unsatisfiability in\nthe standardised DRAT (\u201cdeletion resolution asymmetric tautology\") format ."}, {"title": "6.3 Proving Mathematical Conjectures with Unsatisfiability Proofs", "content": "Machine-verifiable proof technology gave rise to a line of research in which mathematical conjectures were proved\nusing SAT solvers. Notable examples include a proof that Schur Number Five is S(5) = 160 (a centuries-old open\nproblem) [Heu18], and a 200 terabyte proof of the solution to the related Boolean Pythagorean triples problem [Heu17],\nwhich took 40 000 CPU hours of computation to generate, including verification.\nThe recipe for proving a conjecture is the following. First, encode the negation of the conjecture. This encoding can\nbe a propositional formula, for example in conjunctive normal form (CNF), or a PB formula, or even a sentence in a\nmore expressive constraint specification language. Then, let an appropriate solver refute the satisfiability of the encoded\nnegated conjecture. Finally, let a verification tool validate the unsatisfiability certificate.\nIn order for these machine-generated proofs to be socially accepted, we must convince ourselves of the following:\n1. The encoding of the conjecture is correct.\n2. The implementation of that encoding is correct.\n3. The verifier is correct.\nThe first item on this list is impossible to formally guarantee. The best we can do, is to make the encoding as simple\nand as straightforward as possible, so we can convince the reader that it is correct. Similarly, the second item relies on\nimplementing the encoding in a succinct and clear way, so the reader can convince themselves of the correctness of the\nimplementation. Finally, we must be convinced that the verifier made no mistakes in generating the proof, which we\ndiscussed at the end of Section 6.2."}, {"title": "6.4 Cutting-Planes Proofs of Unsatisfiability", "content": "Proofs of unsatisfiability of sets of PB constraints all use a set of inference rules to derive new constraints from existing\nconstraints, until the contradictory constraint 0 \u2265 1 is derived. The first rules are simply definitions and axioms:\n$x \\geqslant 0$\n$\\overline{x} > -1$\n$\\overline{x} = 1 - x$\nlower bound\nupper bound\nnegation\nidempotence"}, {"title": "7 Machine-Generated and Machine-Verified Lower Bound of MICS of SBG", "content": "We now describe how we use machine-verifiable proofs to prove the following theorem:\nTheorem 4 The MICS of SBG is at least ten.\nFirst, we show how to encode the GCS problem as a PB formula. We then describe the steps we took to generate\nand verify a proof of this theorem."}, {"title": "7.1 Pseudo-Boolean Encoding", "content": "Recall the Identifying Code Set decision problem as described in Definition 2. Using the Graph Coloring with Seepage\n(GCS) terminology as described in Section 3.2, we now describe a PB encoding of the ICS decision problem.\nIn the following discussion, we will use dist(u, v) to denote the distance between two nodes in a graph, i.e., the\nnumber of edges along the shortest path from u to v (with dist(v, v) := 0). Additionally, we define $N_{\\leqslant 2}(v) := {u \\in\nV | dist(u, v) \\leqslant 2}$ to be the closed 2-neighborhood of a node v \u2208 V. We define $DS(u, v) := N^+(u)\\triangle N^+(v)$ to be\nthe distinguishing set of nodes u, v \u2208 V, i.e., the symmetric difference of $N^+(u)$ and $N^+(v)$.\nWe encode the decision version of the GCS/ICS decision problem into a set of PB constraints as follows. First, we\ndefine the Boolean variables X = {$x_v | v \\in V$} to be the injection variables, such that $x_v = 1$ indicates that node v is\ninjected with a color and $x_v = 0$ that it is not injected with any color. The first set of constraints in F(X) expresses\nthat each node has to receive a color (either through injection or seepage). To ensure that a node v \u2208 V is colored, it is\nenough to ensure that color is injected into v itself, or into one of the nodes that are adjacent to v:\n$F_{alo}(X) := {\\sum\\limits_{u \\in N^+(v)} x_u \\geqslant 1 | v \\in V }$\nThe next set of constraints that we need to define, express that all signatures must be unique. For the signatures of two\ndistinct nodes u, v \u2208 V to coincide, they must have at least one color in common. The only way in which u and v can\nshare a color, is if they are within a distance of at most 2 of each other. Hence, we only need to explicitly encode that\nthe signatures of nodes u, v \u2208 V are different if they are in each other's closed 2-neighbourhood. Furthermore, the only\nway in which the coloring of u can be different from the coloring of v, is if at least one node in their distinguishing set\nis injected with color. With these observations, we define the following set of uniqueness constraints:\n$F_{unique}(X) := {\\sum\\limits_{w \\in DS(u,v)} x_w \\geqslant 1 | v \\in V, u \\in N_{\\leqslant 2}(v) \\cap N_{\\leqslant 2}(v)}$\nFinally, we add a constraint that says that, for the SBG, there exists a solution with at most nine sensors:\n$C_{budget}(X) := \\sum\\limits_{v \\in V} x_v \\leqslant 9$\nWith this, we obtain the following PB formula:\n$F_{|MICS| \\leqslant 9}(X) := C_{alo} \\cup C_{unique} \\cup {C_{budget}}$\nIf this formula is unsatisfiable for the SBG, we know that the cardinality of the MICS for the SBG must be greater than\nnine. Since we have proved in Section 5 that the cardinality of the MICS of the SBG is at least nine, and proved in\nSection 4 that it is at most ten, by proving that it is greater than nine, we prove that the cardinality of the MICS of the\nSBG is indeed ten."}, {"title": "7.2 Proving that ten is a Strict Lower Bound for the SBG", "content": "We implemented a script that takes a network, in this case the edge list of the SBG, and returns eq. (22) in OPB\nformat . This script was implement in Python 3.12.1, using the Networkx 3.1 library to compute the\nneighbourhood functions. The result was a PB formula consisting of 273 PB constraints.\nThen, we used RoundingSAT  to generate a certificate of unsatisfiability of the\nformula. The proof is 3884 lines long, and has a size of 359 KiB. It is available in our project repository, along with all\nother scripts and related files: github.com/latower/SBG-bounds. We then used VeriPB v2  to verify that all inferences made in the certificate of unsatisfiability are indeed"}, {"title": "7.3 Counting the number of solutions", "content": "In Section 4, we showed analytically that there exist at least 26 distinct identifying code sets (ICSes) with cardinality 10\nfor the soccer ball graph (SBG), proving that Theorem 2 holds. Using the PB formula FMICS>10(X), we can prove a\nstronger statement:\nTheorem 5 There exist exactly 26 distinct size-10 ICSes of the SBG.\nTo prove that Theorem 5 holds, we wrote a script that does the following. It takes F|MICS|\u226510(X) and uses\nRoundingSAT to find a solution $\\sigma : X \\rightarrow {0,1}$. Suppose that $X_1 \\subset X$ are all the variables that are mapped\nto 1 by $\\sigma$, and $X_0 \\subset X$ are all the variables that are mapped to 0 by $\\sigma$, such that $X_1 := {x \\in X | \\sigma(x) = 1}$,\n$X_0 := {x \\in X | \\sigma(x) = 0}$, X = X1 \u222a X0 and X1 \u2229 X0 = \u2205. Now, the script generates the following constraint:\n$C_{\\neg\\sigma} := \\sum_{x \\in X_1} (1 - x) + \\sum_{x \\in X_0} x \\geqslant 1,$\nwhich expresses that at least one variable x \u2208 X must take a different value than what it was assigned by solution $\\sigma$. We\ncall this constraint a blocking constraint for $\\sigma$, because it cannot be satisfied by $\\sigma$. This blocking constraint is rewritten\nto the following constraint, so it is in the right input format for our PB solver:\n$C_{\\neg\\sigma} := - \\sum_{x \\in X_1} x + \\sum_{x \\in X_0} x \\geqslant 1 - |X_1|.$\nThen, the script generates a new formula\n$F_{|MICS| \\geqslant 10}(X) := F_{|MICS| \\geqslant 10}(X) \\cup {C_{\\neg\\sigma}},$\nand uses RoundingSAT to find a solution \u03c3' : X \u2192 {0,1}, which is then turned into a blocking constraint, and added\nto the formula. This process continues until the PB formula becomes unsatisfiable.\nThe script then counts all the solutions, checks that they are all distinct, checks that each found solution is indeed a\nsolution to the original PB formula FMICS\u226510(X), and uses VeriPB v2 to verify that the refutation certificate of the final,\nunsatisfiable formula is correct. All scripts and results can be found in our repository: github.com/latower/SBG-bounds."}, {"title": "8 Conclusion", "content": "We have studied an event monitoring problem with satellites as sensors and a soccer ball as a model of the planet Earth.\nHere, each patch of the soccer ball models a region of the globe that can be monitored by one satellite for big events.\nThe assumption is that the effects of a big event taking place in one region, spills out to the adjacent regions. Hence,\nwe do not need to employ one satellite per region to monitor the entire earth for big events. The problem is to find a"}]}