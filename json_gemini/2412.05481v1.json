{"title": "A Compositional Atlas for Algebraic Circuits", "authors": ["Benjie Wang", "Guy Van den Broeck", "Denis Deratani Mau\u00e1", "Yoo Jung Choi"], "abstract": "Circuits based on sum-product structure have become a ubiquitous representation to compactly encode knowledge, from Boolean functions to probability distributions. By imposing constraints on the structure of such circuits, certain inference queries become tractable, such as model counting and most probable configuration. Recent works have explored analyzing probabilistic and causal inference queries as compositions of basic operators to derive tractability conditions. In this paper, we take an algebraic perspective for compositional inference, and show that a large class of queries\u2014including marginal MAP, probabilistic answer set programming inference, and causal backdoor adjustment\u2014correspond to a combination of basic operators over semirings: aggregation, product, and elementwise mapping. Using this framework, we uncover simple and general sufficient conditions for tractable composition of these operators, in terms of circuit properties (e.g., marginal determinism, compatibility) and conditions on the elementwise mappings. Applying our analysis, we derive novel tractability conditions for many such compositional queries. Our results unify tractability conditions for existing problems on circuits, while providing a blueprint for analysing novel compositional inference queries.", "sections": [{"title": "1 Introduction", "content": "Circuit-based representations, such as Boolean circuits, decision diagrams, and arithmetic circuits, are of central importance in many areas of AI and machine learning. For example, a primary means of performing inference in many models, from Bayesian networks [16, 9] to probabilistic programs [20, 24, 26, 43], is to convert them into equivalent circuits; this is commonly known as knowledge compilation. Inference via knowledge compilation has also been used for many applications in neuro-symbolic AI, such as constrained generation [2, 54] and neural logic programming [34, 28]. Circuits can also be learned as probabilistic generative models directly from data [25, 41, 40, 32], in which context they are known as probabilistic circuits [11]. Compared with neural generative models, probabilistic circuits enjoy tractable evaluation of inference queries such as marginal probabilities, which has been used for tasks such as fair machine learning [12] and causal reasoning [53, 50, 49].\nThe key feature of circuits is that they enable one to precisely characterize tractability conditions under which a given inference query can be computed exactly and efficiently, in terms of structural properties of the circuit. One can then enforce these circuit properties when compiling or learning a model to enable tractable inference. For many basic inference queries, such as computing a marginal probability, tractability conditions are well understood [48, 8]. However, for more complex queries,"}, {"title": "2 Preliminaries", "content": "Notation We use capital letters (e.g., X, Y) to denote variables and lowercase for assignments (values) of those variables (e.g., x, y). We use boldface to denote sets of variables/assignments (e.g., X, y) and write Assign(V) for the set of all assignments to V. Given a variable assignment v of V, and a subset of variables WC V, we write vw to denote the assignment of W corresponding to v.\nSemirings In this paper, we consider inference problems over commutative semirings. Semirings are sets closed w.r.t. operators of addition (\u2295) and multiplication (\u2297) that satisfy certain properties:\nDefinition 1 (Commutative Semiring). A commutative semiring S is a tuple (S, \u2295, \u2297, 0s, 1s), where \u2295 and \u2297 are associative and commutative binary operators on a set S (called the domain) such that \u2297 distributes over \u2295 (i.e., a \u2297 (b + c) = (a \u2297 b) + (a \u2297 c) for all a, b, c \u2208 S); 0s \u2208 S is the additive identity (i.e., 0s\u2295 a = a for all a \u2208 S) and annihilates S through multiplication (i.e., 0s \u2297 a = 0 for all a \u2208 S); and 1s \u2208 S is the multiplicative identity (i.e., 1s \u2297 a = a for all a \u2208 S)."}, {"title": "3 Compositional Inference: A Unifying Approach", "content": "Many inference problems can be written as compositions of basic operators, which take as input one or more functions and output another function. For example, the marginal MAP query on probability distributions maxx \u03a3y p(x, y) is a composition of the \u2211 and max operators. Similarly, for Boolean functions \u03c6, \u03c8, the query \u2211 \u2203y. (x, y) \u2227 \u03c8(x, y) composes the \u2211, \u2203 and \u2227 operators.\nProbabilistic circuits are sometimes written with weights on the edges; this can easily be translated to our formalism by replacing the child of a weighted edge with a product of itself and an input function with empty scope corrresponding to the weight [44, 42].", "subsections": [{"title": "3.1 Basic Operators", "content": "Aggregation Given a function f : Assign(V) \u2192 S, aggregating f over W \u2286 V returns the function f': Assign(Z) \u2192 S for Z = V \\ W defined by $f'(z) := \\bigoplus_w f(z, w)$.\nFor example, aggregation corresponds to forgetting variables W in the Boolean semiring, marginal-izing out W in the probability semiring, and maximizing over assignments in the (max, \u00b7) semiring. Next, some queries, such as divergence measures between probability distributions, take two functions as inputs, and many others involve combining two or more intermediate results, as is the case in probabilistic answer set programming inference and causal backdoor/frontdoor queries. We define the product operator to encapsulate such \u201ccombination\" of functions in general.\nProduct Given two functions f : Assign(W) \u2192 S and f' : Assign(W') \u2192 S, the product of f and f' is a function f\" : Assign(V) \u2192 S, where V=WUW', defined by f\"(v) := f(vw) \u2297 f'(vw').\nFor example, a product corresponds to the conjoin operator \u2227 in the Boolean semiring, and standard multiplication in the probability semiring. Lastly, we introduce the elementwise mapping operator, defined by a mapping \u03c4 from a semiring to a (possibly different) semiring. When applied to a function f, it returns the function composition \u03c4 \u25e6 f. This is the key piece that distinguishes our framework from prior analysis of sum-of-product queries over specific semirings, allowing us to express queries such as causal inference and probabilistic logic programming inference under the same framework.\nElementwise Mapping Given a function f : Assign(V) \u2192 S and a mapping \u03c4 : S \u2192 S' from semiring S to S' satisfying \u03c4(0s) = 0s', an elementwise mapping of f by \u03c4 results in a function f': Assign(V) \u2192 S' defined by f'(v) := \u03c4(f(v)).\u00b2\nIn practice, we use elementwise mappings as an abstraction predominantly for two purposes. The first is for switching between semirings, while the second is to map between elements of the same semiring. For the former, one of the most important elementwise mappings we will consider is the support mapping, which maps between any two semirings as follows.\nDefinition 6 (Support Mapping). Given a source semiring S and a target semiring S', the support mapping []ss' is defined as: $[a]_{S\\rightarrow S'} = 0_{S'}$ if a = 0s; $[a]_{S\\rightarrow S'} = 1_{S'}$ otherwise."}, {"title": "3.2 Tractability Conditions for Basic Operators", "content": "We now consider the tractability of applying each basic operation to circuits: that is, computing a circuit whose function corresponds to the result of applying the operation to the functions given by the input circuit(s). First, it is well known that forgetting and marginalization of any subset of variables can be performed in polynomial time if the input circuits in the respective semirings (NNF and PC) are smooth and decomposable [18, 11]. This can be generalized to arbitrary semirings:\nTheorem 1 (Tractable Aggregation). Let C be a smooth and decomposable circuit representing a function p: Assign(V) \u2192 S. Then for any W \u2286 V, it is possible to compute the aggregate as a smooth and decomposable circuit C' (i.e., $p_{C'}(Z) = \\bigoplus_w p_C(Z, w)$) in O(|C|) time and space.\nNext, let us consider the product operator. In the Boolean circuits literature, it is well known that the conjoin operator can be applied tractably if the circuits both follow a common structure known as a vtree [17]. In [48] a more general property known as compatibility was introduced that directly specifies conditions with respect to two (probabilistic) circuits, without reference to a vtree. We now define a generalization of this property (X-compatibility) and also identify a new condition (X-support-compatibility) that enables tractable products.\nDefinition 7 (X-Compatibility). Given two smooth and decomposable circuits C, C' over variables V,V' respectively, and a variable set X \u2286 V \u2229 V', we say that C, C' are X-compatible if for every product node a = a1 \u00d7 a2 \u2208 C and a' = a\u2081 \u00d7 a2 \u2208 C' such that vars(a)\u2229X = vars(a')\u2229X, the scope is partitioned in the same way, i.e. vars(a1) \u2229 X = vars(a\u2081) \u2229 X and vars(a2) \u2229 X = vars(2) \u2229 X. We say that C, C' are compatible if they are (V\u2229V')-compatible.\nIntuitively, compatibility states that the scopes of the circuits decompose in the same way at product nodes. Compatibility of two circuits suffices to be able to tractably compute their product:\nTheorem 2 (Tractable Product - Compatibility). Let C, C' be compatible circuits over variables V, V', respectively, and the same semiring. Then it is possible to compute their product as a circuit C compatible with them (i.e., $p_{C\"} (V\\cup V') = p_C(V) \\otimes p_{C'} (V')$) in O(|C||C'|) time and space.\nWe remark that if we are given a fully factorized function $f(V) = \\bigotimes_{v_i \\in V} f_i(V_i)$, this can be ar-ranged as a circuit (series of binary products) compatible with any other decomposable circuit; thus, we say this type of function is omni-compatible. We also say that a circuit is structured decompos-able if it is compatible with itself. Now, our more general definition of X-compatibility states that the scopes of the circuits restricted to X decompose in the same way at product nodes. This will be important when we consider composing products with other operators, such as aggregation. The following result shows that compatibility w.r.t. a subset is a weaker condition:\nProposition 1 (Properties of X-Compatibility). If two circuits C, C' are X-compatible, then they are X'-compatible for any subset X' \u2286 X."}, {"title": "3.3 Tractable Composition of Operators", "content": "We now analyze compositions of these basic operators. As such, we need to consider not only circuit properties that enable tractability, but how these properties are maintained through each operator, so that the output circuit can be used as input to another operator. We call these composability conditions. In all cases, the output circuit is smooth and decomposable. Thus, we focus on the properties of X-determinism, X-compatibility, and X-support-compatibility. We emphasize that these are not singular properties, but rather families of properties indexed by a variable set X. We present the intuitive ideas behind our results below, while deferring full proofs to the Appendix.\nTheorem 5 (Composability Conditions). The results in Table 1 hold.\nX-determinism Intuitively, X-determinism is maintained through products because the resulting sum nodes partition the X-support in a \"finer\" way to the original circuits, and through elementwise mappings since they do not expand the support of any node (since \u03c4(0s) = 0s'). For aggregation, the X-support is maintained if aggregation does not occur over any of the variables in X.\nX-compatibility Here, we are interested in the following question: if the input circuit(s) to some operator are X-compatible with some other circuit Cother for any fixed X, is the same true of the output of the operator? X-compatibility with Cother is maintained through aggregation because it weakens the condition (by Proposition 1) and through elementwise mapping as it does not change variable scopes. As for taking the product of circuits, the output circuit will maintain similar variable partitionings at products, such that it remains X-compatible with Cother. Notably, this result does not hold for compatibility where the scope X may be different for each pair of circuits under consideration; we show a counterexample in Example 4 in the Appendix."}]}, {"title": "4 Case Studies", "content": "In this section, we apply our compositional framework to analyze the tractability of several different problems involving circuits found in the literature (Table 2). Some of the results are known, but can now be cast in a general framework (with often simpler proofs). We also present new results, deriving tractability conditions that are less restrictive than reported in existing literature.\nTheorem 6 (Tractability of Compositional Queries). The results in Table 2 hold."}, {"title": "4.1 Algebraic Model Counting", "content": "In algebraic model counting [30] (a generalization of weighted model counting), one is given a Boolean function (V), and a fully-factorized labeling function w(V) = \u2297v\u1d62\u2208Vwi(Vi) in some semiring S, and the goal is to aggregate these labels for all satisfying assignments of \u03c6. This can be easily cast in our framework as $\\bigoplus_v([\\phi(v)]_{B\\rightarrow S} \\otimes w(v))$. Here, the support mapping [\u00b7]B\u2192S transfers the Boolean function to the semiring S over which aggregation occurs. Assuming that \u03c6(V) is given as a smooth and decomposable Boolean circuit (DNNF), then by Corollary 1 AMC is tractable if S is idempotent or if the circuit is additionally deterministic (note that w(V) is omni-compatible, so the product is tractable); this matches the results of [30]."}, {"title": "4.2 Causal Inference", "content": "In causal inference, one is often interested in computing interventional distributions, denoted using the do() operator, as a function of the observed distribution p. This function depends on the causal graph linking the variables, and can be derived using the do-calculus [38]. For example, the well-known backdoor and frontdoor graphs induce the following formulae:\n$p(y|do(x)) = \\sum_z p(z)p(y|x, z)$,\n$p(y|do(x)) = \\sum_z p(z_x) \\sum_{x'} p(x')p(y|x', z)$.\nAssuming that the observed joint distribution p(X, Y, Z) is given as a probabilistic circuit C, we consider the problem of obtaining a probabilistic circuit C' over variables X UY representing p(Y|do(X)). Tractability conditions for the backdoor/frontdoor cases were derived by [49], with quadratic/cubic complexity respectively. However, we observe that in some cases we can avoid the requirement of structured decomposability and/or obtain reduced complexity relative to their findings.\nIn the backdoor case, it is known that structured decomposability and (XUZ)-determinism suffices for a quadratic time algorithm. This can be seen by decomposing into a compositional query:\n$\\bigoplus_z \\bigg(\\bigoplus_{x,y}\\big( [\\phi(v)] & \\otimes \\delta_{p_V(v)}\\big)\\otimes\\delta_{T^{-1}(p(v))}\\bigg)$,where V = (X, Y, Z), and $T^{-1}(a) = \\begin{cases}a^{-1} & \\text{if } a \\neq 0\\\\0 & \\text{if } a = 0\\end{cases}$. Assuming (XUZ)-determinism and structured decomposability, then $T^{-1} (\\bigoplus_y p(V))$ is tractable by (Det) and (Multiplicative), the product $p(V) \\otimes T^{-1}(\\bigoplus_y p(V))$ by support-compatibility, and the final product by compatibility. However, if we additionally have Z-determinism, then the final product becomes tractable by support compatibility. This has linear rather than quadratic complexity, and does not require the circuit to be structured decomposable. In the frontdoor case, [49] showed that X-determinism, (X U Z)-determinism, and structured decomposability suffices for cubic complexity. However, we note that under such conditions, the inner product p(X') \u2297p(Y|X', Z) is tractable by support-compatibility. As such, the complexity of this query is actually quadratic rather than cubic as previously shown. We summarize our findings in Table 2 and refer the reader to the Appendix for full proofs."}, {"title": "5 Related Work", "content": "Our work builds upon the observation that many inference problems can be characterized as a com-position of basic operators. Prior works have considered compositional inference for circuits in the Boolean [18] and probabilistic semirings [48, 49], deriving tractability conditions for operators spe-cific to these semirings. Aside from generalizing to arbitrary semirings, we also introduce extended composability conditions that enable interleaving of aggregation, products, and mappings. Mean-while, algebraic model counting [30] deals (implicitly) with mappings from the Boolean semiring to an arbitrary semiring, but does not consider compositional queries. Closest to our work, [29] con-sider a generalization of algebraic model counting that allows for an additional semiring translation; however, this still assumes input Boolean circuits and has incomplete tractability characterizations. Our framework resolves these limitations, permitting arbitrary compositional queries over semirings.\nMany works have considered (unbounded) sums-of-products queries on arbitrary semirings [21, 5, 1, 23], encompassing many important problems such as constraint satisfaction problems [7], graphical model inference [56], and database queries [52], which are often computationally hard in the worst-case. Algorithms for such queries often utilize compact intermediate representations and/or assume compact input representations, such as circuits [35, 17, 36, 3]. Our framework focuses on queries where the number of operators is bounded, and characterizes conditions under which inference is tractable in polynomial time. It also includes elementwise mappings as a key additional abstraction that can be used to express queries involving more than sums and products."}, {"title": "6 Conclusion", "content": "In summary, we have introduced a framework for analysing compositional inference problems on circuits, based on algebraic structure. In doing so, we were able to derive new tractability conditions and simplified algorithms for a number of existing problems, including 2AMC and causal inference. Our framework focuses on simple and composable sufficient tractability conditions for aggregations, products and elementwise mappings operators; a limitation of this generality is these conditions may not be necessary for specific queries on specific semirings. Our work motivates the development of knowledge compilation and learning algorithms that target the requisite circuit properties, such as X-determinism. Finally, while we focus on exact inference, for many problems (e.g. marginal MAP) approximate algorithms exist and are of significant interest; an interesting direction for future work is to investigate if these can be also be generalized using the compositional approach."}]}