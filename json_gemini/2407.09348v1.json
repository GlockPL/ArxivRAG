{"title": "Predictable and Performant Reactive Synthesis Modulo Theories via Functional Synthesis", "authors": ["Andoni Rodr\u00edguez", "Felipe Gorostiaga", "C\u00e9sar S\u00e1nchez"], "abstract": "Reactive synthesis is the process of generating correct controllers from temporal logic specifications. Classical LTL reactive synthesis handles (propositional) LTL as a specification language. Boolean abstractions allow reducing LTLT specifications (i.e., LTL with propositions replaced by literals from a theory T), into equi-realizable LTL specifications. In this paper we extend these results into a full static synthesis procedure. The synthesized system receives from the environment valuations of variables from a rich theory T and outputs valuations of system variables from T. We use the abstraction method to synthesize a reactive Boolean controller from the LTL specification, and we combine it with functional synthesis to obtain a static controller for the original LTLT specification. We also show that our method allows adaptive responses in the sense that the controller can optimize its outputs in order to e.g., always provide the smallest safe values. This is the first full static synthesis method for LTLT, which is a deterministic program (hence predictable and efficient).", "sections": [{"title": "1 Introduction", "content": "Reactive synthesis for Linear Temporal Logic (LTL) specifications [31] has received extensive research attention [33]. A specification \u03c6 has its propositions split into those variables controlled by the system and the rest, controlled by the environment. A specification is realizable if there is a strategy for the system that produces valuations of the system variables such that all traces generated by the controller satisfy the specification. Realizability is the decision problem of whether such a strategy for the system exists. Synthesis is the process of generating one such winning strategy. Also, both problems are decidable for LTL [31].\nA recent extension of LTL called LTLT (LTL modulo theories) allows replacing propositions with literals from a first-order theory T. Given an LTLT specification \u03c6T an equi-realizable LTL \u03c6B formula can be generated, provided that the validity of T formulae of the form \u2203*\u2200* is decidable [35,37]. In LTLT synthesis the theory variables (for example Natural o Real) in the specification are split into environment-controlled and system-controlled variables, and both kinds can appear in any given literal, whereas in LTL an atomic proposition belongs exclusively to one player."}, {"title": "2 Preliminaries", "content": "First-order Theories. In this paper we use first-order theories. We describe theories with single domain for simplicity, but this can be easily extended to multiple sorts. A first-order theory T (see e.g., [7]) is described by a signature \u03a3, which consists of a finite set of functions and constants, a set of variables and a domain. The domain D of a theory T is the sort of its variables. For example, the domain of non-linear real arithmetic TR is R and we denote this by D(TR) = R or simply by D if it is clear from the context. A formula \u03c6 is valid in T if, for every interpretation I of T, then I \u22a8 \u03c6. A fragment of a theory T is a syntactically-restricted subset of formulae of T. Given a formula \u03c6, we use \u03c6[x\u2190 u] for the substitution of variables x by terms u (typically constants).\nReactive Synthesis. We fix a finite set of atomic propositions AP. Then, \u03a3 = 2AP is the alphabet of valuations, and \u03a3* and \u03a3\u03c9 are the set of finite and infinite traces respectively. Given a trace \u03c3 we use \u03c3(i) for the letter at position i and \u03c3i for the suffix trace that starts at position i. The syntax of propositional LTL [31,29] is:\n$\\varphi::=\\top\\mid a \\mid \\varphi \\vee \\varphi \\mid \\neg \\varphi \\mid O\\varphi \\mid \\varphi U \\varphi$\nwhere a \u2208 AP; \u2228, \u2227 and \u00ac are the usual Boolean disjunction, conjunction and negation; and O and U are the next and until temporal operators. The semantics of LTL associates traces \u03c3\u2208 \u03a3\u03c9 with LTL fomulae as follows:\n$\\begin{array}{ll}\\sigma \\vDash \\top & \\text { always holds } \\\\ \\sigma \\vDash a & \\text { iff } a \\in \\sigma(0) \\\\ \\sigma \\vDash \\varphi_{1} \\vee \\varphi_{2} & \\text { iff } \\sigma \\vDash \\varphi_{1} \\text { or } \\sigma \\vDash \\varphi_{2} \\\\ \\sigma \\vDash \\neg \\varphi & \\text { iff } \\sigma \\not\\vDash \\varphi \\\\ \\sigma \\vDash O \\varphi & \\text { iff } \\sigma^{1} \\vDash \\varphi \\\\ \\sigma \\vDash \\varphi_{1} U \\varphi_{2} & \\text { iff for some } i \\geq 0 \\sigma^{i} \\vDash \\varphi_{2}, \\text { and for all } 0<j<i, \\sigma^{j} \\vDash \\varphi_{1}\\end{array}$\nWe use common derived operators like \u2227, R, and \u2192. Reactive synthesis [33,32,5,17] is the problem of automatically constructing a system based on an LTL specification \u03c6, where the atomic propositions of \u03c6 (AP) are divided into propositions e = Varsee(\u03c6) controlled by the environment and s = Varss(\u03c6) con- trolled by the system (with e \u2229 s = AP and e \u2229 s = \u2205). A reactive specification corresponds to a turn-based game where the environment and system players alternate. In each turn, the environment produces values for e, and the system responds with values for s. A valuation is a map from e into B (similarly for s). We use val(e) and val(s) for valuations. A play is an infinite sequence of turns and"}, {"title": "3 Static Reactive Synthesis Modulo Theories", "content": "The Boolean abstraction method [35] reduces an LTLT formula \u03c6T into an equi- realizable LTL specification \u03c6B, but it does not present a synthesis procedure for \u03c6T. We solve this problem here by providing a full static synthesis method for LTLT. Our procedure builds a controller for realizable \u03c6T specifications that handles inputs and outputs from a rich domain D(T), using as a building block the synthetized Boolean controller for \u03c6B and other two sub-components.\n3.1 Formal Architecture\nWe call our approach static LTL synthesis (see Fig. 1). Our method starts from \u03c6T(x,y) and statically generates a Boolean controller \u03c1 for \u03c6B and combines it with a partitioner and a provider (generated from the abstraction process of \u03c6T to \u03c6B) handle the inputs and outputs from D. At run-time, at each instant the resulting controller follows these steps:\n(1) a valuation vx \u2208 val(x) is provided by the environment;\n(2) the partitioner discretizes vx generating a Boolean valuation ve \u2208 val(e) of input variables for \u03c1B.\n(3) \u03c1 responds with a valuation vs \u2208 val(s) of the variables s that \u03c1 controls.\n(4) the provider produces a valuation vy \u2208 val(y) of the output variables that together with vx guarantee that the literals from \u03c6T will be evaluated as indicated by the choice c that corresponds to s indicated by \u03c1. This step corresponds to finding a model of \u2203y.fc([x \u2190 vx], y).\nFor step (4) one approach is to invoke an SMT solver on the fly to generate mod- els (proper values of y), which is guaranteed to be satisfiable (by the soundness of the Boolean abstraction method). However, most uses of controllers cannot use SMT solvers dynamically. Moreover, note that the formula to be solved has\n$\\exists {*}\\forall{*}$ which is currently challenging for state-of-the art SMT solving technology for many theories. In this paper we present an alter- native: a method that produces a totally static controller, using Skolem functions associated to each (e, c) pair. These Skolem functions are models of the formula\n$\\forall x \\exists y . f_{r}(x) \\rightarrow f_{c}(x, y)$\nRecall that fr(x) is the formula that characterizes the environment valuations for which r captures the possible responses after receiving x, according to reasoning in the theory T.\nPartitioner. At each timestep, the partitioner receives a valuation vx \u2208 val(x) of the environment variables and finds the input variable ek to be fed to the Boolean controller. The partitioner must find the entry (e, r) in the table of valid reactions for which fr(x) is valid and return e. For instance, recall partitions eo and e1 from Ex. 1, then an input trace ((x : 4), (x : 4), (x : 1), (x : 0), (x : 2), ...) will be partitioned into ((e : e1), (e : e1), (e : eo), (e : eo), (e : e1),...) (for simplicity, here we show the only Boolean variable ei that is true). The following defines a legal partitioner.\nDefinition 1. Let \u03c6T(x,y) be an LTLT specification and (e,s) its Boolean abstraction. A partitioner is a function \u03b1 : val(x) \u2192 e such that if (e,r) is a valid reaction and fr[x \u2190 vx] is valid, then \u03b1(vx) = e.\nProvider. The discrete behavior of the Boolean controller requires an additional component that produces a valuation vy \u2208 val(y) of the system variables over y satisfying \u03c6T. The provider receives the choice s and the input vx \u2208 val(x), and substitutes vx for x in fc: fc([x \u2190 vx], y). The goal of the provider is to find a proper valuation for y.\nDefinition 2 (Provider). A provider is a function \u03b2 : val(x) \u00d7 val(s) \u2192 val(y) such that for every vx \u2208 val(x) and choice c\u2208 val(s), the following holds\n$f_{c}(x \\leftarrow v_{x}, y \\leftarrow \\beta(v_{x}, c))$.\nWe will show below that if vx is an input to a partitioner, r is the valid corre- sponding reaction, and c is one of the winning choices of the controller (that is, c\u2208r), then the following formula is valid.\n[\u2203y.fc(y, x\u2190 vx)]\nThis formula can be discharged into a solver with capabilities to produce a model vy (e.g., an SMT solver like Z3 [13]), which is exactly the dynamic approach presented at [36].\nCorrectness. The Boolean system strategy \u03c1 : \u27e8Q, qo, \u03b4, \u03bf\u27e9 for \u03c6B produces, at every timestep, a valuation of s from a valuation of e. We now define a strategy \u03c1T of the system in \u03c6T and prove that all moves played according to \u03c1T are winning for the system; i.e., all produced traces satisfy \u03c6T. Intuitively, \u03c1T composes the partitioner, which translates inputs to the Boolean controller, collects the move chosen by the Boolean controller and then uses the provider to generate an output.\nDefinition 3 (Combined Strategy). Given a partitioner \u03b1, a controller \u03c1B for \u03c6B and a provider \u03b2, the strategy \u03c1T : \u27e8Q', q0, \u03b4', \u03bf'\u27e9 for \u03c6T is:"}, {"title": "3.2 Standalone Synthesis Modulo Theories", "content": "Static Provider. As stated above, a provider produces, at every step, a model of a (satisfiable) formula (where some of the elements in the formula are the inputs received at that specific step). This can be implemented using an SMT solver at every step. In this paper we propose an alternative approach where we produce at static time a provider via the functional synthesis of a Skolem function. The controller then invokes the function produced instead of using dynamic queries to an SMT solver. Given an arbitrary relation R(x,y) a Skolem function is a function h that witnesses the validity of \u2200x.\u2203y.R(x,y) by guaranteeing that \u2200x..R(x, h(x)) is valid. Recall that a correct provider is a function \u03b2 : val(x) \u00d7 val(s) \u2192 val(y) which is a witness of the validity of the following formula:\n$\\forall x \\exists y . f_{r}(x) \\rightarrow f_{c}(x, y)$\nfor a given reaction r and choice c\u2208r. A Skolem function for c is a function hc : val(x) \u2192 val(y) such that the following is valid:\n$\\forall x . f_{r}(x) \\rightarrow f_{c}(x, h_{c}(x))$\nFor instance, consider a specification where the environment controls an integer variable x and the system controls an integer variable y in the specification \u03c6T = \u25a1(y > x). A Skolem function h(x) = x + 1 serves as a witness (providing values for y) of the validity of \u2200x.\u2203y.(T \u2192 (y > x)) and can be used to provide correct integer values for y. For many theories, Skolem functions for \u03b2 can be"}, {"title": "4 Adaptive Synthesis Modulo Theories", "content": "4.1 Enhancing Controllers\nThe static partitioner presented in the previous section always generates the same output, for a given choice (valuation of literals) and input. However, it is often possible that many different values can be chosen to satisfy the same choice. From the point of view of the Boolean controller, any value is indistinguishable, but from the point of view of the real-world controller the difference may be significant. For example, in the theory of linear natural arithmetic T = TN, given x = 3 and the literal (y > x), a Skolem function h(x) = x + 1 would generate y = 4, but y = 5 or y = 6 are also admissible. We call adaptivity to the ability of a controller to produce different values depending on external criteria, while still guaranteeing the correctness of the controller (in the sense that values chosen guarantee the specification). We introduce in this section a static adaptive provider that exploits this observation. Recall that the Skolem functions in Sec. 3 are synthetised as follows.\nDefinition 4 (Basic Provider Formula). A basic provider formula is a for- mula of the form \u2200x.\u2203y.\u03c8(x,y), where \u03c8 = frk(x) \u2192 fc(x,y) is the characteristic formula for reaction rk and choice c.\nWe now introduce additional constraints to \u03c8 that in the case that the resulting formulae are valid allow generating functions that guarantee further properties. Given a formula \u03c8(x, y) and a set of variables z (different than x and y) adaptive formulae also enforce an additional constraint \u03c8+.\nDefinition 5 (Adaptive Provider Formula). Let \u03c8(x,y) be the character- istic formula for a given reaction rk and choice c. An adaptive constraint is a formula \u03c8+(x,z,y) whose only free variables are x, y and z. An adaptive provider formula is of the form\n$\\forall x, z . \\exists y . [\\psi(x, y) \\wedge \\psi^{+}(x, z, y)]$,\nwhere \u03c8+ is an adaptive constraint."}, {"title": "5 Empirical Evaluation", "content": "We now report on empirical evaluation to asses the performance of our approach. We used Python 3.8.8 for the implementation of the architecture and Z3 4.12.2 for the SMT queries. We use Strix [30] as the synthesis engine and aigsim.c to execute the synthetised controller. For functional synthesis we used the AEval solver [16]5 that leverages Z3. Currently, AEval expects formulae in linear arith- metic with the \u2200*\u2203* shape, which is suitable for the static provider we want to synthesise. We translate the Skolem functions into C++ and used g++ 14.0.0 as a compiler. We ran all experiments on a MacBook Air 12.4 with the M1 processor and 16 GB. of memory.\nWrap-up experiment. We first report our results on T-controller for Ex. 1. Following the idea of Ex. 2, we execute the input trace \u03c0 = ((x|x \u2265 2), (x|x \u2265 2), (x|x < 2), (x|x < 2), \u27e8x|x \u2265 2\u27e9) 100000 times on (1) a dynamic provider following [36] and (2) our static provider approach. Throughout both experi- ments, the average time for the partitioner was 28 ms6 and the average time for the Boolean controller execution was 2.47 \u03bcs. However, the average time for the dynamic provider was 169 \u03bcs, whereas the static provider was about 50 times faster: 2.9 \u03bcs. We show in Fig. 3 the time needed (in \u03bcs) of the dynamic provider and the static provider in the first 50 events. We can see that (1) the times re- quired in the dynamic approach are more unstable and that (2) the dynamic approach is two orders of magnitude faster. Fig. 5 and Fig. 4 zoom over Fig. 3."}, {"title": "6 Related Work and Conclusions", "content": "Related Work. LTL modulo theories has been previously studied (e.g., [23,14]), but allowing temporal operators within predicates, again leading to undecidabil- ity. Also, infinite-state synthesis has been recently studied at [8,15,19,39,3,24] but with similar restrictions. At [26,27] authors perform reactive synthesis based on a fixpoint of \u2200*\u2203* formulae (for which they use AEval), but expressivity is limited to safety and does not guarantee termination. The work in [41] also relies on ab- straction but needs guidance and again expressivity is limited. Reactive synthesis of Temporal Stream Logic (TSL) modulo theories [18] is studied in [9,28], which extends LTL with complex data that can be related accross time. Again, note that general synthesis is undecidable by relating values across time. Moreover, TSL is already undecidable for safety, the theory of equality and Presburger arithmetic. Thus, all the specifications considered for empirical evaluation in Sec. 5 are not within the considered decidable fragments.\nAll approaches above adapt one specific technique and implement it in a monolithic way, whereas [35,37] generates LTL specification that existing tools can process with any of their internal algorithms (bounded synthesis, for exam- ple) so we will automatically benefit from further optimizations in these tech- niques. Moreover, Boolean abstraction preserves the temporal fragments like safety and GR(1) so specialized solvers can be used. Throughout the paper, we have already extensively compared the work [36] with ours and we showed that our approach uses Skolem functions instead of SMT queries on-the-fly, which makes it faster, more predictable and a pure controller that can be used in embedded contexts. It is worth noting that [36] and our approach can be under- stood as computing minterms to produce Symbolic automata and transducers [11,12] from reactive specifications (and using antichain-based optimization, as suggested by [40]). Also, note that any advance in abstraction method (e.g., [4]) has an immediate positive impact in our work.\nLast, [25] presents a similar idea to our Skolem function synthesis: instead of solving a quantified formula every time one wants to compute an output, they synthesize a term that computes the output from the input. However, the paper is framed in the program synthesis problem and uses syntax-guided synthesis [2], whereas previous reactive synthesis papers have suggested functional synthesis as a recommended software engineering practise (e.g., [38]).\nConclusion. The main contribution of this paper is the synthesis procedure for LTLT, using internally a Boolean controller and static Skolem function synthe- sis, which is more performant and predictable than previous approaches. Our method also allows producing adaptive responses that optimize the behaviour of the controller with respect to different criteria. We showed empirically that our approach is fast for many targeted applications and analyzed the cost and predictability of our Skolem functions component compared to [36]. As far as we know, this is the first decidable full reactive synthesis approach (with or with adaptivity) for LTLT specifications.\nFuture work includes first to use winning regions instead of concrete con- trollers to allow even more choices for the Skolem functions, and to develop a further adaptivity theory. Another direction is studying adaptivity over the en- vironment inputs and combining this approach with monitoring. Also, we plan to study how to extend LTL with transfer of data accross time preserving de- cidability, since recent results [22] suggest that the expressivity can be extended with limited transfers in semantic fragments of LTLT. Moreover, explaining our synthesis approach within more general frameworks like (e.g., [21]) is immediate work to do. Finally, we want to study how to use our approach to construct more predictable and performant shields [1,6] (concretely, shields modulo theo- ries [34,10]) to enforce safety in critical systems."}, {"title": "A Complete running example", "content": "In \u03c6T of Ex. 1 a valid (positional) strategy of the system is to always play y: 2. In this appendix we show that a controller synthetised using our technique will, precisely, respond in this manner infinitely many often. To do so, we rely on the trace of Ex. 2 and Skolem functions of Ex. 3.\nFirst, we Booleanize \u03c6T using [35] and get \u03c6B (also, recall from Ex. 1 that we use the notation ci to indicate choice i; e.g., C0 = {s0, s1,s2}, C1 = {s0, s1}, ... C6 = {s2}, C7 = \u2205.). Then, we get a controller CB from \u03c6B. We note that many strategies satisfy \u03c6B, but CB by Strix is as follows: CB(e1) = c4 and CB(eo) = c1. Also, note that this particular strategy is memoryless, but there are diverse strategies that use memory. We now show how the static T-controller computes Skolem functions on demand.\nStep 1: Environment forces instant response. Let x 4, which holds (x > 2) and forces constraint \u25a1(y \u2264 x). We are in partition e1, which implies choices {c4, c5, c6}. Now, CB(e1) = c4, so the T-controller looks whether the pair (e1, c4) appeared before. Since it did not, it computes h(e1,c4) (see left-hand function at Ex. 3). Thus, h(e1,c4) (2) = 2 is the output vy in the first timestep. Note that a T-controller with a different underlying CB could also consider c6 in the current play.\nStep 2: Environment repeats the strategy. Again, x: 4 and again we are in partition e1. Now, CB(e1) = c4, so the T-controller looks whether the pair (e1, c4) appeared before. Since it does, it just calls pre-computed h(e1,c4). Thus, h(e1,c4) (2) = 2 is the output vy in the second timestep.\nStep 3: Environment changes its mind. Let x : 1, which holds (x < 2) and forces constraint \u25cb(y > 1), whereas no constraint is further for the current timestep. We are in partition eo, which implies choices {c1,c2}. Now, CB(eo) = c1, so the T-controller looks whether the pair (eo, c1) appeared before. Since it did not, it computes h(eo,c1) (see right-hand function at Ex. 3). Thus, h(eo,c1) (2) = 2 is the output vy in the third timestep. Note that a T-controller with a different underlying CB could also consider c2 in the current play.\nStep 4: Environment prepares its trap. Let x: 0, which holds (x < 2) and forces constraint \u25cb(y > 1), and take into account that the system has constraint (y > 1) forced by the previous timestep. We are again in partition eo, which implies, again, choices {c1, c2}. Now, CB(eo) = c1, so the T-controller looks whether the pair (eo, c1) appeared before. Since it does, it just calls pre- computed h(eo,c1). Thus, h(eo,c1)(2) = 2 is the output vy in the fourth timestep. Note that this time there is no correct CB that could also consider c2 in the current play."}, {"title": "B More About Adaptivity", "content": "We outline several immediate consequences of using adaptivity of Sec. 4.\nAcross-time Adaptivity. In the previous section we showed that if we can synthesize Skolem functions for adaptive provider formulae, then the system obtained is still a good system for the \u03c6T. We show now that the additional arguments can be used to produce better controllers for \u03c6T. For instance, Z (thus, vz in Fig. 2) can be used to feed past values to the controller, and \u03c8+ can describe desired evolution of the output in terms of the past history.\nDefinition 8 (Across-time adaptive controller). Let \u03c6T (x,y) be a speci- fication, let \u0393 be an adaptive provider description, and let \u03c1\u0393 be the resulting controller. Then, we say that \u03c1\u0393 is an across-time adaptive controller if the extra variables z in \u0393 fed are past values of x and y.\nExample 6. Consider again the characteristic formula \u03c8 = (y > x), and the cor- responding basic provider formula \u2200x.\u2203y.\u03c8, which is valid in Tz. The constraint \u03c8+ = (y > z) makes the adaptive provider formula \u03c6 = \u2200x, z.\u2203y.(\u03c8\u2227\u03c8+) valid. A Skolem function h(x, z) guarantess that the output y generated is greater than the values of both x and z. Then, if the controller received z as the value of y in the previous timestep (denoted y\u2032), then we have that the controller will generate outputs that are monotonically increasing.\nNote that time adaptivity is not always possible. For example, using the constraint \u03c8+ = (y < z) (which would force the output to be monotonically decreasing) would turn the resulting adaptive provider formula invalid, so a controller cannot be produced.\nThe practical implication of Def. 8 is that we can now produce controllers that in practice satisfy constraints that were not expressible in LTL before, because the transfer of values across time quickly leads to undecidability of the realizability problem. Note that the Booleanization process in Sec. 3 only considers LTL specifications where literals do not relate variables from different time instants (also called non-cross state fragment in [22]). Note that across-time"}]}