{"title": "Compilation and Fast Model Counting beyond CNF", "authors": ["Alexis de Colnet", "Stefan Szeider", "Tianwei Zhang"], "abstract": "Circuits in deterministic decomposable negation normal form (d-DNNF) are representations of Boolean functions that enable linear-time model counting. This paper strengthens our theoretical knowledge of what classes of functions can be efficiently transformed, or compiled, into d-DNNF. Our main contribution is the fixed-parameter tractable (FPT) compilation of conjunctions of specific constraints parameterized by incidence treewidth. This subsumes the known result for CNF. The constraints in question are all functions representable by constant-width ordered binary decision diagrams (OBDDs) for all variable orderings. For instance, this includes parity constraints and cardinality constraints with constant threshold. The running time of the FPT compilation is singly exponential in the incidence treewidth but hides large constants in the exponent. To balance that, we give a more efficient FPT algorithm for model counting that applies to a sub-family of the constraints and does not require compilation.", "sections": [{"title": "Introduction", "content": "Knowledge compilation is a domain of computer sciences that studies the different ways to represent functions. Classes of representations, or languages, have been invented where specific problems become tractable. In particular, many Boolean languages have been created that support polynomial-time model counting, that is, determining the number of truth assignments on which a function $f : {0,1}^n \\rightarrow {0,1}$ evaluates to 1. In practice, several model counters for CNF formulas are transforming, or compiling, their inputs into the language d-DNNF of circuits in deterministic decomposable negation normal form, where model counting is feasible in linear time (in the size of the circuits). For instance, C2D [Dar04], DSharp [MMBH12], miniC2D [OD15], and D4 [LM17] all compile CNF formulas into (sublanguages) of d-DNNF. Other model counters do not explicitly compile the CNF but can be seen as compilers in disguise [KE23].\nCompilation to d-DNNF is often hard in the sense that the d-DNNF circuit representations of many functions provably have exponential size, even for functions that belong to fragments where model counting is tractable such as systems of Boolean linear equations [dCM23]. On a more positive note, compiling from CNF to d-DNNF is fixed-parameter tractable (FPT) when the parameter is the treewidth of the CNF's primal graph [HD07] and when it is the treewidth of its incidence graph [BCMS15]. To further understand when the input is easy to compile, one possibility is to find new CNF parameters that dominate treewidth and yet enable FPT compilation to d-DNNF, for instance, decision-width [OD14b], CV-width [OD14a] and PS-width [BCMS15]. Another direction is to part from the CNF input and study the parameterized compilability of functions given in a different format such as DNF or a general Boolean circuit [ACMS20]. In this paper, we follow the latter direction: we investigate the FPT compilation of systems (i.e., conjunctions) of Boolean constraints that are not just CNF. We see each CNF formula as a system of disjunctive clauses and identify other types of constraints that can be added to the system while ensuring an FPT compilation to d-DNNF parameterized by its incidence treewidth k. While compiling general systems of constraints to d-DNNF cannot be FPT parameterized k unless FPT = W[1] (since even satisfiability is W[1]-hard"}, {"title": "Preliminaries", "content": "A Boolean variable $x$ takes a value in {0,1}. Literals are denoted by $x$ and $\\overline{x}$. An assignment to a set $X$ of Boolean variables is a mapping from $X$ to {0,1}, and a Boolean function $f$ over $X$ maps the assignments to $X$ to {0, 1}. For us, constraints are just Boolean functions that appear in systems (conjunctions of constraints). CNF formulas are systems of constraints whose constraints are clauses (disjunctions of literals). We write $|F|$ for the number of constraints in the system $F$. Boolean circuits are another way to represent functions. The size of a circuit $D$, denoted $|D|$, is its number of gates and connectors. We denote by $gates(D)$ the set of gates of $D$. For $g \\in gates(D)$, $D_g$ is the subcircuit of $D$ whose output gate is $g$. We write $f(X)$, $D(X)$, and $F(X)$ to indicate that the variable set of a function, circuit, or system is $X$, respectively. If this set is not explicit, we use $var(f)$, $var(D)$, $var(F)$.\nTreewidth and Tree Decompositions\nA tree decomposition $T$ of a graph $G$ is a pair $(T,b)$ with $T$ a tree and $b : V(T) \\rightarrow P(V(G))$ a bag function such that (1) $\\bigcup_{t \\in V(T)} b(t) = V(G)$, (2) for all $uv \\in E(G)$, there is $t \\in T$ such that ${u, v} \\subseteq b(t)$, and (3) for all $v\\in V(G)$, $T[t | v \\in b(t)]$ is connected. The width of $T$ is $max_{t\\in T} |b(t)|$. The treewidth of $G$ is $tw(G) := min_T max_{t\\in T} |b(t)| \u2013 1$ where $T$ ranges over all tree decompositions of $G$. A tree decomposition is nice when it is rooted and when each node $t \\in V(T)$ is of one of the following three types: a join node, an introduce node, or a forget node. $t$ is a join node if it has two children $t_1$ and $t_2$ and $b(t) = b(t_1) = b(t_2)$. $t$ is an introduce node for $v \\in V(G)$ if it has a single child $t'$"}, {"title": "OBDDs and SDNNF Circuits", "content": "(d-)SDNNF Circuits. A variable tree (vtree) $\\tau$ over a set $X$ of variables is a rooted binary tree whose leaves are in bijection with $X$. For every $t \\in V(\\tau)$, $var(t)$ is the set of variables on the leaves below $t$. A circuit $D$ in structured-decomposable negation normal form (SDNNF) [PD08] is a Boolean circuit with literal inputs, whose gates are binary $\\lor$-gates and binary $\\land$-gates, and such that there exist a vtree $\\tau$ over $var(D)$ and a mapping $\\lambda : gates(D) \\rightarrow V(\\tau)$ verifying the following:\n*   For every $g\\in gates(D)$, $var(D_g) \\subseteq var(\\lambda(g))$.\n*   For every $\\lor$-gate $g = g_1 \\lor g_2$, $\\lambda(g) = \\lambda(g_1) = \\lambda(g_2)$.\n*   For every $\\land$-gate $g = g_1\\land g_2$, $\\lambda(g)$ has two children $t_1$ and $t_2$ and $\\lambda(g_1)$ is below $t_1$ and $\\lambda(g_2)$ is below $t_2$.\nWe say that $D$ is structured by $(\\tau, \\lambda)$ and sometimes omit $\\lambda$. An example of an SDNNF circuit is shown in Figure 3b with the mapping $\\lambda$ given by the color code. An SDNNF circuit $D$ is deterministic (d-SDNNF) when for all $\\lor$-gates $g = g_1 \\lor g_2$, we have $D_{g_1}^{-1}(1) \\cap D_{g_2}^{-1} = \\emptyset$. Counting the models of $D$, i.e., finding $|D^{-1}(1)|$, is tractable when $D$ is a d-SDNNF circuit.\nOBDDs. A binary decision diagram (BDD) is a directed acyclic graph with a single source, two sinks labeled 0 and 1, whose internal nodes are decision nodes with two distinct children and labeled by variables. A node $v$ labeled by variable $x$ and with children $v_0$ and $v_1$ is recursively interpreted as a Boolean function $v = (x \\rightarrow v_0) \\lor (\\overline{x} \\land v_1)$. Every assignment $\\alpha$ corresponds to a path in the DAG. Starting from the root, assuming $\\alpha$'s path reaches $v$ follows $v_0$ if $\\alpha(x) = 0$ and $v_1$ otherwise. The assignments satisfying the BDD are exactly those whose paths reach the sink 1. For a total order $\\pi$ on the variables, a $\\pi$-Ordered BDD ($\\pi$-OBDD) is a BDD whose variables appear at most once along every path from the root to a sink and always in an order consistent with $\\pi$. A $\\pi$-OBDD is complete if every path contains all the variables. d-SDNNF circuits generalize OBDDs in the sense that there is a simple linear-time rewriting that transforms OBDDs into d-SDNNF circuits structured by linear vtrees (i.e., vtrees whose internal nodes all have a leaf child).\nWidth measures. The width of an OBDD is the maximum number of nodes labeled by the same variable. Note that making an OBDD complete, while feasible in linear time, can also increase the width by a linear factor [BW00]. The width of an SDNNF circuit structured by $(\\tau, \\lambda)$ is defined as $max_{t\\in V(\\tau)} |\\lambda^{-1}(t)|$. This definition differs from that of [CM19] but is more convenient for stating our results."}, {"title": "Slim Functions and STS", "content": "In this paper, constraints are global constraints [vHK06]. So we know the type (e.g., clauses, parity constraints, cardinality constraints) of every constraint we manipulate.\nCNF formulas are known to be FPT compilable to d-SDNNF parameterized by their incidence treewidth."}, {"title": "Slim Functions for Complete OBDDs and SDNNFs", "content": "One can consider a complete OBDD is as state diagram where the values of the variables are read in a predefined order. The width of the complete OBDD is then the maximum number of states reachable after having set any number of variables in that order. The property we want for our constraints translates into the requirement that the smallest possible width in one of their $\\pi$-OBDD representations is bounded for all the variable orders $\\pi$. In the following, $h : \\mathbb{N}\\rightarrow\\mathbb{R}$ is a real function.\nDefinition 1. A class $F$ of Boolean functions is $h$-slim for complete OBDDs when, for every $n$-variables function $f\\in F$ and every total order $\\pi$ of $var(f)$, there is a complete $\\pi$-OBDD of width at most $h(n)$ computing $f$.\nThe notions of $O(1)$-slim functions, $O(n)$-slim functions, etc. should be self-explanatory. Given a fixed constant $w$, we talk of $w$-slim functions when $h$ is the constant $w$ function. When $h$ is an unknown polynomial, the $h$-slim functions for complete OBDDs coincide with the nice functions from Wegener's book [Weg00, Section 5.3]. Our proofs below rely on SDNNF representations rather than OBDD representations. The concept of $h$-slim functions generalizes to SDNNF.\nDefinition 2. A class $F$ of Boolean functions is $h$-slim for complete SDNNFs when, for every $n$-variables function $f \\in F$ and vtree $\\tau$ over $var(f)$, there is a complete SDNNF of width at most $h(n)$ and with vtree $\\tau$ that computes $f$.\nGiven the rewriting of complete OBDDs into complete d-SDNNFs, it is immediate that having a small OBDD-width for every variable ordering implies having a small SDNNF-width for every linear vtree. However, generalizing to all possible vtrees is not straightforward.\nLemma 1. If a class $F$ of function is $h$-slim for complete OBDDs, then it is $O(h^3)$-slim for complete SDNNFs.\nProof. Let $f \\in F$. Let$\\tau$ be a vtree over $X = {x_1,...,x_n}$ and suppose the left-to-right ordering of $\\tau$'s leaves is the natural ordering $\\pi$: $x_1 \\prec ... \\prec x_n$. We show how to construct an SDNNF circuit respecting $\\tau$ and computing $f$. For every $1 < i < j \\leq n$ we define the $[i, j]$-slice of $X$, denoted by $X[i,j]$, as ${x_i, x_{i+1},...,x_j}$. By definition of $\\pi$, for every $t \\in V(\\tau) \\setminus leaves(\\tau)$, the vtree $\\tau_t$ rooted under $t$ in $\\tau$ is a vtree over a slice $X[i_t,j_t]$. We define $S \\subseteq V(\\tau)$ as the set of nodes $t$ such that $\\tau_t$ is right-linear and such that, if $t$ has a parent $t'$, then $t \\rightarrow t'$ is not linear. The set of slices $X[i_t,j_t]$ for all $t \\in S$ forms a partition of $X$.\nThe construction uses a $\\pi$-OBDD $B$ representing $f$. The levels of $B$ are numbered top-down: level 1 corresponds to the decision nodes for $x_1$ (so only the root of $B$), level $n$ corresponds to the decision nodes for $x_n$, and level $n + 1$ comprises the two sinks of $B$. Let $w_i$ be the number of nodes at level $i$ of $B$ and introduce a symbol for each of these nodes: $s_1^i,...,s_{w_i}^i$. Note $w := max_{i\\in[n]} w_i$.\nWe also define $w_{n+1} = 1$ and keep the symbols 0 for $s_{w_{n+1}}^{n+1}$ and 1 for $s_{w_{n+1}}^{n+1}$. For every $1 < i < j \\leq n$, we define the $[i, j]$-slice of $B$, denoted by $B[i,j]$, as the function from ${0,1}^{X[i,j]}$ to ${s_{1}^{j+1},..., s_{w_{j+1}}^{j+1}}$ obtained by taking all levels of $B$ from the $i$th to the $(j + 1)$th level and by replacing every node at the"}, {"title": "Commutative State Transitions Systems", "content": "Definition 3. A state transition system (STS) $A = (S, f_0, f_1, T)$ consists of a set of states $S$, two transition functions $f_0, f_1: S \\rightarrow S$, a starting state $s_0 \\in S$ and a set of accepting states $T \\subseteq S$. The associated extended transition function $\\delta_A : {0,1}^* \\rightarrow S$ is defined as:\n$\\delta_A(\\epsilon) := s_0, \\delta_A(i\\ell) := f_0(\\delta_A(\\ell)), \\delta_A(1\\ell) := f_1(\\delta_A(\\ell))$.\nWhen the associated STS is clear from context, we also omit the subscript when writing the extended transition function. An STS is finite if the set of states $S$ is finite, and commutative if $f_0(f_1(s)) = f_1(f_0(s))$ for all $s \\in S$. We write CSTS for commutative STS.\nLemma 4. Let $A = (S, f_0, f_1,T)$ be an STS. Then for any $\\ell_1, \\ell_1', \\ell_2, \\ell_2' \\in {0,1}^*$, if $\\delta(\\ell_1) = \\delta(\\ell_1')$ and $\\delta(\\ell_2) = \\delta(\\ell_2')$, then $\\delta(\\ell_1\\ell_2) = \\delta(\\ell_1'\\ell_2')$.\nProof.\n$\\delta(\\ell_1\\ell_2) = \\delta(\\ell_1\\ell_2') = \\delta(\\ell_2'\\ell_1) = \\delta(\\ell_2'\\ell_1') = \\delta(\\ell_1'\\ell_2')$.\nDefinition 4. Given a function $f : {0,1}^n \\rightarrow {0, 1}$, we say an STS describes $f$ if, for every $\\ell \\in {0,1}^n$, $\\delta(\\ell) \\in T$ if and only if $f(\\ell) = 1$. Let $f,g: {0,1} \\rightarrow {0,1}$ be two functions. We say that a CSTS describes $f$ modulo literal-flipping if it describes $g$ and there exists a literal-flipping function $\\phi$ that sends $x_i$ to either $x_i$ or $\\overline{x_i}$ such that $f = g\\circ\\phi$. We call the minimum number of states of a CSTS that describes $f$ modulo literal-flipping the state size of $f$."}, {"title": "FPT Compilation of Systems of O(1)-Slim Constraints", "content": "In this section, we explain the proof of Theorem 4. The proof is in three steps: (1) find a CNF encoding $H(X, Z)$ of $F(X)$ whose incidence treewidth is at most $O(w\\cdot twi(F))$, (2) compile $H(X, Z)$ to d-SDNNF using Theorem 3, and (3) existentially forget the auxiliary variables $Z$ from the resulting d-SDNNF circuit. We do not have to take care of (2). For (3), forgetting the variables $Z$ from a d-SDNNF circuit $D(X, Z)$ means finding another d-SDNNF circuit computing $\\exists Z.D(X, Z)$. Forgetting many variables from a d-SDNNF circuit is generally intractable [PD08]. However the operation is tractable when the $Z$-variables are completely defined in terms of the $X$-variables. We make sure to be in this situation by using only Tseitin CNF encodings to generate $H(X, Z)."}, {"title": "The Tseitin Encoding", "content": "Let $D(X)$ be a Boolean circuit whose internal gates are binary $\\lor$-gates and binary $\\land$-gates. Let $gates^*(D)$ be the set of its internal gates. Every gate $g$ is associated with a variable $z_g$. Let $Z = {z_g | g \\in gates^*(D)}$. The Tseitin encoding of $D$ is the CNF\n$H_D^{Tseitin}(X,Z) := \\bigwedge_{g \\in gates^*(D)} Tseitin(g)$\nwhere, for every gate $g$, if $g = g_1 \\land g_2$ then $Tseitin(g) := (\\overline{z_g} \\lor z_{g_1}) \\land (\\overline{z_g}\\lor z_{g_2}) \\land (\\overline{z_{g_1}} \\lor \\overline{z_{g_2}} \\lor z_g)$, if $g = g_1 \\lor g_2$ then $Tseitin(g) := (z_g \\lor \\overline{z_{g_1}} \\lor \\overline{z_{g_2}}) \\land (z_{g_1} \\lor \\overline{z_g}) \\land (z_{g_2} \\lor \\overline{g})$, and if $g$ is an input gate, so if $g = x, \\overline{x}, 0$ or 1, then $z_g = g$. The formula $H_D^{Tseitin}$ is a CNF encoding of $D$ in the sense that\n$\\exists Z.H_D^{Tseitin}(X, Z) = D(X)$.\nWe often drop the Tseitin superscript in the rest of the paper. $\\exists Z.H_D(X, Z)$ is the Boolean function over $X$ that maps to 1 exactly the assignments to $X$ that can be extended over $Z$ to satisfying assignments of $H_D$. For $C$ a DNNF circuit and $Z$ a subset of $var(C)$, EXIST(C, Z) is the circuit $C$ where all literals in $C$ for $Z$ are replaced by 1. Clearly, computing EXIST(C, Z) is a linear-time procedure. EXIST(C, Z) is in DNNF and is equivalent to $\\exists Z.C$ [DM02]. It is known that, when $C$ is a d-DNNF circuit representing a Tseitin encoding $H_D(X, Z)$, with $Z$ the Tseitin variables, then EXIST(C, Z) is not just in DNNF but in d-DNNF. This is not straightforward since the EXIST procedure generally breaks determinism for $\\lor$-gates [KE23]. One can go one step further and prove that if $C$ is in SDNNF, then EXIST(C, Z) is also in SDNNF.\nLemma 8. Let $f(X)$ be a Boolean function and $D_1(X_1), ..., D_m(X_m)$ be Boolean circuits. For $D$ an d-SDNNF circuit computing $f(X) \\land H^{Tseitin}(X_1, Z_1) \\land ... \\land H^{Tseitin}(X_1, Z_m)$, where the sets $Z_1,..., Z_m$ are pairwise disjoint, the linear-time procedure $EXIST(D, Z_1 \\cup...\\cup Z_m)$ returns a d-SDNNF circuit com-puting $f(X) \\land D_1(X_1) \\land...\\land D_m(X_m)$.\nProof. Let $Z = Z_1 \\cup...\\cup Z_m$. We have that $EXIST(D, Z) = \\exists Z.D(X, Z)$ by definition of EXISTS, and $\\exists Z.D(X, Z) = f(X) \\land \\bigwedge_{i=1}^m \\exists Z_i.H^{Tseitin}(X_i, Z_i)$ because the sets $X, Z_1, ..., Z_m$ are pairwise disjoint, and therefore $EXIST(D, Z) = f(X) \\land \\bigwedge_{i=1}^m D_i(X_i)$ by property of the Tseitin encoding.\nLet $D' = EXIST(D, Z)$. The proof that $D'$ is in d-DNNF can be found in [KE23]. So we just have to show that this d-DNNF circuit is structured by a vtree. Let $(\\tau, \\lambda)$ be a (vtree,mapping) pair"}, {"title": "Proof of Theorem 4", "content": "The only real hurdle in the proof of Theorem 4 is (1), that is, encoding the system of constraints $F(X) = C_1(X_1) \\land...\\land C_m(X_m)$ into the CNF $H(X, Z)$ while controlling the incidence treewidth. For every $i < m$ we do the following. First, using a certain tree decomposition of $F$'s incidence graph, we construct a vtree $T_{ci}$ over $X_i$. Second, we construct an SDNNF circuit $D_i(X_i)$ structured by $T_{ci}$ that computes $c_i(X_i)$. Next, we encode $D_i$ into a CNF formula $H_i(X_i, Z_i)$ using the Tseitin encoding and a set $Z_i$ of fresh auxiliary variables. The CNF encoding of $F$ is then $H(X, Z) := H_1(X_1, Z_1)\\land...\\land H_m(X_m, Z_m)$. Given the vtrees $T_{ci}$, it should be quite clear that $H(X, Z)$ can be constructed in polynomial time under Assumption 1, and that the $Z$ variables can be forgotten using Lemma 8. So we only need to justify that the $T_{ci}$ can be found efficiently, and that the incidence treewidth of $H(X, Z)$ can be controlled."}, {"title": "Constructing the Vtrees", "content": "To construct the vtree $T_{ci}$ for $c \\in F$, we need a tree decomposition (t.d.) of $G_F$ with specific properties. We do not give the details here but, basically, we use nice t.d. in which a few bags are cloned. Roughly put, $T_{ci}$ shows how the variables of $c$ appear relative to each other in the t.d. For instance, in the t.d. shown Figure 3c (not of the type used in the proof, but sufficient for the example) for the incidence graph of Figure 3a, we have $x_2, x_3$ and $x_4, x_5$ are introduced in a different branches, and this yields the vtree $T_{c2}$ shown Figure 3b. $T_{ci}$ is found using the following lemma.\nLemma 9. Every tree decomposition (t.d.) of $G_F$ can be transformed in polynomial time into another t.d. $(T,b)$ of $G_F$, that has the same width, and that can be used to find in linear time a vtree $t_c$ over $var(c)$ for every $c \\in F$. Each vtree $t_c$ has a t.d. $(T,b_c)$ of width 3 such that, for all $t \\in V(T)$,\ni.   if $c \\notin b(t)$ then $b_c(t) = \\emptyset$,\nii.  if $c\\in b(t)$ then $b_c(t) \\cap b(t) \\subseteq b(t) \\cap var(c)$.\nProof. First, we turn the initial tree decomposition into a nice tree decomposition $(T', b')$, with same width, in polynomial time. We do not describe this step, it is well-known.\nIn a tree, We say that we bypass a node $t$ that has a single child $t'$ when we remove $t$ if it has no parent (so if $t$ is the root), or, if $t$ has a parent $t''$, when we remove $t$ and make $t''$ the parent of $t'$. We say that we insert a parent before $t$ when, if $t$ is the root we create a new root whose unique child is $t$, and otherwise we disconnect $t$ from its parent $t'$ and create a new node $t''$ whose parent is $t'$ and whose unique child is $t$. We insert a clone parent in a tree decomposition $(T, b)$ when we insert a parent $t''$ before a node $t$ and set $b(t'') = b(t)$.\nFor every $x \\in var(F)$, if the highest node $t$ of $T'$ such that $x \\in b'(t)$ is a join node, then we insert a clone parent before $x$. Once this is done, for every $x$, let $t_x$ be the highest node of $T'$ such that $x \\in b(t)$. The properties of nice tree decomposition guarantee that $t_x \\neq t_y$ holds for every $y \\neq x$ and the clone insertions guarantee that $t_x$ has zero or a single child.\nLet $c\\in F$ and let $S = var(c) \\cap b'(t_c)$. For every $x \\in S$, insert a clone parent before $t_c$. Call $t_c$ this new parent. For every $x \\in var(c) \\setminus S$, we have that $t_x$ is a descendant of $t_c$ and that $c\\in b'(t_x)$. For every such $x$, $t_c$ refers to $t_x$. Repeat the construction for every $c\\in F$. The resulting tree decomposition is $(T,b)$. It is clear that this is still a tree decomposition of $G_F$, that it has the same width as the decomposition we started with, and that it is constructed in polynomial time. Note that for every"}, {"title": "Controlling the Treewidth of the Encoding", "content": "Thanks to the properties stated in points i. and ii. of Lemma 9, we can merge the t.d. $(T,b_c)$ of $T_c$ with the t.d. $(T, b)$ of $G_F$ with a simple bag-wise union to get a t.d. of $G_F \\cup T_C$ (the graph with vertex set $V(G_F) \\cup V(T_C)$ and with edge set $E(G_F) \\cup E(T_C)$).\nLemma 10. Let $G$ and $G'$ be two graphs and let $V_S := V(G) \\cap V(G')$. Let $(T,b)$ and $(T', b')$ tree decompositions of $G$ and $G'$, respectively. If $T = T'$ and if for all $t \\in V(T)$ we have $b(t) \\cap V_S \\subseteq b'(t) \\cap V_S$ then $(T, b\\cup b')$ is a tree decomposition of $G\\cup G'$.\nProof. We have that $\\bigcup_{t \\in V(T)} (b\\cup b')(t) = \\bigcup_{t \\in V(T)} b(t) \\cup\\bigcup_{t \\in V(T)} b'(t) = V(G) \\cup V(G') = V(G\\cup G')$. Every edge of $G\\cup G'$ is an edge of $G$ or an edge $G'$, so it is contained in $b(t)$ or $b'(t)$ for some $t \\in V(T)$, a fortiori it is contained in $(b\\cup b')(t)$. Now, for the connectivity condition, if $v \\in V(G) \\setminus V(G')$ then we have that $v\\in (b\\cup b')(t)$ if and only if $v \\in b(t)$, so $T[t | v\\in (b\\cup b')(t)] = T[t | v \\in b(t)]$ is a connected tree. The argument is similar for $v \\in V(G') \\setminus V(G)$. Finally, if $v \\in V_S$, then there is a node $t$ such that $v \\in b(t)$, but then $v \\in b'(t)$ by assumption. It follows that the two trees $T[t | v \\in b(t)]$ and $T[t | v \\in b'(t)]$ share a vertex and therefore $T[t | v\\in (b\\cup b')(t)]$ is connected."}, {"title": "Slim Functions", "content": "Definition 1. A class $F$ of Boolean functions is $h$-slim for complete OBDDs when, for every $n$-variables function $f\\in F$ and every total order $\\pi$ of $var(f)$, there is a complete $\\pi$-OBDD of width at most $h(n)$ computing $f$.\nThe notions of $O(1)$-slim functions, $O(n)$-slim functions, etc. should be self-explanatory. Given a fixed constant $w$, we talk of $w$-slim functions when $h$ is the constant $w$ function. When $h$ is an unknown polynomial, the $h$-slim functions for complete OBDDs coincide with the nice functions from Wegener's book [Weg00, Section 5.3]. Our proofs below rely on SDNNF representations rather than OBDD representations. The concept of $h$-slim functions generalizes to SDNNF.\nDefinition 2. A class $F$ of Boolean functions is $h$-slim for complete SDNNFs when, for every $n$-variables function $f \\in F$ and vtree $\\tau$ over $var(f)$, there is a complete SDNNF of width at most $h(n)$ and with vtree $\\tau$ that computes $f$.\nGiven the rewriting of complete OBDDs into complete d-SDNNFs, it is immediate that having a small OBDD-width for every variable ordering implies having a small SDNNF-width for every linear vtree. However, generalizing to all possible vtrees is not straightforward.\nLemma 1. If a class $F$ of function is $h$-slim for complete OBDDs, then it is $O(h^3)$-slim for complete SDNNFs."}, {"title": "The Hard Systems of Constraints", "content": "The system of constraints is an encoding of a W[1", "problem": "k-CLIQUE.\nk-CLIQUE\nInput: a graph G\nParameter: an integer k\nOutput: yes if G has a clique of size k", "parameters": "a graph $G$ and an integer $k$. For every $i \\in {1,...,k}$ and every ${u, v} \\in E(G)$, we introduce two Boolean variables $x_i[uv", "x_i[vu": ".", "k": {"h": "the subsequence $(u_{\\ell}, ..., u_h)$. We will also denote by $[\\ell, h", "alpha(x_i[uv": 1}}]}