{"title": "DStruct2Design: Data and Benchmarks for Data Structure Driven Generative Floor Plan Design", "authors": ["Zhi Hao Luo", "Luis Lara", "Ge Ya Luo", "Florian Golemo", "Christopher Beckham", "Christopher Pal"], "abstract": "Text conditioned generative models for images have yielded impressive results. Text conditioned floorplan generation as a special type of raster image generation task also received particular attention. However there are many use cases in floorplan generation where numerical properties of the generated result are more important than the aesthetics. For instance, one might want to specify sizes for certain rooms in a floorplan and compare the generated floorplan with given specifications. Current approaches, datasets and commonly used evaluations do not support these kinds of constraints. As such, an attractive strategy is to generate an intermediate data structure that contains numerical properties of a floorplan which can be used to generate the final floorplan image. To explore this setting we (1) construct a new dataset for this data-structure to data-structure formulation of floorplan generation using two popular image based floorplan datasets RPLAN and ProcTHOR-10k, and provide the tools to convert further procedurally generated ProcTHOR floorplan data into our format. (2) We explore the task of floorplan generation given a partial or complete set of constraints and we design a series of metrics and benchmarks to enable evaluating how well samples generated from models respect the constraints. (3) We create multiple baselines by finetuning a large language model (LLM), Llama3, and demonstrate the feasibility of using floorplan data structure conditioned LLMs for the problem of floorplan generation respecting numerical constraints. We hope that our new datasets and benchmarks will encourage further research on different ways to improve the performance of LLMs and other generative modelling techniques for generating designs where quantitative constraints are only partially specified, but must be respected.", "sections": [{"title": "Introduction", "content": "Generative modelling has the potential to accelerate and improve design tasks but in order for them to achieve widespread use by real-world practitioners they need to be flexible and exhibit a sufficiently high degree of controllability. For instance, in floorplan generation users will want to be able to specify a set of constraints detailing how rooms should be connected and what their dimensions are. The resulting model should also be flexible in the sense that it performs equally well on as few or as many constraints as needed. Just as there are many possible constraints that the user can specify, there also needs to be a rigorously-defined set of evaluation metrics to probe how well the model performs (or underperforms) on them, which we contribute in this work."}, {"title": "Related Work", "content": "Datasets. One of the most commonly used datasets for floorplan generation is RPLAN [Wu et al., 2019]. Since we make use of the dataset in this work, we defer its description to Section 3.2. LIFULL [of Informatics, 2015] is an extremely large-scale dataset consisting of floorplans sourced from a Japanese realtor company. Floorplans are provided in raster format, however a subset of vectorized versions exist [Liu et al., 2017]. One common shortcoming is that there is a lack of well-annotated floorplan data (e.g. vectorised) which is amenable to training. Architext [Galanos et al., 2023] address this issue by generating synthetic but diverse floorplans via a CAD script for Rhinoceros 3D. In a similar vein, we leverage ProcTHOR [Deitke et al., 2022] (also used and described in more detail in Section 3.2) which is a fully open source simulator of buildings (and by extension floorplans). Unlike Rhinoceros 3D this simulator is completely open source.\nGenerative Models. House-GAN and House-GAN++ [Nauata et al., 2020a, 2021a] are a family of GAN-based methods which learn to generate floorplans using convolutional graph-based networks. Notably however this line of work only conditions on a bubble graph. FloorplanGAN [Luo and Huang, 2022] proposes a self-attention-based GAN which takes as input (for each room) room centers, desired areas (as a relative proportions), as well as room type for each room. Because the GAN is tasked with also refining the initial input constraints, the output may not respect them. While the use of a differentiable rasteriser to compute losses in pixel space opens up possibilities, the core method does not appear to support a partial specification of constraints or polygons. HouseDiffusion [Shabani et al., 2023] is a diffusion-based method which directly predicts a list of polygons for each room, utilising a transformer architecture which also conditions on a bubble diagram. Lastly, ArchiText [Galanos et al., 2023] also leverages LLMs to generate output floorplans but it appears the prompts are only limited to natural language descriptions rather than geometry.\n3D Scene Generation. Recently, full 3D scene generation methods have shown impressive results. AnyHome [Wen et al., 2023] and Holodeck [Yang et al., 2024] are able to generate floor plans, windows & doors, furniture and meaningful placement in 3D all from a query like \"a 1b1b apartment\". In our method, we focus only on the floor plan aspect, but we allow for specification of room dimensions and areas as well as total floor plan area, which neither method does. Since our proposed dataset is partially comprised of ProcTHOR (a 3D-based floorplan simulator), in principle a future version of our proposed dataset could support the placement of furniture and other props."}, {"title": "Our Text-Based DStruct2Design Floorplan Dataset", "content": "In this work, we view the problem of floor plan generation from a text-based data structure perspective. Specifically, we wish to utilize the data structure to enable, through language input, a unified method that not only allows users to apply numerical constraint but also retains the ability to condition on graphs such as bubble diagrams, which have been the input in the traditional floorplan generation task. As such, the choice of data representation for the floorplans is very important. In our work, we carefully design a JSON based data structure to be used as a new representation for the floorplans. As prior work all use datasets of floorplans in 2D image or 3D scenes, we create a new dataset by converting existing image and scene data into our data structure for the use of our task."}, {"title": "Data Structure", "content": "In this structure, we define crucial numerical data such as the number of rooms present, the total area and type of each room that appears in each floor plan. Each room within a floor plan is further defined with room specific fields. Importantly, each room's location is defined through a set of vertices that forms a polygon. This ensures that the language model cannot cheat by outputting vague locations, and instead it has to predict the exact coordinates of the vertices.\nThis structure also has several additional advantages: 1. Using numerical value based gives us the ability to set numerical constraints in the input, and it allows for clear and explicit evaluation on how well the generation process adheres to these constraints. 2. This structure is designed to have sufficient information to be transformed into higher level representations such as floor plan images, allowing seamless integration with traditional visualization techniques. 3. The format is highly extensible, enabling the inclusion of additional information in the generation process, such as the placement and attributes of objects within the floorplan. This flexibility ensures that our approach can be further adapted to various task expansions in the future."}, {"title": "Datasets & Preparation for Our New Task Formulation", "content": "ProcTHOR-10k [Deitke et al., 2022] is a dataset of 12,000 procedural generated, fully interactive 3D houses designed for research in Embodied AI. We clean and process the raw data from each house, focusing on the geometric properties of the rooms. We employ the shoelace formula to calculate areas and determined room dimensions based on their x and y coordinates. Additionally, we remove redundant points and apply rounding to the coordinates for consistency. Next, we categorize and count the types of rooms, and compute the total area for each house layout. The processed data is organized into the new JSON structure explained in Table 2.\nRPLAN [Wu et al., 2019] is a manually collected dataset of 80,788 real world floor plans of buildings in Asia. Each floor plan in RPLAN is stored as a 256 \u00d7 256 \u00d7 4 vector image. Channels 1 and 2 store interior and exterior boundary information; channel 3 contains room information where each pixel value denotes which room it belongs to; channel 4 has extra information to distinguish rooms with the same room type value in channel 3. To convert this 4 channel image into a JSON structure with well-defined room location, we first extract all pixel coordinates for all of the rooms. For each room, we locate the pixels that make up its perimeter. Then, by tracing the perimeter in one direction we are able to capture all of the vertices in an order that allows recreation of the room polygon. We take the room's type and deduce all the other fields listed in Table 2 to complete the data structure. We convert 80,315 floorplans from RPLAN."}, {"title": "Bubble Diagrams", "content": "Traditionally, much of the prior work has assumed that at the beginning of the floor plan design process a bubble diagram is used to conceptualize the layout of the floor plan. As shown in Figure 2, a bubble diagram is used to represent different room and their spacial relationship with one another as a guidance and constraint for the floor plan design process to follow. Formally, a bubble diagram is a graph $G = (N, E)$ where each node $n_k$ in $N = \\{n_i\\}_{i=1}^R$ represents the kth room in the floor plan with R rooms, and each edge $e_l = (n_p, n_q)$ in $E = \\{e_j\\}_{j=1}^E$ denotes a connection between room p and q.\nIn this work, we enable the use bubble diagram as an additional conditioning in our floor plan generation process. To obtain the bubble diagram we check pair-wise proximity of the rooms in each floor plan. If the Manhattan distance between the rooms' boundaries are within a threshold, they are counted as connected. This threshold is set to 8 pixels for the RPLAN dataset in line with prior work, and to 2 pixels for ProcTHOR to account for the length unit differences between the two datasets. This adjacency information is stored in the \"edges\" field in our data representation. During training, we use G as conditioning for our floor plan generation."}, {"title": "Our DStruct2Design (DS2D) LLM", "content": "We train an LLM by prompting it with structured numerical constraints and or graph constraints (Bubble Diagram) and asking it to predict the converted floor plan, as depicted in Figure 1.\nNumerical Constraints $C = \\{c_i\\}_{i=1}^T$ are a set of T conditions that users may impose on the final floor plan. In the task of floor plan design and generation, these can include, but are not limited to, total square footage of the entire floor, the number and the types of rooms present, the size of each room. These conditions are mostly inherently numerical, and thus we can take advantage by directly using it in its data structure form. For example, the constraint of having a total square footage of 990 can be transformed into {\u201ctotal_area\u201d: 990}. This allows a direct match between the input prompt and output JSON string, which may help the model understand the structure and its relationship better.\nBubble Diagrams are represented differently as conditioning to our model. We chose to pass it in as tuples of connecting rooms. For an edge $e_i = (n_p, n_q)$ connecting nodes p and q, it is formatted as (room_p, room_q). Due to the possible existence of multiple rooms of the same type, which can be clearly distinguished in a graph but not easily in text, we decide to represent room_p and room_q by their room IDs in addition to their room types.\nWe process the constraint set and the bubble diagram into \"constraint string\" and \"adjacency string\". They are then combined with an instruction phrase that is used throughout the training process to create the final prompt."}, {"title": "Our Metrics and Benchmarks", "content": "To assess floorplan quality, we focus on the numerical consistency of the generation. Specifically, we design two groups of metrics to evaluate what we call self-consistency and prompt-consistency:\n\u2022 Self Consistency metrics measures how numbers agree with each other in the generated floor plan. For instance, this includes a metric to check if the area defined by the polygon vertices is the same as the area number presented in the \"room_area\" field.\n\u2022 Prompt Consistency metrics evaluate how consistent the generation is to the constraints used in the prompt. An example of this type of metrics is one that measures if the generated number of rooms adds up to the number of room requested in the prompt.\nIn addition to the two main groups of metrics, we also incorporate Compatibility metrics which is used in past work [Shabani et al., 2022, Nauata et al., 2020b, 2021b, Johnson et al., 2018, Ashual and Wolf, 2019] to measure similarity between the input bubble diagram and the output floor plan. It is by definition the graph edit distance [Abu-Aisheh et al., 2015] between the input bubble diagram and the output diagram extracted from the output JSON. The extraction method is the same one used to generate the bubble diagrams in the first place as described in Section 3.3."}, {"title": "Experiments", "content": "All of our experiments are ran on the LLaMA3-8B-Instruct variant of the LLaMA model family [Touvron et al., 2023]. We train our models by running 8-bit quantization along with LoRA [Hu et al., 2021]. Each of our experiments are also run on single RTX8000 GPU, they take less than a day to complete."}, {"title": "Model Variants", "content": "We train six variants of our model on the converted ProcTHOR dataset and four on converted RPLAN dataset. Each of the four models on RPLAN \u2013 5-R, 6-R, 7-R, 8-R \u2013 is trained without floorplan data of a certain room count. 5-R is trained only on floorplans with 6, 7, and 8 rooms, etc. This follows prior work [Nauata et al., 2020b, 2021b, Shabani et al., 2023]. On the other hand, the six models trained on ProcTHOR are divided two main variants: bubble diagram enabled model, and numerical constraint only model. In the bubble diagram enabled model (BD), both the constraint string and the adjacency string described in Section 4 are used as part of the input. In constrast, in the numerical constraint only model, only the constraint string is used. We further train three sub-variants for each of the two main variants to investigate how robust the models are to missing information:\n\u2022 Full-Prompt (F) model takes advantage of every attribute available in the constraint set. During training, every constraint attribute is part of the constraint string.\n\u2022 Mask (M) model uses a subset of constraint set by applying a 50% masking on every single possible constraint. In the case of rooms which is an attribute containing a list, the masking is applied independently to individual item in the list. (rooms is only dropped out if the entire list becomes empty.) As a safety measure, we always keep at least 1 constraint in the set.\n\u2022 Preset Mask (PM) randomly selects one of four preset constraint sets with varying degree of missing information. The idea is to not just have IID random masking, but a hierarchy of attributes from general to specific"}, {"title": "Generation Prompts", "content": "To test the model, we run four different generation prompts with varying amount of constraints in the prompt. This simulates the real world problem of floorplan design, where designer often receives only partial criteria. For instance, the user might only ask the living room and bedroom to be a certain size, and leaves the designer with the freedom to imagine layouts with varying sizes for the other rooms. The four generation prompts are listed in order of decreasing amount of constraints:\n\u2022 Specific (S) is one where we use all the possible constraints\n\u2022 All Room Area (AR) is one where we pass in the area of all the rooms (total area can be inferred from this information).\n\u2022 Partial Room Area (PR) is similar to Total Area. In addition to the total area of the floor plan, the area of some of the rooms are also passed as conditions in the constraint string.\n\u2022 Total Area (TA) is one where we only use the total area of the floor plan as constraint.\nFor all of the Bubble Diagram model variants, Bubble Diagrams are used in each of these types of prompts."}, {"title": "Results", "content": "We test floor plan generation quality on ProcTHOR-trained six model variants with the four different generation prompts with self and prompt consistency metrics. Results from our best model variants are listed in Table 5, and all results on all 48 sets of experiments are listed in Appendix F.\nWe perform the same evaluation on the four RPLAN-trained model variants. Because each model variant trained on RPLAN uses a slightly different set of data (following prior work), we show results for each model variant in Table 5. Results for the full 24 experiments are shown in Appendix H.\nAnalysis According to our metrics, perhaps surprisingly, our LLM models demonstrate a high level of competence in generating floorplans that are largely mathematically consistent, and are also consistent to input numerical constraint. As seen in Figure 2, when given full specifications, the generated rooms largely resembles ground truth in sizes, width and height. This quality is accurately reflected by our Total Area, R.H and R.W metrics. On the other hand, our metric suggests that generations can produce overlapping room layouts."}, {"title": "Conclusions", "content": "We have motivated the need for new datasets and benchmarks for real-world use case scenarios for floorplan generation. We have developed and explored a Llama 3 based LLM for the problem and it yields SOTA results on the previous compatibility based evaluation and along with our proposed metrics, it highlights different use cases scenarios where improvements are possible. In particular we see from Table 7 that when conditioning on bubble diagrams and room area information this model struggles to respect the bubble diagram constraints. From Table 5 we see that the model does well, but is far from perfect at generating rooms with correct areas as computed from the generated polygons. We also see that the biggest weakness of this otherwise SOTA model is linked to issues with generating overlapping rooms.\nWe hope that our data, simulated data generation procedure and benchmarks will stimulate further developments for this new problem formulation for floorplan generation."}, {"title": "Possible Negative Impacts", "content": "Job Displacement The automation of floorplan generation through advanced technology threatens job displacement for professionals in architecture, real estate, and related fields. As these tools become more sophisticated, human expertise may be undervalued or rendered obsolete.\nMitigation To address this issue, it is important to promote technology as a means to augment human capabilities rather than replace them. By providing training programs, professionals can adapt to new tools and workflows, ensuring they remain relevant and can leverage technology to enhance their work rather than be supplanted by it.\nQuality and Safety There is a significant risk that generated floorplans might not meet established safety standards or quality expectations, leading to potential hazards in construction or living con-ditions. Poorly designed floorplans could result in unsafe buildings and legal liabilities and reduce occupants' overall quality of life.\nMitigation To mitigate these risks, it is essential to incorporate rigorous safety and quality checks into the floorplan generation process. Collaborating with experts in architecture and engineering can help ensure that generated floorplans adhere to all relevant standards and regulations, thus maintaining the integrity and safety of the built environment."}, {"title": "Prompt Structure", "content": "<|start_header_id|>system<|end_header_id|>\nyou are to generate a floor plan in a JSON structure where each room is defined by polygon vertices, make sure to not overlap the polygons.\nyou have to satisfy the adjacency constraints given as pairs of neighboring rooms, two connecting rooms, room1 and room2, are presented as (room1_type/\"room1_id\", room2_type/\"room2_id\"). you have to also match the specifications passed by the user in a JSON structure when they exist. when room area and total area requirements exist, make sure the polygon areas add up to the required number.\n<|eot_id|><|start_header_id|>user<|end_header_id|>\nadjacency constraints: (Bedroom/\"room|4\", Bathroom/\"room|5\"), (Bedroom/\"room|4\", Kitchen/\"room|6\"), (Bedroom/\"room|4\", LivingRoom/\"room|7\"),(Bathroom/\"room|5\", Kitchen/\"room|6\"),\n(Bathroom/\"room|5\", LivingRoom/\"room|7\"),\n(Kitchen/\"room|6\", LivingRoom/\"room|7\"). specifications: {\u2019room_count\u2019: 4, \u2019total_area\u2019: 146.8, \u2019rooms\u2019: [\n{\u2019area\u2019: 41.3, \u2019id\u2019: \u2019room|4\u2019, \u2019room_type\u2019: \u2019Bedroom\u2019},\n{\u2019area\u2019: 27.5, \u2019id\u2019: \u2019room|7\u2019, \u2019room_type\u2019: \u2019LivingRoom\u2019}]}\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>"}, {"title": "Training Details", "content": "For floorplan data converted from RPLAN dataset, we follow the original data split. RPLAN dataset is divided into 5 parts according to the number of rooms present in the floorplan. Specifically, each part respectively contains floorplans with 4, 5, 6, 7, 8 rooms. Each part is further divided into a training, validation, and a test split. Following prior work, we use only training data with 5, 6, 7, 8 rooms. 4 different models are trained, each has never seen one of the 4 part \u2013 when training the model for 5 room floorplan generation, training is done with training splits of 6, 7, 8 room floorplans etc. During test time, the model is asked to generate only 4 room floorplans even though it has never seen a 4 room floorplan in the training set. This is in line with prior work that uses the RPLAN dataset.\nForfloorplan data converted from ProcTHOR dataset, the validation and test split is randomly chosen, with each of validation and test split being 10% of the training split. The training split is used to train the model; the validation split used to perform early stopping; and the test split is used to generate prompts for generation and evaluation."}, {"title": "Hyper-parameters", "content": "We follow the suggest training parameters from Llama-recipes (https://github.com/meta-llama/llama-recipes/tree/main), and we do not perform any hyper-parameter search.\nRandom Seed used for generation is chosen to be 12345 to select 100 (sampling generation) or 1000 (greedy generation) random test set data for generation. This seed is simply chosen and never changed or compared with any other random seed.\nFor Sampling generation, we generate 20 output floorplans for each prompt using nucleus sampling. We choose p = 0.8 for sampling as it is a common value for this parameter.\nFor Greedy generation, we use the default parameter provided by HuggingFace hug."}, {"title": "Specific Attributes Sets in Preset Masking", "content": "Here we present the attributes used in the preset masking variant of our model. The four presets have varying amount of attributes from general to specific."}, {"title": "Self and Prompt Consistency Metrics on ProcTHOR", "content": "In total, we have 6 model variants trained on converted ProcTHOR data. 3 of them are trained with bubble diagram input and 3 without. For each of the 6 model variants, we run 4 different sets of generations with different prompts as explained in Section 6.2; and for each of the generation prompt, we run both greedy and sampling algorithm to obtain 2 sets of different floorplan generations.\nTherefore, in total, we run 48 sets of experiments and evaluations. We present the full evaluation using our designed metrics here, organized into 4 different sections according to the generation prompt. Each section has 2 main tables, one for self consistency metrics, and one for prompt consistency metrics."}, {"title": "Generation Prompt: Specific", "content": null}, {"title": "Generation Prompt: Total Area", "content": null}, {"title": "Generation Prompt: Partial Room Area", "content": null}, {"title": "Generation Prompt: All Room Area", "content": null}, {"title": "Compatibility Metrics on ProcTHOR", "content": "We further run compatibility evaluations on all of the Bubble Diagram model variants to test how well bubble diagrams are followed."}, {"title": "Self and Prompt Consistency Metrics on RPLAN", "content": "This section contains the full self- and prompt-consistency metrics evaluated on the 4 models (Section 6.1) trained on the converted RPLAN dataset.\nSimiliar to the ProcTHOR-trained model experiments, we run the 4 different generation prompts on each of the RPLAN-trained model variants, resulting in 16 different experiments. They are organized by generation prompt and shown here."}, {"title": "Generation Prompt: Specific", "content": null}, {"title": "Generation Example", "content": null}]}