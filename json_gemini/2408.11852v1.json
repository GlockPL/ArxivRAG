{"title": "Fast Training Dataset Attribution via In-Context Learning", "authors": ["Milad Fotouhi", "Mohammad Taha Bahadori", "Oluwaseyi Feyisetan", "Payman Arabshahi", "David Heckerman"], "abstract": "We investigate the use of in-context learning and prompt engineering to estimate the contributions of training data in the outputs of instruction-tuned large language models (LLMs). We propose two novel approaches: (1) a similarity-based approach that measures the difference between LLM outputs with and without provided context, and (2) a mixture distribution model approach that frames the problem of identifying contribution scores as a matrix factorization task. Our empirical comparison demonstrates that the mixture model approach is more robust to retrieval noise in in-context learning, providing a more reliable estimation of data contributions.", "sections": [{"title": "1 Introduction", "content": "Training Data Attribution (TDA) refers to the task of quantifying contributions of different data sources on the outputs of a model (Park et al., 2023; Nguyen et al., 2023). This task is essential for debugging the processes of curating corpora for training and for improving the training of neural networks. Understanding the contribution of data sources allows us to assess the monetary value of proprietary training data, which is crucial for fair compensation and data management (Ghorbani & Zou, 2019; Nohyun et al., 2022).\nExisting methods for TDA, primarily fall into two categories: retraining-based methods and influence function-based methods, as detailed in recent surveys (Hammoudeh & Lowd, 2024; Worledge et al., 2024). Retraining approaches such as those by (Feldman & Zhang, 2020; Ghorbani & Zou, 2019) involve retraining the model without the target data source. However, this method is computationally expensive. Influence function approaches (Koh & Liang, 2017; Pruthi et al., 2020; Chen et al., 2021; Park et al., 2023), relax the need for full retraining by requiring only a few gradient calculations with respect to the data. Despite their efficiency, these methods rely on a linear approximation of the neural network around the target data point, which can be inaccurate. Critically, the influence function approaches compute the attribution score for a dataset as a linear function (usually an average or sum) of the attribution scores for each data point in the dataset (Hammoudeh & Lowd, 2024; Park et al., 2023). This approach fails to provide a holistic view of the contributions of an entire dataset to the model's output. Additionally, both methods require access to the internals of LLMs, which is not feasible for some popular models. A related technique, Machine Unlearning (Ginart et al., 2019; Sekhari et al., 2021) is still expensive for obtaining the contribution scores.\nWe explore the use of in-context learning and prompt engineering to estimate the contributions of each dataset as a whole in the outputs of instruction-tuned LLMs. We propose two approaches: (1) A similarity-based approach, which posits that providing a dataset as context to an LLM trained on that dataset changes its output less compared to when the LLM was not trained on the dataset. (2) A mixture distribution model approach, where we model the behavior of LLMs using a new mixture distribution. This approach transforms the problem of identifying contribution scores into a matrix factorization problem, which we solve using the"}, {"title": "2 Methodology", "content": "An LLM processes knowledge from different sources. Our goal is to examine different prompts and see if we can uncover the sources of this knowledge.\nIn the binary outcome setting, we have tuples in the format of question, context, and outcome: (q, c, y). When we don't use any context, we denote c = (). Our model also outputs p(y|q,c). Our goal is to quantify the contributions of the training datasets D1,...,Dn in p(y|q,c). We assume that we have a query set Q = {q1,..., qm}.\nWe assume that we have k, k = 1, ..., K relevant datasets about a topic and we want to quantify their contributions in the generation of the output by our LLM."}, {"title": "2.1 The Non-parametric Approach: The Shapley Context Method (SCM)", "content": "The key idea of this approach is that if an LLM uses the information from the kth dataset, providing the kth dataset as context will not change the output much. Conversely, if adding a dataset as context changes the output significantly, it was likely not used for generation of the output.\n$S_k = sim(y, y|c_k),$\nwhere ck is the context provided from the kth dataset.\nUsually, desired information can be found in multiple datasets (Ghorbani & Zou, 2019). To consider the impact of datasets in presence of other datasets, we define the following residual scores to be used in the Shapley formula (Shapley, 1953):\n$s_S = sim(y, y|c_S).$\nThe Shapley values are computed as follows:\n$\\phi_k = \\sum_{S \\subseteq {D_1,..., D_K}\\{D_k}} \\frac{|S|!(K - |S| - 1)!}{K!} (s_{S \\cup {k}} \u2013 s_S).$\nThis formula finds the residual increase in the similarity by including Dk, when we already have included another set S\u2286 {D\u2081,...,DK}\\{Dk}. Algorithm 1 in Appendix B describes the details of our Shapley Context Method (SCM)."}, {"title": "2.2 The Semi-Parametric Approach: Context Mixture Factorization (CMF)", "content": "We propose a model for summarizing the behavior of LLMs. Our model explicitly contains attribution scores and captures the entirety of the datasets used for its training. We use a mixture distribution approach, which defines:\n$p(y/q) = \\pi_0p_0(y/q) + \\sum_{k=1}^{K}\\pi_kP_k(y/q),$"}, {"title": "3 Implementation", "content": ""}, {"title": "3.1 Prompt Engineering", "content": "For simplicity of evaluation and without loss of generality, we used BoolQ (Clark et al., 2019) Q&A dataset, where the answers are binary Yes/No. To instruct the LLMs to provide direct boolean responses, we used prompt engineering. Initially, we tested various prompts without explicitly instructing the model to answer with \"Yes\" or \"No.\" Diverse examples used in this process are provided in Appendix C.3. Through iterative testing, we found that responses improved when the model was explicitly instructed to provide a boolean answer. This led to our final prompt:\nPrompt: \"Given the context below, answer the question that follows with only 'Yes', 'No', or 'I don't know' if the context is insufficient.\n{question}? The answer to this question is\"\nWhile this final prompt worked well for GPT-4, Bloomz, and Mistral 7B, generating straightforward \"Yes,\" \"No,\" or \"I don't know\" responses, it was harder to instruct Phi-3-mini. Even with the final prompt, Phi-3-mini often generated more text than just a simple boolean response.\nTherefore, calculating similarities was straightforward for GPT-4, Bloomz, and Mistral 7B, but we had to devise another solution for Phi-3-mini. The embedding similarity API on GPT-4 was not precise enough as it did not focus primarily on the context of the generated response. To calculate the similarity for Phi-3-mini, we created a Zero-shot classification layer (which takes 1000 characters) between the prediction and the result to measure similarity more accurately."}, {"title": "3.2 Using RAG", "content": "Given the limitations of LLM context windows, fitting entire datasets directly into the context is impractical. To address this, we utilized Retrieval-Augmented Generation (RAG) (Lewis et al., 2020) to enhance the context by retrieving relevant documents from databases before generating responses. The process involves splitting the documents into semantically relevant chunks using the RecursiveCharacterTextSplitter from the Hugging Face Transformers library, computing embeddings for all chunks with a model like thenlper/gte-small, and storing these embeddings in a vector database using FAISS (Facebook AI Similarity Search). When a question is posed, it is embedded and a similarity search is performed against the vector database to find the closest matching documents. These retrieved documents are then provided as context to the LLMs along with the original question, allowing the LLMs to generate responses augmented with additional context.\nWe used a chunk size of 512 and a top-k value of 3, ensuring the context was trimmed to 2000 characters for conciseness."}, {"title": "4 Preliminary Experiments", "content": "Simplified setup to demonstrate our methodology:\nStep 1: Task Selection We use the BoolQ Q&A dataset, which consists of tuples in the form (question, relevant context, binary answer) for each question.\nStep 2: LLM Selection We examined four instruction-tuned LLMs: GPT-4, Bloomz, Mistral 7B, and Phi-3-mini. We report the accuracy of these LLMs on the Q&A task in Table 5. Given that the dataset is binary, we prompted the LLMs to answer \"Yes\" or \"No\" to each question, or to say \"I don't know\" if they could not provide a definite response (see Section C.1)."}, {"title": "5 Conclusion and Discussion", "content": "Our results show that both of our proposed algorithms successfully attribute the output of LLMs to the BoolQ dataset (as the proxy for related knowledge). Comparing LLMs GPT-4 showed minimal change in the similarities when BoolQ context was added, suggesting prior exposure to similar data, while Bloomz exhibited a high residual, indicating substantial influence from BoolQ. The CMF algorithm provides further insights by quantifying the contributions of the base LLM. Comparing our two methods, we conclude that CMF is computationally less expensive and more robust to the RAG noise.\nIn this paper, we considered several datasets as proxies for the datasets used for training of LLMs. For future work, we will try to avoid this approximate method and train our LLMs on specific datasets and test our algorithms with ground truth contributing datasets obtained by retraining."}, {"title": "C Implementation Details", "content": ""}, {"title": "C.1 Prompt Engineering", "content": "For simplicity of evaluation and without loss of generality, we used BoolQ (Clark et al., 2019) Q&A dataset, where the answers are binary Yes/No. To instruct the LLMs to provide direct boolean responses, we used prompt engineering. Initially, we tested various prompts without explicitly instructing the model to answer with \"Yes\" or \"No.\" Diverse examples used in this process are provided in Appendix C.3. Through iterative testing, we found that responses improved when the model was explicitly instructed to provide a boolean answer. This led to our final prompt:\nPrompt: \"Given the context below, answer the question that follows with only 'Yes', 'No', or 'I don't know' if the context is insufficient.\n{question}? The answer to this question is\"\nWhile this final prompt worked well for GPT-4, Bloomz, and Mistral 7B, generating straightforward \"Yes,\" \"No,\" or \"I don't know\" responses, it was harder to instruct Phi-3-mini. Even with the final prompt, Phi-3-mini often generated more text than just a simple boolean response.\nTherefore, calculating similarities was straightforward for GPT-4, Bloomz, and Mistral 7B, but we had to devise another solution for Phi-3-mini. The embedding similarity API on GPT-4 was not precise enough as it did not focus primarily on the context of the generated response. To calculate the similarity for Phi-3-mini, we created a Zero-shot classification layer (which takes 1000 characters) between the prediction and the result to measure similarity more accurately."}, {"title": "C.2 Using RAG", "content": "Given the limitations of LLM context windows, fitting entire datasets directly into the context is impractical. To address this, we utilized Retrieval-Augmented Generation (RAG) (Lewis et al., 2020) to enhance the context by retrieving relevant documents from databases before generating responses. The process involves splitting the documents into semantically relevant chunks using the RecursiveCharacterTextSplitter from the Hugging Face Transformers library, computing embeddings for all chunks with a model like thenlper/gte-small, and storing these embeddings in a vector database using FAISS (Facebook AI Similarity Search). When a question is posed, it is embedded and a similarity search is performed against the vector database to find the closest matching documents. These retrieved documents are then provided as context to the LLMs along with the original question, allowing the LLMs to generate responses augmented with additional context.\nWe used a chunk size of 512 and a top-k value of 3, ensuring the context was trimmed to 2000 characters for conciseness."}, {"title": "C.3 Prompts", "content": "General Question Prompt: \u201cRead the context provided and answer the following question: {question}\"\nContextual Understanding Prompt: \"Based on the information in the context, what can you conclude about the following question? {question}\"\nSummarization Prompt: \"After considering the context below, summarize your answer to this question: {question}\"\nOpinion-Based Prompt: \"Given the details in the context, what is your opinion on the following question: {question}\"\nDetail Extraction Prompt: \"Extract relevant information from the context to answer this question: {question}\"\nFact-Checking Prompt: \"Using the context provided, verify the accuracy of the following statement: {question}\"\nTable 5 shows the average accuracy calculated by comparing the predictions with the ground truth from BoolQ."}, {"title": "A Appendix", "content": ""}, {"title": "A Synthetic Experiments with Matrix Factorization", "content": "To understand the impact of regularization terms in Eq. (7), we perform a simple synthetic experiment. We create a matrix of random p(y|q) (uniformly between 0 and 1) for m = 5 queries and decompose it to identify the impact of 3 sources. We vary the regularization terms $$\\pi = \\lambda_P K \\in [0,10^{-4}, 10^{-3}, 10^{-2}, 10^{-1},1]$$. We repeat the experiments with randomly initialized bmr and PK for 100 times and report the variations in the solutions for \u03c0. The variation is measured as the sum of the eigenvalues of the covariance matrix of the solutions (i.e., nuclear norm). Figure 1 recommends choosing the regularization coefficients larger than 0.1 to have stable solutions."}, {"title": "B Algorithms", "content": ""}]}