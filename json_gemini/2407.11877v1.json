{"title": "Bridging Weighted First Order Model Counting and Graph Polynomials", "authors": ["Qipeng Kuang", "Ond\u0159ej Ku\u017eelka", "Yuanhong Wang", "Yuyi Wang"], "abstract": "The Weighted First-Order Model Counting Problem (WFOMC) asks to compute the weighted sum of models of a given first-order logic sentence over a given domain. It can be solved in time polynomial in the domain size for sentences from the two-variable fragment with counting quantifiers, known as C2. This polynomial-time complexity is also retained when extending C2 by one of the following axioms: linear order axiom, tree axiom, forest axiom, directed acyclic graph axiom or connectedness axiom. An interesting question remains as to which other axioms can be added to the first-order sentences in this way. We provide a new perspective on this problem by associating WFOMC with graph polynomials. Using WFOMC, we define Weak Connectedness Polynomial and Strong Connectedness Polynomials for first-order logic sentences. It turns out that these polynomials have the following interesting properties. First, they can be computed in polynomial time in the domain size for sentences from C\u00b2. Second, we can use them to solve WFOMC with all of the existing axioms known to be tractable as well as with new ones such as bipartiteness, strong connectedness, being a spanning subgraph, having k connected components, etc. Third, the well-known Tutte polynomial can be recovered as a special case of the Weak Connectedness Polynomial, and the Strict and Non-Strict Directed Chromatic Polynomials can be recovered from the Strong Connectedness Polynomials, which allows us to show that these important graph polynomials can be computed in time polynomial in the number of vertices for any graph that can be encoded by a fixed C2 sentence and a conjunction of an arbitrary number of ground unary literals.", "sections": [{"title": "Introduction", "content": "Given a first-order logic sentence \u03a8 and n \u2208 N, the first-order model counting (FOMC) problem asks to compute the number of models of \u03a8 over the domain {1,...,n}. FOMC can be used, among others, to solve various combinatorics problems on labeled structures. For instance, the FOMC of the sentence \u03a8 = \u2200x\u2203y(E(x,y) \u2228 E(y,x)) \u2227 \u2200x\u00acE(x,x) corresponds to the number of n-vertex directed graphs with no isolated vertices and no loops. Similarly, the FOMC of \u03a6 = \u2200x\u00acE(x,x) \u2227\u2200x\u2200y (E(x,y) \u2192 E(y,x)) \u2227 \u2200x\u2203=kyE(x,y) equals the number of k-regular graphs on n vertices where \u2203=ky is a counting quantifier restricting the number of y satisfying E(x,y) = T to exactly k for each x.\nThe weighted variant of the FOMC problem, known as the weighted first-order model counting (WFOMC) problem, additionally expects a specification of positive and negative weights for predicates in the language, which are then used to assign weights to models. In WFOMC, the task is to compute the sum of the weights of the given sentence's models.\u00b9 WFOMC has applications in Statistical Relational Learning (SRL) [GT07]. For instance, Markov Logic Networks (MLN) [RD06], one of the most popular SRL formalisms, model relational data by a distribution over possible worlds, where the computation of the partition function (equivalent to probabilistic inference in MLN) is reducible to WFOMC [dB11].\nA key issue regarding WFOMC is its computational complexity. Generally, there is no hope of devising algorithms for WFOMC that would scale polynomially with the size of the first-order logic sentences under reasonable assumptions, since it can be reduced from #SAT. This is true even for very simple fragments such as the one-variable fragment FO\u00b9, which contains sentences with at most one logical variable. Therefore, most of the focus in this area has been on identifying fragments containing first-order logic sentences for which WFOMC can be computed in time polynomial in the size of the domain (but not necessarily in the size of the sentence). The term coined for this kind of tractability by [dB11] is domain liftability\u2014it is an analog to data complexity [Var82] from database theory. Domain liftability also means that enumerative combinatorial problems can be solved in time polynomial in the size of the structures being counted.\nThe first positive results regarding the tractability of WFOMC came from the two seminal papers [dB11, dBMD14], which together established domain liftability of the two-variable fragment of first-order logic FO2. This was quickly complemented by a hardness result [BdBGS15], showing that WFOMC for the three-variable fragment FO\u00b3 is not domain-liftable (under plausible complexity-theoretic assumptions). However, this does not mean that the frontiers of tractability cannot be pushed beyond FO\u00b2. For instance, the two-variable fragment with counting quantifiers C\u00b2 [GOR97] (e.g., the above sentence of a k-regular graph) with cardinality constraints (i.e., the restrictions to the number of true ground atoms for relations), which is strictly more expressive than FO\u00b2, was shown to be domain-liftable in [Kuz21]. Other works [dBD12, WPWK24] proved domain-liftability when attaching unary evidence (i.e., a series of ground unary literals) to these fragments.\nOne strategy for discovering new tractable fragments is to add extra axioms, which may or may not be finitely expressible in first-order logic. This approach was first explored in [KL18] where it was shown that adding a single functionality axiom to FO2 results in a domain-liftable fragment.\u00b2 Subsequent works extended domain liftability to the fragments C\u00b2 + Tree [vBK23] and C2 + LinearOrder [TK23], which are obtained by adding to C2 an axiom specifying that a distinguished relation R should correspond to an undirected tree or to a linear order, respectively."}, {"title": "Our Contribution", "content": "In this paper, we take a different route inspired by graph polynomials. We consider C2 possibly extended by cardinality constraints and unary evidence, denoted by extended C\u00b2. We introduce several polynomials that we associate to first-order logic sentences and show that they can be computed efficiently for extended C2 sentences, which extends the domain-liftability to WFOMC for several new axioms (as well as for all of the old ones) and enables the efficient computation of the Tutte polynomial for any graph that can be encoded by certain first-order fragments.\nWe first define the Weak Connectedness Polynomial (WCP) as a univariate polynomial of u for any first-order sentence \u03a8 with domain size, a pair of weighting functions, and a distinguished binary relation R. Roughly speaking, it is the sum over the weight of each possible graph interpreting R (i.e., a graph denoted by G(R) obtained by regarding each R(a,b) = T as an edge a \u2192 b) multiplied by a term of u indicating the number of its weakly connected components. The WCP can be regarded as a classification of all possible G(R) by the number of connected components and, therefore, captures the information of the connectedness of models.\nWe then incorporate edge orientations by defining two Strong Connectedness Polynomials (SCPs), namely Non-strict Strong Connectedness Polynomial (NSCP) and Strict Strong Connectedness Polynomial (SSCP), which are intuitively the sum over the weight of each possible G(R) multiplied by the non-strict and strict directed chromatic polynomials respectively, so that they embrace the operations of directed chromatic polynomials. As an extension of WCP, we also define Multi- relation Weak Connectedness Polynomial (MWCP) for multiple distinguished binary relations under the conditions that the relations are nested.\nThe polynomials are formally defined in the language of first-order logic such that the evaluation of the polynomials at each positive integer point is equivalent to the WFOMC of a certain sentence. Therefore a natural way to obtain the polynomials is to evaluate the polynomials at a sufficiently large number of points and recover the polynomials by interpolation. However, existing algorithms for WFOMC can not solve these resulting WFOMC problems in polynomial time data complexity, as in our case, the length of the sentences depends on the domain size n and the runtime of these algorithms can be exponential in the length of the sentence."}, {"title": "Polynomials for WFOMC", "content": "We further adapt the existing framework for WFOMC of FO\u00b2 sentences to dynamic programming algorithms involving insight into the structure of our WFOMC queries, hence we show that all these polynomials can be computed in polynomial time in the domain size.\nProposition 1.1 (Summary of Propositions 3.3, 4.3, 4.4 and 6.1). Computing WCP, NSCP and SSCP for a given extended 2 sentence, a domain of size n, a distinguished binary relation, and weighting functions can be computed in polynomial time in n.\nMoreover, computing MWCP for a given extended C\u00b2 sentence, a domain of size n, a sequence of distinguished nested binary relations, and weighting functions can be computed in polynomial time in n.\nWith the help of polynomials for WFOMC, we can tackle several counting tasks efficiently.\nThe first task is WFOMC for an extended C2 sentence associated with axioms, the special constraints on G(R) that it should be a certain combinatorial structure. It can be generalized to multiple relations R\u2081,\u2026\u2026, Rk such that G(R1),\u2026\u2026,G(Rk) satisfy additional internal restrictions. As the polynomials allow us to obtain knowledge of combinatorial structures using similar operations as graph polynomials, this gives rise to the domain-liftability of new axioms (such as the bipartite axiom), generalization of the existing axiom (such as connectedk from the connected axiom), and incorporation of the existing axioms (such as the tree axiom). The main axioms for which we prove domain-liftability are listed in Table 1.\nTheorem 1.1. The fragment of extended C\u00b2 with any single axiom in Table 1 is domain-liftable.\nMoreover, we can give domain-liftability to the combination of axioms in Table 1. Table 2 offers a comprehensive list of potential axioms by combining the existing axioms. All of them are new axioms that have not been shown to be domain-liftable before. A common challenge in prior research was the individual treatment of axioms using specific techniques, which made their combination a non-trivial task. However, our methodology seamlessly integrates these axioms through a unified polynomial that encapsulates the structural characteristics of the graphs.\nTheorem 1.2. The fragment of extended C\u00b2 with a single combined axiom in Table 2 is domain- liftable.\nOur approach offers several distinct advantages over existing techniques for individual axioms. First, it is more general, requiring only a polynomial representation for axioms without relying on specific algorithmic techniques for each problem. Second, it enables the use of the same polynomial for multiple axioms. Third, it is more flexible, allowing easy extension to new axioms as long as they can be expressed with polynomials, for instance, requiring G(R) to represent a k-cycle permutation in Example 3.2 or a strongly connected tournament in Example 4.1. Lastly, it establishes a connection between the complexity of graph polynomials and the domain-liftability of WFOMC.\nBesides using the idea of graph polynomials to solve several counting tasks efficiently, conversely, the polynomials for WFOMC make contribution to graph polynomials. We show that the well-known Tutte polynomial [Tut54] can be recovered from the extended version of WCP, and the strict and non-strict directed chromatic polynomials can be recovered from SSCP and NSCP respectively, which allows us to show that these graph polynomials can be computed in time polynomial in the number of vertices for any graph that can be encoded by a fixed C2 sentence with cardinality constraints and unary evidence.\nTheorem 1.3 (Informal summary of Theorem 3.5 and Corollary 4.1). Let G be a graph that can be encoded by a 2 sentence of constant size associated with cardinality constraints and unary evidence. The Tutte polynomial (if G is undirected), the strict directed chromatic polynomial, and the non-strict directed chromatic polynomial of G can be computed in time polynomial in the size of G.\nThe above result answers in the positive way the question in [vBK23] whether calculating the Tutte polynomial of a block-structured graph can be done in time polynomial in the number of vertices. However, this result cannot be extended to computing Tutte polynomial or evaluating any point for a general graph, since the first-order sentence encoding the given graph might not satisfy the condition in the theorem."}, {"title": "Related Work", "content": "We build on several lines of research. First, we build on the stream of results from lifted inference literature which established domain-liftability of several natural fragments of first-order logic [Poo03, dSBAR05, dB11, GD11, dBMD14, BdBGS15, KKVP16, Kuz21]. These works started with the seminal results showing domain-liftability of FO\u00b2 [dB11, dBMD14] and continued by showing domain-liftability of larger fragments such as S2FO2 and S2RU [KKVP16], U\u2081 [KL18] or C\u00b2 [Kuz21]. Second, we build on extensions of these works that added axioms not expressible in these fragments or even in first-order logic such as the tree axiom [vBK23], forest axiom [MBS23], linear order axiom [TK23], acyclicity axiom [MBS23] and connectedness axiom [MBS23]. In this work, we generalize all of these results and add new axioms to this list, showing their domain-liftability. Finally, our work builds on tools from enumerative combinatorics [SS86] and on graph polynomials [Tut04]. The most well-known among graph polynomials is the Tutte polynomial [Tut54] but there exist also extensions of it [AB20], with which we do not work directly in this paper. Computing the Tutte polynomial is known to be intractable in general [JVW90], however, in this work we show that it can be computed in polynomial time for graphs that can be encoded by a fixed sentence from the first-order fragment C2, possibly with cardinality constraints and unary evidence."}, {"title": "Preliminaries", "content": "We introduce our notations and main technical concepts, and provide a brief overview of existing algorithms in this section."}, {"title": "Mathematical Notations", "content": "Throughout this paper, we denote the set of natural numbers from 1 to n as [n]. For a polynomial f(x), the notation [x\u00b2]f represents the coefficient of the monomial x\u00b2.\nAll vectors used in this paper are non-negative integer vectors. For a vector c of length L, |c| denotes the sum of its elements, i.e., $\\Sigma$. When considering two vectors a and b of the same length L, the operation a + b denotes the vector (a1 + b1, a2 + b2,\u2026,aL + bL), and the subtraction is defined similarly. For a vector a and a non-negative integer n, $\\binom{n}{a} = \\frac{n!}{(a)(n-1)... (n-a1-a1-aL-1) = a1a2a!}$ refers to $\\frac{n!}{\u03b11!\u03b12!...\u03b1!}$."}, {"title": "First-Order Logic", "content": "We consider the function-free, finite domain fragment of first-order logic. An atom of arity k takes the form P(x1,\u2026\u2026,xk) where P/k is from a vocabulary of predicates (also called relations), and X1,\uff65\uff65\uff65, xk are logical variables from a vocabulary of variables. 3 A literal is an atom or its negation. A formula is formed by connecting one or more literals together using negation, conjunction, or disjunction. A formula may optionally be surrounded by one or more quantifiers of the form \u2200x or \u2203x, where x is a logical variable. A logical variable in a formula is said to be free if it is not bound"}, {"title": "Weighted First Order Model Counting", "content": "The weighted first-order model counting problem (WFOMC) takes the input consisting of a first- order sentence \u03a8, a domain size n \u2208 N, and a pair of weighting functions (w,w) that both map all predicates in \u00dd to real weights. Given a set L of true or false ground atoms (i.e., ground literals) whose predicates are in \u03a8, the weight of L is defined as W(L,w,w) := \u03a0a\u2208LT W(pred (a)) \u00b7 \u03a0\u03b1\u2208LF W(pred (a)), where LT (resp. LF) denotes the set of true ground (resp. false) atoms in L, and pred (a) maps an atom a to its corresponding predicate name.\nExample 2.1. Consider the sentence \u03a8 = \u2200xy (R(x,y) \u2192 S(y)) and the weighting functions w(R) = 2,W(R) = w(S) = W(S) = 1. The weight of the atoms set\nL = {R(1,1), \u00acR(1, 2), R(2, 1), R(2, 2), S(1), S(2)}\nis w(R) \u00b7 W(R) \u00b7 w(R) \u00b7 w(R) \u00b7 w(S) \u00b7 w(S) = 2 \u00b71\u00b71\u00b71\u00b71\u00b71 = 2.\nDefinition 2.1 (Weighted First Order Model Counting). The WFOMC of a first-order sentence \u03a8 over a finite domain of size n under weighting functions (w,w) is\nWFOMC(\u03a8,n,w,w) := \u2211 W(\u03bc, \u03c9, \u03c9).\n\u03bc\u0395\u039c\u03a8, n\nSince these weightings are defined on the predicate level, all groundings of the same predicate get the same weights. For this reason, the notion of WFOMC defined here is also referred to as symmetric WFOMC.\nExample 2.2. Consider \u03a8 = \u2200x\u2203y R(x, y), and let w(R) = 1,W(R) = 1. Then WFOMC(\u03a8, n,w,w) = (2n - 1) because for each domain element i \u2208 [n], there are 2n 1 ways to choose the truth assignment of R(i, 1), R(i, 2), ..., R(i,n) that make \u2203y R(i,y) satisfied, and there are n domain elements. For another example, consider the sentence \u03a8 and the weighting functions (w,w) in Example 2.1. One may check that WFOMC(\u03a8,n,w,w) = (3\u2033 + 1)n.\nThe weighted model counting problem (WMC) is defined similarly but the input formula is a ground propositional sentence.\nDefinition 2.2 (Weighted Model Counting). The WMC of a ground propositional sentence \u0424 under weighting functions (w,w) is\nWMC(\u03a6,w,w) := \u2211 W(\u03bc, \u03c9, \u03c9),\nwhere Mo denotes the set of all models of \u0424."}, {"title": "Data Complexity of WFOMC", "content": "We consider the data complexity of WFOMC: the complexity of computing WFOMC(\u03a8,n,w,w) when fixing the input sentence \u03a8 and weighting (w, W), and treating the domain size n as an input encoded in unary.\nDefinition 2.3 (Domain-liftability [dB11]). A sentence, or class of sentences, that enjoys polynomial- time data complexity is said to be domain-liftable.\nBuilding on [dB11, dBMD14], in [BdBGS15, Appendix C], it was shown that any sentence with at most two logical variables (FO\u00b2) is domain-liftable by devising a polynomial-time algorithm for computing WFOMC(\u03a8,n,w,w) for any FO2 sentence and any weighting (w,w).\nHere we briefly describe this algorithm, as some of its concepts are important in this paper. We mostly follow the notation from [vBK21]. Any sentence in FO2 can be reduced to the prenex normal form with only universal quantifiers (i.e., \u2200x\u2200y \u03c8(x,y), where (x, y) is a quantifier-free formula) by the normalization in [GKV97] and the technique of eliminating existential quantifiers in [dBMD14]. The reduction respects the WFOMC value, and hence in what follows, we assume that the input sentence is in the form \u2200xy \u03c8(x,y). We first need the notion of a 1-type.\nDefinition 2.4 (1-type). A 1-type of a first-order sentence \u03a8 is a maximally consistent se\u0165 of literals formed from atoms in \u00dd using only a single variable x.\nFor example, \u03a8 = \u2200x\u2200y (F(x) \u2227 G(x, y)) has four 1-types: F(x) \u2227 G(x,x), F(x) \u2227 \u00acG(x,x), \u00acF(x)\u2227G(x,x) and \u00acF(x) \u2227 \u00acG(x,x). Intuitively, a 1-type interprets unary and reflexive binary predicates for a single domain element.\nLet C1(x), C2(x),\u2026\u2026, CL(x) be all the 1-types of \u03a8. When we consider domain-liftability, the sentence is fixed and therefore L is a constant. We partition domain elements into 1-types by enumerating the configuration c = (C1, C2,\u2026\u2026,CL), a vector indicating the number of elements partitioned to each 1-type, since in the symmetric WFOMC only the configuration matters. Then we can rewrite \u03a8 as\nn = \u2227 \u2200x \u2208 Ci\u2200y \u2208 Cj(\u03c8(x,y) \u2227 \u03c8(y, x))\n1<i<j<L\n\u2227\u2227 \u2200x \u2208 Ci\u2200y \u2208 Ci \u03c8(x, y).\n1<i<L\nSince we know the truth values of the unary and reflexive binary atoms of each 1-type, we may simplify the body of each conjunct by substituting every unary and reflexive binary atom with true or false as appropriate. Denote by Vi(x, y) the simplification of f(x,y) when both x and y belong to the same 1-type Ci, and by Vij (x, y) the simplification of f(x,y) \u2227\u03c8(y, x) when x and y belong"}, {"title": "Domain-liftability of Extended C2", "content": "to Ci and Cj respectively. We then have:\nn = \u2227 \u2200x \u2208 Ci\u2200y \u2208 Cj Vij (x, y)\n1<i<j<L\n\u2227\u2227 \u2200x \u2208 Ci\u2200y \u2208 Ci Vi(x, y).\n1<i<L\nAn important property here is that each conjunct is independent of others since no two conjuncts involve the same ground binary atom. Let\nri,j = WMC(Vi,j(a,b),w,w),\nsi = WMC(Vi(a, b) \u2227 \u03c8\u2081(b,a), w,w).\nThen we have\nWFOMC(\u03a8, n, w, W) = \u2211 $\\tbinom{n}{c}$ \u03a0 W(C\u2081,w,w).s$\nwhich can be calculated in polynomial time in n.\nThe above algorithm also serves as the basis of a WFOMC algorithm for C2 (the FO2 sentence with counting quantifiers \u2203=k, \u2203 and \u2203>k) together with cardinality constraints and unary evidence. The counting quantifiers allow us to express concepts such as \"each vertex in the graph has exactly two outgoing edges\", i.e., 2-regular graphs, by the sentence \u2200x\u2203=2y E(x,y), where E/2 is a binary predicate representing the edge relation. The cardinality constraint is in the form of |P| \u2709 k, where P is a predicate and is a comparison operator {<, <, =, >, >}. These constraints are imposed on the number of distinct positive groundings of P in a model. For example, |Eq| = n means that there are exactly n distinct groundings of Eq in a model, and the sentence \u2200x Eq(x,x) \u2227 |Eq| = n along with a domain of size n encode an identity relation Eq. Unary evidence is a set of ground unary atoms that specify the interpretation of unary predicates for some domain elements. For better exposition, we use extended C\u00b2 to refer to the fragment of C2 with cardinality constraints and unary evidence.\nDefinition 2.5 (Extended C\u00b2). An extended C\u00b2 sentence is a C\u00b2 sentence possibly with cardinality constraints and unary evidence.\nCounting quantifiers, cardinality constraints, and unary evidence are useful to encode certain properties of graphs. An example is using cardinality constraints to encode the identity relation Eq as mentioned above. We present another example of using unary evidence to encode a block- structured graph in the following."}, {"title": "Axioms", "content": "Example 2.4. A block-structured graph is an undirected graph G = (V,E) where vertices are partitioned into a constant number of blocks, and for every two blocks V1, V2, either \u2200x \u2208 V\u2081\u2200y \u2208 V2, (x, y) \u2208 E or \u2200x \u2208 V\u2081\u2200y \u2208 V2, (x,y) \u2209 E. With unary evidence, we can encode a block-structured graph in the following way: we introduce a fresh unary predicate Blocki for each block Vi, and let\n\u03a8\u0392 = \u2227 \u2200x\u2200y (Blocki(x) \u2227 Blockj(y) \u2192 E(x, y))\nVi, Vj are connected\n\u2227 (Blocki(x) \u2227 Blockj(y) \u2192 \u00acE(x,y))\nVi,Vj are not connected\nn\n\u2227 \u2227(Block) (i) (i) Block(i)\ni=1 j\u2260v(i)"}, {"title": "Graph Polynomial", "content": "where v(i) indicates the block that vertex i belongs to, and Block\u2217(i) and \u00acBlock\u2217(i) are unary evidence for vertex i.\nRemark 2.1. When the input sentence of WFOMC involves cardinality constraints and unary evidence, i.e., the sentence is in extended C\u00b2, we need to analyze the data complexity more carefully. In such instances, the C\u00b2 sentence in the input remains fixed, while the parameters of the constraints and the number of facts in the unary evidence, which might depend on the domain size, are considered variable inputs.\nThe presence of counting quantifiers, cardinality constraints, and unary evidence does not change the domain-liftability of FO2 even if the parameters of cardinality constraints and the length of unary evidence depend on the domain size. By the techniques in [Kuz21] and [WPWK24, Appendix A], the WFOMC of an extended C2 sentence can be reduced to the WFOMC of a sentence in FO2 with symbolic weightings, and then solved by the algorithm for FO2. As we will see, all these techniques apply to the methods in this paper. Therefore, in the rest of this paper, we only present the algorithms for FO\u00b2, and the results can be extended to extended C2.\nWhile extended C2 captures numerous graph properties, it falls short in expressing certain important characteristics, such as trees, forests, and strongly connected orientations. In fact, these structures cannot be finitely axiomatized by first-order logic without grounding them out. However, in terms of WFOMC, it is possible to express these properties more succinctly using what we refer to as axioms.\nGiven a binary predicate R, an interpretation for R can be regarded as a directed graph where the domain is the vertex set and R is the edge set, which we call G(R). If a possible world w is specified, the interpretation of R in w is a specific graph, denoted by G(WR).\nAn axiom is a special constraint on the interpretation of a binary predicate R that G(R) should be a certain combinatorial structure. We often write an axiom as axiom(R) where axiom is an identifier of the axiom. For example, in what follows, we will discuss the tree axiom tree(R), which requires G(R) to be a tree, and the forest axiom forest(R), which requires G(R) to be a forest. For better illustration, we treat axioms as atomic formulas in a sentence, and use \u03a8\u039b axiom(R) to denote the sentence \u03a8 with the axiom axiom(R) conjoined. For instance, tree(E) \u2227 \u2200x (Leaf(x) \u2194 \u2203=1y E(x, y)) is a sentence that expresses the concept of trees with a leaf predicate Leaf/1.\nGraph polynomials are a class of polynomials that are defined on graphs and have combinatorial meaning.\nThe Tutte polynomial [Tut54] is one of the most well-known graph polynomials for undirected graphs. Consider an undirected graph G = (V, E), where V is the set of vertices and E is the set of edges. The Tutte polynomial for the graph G is a polynomial in two variables x and y defined as\nTG(x, y) = \u2211(x \u2013 1)cc(A)-cc(E) (y - 1)cc(A)+|A|-|V|,\nwhere cc(A) is the number of connected components considering only edges in A."}, {"title": "Weak Connectedness Polynomial", "content": "The Tutte polynomial holds significant combinatorial meaning. Evaluating the polynomial at specific points reveals various combinatorial properties. For example, TG(1, 1) counts the number of spanning forests of G (specifically, the number of spanning trees if G is connected), and TG(0, 2) counts the strongly connected orientations of G [Ver80]. Substituting a concrete value for only one variable yields another graph polynomial of G. For example, TG(x, 0) corresponds to the chromatic polynomial [Rea68] of G; TG(0, y) corresponds to the flow polynomial [DSS08] of G.\nThe computation of the Tutte polynomial for an arbitrary graph is known to be computationally challenging. Even the evaluation of a specific point of the polynomial is known to be #P-hard, with only a limited number of points being computationally tractable [JVW90].\nThe idea of the chromatic polynomial of a directed graph appeared in [Sta70] though they stated it in terms of ordered sets. Given a directed graph D = (V, E) where n = |V|, let XD(x) be the number of ways of coloring each vertex in D by one of the colors {1,2,...,x} such that if there is an edge from u to v, the color of u is smaller than the color of v. We have the following lemma to state that XD(x) is a polynomial of x.\nLemma 2.1 ([Sta70]). For a directed graph D of size n, let x(i) be the number of surjective colorings of vertices using i colors (i.e., each color should be used at least once) such that if there is an edge from u to v, the color of u is smaller than the color of v. It holds that\nXD(x) = \u2211 Xi x(i) = \u2211 X (x - 1) (x \u2212 i + 1)x(i),\ni=1 i=1 i!\nwhere$\\(x \\\\ i) = 0$ if i > x.\nCorollary 2.1. XD(x) is a polynomial of x of degree n.\nWe call XD(x) the strict directed chromatic polynomial of D. A variant of it is the non-strict directed chromatic polynomial XD(x) where for each positive integer x, XD(x) equals the number of colorings of the vertices in D by one of the x colors {1,2,\u2026\u2026,x} such that if there is an edge from u to v, the color of u is smaller than or equal to the color of v. Similarly to XD(x), XD(x) is also a polynomial of x.\nCorollary 2.2. \u0100D(x) is a polynomial of x of degree n.\nThe relation between XD(x) and XD(x) is given by the following lemma.\nLemma 2.2 ([Sta70, AB20]). Let D be a directed graph and acyc(D) be the directed acyclic graph obtained from D by condensing each cycle into a vertex. Denote the number of vertices in acyc(D) by |V(acyc(D))|. We have\nXD(X) = \\begin{cases}\n(-1)X\\\\D(-x), & \\text{D is acyclic,}\\\\\n0, & \\text{otherwise,}\n\\end{cases}\\\\\nX\\\\D(x) = (-1)^\\left|V(acyc(D))\\right| X\\\\acyc(D)(-x).\nIn this section, we introduce our first polynomial, called Weak Connectedness Polynomial (WCP). The WCP is a univariate polynomial defined on a first-order logic sentence and a distinguished"}, {"title": "Definition", "content": "binary relation. Similarly to graph polynomials, the WCP can also capture various combinatorial properties of the models of the sentence w.r.t. the binary relation. As we show later in this section, WCP can be computed in polynomial time in the domain size for the C2 fragment with cardinality constraints and unary evidence. This property allows us to attach axioms of non-trivial combinatorial structures and complicated weight constraints to the first-order logic sentence and derive Tutte polynomial for certain graphs.\nWe define WCP as a univariate polynomial whose point evaluation at every positive integer u is equal to a weighted first-order model count of a suitable first-order logic sentence parameterized by u.\nDefinition 3.1 (Weak Connectedness Polynomial). Let \u03a8 be a first-order logic sentence possibly with cardinality constraints and unary evidence, w,w be two weighting functions, and R be a distinguished binary relation. Then-th WCP fn(u) of \u03a8 for the relation R is the unique univariate polynomial which satisfies:\nfn(u; \u03a8, w, W, R) = WFOMC(\u03a8R,u, n, w, W)\nfor all positive integers u. Here, the sentence Ru is defined as:\n\u03a8\n=\u03a8\u2227\u2227\u2200xy (Ai(x) ((R(x, y) VR(y,x)) \u2192 Ai(y))\nRu i=1\n\u2227\u2227\u2200x (Ai(x) \u2192 Ai-1(x)),\ni=2\nwhere A1,\u2026\u2026, Au are fresh unary predicates and w(Ai) = W(Ai) = 1.\nIntuitively, by introducing u new predicates A\u2081,\u2026\u2026\u2026, Au, we make each weakly connected component in G(R) contribute a factor of u + 1 to WFOMC. In the rest of the paper, we use cc(\u03bcr) to denote the number of weakly connected components in G(\u03bcr). The most important property of WCP is that it captures cc(\u00b5R), which is stated formally in the following proposition.\nProposition 3.1. For the n-th WCP of the sentence \u03a8, the weighting functions w and w and the binary relation R, it holds that\nfn(u; \u03a8, w, w, R) = \u2211W(\u03bc, \u03c9, \u03c9). (u + 1)cc(pr).\n\u03bc\u0395\u039c\u03a8, n\nProof. By 2 \u2200x (A\u00bf(x) \u2192 Ai\u22121(x)), for each element e in the domain there must be an i' \u2208 [0, u] such that A1(e) = = A\u00bf\u00bf(e) = T and A\u00ef'+1(e) = \u2026Au(e) = 1. Meanwhile, elements whose corresponding vertices form a weakly connected component in G(\u00b5R) must have the same i' since\n\u2200xy (Ai(x) R(x,y) \u2192 A\u00bf(y)).\ni=1\nTherefore, for any model \u03bc of \u03a8, each weakly connected component in G(\u00b5R) has u + 1 choices of i' regardless of the interpretations of other predicates. That is, \u03bc replicates u + 1 times in \u03a8R,u, and the weight of each of these replicas is W(\u03bc,w,w) due to w(Ai) = W(Ai) = 1. Therefore, the WFOMC of Ru is \u03a3\u03bc\u03b5\u039c\u03a8 W (\u03bc, \u03c9, \u03c0) \u00b7 (u + 1)(\u00b5r), which completes the proof."}, {"title": "Fast Calculation", "content": ",\nProposition 3.2. Then-th WCP fn(u; \u03a8,w,w, R) is a univariate polynomial of degree at most n.\nProof. Since cc(\u00b5R) \u2264 n, it follows immediately from Proposition 3.1.\nAs WCP is defined based on WFOMC, it can be also extended to first-order logic sentences with counting quantifiers, cardinality constraints, and unary evidence. The counting quantifiers and unary evidence can be naturally incorporated into the first-order logic sentences. Besides, cardinality constraints are usually treated as atomic formulas in the previous WFOMC literature [Kuz21, MBS23, vBK21], where the satisfaction relation as well as the model definition are extended accordingly.\nExample 3.1. Consider the sentence encoding k-regular graphs:\n\u0424 = \u2200x\u00acE(x,x) \u2227 \u2200x\u2200y (E(x,y) \u2192 E(y, x)) \u2227 \u2200x\u2203=kyE(x,y).\nBy Proposition 3.1, its n-th WCP fn(u; \u03a8,1,1, E) is \u2211g\u2208G(n,k) (u + 1)cc(g), where 1 is the constant weighting function that always returns 1, and G(n,k) is the set of k-regular graphs with n vertices. The coefficients [u\u00b2] fn(u \u2013 1; \u03a8, 1, 1, E) count the number of k-regular graphs with i connected components."}, {"title": "Applications", "content": "Before applying the polynomials in any context, we need to be able to compute them (or at least evaluate them at some points) efficiently. By Proposition 3.2, n + 1 evaluations are sufficient to interpolate the n-th WCP (e.g., by Lagrange Interpolation). Therefore, our task is to evaluate the WCP at u = 0,1,\u2026\u2026, n.\nNote that by definition, evaluating the polynomial at a specific positive integer is a WFOMC query. However, such WFOMC is not readily solvable by existing algorithms (e.g., [BdBGS15, vBK21]) even for the FO2 fragment. In general, the runtime of these algorithms is exponential in the length of the sentence, while the length of the sentence IR,u in the WFOMC query can be as large as the domain size n, hence these algorithms would not lead to polynomial runtime in the domain size. In particular, the algorithm described in Section 2.4 is not sufficient in this case either, as there would be O(2\") 1-types and, consequently, an exponential time data complexity. To this end, we adapt this algorithm into a dynamic programming (DP) style algorithm that exploits the structure of Ru to achieve an efficient calculation of the polynomials for FO2 sentences.\nLet and R be the input FO2 sentence and the binary relation that WCP is defined on. Consider the point evaluation of the WCP at u. Let C1(x), C2(x),\u2026\u2026,CL(x) be the valid 1-types 6 of \u03a8. Due to the definition of IR,u, the valid 1-types of \u03a8R,u must have the form Ci(x) \u2227 C^(x), where C^(x) is defined as\nC(x) = A1(x) A2(x)^... A\u2081(x)^\u00acA\u00a1'+1(x) \u06f8\u06f0\u06f0\u06f0\u06f8\u00acAu(x)\nfor i' \u2208 [u], and\nC\u00f4 (x) = -A1(x)^\u00acA\u2082(x)^\u06f0\u06f0\u06f0\u2227\u00acAu(x).\nWe use the tuple (i,i') to index the 1-type Ci(x) AC(x). Then we have the following observation.\""}, {"title": "Fast Calculation", "content": "We call a 1-type valid if it is satisfiable in some model of the sentence.\nReformulate the WFOMC of \u03a8R,u to the WFOMC of a sentence \u2200x\u2200y $(x,y) in prenex normal form with only universal quantifiers (removing existential quantifiers using the Skolemization technique [dBMD14]). Let $(i,i'),(j,j')(x, y) be the simplification of $(x, y) \u2227 \u0444(y, x) when x and y belong to 1-type (i,i') and (j, j') respectively. Define\nr'(i,i'),(j,j') = WMC($(i,i'),(j,j') (a, b), w,w).\nIt holds that\n(r,j = WMC(Vi,j(a, b), w,w),\n''(i,i'),(j,j') =< \n(r,j = WMC(i,j (a, b) \u2227 \u00acR(a,b) \u2227 \u00acR(b,a), w,w), i' = j',\ni' \u2260 j',\nwhere \u03c8i,j(x,y) is the simplified formula of \u00dd defined in Section 2.3.\nThis observation provides an important insight into the structure of the new 1-types (as shown in Figure 1): we can imagine that the new 1-types of Ru form u + 1 layers, with each layer containing a replica of the original 1-types of \u03a8. If two elements a, b fall in 1-types in the same layer, R(a, b) can be either true or false. But if a and b are located in 1-types in different layers, R(a, b) as well as R(b,a) must be false due to the definition of Ru in Equation (3).\nTherefore, we can perform a \"blocked\" DP, where each block consists of the 1-types in the same layer. We can write the new 1-type configuration as\nC(1,1),, C(L,1),C(1,2),\u00b7\u00b7\u00b7,C(L,2),\u00b7\u00b7\u00b7 ,C(1,4),, C(L,u)\n\u00fb\nwhere c(i,i') is the number of elements in the 1-type (i,i'). For any \u00fb \u2208 [u], we define h\u00fb, (C1,C2,...,CL) to be the weights of 1-types (1,1),\u2026\u2026, (L, 1), \u00b7\u00b7\u00b7, (1, \u00fb), \u2026\u2026\u2026, (L,\u00fb) such that c = =1 C(i,j) for each i \u2208 [L], that is,\nh\u00fb, (C1,C2,...,CL) =$\n(\u03a3\u03af\u03b5[L] Ci)!\n\u03a3\n\u03a0W(Ci, W, W) (i,i').S\nCi =C1\nCi=cL Ni\u2208[L],i'\u2208[\u00fb] C(i,i')!\n((i)) ((i), (,", "algorithm": "nh\u00fac = \u2211()h\u00fb\u22121,\u0113\u00b7 Win \u00b7 Win (c*) \u00b7 Wcross (\u0113, c*),"}, {"title": "Applications", "content": "where recall that c+ c* = c means that \u0113i + c = c\u00a1 for each i \u2208 [L],\nWin (c*) = (c) \u03a0W (Ci, w, w).s\ni=1\nis the weight within layer \u00fb, and\nWcross (\u0113, c*) = \u03a0\u03a0 ()\ni=1 j=1\nis the weight between the layer \u00fb and the layers before \u00fb. The initial values are ho,c = Win(c) for each c. The final WFOMC of IR,u can be obtained by:\nWFOMC(\u03a8R,u, n, w, w) = \u2211 hu,c\n|c|=n\nThe new DP algorithm is summarized in Algorithm 1, where interpolate_1d(...) takes n+1 points as input and returns the corresponding polynomial of degree n.\nAlgorithm 1: Computing the WCP\nInput: Sentence \u03a8, weighting functions w,w, the relation R, domain size n\nOutput: fn(u; \u03a8, w,w, R)\nho,c \u2190 Win(c) for each |c| \u2264 n\nevaluation_pairs \u2190 {(0, \u2211|c|=n ho,c)}\nfor u\u2190 1 to n do\nforeach c such that |c| \u2264 n do\nhu,c \u2190\u2211(c) hu-1, Win (C*). Wcross(c, c*)\nevaluation_pairs \u2190 evaluation_pairs \u222a {(u, \u2211|c|=n hu,c)}\nf interpolate_1d(evaluation_pairs)\nreturn f\n> c = (C1,\u2026\u2026,CL)\nProposition 3.3. Computing WCP for a given extended 2 sentence, a domain of size n, a distinguished binary relation, and weighting functions can be computed in polynomial time in n.\nProof. As discussed in Section 2.4, any WFOMC problem for extended C2 sentences can be reduced to WFOMC of an FO2 sentence, which can be solved in polynomial time in n by the algorithm presented above. The interpolation step from n + 1 point evaluations to the polynomial can also be done in polynomial time in n, completing the proof.\nIn this section, we show how WCP can be used for computing WFOMC of extended C2 sentences with several combinatorial axioms in polynomial time, i.e. we show that the fragments together with each of these axioms are domain-liftable. Some of these axioms were previously shown to be domain- liftable (e.g., connectedness axioms [MBS23], tree axiom [vBK23] and forest axiom [MBS23]), while for others we show their domain-liftability for the first time (e.g., generalized connectedness axiom"}, {"title": "Applications", "content": "and bipartite axiom). We also show that WCP allows us to efficiently compute Tutte polynomial of any graph that can be encoded by an extended C2 sentence, e.g., block-structured graphs.\nMost of the axioms in this section require some binary relation R to be symmetric and irreflexive. In this case, we append \u2200x\u2200y (R(x,y) \u2192 R(y,x))\u2227\u2200x\u00acR(x,x) to the input sentence \u03a8, and interpret the graph G(R) as a simple undirected graph. We denote the new sentence by R.\nWe first show how WFOMC with several existing and new combinatorial axioms can be computed using WCP.\nAs in Proposition 3.1, WCP associates the weight of each model with a term indicating the number of connected components in G(R), therefore we can restrict the number of connected components of G(R). The k-connected-component axiom to the binary predicate R, denoted by connectedk(R), requires R to be symmetric and G(R) to consist of exactly k connected components. As a special case, connected\u2081(R), which represents that G(R) is an undirected connected graph, i.e., has just one connected component, was already shown to be domain-liftable in [MBS23]. Here we generalize their result to connectedk(R).\nTheorem 3.1. The fragment of extended C\u00b2 with a single k-connected-component axiom is domain- liftable.\nProof. Consider an extended C\u00b2 sentence \u03a8, a domain of size n, the weighting functions w,w, and a distinguished binary predicate R. By Proposition 3.1, we have that WFOMC(\u03a8\u0245connectedk(R), n, w,w) is equal to [uk]fn(u \u2013 1; \u03a8R, W,W, R).\nThe bipartite axiom to the binary predicate R, denoted by bipartite(R), requires R to be symmetric and G(R) to be a bipartite graph7.\nTheorem 3.2. The fragment of extended 2 with a single bipartite axiom is domain-liftable.\nProof. Consider an extended C\u00b2 sentence \u03a8, a domain of size n weighting functions w,w, and a distinguished binary predicate R. We need another two predicates to represent the bipartite graph. Define\n\u03a8\u044c =\u03a8\u20a8 \u2227 \u2200x ((P\u2081(x) \u2228 P2(x)) ^ (\u00acP\u2081(x) \u2228 \u00acP2(x)))\n\u2227\u2200x\u2200y (((P\u2081(x) \u2227 P\u2081(y)) \u2228 (P2(x) \u2227 P2(y))) \u2192 \u00abR(x,y)),\nwhere w(P\u2081) = v(P\u2081) = w(P2) = I(P2) = 1. The predicates P1, P2 divide domain elements into two groups to ensure that G(R) is a bipartite graph. However, overcounting occurs since for every connected component in the bipartite graph, we have two choices of assigning vertices to P\u2081 and P2. Hence, for each connected component, we need to multiply the WFOMC by a factorto its weight, which can be done using WCP:\nWFOMC(\u03a8 / bipartite(R), n,w,w) = \u2211 W(\u03bc, \u03c9, \u03c9). (2)cc(pr) = fn (--; \u03a8, w, W, R)."}, {"title": "The tree axiom", "content": "Note that bipartite graphs are not finitely axiomatizable in first-order logic by the compactness theorem.\n[vBK23] to the binary predicate R (denoted by tree(R)) requires R to be symmetric and G(R) to be a tree. To handle the tree axiom, we extend the ability of WCP to classify the models of a sentence by both the number of connected components in G(R) and the number of edges in G(R) by introducing a new variable to the weight of R.\nDefinition 3.2. With the notations in Definition 3.1, the extended WCP of \u03a8 is defined as a bivariate polynomial such that for all positive integers u and all real numbers v,\nfn (u, v; \u03a8, w,w, R) = WFOMC(\u03a8R,u, n, WR,v, W),\nwhere WR,v(R) = w(R) \u00b7 v, and wr,v(P) = w(P) for any other predicate P.\nCorollary 3.1 (Corollary from Proposition 3.1). For the sentence \u00dd containing the symmetric binary relation R, a domain of size n, and the weighting functions w,w, we have\nfn(u, v; \u03a8, w, W, R) = \u03a3 W (\u03bc, \u03c9, \u03c0)\u00b7 (u + 1)cc(pr)v2e(r),\n\u03bc\u0395\u039c\u03a8, \u03b7\nwhere cc(\u00b5r) is the number of connected components of G(\u00b5R) and e(\u00b5r) is the number of undirected edges8 of G(\u00b5r).\nWith the above corollary, we can show that the tree and forest axioms are domain-liftable.\nTheorem 3.3. The fragment of extended C\u00b2 with a single tree axiom is domain-liftable.\nProof. Consider an extended C\u00b2 sentence \u03a8, a domain of size n, weighting functions w,w and a distinguished binary predicate R. By definition, the tree axiom requires that G(R) should be connected and the number of edges in G(R) should be n \u2212 1. By Corollary 3.1, we have\nWFOMC(\u03a8\u0245tree(R), n, w, w) = [uv2(n-1)] fn(u \u2013 1, v; \u03a8\u03ba, W,W, R).\n[MBS23] to the binary predicate R (denoted by forest(R)) requires R to be symmetric and G(R) to be a forest. Similar to the tree axiom, we can also represent that the forest axiom is domain-liftable by Corollary 3.1.\nTheorem 3.4. The fragment of extended C\u00b2 with a single forest axiom is domain-liftable.\nProof. Consider an extended C\u00b2 sentence \u03a8, a domain of size n, weighting functions w,w and a distinguished binary predicate R. By definition, the forest axiom requires the number of edges in G(R) to be equal to the difference between the number of vertices in G(R) and the number of connected components in G(R). By Corollary 3.1, we have\nWFOMC(\u03a8 / forest(R), n, w, w) = \u2211 [u\u00b2v2(n-i)] fn (u \u2013 1, v; \u03a8\u03ba, \u03c9, \u03c9, R).\ni\u2208[n]"}, {"title": "Strong Connectedness Polynomials", "content": "Remark 3.1. The tree axiom and the forest axiom have already been shown to be domain-liftable in [vBK23] and [MBS23] respectively. Nevertheless, our method provides a more flexible command of the graph structures. For example, it is easy to add further constraints on the number of trees in the forest by our method.\nHere, as R is symmetric, G(\u00b5R) is interpreted as an undirected graph, and the number of undirected edges is equal to half the cardinality of R in \u00b5. It is where the number 2 in the exponent comes from.\nThe strong expressive power of extended C2 fragment and the axioms above allows us to represent many interesting combinatorial problems as well as Statistical Relational Learning (SRL) problems that can be solved in polynomial time.\nExample 3.2. Consider a permutation P1,...,Pn over [n], where pi is the position of i in the permutation. The permutation can be regarded as a directed graph with several disjoint cycles if we add an edge from i to pi for each i \u2208 [n]. Counting the number of permutations with exactly k cycles is a well-known combinatorial problem whose solution is given by the unsigned Stirling numbers of the first kind. This problem can be readily solved by the k-connected-component axiom, where we allow the binary relation R to be asymmetric. More precisely, we add the k-cycle-permutation axiom to the binary predicate R, denoted by perm\u3047(R), which requires G(R) to be the graph corresponding to a permutation with exactly k cycles. Given an extended C\u00b2 sentence \u03a8, a domain of size n, weighting functions w,W and a distinguished binary predicate R, WFOMC(\u03a8 > permk(R), n, w,w) is domain-liftable. In fact, let\n\u03a8p = \u03a8 > \u2200x\u2203=1y R(x,y) \u2227 \u2200x\u2203=1y R(y,x).\nThen we have\nWFOMC(\u03a8 > perm\u2081(R), n, w, w) = [uk]fn(u \u2013 1; \u03a8p, w,w, R).\nFor SRL problems, we can express hard constraints on some relation by adding axioms to the relation, e.g., expressing a company hierarchy with the tree axiom, and player matching in a game with the bipartite axiom. In the following example, we show that more complex soft constraints can also be expressed with WCP.\nExample 3.3. In a social network, one may want to model the compactness in terms of a symmetric relation friends by the number of connected components in G(friends). In this case, a real number d might be used to represent the degree of compactness: the larger d means that the network is more compact, i.e., the number of connected components in G(friends) is smaller. This can be achieved by defining the weight of a possible world w as W (w,w,w) \u00b7 exp(-d.cc(wfriends)). Then the reduced WFOMC of the inference problem is equal to fn (exp(-d) \u2013 1; \u03a8, w,w, friends), where \u03a8 and (w,w) are the sentence and weighting functions modeling other aspects of the social network."}, {"title": "From WCP to Tutte Polynomial", "content": "We can further use the extended WCP in Definition 3.2 to obtain the well-known Tutte polynomial of graphs that can be encoded by a fixed C2 sentence with cardinality constraints and unary evidence. Note that the size of the C2 sentence should be fixed to a constant independent of the graph size while the parameters for cardinality constraints and the size of unary evidence are unbounded.\nThe weighting functions are all set to 1 (i.e., a function always returns 1) in the rest of this section.\nTheorem 3.5. Let S1, S2,\u2026\u2026 be an infinite sequence of sets of undirected graphs where each graph in Sn has n vertices. Suppose that there is a fixed 2 sentence \u03a8 with a distinguished symmetric binary relation E such that for each n and each G in Sn, there is an extended C\u00b2 sentence \u03a8G obtained by \u03a8 conjuncted with cardinality constraints and unary evidence, and G is isomorphic to G(\u03bc\u03b5) for each model \u03bc \u2208 \u039c\u03c8\u04ab,n.9 Then the Tutte polynomial of any G in any Sn can be computed"}, {"title": "Definition", "content": "For instance, [KSS22] gave the characterization of such graphs when the sentence is restricted to be in C2. Note that in their work the counting parameters and the size of the sentence are unbounded while in our case they should be constant to apply the fast calculation of WCP.\nas follows in time polynomial in n:\nT(x,y) = fn ((x - 1)(y \u2212 1) \u2212 1, \u04af\u221ay \u2013 1; \u04b8\u0442(G), 1, 1, R)/(x \u2013 1)\u0441\u0441(\u043d\u0435) (\u0443 \u2013 1)\"WFOMC(\u03a8G, n, 1, 1)\nwhere \u03a8\u0442(G) = \u03a8G > \u2200x\u2200y ((R(x,y) \u2192 E(x,y)) ^ (R(x, y) \u2192 R(y,x))).\nProof. Denote the edges of G(\u03bc\u03b5) by E. By Corollary 3.1, we have\n fn ((x \u2013 1)(y \u2212 1) \u2212 1, \u221ay \u2013 1; \u03a8r(G), 1, 1, R)= \u2211(x - 1)cc('R) (y - 1)cc(HR)+e('r)/=WFOMC(IG, n, 1, 1). \u2211 (x \u2013 1)cc(A) (y \u2212 1)cc(A)+|A|=WFOMC(\u03a8G, n, 1, 1) (x \u2013 1)cc(\u03bc\u03b5) (y \u2212 1)n. TG(x, y),\nwhere TG(x, y) is the Tutte polynomial of G defined in Section 2.6.\nBy Proposition 3.3, computing fn ((x \u2013 1)(y \u2212 1) \u2212 1, \u221ay \u2013 1; \u03a8\u0442(G), 1, 1, R) is in polynomial time in n. WFOMC(\u03a8G, n, 1, 1) is domain-liftable by the algorithm described in Section 2.4 as well. Therefore, we can obtain T(x, y) in time polynomial in n.\nExample 3.4. We can get the Tutte polynomial for a simple complete graph of any size n. Let Sn be the set consisting the only complete graph Gn of n vertices and define\n\u03a8 = \u2200x\u00acE(x,x),\n\u03a8Gn = \u03a8 \u039b |E| = n(n \u2212 1).\nfor each Gn.\nThen \u03a8Gn consists a unique model \u03bc over the domain of size n such that G(\u03bc\u03b5) is identical to Gn. Therefore,\nfn ((x - 1)(y \u2212 1) \u2212 1, \u221ay \u2013 1; \u03a8\u0442(Gn), 1, 1, R)/(x - 1)(y - 1)n\nis the Tutte polynomial of the complete graph of size n, which can be computed in polynomial time in n by Theorem 3.5.\nExample 3.5. Consider the Tutte polynomial of a block-structured graph defined in Example 2.4. We first fix the number k of blocks and the connection among blocks. Let Sn be the set of block- structured graphs of k blocks and n vertices and define similarly to Equation (2):\n\u03a8 = \u039b (Blocki(x) \u2227 Blockj(y) \u2192 E(x, y))\nVi, Vj are connected\n\u039b (Blocki(x) \u2227 Blockj(y) \u2192 \u00abE(x,y)),\nVi, V; are not connected\nG = \u03a8 \u039b \u039b (Block()()Block)\n=\u03a8\u039b\ni=1\nfor each Gn in each Sn. Then, the Tutte polynomial of Gn is\nfn ((x - 1)(y \u2212 1) \u2212 1, \u221ay \u2013 1; \u03a8\u0442(Gn), 1, 1, R)/(x - 1)cc(Gn) (y - 1)n\""}, {"title": "Strong Connectedness Polynomials", "content": "By Theorem 3.5, the Tutte polynomial of Gn can be computed in polynomial time in n. Applying the same proof to any constant k and any possible connection among blocks, we conclude that the Tutte polynomial of any block-structured graph can be computed in polynomial time in the size of the graph.\nThe above result answers the question in [vBK23] whether calculating the Tutte polynomial of a block-structured graph is hard. However, we remark that this result cannot be extended to computing Tutte polynomial or evaluating any point for a general graph as representing a general graph by a first-order sentence involves a list of binary evidence (i.e., a set of ground literals of arity 2), making the WFOMC task #P-hard [dBD12]. Therefore we are consistent with the hardness of Tutte polynomial.\nThe polynomial WCP is insensitive to the orientation of the edges of G(R), where R is the distinguished relation. Hence, with WCP we can only define axioms that do not depend on the orientation of the edges of the graph G(R). In this section, we define two new polynomials, Strict Strong Connectedness Polynomial (SSCP) and Non-strict Strong Connectedness Polynomial (NSCP), that use the orientation of the edges as well. Both polynomials are collectively referred to as Strong Connectedness Polynomials (SCPs). We show that these new polynomials can be used to enforce several axioms, some of which have not been known to be domain-liftable before.\nThe definitions of SCPs are similar to WCP except that we need another sequence of unary predicates to characterize the strong connectedness in G(R).\nDefinition 4.1 (Strong Connectedness Polynomials). Let \u03a8 be a first-order logic sentence possibly with cardinality constraints and unary evidence, w and w be two weighting functions and R be a distinguished binary relation. The n-th Strict Strong Connectedness Polynomial (SSCP) gn(u, v) of \u03a8 for the relation R is the unique bivariate polynomial which satisfies:\ngn (u, v; \u03a8, \u03c9, \u03c9, R) = WFOMC(\u03a8R,u,v, n, w, W)\nfor all positive integers u, v, where \u03a8R,u,v is defined as:\nu\n\u03a8R,u,v = \u03a8\u039b\u039b\u2200xy (A\u00bf(x)^ (R(x,y) \u2228 R(y,x)) \u2192 Ai(y))\ni=1\nu-1\n^^\u2200x (Ai(x) \u2192 Ai-1(x))\ni=2\n^^\u2200xy (Bi(x)^R(x,y) \u2192 Bi+1(y))\ni=1\n\u2227\u2200x\u2200y (R(x, y) \u2192 \u00acB\u2084(x))\n\u03c5\n^^x (Bi(x) \u2192 Bi-1(x))\ni=2\nwhere Ai's and Bi's are fresh unary predicates and w(Ai) = w(Ai) = w(B\u00bf) = w(Bi) = 1."}, {"title": "Fast Calculation", "content": "The n-th Non-strict Strong Connectedness Polynomial (NSCP) \u011dn(u, v) of \u03a8 for the relation R is the unique bivariate polynomial which satisfies:\n\u011dn (u, v; \u03a8, w, w, R) = WFOMC(\u012aR,u,v, n, w, W)\nfor all positive integers u, v, where \u012aR,u,v is defined as:\nu\n\u012aR,u,v = \u03a8\u039b\u039b\u2200xy (A\u00bf(x)^ (R(x, y) VR(y, x)) \u2192 Ai(y))\ni=1\nu\n^^ \u2200x (Ai(x) \u2192 Ai-1(x))\ni=2\n^^\u2200xy (Bi(x)^R(x,y) \u2192 Bi(y))\ni=1\nu\n^^x (Bi(x) \u2192 Bi-1(x))\ni=2\nwhere Ai's and Bi's are fresh unary predicates and w(Ai) = W(Ai) = w(Bi) = v(Bi) = 1.\nThe predicates A1,\u2026, Au treat R symmetrically and are defined similarly as those in WCP. As discussed in Proposition 3.1, we can imagine them as capturing the information about weakly connected components of G(R). The predicates B\u2081,\u2026\u2026, Bcapture the directionality of edges in G(R), enabling further directed axioms on R. We give an interpretation of both polynomials by the following proposition and present more properties and applications in Section 4.3.\nProposition 4.1. For the n-th SSCP and the n-th NSCP of the sentence \u03a8, the weighting functions w and w and the binary relation R, it holds that\ngn(u, v; \u03a8, w,w, R) = \u2211 W(\u03bc, \u03c9,\u03c0)\u00b7 (u + 1)cc(MR). XG(\u00b5R) (V + 1),\n\u03bc\u0395\u039c\u03a8, \u03b7\n\u011dn(u, v; \u03a8, w,w, R) = \u2211W(\u03bc, \u03c9, \u03c0)\u00b7 (u + 1)cc(pr). XG(\u00b5r) (V + 1),\n\u03bc\u0395\u039c\u03a8, \u03b7\nwhere cc(pr) is the number of weekly connected components of G(\u00b5R), and XG(\u00b5r) and XG(\u00b5r) are the strict and non-strict directed chromatic polynomials of G(\u00b5r) respectively.\nProof. We first prove the proposition for SSCP. Following the same argument in the proof of Proposition 3.1, for any model \u03bc' of \u03a8R,u,v, we can think of \u03bc' as an extension of a model \u03bc of \u03a8 with the same weight, where the interpretation of Ai's and Bi's are determined by choosing labellings i' \u2208 [u] and i\" \u2208 [v] for each domain element. Therefore, the polynomial gn (u, v; \u03a8, w, W, R) must be of the form \u03a3\u03bc\u03b5\u039c\u03c8\u03b7 W (\u03bc, \u03c9, \u03c0) \u00b7 (u + 1)cc(pr) \u00b7 q(v; \u03bcr), where q(v; \u03bcr) is a term that depends on v and \u00b5R. We can observe by Definition 4.1 that q(v; \u03bcr) is the number of vertex labellings of G(\u00b5r) by numbers {0,1,2,\u2026\u2026,v} such that if there is an edge from vertex x\u2081 to vertex x2, the label of x1 is smaller than the label of 22. In other words, q(v) = XG(\u03bcr)(v + 1).\nThe same argument works for NSCP except that q(v; \u03bcr) is the number of vertex labellings of G(\u00b5R) by numbers {0,1,2,\u2026\u2026\u2026, v} such that if there is an edge from vertex x1 to vertex x2, the label of x1 is smaller than or equal to the label of x2, which is the same meaning as \u012aG(\u00b5R)(v + 1). \u03a0\nProposition 4.2. gn(u,v; \u03a8, w,w, R) and \u011dn(u, v; \u03a8,w,w, R) are bivariate polynomials in which both variables have a degree at most n.\nProof. By Corollary 2.1 and Corollary 2.2, XG(\u00b5R)(v) and XG(\u00b5R)(v) are polynomials of v which has degree at most n. Since cc(\u00b5R) \u2264 n, the proposition follows immediately from Proposition 4.1."}, {"title": "Fast Calculation", "content": "Similarly to WCP, we can efficiently compute both SCPs for extended C2 sentences. We first elaborate the algorithm for NSCP, from which the algorithm for SSCP can be easily extended.\nThe algorithm, also based on DP, resembles the fast calculation of WCP with the distinction that WCP involves the 1-type structure of u+1 layers while here we are dealing with a (u+1)\u00d7(v+1) grid. With the technique reducing the WFOMC of an extended C\u00b2 sentence to the WFOMC of an FO2 sentence (refer to Section 2.4), in what follows, we assume that the input sentence is an FO2 sentence.\nBy Proposition 4.2, (n + 1)\u00b2 point evaluations are sufficient to interpolate the polynomial (e.g., by 2D Lagrange Interpolation). Therefore, our task is to evaluate NSCP at u = 0,1,\u2026\u2026,n and v = 0,1,\u2026,n. Let \u03a8 and R be the FO2 sentence and the binary relation involved in the NSCP. Consider the point evaluation of the NSCP at the point (u, v).\nLet C1(x), C2(x),\u2026\u2026,CL(x) be the 1-types of the sentence \u03a8. We first define\nC(x) = A1(x) A2(x) \u039b... \u0391\u00a1 (x)^\u00acA\u00a1'+1(x) \u06f8\u06f0\u06f0\u06f0\u06f8\u00acAu(x)\nCh(x) = B1(x) / B2(x) ^ . . . B\u2081", "w,w),\n''(i,i',i": "j,j',j'"}]}