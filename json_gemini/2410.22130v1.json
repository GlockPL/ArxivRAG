{"title": "Solving Epistemic Logic Programs using Generate-and-Test with Propagation", "authors": ["Jorge Fandinno", "Lute Lillo"], "abstract": "This paper introduces a general framework for generate-and-test-based solvers for epistemic logic programs that can be instantiated with different generator and tester programs, and we prove sufficient conditions on those programs for the cor-rectness of the solvers built using this framework. It also introduces a new generator program that incorporates the propagation of epistemic consequences and shows that this can exponentially reduce the number of candidates that need to be tested while only incurring a linear overhead. We implement a new solver based on these theoretical findings and experimentally show that it outperforms exist-ing solvers by achieving a ~3.3x speed-up and solving 91% more instances on well-known benchmarks.", "sections": [{"title": "Introduction", "content": "Answer Set Programming (ASP) is a declarative programming language well-suited for solving knowledge-intensive search problems, which allows users to encode prob-lems such that the resulting output of the program (called stable models or answer sets) directly corresponds to solutions of the original problem (Gelfond and Lifschitz, 1988, 1991; Lifschitz, 2008; Brewka et al., 2011; Schaub and Woltran, 2018; Lifschitz, 2019). Epistemic logic programs (ELPs) extend the ASP language by allowing the use of subjective literals in the body of rules (Gelfond, 1991; Gelfond and Przymusinska, 1993; Gelfond, 1994; Fandinno et al., 2022). As an example, rules\nfelon \u2190 Kbreak_rule\nsuspect \u2190 Kbreak_rule,\u00acK\u00acbreak_rule\nencode that a person is a felon if we can determine that she broke a rule, and she is a suspect if it cannot be determined that she has broken it nor that she has not done so (Son et al., 2017). ELPs allow us to naturally represent problems that in-volve reasoning about the lack of knowledge of agents as illustrated by the above example-as well as problems laying on the second level of the polynomial hierar-chy such as conformant planning (Son et al., 2017; Kahl et al., 2020; Cabalar et al., 2019b, 2021), action reversibility (Faber et al., 2021) or reasoning about attack trees and graphs (Fandinno et al., 2022). It is worth noting that the computational complex-ity of ELPs is higher than that of ASP: the problem of determining whether an ELP has"}, {"title": "Background", "content": "We assume some familiarity with the answer set semantics for disjunctive logic pro-grams (Gelfond and Lifschitz, 1991). Given a set of atoms At, an objective literal is either an atom or an atom preceded by one or two occurrences of the negation sym-bol \u201c\u00ac.\u201d An extended objective literal is either an objective literal or a truth constant\u00b9. An expression of the form Kl with l being an extended objective literal is called sub-jective atom. A subjective literal L is a subjective atom possibly preceded by one or two occurrences of the negation symbol. A literal is either an extended objective literal or a subjective literal. A rule is an expression of the form:\na1 V ... Van \u2190 L1,..., Lm"}, {"title": "Guess-and-Check computation of world-views", "content": "As mentioned in the introduction, generate-and-test-based solvers rely on using two objective programs: a generator program that provides candidates and a tester program that checks whether a candidate is a worldview. Algorithm 1 summarizes how to com pute n worldviews using this approach, where G(\u03a0) and T (\u03a0) respectively are a gen erator and a tester program for \u03a0. Different generator and tester programs can be used to compute the worldviews of a program. Here we provide general definitions for these"}, {"title": "Basic Generator Programs", "content": "In this section, we introduce two basic generator programs that can be used to com-pute the worldviews of a program. These two programs are inspired by the generator program used by EP-ASP and eclingo, respectively.\nTester program as a generator. We start by showing that the tester program To (\u03a0) is also a generator program for II.\nGenerator with consistency constraints. Cabalar et al. (2020b) noted that some sta-ble models of To (II) can never correspond to a worldview of II. Consider, for instance, the single rule program\nb \u2190 Ka\nand its corresponding To (\u03a0\u2081) program\nb \u2190 ka\n{ka} \u2190"}, {"title": "Generator with Epistemic Propagation", "content": "In a generate-and-test approach, the tester needs to check every stable model of the guess program. Each of these checks requires a linear amount of calls to an answer set solver to compute the corresponding cautions consequences. Each of these calls is \u03a3-complete. Hence, reducing the number of tester checks is crucial to achieve a fast solver. In the previous section, we saw how we can reduce the number of candidates by adding consistency constraints to the generator program. In this section, we introduce a new generator program that can exponentially reduce the number of candidates by propagating the consequences of epistemic literals in the generator program.\nExample 1. Let us consider the following program:\nai \u2190 K\u00acnai for 0 \u2264 i \u2264 n\nnai \u2190 \u00acai for 0 \u2264 i \u2264 n\ngai \u2190 K\u00acg for 0 \u2264 i \u2264 n\n\u2190 Kg"}, {"title": "Implementation and Experimental Evaluation", "content": "Implementation. We implemented a new solver for epistemic logic programs based on Algorithm 1. Our implementation is built on top of version 5.7 of the ASP solver clingo (Gebser et al., 2019) using Python and ASP. We extend the language of clingo by allowing literals of the form &k{L} in the body of rules, with L being a literal of the forms A, not A, or not not A for some atom A in the usual syntax of clingo. An interesting side effect of using clingo in this way is that our solver accepts most of the features of clingo such as aggregates, choice rules, intervals, pools, etc. Another important aspect of our implementation is that it easily allows us to use different gen-erator and tester programs. To achieve this, we rely on metaprogramming, where the ground program is reified as a set of facts and we can use an ASP program to produce the generator and tester programs (Kaminski et al., 2023). As a result, we can change the generator and tester programs by only changing the ASP metaprogram. The source code is provided in the Supplementary Material and will be made available online on acceptance.\nExperimental Evaluation. For the experiment evaluation, we use the well-established benchmarks suite by Son et al. (2017). This consists of three problems: the Eligibility problem that represents reasoning in disjunctive databases (Gelfond, 1991), and the Yale Shooting and Bomb in the Toilet problems that are instances of conformant plan-ning. The original suite consists of 58 instances (25 of the Eligibility problem, 7 of the Yale problem and 26 of the Bomb problem). We have expanded this suite by adding 268 new instances for a total of 326 instances (145 for the Eligible problem, 7 Yale problems and 174 for Bomb problems). The new instances are automatically gener-ated by increasing the number of students in the Eligibility problem and the number of packages and toilets in the Bomb problem. We set a timeout of 600s and ran our ex-periments on a machine powered by anIntel Core Processor (Broadwell) with 12 CPUs running at 2095.078 MHz and 100GB of RAM. The OS is Red Hat Enterprise Linux Server 7.9. The code to run the benchmarks is provided in the Supplementary Material and will be made available online on acceptance.\nResults. We first compare our implementation of Algorithm 1 with two different ver-sions of the generator program, denoted Go and G1. The next table shows the number of instances solved within the timeout and the average solving time by each version of the generator program. On computing average times, instances that did not solve within the timeout were assigned a time of 600s. Figure 1 reports the cactus plot for these two versions of our solver. Using G\u2081 solves more instances than using Go with any timeout greater than 0.546 seconds. There are 49 easy instances solved under that"}, {"title": "Conclusions", "content": "We presented a general framework to study generate-and-test-based solvers for epis temic logic programs (ELPs). In this framework, we first compute the normal form of the epistemic program. Then, we check all the stable models of a generator pro gram by computing the cautious consequences of a tester program. We provided suffi cient conditions on the generator and tester programs for the correctness of the solvers built using this algorithm. We instantiate this framework with generator programs cor responding to the existing generate-and-test-based solvers (EP-ASP and eclingo) and introduce and new generator program based on the idea of propagating epistemic consequences. We formally prove that this new generator program can exponentially reduce the number of candidates while only incurring a linear overhead. We exper imentally evaluate our new solver and show that it outperforms existing solvers by achieving a ~3.3x speed-up and solving 91% more instances on well-known bench marks. Even when comparing with EP-ASPse on conformant planning problems our"}]}