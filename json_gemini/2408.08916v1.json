{"title": "Cyclic Supports in Recursive Bipolar Argumentation Frameworks: Semantics and LP Mapping", "authors": ["GIANVINCENZO ALFANO", "SERGIO GRECO", "FRANCESCO PARISI", "IRINA TRUBITSYNA"], "abstract": "Dung's Abstract Argumentation Framework (AF) has emerged as a key formalism for argumentation in Artificial Intelligence. It has been extended in several directions, including the possibility to express supports, leading to the development of the Bipolar Argumentation Framework (BAF), and recursive attacks and supports, resulting in the Recursive BAF (Rec-BAF). Different interpretations of supports have been proposed, whereas for Rec-BAF (where the target of attacks and supports may also be attacks and supports) even different semantics for attacks have been defined. However, the semantics of these frameworks have either not been defined in the presence of support cycles, or are often quite intricate in terms of the involved definitions. We encompass this limitation and present classical semantics for general BAF and Rec-BAF and show that the semantics for specific BAF and Rec-BAF frameworks can be defined by very simple and intuitive modifications of that defined for the case of AF. This is achieved by providing a modular definition of the sets of defeated and acceptable elements for each AF-based framework. We also characterize, in an elegant and uniform way, the semantics of general BAF and Rec-BAF in terms of logic programming and partial stable model semantics.", "sections": [{"title": "1 Introduction", "content": "Formal argumentation has emerged as one of the important fields in Artificial Intelligence Rahwan and Simari (2009). In particular, Dung's abstract Argumentation Framework (AF) is a simple, yet powerful formalism for modelling disputes between two or more agents Dung (1995). An AF consists of a set of arguments and a binary attack relation over the set of arguments that specifies the interactions between arguments: intuitively, if argument a attacks argument b, then b is acceptable only if a is not. Hence, arguments are abstract entities whose role is entirely determined by the interactions specified by the attack relation.\nDung's framework has been extended in many different ways, including the introduction of new kinds of interactions between arguments and/or attacks. In particular, the class of Bipolar Argumentation Frameworks (BAFs) is an interesting extension of AF which allows for also modelling supports between arguments Nouioua and Risch (2011); Villata et al. (2012). Different interpretations of supports have been proposed in the literature. Further extensions consider"}, {"title": "2 Preliminaries", "content": ""}, {"title": "2.1 Argumentation Frameworks", "content": "An abstract Argumentation Framework (AF) is a pair (A, \u03a9), where A is a set of arguments and \u03a9 \u2286 A \u00d7 A is a set of attacks. An AF can be seen as a directed graph, whose nodes represent arguments and edges represent attacks; an attack (a, b) \u2208 \u03a9 from a to b is represented by a \u2192 b.\nGiven an AF \u2206 =(\u0391, \u03a9) and a set S C A of arguments, an argument a \u2208 A is said to be i) defeated w.r.t. S iff \u2203b \u2208 S such that (b, a) \u2208 N, and ii) acceptable w.r.t. S iff for every argument b\u2208 A with (b, a) \u2208 \u03a9, there is c\u2208 S such that (c, b) \u2208 \u03a9. The sets of defeated and acceptable arguments w.r.t. S (where \u2206 is understood) are next defined.\nDefinition 1\nFor any AF \u2206 = \u3008\u0391, \u03a9\u3009 and set of arguments S C A, the set of arguments defeated by S and acceptable w.r.t. S are defined as follows:"}, {"title": "2.2 Bipolar Argumentation Frameworks", "content": "A Bipolar Argumentation Framework (BAF) is a triple (\u0391, \u03a9, \u0393), where A is a set of arguments, \u03a9 \u2286 A \u00d7 A is a set of attacks, and \u0393 \u2286 A \u00d7 A is a set of supports. A BAF can be represented by a directed graph with two types of edges: attacks and supports, denoted by \u2192 and \u21d2, respectively. A support path ao an from argument ao to argument an is a sequence of n edges ai\u22121 \u21d2 ai with 0 < i < n. We use F+ = {(a, b) | a, b \u2208 A ^ a \u21d2 b} to denote the set of pairs (a, b) such"}, {"title": "2.3 Recursive BAF", "content": "By combining the concepts of bipolarity and recursive interactions, more general argumentation frameworks have been defined. A Recursive Bipolar Argumentation Framework (Rec-BAF) is a tuple (A, R, T, s, t), where A is a set of arguments, R is a set of attack names, T is a set of support names, s (resp., t) is a function from RUT to A (resp., to AU RUT), that is mapping each attack/support to its source (resp., target).\nConsidering AF with recursive attacks, i.e. AF in which the target of an attack can also be an attack, two different semantics have been defined, giving rise to two specific frameworks: Recursive Abstract Argumentation Framework (RAF) Cayrol et al. (2017) and Abstract Argumentation Framework with Recursive Attacks (AFRA) Baroni et al. (2011). We do no further discuss these two frameworks as they are just special cases of Rec-BAF. We mention them only for the fact that they were proposed before Rec-BAF frameworks, and the differences in their semantics, combined with different interpretation of supports, give rise to different specific Rec-BAF frameworks, namely the ones appearing at the corner of Figure 2. We first discuss the two frameworks where supports are interpreted as necessities: Recursive Argumentation Framework with Necessities (RAFN) (extending RAF) Cayrol et al. (2018), and Attack Support Argumentation Framework (ASAF) (extending AFRA) Gottifredi et al. (2018). Regarding the extensions of RAF and AFRA with deductive supports, called Recursive Argumentation Framework with Deductive Supports (RAFD), and Argumentation Framework with Recursive Attacks-Supports (AFRAD) Alfano et al. (2020b), their semantics will be recalled at the end of this section.\nWe now discuss semantics for \u2018acyclic' Rec-BAF, although recently there have been two con- tributions defining the semantic of general RAF and RAFN Lagasquie-Schiex (2023). We do not further discuss these semantics as they are quite involved and in the next two sections we present our main contribution, consisting in the definition of new semantics for general BAF and Rec- BAF, extending in a natural way the semantics defined for acyclic BAF and acyclic Rec-BAF. As the underlying structure representing a Rec-BAF is not a graph, the definition of (a)cyclicity has been formulated in terms of acyclicity of the BAF obtained by replacing every attack a \u2192 b with a \u21d2 a and a \u2192 b, and every support ab with a \u21d2 \u03b2 and \u03b2 \u21d2 b. Note that the so-obtained auxiliary BAF is only used to formally define and check acyclicity in Rec-BAF, not to provide the semantics which are instead recalled next.\nRecursive AF with Necessities (RAFN). The RAFN framework has been proposed in Cayrol et al. (2018). The semantics combines the RAF interpretation of attacks in RAF with the neces- sity interpretation of supports of AFN. Here we consider a simplified version where supports"}, {"title": "3 A new semantics for BAF", "content": "In this section we present a new and intuitive semantics for general BAF. In the rest of this section, whenever we refer to a BAF we intend either an AFN (i.e. a BAF where supports are intended as necessities) or an AFD (where supports are intended as deductive).\nWe start by introducing new definitions for defeated and acceptable sets that extend the ones recalled in the previous section. To distinguish the defeated and acceptable sets defined for gen- eral BAF from those defined for acyclic BAF, we introduce new functions DEF and ACC.\nDefinition 7\nFor any general AFN \u3008\u0391, \u03a9, \u0393) and set of arguments S C A:\n\u2022 DEF(S) = {a \u2208 A \u00a6 (\u2203b \u2208 S . b \u2192 a) V (\u2203c \u2208 DEF(S) . c \u21d2 a) V a \u2260 a};\n\u2022 Acc(S)={a \u2208 A|(\u2200b\u2208 A. b \u2192 a implies b\u2208 DEF(S))\u2227(\u2200c\u2208 A. c \u21d2 a implies c\u2208 ACC(S)}.\nAs for the acyclic case, the semantics of general AFD is dual w.r.t. that of general AFN. Thus, we can transform any AFD into an equivalent AFN by reversing supports.\nThe main difference between the definitions of defeated and acceptable sets for acyclic and general BAF (highlighted in blue) consists in the fact that the new definition of acceptable set"}, {"title": "3.1 LP mapping", "content": "As done in Alfano et al. (2020b) for acyclic BAF, the semantics here presented can be defined even in terms of logic programs under partial stable model semantics.\nTo this end, we now provide the mappings from general BAF to propositional programs, so that the set of \u03c3-extensions of any general BAF \u2206 is equivalent to that of partial stable models of the corresponding logic program P\u25b3. The logic rules of P\u25b3 are derived from the topology of the AF. Basically, the rules in P\u25b3 extend the ones defined for AF (Equation (1)) as the body of a rule defining an argument a also contains the (positive) conjunction of arguments supporting it.\nDefinition 8\nGiven an AFN (resp. AFD) \u2206 = \u3008\u0391, \u03a9, \u0393), then P\u25b3 (the propositional program derived from contains, for each argument a \u2208 A, a rule"}, {"title": "3.2 Computational Complexity", "content": "The complexity of verification and acceptance problems for acyclic BAF are well-know and coincide with the corresponding ones on AF, as any acyclic BAF can be rewritten into an AF. In this section we show that the same holds also for general BAF, that is the complexities of the verification and acceptance problems for general BAF are the same of those known for AF.\nProposition 2\nFor any BAF A = (\u0391, \u03a9, \u0393), and semantics \u03c3\u2208 {co,gr,pr, st}, checking whether a set of arguments S C A is a o-extension for \u2206 is: (i) in PTIME for \u03c3\u2208 {gr, co, st}; and (ii) coNP- complete for \u03c3 = pr.\nProof\nLower bounds derive from the complexity results of the same problems for AF Dvor\u00e1k and Dunne (2017), as BAF is a generalization of AF. As for upper bounds, the proof can be carried out by writing P\u25b3 (in PTIME) and check that (PA, S = S\u222a {\u00abx | x \u2208 DEF(S)}, \u03c3*) is a true instance of the verification problem in LP Sacc\u00e0 (1997), where \u03c3* = WF (resp., PS, TS, MS) iff \u03c3 = gr (resp., co, st, pr). As for Theorem 1 we have that co(\u25b3) = PS(P\u25b3), the result follows.\nProposition 3\nFor any BAF \u2206 = \u3008\u0391, \u03a9, \u0393) and semantics \u03c3\u2208 {co, gr, pr, st}, checking whether an argument g\u2208 A is\n\u2022 credulously accepted under o is: (i)\n(ii)\n\u2022 skeptically accepted under \u03c3 is: (i)\nProof\nin PTIME for \u03c3 = gr; and\nNP-complete for \u03c3 \u2208 {co, st, pr};\nin PTIME for \u03c3 = gr;\n(ii) coNP-complete for \u03c3\u2208 {co, st}; and\n(\u0456\u0456\u0456) \u041f-complete for o = pr.\nSame strategy used in the proof of Proposition 2 can be used, where we check that (P\u2206, g, \u03c3*) is a true instance of the credulous/skeptical acceptance problem in LP Sacc\u00e0 (1997)."}, {"title": "4 A new semantics for Recursive BAF", "content": "In this section we present new semantics for Recursive BAF (Rec-BAF) frameworks. Analogously to the case of BAF, we assume that self-supported arguments (w.r.t. a set S), that is arguments a s.t. there exists a cycle a a\u2081... a. {\u03b21,..., n} \u2286 S, are always defeated. Thus, the definition of defeated elements can be accomplished by adding such a condition.\nDefinition 9\nFor any general RAFN (A, R, T, s, t) and set S C AURUT, we have that:\n\u2022 DEF(S) = {X\u2208 A URUT | (\u2203\u03b1\u2208 R\u2229 S. t(a) = X^s(a) \u2208 S) V\n(\u2203\u03b2\u2208T\u2229 S. t(\u03b2) = X \u2227 s (\u03b2) \u2208 DEF(S)) v\n(\u2203 cycle X\uc641 a\u2081.\u2026\u2026\uc3d9 X .{\u1e9e1, ..., \u1e9en)} \u2286 S};\n\u2022 Acc(S) = {X \u2208 AURUT | (\u2200a\u2208 R .t(a) = X implies (\u03b1 \u2208 DEF(S) Vs(a) \u2208DEF(S))) ^\n(\u2200\u03b2\u2208T.t(\u03b2) = X implies (\u03b2 \u2208 DEF(S) v s(\u03b2) \u2208 Acc(S)))}."}, {"title": "4.1 LP mapping", "content": "We now provide the mappings from general Rec-BAF to ground logic programs, so that the set of o-extensions of any general Rec-BAF \u2206 is equivalent to that of partial stable models of the corresponding logic program P\u25b3. Basically, the logic rules of the program P\u25b3 are derived from the topology of \u2206. The main difference w.r.t. the rules generated for BAF is that we now have rules defining all elements (arguments, attacks and supports) denoted by X. Thus, for instance, regarding RAFN, a target element X is true if (i) for every attack a, either a or the source of a is false, and (ii) for every support \u03b2, either \u03b2 is false or the source of \u1e9e is true.\nDefinition 11\nGiven an RAFN (resp. RAFD) \u2206 = (A, R, T, s, t), then P\u25b3 (the propositional program derived from A) contains, for each element X \u2208 AURUT, a rule\nDefinition 12\nFor any ASAF (resp. AFRAD) \u2206 = (A, R, T, s, t), P\u25b3 (the propositional program derived from \u2206) contains, for each X \u2208 AURUT, a rule of the form\nThe set of complete extensions of any Rec-BAF A coincides with the set of PSMs of the derived propositional program P\u2206.\nTheorem 2\nFor any Rec-BAF \u2206, \u00f4(\u25b3) = PS(P\u25b3).\nProof\nThe proof is similar to that of Theorem 1. The only difference is that complete extensions also contain attacks and supports, whereas the logic program also contains rules defining attacks and supports and, consequently, the partial stable models contain arguments, attacks and supports."}, {"title": "4.2 Computational Complexity", "content": "The complexity of verification and acceptance problems for acyclic Rec-BAF are well-known and coincide with the corresponding ones on AF, as any acyclic Rec-BAF can be rewritten into an AF. In this section we show that the same holds also for general Rec-BAF, that is the complexities of the verification and acceptance problems for general BAF are the same of those known for AF, as stated in the following two propositions.\nProposition 5\nFor any Rec-BAF (A, R, T, s, t) and semantics \u03c3\u2208 {co,gr,pr, st}, checking whether a set of arguments S \u2286 A is a \u03c3-extension for \u2206 is (i) in PTIME for \u03c3\u2208 {gr, co, st}; and (ii) coNP-complete for o = pr.\nProof\nLower bounds derive from the complexity results of the same problems for AF Dvor\u00e1k and Dunne (2017), as Rec-BAF is a generalization of AF. Regarding upper bounds, the proof can carried out by writing P\u25b3 (in PTIME) and check that (P\u25b3, S = S\u222a {\u00abx | x \u2208 DEF(S)}, \u03c3*) is a true instance of the verification problem in LP Sacc\u00e0 (1997), where \u03c3* = WF (resp., PS,TS, MS) iff \u03c3 gr (resp., co, st, pr). As for Theorem 2 we have that co(\u2206) = PS(P\u25b3), the result follows.\nProposition 6\nFor any Rec-BAF (A, R, T, s, t) and semantics \u03c3\u2208 {co, gr, pr, st}, checking whether an argument g\u2208 A is\n\u2022 credulously accepted under o is: (i) in PTIME for \u03c3 = gr; and\n(ii) NP-complete for \u03c3 \u2208 {co, st, pr};\n\u2022 skeptically accepted under o is: (i) in PTIME for \u03c3 = gr;\nProof\n(ii) coNP-complete for \u03c3\u2208 {co, st}; and\n(\u0456\u0456\u0456) \u041f-complete for o = pr.\nSame strategy used in the proof of Proposition 5 can be used, where we check that (P\u2206, g, \u03c3*) is a true instance of the credulous/skeptical acceptance problem in LP Sacc\u00e0 (1997)."}, {"title": "5 Related Work", "content": "Bipolarity in argumentation is discussed in Amgoud et al. (2004), where a formal definition of bipolar argumentation framework (BAF) extending Dung's AF by including supports is pro- vided. A survey of different approaches to support in argumentation can be found in Cohen et al. (2014), and a survey on different recursive AF-based frameworks can be found in Cayrol et al. (2021). However, a semantics for AFNs with cyclic supports have been recently defined in the literature Nouioua and Boutouhami (2023). Essentially, it is based on avoiding considering the contribution of incoherent (set of) arguments, that are those occurring in support-cycles or (transitively) supported by arguments in support-cycles. In the same spirit, our approach ensures that incoherent arguments are always defeated (i.e., appearing in DEF). A semantics for general RAFNs has been recently defined in Lagasquie-Schiex (2023). We believe their proposal is quite intricate as it relies on numerous definitions, whereas ours seamlessly extends the definitions of defeated and acceptable elements, previously defined for AF(N) in an elegant and uniform way.\nThere has been an increasing interest in studying the relationships between argumentation frameworks and logic programming (LP) Caminada et al. (2015); Alfano et al. (2020b). In par- ticular, the semantic equivalence between complete extensions in AF and 3-valued stable models in LP was first established in Wu et al. (2009). Then, the relationships of LP with AF have been further studied in Caminada et al. (2015). A one-to-one correspondence between extensions of general AFN and corresponding normal logic program (LP) has been proposed in Nouioua and Boutouhami (2023), under complete-based semantics. A logical encoding able to characterize the semantics of general RAFN has been proposed in Lagasquie-Schiex (2023). However, the rules defining acceptability of arguments are a bit involved, as they require several predicate symbols. Nevertheless, in Nouioua and Boutouhami (2023); Lagasquie-Schiex (2023) no attention has been devoted to deductive supports.\nEfficient mappings from AF to Answer Set Programming (i.e. LP with Stable Model semantics Gelfond and Lifschitz (1988)) have been investigated as well Sakama and Rienstra (2017); Gaggl et al. (2015). The well-know AF system ASPARTIX Dvor\u00e1k et al. (2020) is implemented by rewriting the input AF into an ASP program and using an ASP solver to compute extensions.\nOur work is complementary to approaches providing the semantics for an AF-based frame- work by using meta-argumentation, that is, by relying on a translation from a given AF-based framework to an AF Cohen et al. (2015); Alfano et al. (2018a;b). In this regard, we observe that meta-argumentation approaches have the drawback of making it a bit difficult to understand the original meaning of arguments and interactions, once translated into the resulting meta-AF. In fact, those approaches rely on translations that generally require adding several meta-arguments and meta-attacks to the resulting meta-AF in order to model the original interactions. Concern- ing approaches that provide the semantics of argumentation frameworks by LPs Caminada et al. (2015), we observe that a logic program for an AF-based framework can be obtained by first flattening the given framework into a meta-AF and then converting it into a logic program. The so-obtained program contains the translation of meta-arguments and meta-attacks that make the program much more verbose and difficult to understand (because not straightly derived from the given extended AF framework) in our opinion, compared with the direct translation we proposed. Moreover, the proposed approach uniformly deals with several AF-based frameworks. Other ex-"}, {"title": "6 Conclusions", "content": "In this paper we jointly tackled two relevant aspects that were so far considered separately by the community of argumentation: extending Dung's abstract argumentation framework with recur- sive attacks and (general) supports, and show that the semantics for specific BAF and Rec-BAF frameworks can be defined by very simple and intuitive modifications of that defined for the case of AF. We presented in an elegant and uniform way the semantics of several (possibly cyclic) AF-based frameworks, including those for which a semantics has never been proposed.\nOur semantics is inspired by the self-supportless principle in logic programs, that ensures no literal in an answer set is supported exclusively by itself or through a cycle of dependencies that lead back to itself. This principle is essential for maintaining the integrity of the answer set, ensuring that it is grounded in the logic rules provided and does not rely on circular reasoning. It is worth noting that, this intuition is also reflected in the stable semantics of ADF Brewka et al. (2013). Indeed, the basic intuition is that all elements of a stable model should have a non-cyclic justification. For instance, considering the (bipolar) ADF having two statements a and b where the acceptance condition of a is b and vice versa, the set {a,b} is not a stable model. Thus, similarly to answer-set and ADF stable semantics, a principle of our semantics is that arguments cannot be circularly justified.\nFinally, we believe that our approach is also complementary to that using intermediate trans- lations to AF to define the Rec-BAF semantics. Indeed, our approach can also be used to provide additional tools for computing complete extensions using answer set solvers Gebser et al. (2018) and program rewriting techniques Janhunen et al. (2006); Sakama and Rienstra (2017)."}, {"title": "Appendix A - Partial Stable Models", "content": "The semantics of a logic program is given by the set of its partial stable models (PSMs) (cor- responding to complete extensions of AFs Caminada et al. (2015)). We summarize the basic concepts underlying the notion of PSMs Sacc\u00e0 (1997).\nA (normal) logic program (LP) is a set of rules of the form A \u2190 B\u2081 ^ \u2026 ^ Bn, with n \u2265 0, where A is an atom, called head, and B\u2081 ^\u2026^ Bn is a conjunction of literals, called body. We consider programs without function symbols. Given a program P, ground(P) denotes the set of all ground instances of the rules in P. The Herbrand Base of a program P, i.e., the set of all ground atoms which can be constructed using predicate and constant symbols occurring in P, is denoted by Bp, whereas \u00abBp denotes the set {\u00acA | A \u2208 Bp}. Analogously, for any set S \u2286 Bp \u222a \u00abBp, \u00abS denotes the set {\u00acA | A \u2208 S}, where \u00ab\u00abA = A. Given I \u2286 Bp \u222a \u00abBp, pos(I) (resp., neg(I)) stands for I\u2229Bp (resp., \u00acI\u2229Bp). I is consistent if pos(I)\u2229\u00acneg(I) = \u00d8, otherwise I is inconsistent.\nGiven a program P, I \u2286 Bp \u222a \u00abBp is an interpretation of P if I is consistent. Also, I is total if pos(I) Uneg(I) = Bp, partial otherwise. A partial interpretation M of a program P is a partial model of P if for each \u00abA \u2208 M every rule in ground(P) having as head A contains at least one body literal B such that \u00abB \u2208 M. Given a program P and a partial model M, the positive instantiation of P w.r.t. M, denoted by PM, is obtained from ground(P) by deleting: (a) each rule containing a negative literal \u00abA such that A \u2208 pos(M); (b) each rule containing a literal B such that neither B nor \u00abB is in M; (c) all the negative literals in the remaining rules. M is a partial stable model of P iff M is the minimal model of PM. Alternatively, PM could be built by replacing every negated body literal in ground(P) by its truth value.\nThe set of partial stable models of a logic program P, denoted by PS(P), define a meet semi- lattice. The well-founded model (denoted by WF(P)) and the maximal-stable models MS(P), are defined by considering C-minimal and C-maximal elements. The set of (total) stable models (denoted by TS(P)) is obtained by considering the maximal-stable models which are total.\nThe semantics of a logic program is given by the set of its partial stable models or by one of the restricted sets above recalled."}]}