{"title": "Cyclic Supports in Recursive Bipolar Argumentation Frameworks: Semantics and LP Mapping", "authors": ["Gianvincenzo Alfano", "Sergio Greco", "Francesco Parisi", "Irina Trubitsyna"], "abstract": "Dung's Abstract Argumentation Framework (AF) has emerged as a key formalism for argumentation in Artificial Intelligence. It has been extended in several directions, including the possibility to express supports, leading to the development of the Bipolar Argumentation Framework (BAF), and recursive attacks and supports, resulting in the Recursive BAF (Rec-BAF). Different interpretations of supports have been proposed, whereas for Rec-BAF (where the target of attacks and supports may also be attacks and supports) even different semantics for attacks have been defined. However, the semantics of these frameworks have either not been defined in the presence of support cycles, or are often quite intricate in terms of the involved definitions. We encompass this limitation and present classical semantics for general BAF and Rec-BAF and show that the semantics for specific BAF and Rec-BAF frameworks can be defined by very simple and intuitive modifications of that defined for the case of AF. This is achieved by providing a modular definition of the sets of defeated and acceptable elements for each AF-based framework. We also characterize, in an elegant and uniform way, the semantics of general BAF and Rec-BAF in terms of logic programming and partial stable model semantics.", "sections": [{"title": "1 Introduction", "content": "Formal argumentation has emerged as one of the important fields in Artificial Intelligence Rahwan and Simari (2009). In particular, Dung's abstract Argumentation Framework (AF) is a simple, yet powerful formalism for modelling disputes between two or more agents Dung (1995). An AF consists of a set of arguments and a binary attack relation over the set of arguments that specifies the interactions between arguments: intuitively, if argument a attacks argument b, then b is acceptable only if a is not. Hence, arguments are abstract entities whose role is entirely determined by the interactions specified by the attack relation.\nDung's framework has been extended in many different ways, including the introduction of new kinds of interactions between arguments and/or attacks. In particular, the class of Bipolar Argumentation Frameworks (BAFs) is an interesting extension of AF which allows for also modelling supports between arguments Nouioua and Risch (2011); Villata et al. (2012). Different interpretations of supports have been proposed in the literature. Further extensions consider"}, {"title": "2 Preliminaries", "content": ""}, {"title": "2.1 Argumentation Frameworks", "content": "An abstract Argumentation Framework (AF) is a pair (A, \u03a9), where A is a set of arguments and \u03a9 \u2286 A \u00d7 A is a set of attacks. An AF can be seen as a directed graph, whose nodes represent arguments and edges represent attacks; an attack (a, b) \u2208 \u03a9 from a to b is represented by a \u2192 b. Given an AF \u2206 =(\u0391, \u03a9) and a set S C A of arguments, an argument a \u2208 A is said to be i) defeated w.r.t. S iff \u2203b \u2208 S such that (b, a) \u2208 N, and ii) acceptable w.r.t. S iff for every argument b\u2208 A with (b, a) \u2208 \u03a9, there is c\u2208 S such that (c, b) \u2208 \u03a9. The sets of defeated and acceptable arguments w.r.t. S (where \u2206 is understood) are next defined."}, {"title": "Definition 1", "content": "For any AF \u2206 = \u3008\u0391, \u03a9\u3009 and set of arguments S C A, the set of arguments defeated by S and acceptable w.r.t. S are defined as follows:"}, {"title": "2.2 Bipolar Argumentation Frameworks", "content": "A Bipolar Argumentation Framework (BAF) is a triple (\u0391, \u03a9, \u0393), where A is a set of arguments, \u03a9 \u2286 A \u00d7 A is a set of attacks, and \u0393 \u2286 A \u00d7 A is a set of supports. A BAF can be represented by a directed graph with two types of edges: attacks and supports, denoted by \u2192 and \u21d2, respectively. A support path ao \u21d2 an from argument ao to argument an is a sequence of n edges ai\u22121 \u21d2 ai with 0 < i < n. We use F+ = {(a, b) | a, b \u2208 A ^ a \u21d2 b} to denote the set of pairs (a, b) such"}, {"title": "AF with Necessary Supports (AFN)", "content": "The semantics of AFN with acyclic supports can be defined by first redefining the definition of defeated and acceptable sets as follows."}, {"title": "Definition 2", "content": "For any AFN (\u0391, \u03a9, \u0393) and set of arguments S \u2286 A:\n\u2022 def(S) = {a \u2208 A | (\u2203b \u2208 S . b \u2192 a) V (\u2203c \u2208 def(S) . c \u21d2 a};\n\u2022 acc(S) = {a \u2208 A | (\u2200b\u2208 A. b \u2192 a implies b\u2208 def(S)) \u2227 (\u2200c \u2208 A . c \u21d2 a implies c\u2208acc(S)}.\nIt is worth noting that def(S) and acc(S) are defined recursively. The definitions of conflict-free and admissible sets, as well as the definitions of complete, preferred, stable and grounded extensions are the same of those introduced for AF."}, {"title": "AF with Deductive Supports (AFD)", "content": "The semantics of AFD is dual w.r.t. that of AFN, that is we can transform a BAF with deductive supports into an equivalent BAF with necessary supports by simply reversing the direction of the support arrows Cayrol et al. (2021). Equivalently, the semantics of acyclic AFD can be defined in terms of AF by adding mediated attacks and removing the supports. Alternatively, it can be presented as in Definition 2 by replacing the support c \u21d2 a with the support a \u21d2 c."}, {"title": "2.3 Recursive BAF", "content": "By combining the concepts of bipolarity and recursive interactions, more general argumentation frameworks have been defined. A Recursive Bipolar Argumentation Framework (Rec-BAF) is a tuple (A, R, T, s, t), where A is a set of arguments, R is a set of attack names, T is a set of support names, s (resp., t) is a function from RUT to A (resp., to AU RUT), that is mapping each attack/support to its source (resp., target).\nConsidering AF with recursive attacks, i.e. AF in which the target of an attack can also be as attack, two different semantics have been defined, giving rise to two specific frameworks: Recursive Abstract Argumentation Framework (RAF) Cayrol et al. (2017) and Abstract Argu-mentation Framework with Recursive Attacks (AFRA) Baroni et al. (2011). We do no further discuss these two frameworks as they are just special cases of Rec-BAF. We mention them only for the fact that they were proposed before Rec-BAF frameworks, and the differences in their semantics, combined with different interpretation of supports, give rise to different specific Rec-BAF frameworks, namely the ones appearing at the corner of Figure 2. We first discuss the two frameworks where supports are interpreted as necessities: Recursive Argumentation Framework with Necessities (RAFN) (extending RAF) Cayrol et al. (2018), and Attack Support Argumen-tation Framework (ASAF) (extending AFRA) Gottifredi et al. (2018). Regarding the extensions of RAF and AFRA with deductive supports, called Recursive Argumentation Framework with Deductive Supports (RAFD), and Argumentation Framework with Recursive Attacks-Supports (AFRAD) Alfano et al. (2020b), their semantics will be recalled at the end of this section.\nWe now discuss semantics for \u2018acyclic' Rec-BAF, although recently there have been two con-tributions defining the semantic of general RAF and RAFN Lagasquie-Schiex (2023). We do not further discuss these semantics as they are quite involved and in the next two sections we present our main contribution, consisting in the definition of new semantics for general BAF and Rec-BAF, extending in a natural way the semantics defined for acyclic BAF and acyclic Rec-BAF. As the underlying structure representing a Rec-BAF is not a graph, the definition of (a)cyclicity has been formulated in terms of acyclicity of the BAF obtained by replacing every attack a \u2192 b with a \u21d2 a and a \u2192 b, and every support ab with a \u21d2 \u03b2 and \u03b2 \u21d2 b. Note that the so-obtained auxiliary BAF is only used to formally define and check acyclicity in Rec-BAF, not to provide the semantics which are instead recalled next."}, {"title": "Recursive AF with Necessities (RAFN)", "content": "The RAFN framework has been proposed in Cayrol et al. (2018). The semantics combines the RAF interpretation of attacks in RAF with the neces-sity interpretation of supports of AFN. Here we consider a simplified version where supports"}, {"title": "Definition 3", "content": "For any acyclic RAFN (\u0391, \u03a3, \u03a4, s, t) and set S C AURUT, we have that:\n\u2022 def(S) = {X \u2208 A URUT | (\u2203\u03b1\u2208 R\u2229 S. t(a) = X \u028cs(a) \u2208S) V (\u039e\u03b2\u03b5 \u03a4\u2229 S. t(\u03b2) = X \u2227 s (\u03b2) \u2208 def(S)) };\n\u2022 acc(S)={X \u2208 A URUT | (\u2200\u03b1\u2208R. t(a) = X implies (a \u2208 def(S) Vs(a) \u2208def(S))) ^ (\u2200\u03b2\u2208\u03a4.t(\u03b2) = X implies (\u03b2 \u2208 def(S) V s(\u03b2) \u2208 acc(S))) }.\nAttack-Support AF (ASAF). The semantics combines the AFRA interpretation of attacks with that of BAF under the necessary interpretation of supports (i.e., AFN). For the sake of presen-tation, we refer to the formulation presented in Alfano et al. (2020a; 2024a), where attack and support names are first-class citizens, giving the possibility to represent multiple attacks and sup-ports from the same source to the same target. For any ASAF \u2206 and S \u2286 AURUT, the defeated and acceptable sets (given S) are defined as follows."}, {"title": "Definition 4", "content": "Given an acyclic ASAF (A, R, T, s, t) and a set S C AURUT, we define:\n\u2022 def(S) = {X \u2208 A URUT | (X \u2208 R\u028cs(X) \u2208 def(S)) V (\u039e\u03b1\u2208RNS.t(a) = X) V (\u2203\u03b2\u2208\u03a4\u2229S.t(\u03b2) = X \u2227 s(\u03b2) \u2208 def(S))};\n\u2022 acc(S) = {X \u2208 A URUT | (X \u2208 R implies s(X) \u2208 acc(S)) ^ (\u03bd\u03b1 \u2208 R.t(a) = X implies a \u2208 def(S)) ^ (\u2200\u03b2\u2208 T. t(\u03b2) = X implies (\u03b2 \u2208 def(S) v s(\u03b2) \u2208 acc(S)))}.\nAgain, the notions of conflict-free, admissible sets, and the different types of extensions can be defined in a standard way (see Section 2.1) by considering S C AURUT and by using the definitions of defeated and acceptable sets reported above. It is worth noting that, the differences between ASAF and RAFN semantics (highlighted in blue) are not in the way they interpret supports (both based on the necessity interpretation), but in a different determination of the status of attacks as they extend AFRA and RAF, respectively. Moreover, for each semantics, the RAFN extensions can be derived from the corresponding ASAF extensions and vice versa."}, {"title": "Recursive AF with Deductive Supports (RAFD)", "content": "For BAFs, necessary support and deductive support are dual (i.e. it is possible to transform a BAF with necessity into an equivalent BAF with deductive supports by simply reversing the direction of the support arrows) Cayrol et al. (2021). However, in the case of Rec-BAF that are not BAFs, this duality no longer holds. This happens because the target of supports and attacks in Rec-BAF may also be other supports and attacks. For this reason, we next explicitly recall the semantics for Rec-BAF with deductive supports."}, {"title": "Definition 5", "content": "For any acyclic RAFD (A, R, T, s, t) and set S C AURUT, we have that:\n\u2022 def(S) = {X \u2208 A URUT | (\u2203\u0430\u2208 R\u2229 S. t(a) = X \u028cs(a) \u2208 S) V (\u039e\u03b2\u2208 T\u2229 S.s(\u03b2) = X^t(\u03b2) \u2208 def(S)) };\n\u2022 acc(S)={X \u2208AURUT | (\u2200a\u2208R. t(a) = X implies (a \u2208 def(S) V s(a) \u2208def(S))) ^ (\u2200\u03b2\u2208T.s(\u03b2) = X implies (\u03b2 \u2208 def(S) V t(\u03b2) \u2208 acc(S))) }.\nAF with Recursive Attacks and Deductive Supports (AFRAD)."}, {"title": "Definition 6", "content": "Given an acyclic AFRAD (A, R, T, s, t) and a set S C AURUT, we define:\n\u2022 def(S) = {X \u2208 A URUT | (X \u2208 R\u028cs(X) \u2208 def(S)) V (\u039e\u03b1\u2208RNS.t(a) = X) V (\u2203\u03b2\u2208 \u03a4\u2229S.s(\u03b2) = X^t(\u03b2) \u2208 def(S))};\n\u2022 acc(S) = {X \u2208 A URUT | (X\u2208 R implies s(X) \u2208 acc(S)) ^ (\u03bd\u03b1 \u2208 R.t(a) = X implies a \u2208 def(S)) ^ (\u2200\u03b2\u2208T.s(\u03b2) = X implies (\u03b2 \u2208 def(S) V t(\u03b2) \u2208 acc(S)))}.\nAgain, we have highlighted in blue the differences between the ASAF and the AFRAD defini-tions of defeated and acceptable arguments. Analogously to the case of RAFN vs ASAF, RAFD and AFRAD semantics may differ only in the status of attacks.\nMappings to other formalisms. It has been shown that any acyclic Rec-BAF A can be mapped to i) an 'equivalent' AF A so that co(\u25b3) = co(A) (i.e. co(\u2206) = co(A) modulo meta-arguments introduced in the rewriting), and ii) a logic program P\u25b3 so that co(A) = PS(P\u25b3) Alfano et al. (2020b). We next extend these results to general Rec-BAF."}, {"title": "3 A new semantics for BAF", "content": "In this section we present a new and intuitive semantics for general BAF. In the rest of this section, whenever we refer to a BAF we intend either an AFN (i.e. a BAF where supports are intended as necessities) or an AFD (where supports are intended as deductive).\nWe start by introducing new definitions for defeated and acceptable sets that extend the ones recalled in the previous section. To distinguish the defeated and acceptable sets defined for gen-eral BAF from those defined for acyclic BAF, we introduce new functions DEF and ACC."}, {"title": "Definition 7", "content": "For any general AFN \u3008\u0391, \u03a9, \u0393) and set of arguments S C A:\n\u2022 DEF(S) = {a \u2208 A \u00a6 (\u2203b \u2208 S . b \u2192 a) V (\u2203c \u2208 DEF(S) . c \u21d2 a) V a \u2260 a};\n\u2022 Acc(S)={a \u2208 A|(\u2200b\u2208 A. b \u2192 a implies b\u2208 DEF(S))\u2227(\u2200c\u2208 A. c \u21d2 a implies c\u2208 Acc(S)}.\nAs for the acyclic case, the semantics of general AFD is dual w.r.t. that of general AFN. Thus, we can transform any AFD into an equivalent AFN by reversing supports.\nThe main difference between the definitions of defeated and acceptable sets for acyclic and general BAF (highlighted in blue) consists in the fact that the new definition of acceptable set"}, {"title": "3.1 LP mapping", "content": "As done in Alfano et al. (2020b) for acyclic BAF, the semantics here presented can be defined even in terms of logic programs under partial stable model semantics.\nTo this end, we now provide the mappings from general BAF to propositional programs, so that the set of \u03c3-extensions of any general BAF \u2206 is equivalent to that of partial stable models of the corresponding logic program P\u25b3. The logic rules of P\u25b3 are derived from the topology of the AF. Basically, the rules in P\u25b3 extend the ones defined for AF (Equation (1)) as the body of a rule defining an argument a also contains the (positive) conjunction of arguments supporting it."}, {"title": "Definition 8", "content": "Given an AFN (resp. AFD) \u2206 = \u3008\u0391, \u03a9, \u0393), then P\u25b3 (the propositional program derived from contains, for each argument a \u2208 A, a rule"}, {"title": "Theorem 1", "content": "For any BAF \u2206, \u00f4(\u25b3) = PS(P\u25b3).\nProof\nWe denote with sup(\u25b3) = {a | a \u2260 a} \u222a {b | \u2203a \u2208 sup(\u25b3). a \u21d2 b} when is an AFN; sup(\u25b3) = {a|a a}\u222a{b|\u2203a \u2208 sup(\u25b3). b \u21d2 a} when \u2206 is an AFD.\n\u2022 Co(A) \u2286 PS(P\u25b3). We prove that for any \u015c \u2208 Co(A), \u015c \u2208 PS(P\u25b3). Indeed, P\u25b3 contains, for each atom a \u2208 A, a rule a \u2190 \u2227(b,a)\u0395\u03a9\u00acb\u2227\u2227(c,a)\u2208\u0393c (or a \u2190 \u2227(b,a)\u2208\u03a9\u00acb\u2227\u2227(a,c)\u2208\u0413 \u0421 if \u2206 is an AFD). Moreover, PS (the positive instantiation of P\u25b3 w.r.t. S) contains positive rules defining exactly the arguments in S, whose bodies contains only (positive) arguments in S. Since the arguments a\u2208 A \u2229 sup(\u25b3) does not appear in S by construction (they are false in the rules' body as appearing in DEF(S)), we have that PS does not contain cycles of positive literals, and thus Tus (0) = S and S is a PSM for PS.\n\u2022 PS(PA) CC(\u25b3). Consider a PSM M\u2208 PS(P\u25b3), pos(M) = TPM (\u00d8). pos(M) \u2286 A is conflict free w.r.t. \u0394. Indeed, assuming that there are two arguments a,b \u2208 pos(M) such that (a, b) \u2208 \u03a9, this means that the rule defining b in P\u25b3 contains in the body a literal \u00aca. This is not possible as in such a case b \u2209 TPM(0). Assuming that \u2206 is an AFN, and that a attacks b indirectly through a supported attack a \u2192 a1 \u21d2 \u21d2 an \u21d2 b. In such a case a1, ..., an, b & TPM(0). Assuming that \u2206 is an AFD, and that a attacks b indirectly through a mediated attack a \u2192 a\u2081 \u2190 \u2026 \u2190 an \u2190 b. In such a case a1, ..., an, b \u2260 Tpm (\u00d8). Thus, pos(M) is conflict free. pos(M) \u2286 A does not contain any argument a \u2208 sup(\u25b3). Indeed, assuming for contradiction that such an argument a \u2208 pos(M) exists, then there must exists at least one other argument literal b in the body of the rule defining a s.t. (i) b \u2208 pos(M) and b \u2208 sup(\u0394). The same holds for any argument of the form of b. Thus M is not a minimal model, contradicting the assumption. Moreover, from Definition 7, considering that pos(M) = TPM (\u00d8), we derive that pos(M) = ACC(pos(M)).\nThe previous theorem states that the set of complete extensions of any BAF A coincides with the set of PSMs of the derived logic program P\u25b3. Consequently, the set of stable and preferred extensions (resp., the grounded extension) coincide with the set of total stable and maximal-stable models (resp., the well-founded model) of P\u25b3 Sacc\u00e0 (1997); Van Gelder et al. (1991)."}, {"title": "3.2 Computational Complexity", "content": "The complexity of verification and acceptance problems for acyclic BAF are well-know and coincide with the corresponding ones on AF, as any acyclic BAF can be rewritten into an AF. In this section we show that the same holds also for general BAF, that is the complexities of the verification and acceptance problems for general BAF are the same of those known for AF."}, {"title": "Proposition 2", "content": "For any BAF A = (\u0391, \u03a9, \u0393), and semantics \u03c3\u2208 {co,gr,pr, st}, checking whether a set of arguments S C A is a o-extension for \u2206 is: (i) in PTIME for \u03c3\u2208 {gr, co, st}; and (ii) coNP-complete for \u03c3 = pr.\nProof\nLower bounds derive from the complexity results of the same problems for AF Dvor\u00e1k and Dunne (2017), as BAF is a generalization of AF. As for upper bounds, the proof can be carried out by writing P\u25b3 (in PTIME) and check that (PA, S = S\u222a {\u00abx | x \u2208 DEF(S)}, \u03c3*) is a true instance of the verification problem in LP Sacc\u00e0 (1997), where \u03c3* = WF (resp., PS, TS, MS) iff \u03c3 = gr (resp., co, st, pr). As for Theorem 1 we have that co(\u25b3) = PS(P\u25b3), the result follows."}, {"title": "Proposition 3", "content": "For any BAF \u2206 = \u3008\u0391, \u03a9, \u0393) and semantics \u03c3\u2208 {co, gr, pr, st}, checking whether an argument g\u2208 A is\n\u2022 credulously accepted under o is: (i) in PTIME for \u03c3 = gr; and (ii) NP-complete for \u03c3 \u2208 {co, st, pr};\n\u2022 skeptically accepted under \u03c3 is: (i) in PTIME for \u03c3 = gr; (ii) coNP-complete for \u03c3\u2208 {co, st}; and (\u0456\u0456\u0456) \u041f-complete for o = pr.\nSame strategy used in the proof of Proposition 2 can be used, where we check that (P\u2206, g, \u03c3*) is a true instance of the credulous/skeptical acceptance problem in LP Sacc\u00e0 (1997)."}, {"title": "4 A new semantics for Recursive BAF", "content": "In this section we present new semantics for Recursive BAF (Rec-BAF) frameworks. Analogously to the case of BAF, we assume that self-supported arguments (w.r.t. a set S), that is arguments a s.t. there exists a cycle a a\u2081... a. {\u03b21,..., n} \u2286 S, are always defeated. Thus, the definition of defeated elements can be accomplished by adding such a condition."}, {"title": "Definition 9", "content": "For any general RAFN (A, R, T, s, t) and set S C AURUT, we have that:\n\u2022 DEF(S) = {X\u2208 A URUT | (\u2203\u03b1\u2208 R\u2229 S. t(a) = X^s(a) \u2208 S) V (\u2203\u03b2\u2208T\u2229 S. t(\u03b2) = X \u2227 s (\u03b2) \u2208 DEF(S)) v (\u2203 cycle X\uc641 a\u2081.\u2026\u2026\uc3d9 X .{\u1e9e1, ..., \u1e9en)} \u2286 S}};\n\u2022 Acc(S) = {X \u2208 AURUT | (\u2200a\u2208 R .t(a) = X implies (\u03b1 \u2208 DEF(S) Vs(a) \u2208DEF(S))) ^ (\u2200\u03b2\u2208T.t(\u03b2) = X implies (\u03b2 \u2208 DEF(S) v s(\u03b2) \u2208 Acc(S)))}."}, {"title": "Definition 10", "content": "For any general ASAF (A, R, T, s, t) and set S C AURUT, we have that:\n\u2022 DEF(S) = {X\u2208 A URUT | \u2208AURUT | (X \u2208 R \u2227 s(X) \u2208 DEF(S)) V (\u039e\u03b1\u2208RNS.t(a) = X) V (\u2203\u03b2\u2208 \u03a4\u2229 S.t(\u03b2) = X^s(\u03b2) \u2208 DEF(S)) V (\u2203 cycle X\uc3d9 a\u2081 ... \uc4f1 X .{\u1e9e1, ..., n} \u2286 S)};\n\u2022 Acc(S) = {X \u2208 A URUT | (X \u2208 R implies s(X) \u2208 Acc(S)) ^ (\u03bd\u03b1 \u2208 R.t(a) = X implies a \u2208 DEF(S)) \u039b (\u2200\u03b2\u2208 T. t(\u03b2) = X implies (\u03b2 \u2208 DEF(S) vs(\u03b2) \u2208 Acc(S)))}.\nAgain, we have highlighted in blue the differences between the definition of defeated and accepted arguments for general and acyclic ASAF. As for the case of BAF we assume as defeated those arguments that 'depends' on a cycle of support \u03b2\u2081, . . ., \u1e9en and all supports \u03b2\u2081, . . ., \u03b2\u03b7 are part of the candidate extension S."}, {"title": "Proposition 4", "content": "Let \u2206 be a RAFN (resp. ASAF) and \u03c3\u2208 {co, gr, pr, st} a semantics. If A is acyclic, then \u03c3(\u0394) computed by means of Definition 3 (resp. Definition 4) coincides with \u03c3(\u2206) computed by means of Definition 9 (resp. Definition 10).\nProof\nThe result follows by observing that, for any acyclic Rec-BAF \u2206 = (A, R, T, s, t) and set S C AURUT, we have that DEF(S) = de f (S) and Acc(S) = acc(S).\nThe semantics of general Rec-BAFs under deductive support (i.e., RAFD, and AFRAD) are obtained from the definition of defeated and acceptable elements in acyclic Rec-BAF (i.e., def, acc) by (i) replacing def and acc with DEF and ACC and (ii) adding the condition \u2203 cycle X \uc641 a\u2081... X .{1, ..., \u03b2n} \u2286 S in the disjunct condition of DEF, as done in Definition 9 for RAFN and Definition 10 for ASAF."}, {"title": "4.1 LP mapping", "content": "We now provide the mappings from general Rec-BAF to ground logic programs, so that the set of o-extensions of any general Rec-BAF \u2206 is equivalent to that of partial stable models of the corresponding logic program P\u25b3. Basically, the logic rules of the program P\u25b3 are derived from the topology of \u2206. The main difference w.r.t. the rules generated for BAF is that we now have rules defining all elements (arguments, attacks and supports) denoted by X. Thus, for instance, regarding RAFN, a target element X is true if (i) for every attack a, either a or the source of a is false, and (ii) for every support \u03b2, either \u03b2 is false or the source of \u1e9e is true."}, {"title": "Definition 11", "content": "Given an RAFN (resp. RAFD) \u2206 = (A, R, T, s, t), then P\u25b3 (the propositional program derived from A) contains, for each element X \u2208 AURUT, a rule"}, {"title": "Definition 12", "content": "For any ASAF (resp. AFRAD) \u2206 = (A, R, T, s, t), P\u25b3 (the propositional program derived from \u2206) contains, for each X \u2208 AURUT, a rule of the form\n\u03a7\u2190 \u03c6(\u03a7) \u039b \u039b \u03c4\u03b1 \u039b (\u00ac\u00dfvs(\u03b2)) resp. X \u2190 (X) ^ ^\u03c4\u03b1 ^ (-\u03b2vt(\u03b2))\nwhere: (X) = s(X) if X \u2208 R; otherwise, (X) =true.\nThe set of complete extensions of any Rec-BAF A coincides with the set of PSMs of the derived propositional program P\u2206."}, {"title": "Theorem 2", "content": "For any Rec-BAF \u2206, \u00f4(\u25b3) = PS(P\u25b3).\nProof\nThe proof is similar to that of Theorem 1. The only difference is that complete extensions also contain attacks and supports, whereas the logic program also contains rules defining attacks and supports and, consequently, the partial stable models contain arguments, attacks and supports."}, {"title": "4.2 Computational Complexity", "content": "The complexity of verification and acceptance problems for acyclic Rec-BAF are well-known and coincide with the corresponding ones on AF, as any acyclic Rec-BAF can be rewritten into an AF. In this section we show that the same holds also for general Rec-BAF, that is the complexities of the verification and acceptance problems for general BAF are the same of those known for AF."}, {"title": "Proposition 5", "content": "For any Rec-BAF (A, R, T, s, t) and semantics \u03c3\u2208 {co,gr,pr, st}, checking whether a set of arguments S \u2286 A is a \u03c3-extension for \u2206 is (i) in PTIME for \u03c3\u2208 {gr, co, st}; and (ii) coNP-complete for o = pr.\nProof\nLower bounds derive from the complexity results of the same problems for AF Dvor\u00e1k and Dunne (2017), as Rec-BAF is a generalization of AF. Regarding upper bounds, the proof can carried out by writing P\u25b3 (in PTIME) and check that (P\u25b3, S = S\u222a {\u00abx | x \u2208 DEF(S)}, \u03c3*) is a true instance of the verification problem in LP Sacc\u00e0 (1997), where \u03c3* = WF (resp., PS,TS, MS) iff \u03c3 gr (resp., co, st, pr). As for Theorem 2 we have that co(\u2206) = PS(P\u25b3), the result follows."}, {"title": "Proposition 6", "content": "For any Rec-BAF (A, R, T, s, t) and semantics \u03c3\u2208 {co, gr, pr, st}, checking whether an argument g\u2208 A is\n\u2022 credulously accepted under o is: (i) in PTIME for \u03c3 = gr; and (ii) NP-complete for \u03c3 \u2208 {co, st, pr};\n\u2022 skeptically accepted under o is: (i) in PTIME for \u03c3 = gr; (ii) coNP-complete for \u03c3\u2208 {co, st}; and (\u0456\u0456\u0456) \u041f-complete for o = pr.\nProof\nSame strategy used in the proof of Proposition 5 can be used, where we check that (P\u2206, g, \u03c3*) is a true instance of the credulous/skeptical acceptance problem in LP Sacc\u00e0 (1997)."}, {"title": "5 Related Work", "content": "Bipolarity in argumentation is discussed in Amgoud et al. (2004), where a formal definition of bipolar argumentation framework (BAF) extending Dung's AF by including supports is pro-vided. A survey of different approaches to support in argumentation can be found in Cohen et al. (2014), and a survey on different recursive AF-based frameworks can be found in Cayrol et al. (2021). However, a semantics for AFNs with cyclic supports have been recently defined in the literature Nouioua and Boutouhami (2023). Essentially, it is based on avoiding considering the contribution of incoherent (set of) arguments, that are those occurring in support-cycles or (transitively) supported by arguments in support-cycles. In the same spirit, our approach ensures that incoherent arguments are always defeated (i.e., appearing in DEF). A semantics for general RAFNs has been recently defined in Lagasquie-Schiex (2023). We believe their proposal is quite intricate as it relies on numerous definitions, whereas ours seamlessly extends the definitions of defeated and acceptable elements, previously defined for AF(N) in an elegant and uniform way.\nThere has been an increasing interest in studying the relationships between argumentation frameworks and logic programming (LP) Caminada et al. (2015); Alfano et al. (2020b). In par-ticular, the semantic equivalence between complete extensions in AF and 3-valued stable models in LP was first established in Wu et al. (2009). Then, the relationships of LP with AF have been further studied in Caminada et al. (2015). A one-to-one correspondence between extensions of general AFN and corresponding normal logic program (LP) has been proposed in Nouioua and Boutouhami (2023), under complete-based semantics. A logical encoding able to characterize the semantics of general RAFN has been proposed in Lagasquie-Schiex (2023). However, the rules defining acceptability of arguments are a bit involved, as they require several predicate symbols. Nevertheless, in Nouioua and Boutouhami (2023); Lagasquie-Schiex (2023) no attention has been devoted to deductive supports.\nEfficient mappings from AF to Answer Set Programming (i.e. LP with Stable Model semantics Gelfond and Lifschitz (1988)) have been investigated as well Sakama and Rienstra (2017); Gaggl et al. (2015). The well-know AF system ASPARTIX Dvor\u00e1k et al. (2020) is implemented by rewriting the input AF into an ASP program and using an ASP solver to compute extensions.\nOur work is complementary to approaches providing the semantics for an AF-based frame-work by using meta-argumentation, that is, by relying on a translation from a given AF-based framework to an AF Cohen et al. (2015); Alfano et al. (2018a;b). In this regard, we observe that meta-argumentation approaches have the drawback of making it a bit difficult to understand the original meaning of arguments and interactions, once translated into the resulting meta-AF. In fact, those approaches rely on translations that generally require adding several meta-arguments and meta-attacks to the resulting meta-AF in order to model the original interactions. Concern-ing approaches that provide the semantics of argumentation frameworks by LPs Caminada et al. (2015), we observe that a logic program for an AF-based framework can be obtained by first flattening the given framework into a meta-AF and then converting it into a logic program. The so-obtained program contains the translation of meta-arguments and meta-attacks that make the program much more verbose and difficult to understand (because not straightly derived from the given extended AF framework) in our opinion, compared with the direct translation we proposed. Moreover, the proposed approach uniformly deals with several AF-based frameworks. Other ex-"}, {"title": "6 Conclusions", "content": "In this paper we jointly tackled"}]}