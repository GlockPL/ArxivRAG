{"title": "Solving the Encoding Bottleneck: Of the HHL Algorithm, By the HHL Algorithm", "authors": ["Guang Ping He"], "abstract": "The Harrow-Hassidim-Lloyd (HHL) algorithm offers exponential speedup for solving the quantum linear-system problem. But some caveats for the speedup could be hard to met. One of the difficulties is the encoding bottleneck, i.e., the efficient preparation of the initial quantum state. To prepare an arbitrary N-dimensional state exactly, existing state-preparation approaches generally require a runtime of O(N), which will ruin the speedup of the HHL algorithm. Here we show that the states can be prepared approximately with a runtime of O(poly(log N)) by employing a slightly modified version of the HHL algorithm itself. Thus, applying this approach to prepare the initial state of the original HHL algorithm can preserve the exponential speedup advantage. It can also serve as a standalone solution for other applications demanding rapid state preparation.", "sections": [{"title": "I. INTRODUCTION", "content": "The success of Shor's factoring algorithm [1] and Grover's search algorithm [2] stimulated the rapid devel- opment of quantum computation technology that lasts to this day. But as we entered the 21th century, new quantum algorithms with comparable impacts are rare to find. The Harrow-Hassidim-Lloyd (HHL) algorithm [3] is one of the few remarkable examples. It provides a brilliant solution to the quantum version of the linear- system problem (LSP), defined as [4]:\nQLSP: Given a Hermitian N\u00d7N matrix A and an N- dimensional unit vector b = (b1, ..., bN)T, find an n-qubit state $|x\\rangle$ such that $|| |x \\rangle - |x|| |\\leq \\epsilon$ and\n$Ax = b$,\nwhere $\\epsilon$ is the error and $N = 2^n$.\nThe HHL algorithm can solve this problem in $O(poly(log(N)))$ runtime, while the best known classical algorithm for the classical LSP takes $O(poly(N))$ run- time. As LSP is one of the most basic problem in all of science, the HHL algorithm is highly favored in the study of machine learning [5, 6], quantum walk [7], computa- tional fluid dynamics [8], quantum many body problem [9], and electromagnetic scattering cross-sections [10], et al.\nHowever, as pointed out in [11], this exponential speedup requires the following caveats:\n(i) The vector $b$ needs to be converted quickly into a quantum computer as the n-qubit quantum state\n$|b\\rangle = (b_1, ..., b_N) = \\sum_{j=0}^{2^n-1} b_j|j\\rangle$.\n(ii) The quantum computer needs to be able to ap- ply unitary transformations of the form $e^{-iAt}$ for various values of $t$.\n(iii) The matrix $A$ needs to be \u201cwell-conditioned\u201d, i.e., the condition number $\\kappa$ (defined as the ratio in magni- tude between the largest and smallest eigenvalues of $A$) should not grows like $N^\\alpha$.\n(iv) The quantum computer user can use the resultant quantum state $|x\\rangle$ directly, without needing to learn the value of any specific entry of $x$.\nHere we focus on the caveat (i). To initialize the quan- tum computer to the state $|b\\rangle$ corresponding to an arbi- trary known vector $b$ exactly, existing state-preparation approaches generally require $O(N)$ runtime, except for some special states [12-15]. Without a better solution, the exponential speedup of the HHL algorithm will be ruined. This is called \"the encoding bottleneck\".\nIn this research, we will show that the state $|b\\rangle$ can be prepared approximately to any desired nonzero error, with the runtime speeded up to $O(poly(log(N)))$. The approach is to apply the HHL algorithm itself to prepare the initial state, with two minor modifications only.\nMoreover, the application of our approach is not lim- ited to preparing the initial state of the HHL algorithm. Any other task in need of the preparation of quantum states can be benefited, e.g., when training quantum ma- chine learning models [16-22] using the amplitude encod- ing method [23, 24] for classical input data."}, {"title": "II. MAIN IDEA", "content": "Eq. (1) means that the HHL algorithm is capable of finding an approximation of the quantum state $|x\\rangle$ where $x$ satisfies\n$x = A^{-1}b$,\ngiven that $A$ and $b$ are known. Our goal is to find an algorithm to prepare the state $|b\\rangle$ efficiently.\nWhile preparing $|b\\rangle$ for arbitrary values of $b$ is hard in general, some special states does not have to take $O(poly(N))$ runtime to prepare. Therefore, we can start from such a state, then find an effective method to turn it into any arbitrary $|b\\rangle$. Interestingly, with some minor twists, the HHL algorithm itself provides such a solution, as elaborated below."}, {"title": "III. OUR STATE-PREPARATION ALGORITHM", "content": "With the above idea in mind, our algorithm for state- preparation can be constructed following the HHL algo- rithm, with two modifications only. Ref. [25] offered a very clear and concise step-by-step walkthrough of the HHL algorithm. Here we use the same notation and work flow as these in section II of [25], so that it is easy to com- pare our algorithm with the original HHL algorithm and see the difference.\nThe algorithm takes $n_b$ target qubits where the final target state $|b\\rangle$ of the preparation will be stored, $n_c$ clock qubits (as called in [25]), and another ancilla qubit. At the beginning, all these $n_b + n_c + 1$ qubits are initialized as\n$|\\Psi_0\\rangle = |0...0\\rangle_b |0...0\\rangle_c |0\\rangle_a$.\nThen the state-preparation algorithm goes as follows.\n(1) Unlike the original HHL algorithm, our first mod- ification is to apply a Hadamard gate H on each of the target qubits to transform them into the quantum state $|h\\rangle$ corresponding to $h$ up to a normalization factor, i.e.,\n$|h\\rangle = \\frac{1}{\\sqrt{2^{n_b}}} \\sum_{j=0}^{2^{n_b}-1}|j\\rangle = \\frac{1}{\\sqrt{2^{n_b}}}(1,1,...,1,1)^T$.\nIt takes $n_b$ single-qubit gates in total, and the state of the whole system becomes\n$|\\Psi_1\\rangle = (H^{\\otimes n_b} \\otimes I^{n_c} \\otimes I) |\\Psi_0\\rangle$\n$= \\frac{1}{\\sqrt{2^{n_b}}} (|0\\rangle + |1\\rangle)^{\\otimes n_b} |0...0\\rangle_c|0\\rangle_a$\n$= \\frac{1}{\\sqrt{2^{n_b}}} \\sum_{j=0}^{2^{n_b}-1} |j\\rangle |0...0\\rangle_c|0\\rangle_a$\n$= |h\\rangle |0...0\\rangle_c |0\\rangle_a$.\n(2) From now on, we follow the HHL algorithm except where noted. That is, we launch the quantum phase estimation (QPE) process, which starts from applying a Hadamard gate H on each of the clock qubits, turning the state into\n$|\\Psi_2\\rangle = (I^{\\otimes n_b} \\otimes H^{\\otimes n_c} \\otimes I) |\\Psi_1\\rangle$\n$= |h\\rangle \\frac{1}{\\sqrt{2^{n_c}}} \\sum_{k=0}^{2^{n_c}-1} |k\\rangle_c |0\\rangle_a$.\n(3) The controlled rotation part of the QPE: apply $n_c$ controlled gates on $|h\\rangle$, as shown in Fig. 2 of [25]. That is, the rth controlled gate (r = $n_c$ \u2212 1, $n_c$ \u2212 2, ..., 0) performs"}, {"title": "IV. ERROR AND RUNTIME", "content": "As shown in step (5), when the desired error of the quantum operation for achieving Eq. (21) is $ \\epsilon_0$, it takes $n_c = O[(log \\epsilon_0^{-1/2})^3]$ clock qubits and $O[(log \\epsilon_0^{-1/2})^4] = O(n^{4/3})$ quantum operations. The error of other steps is the same as that of the original HHL algorithm, which was analyzed in [3]. That is, the dominant source of error is phase estimation, which can be done with error $ \\epsilon$ in time proportional to\n$ts^2(t/\\epsilon)^{O(1)} =: \\tilde{O}(ts^2)$\nfor a $s$ sparse matrix $A$.\nTherefore, to reach a successful computation, the run- time of the original HHL algorithm is [3]\n$\\tilde{O}(log(N)s^2\\kappa^2/\\epsilon)$.\nIn our case, A is replaced by B and we have s = 1 in the above two equations, as can be seen from Eq. (4). Meanwhile, our first modification (step (1)) takes $n_b$ Hadamard gates. The second modification (step (5)) replaces Eq. (20) with Eq. (21), which takes $O(n^{4/3})$ quantum operations to implement. Putting these three parts together, the total runtime of our state-preparation algorithm remains at $O(log(N))$, as long as the condition number of the matrix B does not grow like $N^\\alpha$ (in the case where $ \\alpha$ is large, the treatment in [28] may help). Therefore, for preparing quantum states satisfying this condition, it can offer exponential speedup in compari- son with other existing state-preparation methods."}, {"title": "V. DISCUSSION", "content": "In conclusion, our modified algorithm can prepare a quantum state with a runtime at the same level of the original HHL algorithm. Thus, using it to prepare the initial state will preserve the exponential speedup ad- vantage of the HHL algorithm.\nNote that among the four caveats that we mentioned at the beginning of this paper, our approach conquers the first one only. To ensure that the speedup brought by the HHL algorithm will not be ruined, the other three caveats still need to be satisfied. Nevertheless, as our ap- proach solves the encoding bottleneck, it surely extends the potential application scope of the HHL algorithm. Also, in other application scenarios which have intensive needs of preparing initial states, e.g., quantum machine learning, our approach can serve as a standalone solution to speed up the process."}]}