{"title": "Finding path and cycle counting formulae in graphs with Deep Reinforcement Learning", "authors": ["Jason Piquenot", "Maxime B\u00e9rar", "Pierre H\u00e9roux", "Jean-Yves Ramel", "Romain Raveaux", "S\u00e9bastien Adam"], "abstract": "This paper presents Grammar Reinforcement Learning (GRL), a reinforcement learning algorithm that uses Monte Carlo Tree Search (MCTS) and a transformer architecture that models a Pushdown Automaton (PDA) within a context-free grammar (CFG) framework. Taking as use case the problem of efficiently counting paths and cycles in graphs, a key challenge in network analysis, computer science, biology, and social sciences, GRL discovers new matrix-based formulas for path/cycle counting that improve computational efficiency by factors of two to six w.r.t state-of-the-art approaches. Our contributions include: (i) a framework for generating gramformers that operate within a CFG, (ii) the development of GRL for optimizing formulas within grammatical structures, and (iii) the discovery of novel formulas for graph substructure counting, leading to significant computational improvements.", "sections": [{"title": "1 Introduction", "content": "Paths and cycles are fundamental structures in graph theory, playing a crucial role in various fields such as network analysis [1], chemistry [2], computer science [3], biology [4], and social sciences [5]. Efficiently counting paths and cycles of varying lengths is essential for understanding graph connectivity and network redundancies, and is the foundation of many graph processing algorithms, including graph learning algorithms such as some recent Graph Neural Networks (GNN) [6, 7].\nThis problem of counting paths and cycles has been extensively studied in the literature [8, 9, 10]. Among existing approaches, matrix-based formulae such as those proposed in [11] (see equation (1) for an example) are known to be the most efficient methods for paths and cycles of lengths up to six and seven, respectively [12]. This raises a significant open question: Can a deep learning algorithm discover more efficient formulae for counting paths?\nIn [13] and [14], the length limits mentioned above are theoretically explained by examining the relationship between the subgraph counting problem and the kth-order Weisfeiler-Leman test (k-WL). These papers conclude that 3-WL cannot count cycles longer than seven. Concurrently, [15] explored the connection between 3-WL and a fragment of the matrix language MATLANG [16], defined by the operations L3 := {, T, diag, 1,0}. This paper demonstrates that this fragment, when applied to adjacency matrices, distinguishes the same graph pairs as 3-WL. In order to build a 3-WL GNN, [17] introduced a 3-WL Context-Free Grammar (CFG), a generative framework that notably produces all formulae identified by [11]. Taken together, these recent works enable to transform the search for a path/cycle counting algorithm into a CFG-constrained language generation problem where the aim is to build efficient path counting formulae.\nSearching for formulae within a CFG corresponds to solving a combinatorial optimization problem of possibly infinite size. In recent years, Deep Reinforcement Learning (DRL) approaches have been proposed to address such problems in domains like game playing [18, 19]. A recent success of DRL has been the discovery of more efficient matrix multiplication algorithms through a Monte Carlo Tree Search (MCTS)-based approach"}, {"title": "2 Background", "content": ""}, {"title": "2.1 Path and cycle counting", "content": "Path and cycle counting in graphs can be performed at multiple levels: graph, node, and edge. At the graph level, all possible paths or cycles of a given length within the graph are counted. At the node level, the focus is on counting paths starting at a specific node, as well as cycles that include the node. At the edge level, for any non-negative integer l, let P\u2081 represent the l-path matrix where (Pi)i,j is the number of l-length paths connecting vertex i to vertex j. Additionally, for l > 2, let C\u2081 represent the l-cycle matrix where (Ci)i,j indicates the number of l-cycles that include vertex i and its adjacent vertex j.\nAs mentioned in Section 1, path/cycle counting has been extensively tackled in the literature. In the early 1970s, [8] introduced algorithms for counting cycles up to length five at the graph level. Two decades later, [9] refined these algorithms, extending cycle counting to lengths of up to seven, and conjectured that these methods can also be adapted to count cycles at the node level. Later [11] established a relationship between the counting of l-cycles at the edge level and the counting of (l \u2013 1)-paths at the edge level using a simple formula. By deriving explicit formulae for the counting of paths of length up to six at the edge level, they were able to compute the number of cycles of length up to seven. More recently, [10] rediscovered the formulae for paths of length up to four from [11]. In contrast, [12] proposed an algorithm capable of counting cycles and paths of arbitrary lengths. However, they acknowledged that their method is slower than those presented by [9] and [11]. Specifically, since the latter algorithms are based on matrix multiplication, they exhibit a computational complexity of O (n\u00b3), where n is the number of nodes. As noted by [12], these matrix-based approaches remain the most efficient known methods for counting paths and cycles of lengths up to six and seven, respectively."}, {"title": "2.2 Context-Free Grammar.", "content": "Throughout this paper, we employ standard formal language notation: \u0393* denotes the set of all finite-length strings over the alphabet \u0393, and a represents the empty string. The relevant definitions used in this context are as follows:\nDefinition 2.1 (Context-Free Grammar)\nA Context-Free Grammar (CFG) G is defined as a 4-tuple (V, \u03a3, R, S), where V is a finite set of variables, \u03a3 is a finite set of terminal symbols, R is a finite set of production rules of the form V \u2192 (V\u222a\u2211)*, and S is the start variable. Note that R fully characterizes the CFG, following the convention that the start variable is placed on the top left and that the symbol| represents \"or\".\nDefinition 2.2 (Derivation)\nLet G be a CFG. For u, v \u2208 (VU\u03a3)*, we define u *\u21d2 v if u can be transformed into v by applying a single production rule, and u *\u2192 v if u can be transformed into v by applying a sequence of production rules from G.\nDefinition 2.3 (Context-Free Language)\nA set B is called a Context-Free Language (CFL) if there exists a CFG G such that B = L(G) := w | w \u2208 \u03a3* and S *\u2192 w.\nThe generation process in a CFG involves iteratively replacing variables with one of their corresponding production rules, starting from the start variable, until only terminal symbols remain.\nAs mentioned in Section 1, it is well known that CFGs are equivalent to PDAs [21, 22, 23, 24]. Thus the following subsection is dedicated to defining PDA."}, {"title": "2.3 PushDown Automaton", "content": "Definition 2.4 (PushDown Automaton)\nA PushDown Automaton (PDA) is defined as a 7-tuple P = (Q, \u03a3, \u0393, \u03b4, qo, Z, F) where Q is a finite set of states, \u2211 is a finite set of symbols called the input alphabet, \u0393 is a finite set of symbol called the stack alphabet, d is a finite subset of Q \u00d7 (\u03a3\u222a {e}) \u00d7 \u0413 \u2192 Q \u00d7 \u0393*, the transition relation, qo \u2208 Q is the start state, Z\u2208 F is the initial stack symbol, F \u2286 Q is the set of accepting states.\nIn the case of PDA corresponding to CFG, the input alphabet \u2211 corresponds to the terminal symbol alphabet. The stack alphabet I consits of VU\u03a3, which is the union of the set of variables (non-terminal symbols) and the terminal symbols. For such a PDA, there are only two states: 90, the initial state and, 91 \u2208 F, the accepting state. The initial stack symbol is Z = S, where S is the start variable of the CFG. The transition relation & consists of two types of transitions:\n\u2022 Transcription transitions: If the top of the stack is a terminal symbol a \u2208 \u03a3, the transition is of the form (qo, a, a) = {(0,\u20ac)}. This indicates that the system remains in state qo, outputs the symbol a, and removes a from the stack.\n\u2022 Transposition transitions: If the top of the stack is a variable v \u2208 V, the transition is of the form \u03b4(\u03b1\u03bf,\u03b5,\u03bd) = {(q\u2030,r),r \u2208 V\u2081}, where V, CR is the subset of rules for v. This means that the system stays in state 90, produces no output, and replaces v with the ruler on the stack.\nIn the same way that production rules fully defines a CFG, the transition relation & completely specifies a PDA. For a PDA constructed from a CFG, the transposition transitions alone are sufficient to define the automaton.\nA PDA generates a string by starting in the initial state qo, with the stack initialized to Z and the generated string s initialized to \u025b. The PDA then processes the top symbol t of the stack according to the transition relation d. If t\u2208\u03a3, a transcription occurs: t is popped from the stack and appended to the output string s. If t \u2208 V = \u0393 \\ \u03a3, a transposition occurs: t is popped from the stack, and some"}, {"title": "3 Generating path/cycle counting formula through GRL", "content": "The following subsection presents a specific CFG (see Section 2) designed to address the open problem of path counting."}, {"title": "3.1 From path matrix formulae to the CFG G3", "content": "Let G = (V,E) denote an undirected graph, where V = [1,n] represents the set of n nodes, and E \u2286 V \u00d7 V represents the set of edges. We define the adjacency matrix A \u2208 {0,1}n\u00d7n, that encodes the connectivity of G, the identity matrix I \u2208 {0,1}n\u00d7n, and the matrix J \u2208 {0, 1}n\u00d7n, that is filled with ones except along the diagonal.\nIn the work of [11], all of the proposed formulae are linear combinations of terms composed of matrix multiplications and Hadamard products (denoted by) applied exclusively on the arguments A, I, J. For example, the matrix formula in equation (1) is used to count the number of 3-paths between two nodes in the graph. The formulae for path of length four to six can be found in Appendix D of the supplementary material.\n$P3 = JA\u00b3 \u2013 (I\u2299 A\u00b2)A \u2013 A(I \u00a9 A\u00b2) + A$ (1)\nTo generate the terms of Voropaev's formulae, we define the CFG G3 in equation (2).\n$M\u2192 (MM) | (MM) | A | I | J.$ (2)\nVoropaev's formulae are linear combinations of sentences of L(G3). This ensures that the problem of counting paths of length up to 6 can be addressed through finding linear combinations of sentences of L(G3). Additionally, we prove in Appendix A that G3 is 3-WL equivalent, resulting in Theorem 3.1.\nTheorem 3.1 (3-WL CFG)\nG3 is as expressive as 3-WL\nWhile CFGs are theoretical objects, PDAs are the practical tools for processing and applying the production rules of a CFG to ensure the correct generation of valid sentences according to the grammatical structure. The following subsection derives a PDA (see Section 2) from G3."}, {"title": "3.2 From G3 to the PDA D3", "content": "We denote as D3 the PDA described by the following transition \u03b4:\n\u03b4(\u03b1\u03bf, \u03b5, \u039c) = {(qo, (MM)), (qo, (MM)), (qo, A), (90, I), (qo, J)},\nwhich corresponds directly to the production rules of G3."}, {"title": "3.3 Search in D3 through Grammar Reinforcement Learning", "content": "To find efficient formulae for path and cycle counting, we propose a two step strategy as illustrated by Figure 2. The first step is to generate a set of sentences belonging to G3 by the D3 generation process. The second step compares a linear combination of this set with a ground truth matrix in order to evaluate the corresponding formula. In the following of this subsection, we detail each of these steps.\nAs stated before, the tree structure of a sentence generation within PDA (see Figure 2) aligns with MCTS algorithm. Such algorithms have been proposed and refined over the last decade to guide the search within trees with a general heuristic [25]. In this work, we propose an MCTS-based DRL algorithm, termed Grammar Reinforcement Learning (GRL) adapted to the path counting open problem, generating sets of different sentences.\nIn GRL, MCTS performs a series of walks through the PDA, which are stored in a search tree. The nodes of the tree represent states I, which are a concatenation of the written terminal symbols and the stack. The edges correspond to actions defined by the CFG rules r that can be applied at those states.\nEach walk begins at the start state Io = {Z,..., Z}, whose cardinality is the number of desired sentences, and terminates when a state contains only terminal symbols. Such terminal states are sets of sentences located in leaf nodes. For each state-action pair (I,r), the algorithm tracks the visit count N(I,r), the empirical rule value Q(I, r), and two scalars predicted by a neural network: a policy probability \u03c0(\u0399, r) and a value v(I,r). At each intermediate state, a rule action r is selected according to the following equation:\n$argmax_r aQ(I,r) + (1 \u2212 a)v(I,r) + c(I)\u03c0(I,r)\\frac{\\sqrt{\\Sigma_a N(I,a)}}{1+ N(I,r)},$ (3)\nwhere the exploration factor c(I) regulates the influence of the policy \u03c0(\u0399, r) relative to the Q-values, adjusting this balance based on the frequency of node traversal. The parameter a \u2208 [0,1] controls the reliance on neural network predictions. After a walk reaches a leaf node, the visit counts and the values are updated via a backward pass.\nTo update the values, it is necessary to evaluate a leaf node. Its associated set of sentences is computed for a collection of graphs, and a linear combination of these computed sentences is derived by comparing"}, {"title": "4 Gramformer", "content": "Since our problem is related to the generation of sentences within a language, a transformer architecture fits with this CFG framework. Central to this architecture is the concept of tokens, which represent individual units of input data.\nWe propose Gramformer, a transformer architecture that follows the production rules of a given CFG, through a PDA. It relies on the assignment of the elements of the transition function & into three distinct sets of tokens. Recall that d can be partitioned into two subsets: the transcription set \u03b4\u03c9 (for writing) and"}, {"title": "5 Finding more efficient formulae for counting with RL.", "content": "To address the problem of path counting at the edge level, we apply GRL using a slightly modified version of the grammar G3, denoted G3. This grammar generates matrices of L(G3) with a null diagonal, reducing the search space. For more details on this modified grammar, please refer to Appendix C.\nThe primary objective of this experiment was to demonstrate that GRL can successfully derive the path counting formulae P\u2081 proposed in [11]. Specifically, for I = 2, GRL successfully identified the formula P2. For path lengths l\u2208 3, 4, 5, 6, GRL not only derived the P\u2081 formulae but also discovered more efficient alternatives, denoted as P*. These new formulae significantly reduce the time complexity of l-path counting by factors of 2, 2.25, 4, and 6.25, respectively. The formulae for P through P are provided below, while those for P and P can be found in Appendix D.\n$P_2 = JA\u00b2$,\n$P_3^* = J \u2299 (A(J\u2299 A\u00b2)) \u2013 A \u2299 (AJ)$,\n$P_4^* = J \u2299 (A(J\u2299 (A(J \u2299 A\u00b2)))) \u2013 J \u2299 (A(A \u2299 (AJ)))$\n$- J \u2299 ((A \u2299 (AJ))A) \u2013 A\u2299 ((A\u2299 A\u00b2)J) + 2A \u00a9 A\u00b2$.\nFor each formula, we prove in Appendix D that P\u2081 = P*, leading to the following theorem.\nTheorem 5.1 (Efficient path counting)\nFor l \u2208 {2,3,4,5,6}, (P*)i,j computes the number of l-paths starting at node i and ending at node j.\nIt is visually obvious that P is more compact than P3. To quantify this, we compare the number of matrix multiplications required, which allows us to derive the ratio of time complexity between the formulae. The theoretical time savings between P\u2081 and P* are detailed in Appendix D.\nWe also assessed the empirical time savings across various random graphs. For each graph, the time required to compute each formula was recorded, and the average computation time was calculated for graphs of the same size. To compare these results with the theoretical time savings, we divided the mean computation time of P by the corresponding theoretical time reduction factor. The results of these experiments are presented in Figure 7, demonstrating a strong alignment between empirical and theoretical gains. This confirms the significant time savings provided by the new formulae discovered by GRL and supports our theoretical analysis.\nIn Appendix D, we derive the cycle-counting formulae based on the work of [11], using the relation C1+1 = A P\u2081. Additionally, we provide a detailed explanation of how P* counts l-path establishing a new methodology for deriving formulae."}, {"title": "6 Conclusion", "content": "This paper introduces Gramformer, a deep learning architecture that learns a policy and a value function within a CFG/PDA framework, by assigning tokens to elements of the transition function of a PDA. Used within the GRL algorithm, it effectively addresses the question \"Can a deep learning algorithm discover efficient set of sentences for a given task\".\nInstantiated over the grammar G3 to solve the path counting problem, GRL provides efficient formulae that are linear combinations of sets of sentences in L(G3). These formulae of enhanced computational efficiency by factors ranging from 2 to 6.25 demonstrate the ability of GRL to not only discover explicit formulae for counting paths, but also to provide new ways of designing such formulae.\nFor paths longer than 6, future research should aim to characterize k-WL CFGs to bypass the theoretical limit on path counting of G3. Such a characterization will enable the application of GRL to uncover more explicit formulae for substructure counting across graph structures.\nMoreover, applying GRL to real-world datasets to derive formulae for various tasks represents a promising direction for future exploration as the grammar provides a link to substructures and thus interpretability. This approach could potentially improve the applicability and effectiveness of GRL in practical scenarios, thereby broadening its impact."}, {"title": "A CFGs and PDAs", "content": "This section provides the proof of theorem 3.1 of Section 2 and more details about PDA.\nEven if G3 is different from the 3-WL CFG proposed in [17], they share the same expressive power. Indeed, in the context of this paper, we are not limited by the depth of the CFG while the goal of the grammar reduction in [17] was to keep the expressiveness of the CFG at a given depth.\nIt is important to note that in a separative point of view, we separate graphs with scalar, a CFG G separates two graphs G\u2081 and G2 if there exists a sentence s \u2208 L(G) such that s(Ag\u2081) \u2260 s(Ag\u2082). Knowing that, we have the following proposition and theorem relative to the expressive power of G3.\nProposition A.1\nAssume we have a sentence s that is the sum of two sentences s\u2081 and 52. If s separates G\u2081 and G2, then it is necessary that s\u2081 or s2 separate G\u2081 and G2.\nProof. Assume for the sake of contradiction that neither s\u2081 nor s2 can separate G\u2081 and G2. Then\ns(Ag\u2081) = 81(Ag\u2081) + s2(AG\u2081)\n= $1(Ag\u2082) + $2(Ag\u2082) = s(Ag\u2082).\nThat is absurd.\nTheorem A.1 (3-WL CFG)\nG3 is as expressive as 3-WL\nProof.\nV\u2192 MV1 (4)\nM\u2192 (MM) | (MM) | diag (Vc) | A.\nWe will start from the CFG (4) that was proven to be 3-WL equivalent. We show that Ve variable and diag (Vc) can be removed.\nFirst of all, we have that for any matrix N and vector w, \u039d\u03c9 = (NI)w + (NJ)w, since a sentence in the CFG (4) consists on a sum other the resulting vector, we have with the help of proposition A.1 that vectors (NI)w and (NJ)w have a better separability than Nw. To remove Ve variable, we first have I = diag (1). Then for any matrix N and vector w, we have that (NJdiag (w)) I = diag ((NJ)w) and (Ndiag (w)) I = diag ((NI)w). The conclusion can be made by induction. We obtain G3 as expressive as 3-WL.\nTo give more insight in the construction of PDA from CFG, consider the PDA D3, which corresponds to the CFG G3:\nD3 = ({90,91}, {A, I, J, (, ), \u2299}, {M, A, I, J, (, ), }, \u03b4, 90, \u041c, 91).\nwhere the transition relation d is defined as follows:\n\u03b4(\u03b1\u03bf, \u03b5, \u039c) = {(qo, (MM)), (qo, (MM)), (90, A), (qo, I), (qo, J)}\n\u03b4(\u03b1\u03bf, \u0391, \u0391) = \u03b4(qo, I, I) = \u03b4(qo, J, J) = d(qo, (, () = \u03b4(q\u2030, ), )) = \u03b4(qo, 0, 0) = {(90,\u025b)}\n\u03b4(9\u03bf, \u03b5, \u03b5) = {(91,\u20ac)}."}, {"title": "BOn the evaluation of GRL in the context of path counting", "content": "We remind the acting phase of GRL described in section 4. In GRL, an agent generates a set of sentences, S, using a pushdown automaton corresponding to a given CFG. For a given set of graphs, the agent computes the results of each sentence in s. A linear combination of these computed results is then derived and compared to the ground truth path counts, which yields a reward Rs. This section aims to detailed this evaluation process in the case of GRL applied to G3.\nIn the case of G3, the set of computed sentences for a given set of graphs results into a set of matrices for each sentence. We have then s sets of g matrices, where s is the number of sentences and g the number of graphs. Along with this, we have a set of g matrices of ground truth. For the sake of explanation, we assume that each graphs have the same size n. Then we chose s indices 11,\u2026\u2026,ts and a graph G such that, the matrix E of size s \u00d7 s, where Ei,j = sj(Ag)\u0131, is invertible. If such a matrix does not exist, we penalise the set of sentences by attributing a negative value. Along with the construction of E, we define the vector v with the ground truth matrix of G, T\u00e7 by v\u2081 = (Tg);\u00b7\nThe linear combination is then obtained by resolving the equation Ex = v. Then, the linear combination \u03a3ixisi(AG) is compared to the ground truth T\u00e7 for all graphs G resulting in the value rs. This value encompasses the pertinence of the set of sentence S over a specific path counting problem. Figure 8 depicts this evaluation procedure."}, {"title": "CACFG to count at edge level", "content": "In our investigation of substructure counting at the edge level for the grammar G3, we focus on the non-diagonal elements of the involved matrices. To streamline this process, we introduce an alternative context-free grammar, denoted as G3, which is equally expressive as G3 but specifically tailored for edge-related computations. The grammar is defined as follows:\n$E \u2192 (E \u2299 M) | (NE) | (EN) | A | J$\n$N \u2192 (NM) | (N\u2299 N) | I$ (5)\n$M\u2192 (MM) | (EE)$\nIn G3, the variable E represents matrices with zero on the diagonal, corresponding to edges in the graph, while N represents diagonal matrices, corresponding to nodes, and M represents general matrices. The start variable is E as we aim to focus on edge-level structures. The production rules for each variable describe valid operations and combinations within G3 that yield matrices corresponding to that variable.\nIn the case of N, matrix multiplication is omitted because, for diagonal matrices, the matrix product behaves like the Hadamard product. This choice reduces computational complexity without sacrificing expressiveness."}, {"title": "D Path and cycle counting", "content": "This section contains the proof of theorem 5.1 of Section 5 and provides a detailed explanation of how P* counts l-path."}, {"title": "Lemme D.1", "content": "Let N,M and P be square matrices of the same size, such that Nisi = \u2211k Mi,k for all indices i. Then we have\n$PO (MJ) = (I \u2299 N)P \u2212 P \u2299M$\nProof. We have\n$(PO (MJ))_{i,j} = P_{ij} \\sum_k M_{i,k} \u2013 M_{i,j}$ (6)\n= $P_{i,j}N_{i,i} - P_{i,j} M_{i,j}$,\nand\n$((I \u2299 N)P \u2212 P \u2299 M)_{i,j} = \\sum_k (I_NN)_{i,k}P_{k,j} \u2013 Pi,j Mi,j$\n= $N_{i,i}P_{i,j} - P_{i,j} M_{i,j}$\nFrom equations (6) and (7), we can conclude.\n2-paths and 3-cycles The most effective explicit formula discovered to date for calculating the number of 2-paths connecting two nodes was proposed by [11], it is\n$P_2 = JA\u00b2$. (8)\nFollowing the formula for the l-cycle proposed in [11], we obtain for the 3-cycle the following formula\n$C_3 = A P_2 = A \u00a9 A\u00b2$. (9)\nWithout any surprise, our architecture found the same formulas for both 2-path and 3-cycle.\n3-paths and 4-cycles The most effective explicit formula discovered to date for calculating the number of 3-paths connecting two nodes was proposed by [11], it is\n$P_3 = J \u00a9 A\u00b3 \u2212 (I \u2299 A\u00b2)A \u2013 A(I \u2299 A\u00b2) + A$. (10)\nFollowing the formula for the l-cycle proposed in [11], we obtain for the 3-cycle the following formula\n$C\u2081 = A P_3 = A \u00a9 A\u00b3 \u2013 A(I \u00a9 A\u00b2) \u2013 (I \u00a9 A\u00b2)A + A$.\nObviously our architecture found P3, but surprisingly, it found a more compact formula."}, {"title": "Theorem D.2", "content": "The following formula, denoted as P, computes the number of 3-paths linking two nodes\n$P = J \u2299 (A(JA\u00b2)) \u2013 A \u2299 (AJ)$. (12)\nProof. We will show that P3 = P. Firstly, we have\n$J \u00a9 A\u00b3 \u2013 A(I \u00a9 A\u00b2) = J \u2299 ((A((J + I) \u00a9 A\u00b2))) \u2013 A(I A\u00b2)$\n$= J \u2299 (A(J \u00a9 A\u00b2)) + J \u2299 (A(I \u00a9 A\u00b2)) \u2212A(I A\u00b2)$\n$=A(IOA2) (13)\n= J (A(JA\u00b2)).\nSecondly, we have that A = \u2211k Ai,k. Thus lemma D.1 implies\n$(I A\u00b2)A \u2013 A = A \u2299 (AJ)$. (14)\nFrom equality (13) and (14), we can conclude.\nAn alternative understanding of how P computes the number of 3-paths connecting two nodes is illustrated in Figure 11. The process can be described as follows:\nThe expression A(J A2) calculates, from a given node, a non-closed 2-path followed by a 1-path. This computation inherently includes non-closed 3-paths as well as 3-cycles. The 3-cycles are subsequently removed by the Hadamard multiplication with J, which zeroes out the diagonal elements. However, this operation also allows the possibility of traversing a 2-path and then returning to the intermediate node. To account for this and eliminate such paths, we subtract the term A (AJ).\nThanks to formula (12), we can derive the 4-cycle formula.\nCorollary D.2.1\nThe following formula, denoted as C4f computes the number of 4-cycles linking two nodes\n$C_{4f} = A \u2299 (A(J\u00a9 A\u00b2)) \u2013 A \u2299 (AJ)$. (15)\nIn terms of time complexity, P is more efficient than P3. The ratio of time complexity of P over P3 is 3. It is directly derived from the number of matrix multiplications in both formulas. Figure 7 shows the gain of complexity of P and the ratio between the two formulas.\nSurprisingly, even for l = 3, GRL allows to improve the computation of path and cycle at edge-level in terms of time complexity."}, {"title": "5-paths and 6-cycles", "content": "5 \u2212 (I A\u00b2) \u2013 (I \u00a9 A\u00b2)(J \u00a9 A\u00b2) 1 \u2013 The most effective explicit formula discovered to date for calculating the number of 4 - I \u00a9 +34 A = 4 A2 \u00a9 \u2212(I \u2299 \u2212 ( A4 \u00a9\u2212 - (A4 \u2212 \u2212A A \u22124 ) \u2212( 4 )\u2212 (A A + J P\u2081 J A \u2212( J P\u2081 .J J A A J= \u2212A) J\u00a9 (I ((A\u00b2+(I ) I\u00a9((A\u00b2 A += \u221256 +I ,A4( AA ++ A ++ \u22120+ A + A)\u2212 J C\u2082= \u2084=++ (AA((\u2212J AA\u2212) \u2212( )) (AA+ I J ) J 2I I AJ I+A AA JA I \u2212J (IA\u00a9+A ( )A) IA IA AA IA A) AA AA AA J A)AA\u2212 AA AA( J J (A)) JA AA J (A)) A A \u00a9(AA A) AAA)AA (J) A(I(AA \u2212 \u2212\u2212A IA I \u2212AAI J\u00a9AJ= A + )I \u00a94AA AI ) A J\u00a9JI+A AAA\u00a9AA\u2212 \u00a9\u2212 \u2212 \u2212AA\u00a9\u00a9 (( AA4\u2212AI \u2212\u2212 AAA++++4 A AJ\u2212 A\u2212 A\u00a9\u00a9 (( A+(I \u00a9+A2 AA3 \u00a9J AAA\u2212+++ \u2212 (A A+AA AJ IA2\u2212)+ 2 + ++ AA A \u00a9+AAA ++A AI +AA J4+3 JA \u00a9I \u00a9\u00a9 AA \u00a9A AIJ AAJ AAA AAA+A AJIJA A JI JAJI \u00a9AIJJI+ IAJAA J)+ A J A\u00a9 A\u00a9AJ A (J(I\u00a9AIA\u00a9AJAA AI \u00a9 (AJ + AJ AJ JA ))4A3 (JJ ((I( (( \u00a9I \u00a9\u2212\u00a9+A) IA IA AJAAJ J)+AA JA A\u00a9A ++ 45A (AJ\u00a9 10AJ AJ )\u2212 AAA\u2212AA+\u00a9AAA( )A \u00a9 I 4 (J \u00a9 ((AA 8+A \u00a9++( AAA A JA2\u2212A I A(IJA AA23A \u00a9A J12 ((AA ((AAA2 IA2\u2212IA AJ\u00a9A A 23 A)+I I +AI I\u00a9 (A8)+I A\u00a9 ))I\u00a9AAA)4A A)))A 3A AAI AI A + J AAA)))I+I AJ++AAAA)+++ \u2212((I\u2212 ++ AA4++( AA AJAA24IJI A)+()I\u00a9I (2JAI AA3+ ) \u00a92\u00a9A A3J \u2212AAA4) + 3J A \u00a9AA(+++\u00a9IAA\u00a9I ))J\u22124A\u2212 ))\u00a9 A AI A +A5\u2212JA \u00a9IIA )3((+ AAA AI\u00a9I A+ AAJ)A )A)))JI (36 )A\u00a9 AA++++A A+ \u00a9A(37\u2212)) )4J+ + AJ AJ (AAA I\u2212) 3 \u2212AAA A + AAAJ A AIA+ \u2212+++++4A\u00a9A \u00a9AA++ AIAJ AJ\u00a9AA \u00a9 AJ4\u00a9IAA+++++JJA++AAJ+AI ++++++A A( JA\u00a9\u00a9 ))A() JAA )\u00a9A(A\u00a9+A A+JII+AA)J( ((J\u00a9++\u2212J A2J A++++ AA+I A+++A AA\u00a9I JAJ\u2212\u2212 AAA \u00a9AJ( \u2212((\u00a9 \u00a9I 48A )IA\u00a9( AJ)))I A J((3AJ AA AAJ AA AIJ AAA AA A)+IA +3(J) \u22122+() \u22123A(AAAJJAA )AA I) AAA (( ))))++AAAIA JIIAJJAIA \u2212\u00a9I) )\u2212\u2212 ))AI ++ AJ4JIJAIAA\u2212 \u00a9A (A + AAA \u00a9(I (((J(J+(332JI AJ2JAA\u2212)AA JA AAA)2\u2212) AAAJ) ))() A2 +A+) ))A() +)AA \u2212) 4()2 +)))+++J\u2212(++)+++AAAA + A+\u00a9AA++ (AA A2+) AA+IAJ3+ AA2)A\u00a9 A 4 +) ))4(1132(A2++++(\u00a9AA5++577+ J((IAJ++++2( \u00a9 \u22123AI AA)3)+4II J2\u00a9IIJI )))55\u00a9\u00a9(AA\u00a92AA\u00a9++++((I\u00a9AJI\u00a9AA3+JI J ))AA) AA++A)A)+3A\u00a9( )) \u00a9I 4JA \u00a9I A +1 J 1 AAAI+++AA(J\u00a9 \u00a9++++()+( A AJ JAAIA++ A++A\u00a9\u2212A32 (A\u00a9 I\u22125( AJ AA1() AA3)\u2212 (A ( AJJ\u00a9 )) JAIJ (A A ((II++ \u00a9 3))+ \u2212)\u2212) AJ++JI)AA( \u22127+()I IA (I)II \u00a9\u00a9I\u00a9))))IA++ A15IAJI A \u00a9( 7)\u2212AJAIJAA\u2212\u2212 AA 22A +AI\u00a9 7 7 (I) I\u00a9I777 \u00a9 \u00a9 ( A2JI \u00a9 AJ2 J AJ)J)++++ 4(16 \u2212 A ))IAJAAA A++I IA A))A IA+++ AAA)+((I ))+++A I++ \u00a9 A(7++))))\u2212\u2212++AAA4\u00a9\u2212AA(((AI4)))))))) ))2)+IA)++ (AAJ)++++111 I(\u00a9 J(\u2212AI\u00a94 )\u2212A) )((AI(\u00a9II J()AJJ))+(III((J"}]}