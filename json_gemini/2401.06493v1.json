{"title": "Expected Shapley-Like Scores of Boolean Functions: Complexity and Applications to Probabilistic Databases", "authors": ["Pratik Karmakar", "Mika\u00ebl Monet", "Pierre Senellart", "St\u00e9phane Bressan"], "abstract": "Shapley values, originating in game theory and increasingly prominent in explainable AI, have been proposed to assess the contribution of facts in query answering over databases, along with other similar power indices such as Banzhaf values. In this work we adapt these Shapley-like scores to probabilistic settings, the objective being to compute their expected value. We show that the computations of expected Shapley values and of the expected values of Boolean functions are interreducible in polynomial time, thus obtaining the same tractability landscape. We investigate the specific tractable case where Boolean functions are represented as deterministic decomposable circuits, designing a polynomial-time algorithm for this setting. We present applications to probabilistic databases through database provenance, and an effective implementation of this algorithm within the ProvSQL system, which experimentally validates its feasibility over a standard benchmark.", "sections": [{"title": "1 INTRODUCTION", "content": "The Shapley value is a popular notion from cooperative game theory, introduced by Lloyd Shapley [30]. Its idea is to \"fairly\" distribute the rewards of a game among the players. The Banzhaf power index [8], another power distribution index with slightly different weights also plays an important role in voting theory. These are two instances of power indices for coalitions, which also include the Johnston [16, 17], Deegan-Packel [11], and Holler-Packel indices [14], see [22] for a survey. Shapley and Banzhaf values, in particular, have found recent applications in explainable machine learning [19, 33] and valuation of data inputs in data management [2, 13].\nIn this work, we revisit the computation of such values (which we call Shapley-like values or scores) in a setting where data is uncertain. Our objective is then to investigate the tractability of expected Shapley-like value computations for Boolean functions, having in mind the potential application of computation of expected Shapley-like values of facts for a query over probabilistic databases. In particular, some results have been obtained in the literature that"}, {"title": "2 PRELIMINARIES", "content": "For $n \\in \\mathbb{N}$ we write $[n] \\stackrel{\\text{def}}{=} \\{0, ..., n\\}$. We denote by P the class of problems solvable in polynomial time. For a set $V$, we denote by $2^V$ its powerset.\nBoolean functions. A Boolean function over a finite set of variables $V$ is a mapping $q : 2^V \\rightarrow \\{0, 1\\}$. To talk about the complexity"}, {"title": "3 EQUIVALENCE WITH EXPECTED VALUES", "content": "In this section we link the complexity of computing expected Shapley-like scores with that of computing expected values. The point is that EV(F) is a central problem that has already been studied in depth for most meaningful classes of Boolean functions, with classes for which that problem is in P while the general problem is #P-hard. In a sense then, if we can show for some problem A that A =p EV(F), this settles the complexity of A. We start in Section 3.1 by the direction that is most interesting in practice to obtain efficient algorithms: going from expected values to expected scores. We show that this is always possible, under the assumption that the coefficient function is computable in polynomial time. We then give results for the other direction in Section 3.2, where the picture is more complex."}, {"title": "3.1 From Expected Values to Expected Scores", "content": "Let us call a coefficient function c tractable if c(k, l) can be computed in P when k and I are given in unary as input. It is easy to see that CBanzhaf and its normalized version are tractable. This is also the case of cShapley, using the fact that binomial coefficients can be computed in time O(k \u00d7 l) by dynamic programming (assuming arguments are given in unary). Under this assumption, we show that computing expected Shapley-like scores always reduces in polynomial time to computing expected values."}, {"title": "3.2 From Expected Scores to Expected Values", "content": "In this section we show reductions in the other direction for CShapley and CBanzhaf, under additional assumptions on the class F.\nShapley score. Let us call a class of Boolean functions F reasonable if the following problem is in P: given as input (a representation of) \u03c6\u2208 F, compute q (0). It is clear that all classes mentioned in this paper are reasonable in that sense. Then, under this assumption:"}, {"title": "4 DD CIRCUITS", "content": "We now present algorithms to compute expected Shapley-like scores in polynomial time over deterministic and decomposable Boolean circuits. Since computing expected values can be done in linear time over such circuits, the fact that computing expected Shapley-like scores over them is in P is already implied by our main result, Theorem 3.1. We nevertheless present more direct algorithms for these circuits as they are easier and more natural to implement than the convoluted chain of reductions with various oracle calls and matrix inversions from the previous section. We will moreover use these algorithms in our experimental evaluation in Section 6. We start by defining what are these circuits.\nBoolean circuits. Let C be a Boolean circuit over variables V, featuring \u2227, \u2228, \u00ac, constant 0- and 1-gates, and variable gates (i.e., gates labeled by a variable in V). We write Vars (C) \u2286 V the set of variables that occur in the circuit. The size |C| of C is its number of wires. For a gate g of C, we write Cg the subcircuit rooted at g, and write Vars(g) its set of variables. An \u2227-gate g of C is decomposable if for every two input gates $g_1 \\neq g_2$ of g, $Vars(g_1) \\cap Vars(g_2) = \\emptyset$. We call C decomposable if all \u2227-gates in it are. An \u2228-gate g of C is deterministic if the Boolean functions captured by each pair of distinct input gates of g are pairwise disjoint; i.e., there is no assignment that satisfies them both. We call C deterministic if all \u2228-gates in it are. A deterministic and decomposable (d-D) Boolean circuit [25] is a Boolean circuit that is both deterministic and decomposable. An \u2228-gate g is smooth if for any input $g'$ of g we have $Vars(g) = Vars(g')$, and C is smooth is all its \u2228-gates are. We say that C is tight if it satisfies the following three conditions: (1) Vars(C) = V; (2) C is smooth; and (3) every \u2227 and every \u2228 gate of C has exactly two children. The following is folklore."}, {"title": "5 PROBABILISTIC DATABASES", "content": "(Probabilistic) databases and queries. Let $\\Sigma = \\{R_1,..., R_n\\}$ be a signature, consisting of relation names each with their associated arity ar(Ri) \u2208 N, and Const be a set of constants. A fact over (\u03a3, Const) is a term of the form R(a1,..., aar(R)), for R \u2208 \u2211 and ai \u2208 Const. A (\u03a3, Const)-database D (or simply a database D) is a finite set of facts over (\u03a3, Const). We assume familiarity with the most common classes of query languages and refer the reader to [1, 7] for the basic definitions. A Boolean query is a query q that takes as input a database D and outputs q(D) \u2208 {0, 1}. If q(x) is a query with free variables x and t is a tuple of constants of appropriate length, we denote by $q[/t]$ the Boolean query defined by $q[/t](D) = 1$ if and only if t is in the output of q(x) on D. A tuple-independent probabilistic database, or TID for short, consists of a database D together with probability values pf for every fact f \u2208 D. For a Boolean query q and TID D = (D, (pf)f\u2208D), the probability that D satisfies q, written $\\text{Pr}(D \\models q)$, is defined as $\\text{Pr}(D \\models q) \\stackrel{\\text{def}}{=} \\sum_{D' \\subseteq D \\text{ s.t. } q(D')=1} \\text{Pr}(D')$, where $\\text{Pr}(D') = \\prod_{f \\in D'} p_f \\times \\prod_{f \\in D \\setminus D'} (1-p_f)$. For a fixed Boolean query q, we denote by PQE(q) the computational problem that takes as input a TID D and outputs Pr(D = q).\n(Expected) Shapley-like scores. Letc: N\u00d7N\u2192 be a coefficient function, q a Boolean query, D a database and f\u2208 D a fact. Following the literature [13, 23, 24], we define the Shapley-like score with"}, {"title": "6 IMPLEMENTATION AND EXPERIMENTS", "content": "In this section, we experimentally show that the computation of expected Shapley-like scores is feasible in practice on some realistic queries over probabilistic databases, despite the #P-hardness of the problem in general and the high $O(|C|\\times |V|^5)$ upper bound (see Theorem 4.2) on the complexity of Algorithm 1 for d-Ds. The objective is not to provide a comprehensive experimental evaluation but to simply validate that algorithms presented in this work have reasonable complexity for practical applications.\nImplementation. We rely on ProvSQL [29], an open-source PostgreSQL extension that computes (between other things) the Boolean provenance of a query over a database. We let ProvSQL compute the Boolean provenance of SQL queries over relational databases as a Boolean circuit, and have extended this system to add the following features2: (1) We compile Boolean provenance into a d-D in the simple but common decomposable case where every \u2227- or \u2228-gate g is decomposable, i.e., for every two inputs g1 and g2 to g, Vars (g1) \u2229 Vars(g2) = 0. Note that, as we have already observed in Section 4, a decomposable \u2228-gate of the form A\u2228B can be rewritten, using De Morgan's laws, into a decomposable \u2227-gate. (2) For cases where this is not possible, we attempt to compile Boolean provenance into a d-D by computing, if possible, a tree decomposition of the circuit of treewidth < 10, and by then following the construction detailed in [4, Section 5.1] to turn any Boolean circuit into a d-D in linear time when the treewidth is fixed. (3) Otherwise, we default to ProvSQL's default compilation of circuits into d-Ds, which amounts to coding the circuit as a CNF using the Tseitin transformation [32] and then calling an external knowledge compiler, d4 [21]. (4) We have implemented directly within ProvSQL Algorithm 1 to compute expected Shapley values on d-Ds, its simplification when all py are set to 1 detailed at the end of Section 4, as well as the algorithm to compute expected Banzhaf values in the proof of Theorem 4.4. They are all implemented with floating-point numbers.\nNote that, in particular, this approach is not restricted to queries that fall on the tractable side of the dichotomy of [10]."}, {"title": "7 RELATED WORK", "content": "There are two lines of work that our results should be compared to. The first one studies the complexity of computing (non-expected) Shapley-like values for databases and Boolean functions. The second one studies the complexity of computing the SHAP-score, a score used in explainable AI and machine learning. In both cases the problem has been studied by relating it to that of computing expected values or of computing model counts, and also by proposing tractable algorithms for deterministic and decomposable Boolean circuits. In this sense then, the structure of our paper is similar to existing literature. Yet we think that all these problem variants are worth studying because the underlying notions are solutions to different problems. We summarize the existing related literature here and compare to it, starting with what is closest to our work."}, {"title": "8 CONCLUSION", "content": "We proposed the new notion of expected Shapley-like scores for Boolean functions, proved that computing these scores can always be reduced in polynomial-time to the well-studied problem of computing expected values, and that these two problems are often even equivalent (under commonplace assumptions). We designed algorithms for deterministic and decomposable Boolean circuits and implemented them in the setting of probabilistic databases, where our preliminary experimental results show that these scoring mechanisms could actually be used in practice. We leave as future work the study of approximation algorithms for this new notion. In particular, it is known that Scorecshapley (q) has a fully polynomial-time randomized scheme [15] whenever q is a UCQ [9], and one could study whether this stays true for the probabilistic variant. Still we note that, since the reduction from Fact 2.3 is parsimonious, we inherit the few hardness results of the non-probabilistic setting, such as those of [27] for conjunctive queries with negations."}]}