{"title": "eSPARQL: Representing and Reconciling Agnostic and Atheistic Beliefs in RDF-star Knowledge Graphs", "authors": ["Xinyi Pan", "Daniel Hernandez", "Philipp Seifer", "Ralf L\u00e4mmel", "Steffen Staab"], "abstract": "Over the past few years, we have seen the emergence of large knowledge graphs combining information from multiple sources. Some- times, this information is provided in the form of assertions about other assertions, defining contexts where assertions are valid. A recent exten- sion to RDF which admits statements over statements, called RDF-star, is in revision to become a W3C standard. However, there is no proposal for a semantics of these RDF-star statements nor a built-in facility to operate over them. In this paper, we propose a query language for epis- temic RDF-star metadata based on a four-valued logic, called eSPARQL. Our proposed query language extends SPARQL-star, the query language for RDF-star, with a new type of FROM clause to facilitate operating with multiple and sometimes conflicting beliefs. We show that the proposed query language can express four use case queries, including the following features: (i) querying the belief of an individual, (ii) the aggregating of beliefs, (iii) querying who is conflicting with somebody, and (iv) beliefs about beliefs (i.e., nesting of beliefs).", "sections": [{"title": "1 Introduction", "content": "Over the past few years, we have seen the emergence of large knowledge graphs combining information from multiple sources, such as Wikidata [21], YAGO [20], and DBpedia [3]. These knowledge graphs provide information about a great va- riety of entities, such as people, countries, universities, as well as facts over these entities, which are codified as triples. For example, the fact that Albert Einstein was born in Germany can be encoded as a triple (Einstein, wasBorn, Germany). Triples like this are the information units of the Resource Description Frame- work (RDF) [12], a data model for representing information about World Wide"}, {"title": "2 Use Case Requirements", "content": "We have explored a broad range of queries that an epistemic query language for RDF-star should be able to answer. We distil four query examples that this language must allow formulating easily. They require (i) to query for people's beliefs, (ii) to query for aggregated or integrated belief states, (iii) to query for subjects whose beliefs coincide, conflict, are compatible or ignorant of other belief sets, (iv) allow for nested belief states.\nUse Case U1 (Query for people's beliefs) We should be able to query people's beliefs regarding a given statement, and the query should return the bindings to the possible variables in the statement and the respective four-valued logic truth values for the variable bindings. The expression for these queries should be simple (i.e., do not include any algebraic operators like AND, UNION, FILTER, or SELECT).\nExample: Return the full deities ?x according to Pope Damasus the First. All returned individuals should be annotated with a belief value that indicates the belief of the Pope regarding the individual. For example, Jesus must be annotated as true if the Pope believes Jesus is a full deity, false if the Pope believes Jesus is not a full deity, unknown if there is no information about the belief of the Pope regarding the nature of Jesus, and conflicted if either the Pope believes this statement is conflicted, or the belief is both true and false.\nUse Case U2 (Query for combined belief values) We should be able to combine people's beliefs to represent the belief of a group, or operations between different people's beliefs.\nExample: Return the beliefs of Christian people regarding the full deities. For example, Jesus must be annotated with true if all Christians think Jesus is a full deity, false if all Christians think Jesus is not a full deity, conflicted if they have contradictory opinions, and unknown if no Christian has an opinion regarding the nature of Jesus.\nUse Case U3 (Query for people whose beliefs coincide, conflict, or are compatible) Given a set of statements, we should be able to query people who coincide (they all have the same belief for all the statement), conflict (some people believe a statement is true, whereas others believe it is false), or they are compatible (if a person believes a fact is true, the others can believe it is true or unknown).\nExample: Return all people whose opinion is conflicted with Pope Damasus the First in at least one statement. For example, since Pope Damasus the First believes that Jesus is a full deity, and Arius believes it is not, then Arius should"}, {"title": "3 Preliminaries", "content": "The FOUR structure. A partially ordered set (or poset) is a set taken together with a partial order on it. Formally, a partially ordered set is defined as a pair (A, \u2264), where A is called the ground set of the poset and < is the partial order of the poset.\nA poset (A, \u2264) defines a lattice if for every two elements a, b \u2208 A, there is a unique maximum element c\u2208 A such that c\u2264 a and c < b, called the meet of a and b, and there is a unique minimum element c\u2208 A such that a \u2264 c and b < c, called the join of a and b.\nWe write FOUR to denote the set {\u22a5, T, F, \u3153}, and we use FOUR elements to refer to the elements in this set. We define the posets (FOUR,\u2264tr) and (FOUR, \u2264in) as the minimum posets satisfying the inequalities \u22a5 \u2264trF, \u22a5 \u2264tr \u3153\u314f\u2264tr T, \u3153 \u2264tr T, F\u2264in \u3157, F\u2264in T, \u22a5 \u2264in \u3153, and T \u2264in \u3153. These two posets with ground set FOUR, define the bilattice depicted in Figure 1. The axis can be interpreted as the orderings regarding truth and information, and the FOUR elements are the respective elements of the 4-valued logic false (1), true (T), unknown (F), and conflicting (+). We use FOUR operators to refer to the operators,,, and (see Figure 1), and FOUR structure to refer to the algebraic structure that consists of the FOUR operators over the FOUR set. Given a FOUR operator o and a set A = {A1, ..., an } \u2286 FOUR, we write Id(0) to denote the identity element for an operator o in the FOUR structure (i.e., Id() = T, Id() = 1, Id() = 1, and Id() = \u3153), we write Abb(0) to denote the absorbing element for a FOUR operator \u0966, (i.e., Abb() = 1, Abb() = T, Abb() = \u251c, and Abb(\u00a9) = \u3153), and we write \u25cb(A) for the FOUR element Id(0) 0 A1 0\u06f0\u06f0\u06f0 0 An\u00b7\nA monoid M is an algebraic structure (M,+\u043c,0\u043c) where M is a non- empty set, +m is a closed associative operation on set M, and 0\u043c\u2208 M is the identity element of operation +\u043c (\u0456.\u0435., 0\u043c +\u043c\u0430 = a and a +\u043c 0\u043c = a, for every a \u2208 M). The monoid M is said to be commutative if operation +Mis commutative.\nA semiring K is an algebraic structure (K, +\u03ba, \u00d7\u049d,0k, 1x) where (K, +\u03ba, 0k) and (K, \u00d7, 1x) are monoids, and \u00d7 distributes over +x (i.\u0435., \u0430 \u0445\u043a (\u0432+\u043a \u0441) ="}, {"title": "4 K-annotated SPARQL-star", "content": "In this section, we extend a fragment of the Geerts et al. [6] K-annotated SPARQL algebra to support RDF-star and SPARQL-star (following the notions from the working draft [11]). We consider a fragment without the non-monotonic operator MINUS because the non-monotonic operators go beyond the semiring structure of each of the two FOUR lattices.\nWe assume two countable pairwise disjoint sets I and V, called the set of IRIs and the set of variables. We call the elements of I\u00b3 RDF triples4. Given an RDF triple (s, p, o) \u2208 I\u00b3, we say that s is the subject, p is the predicate, and o is the object of the triple. According to the working draft [11], SPARQL-star triples and SPARQL-star triple patterns are defined recursively as follows. Given two SPARQL-star triple patterns T\u2081 and T2, and an RDF triple pattern (S, P, O), the triples (S, P, O), (T\u2081, P, O), (S, P, T2), and (T1, P, T\u2082) are SPARQL-star triple patterns. A SPARQL-star triple pattern without variables is an RDF-star triple (and T is the set of all RDF-star triples), and an RDF-star graph is a set of RDF-star triples.\nA SPARQL-star solution mapping (or a mapping) is a partial function \u03bc: V\u2192 IUT with finite domain dom(\u03bc). Two mappings \u03bc and \u00b5' are compatible if \u03bc(?x) = \u03bc' (?x) for every variable ?x \u2208 dom(\u03bc) \u2229 dom(\u03bc'). If mappings \u03bc and \u03bc' are compatible, \u03bc\u222a\u03bc' is the mapping with domain dom(\u03bc) U dom(\u03bc') that is compatible with \u03bc and \u03bc'. Given a set of variables W CV, we write w to denote the set of mappings {\u03bc : dom(\u03bc) = W}."}, {"title": "5 Epistemic SPARQL", "content": "This section presents the syntax and semantics of Epistemic SPARQL (eS- PARQL), the language designed for the use cases described in Section 2.\nSo far, we have defined the notion of SPARQL-star K-graphs, where Kis a semiring. However, a K-graph is an abstract notion, since no concrete semiring is provided. If concrete semirings like FOURth and FOURin are considered, then we have concrete notions as FOURth-graphs and FOURin-graphs (see Example 1). In what follows, a FOUR-graph will be a function that associates RDF-star triples to elements in set FOUR, without choosing one of the two semirings (FOURth or FOURin) defined by the FOUR structure.\nA key characteristic of FOUR-graphs is that they can contain epistemic metadata encoded using four predicates: believesToBeTrue, believesToBeFalse, believes ToBeUnknown, and believesToBeConflicted. Each of these predicates en- codes a belief. For example, triple t\u2081 = (PopeDI, believesToBe True, t9) from Ta- ble 1 encodes that PopeDI believes statement to to be true.\nA basic operation over a FOUR-graph G is thus extracting beliefs for each of these predicates. We next present belief queries, which are expressions to extract a FOUR-graph G' representing the belief of one or more people according to the information of an input FOUR-graph G. An atomic belief query [PopeDI, T, H] represents all statements PopeDI believe to be T, assuming that the rest are annotated with the state F. Compound belief queries are generated by combining atomic statements with the FOUR operators."}, {"title": "6 Use Case Requirements Discussion", "content": "In this section, we show a eSPARQL query for each of the use cases U1-U4. Since the notation of eSPARQL queries in an algebraic format is not suitable for end-users, we additionally present how this query can be written as an extension of the user SPARQL syntax."}, {"title": "7 Finitely Supported eSPARQL", "content": "To implement eSPARQL, the query results must be finitely encoded. As we have already shown, we can encode an infinite function with a finite mapping that has a finite support by encoding the non-zero states only.\nDefinition 9. An eSPARQL query Q is said to be finitely supported if, for every FOUR-graph with finite support, there exists an element a \u2208 FOUR, called a zero for Q and G, such that the set {\u03bc | (Q)g(\u03bc) \u2260 a} is finite.\nTo know if eSPARQL queries are finitely supported, consider two FOUR- relations R\u2081 and R2 with finite support that result of evaluating the respective queries Q1 and Q2. That is, there are two FOUR operations o and \u25c7, such that the sets supp. (R\u2081) and supp\uff61(R2) are finite. Given a FOUR operation, does R3 = R1 R2 have a finite support? To answer this question, lets start figuring what is needed for R3 to have a finite support for each operator combination of the operators o, \u25c7, and ..\nThe first observation is that R\u2081 and R2 have infinitely many mappings whose states are respectively Id(0) and Id(\u25ca). If \u2022 is a join operator (i.e., or), then we will have infinitely many mappings \u03bc such that R3(\u03bc) = Id(0) \u2022 Id(\u25ca). Since there is exactly one FOUR-operator, namely * such that Id(*) = Id(0)\u2022Id(), we want to know if supp (R3) is finite. In this case, the answer is straightforward. If we have a mapping \u03bc' such that R3(\u03bc) \u2260 Id(*) then it must happen that R1(\u03bc) \u2260 Id(0) or R2(\u03bc) \u2260 Id(0). Since R\u2081 and R2 have finite support, there are finitely many mappings \u03bc satisfying that condition. Thus, supp (R3) is finite. Hence, for the two operations corresponding to the two lattice join (i.e., the generalizations of the SPARQL UNION), two FOUR-relations with finite support result in a FOUR-relation with finite support.\nWe next show that if \u2022 is a meet operator (i.e., or), then the resulting FOUR-relation can have no finite support. To this end, consider the query Q1 Q2 where Q1 and Q2 are two queries with respective in-scope variables ?x and ?y. Given a FOUR-annotated graph G, let R\u2081 be (Q1), and R2 be (Q2) G, supp(R2) be finite, R\u2081({?x \u2192 a}) = T, R\u2081({?x \u2192 b}) = 1, and assume that there are infinitely many values c such that R2({?y \u2192 c}) = T. Then,\n(Q1 Q2)({?x \u2192 \u0430, ?y \u2194 c}) = T,\n(Q1 Q2)({?x \u2192 b, ?y \u2192 c}) = F.\nSince we can take infinitely many values of c to produce these two different states, we conclude that the answer of query Q1 Q2 has no finite support.\nProposition 2. Every fragment of eSPARQL that includes the operations or can include queries that are not finitely supported.\nThis negative result is not necessarily an impediment for implementing eS- PARQL. In general, since we are interested in statements about the individuals who appear in a knowledge graph, it suffices to consider mappings that range to the active domain of the graph (i.e., individuals that occur in triples in the support of the graph). Since this subset of I is finite, using the active domain will lead to a query language whose results can be finitely encoded."}, {"title": "8 Related Work", "content": "There are many works on four-valued logics [8,17,15], but no one of them con- siders them for the semantics and query evaluation in SPARQL. Other works annotate SPARQL answers with lattice elements [13,2], but they do not provide a mean to operate with sets of statements encoding beliefs. Arnout et al. [1] consider knowledge graphs with negative facts. However, they do not consider conflicted statements as we did. Works on distributed knowledge contexts are all assuming that knowledge was represented using different ontologies but with the same epistemological status [4,7,9]. Some of them used SPARQL queries as mappings [19], but did not address epistemological status as a key concern. Schenk et al. [18] studies the semantics of trust and caching in the Semantic Web considering the FOUR structure, however did not consider the problem of querying."}, {"title": "9 Conclusions and Future Work", "content": "We presented eSPARQL, a novel approach that allows for the description of epistemic information using RDF-star and formulating epistemic queries using a query language which extends SPARQL-star. This query language is based on the concrete FOUR bilattice, but we expect to generalize it to include more general bilattices.\nFuture work could include the study of different ways to implement eS- PARQL. The most direct way is to build on top of a standard SPARQL-star engine. Indeed, the functionality of FROM BELIEF clauses to generate a new graph representing people's beliefs can be implemented with SPARQL-star CON- STRUCT queries, which use aggregate operations to compute states of dupli- cated statements on a set of beliefs. Then, SPARQL-star SELECT queries can be executed on top of the results from these CONSTRUCT queries. Other im- plementations include: (i) the whole rewriting of a eSPARQL query as a single SPARQL-star SELECT query, and (ii) using specialized indexes and algorithms to implement this query language.\nImplementation.\nWe implemented eSPARQL on top of Apache Jena [5], an open source SPARQL- star engine. Our implementation [14] is available under a free software license."}]}