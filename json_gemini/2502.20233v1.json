{"title": "Selective Use of Yannakakis' Algorithm to Improve Query\nPerformance: Machine Learning to the Rescue", "authors": ["Daniela B\u00f6hm", "Matthias Lanzinger", "Reinhard Pichler", "Alexander Selzer", "Georg Gottlob", "Davide Mario Longo", "Cem Okulmus"], "abstract": "Query optimization has played a central role in database research\nfor decades. However, more often than not, the proposed optimiza-\ntion techniques lead to a performance improvement in some, but\nnot in all, situations. Therefore, we urgently need a methodology\nfor designing a decision procedure that decides for a given query\nwhether the optimization technique should be applied or not.\nIn this work, we propose such a methodology with a focus on\nYannakakis-style query evaluation as our optimization technique\nof interest. More specifically, we formulate this decision problem as\nan algorithm selection problem and we present a Machine Learning\nbased approach for its solution. Empirical results with several bench-\nmarks on a variety of database systems show that our approach\nindeed leads to a statistically significant performance improvement.", "sections": [{"title": "1 INTRODUCTION", "content": "Query optimization has played a central role in database research\nfor decades. Some generally accepted techniques such as replac-\ning Cartesian product plus selection by a join or projecting out\nattributes not needed further up in the query plan as soon as pos-\nsible are guaranteed to (almost) always lead to a performance im-\nprovement. However, more often than not, optimization techniques\nproposed in the literature lead to a performance improvement in\nsome, but not in all, situations. Moreover, it is usually a non-trivial\ntask to delineate the situations where the application of a specific\noptimization is advantageous and where it is not. This also applies\nto optimization techniques which, in theory, should (almost) always\noutperform the conventional query evaluation methods.\nA prominent example of an optimization technique is Yannakakis'\nalgorithm [76] in case the query is acyclic. Several applications\nand extensions of this algorithm in recent time (see, e.g., [9, 36-\n38, 42, 70, 71]) witness the renewed interest in this approach. The\nkey idea of this algorithm is to first eliminate all dangling tuples (=\ntuples that will not contribute to the final result of the query) via\nsemi-joins and then compute the join with the guarantee that all\nintermediate results thus obtained will be extended to tuples in the\nfinal result. Hence, in a sense, Yannakakis' algorithm solves the (in\ngeneral NP-complete) join ordering problem that aims at avoiding\nthe explosion of intermediate results. In theory, such a strategy of\ncompletely avoiding the generation of useless intermediate results\nshould always be superior to conventional techniques that just try\nto compute the joins in an optimal order and thus aim at minimizing\nuseless intermediate results. However, in practice, it turns out that\nYannakakis' algorithm leads to a performance improvement in some\ncases but, by no means, in all cases.\nIn this work, we revisit a sub-class of acyclic queries called 0MA\n(= zero materialization aggregate) queries [25], where the theoreti-\ncal advantage of Yannankakis-style query evaluation is even more\nextreme: 0MA-queries are a restricted class of join queries with an\naggregate on top and which can be evaluated by carrying out only\nsemi-joins, i.e., completely avoiding the need for computing any\njoins. More precisely, after traversing the join tree T of such a query\nby semi-joins in bottom-up direction, the result can be computed\nfrom the relation resulting at the root node of T. Note that the\nquery given in Figure 1, which is a slightly modified version of a\nquery from the STATS benchmark (we have only replaced COUNT(*)\nin the SELECT-clause by a MIN-expression), falls into this class. In-\ndeed, if we consider a join tree of this query with the comments\nrelation at the root node, then we can evaluate this MIN-expression\nafter the bottom-up traversal with semi-joins by only considering\nthe resulting relation at the root node.\nIn theory, it is \"clear\" that such a join-less evaluation must always\noutperform conventional query evaluation techniques that first\nfully evaluate the underlying join query and only then apply the\naggregate as a kind of post-processing. Alas, empirical evaluation\non queries from several benchmarks shows that, in practice, this\nis not necessarily the case. Actually, for the query in Figure 1,\nYannankakis-style evaluation was significantly faster (by a factor of"}, {"title": "2 PRELIMINARIES", "content": "Conjunctive Queries and beyond. The basic form of queries studied\nhere are Conjunctive Queries (CQs), which correspond to select-\nproject-join queries in the Relational Algebra. It is convenient\nto consider CQs as Relational Algebra expressions of the form\n$Q = \\pi_U (R_1 \\Join \\dots \\Join R_n)$. Here we assume w.l.o.g., that equi-joins\nhave been replaced by natural joins via appropriate renaming of\nattributes. Moreover, we assume that selections applying to a single\nrelation have been pushed immediately in front of this relation\nand the $R_i$'s are the result of these selections. The projection list U\nconsists of attributes occurring in the $R_i$'s.\nTo go beyond CQs, we will also consider the extension of Rela-\ntional Algebra by the grouping operator $\\gamma$ and aggregate expres-\nsions. In other words, we are interested in queries of the form\n$Q = \\gamma_{g_1,...,g_e, A_1(a_1),...,A_m(a_m)} (R_1 \\Join ... \\Join R_n)$ (1)\nwhere $\\gamma_{g_1,...,g_e, A_1(a_1),...,A_m(a_m)}$ denotes the grouping operation for\nattributes $g_1,..., g_e$ and aggregate expressions $A_1(a_1),..., A_m(a_m)$.\nThe grouping attributes $g_1,..., g_e$ are attributes occurring in the\nrelations $R_1,..., R_n$, the functions $A_1, ..., A_m$ are (standard SQL) ag-\ngregate functions such as MIN, MAX, COUNT, SUM, AVG, MEDIAN,\netc., and $a_1, ..., a_m$ are expressions formed over the attributes from\n$R_1,..., R_n$. Note that we have omitted the projection $\\pi_U$ in Equa-\ntion (1), since it can be taken care of by the grouping. A simple\nquery of the form shown in Equation (1) is given in SQL-syntax in\nFigure 1.\nAcyclicity. Several forms of acyclicity have been studied in the liter-\nature [11, 22]. Our notion of acyclicity is the so-called a-acyclicity.\nAn acyclic conjunctive query (an ACQ, for short) is a CQ Q =\n$\\pi_U (R_1 \\Join \\dots \\Join R_n)$ that has a join tree, i.e., a rooted, labeled tree\n(T, r, \u03bb) with root r, such that (1) A is a bijection that assigns to\neach node of T one of the relations in {R1, ..., Rn} and (2) \u03bb sat-\nisfies the so-called connectedness condition, i.e., if some attribute\nA occurs in both relations \u03bb(ui) and \u03bb(uj) for two nodes ui and\nuj, then A occurs in the relation \u03bb(u) for every node u along the\npath between ui and uj. Deciding if a CQ is acyclic and, in the\npositive case, constructing a join tree can be done very efficiently\nby the GYO-algorithm (named after the authors of [27, 77]). The\njoin query underlying the SQL query in Figure 1 can be easily seen\nto be acyclic. A possible join tree is shown in Figure 2.\nYannakakis' algorithm. In [76], Yannakakis showed that ACQs can\nbe evaluated in time O((||D||+||Q(D)||)\u00b7||Q||), i.e., linear w.r.t. the\nsize of the input and output data and w.r.t. the size of the query. This\nbound applies to both, set and bag semantics. Let us ignore grouping,\naggregation, and projection for a while and consider an ACQ Q\nof the form $R_1 \\Join \\dots \\Join R_n$ with join tree (T, r, \u03bb). Yannakakis'\nalgorithm (no matter whether we consider set or bag semantics)\nconsists of a preparatory step followed by 3 traversals of T:\nIn the preparatory step we associate with each node u in the join\ntree T the relation \u03bb(u). If the CQ originally contained selection\nconditions on attributes of relation \u03bb(u), then we can now apply this\nselection. The 3 traversals of T consist of (1) a bottom-up traversal of\nsemi-joins, (2) a top-down traversal of semi-joins, and (3) a bottom-\nup traversal of joins. Formally, let u be a node in T with child nodes\nu1,..., uk of u and let relations R, Ri\u2081,..., Rik be associated with\nthe nodes u, u1,..., uk at some stage of the computation. In the 3\ntraversals (1), (2), and (3), respectively, they are modified as follows:\n(1) $R = ((((R \\Join R_{i_1}) \\Join R_{i_2})...)\\Join R_{i_k}),$\n(2) $R_{i_j} = R_{i_j} \\Join R$ for every $j \\in {1, . . ., k}$, and\n(3) $R = ((((R \\Join R_{i_1}) \\Join R_{i_2})...)\\Join R_{i_k}$\nThe result of the query is the final relation associated with the\nroot node r of T. Grouping and the evaluation of aggregates can be\ncarried out as post-processing after the evaluation of the join query.\nIn contrast, projection \u03c0U can be integrated into this algorithm by\nprojecting out in the second bottom-up traversal all attributes that\nneither occur in U nor further up in T. Of course, attributes neither\noccurring in U nor in any join condition can already be projected\nout as part of the preparatory step.\nThe correctness of Yannakakis' algorithm is seen by a closer look\nat the relations resulting from each traversal of T. For a node u of\nT, let R denote the original relation associated with u, i.e., \u03bb(u) = R,\nand let Ri\u2081,..., Ri, denote the relations labeling the nodes in the\nsubtree Tu of T rooted at u. Moreover, let R' denote the relation\nresulting from each traversal of the join tree. We again write (1),\n(2), (3) to denote the 3 traversals of the join tree. Then it holds:\nafter (1), we have $R' = \\pi_{Att(u)} (R_{i_1} \\Join ... \\Join R_{i_p}),$\nafter (2), we have $R' = \\pi_{Att(u)} (R_1 \\Join ... \\Join R_n),$\nafter (3), we have $R' = \\pi_{Att(T_u)} (R_1 \\Join ... \\Join R_n).$"}, {"title": "3 RELATED WORK", "content": "Acyclic queries and Yannakakis-style query evaluation. Yannakakis'\nalgorithm [76] has recently received renewed attention for the opti-\nmization of hard join queries. Recent work has focused on bringing\nits advantages into DBMSs from the outside via SQL query rewrit-\ning [24, 25, 41], and similar methods such as generating Scala code\nexpressing Yannakakis' algorithm as Spark RDD-operations [16].\nEven more recently, Yannakakis-like approaches have been pro-\nposed, which aim to reduce the overhead of the full Yannakakis'\nalgorithm for enumeration, with its 3 traversals, by instead propa-\ngating up additional data and computing the whole query in only\none traversal. Such approaches have been integrated into Spark\nSQL [42], Umbra [9], DuckDB [29], and Apache DataFusion [7].\nFurther research extends Yannakakis' algorithm to non-equi-join\nqueries, such as differences of CQs [36], acyclic queries with com-\nparisons [71], and queries with theta-joins [38].\nDecompositions. In order to go beyond acyclic queries, a major\narea of research seeks to extend Yannakakis-style query answer-\ning to \"almost-acyclic\" queries via various notions of decomposi-\ntions and their associated width measures, such as hypertree-width,\nsoft hypertree-width, generalized hypertree-width, and fractional\nhypertree-width [3, 26, 28, 41]. Several implementations [1, 16, 57,\n68] combine Yannakakis-style query execution with worst-case\noptimal joins [53]. To address the problem of minimal-width de-\ncompositions not necessarily being cost-optimal, approaches of\nintegrating statistics about the data into the search for the best\ndecomposition have been proposed and implemented [41, 60].\nQuery rewriting. Optimizing queries before they enter the DBMS\nis a different strategy towards query optimization that has been\nsuccessfully applied in standard DBMSs [82, 83]. Although DBMSs\nalready perform optimizations on the execution of the query, it\nhas been shown that rewriting the query itself can still be highly\neffective. The WeTune [72] system goes even further, and can be\nused to automatically discover rewrite rules but comes with the\ndisadvantage of extremely long runtimes.\nMachine learning for databases. There has been growing interest\nin the application of machine learning techniques to increase the\nperformance of database systems, as can be seen by a recent survey\non this broad area [81]. We proceed to give a very brief overview\nof the general topics as to how machine learning has been adapted\nfor database research. For a more detailed account on the rich inter-\naction between machine learning and databases, we refer to [81].\nIn this survey, the authors categorize the different efforts of using\nmachine learning for core database tasks into the following groups.\nThe first group is \"learning-based data configuration\". These are\nworks that aim to utilize machine learning for knob tuning, and view\nadvisor and index advisor tasks [5, 13, 18, 34, 45, 54, 61, 66, 79, 86].\nThe next group is \"learning-based data optimization\". These works\naim to tackle important, computationally intractable problems such\nas join-order selection and cardinality estimation of joins [19, 21, 33,\n39, 49, 50, 52, 55, 56, 63, 67, 69]. Another group is \"learning-based\ndesign for databases\". These works aim more specifically at explor-\ning the use of machine-learning in the construction of various data\nstructures used by modern databases, such as indexes, hashmaps,\nbloom filters and so on [17, 40, 47, 75]. A further group listed in the\nsurvey is \"learning-based data monitoring\". As the name suggests,\nthese works aim to use machine learning to create systems that au-\ntomate the task of running a database and detecting and reacting to\nanomalies [30, 48, 50, 65, 84]. Lastly the survey mentions \"learning-\nbased database security\". This category is on how to use machine\nlearning based methods to help with critical problems, such as\nconfidentiality, data integrity and availability [6, 8, 15, 46, 62].\nQuery performance prediction. Predicting the performance of a query\nusually the runtime, or sometimes the resource requirements\nis related to the problem of deciding whether to rewrite a query.\nRuntime prediction has been performed by constructing cost models\nbased on statistical information of the data [32], on SQL queries [74],\nand XML queries [84]. Further approaches use machine learning and\ndeep learning to predict the runtimes of single queries [50, 80, 85]\nor concurrent queries (workload performance prediction) [4, 20]."}, {"title": "4 FORMULATING THE ALGORITHM\nSELECTION PROBLEM", "content": "Whenever a new, optimized method for query evaluation is pre-\nsented, we need a decision program that decides whether the new\nmethod should be applied or not. We are thus faced with an algo-\nrithm selection problem, where we have to decide, for every data-\nbase instance and query, which query evaluation method should\nbe applied. In this section, we describe the steps needed to actu-\nally formulate the precise algorithm selection problem at hand. An\noverview of this workflow is given in Figure 3."}, {"title": "4.1 Benchmark Data", "content": "We aimed to gather a diverse set of data and queries from different\ndomains, designed for different purposes. Thus, we have chosen sev-\neral widely used benchmarks, which represent a variety of queries\nand datasets: (1) The JOB (Join Order Benchmark) [43], which was\nintroduced to study the join ordering problem, is based on the real-\nworld IMDB dataset and contains realistic join-aggregation queries\nwith many joins and various filter conditions, (2) STATS/STATS-\nCEB [31] is based on the Stackexchange-dataset, and contains many\njoin queries not following FK/PK-relationships, (3) Four different\ndatasets (namely cit-Patents, wiki-topcats, web-Google and com-\nDBLP) from SNAP (Stanford Network Analysis Project) [44], a collec-\ntion of graphs, which we combine with synthetic queries introduced\nin [42], (4) LSQB (Large-Scale Subgraph Query Benchmark) [51],\nwhich was designed to test graph databases as well as relational\ndatabases, consists of synthetic data and hard queries based on\na social network scenario, and (5) HETIONET [35]. The latter is\nless known in the database world. It contains real-world queries\non real-world data from a heterogeneous information network of\nbiochemical data, and is part of the new CE benchmark[14], which\nhas, for instance, been recently used in [9] and [7].\nWe are only interested in ACQs (possibly with group-by and\naggregates). Most of the queries in the chosen benchmarks are CQs\nwith additional filter conditions applied to single tables. These filter\nconditions can be taken care of by the preparatory step; so they\npose no problem. However, not all of the CQs are acyclic; so we\nhave to eliminate the cyclic ones from further consideration. The\nnumber of (acyclic) CQs of each dataset is given in Table 1.\nNote that some of the queries in the benchmarks are enumer-\nation queries and some already contain some aggregate (in par-\nticular, MIN) and satisfy the 0MA conditions. Of course, also from\nthe enumeration queries, we can derive 0MA queries by putting\nan appropriate aggregate expression (again, in particular, with the\nMIN aggregate function) into the select-clause of the query. We do\nthis by randomly choosing a table occurring in the query and one\ncolumn of this table (mostly the first column in the table). We will\nsee in Section 4.2. that it makes no significant difference which\ntable and attribute we choose for turning a query into 0MA form,\nas we will vary the table and attribute anyway."}, {"title": "4.2 Data Augmentation", "content": "As can be seen in Table 1, we get 219 acyclic queries from the\nchosen benchmarks. Since we want to use these queries to train"}, {"title": "4.3 Selection of DBMSS", "content": "We want to check the effectivity of the optimized evaluation follow-"}]}