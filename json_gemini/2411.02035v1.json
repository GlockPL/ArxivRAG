{"title": "SibylSat: Using SAT as an oracle to perform a greedy search on TOHTN Planning", "authors": ["Gaspard Quenard", "Damier Pellier", "Humbert Fiorino"], "abstract": "This paper presents SibylSat, a novel SAT-based method designed to efficiently solve totally-ordered HTN problems (TO-HTN). In contrast to prevailing SAT-based HTN planners that employ a breadth-first search strategy, SibylSat adopts a greedy search approach, enabling it to identify promising decompositions for expansion. The selection process is facilitated by a heuristic derived from solving a relaxed problem, which is also expressed as a SAT problem. Our experimental evaluations demonstrate that SibylSat outperforms existing SAT-based TOHTN approaches in terms of both runtime and plan quality on most of the IPC benchmarks, while also solving a larger number of problems.", "sections": [{"title": "Introduction", "content": "Hierarchical Task Network (HTN) planning [9] is a field of Artificial Intelligence dedicated to decomposing complex tasks into simpler subtasks. This hierarchical approach improves planning speed and scalability, especially in practical applications [12]. Unlike classical planning, HTN planning introduces abstract tasks representing complex, non-executable actions, and decomposition methods that break down abstract tasks into partially ordered sets of primitive actions and abstract tasks. The main goal of an HTN planner is to determine how an initial abstract task can be decomposed into a plan i.e., an executable sequence of primitive tasks.\nIn this paper, we focus our investigation on a highly popular subclass of HTN problems where the decomposition methods specify a totally-ordered list of primitive actions and abstract tasks to be executed in order to achieve an abstract task, namely Totally-Ordered HTN (TOHTN) planning. The prevalent approaches to TOHTN planning are either to use heuristic search, e.g., [13, 14, 15], to encode planning problems into STRIPS problems in order to benefit from the constant improvements of the classical planners, e.g., [1, 2, 8], or to encode them into propositional logic, e.g., [5, 23, 4, 21] and use highly optimized solvers. The latter has attracted renewed interest over the last few years, especially with planners performing particularly well in recent International Planning Competitions (IPC). The work presented in this paper aligns with this trend.\nIn the realm of TOHTN planning, the prevailing strategy among current SAT planners is to employ a \"breadth-first search\" approach, bounded by the number of decompositions of the initial abstract task. Specifically, for a given bound k, the logical encoding considers plans where the initial task can be decomposed at most k times. If no solution is found within this bound, k is increased, broadening"}, {"title": "HTN Planning Problem", "content": "This paper adopts a description of TOHTN planning inspired by the formulation presented in [5, 4], which is an adaptation of the HTN planning description outlined in [11] tailored to totally ordered planning."}, {"title": "Task, Action, Methods, and Task Networks", "content": "The central concept in HTN Planning is the notion of tasks. A task is characterized by a name and a list of parameters. There are two types of tasks: primitive tasks and abstract tasks. While primitive tasks directly affect the state of the world, abstract tasks do not; however, they must be decomposed into primitive tasks via decomposition methods before they can be executed. The HTN planning problem specifies how a method can decompose an abstract task into a"}, {"title": "Planning Problem and Solution", "content": "We define a TOTHN planning problem as follows:\nDefinition 1 (TOHTN Planning problem) A totally ordered HTN Planning problem P is a tuple (L, C, O, M, C1, s1, g) where: L is a finite set of propositions; C is a finite set of abstract (or compound) tasks; O is a finite set of primitive tasks (or actions); M is a finite set of decomposition methods (or methods); C1 \u2208 C is the initial abstract task; S1 \u2286 L is the initial state and g is the (possibly empty) goal state.\nSolving a planning problem P involves finding a primitive task network (or plan) \u03c0 which can be decomposed from the initial abstract task (c1 \u2192* \u03c0) such that \u03c0 is executable in the initial state s1 and reaches the goal g after execution, i.e., g \u2286 \u03b3(s1, \u03c0). Unlike classical planning, a solution to a TOHTN planning problem is not only a sequence of primitive tasks executable in the initial state of the problem and reaching a goal state, but it must also express the decomposition methods used which lead to this sequence of primitive tasks. Such a solution can be represented by a tree called a decomposition tree [11] which shows the full trace indicating how an abstract task is refined into a task network.\nDefinition 2 (Decomposition tree) A decomposition tree (DT) for a task network w for a problem P = (L, C, O, M, C1, s1, g) is a tree T = (N, E) with:\n\u2022 N - A set of nodes labelled by either a primitive task, an abstract task or a method,\n\u2022 E : N \u2192 N* - the edge function which provides for every node an ordered list of children (e1, e2, ..., ek),\n\u2022 For every inner node n labelled by an abstract task c, |E(n)| = 1 and E(n) = (n') where n' is labelled by a method m \u2208 M(c).\n\u2022 For every inner node n labelled by a method m, let us consider (t1, t2,..., tk) the subtasks of m, then |E(n)| = k and ei is labelled by the task ti for all ei \u2208 E(n) = (e1, e2, ..., ek).\n\u2022 For the sequence of leafs L = (n1, n2, .., nk), it holds that each leaf if labelled by either a primitive task or an abstract task and if we consider the corresponding sequence of tasks (t1, t2,..., tk), then we have w = (t1, t2,..., tk).\nWe can now formally define a decomposition tree solution as follows:\nDefinition 3 (Decomposition Tree solution) Let P = (L, C, O, M, C1, s1, g) be a planning problem. Consider Tsol as the decomposition tree for the task network \u03c0 for the problem P. The decomposition tree Tsol is a solution for P if and only if it achieves the following characteristics:\n1. The root of Tsol is the initial abstract task c1.\n2. \u03c0 only contains primitive tasks.\n3. \u03c0 is executable in the initial state sI.\n4. \u03c0 reaches the goal g after execution."}, {"title": "Path Decomposition Tree and SAT planners", "content": "Since finding a solution for an HTN planning problem is equivalent to finding a decomposition tree (DT) that satisfies some characteristics, one way to find a solution is to test all possible DTs that exist for a problem P. However, the search space representing all possible DTs is very large for most domains and infinite for recursive domains (domains in which an abstract task can be obtained by decompositions from the same abstract task). To address this issue, [5, 23] suggested creating structures that represent a subset of all possible DTs to check if they contain valid solutions. If no solution is found, these structures can be expanded to encompass additional DTs. These proposed structures are designed to ensure they can be expanded to include any possible DT for a given problem. Here, we introduce an isomorphic equivalent of their structures:\nDefinition 4 (Path Decomposition Tree) A path decomposition tree (PDT) for a problem P = (L, C, O, M, C1, s1, g) is a tree \u0393 = (N, E) with:\n\u2022 N - A set of nodes labelled by either a primitive task, an abstract task or a method,\n\u2022 E : N \u2192 N* - the edge function which provides for every node an ordered list of children (e1, e2, ..., ek).\nWe denote the root node of the PDT as rr. We call the PDT well-formed if and only if:\n\u2022 The root node of the PDT rr is labelled by the initial abstract task of the problem c1.\n\u2022 For every inner node n labelled by an abstract task c, |E(n)| = |M(c)| and mi \u2208 M(c), \u2203ei \u2208 E(n) such that ei is labelled by the method mi.\n\u2022 For every inner node n labelled by a method m, let us consider (t1, t2,..., tk) the subtasks of m, then |E(n)| = k and ei is labelled by the task ti for all ei \u2208 E(n) = (e1, e2, ..., ek).\n\u2022 For every leaf n', n' is labelled by either a primitive task or an abstract task."}, {"title": "SibylSat planner", "content": "Like other SAT-based TOHTN planners, SibylSat employs a PDT as a search space and adheres to a standard procedure of alternating between expanding the search space, encoding, and invoking a SAT solver to find a solution plan. However, a significant departure lies in the expansion strategy, which does not follow a breadth-first approach. Instead, SibylSat selects promising abstract tasks for expansion.\nThe procedures are illustrated as a pseudo-code in Algorithm 1. The algorithm begins by initializing the PDT with a single node representing the initial abstract task of the problem. Then, the process alternates between two phases until a solution is found: one where SibylSat seeks a solution DT within the PDT (which acts as the termination condition), and another where it expands the PDT by exploring first the most promising abstracts tasks. To achieve this, it focuses on finding and developing a promising DT within the PDT, where 'promising' refers to a DT whose expansion (i.e., the development of all its pending nodes) could lead to a solution DT. The choice of the promising DT to develop is made by searching for a solution DT in a relaxation of the PDT where abstract task leaves are considered as actions. The DT solution found in this relaxed PDT is used as a heuristic to identify which pending nodes need to be developed in the PDT to reach a solution. Specifically, any abstract task that is part of the plan of the relaxed solution DT will have its corresponding leaf in the PDT developed. The search for a solution DT in the PDT, as well as a promising DT in its relaxed counterpart is done by a SAT solver.\nA necessary (but not sufficient) condition to ensure the completeness of our planner is that any subtree of a solution DT must also be recognized as a promising DT in a relaxed PDT. Failure to meet this condition could result in overlooking viable solutions. Therefore, when relaxing the PDT, the preconditions and effects assigned to an abstract task must be carefully inferred to comply with this requirement. The approach for deducing them will be detailed in an upcoming section. Note that this implication is not bidirectional: a promising DT does not necessarily lead to a solution DT when further developed. The accuracy with which we can represent abstract tasks as actions (i.e., how well we can infer their preconditions and effects) brings us closer to achieving this equivalence. It should also be noted that a relaxed PDT typically contains several promising DTs available for further development. We do not use a deterministic method to select which promising DT to develop. Instead, we entrust this decision to our SAT solver, which acts as an oracle in this context. Specifically, we use an incremental SAT solver (i.e., a solver that can be queried multiple times with a growing set of clauses and is able to preserve its knowledge base from previous solving iterations), which aids in maintaining a consistent trajectory when choosing a promising DT to develop as it incrementally builds upon previous decisions.\nAlgorithm 1 is \"greedy\" because it expands the PDT by using the first relaxed solution DT it finds in its expansion phase, even if there are multiple relaxed solution DTs in a PDT. This method is complete for non-recursive planning domains because there is a limited number of DTs, and our algorithm eventually finds them all as it keeps expanding the PDT. However, this approach is generally non-terminating for recursive domains because the algorithm can keep expanding DTs in the PDT that cannot lead to a solution DT. We will explain how we can transform the algorithm 1 to be terminal in a later section."}, {"title": "Planning approach", "content": "1: procedure SIBYLSAT(P = (L, C, O, M, CI, SI,g))\n2:\n3:\nPDT \u2190 INITIALIZEPDT(P)\nreturn GREEDY(PDT)\n4: end procedure\n5: procedure GREEDY(PDT)\n6:\n7:\n8:\n9:\n10:\n11:\n12:\nDTsol \u2190 FINDSOLUTION (PDT)\nif DTsol \u2260 then\nreturn DTsol\nend if\nDTrelaxed \u2190 FINDPROMISINGDT(PDT)\nPDT \u2190 EXPANDPDT(PDT, DTrelaxed)\nreturn GREEDY(PDT)\n13: end procedure"}, {"title": "Example", "content": "To illustrate our algorithm, we detail how the PDT of a problem P is developed by our planner in Figure 1. SibylSat is initialized by creating a PDT with a single root node, Troot, representing the problem's initial abstract task. It then alternates between a search phase and an expansion phase until a solution DT is found.\nIn the initial search phase, since Troot is abstract, the PDT does not contain a solution DT, prompting the first expansion phase. In the expansion phase, SibylSat uses the relaxation technique to transform all the abstract task leaves, in this case, Troot, into actions. A search is then performed within the relaxed PDT, which identifies the relaxed DT of the plan (Troot) as a solution. This DT is then developed within the PDT, leading to an expanded PDT encapsulating the initial three layers of Figure 1, before returning to the search phase.\nThe second search phase fails again to find a solution DT in the PDT, leading to another expansion phase. In this phase, the PDT is relaxed once more by treating the abstract task leaves T2, T3 and T5 as actions and trying to find a solution DT in this relaxed PDT. Notably, within this relaxed PDT, two potential solution DTs emerge: one involving the task network (A0, T2) and another comprising (T3, A1, T5). Assuming that these task networks are both executable in the problem's initial state and can reach the goal after execution, the SAT solver selects one of them for further development. In this example, the SAT solver chooses the DT of the task network (T3, A1, T5), prompting SibylSat to expand the corresponding nodes T3 and T5, which leads to the whole PDT in Figure 1 before returning to the search phase.\nIn this search phase in the PDT, SibylSat identifies the solution DT with the plan (A2, A1, A3), leading to a successful termination of the planner. However, should this solution prove non-executable in the initial state, the absence of other possible solution DTs would have led to another expansion phase of the PDT. In that case, if both the DT of the task networks (A0, T2) and (A2, A1, Ts) are relaxed solution DTs, then, the SAT solver would have returned either of those two, which would have led to developing either the node T2 or the node T5."}, {"title": "Searching for solution DT in PDT", "content": "During the search phase, our planner needs to determine whether a PDT contains a solution DT as its subtree. To achieve this, the approach of SAT-based TOHTN planners is to create a SAT formula that is satisfiable if and only if a solution DT exists in the PDT. Given that our search space is structurally congruent with those proposed by [21, 23, 5, 4], we can use any of the encodings introduced in these papers to search for a solution DT. We opted for the encoding used by the Lilotane planner specifically because it can be employed with an incremental solver, which enables our solver to keep knowledge of previous solving iterations when looking for solution DTs and relaxed solution DTs. Given that the encoding is no different from that proposed by Lilotane for a PDT, we do not detail the specific SAT rules used to search for a solution DT in this paper."}, {"title": "Expansion of the PDT", "content": "In this section, we present the expansion phase of the PDT. This phase occurs when there are no solution DTs in the current PDT (i.e., the search procedure has failed to find a solution DT). As such, some pending leaves need to be expanded to allow the PDT to capture a larger set of DTs. The core idea of our expansion phase is to find a DT that is a subtree of a solution DT. If such a DT could be found, developing it would lead to expanding the PDT toward having a solution DT as its subtree. However, finding a DT leading to an executable primitive plan is not feasible, as it would require knowing a solution DT for the problem in the first place. As such, we are interested in an approximation. This approximation takes the form of finding instead a promising DT: a DT that may lead to a solution DT when developed. We define a DT as 'promising' if its relaxed task network is executable in the initial state and reaches the goal after execution. To relax a task network, we convert all its abstract tasks into actions with preconditions and effects based on the possible decompositions of the respective abstract task. As such, finding a promising DT is equivalent to finding a solution DT in a relaxed PDT where all abstract task leaf nodes are converted into actions.\nWe now turn to the process by which the preconditions and effects of an abstract task are inferred. As detailed in the planning approach, a necessary condition for completeness is that all subtrees of a solution DT are recognized as promising DTs. Consequently, the preconditions and effects inferred for an abstract task must be applicable for all refinements into primitive task networks of the respective abstract task.\nFirst, we explain the inference of preconditions for an abstract task. These preconditions must encapsulate the facts necessary for any feasible refinement of an abstract task. [20] have referred to such preconditions as 'mandatory preconditions', a concept used in several planners [21, 16] to prune DTs in their search space that do not lead to an executable sequence of primitive tasks. In our planner, we employ the algorithm for inferring mandatory preconditions proposed by [21].\nLet us now consider the effects of an abstract task. Unlike actions, where effects are explicitly defined, abstract tasks introduce uncertainty in the resulting state. Indeed, for an action a, the transition \u03b3(s, a) = (s \\ effect\u2212(a)) \u222a effect+(a) precisely defines the post-execution state. In contrast, it is difficult to properly define the post-execution state of an abstract task since it can be decomposed into multiple different primitive task networks with different post-execution effects. Our solution for this problem is to compute all the poss-effect+(t) (respectively poss-effect\u2212(t)) of an abstract task, which correspond to all the positive (respectively negative) facts that may be caused by a refinement of the abstract task.\nIf we successfully compute these two sets, we can then define an overestimation of the post-execution state of an abstract task t. This is achieved by considering the execution of t as leading to a nondeterministic state, which falls within a range determined by subtracting any subset of poss-effect\u2212(t) and adding any subset of poss-effect+(t) to the pre-execution state.\n[4] have shown that computing the exact set of possible effects of an abstract task is PSPACE or EXPTIME-complete depending on the hierarchical decomposition structure of the respective task. However, it is possible to find an over-approximation of them in polynomial time. For our algorithm, we compute an over-approximation of the possible effects of an abstract task (denoted poss-effect) with the following formula:\nposs-effect(t) = \u222a poss-effect(t\u2032)\nt\u2032\u2208subtasks(m),m\u2208M(t)"}, {"title": "Expanding PDT leafs", "content": "Finally, let us explain how we develop the pending nodes of a PDT based on a solution DT found in a relaxed PDT. In the relaxed PDT, all abstract task leaf nodes are considered actions. Consequently, the plan in the solution DT may include abstract tasks. For each of these abstract tasks, we develop the corresponding node in the PDT, as well as all the immediate child method nodes. This approach ensures that all leaves of the PDT contain either primitive or abstract tasks. For example, as illustrated in Figure 1, if the plan in the solution DT for the relaxed PDT is (A0, T2), then the node containing T2 and its immediate method children will be developed.\nNote that in our implementation, we use the search space proposed by the Lilotane planner, where each node contains all the abstract tasks that may occur simultaneously at some degree of refinement. To adhere to the incremental encoding provided by Lilotane, where some rules depend on the full set of operations within a node, we develop all the abstract tasks within the same node when such a node is expanded. A potential next contribution could be to alter the encoding to allow for the selective development of only the abstract tasks found in the relaxed solution DT."}, {"title": "Ensuring completeness for recursive domains", "content": "As the current description given for our planner is greedy instead of the \"breadth-first search\" used by the other TOHTN SAT plan-"}, {"title": "Evaluation", "content": "We compared SibylSat against other state-of-the-art SAT-based TO-HTN planners to evaluate its performance. The evaluation involved three planners: SibylSat\u00b9, our planner with the approach to ensure completeness linked with the Glucose solver [3]; Lilotane [21], a Lifted SAT TOHTN planner and runner-up of the 2020 International Planning Competition (IPC); and pandaPIsatt-1iB [4], an improved version of their original TOHTN planner totSAT [5]. The experiments were conducted on a system with an Intel Core i7-12700H CPU and 32GB of RAM. Each problem instance was given a maximum runtime of 10 minutes. The evaluations covered all TOHTN benchmarks proposed in the IPC 2020 and IPC 2023."}, {"title": "Evaluation Metrics", "content": "The performance of the planners is evaluated using two different metrics:"}, {"title": "IPC Score", "content": "The IPC score measures the speed of the planner in solving a problem. The score ranges from 0 to 1 for each problem, with 1 indicating that the planner solved the problem in less than one second and 0 indicating a timeout. The IPC score is calculated as follows:\nIPC Score =\n  {\n    min(1,1-log(t)/log(T))   if a plan is found\n   0                            If no plan is found\n  }\nwhere T is the maximum runtime allowed for finding a plan, and t is the time taken to find a plan, in seconds."}, {"title": "Quality Score", "content": "The quality score measures the makespan (i.e., the total number of actions in a plan). It ranges from 0 to 1, with 1 indicating the shortest plan and 0 indicating that no solution was found. The quality score is calculated as follows:\nQuality Score =\n  {\n    Cref/C if a plan is found\n   0     If no plan is found\n  }\nwhere C is the makespan of the plan found by the planner and Cref is the best makespan among all evaluated planners."}, {"title": "Results", "content": "domains in the benchmarks, our planner achieves a better IPC score in 19 of them and also surpasses other planners in terms of coverage and quality score. Note that the quality score is computed based on the first solution DT found, and therefore does not include any plan improvement procedures, such as the one proposed by Lilotane, which allows finding the solution DT with the shortest plan within a PDT at the cost of a higher runtime.\nTo verify if the expansion strategy proposed by SibylSat effectively allows exploring a smaller part of the search space before finding a solution DT, we compare in Figure 3 the number of methods developed before finding a solution DT by Lilotane and SibylSat, as both use the same structure to represent the search space. The figure shows that our approach generally reduces the number of methods developed before finding a solution DT in most domains. In some domains, such as Towers and Childsnack, the number of methods developed by our planner is similar to that of Lilotane because Lilotane already develops the minimal number of nodes in its structure to find a solution DT. The only benchmark where our planner develops more methods than Lilotane is the AssemblyHierarchical domain (purple star markers in Figure 3). This is reflected in the results, as it is the only benchmark where SibylSat's IPC score is lower than that of both Lilotane and PandaPIsatt-1iB. An analysis of the AssemblyHierarchical domain reveals the underlying reason for this outcome. Most of the abstract tasks in this domain are recursive and interconnected, leading to a larger set of possible effects for each task. Because of this complexity, the possible effects of each abstract task are extensive and often lead our planner to find impractical relaxation solution DT. Improving our algorithm for the inference of possible effects of the abstract tasks could likely assist with this type of problem."}, {"title": "Related Work", "content": "The use of SAT-based HTN planners was first introduced by Mali and Kambhampati in 1998 [17], although their representation of HTN problems differed significantly from the current formalisms and their encoding was incapable of handling recursive domains. Despite this early exploration, there was a two-decade gap in research that specifically focused on translating HTN planning problems into propositional logic. This changed with the introduction of totSAT in 2018 [5], a SAT-based translation of TOHTN planning which outperformed other state-of-the-art HTN planners and revitalized interest in this approach. Unlike classical planning, which extends encodings iteratively along the length of the final plan, totSAT uses a breadth-first search to extend encodings along the depth of the hierarchy. Following this work, Behnke et al. refined their approach to handle partially ordered HTN planning [6], optimal plan finding [7], and proposed techniques to prune the search space and enhance their encoding [4]. Concurrently with totSAT, Schreiber et al. proposed a new encoding that was the first to leverage incremental SAT solving [22] for HTN problems. An enhancement of this approach led to the development of the Tree-REX planner [23], which explores the search space similarly to totSAT but whose translation to propositional logic is specifically designed for incremental SAT solving, providing improved performance and smaller encodings. Following this work, Schreiber et al. introduced Lilotane [21], a successor to Tree-REX and the first lifted TOHTN SAT-based planner. Lilotane is able to avoid the costly grounding process by using a lazy instantiation approach for tasks and methods, allowing free arguments where needed, resulting in SAT formulas that are considerably smaller than previous encodings."}, {"title": "Conclusion", "content": "In this paper, we have presented a novel SAT-based approach for solving TOHTN planning problems that uses a SAT solver both for searching for solutions and guiding the exploration of the search space. Specifically, we demonstrated how encoding a relaxed problem can help uncover a heuristic with a SAT solver, which can then be used to identify promising areas in the search space. We have shown that our planner, which uses this heuristic to greedily explore the search space, outperforms other state-of-the-art SAT-based TOHTN planners in runtime and plan quality. This work paves the way for integrating heuristic information into SAT-based TOHTN planning.\nIn future work, we plan to explore methods beyond our current greedy search strategy. Specifically, we aim to determine if identifying multiple promising areas within the search space using our heuristic, then ranking and prioritizing them with classical HTN heuristics [13, 14, 15], could lead to improved performance."}]}