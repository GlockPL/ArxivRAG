{"title": "A NOVEL FRAMEWORK FOR AUTOMATED WAREHOUSE LAYOUT GENERATION", "authors": ["Atefeh Shahroudnejad", "Payam Mousavi", "Oleksii Perepelytsia", "Sahir", "David Staszak", "Matthew E. Taylor", "Brent Bawel"], "abstract": "Optimizing warehouse layouts is crucial due to its significant impact on efficiency and productivity. We present an AI-driven framework for automated warehouse layout generation. This framework employs constrained beam search to derive optimal layouts within given spatial parameters, adhering to all functional requirements. The feasibility of the generated layouts is verified based on criteria such as item accessibility, required minimum clearances, and aisle connectivity. A scoring function is then used to evaluate the feasible layouts considering the number of storage locations, access points, and accessibility costs. We demonstrate our method's ability to produce feasible, optimal layouts for a variety of warehouse dimensions and shapes, diverse door placements, and interconnections. This approach, currently being prepared for deployment, will enable human designers to rapidly explore and confirm options, facilitating the selection of the most appropriate layout for their use-case.", "sections": [{"title": "1 Introduction", "content": "The main goal of Warehouse Management Systems (WMS) is running operations as efficiently as possible to improve profitability through increasing productivity, reducing labor costs, and ultimately increasing customer satisfaction. One of the key components of a WMS is optimal space utilization. It reduces the need for a larger capacity warehouse by maximizing inventory storage and minimizing wasted or underutilized areas. Moreover, warehouse configuration has a direct impact on all warehouse operations, especially the worker routing and picking processes. Efficient warehouse configurations (i.e., layouts) can enhance the order fulfillment process by eliminating unnecessary movement and related errors, resulting in time and cost savings Mohamud et al. [2023], Richards [2017]. However, the vast majority of warehouses worldwide still continue to rely on manual management or basic automation Albert et al. [2023]. There are a range of traditional and non-traditional manual layout designs that have been proposed over the years to speed"}, {"title": "2 Methodology", "content": "We aim to create warehouse layouts that balance various factors such as storage capacity, sufficient number of access points, ease of navigation, and average projected throughput during item retrieval. After generating a range of candidate layouts, an experienced warehouse designer can select from the candidates or further refine them. For any candidate chosen in this interactive selection process, the layout would then undergo a thorough validation by an on-site team prior to implementation.\nWe propose a novel candidate layout generation algorithm (see Algorithm 1) to generate optimal layouts based on tree search. A given space is specified by a discrete two-dimensional grid of cells with several masks marking the positions of walls $M_{walls}$ and door connections $M_{door\\_connections}$. Figure 1 shows a running example of a sample space from our industry partner. Each unit cell in the grid is colored based on what category it belongs to: walls, door connections, aisles, storage, or pick face. The grid is initialized with all cells fully occupied $L_{full}$. The tree search then explores the space of possible layouts by systematically carving new aisles. Invalid nodes (i.e., layouts violating any constraints) are filtered in the Layout Filtering step (explained in Section 2.2). The valid layouts are scored using a custom scoring function, and those with the highest score are designated as optimal. As discussed before, there are typically multiple optimal (and viable) layouts for consideration by the customer. In Figure 1, each colored path represents a route that leads to the best possible solution for a particular setting."}, {"title": "2.1 Tree Search", "content": "Due to the time-intensive nature and memory constraints of exhaustive tree search at scale, we employ beam search for exploring the tree. Beam search is a heuristic Breadth-First Search (BFS) algorithm that helps to make local decisions and limit the search space. In the default setting (beam size: b = 1), for each node in the tree: (i) all children are"}, {"title": "2.2 Layout Filtering", "content": "To ensure that only viable and efficient layouts are selected, we sift through all generated children layouts and reject those that violate any functional or efficiency constraints as defined below:\nFunctional constraints:\n\u2022 Aisles that are connected to pick faces can not be narrower than the specified aisle width,\n\u2022 All aisles need to be reachable by all doors into the warehouse space,\n\u2022 No item is allowed to be placed in doorways or areas marked as \"reserved,\" and\n\u2022 No pillar can block an aisle.\nEfficiency constraints:\n\u2022 Aisles wider than the minimum required size are not allowed as they waste space,\n\u2022 Two-sided access block stores should contain at least two rows, and\n\u2022 Each block store should contain more than one item as it is never efficient or desirable to store a single item at a given location."}, {"title": "2.3 Layout Scoring", "content": "Candidate solutions are evaluated and the underperforming tree nodes are pruned. The scoring function is a critical component used as a heuristic in the tree search. A misspecified score will be detrimental to the node expansion of"}, {"title": "2.4 Connectivity Score", "content": "In addition to the scoring function presented above, we define another score term, connectivity to estimate the likely relative throughput expected from different candidate layouts. Note that the exact throughput cannot be known a priori as it will depend on specific product assignment and order lists. Our estimates here are used only to determine the ranking order of different candidates as a tool to select among several optimal candidates generated above. The connectivity score is defined as the average cumulative ratios of shortest distances to the Manhattan distances Black [2006] for pairs of pick faces:\n$C = \\frac{1}{N_{pf}} \\sum_{i,j} D_{Shortest}/D_{Manhattan}$,\nwhere $N_{pf}$ is the number of pick faces, and $D_{i,j}$ is the distance (i.e., shortest or Manhattan) between two pick face locations.\nThis is based on the intuition that for a high-throughput (i.e., more connected) layout, the shortest distances (between pairs of pick faces) will on average be closer in value to the Manhattan distance. This function has the additional desired property that it is normalized to one, facilitating simple direct comparisons between different layouts. Note that we decided not to include connectivity as an independent scoring term in Eq. (1) to simplify the process and minimize instabilities in the search."}, {"title": "2.5 Post-Refinement", "content": "The objective of the post-refinement step is to apply any additional constraints to arrive at the final layouts. While every application will require some customization by the on-site team often these constraints and requirements can be codified to save time. In one application, the pallet racking system only allowed even numbers of racking units along the total block store (due to how the racking infrastructure was constructed). In another application, clear paths were necessary to access pillars that contained fire safety equipment. In both cases, the flexibility of our algorithm allowed for these constraints to be programmatically applied as a final step, only passing layouts that fulfilled the criteria."}, {"title": "2.6 Implementation Details", "content": "Our method is adjustable to larger beam sizes. By increasing the beam size, the search space is expanded as more children are explored at a time. However, it also increases the exploration time. Therefore, we use multiprocessing to expedite the search process, especially for larger beam sizes. We used eight CPU cores with 16GB of memory to run experiments. For a medium-sized space (50 \u00d7 55), the average processing time for generating the Pareto plot (e.g., Figure 2) is 85s."}, {"title": "3 Results", "content": "To generate all possible optimal layouts for a given space, the layout generation process is run separately for all combinations of \u03b1 and @ in their defined ranges. Drawing from the pool of generated optimal layouts, we create a Pareto"}, {"title": "4 Discussion", "content": "Warehouse layout design plays a vital role in warehouse operations performance. We proposed a novel automated optimal layout candidate generation framework using beam search that satisfies a set of constraints. We also introduced a new scoring function that handles a balance between storage capacity, number of access points, and accessibility cost. Our method can generate a wide variety of candidate layouts for different ranges of picking and storage areas and we demonstrated this in two real-world physical spaces. The simplicity of the method makes it easily adaptable to any changes in user specifications and requirements.\nDespite all these strengths, our approach is not without limitations. One limitation is that we were unable to measure the throughput of the layouts and compare their performances comprehensively. Throughput depends on order lists and item allocation, which would add a layer of complexity that is beyond the scope of this work. As throughput is the ultimate measure of effectiveness, not being able to account for these factors restricts our ability to fully evaluate"}, {"title": "Algorithms", "content": "\\begin{algorithm}\n\\caption{Candidate Layout Generation (beam size =1)}\n\\begin{algorithmic}[1]\\scriptsize\n\\REQUIRE Inputs: $M_{walls}$, $M_{door\\_connections}$ //input masks\n\\STATE Initialize: Start from the full space : $L_{full}$\n\\STATE $Q \\gets Queue()$ //create an empty queue\n\\STATE $Q.push(L_{full})$\n\\STATE $L_{optimal} \\gets L_{full}$\n\\WHILE {not $Q.empty()$} \\\\\n        \\STATE $L \\gets Q.pop()$\n        \\STATE Generate all children by carving aisles horizontally and vertically for all block stores in $L$\n        \\IF {$L == L_{full}$} \\THEN // first level\n                \\STATE score valid children\n                \\IF {highest score $> L_{optimal} \\ score$} \\THEN\n                    \\STATE $L_{optimal} \\gets$ valid children with highest score\n                    \\STATE $Q.push(all children)$\n                    \\STATE break\n                \\ENDIF\n        \\ENDIF\n        \\FOR {All children ($C_1,..., C_n$)}\n            \\IF {$c_i$ is valid} \\THEN //filtering step\n                \\STATE Score $C_i$\n                \\IF {children highest score $>= L \\ score$} \\THEN\n                    \\STATE $Q.push$(children with highest score)\n                    \\IF {children highest score $> L_{optimal} \\ score$} \\THEN\n                        \\STATE $L_{optimal} \\gets $children with highest score\n                    \\ENDIF\n                \\ENDIF\n            \\ENDIF\n        \\ENDFOR\n\\ENDWHILE\n\\RETURN $L_{optimal}$\n\\end{algorithmic}\n\\end{algorithm}"}, {"title": "Layout Scoring Equations", "content": "\\begin{equation}\nScore = T_{s} + \\beta T_{pf} + c_{1} T_{o},\\label{}\n\\end{equation}\n\\begin{equation}\nT_{s} = \\frac{N_{s}-c_{2}\\theta P_{a}}{Total \\ open \\ area}.\n\\end{equation}\n\\begin{equation}\nP_{a} := \\frac{\\Sigma w_{i}.max_{j \\in BSi}(h_{j} - 1)^{2}}{\\frac{}{}\\mid BSi\\mid}.\n\\end{equation}\n\\begin{equation}\nT_{pf} = \\frac{N_{pf}}{N_{s}},\n\\end{equation}"}]}