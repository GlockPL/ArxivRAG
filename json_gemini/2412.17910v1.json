{"title": "A Novel Approach to Balance Convenience and Nutrition in Meals With Long-Term Group Recommendations and Reasoning on Multimodal Recipes and its Implementation in BEACON", "authors": ["Vansh Nagpal", "Siva Likitha Valluru", "Kausik Lakkaraju", "Nitin Gupta", "Zach Abdulrahman", "Andrew Davison", "Biplav Srivastava"], "abstract": "A common, yet regular, decision made by people, whether healthy or with any health condition, is to decide what to have in meals like breakfast, lunch, and dinner, consisting of a combination of foods for appetizer, main course, side dishes, desserts, and beverages. However, often this decision is seen as a trade-off between nutritious choices (e.g., salt and sugar levels, nutrition content) or convenience (e.g., cost and speed to access, cuisine type, food source type). We present a data-driven solution for meal recommendations that considers customizable meal configurations and time horizons. This solution balances user preferences while taking into account a food's constituents and cooking process. Beyond the problem formulation, our contributions include introducing goodness measures, a recipe conversion method from text to the recently introduced multimodal rich recipe representation (R3) format, learning methods using contextual bandits that show promising preliminary results, and the prototype, usage-inspired, BEACON system.", "sections": [{"title": "Introduction", "content": "Although it is well known that nutritious foods are essential to a person's health, the actual adherence to dietary requirements is quite poor across the world. In fact, according to a recent meta-survey (Leme et al. 2021), almost 40% of the population across high and low- and medium-income countries do not adhere to their national food-based dietary guidelines, often prioritizing convenience over nutrition needs. Previous studies have shown that adhering to a provided meal plan instead of a self-selected one reduces the risk for adverse health conditions (Metz et al. 1997). Some people prefer getting food recommendations from their friends or family, and others turn to online recommender systems (Yang et al. 2017) or even Large Language Models (LLMs)(Rostami 2024) as they have become easily available in the form of chatbots, which can be inaccurate, misleading, or not wholly informed. For example, authors in (Papastratis et al. 2024) found that ChatGPT alone is not a reliable tool for meal recommendation when assessing ChatGPT-based recommenders for balanced diets in non-communicable diseases (NCDs) patients.\nWe seek to help the general population decide on meal choices while nudging them towards healthy choices by leveraging data from online recipes, domain knowledge about meals and how they are configured from foods, and user preferences (Figure 1). In doing so, we recognize the reality that people want to explore a variety of foods, and a long-horizon meal recommender can act as a trusted companion seeking to keep the user well informed even when they deviate from nutrition guidelines.\nOur contributions are that we: (1) introduce a novel approach to the meal recommendation problem, accounting for variable meal configurations and flexible time horizons, and propose innovative quantitative metrics to evaluate the framework and benchmark its performance against relevant baselines, (2) adopt the multi-modal R3 framework to convert recipes from two prominent fast food chains into R3 representations, leveraging various LLM-based methodologies to ensure robust and accurate transformation, and (3) present the design of the BEACON meal recommender system, showcasing its potential through a compelling and practical use case to effectively balance both convenience and nutrition.\nIn the remainder of the paper, we provide relevant background in automated recommendations of personalized meals and then discuss our problem formulation, key solution components including data (recipe representation and format conversion) and meal recommendation, and their evaluation. We then describe a prototype implementation of the solution in the BEACON system along with the supported use cases and conclude with a discussion of practical considerations and avenues for future extensions."}, {"title": "Related Work", "content": "There is a large body of literature on recommendation methods for single items (Su and Khoshgoftaar 2009; Cremonesi, Koren, and Turrin 2010). In many practical situations, a group of items has to be recommended, as in the case of team formation. Here, although the group problem can be treated as a special case of sequential single-item recommendation problem (Srivastava et al. 2022), better results are found when treating them as a group (Valluru et al. 2024a,b,c). Our work falls in the latter category.\nThere are food recommendation systems in literature that"}, {"title": "Problem Formulation", "content": "We define the problem statement by explaining the inputs and outputs of the proposed system (Figure 1). Let (R) be the set of all recipes in the R3 representation.\nLet (U) be the set that contains all user-provided information, including dietary conditions( Healthy or Diabetic), their ternary food preferences (likesDairy, likesNuts, likesMeat), meal plan format constraints (C). C includes daily meal names corresponding to the number of meals requested per day (such as Mid-Morning Snack or Dinner), the meal components for each represented as a set MC C {Beverage, Main, Side, Dessert}, and the length of the meal plan in days. 2. The output of our system, MP, is a meal plan consisting of meals from (R) informed by (U) in JSON format with a schema defined by C, with meal items outputted by one of three methods, each of which is described more in detail in Solution Components: random"}, {"title": "Solution Components and BEACON System Implementation", "content": "Figure 1 shows the proposed BEACON's architecture."}, {"title": "Data Component: Recipes and R3 Preparation", "content": "We will first motivate our chosen data representation for our recipes, then our methods for converting new recipes to this representation, and finally, the effectiveness of our approach in converting food in that format.\nExisting recipes on the internet are available as inconsistently structured textual documents which makes it difficult for machines to read and reason. Better representation of such information can improve decision support systems and also provide an easy way to query and get insights from the data. (Pallagani et al. 2022) introduced a Rich Recipe Representation (R3) which represents recipes in a structured JSON format. They created twenty-five egg-based recipes in R3 manually from original recipes taken from the RecipeQA dataset (Yagcioglu et al. 2018). To expand the existing twenty-five R3 recipes from the RecipeQA dataset, we considered fast food recipes which are known for their convenient access and soul food recipes which are culturally relevant to the African-American population. In this work, we generate recipes for eleven items served by McDonald's, ten served by Taco Bell, and two commonly known soul food dishes: fried okra and pumpkin soup.\nSince LLMs have been reported to be effective in many natural language and data processing tasks (Zhang et al. 2024), including automated machine translation (Chitale, Gala, and Dabre 2024), we wanted to study the effectiveness of using LLMs for the task of automating the conversion of online recipe texts to corresponding R3 structures. For this text-to-JSON translation task, we employed two in-context learning-based methods (Dong et al. 2022). We note that there are costlier alternatives line finetuning (Escarda-Fern\u00e1ndez et al. 2024) and designing LLMs-from-scratch (Srivastava and Pallagani 2024), which we leave as possible future extensions.\nThe twenty-five RecipeQA recipes were extracted manually, requiring end-to-end human effort, with a method denoted by RCo. We then employed a semi-automated approach denoted by RC1, using ChatGPT (GPT 3.5) to convert the recipes into their intended R3 structure. Finally, we considered a fully automated approach, denoted by RC2 utilizing Mixtral-8x7B-Instruct-v0.1's(Jiang et al. 2024) API available through HuggingFace."}, {"title": "R3 Evaluation Metrics", "content": "Before expanding on the usage of LLMs for R3 conversion, it is pertinent to discuss the metrics for evaluation of the conversions. We describe four metrics: semantic similarity score ($s_{sem}$), syntatic similarity score ($s_{syn}$), perplexity ($s_{ppl}$), and JSON decoding error count ($s_{jec}$).\nSemantic Similarity Score: To assess if the semantic meaning and essence is preserved in the R3 representation, we generate an embedding vector for the original recipe text ($V_{org}$) and for the R3 JSON string ($v_{r3}$), and calculate the BERTScore (Zhang et al. 2020) $s_{sem} \\in [-1,1]$.\nSyntatic Similarity Score: To assess if the structure of the R3 representation of a metric is similar to other R3 representations in terms of the present JSON keys, we initialize a set, $R3_{keys} = {(k,n)}$, where k is a key in the JSON string and n is the nesting level of the key. We then populate $R3_{keys}$ with all of the keys and nesting levels in the R3 representations of the twenty-five egg-based recipes curated using method RCo.\nPerplexity: As it is common to measure the informativeness of an LLM's output, we use perplexity to assess the confidence of the LLM's generated R3 representations (Miaschi et al. 2021). We denote it by $S_{ppl}$.\nJSON Decode Error Count: LLMs tend to make mistakes when generating a JSON string, including missing and extra characters like quotations, brackets, and commas. For this reason, when processing an LLM's output, we count the number of these mistakes, $S_{jec}$."}, {"title": "LLM-based Conversion Methods", "content": "We now present two methods for recipe format conversion, one semi-automated (RC1) and another automated (RC2).\nHybrid-LLM conversion of recipes to R3 (RC1): Converting recipes with this approach exploits the summarization and machine translation in LLMs and involves manually collating different portions of the R3 representation, as described below.\n(1) Ingredients and Nutrients Extraction: For extracting ingredients with amounts and units, we use 0-shot prompting. We copied the list of ingredients with their amounts as presented in the online recipes and input it into ChatGPT with the prompt \u201cPlease extract the ingredients from this list in this JSON structure: \", with the JSON structure in Figure 6 appended. We provided a similar prompt and JSON structure (Figure 7 for nutritional information, including macronutrients, such as proteins or carbohydrates, and micronutrients like vitamins and minerals.\n(2) Instruction Extraction: For properly extracting instructions with atomic steps, we utilize the chain-of-thought prompting and few-shot prompting (Ma et al. 2024; Zhang et al. 2023) by first inputting to it the prompt seen in Figure 9. Following this, we provided it a series of prompts with JSON strings of the form seen in Figure 8.\n(3) Meal Component Annotation: Each of the input recipes are structured in a formal representation using JSON and\""}, {"title": "Meal Recommendations Component", "content": "We will first present the goodness metrics for evaluation meal plans, then recommendation methods, and finally the evaluation for said recommendation methods.\nGoodness Metrics for Recommendations We use three different evaluation criteria to evaluate a recommendation. These criteria include assessing the recurrence of items across meals and within meals (duplicate metric, md), assessing if the recommended meals satisfy the preferred components (meal coverage metric, cs), and assessing if the recommended meals have ingredients that match user preferences (user-constraint metric, uc). For each recommendation, we compute the goodness score Gas a weighted sum of the individual scores md, cs, and uc, with weights tailored to user preferences (e.g., some users may prefer having duplicates in their meals, while others may not). We elaborate on the three metrics below.\nDuplicate Metric (dm) Our duplicate metric examines the occurrence of repeated items meals as a meal item duplicate. The meal item duplicate score, denoted as dmi for a particular meal mi, measures the ratio of unique items to total items within the meal. For a recommendation comprising multiple meals m1, ..., mn, we calculate the meal item duplicate score dm as the average of all meal item duplicate scores dm1,..., dmn.\nMeal Coverage Metric (mc) Our meal coverage metric evaluates the extent to which a meal recommendation aligns with the user's desired food roles (Main Course, Side Dish, Dessert, or Beverage). To calculate the coverage score for a recommendation, we analyze the presence of recommended meal items corresponding to their role and alignment with user preferences. If a recommended item matches its assigned role and aligns with user preferences (indicated using a weight of +1), it positively contributes to the coverage score. Conversely, misaligned recommended items (e.g., recommending a beverage item like soda as a side dish) would incur a penalty on the coverage score. For each meal, mi, we calculate a coverage score mci by taking the ratio of requested roles fulfilled to the number of requested roles. We calculate our final coverage score, mc, as the average of all scores mc1, ..., Mcn.\nUser Constraint Metric (uc) In addition to specifying the types of food roles they prefer in each meal, users also provide their ingredient preferences, focusing on three key features: dairy content, meat content, and nuts content. These features were chosen to create a minimally functional system, with plans to extend the list of features in the future. Each feature can have a user preference value of -1, 0,"}, {"title": "Use Case Walk-through and Demonstration", "content": "In the following sections, we describe a detailed use case of the BEACON system and consider the ethical, legal, and security ramifications of the deployed system. Our proposed solution can be used in a variety of different use cases, including serving as a meal planner for: (a) diabetic individuals looking to be recommended meals that help them manage their condition, (b) individuals from minority communities looking to be recommended culturally relevant meals, (c) busy professionals seeking convenient and healthy meal options, (d) medical professionals seeking to recommend meal plans to their patients."}, {"title": "Ethical, Legal, and Security Considerations", "content": "Ensuring ethical, legal, and secure practices is central to the BEACON system. The system is distributed under the MIT license, ensuring easy access while crediting appropriate intellectual property (IP)."}, {"title": "Evaluation", "content": "Recipe Translation with LLMs Evaluation\nWe conclude from the Tables 3 and 4 that freely accessible, pre-trained LLMs alone can not consistently generate large JSON structures. We note that only one out of 24 configurations (1-shot, e\u2081, t = 0.3 were able to generate a properly formatted JSON string, which is why all other configurations do not report a syntactic score. Additionally, all LLM-based methods of recipe conversion (RC1, RC20, RC2B) consistently score more than the manual RC method in terms of preserved semantic information. We also note that manually curated recipes report a significantly lower syntactic score than ones generated using method RC1, which is because we consider the set of all keys in all of our R3 recipes as our reference set. LLMs may produce a lot of unnecessary keys that are not in the manually curated set of R3 recipes. Expectedly, manually curated R3 recipes report the highest semantic score as a human ensures that information is not lost in translation. We conclude that LLMs must be used in conjunction with rule-based or manual methods for data processing or be fine-tuned on the specific problem domain to be more effective.\nBEACON Recommendation Evaluation\nWe conduct our experiments for each recommendation method across 3 different time frames t\u2081 (1 day) t2 (3 days), and t3 (5 days) and 3 user configurations, C1, C2, and C3. These user configurations all include 24 users. For each of the food features that we consider (hasDairy, hasMeat, hasNuts), we consider the corresponding user features {uf} that can each take on a value of -1, 0, or 1. These values correspond to negative preference, neutral preference, and positive preference respectively. For each ci and feature uf, we randomly select p\u2081 users to have a positive preference to uf, ni users to have a negative preference to uf, and the remaining to have a neutral preference to uf. In C1, C2, and c3, we choose n\u2081 = P1 = 12, n2 = p2 = 8, and n3 = p3 = 2. Thus, the constraints on users' preferences are decreasing across the configurations. Each c\u2081 is referred to as ni/(24 - ni - pi)/pi in Figure 5, corresponding to negative, neutral, and positive preference. For each experiment that we conducted, we display our three metrics: user constraint (uc), duplicate meal (dm), and meal coverage (mc), as well as their average (uc_dm_mc). We display our results graphically in Figure 5. Please refer to Table 5 for an equivalent tabular view.\nAs shown in Figure 5, M2 expectedly outperforms other methods in the user constraint metric and meal coverage metric as it is the most informed out of the three. It is important to note that when there are fewer users with negative preferences towards the food features, MO and MI only perform marginally worse because users are less particular about their preferences. MI always scores perfectly in the duplicate meal metric because there are more items in our dataset than are in a meal, while M2 performs the worst, which is caused by M2 favoring very few items with a higher probability of being a positively recommended item. This causes M2 to perform poorly in the uc_dm combination metric for most trials. Additionally, in the uc_dm metric, M2 performs the worst in the C3 configuration because users are less particular and M2 is more likely to recommend duplicates. However, since, MO and MI do not perform nearly as well in the me and uc metrics, M2 performs significantly better in the uc_dm_mc, uc_mc, and dm_mc combination metrics. We can also see that M2 is a precise and accurate method regardless of the user configuration and MO and M1 are somewhat accurate for some metrics, but lack precision. We thus conclude that the boosted bandit algorithm represented by M2 is the most effective in recommending meals out of the three."}, {"title": "Discussion and Conclusion", "content": "As mentioned previously, we only considered two LLMs (ChatGPT, Mixtral-8x7B-Instruct-v0.1) in our recipe conversion efforts, as we wanted to determine if such an effort could be undertaken at minimal cost. We conclude that these LLMs alone can not successfully translate plain text recipes into R3 representations. A future extension of this work, it may be worthwhile to consider fine-tuning an LLM on recipe translation or considering larger models behind a paywall.\nIn conclusion, in this paper, we introduced the novel problem of meal recommendation considering different meal configurations and time horizons, presented our solution which utilizes the boosted bandit method to address the problem of meal recommendation, displayed a dataset of 50 R3 items consisting of non-fast food and fast food items (Taco Bell and McDonald's), contributed a unique goodness metric that can be used to assess the quality of recommendations, showed the efficacy of the boosted bandit method for generating robust recommendations across three user configurations and three time frames, as well as motivating a use case of the BEACON system, which is in development. We believe this can be a promising path toward promoting user adherence to dietary nutrition guidelines while balancing convenience.\nIn the future, one can extend this work in many directions, including (1) increasing the size of our dataset as this leads to more robust models by exploring more LLM-based approaches; (2) increasing the number of features in terms of ingredients/allergens so that our dataset is more varied, and users with more allergens can receive positive recommendations; (3) experimenting with different recommendation algorithms and methods so that we may further explore the use of R3 representations; and (4) conducting qualitative evaluation to show the acceptance of our recommendation system."}, {"title": "BEACON Implementation", "content": "System Architecture and Design\nThis section describes the architectural design of the web application, which employs a hybrid approach combining React for the frontend and Django for the backend. This design aims to leverage the strengths of both frameworks to optimize system performance, user experience, and scalability. Additionally, the system incorporates a combination of relational and semi-structured data storage formats to efficiently manage diverse data types, including user profiles, recipes, and meal plans.\n1. Frontend Architecture: On the frontend, the system utilizes React to implement a dynamic Single Page Application (SPA) architecture. React's component-based design facilitates the development of a highly responsive user interface, enabling seamless navigation and interaction without requiring full-page reloads. This SPA-like behavior enhances the user experience, especially for features such as recipe navigation and interactive data visualizations. For complex data visualizations, the system integrates D3.js, a powerful JavaScript library that enables the rendering of sophisticated, data-driven graphics directly within the user's browser. By offloading the processing of visualizations to the client-side, this approach minimizes the load on the server, thereby improving scalability and responsiveness. Jest is employed for unit testing of React components, ensuring the reliability and maintainability of the frontend codebase. Dependency management for the frontend is handled through npm, which facilitates the installation and resolution of JavaScript package dependencies.\n2. Backend Architecture: On the backend, Django is employed to manage server-side operations, including user authentication, data processing, and the execution of machine learning algorithms for personalized meal plan generation. Django is chosen for its robustness, scalability, and comprehensive support for web application development. The backend will interact with AWS EC2 instances for scalable storage of user data, meal plans, and recipe information. The Django framework facilitates the creation of RESTful APIs through the Django REST Framework (DRF), enabling seamless communication between the frontend and backend. The use of DRF ensures that the system can efficiently handle requests from the frontend and manage data exchange in a structured manner.\n3. Data Management:\n\u2022 Users: User data is stored in a relational database, with a schema designed to capture detailed attributes related to user profiles. Each user record includes essential fields such as name, email, username, and UUID (serving as the primary key). Additionally, the schema includes attributes for capturing user-specific health conditions, dietary restrictions, and food preferences, such as height, weight, isVegan, isDiabetic, as well as individual food preferences and allergies (e.g., likesDairy, allergicToGluten). This relational format ensures the integrity and consistency of user data.\n\u2022 Recipes: Recipes are stored in a NoSQL database using a JSON-based schema (R3 format), designed to capture the complexity and variability of recipe data. The recipe schema includes fields such as recipe_name, food_role, and macronutrients. Recipes also include detailed ingredient lists, each of which specifies ingredient quantities, potential allergens, and associated image paths. Cooking instructions are stored in an array, allowing for the inclusion of multiple steps, each with relevant metadata (e.g., action name, output quality, background knowledge). This semi-structured format facilitates flexibility in the representation of diverse recipe data.\n\u2022 Meal Plans: Meal plan data is also stored in a NoSQL database in JSON format. Each meal plan is organized by day, with each day's entries containing details about meals, including meal_name, beverage, main_course, side, and dessert. This format supports flexibility in meal organization and allows for easy modification and retrieval of meal plans for users.\n4. Scalability and Infrastructure: To ensure the system is capable of scaling effectively, AWS EC2 instances are employed to host both the frontend and backend components of the application. AWS EC2 offers scalable cloud infrastructure, allowing the system to dynamically allocate resources based on varying levels of demand. This ensures that the web application can accommodate increasing user traffic without compromising performance. EC2's flexibility enables the system to scale horizontally, with additional instances provisioned to meet the needs of high-traffic periods. Additionally, the system benefits from the security and reliability features provided by AWS, including data redundancy, automatic load balancing, and secure data storage.\nThe use of EC2 allows for seamless scaling of both compute and storage resources, which is critical as the application evolves and the user base grows. As a result, the architecture is designed to handle future demands and provide the necessary infrastructure to support a high-availability, high-performance application."}]}