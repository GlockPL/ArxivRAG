{"title": "Queries With Exact Truth Values in Paraconsistent Description Logics", "authors": ["Meghyn Bienvenu", "Camille Bourgaux", "Daniil Kozhemiachenko"], "abstract": "We present a novel approach to querying classical inconsistent description logic (DL) knowledge bases by adopting a paraconsistent semantics with the four 'Belnapian' values: exactly true (T), exactly false (F), both (B), and neither (N). In contrast to prior studies on paraconsistent DLs, we allow truth value operators in the query language, which can be used to differentiate between answers having contradictory evidence and those having only positive evidence. We present a reduction to classical DL query answering that allows us to pinpoint the precise combined and data complexity of answering queries with values in paraconsistent ALCHI and its sublogics. Notably, we show that tractable data complexity is retained for Horn DLs. We present a comparison with repair-based inconsistency-tolerant semantics, showing that the two approaches are incomparable.", "sections": [{"title": "Introduction", "content": "Ontology-mediated query answering (OMQA) has been extensively studied over the past fifteen years as a promising paradigm for querying incomplete and heterogeneous data (Poggi et al. 2008; Bienvenu and Ortiz 2015; Xiao et al. 2018). In a nutshell, OMQA enriches the data with an ontology which provides both a convenient vocabulary for query formulation as well as domain knowledge that is exploited when answering queries. Ontologies are typically formulated in logic-based languages (description logics, DLs, being a popular choice) and equipped with a first-order logic semantics, whereby a Boolean ('yes or no') query is deemed to hold whenever it is entailed from the logical theory consisting of the data and ontology. An important practical concern with (traditional) OMQA is its lack of robustness in the presence of contradictory information, as every Boolean query is entailed from an inconsistent knowledge base.\nA prominent approach to tackling data inconsistencies in OMQA is to adopt inconsistency-tolerant semantics based upon repairs, defined as inclusion-maximal subsets of the data that are consistent with the ontology. Arguably the most natural repair-based semantics is the AR semantics (Lembo et al. 2010) that considers those answers that hold w.r.t. each repair, inspired by analogous semantics for inconsistent databases (Arenas, Bertossi, and Chomicki 1999). Other commonly considered repair semantics include the more permissive brave semantics (Bienvenu and Rosati 2013), which only requires an answer to hold in at least one repair, and the more cautious IAR semantics (Lembo et al. 2010), which queries the intersection of all repairs. Several other repair-based semantics, incorporating closure operations or various kinds of preferences, have been explored, see (Bienvenu and Bourgaux 2016; Bienvenu 2020) for an overview of repair-based semantics for DL knowledge bases.\nParaconsistent logics represent another natural approach to obtaining meaningful answers from contradictory knowledge bases. Whereas repair-based semantics are defined in terms of the consistent subsets of the inconsistent theory, paraconsistent logic semantics, often based upon extended sets of truth values, makes it possible for classically inconsistent theories to possess models. A common approach is to augment the classical set of truth values {T, F} with two additional elements - B (both true and false) and N (neither true nor false).\u00b9 The four values can be interpreted as four kinds of information one can have on a given assertion A(a): only be told that A(a) is true, only be told that A(a) is false, be told that A(a) is both true and false, and be told nothing about A(a).\u00b2 The truth and falsity conditions of Boolean connectives \u00ac, \u2293, and \u2294 are then defined as follows:\n\u2022 \u00acA(a) is true if A(a) is false and vice versa;\n\u2022 [A\u2293 B](a) is true if A(a) and B(a) are true, and false if A(a) or B(a) is false;\n\u2022 [A\u2294 B](a) is true if A(a) or B(a) is true, and false if A(a) and B(a) are false.\nParaconsistent DLs were first introduced by Odintsov and Wansing (2003) and have since then been extensively studied. In particular, four-valued counterparts of expressive description logics such as SH\nOIN(D) and SROIQ were considered (Ma, Lin, and Lin 2006; Ma and Hitzler 2009; Maier 2010; Maier, Ma, and Hitzler 2013). Moreover,"}, {"title": "Four-Valued ALCHI and Its Fragments", "content": "In this section, we provide the syntax and semantics of four-valued DLs, equipped with a new constructor \u25b3 that was previously added to Belnap-Dunn propositional logic and its first-order expansion by Sano and Omori (2014), and which can be intuitively interpreted as follows: \u25b3A(a) means that A(a) is true and \u00ac\u25b3A(a) that A(a) is not true (as opposed to \u00acA(a) which means that A(a) is false).\nSyntax Let CN, RN and IN be three mutually disjoint countable sets of concept, role, and individual names, respectively, and let RN\u2260 = RN\u222a {R\u2212 | R \u2208 RN} be the set of roles and inverse roles. Given a DL language L, an LA knowledge base (KB) K = (T, A) consists of a finite set A of concept and role assertions of the form A(a) and R(a, b) respectively, with a, b \u2208 IN, A \u2208 CN, and R \u2208 RN, called the ABox, and a finite set T of axioms whose form depends on the DL L, called the TBox. An ALCHIA TBox contains role inclusions of the form S \u2286 S' where S, S' \u2208 RN\u2260 and concept inclusions of the form C \u2286 D where C and D are ALCHI concepts built using the following grammar:\nC := \u22a4 | \u22a5 | A | \u00acC | \u25b3C | C\u2293C | C\u2294C | \u2203S.C | \u2200S.C\nwith A \u2208 CN and S\u2208 RN\u2260. We also write C \u2261 D as a shorthand for {C \u2286 D, D \u2286 C}. We sometimes use \u2022 and \u25e6 to denote binary connectives from {\u2293, \u2294} and Q and Q for quantifiers from {\u2203, \u2200}, assuming that \u2022 \u2260 \u25e6 and Q \u2260 Q. An L KB is defined as an LA KB except that it cannot contain \u25b3A. Besides ALCHI, we will consider the following DL languages which are sub-languages of ALCHI: ALCH has no inverse roles, ALCI has no role inclusions, ALC has neither, ELHI does not allow \u00ac, \u2200 and \u25b3, and ELH1, ELI and EL1 are obtained from ELHI by disallowing inverse roles, role inclusions, and both respectively. Finally DL-Liter TBoxes contain role inclusions of the form S \u2286 S' or S \u2288 S' and concept inclusions of the form B1 \u2286 B2 or B1 \u2288 B2 with B := A | \u2203S.\u22a4. ELHI and its sub-logics are Horn DLs and we call propositional TBoxes the TBoxes that do not use the \u2293 and \u2294 constructors.\nSemantics The semantics of LA is defined through interpretations, which differ from classical DL interpretations in that they define both positive and negative extensions of concepts. A 4-interpretation is a tuple I = (\u0394I, .Ip, .In) with a domain \u0394I \u2260 \u2205, and two interpretation functions Ip and In that map each concept name A \u2208 CN to AIp\u2286 \u0394I and AIn\u2286 \u0394I respectively, each role name R \u2208 RN to RIP = RIn \u2286 \u0394I \u00d7 \u0394I and each individual name a \u2208 IN to aIp = aIn \u2208 \u0394I. For role and individual names interpretations, we can thus omit p and n and simply write RI and aI. The interpretation functions .IP and .In are extended to complex ALCHI concepts and roles as follows.\n(R\u2212)I = {(y, x)|(x,y)\u2208RI}\n\u22a4I = \u0394I\n(\u00acC)Ip = CIn\n(\u25b3C)In = \u0394I\\CIP\n(C\u2293D)Ip = CIp \u2229 DIP\n(\u2200S.C)Ip = {x | \u2200y : (x, y) \u2208 SI \u21d2 y \u2208 CIp}\n(1)"}, {"title": "Queries With Exact Truth Values", "content": "Before introducing our novel approach to querying four-valued DL KBs, let us recall the query language and semantics considered by Zhou et al. (2012).\nDefinition 4. Let Var be a set of variables disjoint from IN and Term = Var \u222a IN. A conjunctive query (CQ) has the form q := \u2203y1...ym: \u03c6 where y1,..., ym \u2208 Var and \u03c6 is a conjunction of atoms of the form R(t, t') or A(t) with t, t' \u2208 Term, R \u2208 RN and A \u2208 CN. A CQ q is Boolean (BCQ) if no variable occurs in it freely.\nA KB K 4-entails a BCQ q (K\u22a84 q) if for every 4-model I = (\u0394I, .Ip, .In) of K, there is a match \u03c0 : Term \u2192 \u0394I such that for every c\u2208 IN, \u03c0(c) = c, and for every R(t1, t2) (resp. A(t)) that occurs in q, (\u03c0(t1), \u03c0(t2)) \u2208 RI (resp. \u03c0(t) \u2208 AIp).\nWe make an important observation (not explicit in (Zhou et al. 2012)), namely, that in the case of Horn DLs, answering CQs under paraconsistent semantics amounts to answering them classically over the 'positive' part of the KB obtained by dropping the weak disjointness axioms. Recall that a classical, two-valued, KB K entails a BCQ q, denoted K |= q, iff there is a match for q in every model of K.\nProposition 5. If K is an ELHI\u00ac\u25b3 KB and K+ denotes the ELHI KB obtained from K by dropping all inclusions of the form A \u2286 \u00acB, then for every BCQ q, K \u22a84 q iff K+ |= q.\nProof. Assume that K \u22a84 q. If K+ has no classical model, then K+ |= q. Otherwise, let I = (\u0394I, .I) be a model of K+. Define J = (\u0394I, .Ip, .In) with AIn = \u0394 for every A \u2208 CN. Since \u00ac only occurs in inclusions of the form A \u2286 \u00acB in K, it is easy to check that J \u22a84 K. It follows that J \u22a84 q, which implies the existence of a match for q in J by construction of J. Hence K+ |= q.\nThe fact that paraconsistent query answering in Horn DLs basically amounts to ignoring possible sources of contradiction provides strong motivation for exploring a more expressive query language that better exploits the paraconsistent semantics. We propose such a language by introducing four value operators corresponding to Belnapian values.\nDefinition 5 (Queries with values). A conjunctive query with values (CQV) is a CQ whose atoms are of the form R(t, t'), A(t) or X(A(t)) with X \u2208 {T, B, N, F}. A Boolean CQV (BCQV) has no free variable."}, {"title": "Complexity of Query Answering", "content": "In this section, we establish the complexity of answering CQVs. We do this by constructing a reduction of CQV answering to answering union of conjunctive queries (UCQs) over classically interpreted knowledge bases."}, {"title": "Comparison With Repair-Based Semantics", "content": "In this section, we compare paraconsistent querying semantics with existing repair-based semantics. When dealing with repair-based semantics, we assume a classically consistent TBox, i.e., we assume that if a KB is inconsistent, it is due to errors in the ABox. For our comparison, we will naturally consider the popular AR semantics, which deems a tuple to be an answer if it holds w.r.t. every repair. We shall further consider repair-based semantics that provide minimal under-approximation and maximal over-approximations of AR (Bienvenu and Bourgaux 2016): IAR, brave and CAR. The IAR semantics retains only the \"safest\" answers that are true in the intersection of the repairs, while the brave semantics considers all answers that hold in at least one repair. Finally, the CAR semantics over-approximates the AR semantics in a way that is incomparable with brave, by incorporating a closure operation on the ABox. The latter semantics may seem closer in spirit to paraconsistent reasoning where the positive extensions retain all consequences of the axioms.\nThe formal definitions of repairs and the considered repair-based semantics follow. Recall that ABox A is called T-consistent if the KB (T, A) is (classically) consistent.\nDefinition 9 (Repairs). Let K = (T, A) and define\nC\u03c4(A) = {\u03c6 | \u2203 A'\u2286 A, (\u03c4, A') |= \u03c6 for some \u03c4-consistent A'\u2286 A}\n\u2022 A repair of K is a maximal T-consistent subset of A.\n\u2022 A closed repair of K is a T-consistent R \u2286 C\u03c4(A) for which there is no T-consistent R' \u2286 C\u03c4(A) s.t. either (1) R \u2229 A \u2282 R' \u2229 A or (2) R \u2229 A = R' \u2229 A and R \u2282 R'.\nWe denote the set of all repairs (resp. closed repairs) of K with Rep(K) (resp. CRep(K)).\nDefinition 10 (Repair semantics). Let q be a Boolean CQ.\n\u2022 K |=AR q if (T, A') |= q for every A' \u2208 Rep(K).\n\u2022 K |=brave q if (T, A') |= q for some A' \u2208 Rep(K).\n\u2022 K |=IAR q if (T, \u2229A' \u2208 Rep(K)A' )|= q.\n\u2022 K |=CAR q if (T, R) |= q for every R \u2208 CRep(K).\nWe recall the relations between these semantics.\nK |=IAR q\n\u21d3\nK |=AR q\n\u21cf\nK |=brave q\n\u21cf\nK |=CAR q\nWe start by remarking that \u22a84 over-approximates |=brave in Horn DLs.\nTheorem 4. If K is an ELHI\u00ac\u25b3 KB and q is a BCQ, then K |=brave q implies K \u22a84 q.\nProof. Assume that K |=brave q: there is a classically consistent subset K' \u2286 K such that K' |= q. By Proposition 7, K' \u22a84 q because q does not contain any value operator. It follows that K \u22a84 q. Indeed, every 4-model of K is a 4-model of K' and since q does not contain any value operator, item 2 of Definition 7 is vacuously true.\nNote that Theorem 4 and Proposition 5 are a way to see that in Horn DLs, dropping the negative inclusions A \u2286 \u00acB provides an over-approximation of brave. However, we cannot generalise Theorem 4 beyond Horn DLs. Indeed, recall that |=4 and |= differ on consistent KBs (cf. Example 3) for languages with A, while all repair-based semantics coincide with |= on consistent KBs.\nSince Theorem 4 indicates that \u22a84 with CQs (without values) is more permissive than brave, a natural idea for bringing closer paraconsistent reasoning and repair-based reasoning is to add T on query atoms to strengthen the requirements on answers. We quickly observe that in this case, \u22a84 no longer over-approximates (in contrast with Theorem 4) even the safest semantics IAR, while it does not under-approximate the loosest semantics brave and CAR. For example, consider the following knowledge base: Kic = \u3008{C \u2286 A, C \u2286 \u00acA, C \u2286 \u00acB}, {C(a), B(a)}\u3009. The only (closed) repair of Kic is {B(a)} so Kic |=IAR B(a) while Kic |\u2260brave C(a) and Kic |\u2260CAR C(a). On the other hand, Kic |\u22604 T(B(a)) while Kic \u22a84 T(C(a)). However, this example relies on the use of a concept name unsatisfiable w.r.t. the TBox, which may be not so common in practice. We thus next investigate the case of coherent KBs, i.e., KBs where all concept names are satisfiable w.r.t. the TBox.\nWe show that even for coherent KBs, answering CQs under repair-based semantics and answering CQVs over paraconsistent DL KBs is incomparable. Moreover, we show this not only for the paraconsistent DLs we study in this paper but for a wider class of such logics. The following definition, inspired by (Gottwald 2001, Chapter 3) and (Skurt 2020, \u00a71.5.2), will allow us to state our incomparability results in a general setting, by abstracting from the way extensions (and"}, {"title": "Conclusion and Discussion", "content": "In this paper, we presented a new approach to querying inconsistent DL KBs based upon paraconsistent logic, which we show to be incomparable to repair-based semantics. Differently from existing paraconsistent OMQA approaches, our query language enables us to take full advantage of the four-valued semantics, making it possible to differentiate between exactly true and at least true instances of a concept. We proved that our approach is computationally well-behaved (cf. Table 2): in Horn KBs, the combined and data complexity of paraconsistent query answering coincides with that of the classical certain answers semantics; in expressive DLs, data complexity of paraconsistent BCQV entailment remains lower than in repair-based semantics. Moreover, our complexity results rely on a simple reduction of CQV answering to OMQA, providing a way to readily implement CQV answering. We also expect that the technique based on translation we provide can be adapted to more expressive DLs (the translation given by (Maier, Ma, and Hitzler 2013) that we adapted was for SROIQ).\nParaconsistent DLs assign truth values to concept assertions and are in this regard close to fuzzy DLs, in which concept memberships are evaluated using degrees. In particular, it is natural to wonder whether there is a relationship between our work and lattice-based fuzzy DLs that allow for incomparable membership degrees (Borgwardt and Pe\u00f1aloza 2014). If we consider fuzzy DLs based on a lattice formed by Belnapian values (be it the lattice with T as the supremum and F as the infimum or the one with B as the supremum and N as the infimum) and queries that allow one to ask that a concept holds to at least some degree, then one can capture the semantics of CQs (without value operators) in paraconsistent DLs (Definition 4). However, it would not be possible to capture CQVs under the semantics we introduce. For example, considering the lattice with B as supremum, in our semantics T(A(a)) would mean that A(a) has degree at least T in all models and that there exists a model such that A(a) has not degree at least F, which is not directly expressible in fuzzy DLs.\nFollowing this idea of queries requiring that an atom has \"degree at least X\u201d, note that CQV atoms of the form A(t) can be seen as two-valued atoms \u201cT or B\u201d (at least positive evidence). We could extend the definition of CQVs to allow for multi-valued atoms and would easily treat the case \u201cF or B\u201d (at least negative evidence) by extending q+ (Definition 8) with A\u2212(t) for such atoms and not taking them into account in qctr. However, allowing multi-valued query atoms in general would affect the results. For example, the cases \u201cN or F\u201d (no positive evidence) or \u201cN or T\u201d (no negative evidence) would be equivalent to having a (classical) negation in the query (we would need atoms of the form A+(t) or \u00acA\u2212(t) in q\u207a) so we would need to reduce queries with such atoms to queries with negative atoms in classical DLs, which are known to be much harder to handle and will lead to higher complexity results.\nIn future work, we plan to adapt CQVs to paraconsistent DL knowledge bases with four-valued roles by allowing value operators also on role atoms. We expect that our complexity results will continue to hold in the presence of four-valued roles under any of the previously proposed semantics, by adapting the translation-based approach. However, what kind of new inferences we can obtain by adding four-value roles will depend on the adopted semantics for roles and on which other DL constructors are present."}]}