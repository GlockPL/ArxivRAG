{"title": "Queries With Exact Truth Values in Paraconsistent Description Logics", "authors": ["Meghyn Bienvenu", "Camille Bourgaux", "Daniil Kozhemiachenko"], "abstract": "We present a novel approach to querying classical inconsistent description logic (DL) knowledge bases by adopting a paraconsistent semantics with the four 'Belnapian' values: exactly true (T), exactly false (F), both (B), and neither (N). In contrast to prior studies on paraconsistent DLs, we allow truth value operators in the query language, which can be used to differentiate between answers having contradictory evidence and those having only positive evidence. We present a reduction to classical DL query answering that allows us to pinpoint the precise combined and data complexity of answering queries with values in paraconsistent $\\mathcal{ALCHI}$ and its sublogics. Notably, we show that tractable data complexity is retained for Horn DLs. We present a comparison with repair-based inconsistency-tolerant semantics, showing that the two approaches are incomparable.", "sections": [{"title": "Introduction", "content": "Ontology-mediated query answering (OMQA) has been extensively studied over the past fifteen years as a promising paradigm for querying incomplete and heterogeneous data (Poggi et al. 2008; Bienvenu and Ortiz 2015; Xiao et al. 2018). In a nutshell, OMQA enriches the data with an ontology which provides both a convenient vocabulary for query formulation as well as domain knowledge that is exploited when answering queries. Ontologies are typically formulated in logic-based languages (description logics, DLs, being a popular choice) and equipped with a first-order logic semantics, whereby a Boolean ('yes or no') query is deemed to hold whenever it is entailed from the logical theory consisting of the data and ontology. An important practical concern with (traditional) OMQA is its lack of robustness in the presence of contradictory information, as every Boolean query is entailed from an inconsistent knowledge base.\nA prominent approach to tackling data inconsistencies in OMQA is to adopt inconsistency-tolerant semantics based upon repairs, defined as inclusion-maximal subsets of the data that are consistent with the ontology. Arguably the most natural repair-based semantics is the AR semantics (Lembo et al. 2010) that considers those answers that hold w.r.t. each repair, inspired by analogous semantics for inconsistent databases (Arenas, Bertossi, and Chomicki 1999). Other commonly considered repair semantics include the more permissive brave semantics (Bienvenu and Rosati 2013), which only requires an answer to hold in at least one repair, and the more cautious IAR semantics (Lembo et al. 2010), which queries the intersection of all repairs. Several other repair-based semantics, incorporating closure operations or various kinds of preferences, have been explored, see (Bienvenu and Bourgaux 2016; Bienvenu 2020) for an overview of repair-based semantics for DL knowledge bases.\nParaconsistent logics represent another natural approach to obtaining meaningful answers from contradictory knowledge bases. Whereas repair-based semantics are defined in terms of the consistent subsets of the inconsistent theory, paraconsistent logic semantics, often based upon extended sets of truth values, makes it possible for classically inconsistent theories to possess models. A common approach is to augment the classical set of truth values {T, F} with two additional elements - B (both true and false) and N (neither true nor false).\u00b9 The four values can be interpreted as four kinds of information one can have on a given assertion A(a): only be told that A(a) is true, only be told that A(a) is false, be told that A(a) is both true and false, and be told nothing about A(a).\u00b2 The truth and falsity conditions of Boolean connectives $\u00ac$, $\u2294$, and $\u2293$ are then defined as follows:\n\u2022 $\u00acA(a)$ is true if A(a) is false and vice versa;\n\u2022 $[A\u2293 B](a)$ is true if A(a) and B(a) are true, and false if A(a) or B(a) is false;\n\u2022 $[A\u2294 B](a)$ is true if A(a) or B(a) is true, and false if A(a) and B(a) are false.\nParaconsistent DLs were first introduced by Odintsov and Wansing (2003) and have since then been extensively studied. In particular, four-valued counterparts of expressive description logics such as $\\mathcal{SHOIN(D)}$ and $\\mathcal{SROIQ}$ were considered (Ma, Lin, and Lin 2006; Ma and Hitzler 2009; Maier 2010; Maier, Ma, and Hitzler 2013). Moreover,"}, {"title": "Four-Valued $\\mathcal{ALCHI}$ and Its Fragments", "content": "In this section, we provide the syntax and semantics of four-valued DLs, equipped with a new constructor $\u25b3$ that was previously added to Belnap-Dunn propositional logic and its first-order expansion by Sano and Omori (2014), and which can be intuitively interpreted as follows: $\u25b3A(a)$ means that A(a) is true and $\u00ac\u25b3A(a)$ that A(a) is not true (as opposed to $\u00acA(a)$ which means that A(a) is false).\nSyntax Let CN, RN and IN be three mutually disjoint countable sets of concept, role, and individual names, respectively, and let RN\u2260 = RNU {$R^{\u2212}$ | R \u2208 RN} be the set of roles and inverse roles. Given a DL language L, an LA knowledge base (KB) K = (T, A) consists of a finite set A of concept and role assertions of the form A(a) and R(a, b) respectively, with a, b \u2208 IN, A \u2208 CN, and R \u2208 RN, called the ABox, and a finite set T of axioms whose form depends on the DL L, called the TBox. An $\\mathcal{ALCHI}$ TBox contains role inclusions of the form S \u2286 S' where S, S' \u2208 RN\u2260 and concept inclusions of the form C D where C and D are $\\mathcal{ALCHI}$ concepts built using the following grammar:\nC := \u22a4 | \u22a5 | A |\u00acC\u2502\u25b3C|C\u2293C|C\u2294C | \u2203S.C | \u2200S.C\nwith A \u2208 CN and S\u2208 RN\u2260. We also write C = D as a shorthand for {C \u2286 D, D \u2286 C}. We sometimes use \u2022 and o to denote binary connectives from {$\u2293$, $\u2294$} and Q and Q for quantifiers from {\u2203, \u2200}, assuming that \u2022 \u2260 0 and Q \u2260 Q. An L KB is defined as an LA KB except that it cannot contain A. Besides $\\mathcal{ALCHI}$, we will consider the following DL languages which are sub-languages of $\\mathcal{ALCHI}$: $\\mathcal{ALCH}$ has no inverse roles, $\\mathcal{ALCI}$ has no role inclusions, $\\mathcal{ALC}$ has neither, $\\mathcal{ELHI}$ does not allow, \u2200 and \u00ac, and $\\mathcal{ELH}_{\u22a5}$ , $\\mathcal{ELI}$ and $\\mathcal{EL}_{\u22a5}$ are obtained from $\\mathcal{ELHI}_{\u22a5}$ by disallowing inverse roles, role inclusions, and both respectively. Finally DL-Liter TBoxes contain role inclusions of the form S \u2286 S' or S \u2288 S' and concept inclusions of the form $B_{1} \u2286 B_{2}$ or $B_{1} \u2288 B_{2}$ with B := A | \u2203S.\u22a4. $\\mathcal{ELHI}_{\u22a5}$ and its sub-logics are Horn DLs and we call propositional TBoxes the TBoxes that do not use the \u2293 and constructors.\nSemantics The semantics of LA is defined through interpretations, which differ from classical DL interpretations in that they define both positive and negative extensions of concepts. A 4-interpretation is a tuple I = (\u0394\u0399, $I_{p}$, $I_{n}$) with a domain \u0394 \u2260 0, and two interpretation functions $I_{p}$ and $I_{n}$ that map each concept name A \u2208 CN to $A^{I}_{p}$\u2286 \u0394\u0399 and $A^{I}_{n}$\u2286 \u0394\u0399 respectively, each role name R \u2208 RN to $R^{I}_{p}$ = $R^{I}_{n}$ \u2286 \u0394\u0399 \u00d7 \u0394\u0399 and each individual name a \u2208 IN to $a^{I}_{p}$ = $a^{I}_{n}$ \u2208 \u0394\u0399. For role and individual names interpretations, we can thus omit p and n and simply write R\u00b9 and a. The interpretation functions $I_{p}$ and $I_{n}$ are extended to complex $\\mathcal{ALCHI}$ concepts and roles as follows.\n$(R^{\u2212})^{I} = {(y, x)|(x,y)\u2208R^{I}}$\n$\u22a4^{I} = \u0394^{I}$\n$(\\neg C)^{I}_{p} = C^{I}_{n}$\n$(\\triangle C)^{I}_{n} = \\triangle^{I} \\backslash C^{I}_{p}$\n$(C \\sqcap D)^{I}_{p} = C^{I}_{p} \\cap D^{I}_{p}$\n$(\u2200S.C)^{I}_{p} = {x | \\forall y : (x, y) \u2208 S^{I} \\Rightarrow y \u2208 C^{I}_{p}}$\n$\u22a4^{I}_{n} = \u2205$\n$(\\neg C)^{I}_{n} = C^{I}_{p}$     (1)\n$(\\triangle C)^{I}_{p} = \\triangle^{I} \\backslash C^{I}_{n}$\n$(C \\sqcup D)^{I}_{n} = C^{I}_{n} \\cup D^{I}_{n}$\n$(\u2200S.C)^{I}_{n} = {x | \\exists y : (x, y) \u2208 S^{I} & y \u2208 C^{I}_{n}}$"}, {"title": "Capturing Different Inclusion Semantics With $\u25b3$", "content": "We recall different interpretations of \u2286 from the literature:\nDefinition 1 (Alternative inclusions). Let I = (\u0394\u0399, $I_{p}$, $I_{n}$) be a 4-interpretation and C, D be two concepts.\n\u2022 C is internally included in D (I|=4C\u2286D) iff $C^{I}_{p} \u2286 D^{I}_{p}$.\n\u2022 C is materially included in D (I \u251c4 Cm D) iff \u2206\u0399 \\ C$I_{n}$\u2286 D$I_{p}$.\n\u2022 C is strongly included in D (I|=4C\u2286\u2260 D) iff $C^{I}_{p} \u2286 D^{I}_{p}$ and $D^{I}_{n} \u2286 C^{I}_{n}$.\n\u2022 C is quasi-classically included in D (I =4 C\u2286\u00ba\u00ba D) iff C is internally, strongly, and materially included in D.\nInternal, material, and strong inclusions were presented in (Ma, Hitzler, and Lin 2007) and correspond to three eponymous four-valued implications by Arieli and Avron (1996; 1998). The quasi-classical inclusion proposed by Zhang et al. (2014) combines all three notions. We have chosen to work with internal inclusion but will show how $\u25b3$ allows us to reduce the other interpretations of \u2286 to this one.\nProposition 1. For every pair of $\\mathcal{ALCHI}$ concepts (C, D) and x \u2208 {m, \u00b1, qc}, there is an $\\mathcal{ALCHI}$ concept inclusion x such that for every 4-interpretation I, it holds that I=4C\u2286xD iff I =4 \u00a2x.\nProof. For material inclusion, I =4 C\u2286m Diff 14 $\u22a4\u2286(\\neg C \u2294 D)$. For strong inclusion, it is immediate that I =4 C\u2286\u00b1 Diff 14 C\u2286 D and I =4 $\u00acD \u2286 \u00acC$, whence, I =4 C\u2286\u00b1 Diff I =4$\u22a4\u2286(\\neg \\triangle C \\cup D) \u2293 (\\neg C \u2294 \\triangle \\neg D)$.\",\""}, {"title": "Reductions Between $\\mathcal{ALCHI}$ and $\\mathcal{ALCHI}$", "content": "We show that $\\mathcal{ALCHI}$ and $\\mathcal{ALCHI}$ are equally expressive. Using Proposition 2, we can construct an embedding of 4-valued knowledge bases into the classical ones. The embedding follows the idea from (Ma, Hitzler, and Lin 2007): we encode positive and negative interpretations separately. The only difference in our case is that we need to account for $\u25b3$.\nDefinition 3 (Classical counterparts). Let K = (T, A) be an $\\mathcal{ALCHI}$ KB with T in NNF. We define its classical counterpart Kcd = {cd | \u00a2 \u2208 K} as follows.\n(C \u2286 D)cd = Cd \u2286 Dcd\n(S \u2286 S')cd = S \u2286 S'\n(A(a))cd = Ad(a)\n(R(a, b))cd = R(a, b)\nwhere C, D are $\\mathcal{ALCHI}$ concepts, S, S' \u2208 RN\u2260, A \u2208 CN, R\u2208 RN. For C in NNF, Ccl is defined as follows.\n$A^{cd} = A^{+}$\n$(\\neg A)^{cd} = A^{\u2212}$\n$(\\triangle A)^{cd} = A^{+}$\n$(\\triangle \\neg A)^{cd} = A^{\u2212}$\n$(C \\sqcap D)^{cd} = C^{cd} \u2293 D^{cd}$     (2)\n$(\\neg \\triangle A)^{cd} = \\neg A^{+}$\n$(\\neg \\triangle \\neg A)^{cd} = \\neg A^{\u2212}$\n$(QS.C)^{cd} = QS.C^{cd}$\nProposition 3. Let K be an $\\mathcal{ALCHI}\u2074$ knowledge base in NNF, I a 4-valued interpretation, and & a concept inclusion, role inclusion, or assertion. Then K =4 \u00a2 iff K\u00a9 = $cl and, moreover, I =4 K iff Id = Kcd.\nFor the other direction, we shall exploit the essentially two-valued behaviour of $\u25b3$. We use x\u25b3 to denote the result of putting $\u25b3$ in front of every concept name occurring in X.\nLemma 1. Let K = (T, A) be an $\\mathcal{ALCHI}$ knowledge base in NNF. Then it holds that {.1 | I |= K,I = (\u03941, .1)} = {.1\u00aa | I4 =4 K^,I4 = (1, 1, 1)}.\nThe following proposition straightforwardly follows.\nProposition 4. Let K be an $\\mathcal{ALCHI}$ knowledge base in NNF and & a concept inclusion, role inclusion, or assertion. Then K = \u00a2 iff K\u25b3 =4 $^.\nThe next statement follows from Propositions 3 and 4 and the complexity of $\\mathcal{ALCHI}$ (Tobies 2001).\nTheorem 1. Axiom or assertion entailment in $\\mathcal{ALCHI}$ is ExpTime-complete.\nHorn DLs As we saw in Example 1, \u0410\u041f\u0412 \u2286 \u22a5, A \u2286 \u00acB and B-A have different semantics in the four-valued setting. Hence, to be able to define LA KBs that are really paraconsistent for DLs L that normally have \u2293 but no negation, such as $\\mathcal{ELHI}_{\u22a5}$ and its sub-logics, we need to use syntactic variants that may also express \u2018weak disjointness' with \u00ac. An $\\mathcal{ELHI\u00ac\u00c2} TBox contains inclusions of one of the following forms (extending $\\mathcal{ELHI}_{\u22a5}$ in normal form):\nS \u2286 S' A\u2286S.B S.A\u2286C A\u2293B\u2286C A\u2286\u00acB\nwith S, S' \u2208 RN\u2260, A, B \u2208 CN\u222a{\u22a4} and C\u2208 CNU{\u22a4, \u22a5}. We do not include the $\u25b3$ operator in this syntax because we can equivalently add $\u25b3$ anywhere in the above inclusions without changing the inclusion satisfaction condition, except in the case of $A\u2286 \u00ac\u25b3B$, but as mentioned in Example 1, $A\u00ac\u25b3B$ is equivalent to A\u041f\u0412\u2286\u22a5. We keep the language name in the form of LA only for homogeneity. We denote by $\\mathcal{EL}$, $\\mathcal{ELT}$ and $\\mathcal{ELH}$ the fragments of $\\mathcal{ELHI\u00ac\u00c2}$ that correspond to $\\mathcal{EL}_{\u22a5}$, $\\mathcal{ELI}_{\u22a5}$ and $\\mathcal{ELH}_{\u22a5}$ respectively."}, {"title": "Queries With Exact Truth Values", "content": "Before introducing our novel approach to querying four-valued DL KBs, let us recall the query language and semantics considered by Zhou et al. (2012).\nDefinition 4. Let Var be a set of variables disjoint from IN and Term = Var U IN. A conjunctive query (CQ) has the form q := \u2203$y_{1}...y_{m}$:$\u03c6$ where $y_{1},..., y_{m}$ \u2208 Var and \u03c6 is a conjunction of atoms of the form R(t,t') or A(t) with t,t' \u2208 Term, R \u2208 RN and A \u2208 CN. A CQ q is Boolean (BCQ) if no variable occurs in it freely.\nA KB K 4-entails a BCQ q (K4q) if for every 4-model I = (\u0394\u0399, $I_{p}$, $I_{n}$) of K, there is a match \u03c0 : Term \u2192 \u0394\u0399 such that for every c\u2208 IN, \u03c0(c) = c, and for every R(t1, t2) (resp. A(t)) that occurs in q, (\u03c0(t1), \u03c0(t2)) \u2208 RI (resp. \u03c0(t) \u2208 A$I_{p}$).\nWe make an important observation (not explicit in (Zhou et al. 2012)), namely, that in the case of Horn DLs, answering CQs under paraconsistent semantics amounts to answering them classically over the 'positive' part of the KB obtained by dropping the weak disjointness axioms. Recall that a classical, two-valued, KB K entails a BCQ q, denoted K q, iff there is a match for q in every model of K.\nProposition 5. If K is an $\\mathcal{ELHI\u00ac\u00c2}$ KB and K+ denotes the $\\mathcal{ELHI}$ KB obtained from K by dropping all inclusions of the form AB, then for every BCQ q, K =4 q iff K+ = q.\nProof. Assume that K =4 q. If K+ has no classical model, then K+ q. Otherwise, let I = (\u03941, .1) be a model of K+. Define J = (\u0394\u0399, $I_{p}$, $I_{n}$) with $A^{I}_{n}$ = \u0394 for every A \u2208 CN. Since \u2288 only occurs in inclusions of the form A\u2286\u00acB in K, it is easy to check that I =4 K. It follows that I 4 q, which implies the existence of a match for q in I by construction of J. Hence K+ = q.\nIn the other direction, if K $4 q, there is a 4-model I = (\u0394\u0399, $I_{p}$, $I_{n}$) of K such that I $4 q. Let I = (\u0394\u0399, $I_{p}$). Again, it is easy to check that I = K+. Thus I is a model of K+ such that there is no match for q in I, so K+ $ q.\nThe fact that paraconsistent query answering in Horn DLs basically amounts to ignoring possible sources of contradiction provides strong motivation for exploring a more expressive query language that better exploits the paraconsistent semantics. We propose such a language by introducing four value operators corresponding to Belnapian values.\nDefinition 5 (Queries with values). A conjunctive query with values (CQV) is a CQ whose atoms are of the form R(t, t'), A(t) or X(A(t)) with X \u2208 {T, B, N, F}. A Boolean CQV (BCQV) has no free variable."}, {"title": "Complexity of Query Answering", "content": "In this section, we establish the complexity of answering CQVs. We do this by constructing a reduction of CQV answering to answering union of conjunctive queries (UCQs) over classically interpreted knowledge bases.\nDefinition 8. Let q = \u2203\u1ef9 : \u03c6 be a Boolean CQV and let further INq = {$C_{x}$ | x \u2208 Var occurs in q}. Define\n$C_{t} = \\begin{cases}\nt & \\text{if } t \u2208 IN \\\\\nC_{t} & \\text{if } t \u2208 Var\n\\end{cases}$\nUsing sets of atoms from Definition 6, we set\nq+ := \u2203\u1ef9 :\n$\\bigwedge_{R(t,t')\u2208At(q)} R(t,t') \\wedge \\bigwedge_{A(t) \u2208At^{+}(q)} A^{+}(t) \\wedge \\bigwedge_{A(t) \u2208At^{BF}(q)} A^{\u2212}(t)$\nqctr := $\\bigvee_{A(t) \u2208At^{TN}(q)} \\neg A^{-}(C_{t}) \\bigvee_{A(t) \u2208At^{FN}(q)} A^{+}(C_{t})$\n$A_{q} := {R(C_{t}, C_{t'}) | R(t, t') \u2208 At(q+)} \\cup$     {$A^{+}(C_{t}) | A^{+}(t) \u2208 At(q+)} \\cup$     {$A^{-}(C_{t}) | A^{-}(t) \u2208 At(q+)}$\nWe are now ready to state our main result.\nTheorem 2. Let K be an $\\mathcal{ALCHI}$ KB and q be a BCQV.\nK =4 q iff Kd = q+ and Kd \u222a Aq $ qctr\nIntuitively, Kd = q+ ensures that the positive interpretation of every 4-model of K satisfies item 1 of Definition 7 and Kd \u222a Aq $ qetr ensures that there exists a 4-model of K as required by item 2. Indeed, Aq enforces a match for q+ and qetr checks whether it implies some contradiction of the conditions given by item 2. The proof relies on classical counterparts and 4-counterparts to go from 4-models of K to classical models of K\u00b9 or K\u00b9 \u222a Aq and vice-versa.\nUsing Theorem 2 and the complexity results for classical DL KBs recalled in Table 1, we obtain tight complexity results for BCQV entailment in $\\mathcal{ALCHI}$ and its sublogics, showing that answering queries with values over paraconsistent KBs is often not harder than standard BCQ answering. The only case where we note a complexity increase is the data complexity of $\\mathcal{ALC}$ and its extensions."}, {"title": "Comparison With Repair-Based Semantics", "content": "In this section, we compare paraconsistent querying semantics with existing repair-based semantics. When dealing with repair-based semantics, we assume a classically consistent TBox, i.e., we assume that if a KB is inconsistent, it is due to errors in the ABox. For our comparison, we will naturally consider the popular AR semantics, which deems a tuple to be an answer if it holds w.r.t. every repair. We shall further consider repair-based semantics that provide minimal under-approximation and maximal over-approximations of AR (Bienvenu and Bourgaux 2016): IAR, brave and CAR. The IAR semantics retains only the \"safest\" answers that are true in the intersection of the repairs, while the brave semantics considers all answers that hold in at least one repair. Finally, the CAR semantics over-approximates the AR semantics in a way that is incomparable with brave, by incorporating a closure operation on the ABox. The latter semantics may seem closer in spirit to paraconsistent reasoning where the positive extensions retain all consequences of the axioms.\nThe formal definitions of repairs and the considered repair-based semantics follow. Recall that ABox A is called T-consistent if the KB (T, A) is (classically) consistent.\nDefinition 9 (Repairs). Let K = (T, A) and define\n$C^{+}(A) = \\{ \u03c6 |\\text{assertion } \u03c6\\text{ s.t. } (T, A') |= \u03c6 \\\\ \\text{for some } T\\text{-consistent } A' \u2286 A\\}$\n\u2022 A repair of K is a maximal T-consistent subset of A.\n\u2022 A closed repair of K is a T-consistent R \u2286 C+(A) for which there is no T-consistent R' \u2286 C*(A) s.t. either (1) R \u2229 A\u00c7 R'N A or (2) R \u2229 A = R' \u2229 A and R \u2286 R'.\nWe denote the set of all repairs (resp. closed repairs) of K with Rep(K) (resp. CRep(K)).\nDefinition 10 (Repair semantics). Let q be a Boolean CQ.\n\u2022 K|=AR q if (T, A') |= q for every A' \u2208 Rep(K).\n\u2022 K|=brave q if (T,A')|=q for some A' \u2208 Rep(K).\n$\\bullet K|=IAR q \\text{ if } (T, \\bigcap_{A' \u2208Rep(K)} A') |=q$.\n\u2022 K|=CAR q if (T,R) |= q for every R \u2208 CRep(K).\nWe recall the relations between these semantics.\n$K|=IAR q \\Rightarrow K|=AR q \\Rightarrow K|=brave q$\n$K|=CAR q$\nWe start by remarking that =4 over-approximates brave in Horn DLS.\nTheorem 4. If K is an $\\mathcal{ELHI\u00ac\u00c2}$ KB and q is a BCQ, then K|=brave q implies K4 q.\nProof. Assume that K|=brave q: there is a classically consistent subset K' \u2286 K such that K' |= q. By Proposition 7, K' 4 q because q does not contain any value operator. It follows that K4 q. Indeed, every 4-model of K is a 4-model of K' and since q does not contain any value operator, item 2 of Definition 7 is vacuously true.\nNote that Theorem 4 and Proposition 5 are a way to see that in Horn DLs, dropping the negative inclusions A \u2286 \u00acB provides an over-approximation of brave. However, we cannot generalise Theorem 4 beyond Horn DLs. Indeed, recall that 4 and |= differ on consistent KBs (cf. Example 3) for languages with, while all repair-based semantics coincide with |= on consistent KBs.\nSince Theorem 4 indicates that =4 with CQs (without values) is more permissive than brave, a natural idea for bringing closer paraconsistent reasoning and repair-based reasoning is to add T on query atoms to strengthen the requirements on answers. We quickly observe that in this case, =4 no longer over-approximates (in contrast with Theorem 4) even the safest semantics IAR, while it does not under-approximate the loosest semantics brave and CAR. For example, consider the following knowledge base: Kic = \u3008{C \u2286 A,C \u2286 \u00acA,C \u2286 \u00acB},{C(a), B(a)}). The only (closed) repair of Kic is {B(a)} so Kic |=IAR B(a) while Kic $brave C(a) and Kic $CAR C(a). On the other hand, Kic $4 T(B(a)) while Kic =4 T(C(a)). However, this example relies on the use of a concept name unsatisfiable w.r.t. the TBox, which may be not so common in practice.\nWe thus next investigate the case of coherent KBs, i.e., KBS where all concept names are satisfiable w.r.t. the TBox.\nWe show that even for coherent KBs, answering CQs under repair-based semantics and answering CQVs over paraconsistent DL KBs is incomparable. Moreover, we show this not only for the paraconsistent DLs we study in this paper but for a wider class of such logics. The following definition, inspired by (Gottwald 2001, Chapter 3) and (Skurt 2020, \u00a71.5.2), will allow us to state our incomparability results in a general setting, by abstracting from the way extensions (and"}, {"title": "Conclusion and Discussion", "content": "In this paper, we presented a new approach to querying inconsistent DL KBs based upon paraconsistent logic, which we show to be incomparable to repair-based semantics. Differently from existing paraconsistent OMQA approaches, our query language enables us to take full advantage of the four-valued semantics, making it possible to differentiate between exactly true and at least true instances of a concept. We proved that our approach is computationally well-behaved (cf. Table 2): in Horn KBs, the combined and data complexity of paraconsistent query answering coincides with that of the classical certain answers semantics; in expressive DLs, data complexity of paraconsistent BCQV entailment remains lower than in repair-based semantics. Moreover, our complexity results rely on a simple reduction of CQV answering to OMQA, providing a way to readily implement CQV answering. We also expect that the technique based on translation we provide can be adapted to more expressive DLs (the translation given by (Maier, Ma, and Hitzler 2013) that we adapted was for $\\mathcal{SROIQ}$).\nParaconsistent DLs assign truth values to concept assertions and are in this regard close to fuzzy DLs, in which concept memberships are evaluated using degrees. In particular, it is natural to wonder whether there is a relationship between our work and lattice-based fuzzy DLs that allow for incomparable membership degrees (Borgwardt and Pe\u00f1aloza 2014). If we consider fuzzy DLs based on a lattice formed by Belnapian values (be it the lattice with T as the supremum and F as the infimum or the one with B as the supremum and N as the infimum) and queries that allow one to ask that a concept holds to at least some degree, then one can capture the semantics of CQs (without value operators) in paraconsistent DLs (Definition 4). However, it would not be possible to capture CQVs under the semantics we introduce. For example, considering the lattice with B as supremum, in our semantics T(A(a)) would mean that A(a) has degree at least T in all models and that there exists a model such that A(a) has not degree at least F, which is not directly expressible in fuzzy DLs.\nFollowing this idea of queries requiring that an atom has \"degree at least X\u201d, note that CQV atoms of the form A(t) can be seen as two-valued atoms \u201cT or B\u201d (at least positive evidence). We could extend the definition of CQVs to allow for multi-valued atoms and would easily treat the case \u201cF or B\u201d (at least negative evidence) by extending q+ (Definition 8) with A\u00af(t) for such atoms and not taking them into account in qctr. However, allowing multi-valued query atoms in general would affect the results. For example, the cases \"N or F\" (no positive evidence) or \u201cN or T\u201d (no negative evidence) would be equivalent to having a (classical) negation in the query (we would need atoms of the form A+ (t) or $\u00acA^{\u2212}(t)$ in q+) so we would need to reduce queries with such atoms to queries with negative atoms in"}]}