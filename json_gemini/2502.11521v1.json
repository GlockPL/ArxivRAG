{"title": "DeFiScope: Detecting Various DeFi Price Manipulations with LLM Reasoning", "authors": ["Juantao Zhong", "Daoyuan Wu", "Ye Liu", "Maoyi Xie", "Yang Liu", "Yi Li", "Ning Liu"], "abstract": "DeFi (Decentralized Finance) is one of the most important applica-tions of today's cryptocurrencies and smart contracts. It manageshundreds of billions in Total Value Locked (TVL) on-chain, yet itremains susceptible to common DeFi price manipulation attacks.Despite state-of-the-art (SOTA) systems like DeFiRanger and De-Fort, we found that they are less effective to non-standard pricemodels in custom DeFi protocols, which account for 44.2% of the 95DeFi price manipulation attacks reported over the past three years.In this paper, we introduce the first LLM-based approach, DeFiS-cope, for detecting DeFi price manipulation attacks in both standardand custom price models. Our insight is that large language mod-els (LLMs) have certain intelligence to abstract price calculationfrom code and infer the trend of token price changes based on theextracted price models. To further strengthen LLMs in this aspect,we leverage Foundry to synthesize on-chain data and use it to fine-tune a DeFi price-specific LLM. Together with the high-level DeFioperations recovered from low-level transaction data, DeFiScope detects various DeFi price manipulations according to systematicallymined patterns. Experimental results show that DeFiScope achievesa high precision of 96% and a recall rate of 80%, significantly out-performing SOTA approaches. Moreover, we evaluate DeFiScope'scost-effectiveness and demonstrate its practicality by helping ourindustry partner confirm 147 real-world price manipulation attacks,including discovering 81 previously unknown historical incidents.", "sections": [{"title": "1 Introduction", "content": "DeFi represents a form of finance that eliminates traditional finan-cial intermediaries by utilizing smart contracts on a blockchain. A smart contract [100] is a self-executing program with the terms ofthe agreement between the buyer and the seller directly written intolines of code. The code and the agreements contained therein existacross a distributed, decentralized blockchain network [31]. Smartcontracts enable trusted transactions and agreements to be carriedout among disparate, anonymous parties without the need for acentral authority, legal system, or external enforcement mechanism.While price manipulation is a pervasive risk in traditional finan-cial markets, it poses even more significant damage in the contextof DeFi. In the cryptocurrency space, attackers strategically addor remove large amounts of tokens in specific contracts, or impactthe total supply of target tokens by burning or minting, to exploitvulnerabilities in the pricing mechanisms of DeFi applications, ulti-mately inflating or deflating the price of cryptocurrencies [22]. \u03a4\u03bfdetect price manipulation attacks in DeFi applications, researchershave proposed several state-of-the-art (SOTA) approaches, primar-ily focusing on transaction monitoring-based methods that offerreal-time protection, e.g., DeFiRanger [93] and DeFort [94].However, our analysis indicates that these SOTA approaches areless effective to non-standard price models in custom DeFi proto-cols. This is because they typically require token exchange rates toidentify abnormal price changes, which are only suitable to calcu-late under standard price models such as CPMM (Constant ProductMarket Makers) and Stableswap Invariant (detailed in \u00a72.2). Unfor-tunately, our subsequent evaluation shows that 44.2% of the 95 DeFiprice manipulation attacks reported in the past three years usednon-standard price models. Hence, instead of explicitly calculatingthe exchange rate for a pair of tokens, we aim to capture only theabnormal price fluctuations of tokens, which can be directly derivedfrom the high-level price model and changes in token balances.To achieve this objective, we sought help from large languagemodels (LLMs), considering that their trained intelligence might aidin inferring price changes associated with DeFi operations duringthe transaction process. As such, we introduce DeFiScope, the firstLLM-based approach to detecting DeFi price manipulation attacksin both standard and custom price models. DeFiScope features sev-eral novel designs, such as constructing a transfer graph to recoverhigh-level DeFi operations (\u00a75) and systematically mining price ma-nipulation patterns across all types of DeFi applications (\u00a76). Among"}, {"title": "2 Background and Motivation", "content": "As Figure 1 shows, on blockchains, two primary account typesexist, i.e., externally owned accounts (EOAs), controlled by individ-uals using private keys, and contract accounts (CAs), governed bytheir contract code. External transactions are initiated externallyby EOAs, while internal transactions occurs when a smart contractcalls another contract internally. Smart contracts exchange infor-mation with other smart contracts through internal transactions,where a transaction involving communication between contracts can be regarded as a sequence of function calls, which has beengreatly utilized in DeFi protocols for interoperability. For simplicity,we denote as user invocation an internal transaction between theuser-controlled smart contracts and other smart contracts, whichplays a key role in price manipulation attacks."}, {"title": "2.1 DeFi Protocols", "content": "A DeFi protocol typically consists of multiple smart contracts andoffers various services including trading on decentralized exchange,lending, and yield farming.Decentralized EXchange (DEX). A DEX is a peer-to-peer market-place where users can trade cryptocurrencies. The two predominantforms of DEXs are order book DEXs and automated market makers(AMMs). In the order book DEXs, the management and matchingprocesses of open buy and sell orders take place off-chain whilethe settlement of trades occurs on-chain. Alternatively, the AMMis fully on-chain, and maintains liquidity through liquidity poolswithout replying on real-time buyers and sellers. A liquidity poolmaintains two or more tokens, and the prices of these tokens aredetermined by a constant mathematical formula. In this paper, weonly target fully on-chain DEXs using AMM [17, 21].Lending. To borrow assets from a lending protocol, borrowers arerequired to deposit other cryptocurrencies as collateral first. Toensure that borrowers can repay their loans, the collateral factorof supplied assets is utilized to calculate the maximum value ofassets that users can borrow. For instance, consider a scenariowhere the collateral factor of ETH is set to 0.75, borrowers can onlyobtain assets up to 75% of the value of ETH they have depositedas collateral. If the value of the collateral decreases and falls belowa certain level (the health factor of a borrower is less than 1), theliquidation of the collateral (the lending protocol sells the collateralat a discount rate) occurs to repay the borrowed amount [69].Yield Farming. It provides a way to earn rewards in the form ofAnnual Percentage Yields (APYs). A yield farmer could deposit cryp-tocurrencies into yield-farming applications, which invest theseassets according to various strategies. Based on the returns fromthese investments, yield farmers can obtain rewards. There are twotypes of yield farming. The first involves users depositing cryptocur-rencies into an application to obtain proof tokens, which can betraded, allowing holders to withdraw the corresponding depositedassets. The second, a stake-and-claim model, has users lock theirassets into the contract and later claim them back. This processdoes not generate proof tokens, meaning the staked shares arenon-tradable, and only the staking account can make the claim."}, {"title": "2.2 Price Models", "content": "A price model represents the pricing mechanism within the DeFiapplication, which are typically expressed as equations correlatingthe price of a certain token with the balances of and the total supplyof various tokens as well as other constant.Constant Product Market Maker (CPMM). CPMM is one ofthe most prevalent DeFi AMMs and used in many well-knownDEXs [74, 90]. It maintains liquidity through a constant function $R_x * R_y = k$, where k is a constant, and $R_x$ and $R_y$ represent thereserves of two distinct assets tokenx and tokeny in a liquiditypool. In a swap operation, let Ax amount of tokenx can exchange"}, {"title": "2.3 A Motivating Example", "content": "Our approach is motivated by a real-world price manipulationattack on UwULend [41, 44] in 2024. Figure 2 shows a attack flowof the price manipulation towards UwULend. The attack includessix key steps, and the root cause is the flawed price dependency ineq. (1) related to two functions borrow and liquidationCall.By swapping a large amount of USDe into five liquidity pools,the attacker could deflate the instant price of USDe while the EMAprices remain unchanged, leading to a lower median price for sUSDe.Hence, the attack was able to borrow an exceedingly large amountof sUSDe. Subsequently, swapping back could increase the calcu-lated price of sUSDe, resulting in the attacker's collateral beingunable to repay the debt, thereby allowing liquidation and acquir-ing deposited collateral with a bonus, leading to a $19M loss.While detecting a price manipulation attack, existing tools gen-erally define the exchange rate between two different tokens as their price. For example, the price of sUSDe could be calculated bydividing the amount of WETH deposited into the protocol at step 3by the amount of sUSDe borrowed from it at step 4. Yet, defining"}, {"title": "3 Overview", "content": "Based on the analysis of the motivating example illustrated in\u00a72.3, we establish an intuition of inferring price change associatedwith DeFi operations during the transaction process to detect DeFiprice manipulations in various scenarios. While inferring throughstandard price models (e.g., CPMM and Stableswap as introducedin \u00a72.2) is straightforward, it is challenging to (i) interpret low-levelprice calculation Solidity code into high-level price calculationformulas, and (ii) infer the price change from the (custom) pricecalculation formulas and the information on the token balancechanges in related accounts. Both tasks require certain intelligence.To address this key challenge, we introduce the first LLM-basedapproach, DeFiScope, for effective DeFi price manipulation detec-tion. As depicted in Figure 3, DeFiScope consists of ten steps. Instep1, DeFiScope first decodes and slices raw transaction data.Then in steps\u2461\u2464 DeFiScope extracts the code of possible pricecalculation functions from smart contracts based on their signature,and token balance changes in relevant accounts. Subsequently, insteps 6, DeFiScope embeds these two information into a prompttemplate, which will be used by the LLM to extract the price modeland infer the price change in steps. In the meantime, in steps\u2462\u2463, DeFiScope constructs the transfer graph (\u00a75.1) and uses it torecover the high-level DeFi operations (\u00a75.2) associated with thoseprice change. This is because using the trend of token price changesalone is insufficient for detecting price manipulation. Finally, basedon the recovered DeFi operations and their price change informa-tion, DeFiScope maps them into eight attack patterns listed in \u00a76and detects DeFi manipulation attacks in step 9.We conduct an off-line fine-tuning step (step) to enhanceLLMs' capabilities in extracting price calculation models and tokenprice change reasoning. This is because while the off-the-shelf LLMsmay exhibit certain capability in reasoning and code understanding,they are limited for predicting the trend of token price changesgiven unlabeled code snippet and numerical changes of tokensbalance, which will be illustrated in \u00a77. We will detail our fine-tuning technique in \u00a74."}, {"title": "4 Price Change Inference with LLMs", "content": "Instead of leveraging traditional symbolic or concrete executiontechniques to estimate the price model through input and outputdata points, which results in a significant gap between the actualprice calculation formulas and the approximating ones, we useLLMs to understand codes calculating token prices and extractcorresponding price models, which eliminates the gap caused byestimation."}, {"title": "4.1 LLM Fine-tuning", "content": "For fine-tuning techniques, we chose OpenAI's fine-tuning par-adigm [72] instead of supervised fine-tuning (SFT) [20] and itsparameter-efficient version, LoRA [57], because a very small setof training data is required for the former while much more datapoints are needed for the latter [67]. Moreover, OpenAI's GPT fam-ily models demonstrate state-of-the-art reasoning capabilities oncommon benchmarks [1, 86], which provides a suitable founda-tion for our fine-tuning. Accordingly, DeFiScope has enhanced theGPT-3.5-Turbo and GPT-40 models with data synthesized using thecommonly used price calculation model, i.e., CPMM as illustratedin \u00a72.2, along with on-chain data to fine-tune them.On-Chain Data Simulation. We leverage the fuzz testing methodin Foundry [50], an off-the-shelf toolkit for Ethereum applicationdevelopment, to simulate on-chain data. To avoid data leakage andgenerate a substantial volume of transactions satisfying the CPMM,we select the Uniswap V2:BTC20 [42] liquidity pool as our target.We randomly generate inputs, namely integers ranging from $10^{20}$ to $10^{21}$ ~ 100 Ether to 1000 Ether, for the swap operations which aresimulated on a forked blockchain of block height 17,949,214. Specifically, to include the data of inflating the price of tokens, we craft particular operations. To begin with, we record the balance of WETH and BTC20 in the liquidity pool denoted as $bal_{WETH}$ and $bal_{BTC20}$ respectively. Then we trigger swapExactTokensForTokens in contract UniswapV2Router02 [43] to swap a amount of BTC20 forWETH, and record the latest balance of WETH, $bal'_{WETH}$, and that of BTC20, $bal'_{BTC20}$. Finally, we obtained the tokens' balancechange as a pair $(bal'_{weTH} \u2013 bal_{weTH}, bal'_{BTC20} \u2013 bal_{BTC20})$. In terms of deflating the price of tokens, we swap a amount of WETH for BTC20 instead, with similar subsequent operations. Finally, webuild a fine-tuning database comprising 500 pairs for price inflat-ing and 500 pairs for price deflating, respectively. Despite the onlyuse of CPMM-based DeFi protocols, our evaluation results in \u00a77demonstrates a significant gain in term of price manipulation attackdetection for DeFi protocols using custom price models.CoT-style Fine-tuning. Figure 4 demonstrates the prompt tem-plate used in the fine-tuning. We construct a CoT-style fine-tuningprompt that integrates both on-chain data and the price context.Above the dashed line is the first instruction, which requires theLLM to extract the price calculation model from the provided code."}, {"title": "4.2 Inference with the Fine-tuned LLM", "content": "In this section, we first illustrate the general inference process us-ing the motivating example. Nevertheless, there could be closedsource DeFi protocols that dissatisfy steps \u2464\u2465 so that we design acustomized inference process to deal with them.General Inference Process. To assist LLMs in extracting andanalyzing the price model, our inference prompt provides rele-vant code for LLMs to score the trend of price changes and guidesthem in inferring the token price changes. Figure 5 illustratesa simplified version of the prompt used and the response pro-duced by our fine-tuned LLM for inferring price changes of themotivating example in \u00a72.3. We call this Type-I prompt, used forthe typical cases with code input retrieved from steps 56. It isdifferent from the fine-tuning prompt in the statement} and{change_description} parts. In the fine-tuning prompt shown inFigure 4, both parts are fixed, while they are dynamically generatedduring inference using two formats: (i) \"The price of {token_name}in {contract_name} {direction_of_change} after change\" forthe placeholder {statement}; and (ii) \"The balance of {token_name}in contract_name}{direction_of_change} by {change_value}\"or \"The total supply of {token_name}{direction_of_change}by {change_value}\" for the placeholder {change_description}.However, to fill them in Type-I prompt, DeFiScope generates a pair of statements for each token, i.e., one regarding the increase intoken price and another regarding the decrease in token price.DeFiScope asks the fine-tuned LLM to locate the price calcu-lation model from the input code and evaluate the credibility ofthe generated statements. From the motivating example's responseshown in the right-hand section of Figure 5, the LLM initially ex-tracts the code of price calculation-related functions, followed byan high-level summary. In this example, it accurately identifiesthe underlying price model (see eq. (1)) \u2013 the price of sUSDe isdetermined by the median of multiple prices. With this knowledgelearned, the LLM could credit two opposite statements given thetokens balance changes and yields the correct answer with highconfidence.Customized Inference Process. Although the majority of DeFiapplications are open source to gain users' trust, some remainclosed source, making our Type-I prompt inapplicable. To addressthis, we developed a Type-II prompt template, as shown in Figure6, to infer the trend of price changes in closed source two-tokenliquidity pools. Our observation is that the majority of two-tokenliquidity pools pools use the CPMM as their underlying price model.Therefore, the primary distinction between the Type-I prompt and"}, {"title": "5 DeFi Operations", "content": "The standalone fluctuations in token prices are meaningless; theyneed to be considered within the DeFi context to serve as evidencefor detecting price manipulation. However, the raw transactionsobtained from the blockchain consist solely of low-level informa-tion, such as token transfer actions and smart contract invocations.There exists a gap between raw transactions and high-level DeFisemantics.To bridge this gap, we first model token transfer actions using adirected graph (\u00a75.1), and then recover high-level DeFi operationsfrom it (\u00a75.2). Since our detection is based on a single transaction, itshould be noted that all described operations are derived from oneraw transaction, and we do not consider the DeFi operations ex-pressed by the combination of multiple raw transactions. Based onour study of the top-10 high-value DeFi applications across all threecategories mentioned in \u00a72.1 (the full list is available in Appendix B)with active transactions in each category, due to the susceptibilityto front-running across multiple transactions and the atomicityof transactions ensuring complete execution of operations, only avery few DeFi operations span multiple transactions."}, {"title": "5.1 Transfer Graph Construction", "content": "We define the Transfer Graph (TG) (Definition 2), a directed graphwhere the edges represent transfer actions (Definition 1) and the"}, {"title": "5.2 DeFi Operation Inference", "content": "Based on our in-depth analysis of the top-30 DeFi apps shown inTable 7 (see Appendix B), we identify six DeFi operations that needto be recovered: 1) Swap, primarily from DEXs such as Uniswap; 2)Deposit, defined by yield-farming and lending apps such as AAVEand Pendle; 3) Withdraw, mainly from yield-farming apps; 4) Borrow,based on lending protocols like Compound; 5) Stake; and 6) Claim,both predominantly from yield-farming apps like Convex Finance.Swap involves a user exchanging one token (Tokenin) for an-other (Tokenout) from a liquidity pool. Relevant contract accounts,excluding user-controlled ones, are noted as liquidity pools for pricetrend analysis when source code is unavailable. In a Deposit, a usertransfers a token (Tokendeposit) to a yield-farming or lending proto-col and receives a proof token (Tokenproof) through minting. Withdraw occurs when a user retrieves tokens (Tokenwithdraw) from aprotocol by burning a proof token (Tokenproof). Borrow refers toa DeFi operation where a borrower receives a token (Tokenborrow)and incurs a debt evidenced by another token (Tokendebt), issuedthrough minting. Stake happens in yield-farming protocols likeConvex Finance [34], where users deposit tokens and can earnrewards without receiving a minted proof token. Claim enablesusers to retrieve staked tokens (Tokenclaim) and bonuses withoutburning any tokens, unlike the Withdraw operation which requiresburning tokens to retrieve assets.An Operation Recovering Example. To recover DeFi operationsfrom the TG, we design and employ a search algorithm based ondirected graphs for each operation. Since the recovery algorithm ofDeFi operations is not the central focus of this work, we use therecovery of the Swap operation as an illustrative example here.Figure 7 illustrates that, to recover a Swap operation, we use thedepth-first search algorithm to identify cycles that both start andend at user-controlled accounts. These cycles must satisfy threeconstraints: (i) the transfer action of each edge must be transferringtoken; (ii) the time index of each edge must be monotonically in-creasing; and (iii) the token involved in the first transfer action mustdiffer from the token in the last transfer action. Therefore, from thewell-constructed TG, we can recover the Swap operation expressed as $UC T_1\u2192 CA_1T_4 CA_2 T_5 CA_3 T_1 \u2192 UC$,and we label $CA_1$, $CA_2$, and $CA_3$ as liquidity pools."}, {"title": "6 Price Manipulation Detection", "content": "The price change information and high-level DeFi operations re-covered from \u00a74 and \u00a75, respectively, are finally checked againstthe detection rules (c.f. Table 1). We analyzed all four specific typesof DeFi protocols (c.f. \u00a72.1) and their associated attack instances.Specifically, we examined ElephantMoney [9] for DEX, Cream Fi-nance [58] for lending protocols, ATK [15] for staking-based yieldfarming protocols, and Harvest [82] for deposit-based yield farmingprotocols, which collectively incurred a loss of $163.3M.Based on this in-depth analysis, we identify four attack types targeting different DeFi protocols and their eight generalized attackpatterns, as depicted in Table 1. These attack types are Buy & Sell,Deposit & Borrow, Stake & Claim, and Deposit & Withdraw, witheach type corresponding to two specific attack patterns. We willdiscuss these attack types and patterns in more detail.Buy & Sell. In this type of attack strategy, the attacker primar-ily profits by first buying Tokeny with Tokenx through a swap inPoolbuy and then selling Tokeny for Tokenz through a swap inPoolsell. Tokenx and Tokenz can be the same or different tokens.In the attack against ElephantMoney, the attacker first conducteda swap in Poolbuy to exchange WBNB for ELEPHANT and theninvoked the mint function, which triggered a swap in Poolsell toexchange ELEPHANT for WBNB, resulting in a price increase ofELEPHANT in Poolsell. Ultimately, the attacker utilized a reverseswap in Poolsell to obtain WBNB by selling ELEPHANT at themanipulated price. We design Pattern I based on this attack andsubsequently generalize it to Pattern II. The major difference be-tween these two patterns is that the token price is manipulated"}, {"title": "7 Implementation and Evaluation", "content": "We implement DeFiScope with about 3,900 lines of Python code.DeFiScope currently supports two blockchains, i.e., Ethereum [33]and BSC [16], which account for over 60% of total value locked(TVL) among all the blockchains [29]. To obtain raw data fromspecific transactions, we utilize blockchain node APIs facilitated byQuickNode [80], an external RPC service provider.Our evaluation aims to answer three research questions (RQs):\u2022 RQ1: How effectively does DeFiScope detect price manipulationattacks compared with the existing state-of-the-arts?\u2022 RQ2: How significantly does the fine-tuning technique promotethe accuracy of DeFiScope?\u2022 RQ3: How practically and efficiently does DeFiScope detect pricemanipulation attacks in a real-world setting?Datasets. To address these three RQs, we collect three datasetsfrom real DeFi transactions on Ethereum and BSC to evaluate DeFiS-cope, as shown in Table 2. Specifically, we use the first dataset, D1,which comprises 95 transactions of real-world price manipulationattacks from 90 DeFi applications, to evaluate both RQ1 and RQ2.To demonstrate DeFiScope's practicality for RQ3, we use the seconddataset, D2, consisting of 968 suspicious transactions collected byour industry partner. Furthermore, to measure DeFiScope's timeoverhead when deployed in a realistic setting with both suspiciousand benign transactions, we mix the 968 suspicious transactionsfrom D2 with 96,800 benign transactions in the third dataset, D3."}, {"title": "7.1 RQ1: Detection Effectiveness", "content": "To answer RQ1, we evaluate DeFiScope and compare it with threeSOTA tools-DeFiTainter [63], DeFort [94], and DeFiRanger [93],using the dataset D1. Because DeFiRanger is not open-source, weuse the results reported in their paper for the attacks they evaluated;for other attacks, we re-implemented their approach based on thedescription [93] and conducted our evaluation. Although DeFort isalso not open-source, we obtained a copy of its source code fromthe authors to conduct our experiment.Table 4 presents the detection results. The first four columns listthe name of the victim protocol, the destination chain, the hackdate, and the resulting loss, respectively. Note that one protocolmay face multiple attacks, so we add numerical suffixes to protocolnames to differentiate them. We use to indicate an attack can besuccessfully detected by a tool, and X to indicate a detection failure.DeFiScope can detect most of the price manipulation attacks. Itachieves a recall rate of 80%, outperforming all other tools. Overall,DeFiScope detected 76 attacks, followed by DeFort with 50 andDeFiRanger with 49 attacks, respectively, while DeFiTainter detected only 34 attacks. Figure 8 details the performance of each toolon the evaluated DeFi protocols across four application categoriesusing different price models. Compared to other tools, DeFiScopeperforms the best in every application category. Particularly, itachieves the highest recall, 90.7%, in Token-related protocols. However, DeFiScope yields a low recall rate in Lending-related protocols,though still higher than all existing tools. Through further analysis,we identifies that 3 out of 12 attacks (InverseFinance_2, Sanshulnu,and VesperFinance) are cross-transaction attacks that DeFiScopeis unable to detect. Additionally, one attack (TIFIToken) involvesexploiting a closed-source custom price model, and the InverseFi-nance_1 attack, a false negative, will be detailed below.Yet, DeFiScope missed detecting 11 price manipulation attacks.After analyzing each attack, we discovered that 8 out of 11 are cross-transaction attacks [3, 4, 10, 15, 46, 59, 62, 75], where detection wasunsuccessful because DeFiScope is based on analyzing individualtransactions. For Zoompro, detection failure occurred because thetoken involved in the transaction did not adhere to the ERC20 tokenstandard, resulting in the transfer event not being identified. Theremaining two attacks, i.e., \"IndexedFinance\" and \"InverseFinance_1\"cases, were subject to in-depth analysis. The detection incapabilityfor IndexedFinance was due to its use of an extremely complicatedpricing mechanism that involves exponential calculations in itsprice-related function joinswapExternAmountIn. In the case ofInverseFinance, the attacker exploited the flawed price dependencywhen calculating the price of tokens deposited as collateral, where"}, {"title": "7.2 RQ2: Ablation Study", "content": "In this RQ, we investigate how fine-tuning can enhance DeFiScope'sdetection accuracy on the same D1 dataset, as well as the impact andcost of fine-tuning different GPT models. To this end, we test foursettings shown in Figure 9: (a) the original GPT-3.5-Turbo withoutfine-tuning, (b) GPT-3.5-Turbo with fine-tuning, which was used inRQ1, (c) the original GPT-40 without fine-tuning, and (d) GPT-40with fine-tuning.Figure 9 shows that fine-tuning significantly enhances DeFiScope's ability to detect attacks, with the fine-tuned versions ofGPT-3.5-Turbo and GPT-40 detecting 18 (31%) and 12 (19%) more attacks, respectively. It also indicates that fine-tuning provides a morenoticeable improvement for less powerful models, such as GPT-3.5-Turbo, compared to stronger models like GPT-40. With fine-tuning,the detection success rate for attacks targeting the CPMM increases to 100% with GPT-3.5-Turbo and 95.6% with GPT-40. This veryhigh rate can be attributed to the use of CPMM during the fine-tuning training phase, enabling the model to effectively handle thisspecific pricing model."}, {"title": "7.3 RQ3: Real-World Practicality", "content": "To be practical in a real-world setting, DeFiScope not only needs to maintain high detection rates for true attacks but also minimizefalse alarms for benign transactions. In this RQ, we evaluate thisaspect of DeFiScope and the associated time overhead using thedatasets D2 and D3, which were introduced in the prologue of \u00a77.Specifically, D2 comprises 968 suspicious transactions with variousattacks (i.e., not limited to price manipulations), and D3 includes96,800 benign transactions collected from DeFort [94]'s dataset.For D2, DeFiScope flagged 153 price manipulation attacks outof 968 suspicious transactions. To robustly confirm these poten-tial attacks, we cross-referenced them with attack reports or alertspublished by security companies through their official channels [2,6, 8, 83], thereby verifying the root causes of the attacks. Usingthis method, we confirm that 66 of them are previously reportedprice manipulation attacks. For the remaining cases, we conductedcomprehensive and in-depth analyses by combining manual re-view with ancillary evidence, such as identifying whether the EOAinitiating the transaction was marked as a hacker by blockchain ex-plorers [13, 40, 71]. Finally, we discovered 81 previously unknown"}, {"title": "8 Discussion", "content": "While the precision of DeFiScope is quite satisfactory, its recall rate isprimarily affected by the following two threats. Future work canfurther optimize the following two aspects:Cross-transaction price manipulation attacks. DeFiScope cur-rently detects only single-transaction attacks. However, some price manipulation attacks are designed across multiple transactions tocircumvent time restrictions coded in DeFi protocols, as studiedin [19]. Detecting cross-transaction attacks is often challenging. Forexample, attacks like INUKO [3] span 48 hours (crossing around57,000 blocks), making it extremely difficult to precisely identifyall related transactions. Fortunately, our study observed that cross-transaction attacks are less common than single-transaction ones.Closed-source price calculation functions. The availability ofcode for price models could affect the detection accuracy of De-FiScope. According to our study, most DeFi applications are open-source to gain user trust. To mitigate issues with closed-sourceprice models, we design the Type-II prompt to cover price modelsin those closed-source liquidity pools."}, {"title": "9 Related Work", "content": "On-chain Security Analysis. Prior efforts [28, 78, 79, 97, 98] haveelucidated threats in blockchain and attacks against the DeFi ecosys-tem. Some transaction-based systems have been proposed to minevulnerable transaction sequences [84, 95], explore arbitrage oppor-tunities [96], detect malicious phishing [55], and simulate attacksto prevent intrusions [76].Tools like FlashSyn [18], DeFiRanger [93], DeFiTainter [63], andDeFort [94] are capable of detecting attacks associated with pricemanipulation. FlashSyn uses numerical approximation techniquesto synthesize malicious contracts that target DeFi apps throughprice manipulation attacks. However, there is a gap between thesynthesized contracts and those that launch attacks on the liveblockchain.DeFiRanger generates cash flow trees (CFT) from atransaction, translates the semantics of CFT into high-level DeFi ac-tions, and uses specific patterns to detect price manipulation attacks."}, {"title": "10 Conclusion", "content": "In this paper, we introduced DeFiScope, the first tool that utilizesLLMs specifically for detecting price manipulation attacks. DeFiScope employs LLMs to intelligently infer the trend of token pricechanges based on balance information within transaction execu-tions. To strengthen LLMs in this aspect, we simulated on-chaintransaction data and fine-tuned a DeFi price-specific LLM. We alsoproposed a graph-based method to recover high-level DeFi opera-tions and systematically mined eight price manipulation patterns.Our evaluation demonstrated DeFiScope's superior performanceover SOTA approaches and real-world impact. Future work includesbetter handling of closed-source price calculation functions."}, {"title": "A A Case Study of Type-II Prompt", "content": "Figure 10 illustrates an use case of Type-II prompt. The contract(0x2120...3379) is closed source DEX contract that allows usersto trade SVT and USDT. While recovering the DeFi operations,this contract was identified as a two-token liquidity pool. So, weapplied the Type-II prompt to inferring the token price trend inits transactions. As shown by the LLM response in Figure 10, theprimary difference from the response to a Type-I prompt lies in theabsence of the analysis on the price model; instead, the scoringis directly yielded. The is because the prompt itself assumes thatthe CPMM is employed in this contract. Regarding the CPMM,the relationship between token price and token balance is quitestandardized, i.e., the direction of balance change is opposite to thatof price change."}, {"title": "B High-value DeFi Applications", "content": "The design of DeFi operations and the category of transfer actions in\u00a75 is based on an in-depth study of the high-value DeFi applicationslisted in Table 7 as of August 2024."}, {"title": "C Details of False Positives", "content": "Table 6 presents the details of six false positives discovered in ourexperiments described in \u00a77.3. The reason for these false positivesis that their transactions involve two contract accounts that werecreated three months ago by the transaction initiator. Any fundtransfers among these accounts and the initiator should be consid-ered benign operations rather than price manipulation operations.Yet, these accounts were incorrectly marked as closed-source DEXesin the detection, leading to false inferences. Such false positivescould be mitigated by conducting a historical analysis of accountownership relationships and clustering user accounts that are con-trolled by the same owners."}]}