{"title": "Static Analysis of Logic Programs via\nBoolean Networks", "authors": ["Van-Giang Trinh", "Belaid Benhamou"], "abstract": "Answer Set Programming (ASP) is a declarative problem solving paradigm that can\nbe used to encode a combinatorial problem as a logic program whose stable models\ncorrespond to the solutions of the considered problem. ASP has been widely applied\nto various domains in AI and beyond. The question \"What can be said about stable\nmodels of a logic program from its static information?\" has been investigated and\nproved useful in many circumstances. In this work, we dive into this direction more\ndeeply by making the connection between a logic program and a Boolean network,\nwhich is a prominent modeling framework with applications to various areas. The\nproposed connection can bring the existing results in the rich history on static analysis\nof Boolean networks to explore and prove more theoretical results on ASP, making\nit become a unified and powerful tool to further study the static analysis of ASP. In\nparticular, the newly obtained insights have the potential to benefit many problems in\nthe field of ASP.", "sections": [{"title": "1 Introduction", "content": "Answer Set Programming (ASP) has emerged as a powerful declarative programming paradigm\nfor solving complex combinatorial problems under the umbrella of logic programming and\nnon-monotonic reasoning [18]. Its basic idea is to describe the specifications of a problem by\nmeans of a logic program: solutions of this problem will be represented by the stable models\nof the logic program [12]. Then the logic program can be fed into a software system called\nan ASP solver such as DLV, Cmodels, Smodels, or clasp [16], which can compute some or\nall stable models of this program. With the constant improvements in both theory (e.g.,\nexpressive powers) and practice (e.g., efficient ASP solvers), ASP has been successfully ap-\nplied to a wide range of areas in AI (e.g., planning, knowledge representation and reasoning,\nsemantic web, natural language processing, and argumentation) and beyond (e.g., systems\nbiology, computational biology, bounded model checking, software engineering, robotics, and\nmanufacturing) [13].\nIn general, the problem of deciding if a given ground normal logic program has some\nstable model is NP-complete [27]. It is thus natural to consider the static analysis of ASP,\ni.e., answering the question: What can be said about stable models of a logic program from\nits static information? Herein, a Logic Program (LP) is considered as a ground normal logic\nprogram [18] and its static information is mostly considered as graph representations of the\nLP such as (positive) dependence graphs [14], cycle and extended dependence graphs [7,\n8], rule graphs [9], and block graphs [25]. Historically, the first studies of this research\ndirection focused on the existence of a unique stable model in dependence graph-based\nclasses of LPs including positive LPs [18], acyclic LPs [2], and locally stratified LPs [18]. In\n1994, Fages proved the most important result about the coincidence between stable models\nand models of the Clark's completion (equivalently supported models) in tight LPs [14].\nBeing finer-represented than dependence graphs, cycle and extended dependence graphs\nwere introduced and several improved results were obtained [7, 8]. However, there is quite\nlimited progress regarding this direction. Moreover, it is noted that the cycle graph or the\nextended dependence graph of an LP can have exponentially many vertices as the LP can\nhave an exponential number of cycles [7] or rules [8], respectively. Recently, we have been\nonly aware of the work [15], which presents new understanding of the positive dependence\ngraph to possibly strengthen some existing theoretical results. In summary, while the static\nanalysis of ASP is important and has a wide range of useful applications in both theory and\npractice of ASP [14, 7, 11], there is quite limited progress on this research topic.\nBoolean Networks (BNs) are a simple yet efficient mathematical formalism that has been\nwidely applied to many areas from science to engineering [35, 29]: mathematics, systems\nbiology, computer science, theoretical physics, robotics, social modeling, neural networks,\netc. A BN includes n Boolean variables associated with n corresponding Boolean functions\nthat determine the value update of a variable over time. In this sense, a BN can be seen as\na discrete dynamical system [36, 37]. Originated by the early work [37], the static analysis\nof BNs (i.e., studying relations between the dynamics of a BN and its influence graph) has a\nrich history of research [33]. In particular, most results focus on exploring relations between\nfixed points and the influence graph of a BN, where a fixed point is a state once entered,\nthe BN's dynamics cannot escape from it [4]. To date, this research direction is still growing\nwith many prominent and deep results [33, 32, 34].\nASP has found widespread applications in both the modeling and analysis of BNs. It\nhas been notably used for important tasks on BNs (all are computational ones) such as fixed\npoint enumeration [29], enumeration and approximation of attractors [29, 24], inference of\nBNs from biological data [31], model repair [17], and reprogramming [23]. In the opposite\ndirection, there is however no significant work trying to use BNs for studying the static\nanalysis of ASP. Indeed, the initial connection between ASP and BNs can be traced back\nto the theoretical work by [20]. In this work, the authors used LPs to model BNs, and vice\nversa. However, their investigations were limited to the conceptual level, and no subsequent\nstudies have delved deeper into this connection so far.\nIn this work, we try to explore in depth the static analysis of ASP. Herein, static informa-\ntion of an LP is considered as its Dependence Graph (DG) [14]. The DG can be efficiently\n(syntactically) computed from the LP itself and might be in general more compact than\nother graph representations (e.g., cycle or extended dependence graphs [7, 8]), but can tell\nmany significant insights about stable models of the LP as we shall show in this paper. Our"}, {"title": "2 Preliminaries", "content": "In this paper, we consider only ground normal logic programs. Unless specifically stated, a\nLogic Program (LP) means a ground normal logic program. B = {0,1} is the Boolean do-\nmain, and all Boolean operators used in this paper include \u2227 (conjunction), V (disjunction),\n\u00ac (negation), and \u2194 (bi-implication).\nAn LP P is a finite set of rules of the form $p \\leftarrow p_1, ..., p_m, \\sim p_{m+1}, ..., \\sim p_k$\nwhere p and $p_i$ are variable-free atoms (k > m > 0), ~ denotes the negation as failure.\nWe use atom(P) to denote the set of all atoms of P. For any ruler of this form, p is\ncalled the head of r (denoted by h(r)), $b^+(r) = {p_1,...,p_m}$ is called the positive body of\nr, $b^-(r) = {p_{m+1},...,p_k}$ is called the negative body of r, $b(r) = b^+(r) \\cup b^-(r)$ is the body\nof r, and $bf(r) = p_1 \\wedge \\dots \\wedge p_m \\wedge \\neg p_{m+1} \\wedge \\dots \\wedge \\neg p_k$ is the body formula of r. If b(r) = \u00d8,\nthen r is called a fact and bf(r) is conventionally 1. An Herbrand interpretation I is a\nsubset of atom(P), and is called an Herbrand model if for any ruler in P, $b^+(r) \\subseteq I$ and\n$b^-(r) \\cap I = \\emptyset$ imply h(r) \u2208 I. P is positive if $b^-(r) = \\emptyset$ for all r \u2208 P. In this case, P\nhas a unique least Herbrand model. An Herbrand interpretation I is a stable model of P if\nI is the least Herbrand model of the reduct of P with respect to I (denoted by $P^I$) where\n$P^I = {h(r) \\leftarrow \\bigwedge_{p \\in b^+(r)} p \\mid r \\in P, b^-(r) \\cap I = (\\emptyset}$. We use sm(P) to denote the set of all stable\nmodels of P.\nThe Clark's completion of an LP P (denoted by cf(P)) consists of the following sentences:\nfor each p \u2208 atom(P), let $r_1,...,r_l$ be all the rules of P having the same head p, then\n$p \\leftrightarrow bf(r_1) \\vee \\dots \\vee bf(r_l)$ is in cf(P). If l = 0, then the equivalence is p \u2194 0. In this\npaper, we shall identify a truth assignment with the set of atoms true in this assignment,\nand conversely, identify a set of atoms with the truth assignment that assigns an atom true\niff it is in the set. Under this convention, a model of cf(P) is also a Herbrand model of P.\nAn Herbrand model A is a supported model if for any atom p \u2208 A, there is a ruler \u2208 P\nsuch that h(r) = p, $b^+(r) \\subseteq A$, and $b^-(r) \\cap A = \\emptyset$. We use supp(P) to denote the set of all\nsupported models of P. It is well-known that supported models of P coincide with models"}, {"title": "3 Main Results", "content": "For clarification, we make a summary of the results that shall be presented in this sec-\ntion. First, the known results with formal proofs include Theorem 1, Proposition 4, and\nTheorem 13. Second, the known results in the ASP folklore without formal proofs include\nTheorems 9 and 12. Third, the completely new results include Theorems 2 and 3, Proposi-\ntions 5 and 6, Lemmas 7 and 8, Proposition 10, Lemma 11, and Theorem 14."}, {"title": "3.1 Logic Programs and Boolean Networks", "content": "First of all, we recall Fages' theorem (see Theorem 1).\nTheorem 1 ([14]). Let P be an LP. If dg+(P) has no cycle, then the set of stable models of\nPcoincides with the set of supported models of P.\nNext, we define the BN encoding for LPs (see Definition 1).\nDefinition 1. Let P be an LP. We define a BN f encoding Pas: var f = atom(P) and\n$f_v = \\bigvee_{r \\in P, v=h(r)} bf(r), v \\in var_f$. Conventionally, if v does not appear in the head of any\nrule then $f_v = 0$.\nThe first connection between an LP and its BN encoding is about the relation between\nthe DG and the IG (see Theorem 2). This relation is very important because all the following\nresults rely on it and the DG or the positive DG of P can be efficiently built based on the\nsyntax only, whereas the construction of the IG of f may be exponential in general. Note\nhowever that the IG of f is usually built by using Binary Decision Diagrams (BDDs) [33].\nIn this case, the IG can be efficiently obtained because each Boolean function fv is already\nin Disjunctive Normal Form (DNF), thus the BDD of this function would be not too large.\nTheorem 2. Let P be an LP and f be its BN encoding. Then ig(f) \u2286 dg(P).\nProof. We have that ig(f) and dg(P) have the same set of vertices that is the set of ground\natoms of P. Let (uv, e) be an arc in ig(f). We show that (uv, e) is also an arc in dg(P).\nWithout loss of generality, suppose that e = \u2295.\nAssume that (uv,\u2295) is not an arc in dg(P). There are two cases. Case 1: there is\nno arc from u to v in dg(P). In this case, both u and \u00acu clearly do not appear in fv.\nThis implies that ig(f) has no arc from u to v, which is a contradiction. Case 2: there is\nonly a negative arc from u to v in dg(P). It follows that \u00acu appears in fv but u does not\nbecause fv is in DNF. Then, for any state x and for every conjunction c of fv, we have that\n$c(x[u \\leftarrow 0]) \\geq c(x[u \\leftarrow 1])$. This implies that $f_v(x[u \\leftarrow 0]) \\geq f_v(x[u \\leftarrow 1])$ for any state x.\nSince (uv, \u2295) is an arc in ig(f), there is a state x such that $f_v(x[u \\leftarrow 0]) < f_v(x[u \\leftarrow 1])$.\nThis leads to a contradiction. Hence, (uv, \u2295) is an arc in dg(P).\nWe can conclude that ig(f) \u2286 dg(P) (i.e., ig(f) is a subgraph of dg(P)).\nTheorem 3. Let P be an LP and f be its BN encoding. Then the set of supported models\nof P coincides with the set of fixed points of f, i.e., supp(P) = fix(f).\nProof. By the definition of the BN encoding and the fixed point characterization, fix(f) is\nidentical to the set of models of cf(P). The set of models of cf(P) is exactly the set of\nsupported models of P (i.e., supp(P)) [3]. Hence, supp(P) = fix(f).\nTheorem 3 shows that for an LP P, supp(P) = fix(f) where f be the encoded BN of P.\nIt suggests that the set of fixed points of f is an upper bound for the set of stable models of\nP. See Example 1 for illustration. If dg+(P) has no cycle, then the two sets are the same\nby Fages' theorem. In this case, all existing (both theoretical and practical) results on fixed\npoints of BNs can be directly applied to stable models of LPs. However, such a class of LPs\nis only a small piece of all possible LPs. Hence, we shall exploit Theorem 2, Theorem 3, and\nthe existing results on fixed points of BNs to explore new results on stable models of LPs in\ngeneral."}, {"title": "3.2 Cycles and Stable Models", "content": "We start with revisiting one well-known result in ASP (see Proposition 4). We provide a\nnew proof for it, which relies on the relation between an LP and a BN.\nProposition 4. Let P be an LP. If dg(P) has no cycle, then P has exactly one stable model.\nProof. Let f be the encoded BN of P. Since dg+(P) \u2286 dg(P), dg+(P) has no cycle, then\nsm(P) = supp(P) by Theorem 1. Since ig(f) \u2286 dg(P), ig(f) has no cycle. By Theorem 1\nof [33], f has a unique fixed point, thus P has a unique stable model.\nProposition 4 is the consequence of Theorem 2.5(iv) of [2] and Fages' theorem. Theorem\n2.5(iv) of [2] shows that if dg(P) has no cycle, then cf(P) has a unique model, which is\nalso the unique stable model of P by Fages' theorem. Indeed, the BN-based proof that we\nprovide here is quite simpler than the above proof. We then present two newly small results\nconsidering LPs with very special structures (see Propositions 5 and 6). See Example 2 for\nillustration.\nProposition 5. Let P be an LP. Suppose that dg(P) is a positive cycle. If dg(P) has a\nnegative arc, then P has exactly two stable models. Otherwise, P has exactly one stable\nmodel.\nProof. Let f be the BN encoding of P. Since dg(P) is a positive cycle, the in-degree of\neach vertex is one, leading to every fv is constant-free. Hence, ig(f) is also a positive cycle.\nBy [30], f has exactly two fixed points. If dg(P) has a negative arc, then dg+(P) has no\ncycle. It follows that supp(P) = sm(P) by Theorem 1. Hence, P has exactly two stable\nmodels. If dg(P) has no negative arc, then Pis positive. Hence, it has exactly one stable\nmodel.\nIn the proof of Proposition 5, if P has exactly two stable models (say A and B), then\n$A \\cap B = \\emptyset$ and $A \\cup B = atom(P)$, since A and B are also the two fixed points of f where\n$A_v \\neq B_v, \\forall v \\in var_f$ by [30]. Otherwise, the unique stable model of P is \u00d8.\nProposition 6. Let P be an LP. Suppose that dg(P) is a negative cycle. Then P has no\nstable model.\nProof. Let f be the BN encoding of P. Since dg(P) is a negative cycle, the in-degree of\neach vertex is one, leading to every fv is constant-free. Hence, ig(f) is also a negative cycle.\nBy [30], f has no fixed point. It follows that P has no supported model. Since a stable\nmodel is also a supported model, P has no stable model.\nLemma 7. Let P be an LP. If P has two distinct stable models (say A\u2081 and A2), then dg(P)\nhas a positive cycle C+ such that for every v \u2208 C+, either v \u2208 A\u2081 or v \u2208 A2.\nProof. Let f be the BN encoding of P. A\u2081 and A2 are also distinct supported models of P.\nBy Theorem 3, A\u2081 and A2 are distinct fixed points of f. By Lemma 1\u00b9 of [33], ig(f) has a\npositive cycle C+ such that for every v \u2208 C+, $A_1(v) \\neq A_2(v)$, i.e., either v \u2208 A\u2081 or v \u2208 A2\nbecause $A_1(v), A_2(v) \\in B$. C+ is also a positive cycle of dg(P) because ig(f) is a subgraph\nof dg(P).\nLemma 8. If a sign directed graph G is strongly connected and has no negative cycle or has\nno positive cycle, then G is sign-definite.\nProof. We first prove that each arc of G belongs to a cycle in G (*). Taken an arbitrary arc\n(uv, e) in G. Since G is strongly connected, there is a directed path from v to u. By adding\n(uv, e) to this path, we obtain a cycle.\nAssume that G is not sign-definite. Then there are two arcs: (uv, \u2295) and (uv, \u2295). By\n(*), (uv, \u2295) (resp. (uv, \u2295)) belongs to a cycle in G (say C). C is a positive (resp. negative)\ncycle because G has no negative (resp. positive) cycle. Then $(C - (uv, \\oplus)) + (uv, \\ominus)$ (resp.\n$(C - (uv, \\ominus)) + (uv, \\oplus)$) is a negative (resp. positive) cycle in G. This implies a contradiction.\nHence, G is sign-definite.\nTheorem 9. Let P be an LP. If dg(P) has no positive cycle, then P has at most one stable\nmodel. In addition, if P has no fact and every atom appears in the head of a rule in P, then\nP has no stable model.\nTheorem 10. Let P be an LP. For any PFVSU+ of dg(P), we have that $|sm(P)| < 2^{|U+|}.$\nProof. Let f be the BN encoding of P. Since U+ is a PFVS of dg(P), dg(P) \u2013 U+ has no\npositive cycle. Since ig(f) \u2286 dg(P), ig(f) \u2013 U+ also has no positive cycle. Therefore, U+\nis a PFVS of ig(f). By Theorem 9 of [4], $|fix(f)| \\leq 2^{|U+|}$. Since $|sm(P)| \\leq |fix(f)|$, we can\nconclude that $|sm(P)| \\leq 2^{|U+|}.$\nNote that Proposition 10 can be directly proved by using Theorem 9. The main idea\nis that in any stable model of P, each atom in U+ can be either true or false. For each\nassignment of atoms in U+, we get a new LP whose DG has no positive cycle, then it has at\nmost one stable model by Theorem 9. There are $2^{|U+|}$ possible assignments of atoms in U+,\nhence we can deduce $|sm(P)| \\leq 2^{|U+|}.$\nIt is well-known in the BN field that if ig(f) has no negative cycle, then f has at least\none fixed point (Theorem 6 of [4]). Naturally, it is interesting to question whether an\nLP whose DG has no negative cycle has at least one stable model or not. Fages showed\na counterexample for the case of infinite logic programs [14], but the case of finite logic\nprograms is still open. We answer this question by Theorem 12.\nTo prove Theorem 12, we use the fixpoint semantics of logic programs [10]. To be\nself-contained, we briefly recall the definition of the least fixpoint of a logic program. A\nquasi-interpretation is a set possibly infinite of rules of the form $p \\leftarrow \\sim p_1,...,\\sim p_k$ where\nk \u2265 0 and $p, p_1,..., p_k \\in atom(P)$. Let r be the rule $p \\leftarrow \\sim p_1,..., \\sim p_k, q_1,...,q_j$ and let $r_i$\nbe rules $q_i \\leftarrow \\sim q_1^i,...,\\sim q_{l_i}^i$ where $1 \\leq i \\leq j$ and $l_i \\geq 0$. Then $T_r({r_1,...,r_j})$ is the rule\n$p\\leftarrow \\sim p_1,..., \\sim p_k, \\sim q_1, ..., \\sim q_1^{l_1}, ..., \\sim q_i, ..., \\sim q_i^{l_i}, ..., \\sim q_j, ..., \\sim q_j^{l_j}$. We now introduce the transformation\n$T_p$ on quasi-interpretations: $T_p(Q) = {T_r({r_1,...,r_j}) \\mid r \\in P, r_i \\in Q, 1 \\leq i \\leq j}$. Let\n$lfp_0 = T_p(\\emptyset) = T_p(T_p(...T_p(\\emptyset)))$, then $lfp = \\bigcup_{i>1} lfp_i$ is the least fixpoint of P.\nLemma 11. Let P be an LP and P' be its least fixpoint. If dg(P) has no negative cycle,\nthen dg(P') has no negative cycle.\nProof. By Lemma 5.3 of [14], if vertex a has a negative path to vertex b in dg(P'), then a\nhas also a negative path to b in dg(P). Note that the set of vertices of dg(P') is a subset\nof that of dg(P). It follows that if there is a negative cycle in dg(P'), then there is also a\nnegative cycle in dg(P). Hence, if dg(P) has no negative cycle, then dg(P') has no negative\ncycle.\nTheorem 12. Let P be an LP. If dg(P) has no negative cycle, then P has at least one stable\nmodel.\nProof. Let P' be the least fixpoint of P. By Lemma 11, dg(P') has no negative cycle. Let f'\nbe the encoded BN of P'. Since ig(f') \u2286 dg(P'), ig(f') also has no negative cycle. Therefore,\nf' has at least one fixed point by Theorem 6 of [4]. By Theorem 3, supp(P') = fix(f'). It\nis known that sm(P) = supp(P') (Theorem 4 of [10]). This implies that sm(P) = fix(f').\nHence, P has at least one stable model.\nThe technique used to prove Theorem 12 suggests a potential way to explore more theo-\nretical results: picking up a structural property of dg(P), seeing what it becomes in the DG\nof the least fixpoint of P, and checking how fixed points of the encoded BN of the least fix-\npoint behave under the new property. For illustration, consider the class of locally stratified\nLPs. P is locally stratified if every cycle of dg(P) contains no negative arc [18]. Considering\nthis property, we can prove that the DG of the least fixpoint of P has no cycle. In this case,\nthe least fixpoint has exactly one stable model, leading to P has so. See the detailed proof in\nTheorem 13. This provides an alternative (maybe simpler) proof for the well-known result\nstating that a locally stratified LP has a unique stable model (Theorem 6.2.7 of [19]).\nTheorem 13. Let P be an LP. If P is locally stratified, then P has exactly one stable model.\nRecall that $P' = lfp = \\bigcup_{i \\geq 1} lfp_i$. We show that\nProof. Let P' be the least fixpoint of P.\ndg(lfp\u00bf) has no cycle by induction on i.\nThe base case is trivial (i.e., i = 0). Consider an arbitrary ruler \u2208 $lfp_{i+1} \\setminus lfp_i$. Let\nb = h(r) and $a \\in b^-(r)$. By definition, there exists a rule r' \u2208 P such that h(r') = b and\n$a \\in b^-(r'')$ with $r'' \\in lfp_i$ and $h(r'') \\in b^+(r')$. Let c = h(r''). We use $b \\leq_{\\oplus} a$ (resp. $b \\leq_{\\ominus} a$)\nto denote that there is a positive (resp. negative) path from b to a. We have that $a \\leq b$\nin dg(lfp\u2081+1). Note that lfp; \u2286 lfp\u2081+1 by definition. If $b \\leq_{\\oplus} a$ in dg(lfp\u2081), then $b \\leq a$ in\ndg(lfp\u2081+1), leading to $b \\leq b$ in dg(lfp\u2081+1) (also in dg(P')), which is a contradiction because\ndg(P') has no negative cycle by Lemma 5.3 of [14]. If $b \\leq_{\\ominus} a$ in dg(lfp\u2081), then $b \\leq a$ in\ndg(P'), leading to $b \\leq a$ in dg(P) by Lemma 5.3 of [14]. Similarly, $a \\leq_{\\ominus} c$ in dg(P), since\n$a \\in c$ in dg(lfp\u2081). We use $b \\leq_0 a$ to denote that there is a path of only positive arcs from b\nto a. We have $c \\leq_0 b$ in dg(P). Then there is a cycle containing b and also negative arcs in\ndg(P), which is a contradiction because P is locally stratified. Hence, there is no path from"}, {"title": "4 Discussion", "content": "Theorem 3 and the subsequent results immediately suggest that we can compute stable\nmodels of an LP P by using fixed points of its encoded BN f. Recall that a fixed point of f"}, {"title": "4.1 Computation of stable models", "content": "Theorem 14. Let P be an LP. Suppose that dg(P) is strongly connected, has at least one\narc, and has no negative cycle. If dg+(P) has no cycle, then P has two stable models A and\nB such that $ \\forall v \\in atom(P)$, either v \u2208 A or v \u2208 B. In addition, A and B can be computed\nin polynomial time.\nProof. Let f be the BN encoding of P. Since dg+(P) has no cycle, sm(P) = supp(P) = fix(f)\nby Theorems 1 and 3. We show that f has two fixed points that are complementary.\nSince dg(P) is strongly connected and has no negative cycle, it is sign-definite by Lemma 8.\nIt implies that ig(f) is also sign-definite because ig(f) \u2286 dg(P). dg(P) has the minimum\nin-degree of at least one because it is strongly connected and has at least one arc. By using\nthe deduction similar to that in Theorem 9, we have that f has no constant function. It is\nknown that when dg(P) is strongly connected and has no negative cycle, its set of vertices\ncan be divided into two equivalence classes (say S+ and S\u00af) such that any two vertices in\nS+ (resp. S\u00af) are connected by either no arc or a positive arc, and there is either no arc or\na negative arc between two vertices in S+ and S\u00af (Theorem 1 of [1]). Since ig(f) \u2286 dg(P)\nand ig(f) has the same set of vertices with dg(P), S+ and S\u00af are still such two equivalence\nclasses in ig(f).\nLet x be a state defined as: $x_i = 1$ if $i \\in S^+$ and $x_i = 0$ if $i \\in S^-$. Consider a given node\nj. If $x_j = 0$, by the above result, for all $i \\in atom(P)$ such that ig(f) has a positive arc from\ni to j, $x_i = 1$, and for all $i \\in atom(P)$ such that ig(f) has a negative arc from i to j, $x_i = 0$.\nSince f; cannot be constant, fj(x) = 1. Analogously, if $x_j = 1$, then fj(x) = 1, implying that\nx is a fixed point of f. By using the similar deduction, we can conclude that $ \\bar{x}$ is also a fixed\npoint of f where $\\bar{x_i} = 1 - x_i, \\forall i \\in var_f$. Let A and B are two models of P corresponding\nto x and $ \\bar{x}$. Clearly, A and B are stable models of P. We have that $ \\forall v \\in atom(P)$, either\nv \u2208 A or v \u2208 B. In addition, since S+ and S\u00af can be computed in polynomial time, A and\nB can be computed in polynomial time.\nmay be not a stable model of P, but checking whether a fixed point is a stable model or not\ncan be done in linear time [12]. Notably, there is a rich history for computing fixed points\nin BNs: SAT-based methods [28], ILP-based methods [28], and structure-based methods [5].\nWe can first check if dg+(P) does not contain any cycle. If so, sm(P) = fix(f) and we\ncan apply directly some efficient methods for fixed point computation. Otherwise, we need\nto check if each fixed point is a stable model or not. This approach would be efficient if\n$|fix(f) \\setminus sm(P)|$ is not too large. Note however that we can estimate |fix(f)| in prior by using\nsome known upper bounds of the number of fixed points of a BN (e.g., $2^{|U+|}$ where U+ is a\nPFVS of dg(P), which can be efficiently computed by using some approximation methods [33]\nbecause U+ is unnecessarily minimum). If the chosen bound is too large, we can apply some\ntransformations (e.g., [21]) to P to get a new LP P' such that sm(P) = sm(P') = fix(f')\nwhere f' is the encoded BN of P'. Such a transformation might introduce more atoms, but\nit seems that there are less changes in cycle structures (e.g., the size of the minimum PFVS\nseems to still retain [21]). In this case, structure-based methods for fixed point computation,\nespecially the PFVS-based method [5] whose complexity is $O(2^{|U+| \\times n^{2+k}})$ where the Boolean\nfunctions of the BN can be evaluated in time O(nk), would be very helpful in complementary\nto standard ASP solvers such as Cmodels, Smodels, and clasp."}, {"title": "4.2 Program correction", "content": "Theorem 12 has the potential to be useful in some other problems in ASP. It is related to\nthe program correction problem [22], where we intend to modify an inconsistent LP Pincon\n(i.e., having no stable model) to make it consistent (i.e., having at least one stable model).\nFor example, by making some modification operators (e.g., removing rules, flipping signs of\nliterals) such that dg(Pincon) has no negative cycle, we can obtain the consistency for Pincon\u00b7\nThese modifications might be not minimal, but they might provide a good upper bound\nfor further searching. In the opposite direction, we might want to modify a consistent LP\nPcon to make it inconsistent. By Theorem 9, we can make modifications such that dg(Pcon)\nhas no positive cycle. Such a problem might be useful in program verification where the\nvalidation of a property can be encoded as the unsatisfiability of an SAT formula [26] or the\ninconsistency of an LP. We believe that exploiting Theorems 9 and 12 will give more benefits\nto the program correction problem, which we plan to study deeply in future."}, {"title": "4.3 Interplay between positive and negative cycles", "content": "The results presented in this paper show that positive and negative cycles are key structures\nto understand the relations between stable models and the DG of an LP. However, they use\nonly information on either positive cycles or negative cycles. It is then natural to think that\nby using both kinds of cycles simultaneously, we can obtain more improved results. Indeed,\nthis approach for BNs has been thoroughly investigated with many insightful results [32, 33,\n34]. For example, it has been shown that if the IG of aBN has negative cycles but these\ncycles are isolated by positive cycles, then the BN behaves as in the absence of negative\ncycles, i.e., it has at least one fixed point [32]. Adapting these results for BNs to LPs seems\nto be promising as we are not aware of any similar studies in LPs. However, this direction is\nnon-trivial because the mix between positive and negative cycles might hinder the techniques\nthat we propose in this paper. Other techniques, maybe still being under the umbrella of\nthe connection between LPs and BNs, might be needed."}, {"title": "5 Conclusion and Future Work", "content": "Static analysis of ASP is important and has been proved very useful in both theory and\npractice of ASP. In this work, we for the first time bridged between ASP and BNs, and\nused this connection to study the static analysis of ASP at that depth. Specifically, we\nstated and proved several relations between positive and negative cycles in the DG of an\nLP and its stable models. The most important obtained results include 1) the existence\nand the non-existence of some stable model under the non-existence of negative cycles and\nthe non-existence of positive cycles, respectively, 2) an upper bound of the number of stable\nmodels based on PFVSs, and 3) the connection and techniques we established, which provide\na powerful and unified framework for exploring and proving more new theoretical results in\nASP. In particular, we also demonstrated that the obtained results have the potential to be\nuseful for solving two important problems in the field of ASP.\nIn the future, on the one hand, we shall explore more theoretical results following up the\napproach we established in this paper. First, we shall continue to discover more results by\nconsidering how a structural property of the DG of an LP transforms in its least fixpoint.\nSecond, we plan to investigate how the interplay between positive and negative cycles of\nthe DG affects the set of stable models. Third, we shall generalize the obtained results for\ndisjunctive logic programs, extended logic programs (i.e., containing strong negations), or\nlogic programs with aggregates, constraints, and choice rules. On the other hand, we plan to\ninvestigate thoroughly the applications of the obtained results. First, we shall implement the\nproposed approach for stable model computation discussed in the previous section. Then,\nwe need to thoroughly test the efficiency of this approach on a large set of real-world prob-\nlem instances, maybe obtained from the ASP competitions. Second, we shall develop new\nmethods for program correction that rely on the removal of positive and negative cycles, and\nthen thoroughly test their efficiency."}]}